<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4774 - in rl/trunk/editors/Lockenwickler/src: . media
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4774%20-%20in%20rl/trunk/editors/Lockenwickler/src%3A%20.%20media&In-Reply-To=%3C200902241718.n1OHISu2005780%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001830.html">
   <LINK REL="Next"  HREF="001832.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4774 - in rl/trunk/editors/Lockenwickler/src: . media</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4774%20-%20in%20rl/trunk/editors/Lockenwickler/src%3A%20.%20media&In-Reply-To=%3C200902241718.n1OHISu2005780%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4774 - in rl/trunk/editors/Lockenwickler/src: . media">fusion2 at mail.berlios.de
       </A><BR>
    <I>Tue Feb 24 18:18:28 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001830.html">[Dsa-hl-svn] r4773 - content/textures
</A></li>
        <LI>Next message: <A HREF="001832.html">[Dsa-hl-svn] r4775 - in rl/trunk/editors/Lockenwickler/src: . media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1831">[ date ]</a>
              <a href="thread.html#1831">[ thread ]</a>
              <a href="subject.html#1831">[ subject ]</a>
              <a href="author.html#1831">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2009-02-24 18:18:15 +0100 (Tue, 24 Feb 2009)
New Revision: 4774

Added:
   rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
   rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl
Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
Log:
- fixes for Linux

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,462 +1,468 @@
- #################################################
- #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from ModuleExplorer import *
-from NewModuleWizard import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage(&quot;Starting...&quot;)
-#        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
-        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
-            self.prefDialog.show()
-
-        self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        
-        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
-        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName(&quot;MainWindow&quot;)
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName(&quot;menubar&quot;)
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(&quot;menuFile&quot;)
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName(&quot;menuView&quot;)
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName(&quot;statusbar&quot;)
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
-        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
-
-        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
-        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
-        
-        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filenew.png&quot;,  &quot;Save Module&quot;)
-        self.actionSave.setObjectName(&quot;actionSave&quot;)
-
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionQuit&quot;)
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
-        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
-
-        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
-        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
-
-        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
-        self.actionCut.setObjectName(&quot;actionCut&quot;)
-
-        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
-        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
-
-        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
-        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
-
-        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
-        self.actionMove.setObjectName(&quot;actionMove&quot;)
-
-        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
-        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
-        
-        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
-        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
-
-        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
-        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
-
-        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
-        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
-        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
-        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
-        if platform.system() == &quot;Windows&quot;:
-            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
-        else:
-            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = &quot;&quot;
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-        self.moduleManager.pivot.hide()
-        self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
-        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
-        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
-        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
-        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
-        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
-        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
-        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print&quot;&quot;
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == &quot;__main__&quot;:
-#    # Import Psyco if available
-#    try:
-##        import psyco
-##        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName(&quot;Team Pantheon&quot;)
-    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
-    app.setApplicationName(&quot;Lockenwickler&quot;)
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+ #################################################
+ #################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from ModuleExplorer import *
+from NewModuleWizard import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage(&quot;Starting...&quot;)
+#        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
+        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        
+        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
+        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName(&quot;MainWindow&quot;)
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName(&quot;menubar&quot;)
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName(&quot;menuFile&quot;)
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName(&quot;menuView&quot;)
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName(&quot;statusbar&quot;)
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
+        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
+
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
+        
+        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filenew.png&quot;,  &quot;Save Module&quot;)
+        self.actionSave.setObjectName(&quot;actionSave&quot;)
+
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
+
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
+        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
+        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
+
+        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
+        self.actionMove.setObjectName(&quot;actionMove&quot;)
+
+        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
+        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
+        
+        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
+        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
+
+        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
+        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
+
+        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
+        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
+        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
+        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
+        if platform.system() == &quot;Windows&quot;:
+            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
+        else:
+            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = &quot;&quot;
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == &quot;Linux&quot;:
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
+        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
+        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
+        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
+        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
+        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
+        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
+        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print&quot;&quot;
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == &quot;__main__&quot;:
+#    # Import Psyco if available
+#    try:
+##        import psyco
+##        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName(&quot;Team Pantheon&quot;)
+    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
+    app.setApplicationName(&quot;Lockenwickler&quot;)
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,179 +1,181 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream &lt;&lt; self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData(&quot;application/x-static_model&quot;, data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName(&quot;modelPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName(&quot;splitter&quot;)
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
-        
-        
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-    def ogreViewportCreatedCallback(self):
-        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(&quot;.mesh&quot;):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() &lt; 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-static_model&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName(&quot;modelPreviewDialog&quot;)
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName(&quot;splitter&quot;)
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName(&quot;listWidget&quot;)
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
+                                                         self.splitter)
+        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(&quot;.mesh&quot;):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() &lt; 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreModelPrevWindow.update()

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,862 +1,861 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-
-
-#                &lt;zone name=&quot;Testzone&quot;&gt;
-#                        &lt;area type=&quot;sphere&quot;&gt;
-#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
-#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
-#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
-#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
-#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
-#                        &lt;/area&gt;
-#                        &lt;light name=&quot;red pointlight&quot;/&gt;
-#                        &lt;light name=&quot;green spotlight&quot;/&gt;
-#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
-#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
-#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
-#                        &lt;/trigger&gt;
-#                &lt;/zone&gt;
-
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = &quot;\n&quot; + level*&quot;  &quot;
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + &quot;  &quot;
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
-        mapName = mapName.split(&quot;/&quot;)
-        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
-                self.parseMapNodes(root.find(&quot;nodes&quot;))
-                #self.parseMapZones(root.find(&quot;zones&quot;))
-            else:
-                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
-                return
-
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator(&quot;entity&quot;)
-        
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator(&quot;light&quot;)
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator(&quot;sound&quot;)
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
-        self.createGameObjects(nodes)
-
-        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib[&quot;name&quot;]
-            meshFile = nodes.attrib[&quot;meshfile&quot;]
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    posx = float(t.attrib[&quot;x&quot;])
-                    posy = float(t.attrib[&quot;y&quot;])
-                    posz = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                elif t.tag == &quot;scale&quot;:
-                    scalex = float(t.attrib[&quot;x&quot;])
-                    scaley = float(t.attrib[&quot;y&quot;])
-                    scalez = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                continue
-
-            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib[&quot;name&quot;]
-            lightType = l.attrib[&quot;type&quot;]
-            lightVisible = bool(l.attrib[&quot;visible&quot;])
-            castShadows = bool(l.attrib[&quot;castShadows&quot;])
-            lightPosition = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;colourDiffuse&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == &quot;colourSpecular&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == &quot;lightAttenuation&quot;:
-                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
-                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
-                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
-                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
-            
-
-            light = self.sceneManager.createLight(lightName)
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
-            
-            if lightType == &quot;point&quot;:
-                light.setType(og.Light.LT_POINT)
-            
-            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib[&quot;class&quot;]
-            id = int(g.attrib[&quot;id&quot;])
-            state = g.attrib[&quot;state&quot;]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == &quot;scale&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(x, y, z)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
-                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                go.inWorldId = id
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element(&quot;rastullahmap&quot;)
-        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
-        
-        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
-        
-        iter = self.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            name = iter.getNext().getName()
-            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib[&quot;name&quot;]
-        
-            maps = root.getiterator(&quot;map&quot;)
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
-        
-    def save(self):
-        root = xml.Element(&quot;scene&quot;)
-        root.attrib[&quot;name&quot;] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, &quot;map&quot;)
-            sub.attrib[&quot;file&quot;] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print &quot;ERROR: could not find scene: &quot; + sceneName
-        
-    
-    def isCommon(self):
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Error: couldn't find module config&quot;)
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;super(&quot;):
-                split = lStripped.split(&quot;,&quot;)
-                if split[2].strip() == unicode(&quot;true&quot;):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == &quot;end&quot;:
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
-
-            elif lStripped == &quot;def getDependencies()&quot;:
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Error: couldn't find module config&quot;)
-            return
-
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-            
-        
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-
-    def setResourcePaths(self, recurseFolder = &quot;&quot;):
-        if recurseFolder == &quot;&quot;:
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
-                self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-                            
-class ModuleManager():
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-
-        self.moduleCfgPath = &quot;&quot;
-
-        self.gocManager = GameObjectClassManager()
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.propertyWindow = None
-    
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
-        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-#        e.setMaterialName(&quot;PlainColor&quot;)
-#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-#
-#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
-#        e2.setMaterialName(&quot;PlainColor&quot;)
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-#        
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        if self.currentMap is None:
-            QMessageBox.warning(None, &quot;Don't forget to select a map&quot;, &quot;You won't be happy without a map!&quot;)
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
-
-            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = &quot;&quot;
-        split = name.split(&quot;_&quot;)
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + &quot;_1&quot;
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
-                        newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity, so.distance)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        self.dropCount += 1
-            else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
-
-                newSO = SelectionObject(newEntity, so.distance)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) &lt; 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print &quot;sd&quot;
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+
+
+#                &lt;zone name=&quot;Testzone&quot;&gt;
+#                        &lt;area type=&quot;sphere&quot;&gt;
+#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
+#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
+#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
+#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
+#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
+#                        &lt;/area&gt;
+#                        &lt;light name=&quot;red pointlight&quot;/&gt;
+#                        &lt;light name=&quot;green spotlight&quot;/&gt;
+#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
+#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
+#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
+#                        &lt;/trigger&gt;
+#                &lt;/zone&gt;
+
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = &quot;\n&quot; + level*&quot;  &quot;
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + &quot;  &quot;
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
+        mapName = mapName.split(&quot;/&quot;)
+        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
+                self.parseMapNodes(root.find(&quot;nodes&quot;))
+                #self.parseMapZones(root.find(&quot;zones&quot;))
+            else:
+                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
+                return
+
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;entity&quot;)
+        
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator(&quot;light&quot;)
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator(&quot;sound&quot;)
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib[&quot;name&quot;]
+            meshFile = nodes.attrib[&quot;meshfile&quot;]
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    posx = float(t.attrib[&quot;x&quot;])
+                    posy = float(t.attrib[&quot;y&quot;])
+                    posz = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                elif t.tag == &quot;scale&quot;:
+                    scalex = float(t.attrib[&quot;x&quot;])
+                    scaley = float(t.attrib[&quot;y&quot;])
+                    scalez = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
+                continue
+
+            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib[&quot;name&quot;]
+            lightType = l.attrib[&quot;type&quot;]
+            lightVisible = bool(l.attrib[&quot;visible&quot;])
+            castShadows = bool(l.attrib[&quot;castShadows&quot;])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;colourDiffuse&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == &quot;colourSpecular&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == &quot;lightAttenuation&quot;:
+                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
+                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
+                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
+                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
+            
+
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == &quot;point&quot;:
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.attachObject(light)
+            n.setPosition(lightPosition)
+
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib[&quot;class&quot;]
+            id = int(g.attrib[&quot;id&quot;])
+            state = g.attrib[&quot;state&quot;]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == &quot;scale&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
+                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element(&quot;rastullahmap&quot;)
+        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
+        
+        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
+        
+        iter = self.mapNode.getChildIterator()
+        while iter.hasMoreElements():
+            name = iter.getNext().getName()
+            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib[&quot;name&quot;]
+        
+            maps = root.getiterator(&quot;map&quot;)
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element(&quot;scene&quot;)
+        root.attrib[&quot;name&quot;] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, &quot;map&quot;)
+            sub.attrib[&quot;file&quot;] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print &quot;ERROR: could not find scene: &quot; + sceneName
+        
+    
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;super(&quot;):
+                split = lStripped.split(&quot;,&quot;)
+                if split[2].strip() == unicode(&quot;true&quot;):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == &quot;end&quot;:
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
+
+            elif lStripped == &quot;def getDependencies()&quot;:
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.load: Error: couldn't find module config&quot;)
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+            
+        
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+
+    def setResourcePaths(self, recurseFolder = &quot;&quot;):
+        if recurseFolder == &quot;&quot;:
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
+        self.moduleCfgPath = &quot;&quot;
+
+        self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.propertyWindow = None
+    
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
+        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+        self.moduleExplorer.updateView()
+#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
+#        e.setMaterialName(&quot;PlainColor&quot;)
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
+#
+#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
+#        e2.setMaterialName(&quot;PlainColor&quot;)
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
+#        n.attachObject(e)
+#        n.attachObject(e2)
+#        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, &quot;Don't forget to select a map&quot;, &quot;You won't be happy without a map!&quot;)
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+
+            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = &quot;&quot;
+        split = name.split(&quot;_&quot;)
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + &quot;_1&quot;
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) &lt; 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print &quot;sd&quot;
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+
+        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,146 +1,147 @@
-# -*- coding: utf-8 -*-
-
-&quot;&quot;&quot;
-Module implementing NewModuleWizard.
-&quot;&quot;&quot;
-
-import os
-import glob
-
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
-
-from Ui_NewModuleWizard import Ui_Dialog
-
-class NewModuleWizard(QDialog, Ui_Dialog):
-    &quot;&quot;&quot;
-    Class documentation goes here.
-    &quot;&quot;&quot;
-    def __init__(self, moduleManager, parent = None):
-       
-        QDialog.__init__(self, parent)
-        self.setupUi(self)
-
-        self.moduleManager = moduleManager
-        self.moduleManager.parseModuleConfig()
-        
-        for m in self.moduleManager.moduleList:
-            self.moduleDependenciesList.addItem(m.name)
-
-    @pyqtSignature(&quot;QString&quot;)
-    def on_moduleNameLineEdit_textChanged(self, p0):
-        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
-            self.sceneNameLineEdit.setEnabled(True)
-            self.mapNameLineEdit.setEnabled(True)
-            self.moduleDependenciesList.setEnabled(True)
-            self.scriptDependenciesList.setEnabled(True)
-            self.okButton.setEnabled(True)
-        else:
-            self.sceneNameLineEdit.setEnabled(False)
-            self.mapNameLineEdit.setEnabled(False)
-            self.moduleDependenciesList.setEnabled(False)
-            self.scriptDependenciesList.setEnabled(False)
-            self.okButton.setEnabled(False)
-    
-    def scanDirForScripts(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                self.scanDirForScripts(curFile)
-                continue
-            if os.path.isfile(curFile):
-                if file.endswith(&quot;.rb&quot;):
-                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
-    
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleDependenciesList_itemSelectionChanged(self):
-        self.scriptDependenciesList.clear()
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        
-        for m in self.moduleDependenciesList.selectedItems():
-            path = os.path.join(modulePath, str(m.text()))
-            cmd = os.path.join(path + &quot;/scripts&quot;)
-            self.scanDirForScripts(cmd)
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleNameLineEdit_returnPressed(self):
-        return
-            
-    @pyqtSignature(&quot;&quot;)
-    def on_mapNameLineEdit_returnPressed(self):
-        return
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_okButton_clicked(self):
-        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
-        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
-        f.close()
-        
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        modulePath = str(modulePath + self.moduleNameLineEdit.text())
-        os.mkdir(modulePath)
-        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
-        
-        mname = str(self.moduleNameLineEdit.text())
-        mdeps = &quot;&quot;
-        for m in self.moduleDependenciesList.selectedItems():
-            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
-        mdeps = mdeps.strip(&quot;, &quot;)
-        
-        sdeps = &quot;&quot;
-        for s in self.scriptDependenciesList.selectedItems():
-            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
-            script = script.split(&quot;/&quot;)
-            script = script[len(script) - 1]
-            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
-        
-        
-        f = open(os.path.join(modulePath, &quot;scripts\\&quot;) + &quot;moduleconfig.rb&quot;, &quot;w&quot;)
-        f.write(&quot;include RlScript\n&quot;)
-        f.write(&quot;\n\n&quot;)
-        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
-        f.write(&quot;    def initialize()\n&quot;)
-        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getDependencies()\n&quot;)
-        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getTextureLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getModelLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getSoundLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def start()\n&quot;)
-        f.write(sdeps)
-        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
-        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
-        f.write(&quot;    end\n&quot;)
-        f.write(&quot;end\n\n&quot;)
-
-        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
-        
-        self.moduleManager.resetParsedModuleConfig()
-        self.moduleManager.openLoadModuleDialog()
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_cancelButton_pressed(self):
-        self.close()
-
-
+# -*- coding: utf-8 -*-
+
+&quot;&quot;&quot;
+Module implementing NewModuleWizard.
+&quot;&quot;&quot;
+
+import os
+import glob
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    &quot;&quot;&quot;
+    Class documentation goes here.
+    &quot;&quot;&quot;
+    def __init__(self, moduleManager, parent = None):
+       
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+        self.moduleManager = moduleManager
+        self.moduleManager.parseModuleConfig()
+        
+        for m in self.moduleManager.moduleList:
+            self.moduleDependenciesList.addItem(m.name)
+
+    @pyqtSignature(&quot;QString&quot;)
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
+            self.sceneNameLineEdit.setEnabled(True)
+            self.mapNameLineEdit.setEnabled(True)
+            self.moduleDependenciesList.setEnabled(True)
+            self.scriptDependenciesList.setEnabled(True)
+            self.okButton.setEnabled(True)
+        else:
+            self.sceneNameLineEdit.setEnabled(False)
+            self.mapNameLineEdit.setEnabled(False)
+            self.moduleDependenciesList.setEnabled(False)
+            self.scriptDependenciesList.setEnabled(False)
+            self.okButton.setEnabled(False)
+    
+    def scanDirForScripts(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                self.scanDirForScripts(curFile)
+                continue
+            if os.path.isfile(curFile):
+                if file.endswith(&quot;.rb&quot;):
+                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
+    
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleDependenciesList_itemSelectionChanged(self):
+        self.scriptDependenciesList.clear()
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        
+        for m in self.moduleDependenciesList.selectedItems():
+            path = os.path.join(modulePath, str(m.text()))
+            cmd = os.path.join(path + &quot;/scripts&quot;)
+            self.scanDirForScripts(cmd)
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleNameLineEdit_returnPressed(self):
+        return
+            
+    @pyqtSignature(&quot;&quot;)
+    def on_mapNameLineEdit_returnPressed(self):
+        return
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_okButton_clicked(self):
+        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
+        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
+        f.close()
+        
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        modulePath = str(modulePath + self.moduleNameLineEdit.text())
+        os.mkdir(modulePath)
+        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
+        
+        mname = str(self.moduleNameLineEdit.text())
+        mdeps = &quot;&quot;
+        for m in self.moduleDependenciesList.selectedItems():
+            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
+        mdeps = mdeps.strip(&quot;, &quot;)
+        
+        sdeps = &quot;&quot;
+        for s in self.scriptDependenciesList.selectedItems():
+            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
+            script = script.split(&quot;/&quot;)
+            script = script[len(script) - 1]
+            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
+        
+        p = os.path.join(modulePath, &quot;scripts&quot;)
+        p = os.path.join(p, &quot;moduleconfig.rb&quot;)
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;include RlScript\n&quot;)
+        f.write(&quot;\n\n&quot;)
+        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
+        f.write(&quot;    def initialize()\n&quot;)
+        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getDependencies()\n&quot;)
+        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getTextureLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getModelLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getSoundLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def start()\n&quot;)
+        f.write(sdeps)
+        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
+        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
+        f.write(&quot;    end\n&quot;)
+        f.write(&quot;end\n\n&quot;)
+
+        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
+        
+        self.moduleManager.resetParsedModuleConfig()
+        self.moduleManager.openLoadModuleDialog()
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,329 +1,331 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName(&quot;splitter&quot;)
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print &quot;dbg: DragLeave&quot;
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            data = event.mimeData().data(&quot;application/x-static_model&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            data = event.mimeData().data(&quot;application/x-game_object&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        if self.moduleManager.pivot:
-            self.moduleManager.pivot.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName(&quot;Form&quot;)
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName(&quot;splitter&quot;)
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print &quot;dbg: DragLeave&quot;
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            data = event.mimeData().data(&quot;application/x-static_model&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            data = event.mimeData().data(&quot;application/x-game_object&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,154 +1,162 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.cameraName = cameraName
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-        self.renderWindow = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(self.cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-
-    def resizeEvent(self, event):
-        if self.renderWindow:
-            self.renderWindow.resize(event.size().width(), event.size().height())
-            self.renderWindow.windowMovedOrResized()
-
-            if platform.system() == &quot;Linux&quot;:
-                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-            self.renderWindow.update(True)
-            self.ogreRoot.renderOneFrame()
-
-            if self.camera:
-                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-                
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z &lt; self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3&amp; trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+        
+        win = str(int(self.winId()))
+        self.renderParameters['parentWindowHandle'] = win
+
+#        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
+#            hwnd = int(self.winId())
+#            self.renderParameters['externalWindowHandle'] = str(hwnd)
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+
+            if platform.system() == &quot;Linux&quot;:
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z &lt; self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3&amp; trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -40,7 +40,9 @@
         layout.addWidget(self.modulConfigSelector, 1, 1)
 
         self.setLayout(layout)
-
+        
+        self.moduleCfgPath = None
+        
         QObject.connect(self.modulConfigSelector, SIGNAL(&quot;clicked()&quot;),
                                self.openModulConfigSelector)
 
@@ -70,7 +72,6 @@
             self.lineEdit.setText(self.moduleCfgPath)
 
 
-
     def onLoadSelectedModule(self):
         item = self.prefDialog.listWidget.currentItem()
 

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,244 +1,244 @@
-import ctypes as ctypes
-import random
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-        
-        self.lastEntity = &quot;&quot;
-        self.lastTechnique = None
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-        temp = str(type(subEntity))
-        if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                return self.lastTechnique
-            else:
-                self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-                
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + &quot; &quot; + str(int(255 * self.currentColor.g)) + &quot; &quot; + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = &quot;&quot;
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera(&quot;MainCam&quot;)
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
-        
-        #self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i &lt; len(self.buffer):
-#            #print str(self.buffer[i + 2]) + &quot; &quot; + str(self.buffer[i+1]) + &quot; &quot; + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload(&quot;SelectionPassTex&quot;)
-            
-            self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == &quot;OgreMainWin::0::ViewportGrid&quot;:
-                    return None
-                elif key == &quot;rayLine&quot;:
-                    return None
-                elif key == &quot;EditorXArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorYArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorZArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorFreeMover&quot;:
-                    return None
-                elif key == &quot;EditorXRotator&quot; or key == &quot;EditorYRotator&quot; or key == &quot;EditorZRotator&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName(&quot;Lockenwickler_Pivot_X&quot;)
-        SelectionBufferTexture = baseWhite.clone(&quot;SelectionDebugMaterial&quot;)
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName(&quot;SelectionPassTex&quot;)
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create(&quot;OverlayName&quot;)
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement(&quot;Panel&quot;, &quot;PanelName0&quot;)
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName(&quot;SelectionDebugMaterial&quot;) 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
+        self.lastEntity = &quot;&quot;
+        self.lastTechnique = None
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColorGLSL&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getBestTechnique()
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + &quot; &quot; + str(int(255 * self.currentColor.g)) + &quot; &quot; + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = &quot;&quot;
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera(&quot;MainCam&quot;)
+
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
+        
+        #self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i &lt; len(self.buffer):
+#            #print str(self.buffer[i + 2]) + &quot; &quot; + str(self.buffer[i+1]) + &quot; &quot; + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload(&quot;SelectionPassTex&quot;)
+            
+            self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == &quot;OgreMainWin::0::ViewportGrid&quot;:
+                    return None
+                elif key == &quot;rayLine&quot;:
+                    return None
+                elif key == &quot;EditorXArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorYArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorZArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorFreeMover&quot;:
+                    return None
+                elif key == &quot;EditorXRotator&quot; or key == &quot;EditorYRotator&quot; or key == &quot;EditorZRotator&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName(&quot;Lockenwickler_Pivot_X&quot;)
+        SelectionBufferTexture = baseWhite.clone(&quot;SelectionDebugMaterial&quot;)
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName(&quot;SelectionPassTex&quot;)
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create(&quot;OverlayName&quot;)
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement(&quot;Panel&quot;, &quot;PanelName0&quot;)
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName(&quot;SelectionDebugMaterial&quot;) 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 17:18:15 UTC (rev 4774)
@@ -141,3 +141,26 @@
 		}
 	}
 }
+
+fragment_program PlainColorGLSL_FP glsl
+{
+	source PlainColorFP.glsl
+	
+	default_params
+	{
+	      param_named_auto inColor custom 1
+	}
+}
+
+material PlainColorGLSL glsl
+{
+	technique
+	{
+		pass
+		{
+			fragment_program_ref PlainColorGLSL_FP
+			{
+			}
+		}
+	}
+}

Modified: rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-24 17:18:15 UTC (rev 4774)
@@ -25,8 +25,5 @@
 		uniform float4 inColor
 		)
 {	 
-	// Just sample texture using supplied UV
-	//color = float4(0, 1, 0, 1);
-	//color = float4(inColor.r, inColor.g, inColor.b, 1);
 	color = inColor;
 }

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 17:18:15 UTC (rev 4774)
@@ -0,0 +1,7 @@
+uniform vec4 inColor;
+
+void main(void)
+{
+	gl_FragColor = inColor;
+	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+}
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-02-24 17:18:15 UTC (rev 4774)
@@ -0,0 +1,6 @@
+void main()
+{
+	gl_Position = ftransform();
+}
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001830.html">[Dsa-hl-svn] r4773 - content/textures
</A></li>
	<LI>Next message: <A HREF="001832.html">[Dsa-hl-svn] r4775 - in rl/trunk/editors/Lockenwickler/src: . media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1831">[ date ]</a>
              <a href="thread.html#1831">[ thread ]</a>
              <a href="subject.html#1831">[ subject ]</a>
              <a href="author.html#1831">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
