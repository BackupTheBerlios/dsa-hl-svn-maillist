<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4770 - in rl/trunk/editors/Lockenwickler: .	_eric4project src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4770%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%0A%09_eric4project%20src&In-Reply-To=%3C200902172041.n1HKfBtn031071%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001826.html">
   <LINK REL="Next"  HREF="001828.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4770 - in rl/trunk/editors/Lockenwickler: .	_eric4project src</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4770%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%0A%09_eric4project%20src&In-Reply-To=%3C200902172041.n1HKfBtn031071%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4770 - in rl/trunk/editors/Lockenwickler: .	_eric4project src">fusion2 at mail.berlios.de
       </A><BR>
    <I>Tue Feb 17 21:41:11 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001826.html">[Dsa-hl-svn] r4769 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
        <LI>Next message: <A HREF="001828.html">[Dsa-hl-svn] r4771 - rl/trunk/engine/script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1827">[ date ]</a>
              <a href="thread.html#1827">[ thread ]</a>
              <a href="subject.html#1827">[ subject ]</a>
              <a href="author.html#1827">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2009-02-17 21:41:04 +0100 (Tue, 17 Feb 2009)
New Revision: 4770

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
Log:
- more fixes for Linux

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,180 +1,180 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
-&lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-15, 13:32:17 --&gt;
-&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
-&lt;Project version=&quot;4.6&quot;&gt;
-  &lt;Language&gt;en&lt;/Language&gt;
-  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
-  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
-  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
-  &lt;Version&gt;0.1&lt;/Version&gt;
-  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
-  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
-  &lt;Sources&gt;
-    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
-    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
-    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/Property.py&lt;/Source&gt;
-    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/setup.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
-    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
-    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
-    &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
-    &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
-  &lt;/Sources&gt;
-  &lt;Forms&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
-  &lt;/Forms&gt;
-  &lt;Translations&gt;
-  &lt;/Translations&gt;
-  &lt;Resources&gt;
-  &lt;/Resources&gt;
-  &lt;Interfaces&gt;
-  &lt;/Interfaces&gt;
-  &lt;Others&gt;
-  &lt;/Others&gt;
-  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
-  &lt;Vcs&gt;
-    &lt;VcsType&gt;Subversion&lt;/VcsType&gt;
-    &lt;VcsOptions&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;add&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;checkout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;commit&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;diff&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;export&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;global&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;history&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;log&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;remove&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;status&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;tag&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;update&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOptions&gt;
-    &lt;VcsOtherData&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;standardLayout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;bool&gt;True&lt;/bool&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOtherData&gt;
-  &lt;/Vcs&gt;
-  &lt;FiletypeAssociations&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
-  &lt;/FiletypeAssociations&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
+&lt;!-- eric4 project file for project Lockenwickler --&gt;
+&lt;!-- Saved: 2009-02-17, 21:39:20 --&gt;
+&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
+&lt;Project version=&quot;4.6&quot;&gt;
+  &lt;Language&gt;en&lt;/Language&gt;
+  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
+  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
+  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
+  &lt;Version&gt;0.1&lt;/Version&gt;
+  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
+  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
+  &lt;Sources&gt;
+    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
+    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
+    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
+    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/Property.py&lt;/Source&gt;
+    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/setup.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
+    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
+    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
+    &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
+  &lt;/Sources&gt;
+  &lt;Forms&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
+  &lt;/Forms&gt;
+  &lt;Translations&gt;
+  &lt;/Translations&gt;
+  &lt;Resources&gt;
+  &lt;/Resources&gt;
+  &lt;Interfaces&gt;
+  &lt;/Interfaces&gt;
+  &lt;Others&gt;
+  &lt;/Others&gt;
+  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
+  &lt;Vcs&gt;
+    &lt;VcsType&gt;None&lt;/VcsType&gt;
+    &lt;VcsOptions&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;add&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;checkout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;commit&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;diff&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;export&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;global&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;history&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;log&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;remove&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;status&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;tag&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;update&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOptions&gt;
+    &lt;VcsOtherData&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;standardLayout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;bool&gt;True&lt;/bool&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOtherData&gt;
+  &lt;/Vcs&gt;
+  &lt;FiletypeAssociations&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
+  &lt;/FiletypeAssociations&gt;
 &lt;/Project&gt;
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE UserProject SYSTEM &quot;UserProject-4.0.dtd&quot;&gt;
 &lt;!-- eric4 user project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-10, 21:36:41 --&gt;
+&lt;!-- Saved: 2009-02-17, 21:39:20 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;UserProject version=&quot;4.0&quot;&gt;
 &lt;/UserProject&gt;
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Tasks SYSTEM &quot;Tasks-4.2.dtd&quot;&gt;
 &lt;!-- eric4 tasks file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-10, 21:36:41 --&gt;
+&lt;!-- Saved: 2009-02-17, 21:39:20 --&gt;
 &lt;Tasks version=&quot;4.2&quot;&gt;
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: not implemented yet&lt;/Summary&gt;
@@ -24,10 +24,10 @@
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: implement save here&lt;/Summary&gt;
     &lt;Description&gt;&lt;/Description&gt;
-    &lt;Created&gt;2009-02-10, 12:40:21&lt;/Created&gt;
+    &lt;Created&gt;2009-02-17, 21:38:59&lt;/Created&gt;
     &lt;Resource&gt;
       &lt;Filename&gt;src/Lockenwickler.py&lt;/Filename&gt;
-      &lt;Linenumber&gt;426&lt;/Linenumber&gt;
+      &lt;Linenumber&gt;431&lt;/Linenumber&gt;
     &lt;/Resource&gt;
   &lt;/Task&gt;
 &lt;/Tasks&gt;
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -82,7 +82,9 @@
         
         self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
         self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-
+        
+        self.editorSetupFinished = False
+        
 #        splash.finish(self)
 
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
@@ -271,19 +273,22 @@
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
         
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
         og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
         self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
         self.moduleManager.pivot.hide()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
+        self.editorSetupFinished = True
+        
     def update(self):
         self.ogreRoot.renderOneFrame()
 
     def actionOpenSlot(self):
+        self.finishEditorSetup()
         self.moduleManager.openLoadModuleDialog()
 
     def actionNewSlot(self):

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -92,15 +92,18 @@
         self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
         self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
                                                          self.splitter)
-        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
         
+        
         self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
         self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
 
-
+    def ogreViewportCreatedCallback(self):
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
     def retranslateUi(self):
         self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
 

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,328 +1,329 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName(&quot;splitter&quot;)
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print &quot;dbg: DragLeave&quot;
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            data = event.mimeData().data(&quot;application/x-static_model&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            data = event.mimeData().data(&quot;application/x-game_object&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        self.moduleManager.pivot.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName(&quot;Form&quot;)
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName(&quot;splitter&quot;)
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print &quot;dbg: DragLeave&quot;
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            data = event.mimeData().data(&quot;application/x-static_model&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            data = event.mimeData().data(&quot;application/x-game_object&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,151 +1,154 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-
-    def resizeEvent(self, event):
-        self.renderWindow.resize(event.size().width(), event.size().height())
-        self.renderWindow.windowMovedOrResized()
-
-        if platform.system() == &quot;Linux&quot;:
-            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-        self.renderWindow.update(True)
-        self.ogreRoot.renderOneFrame()
-
-        if self.camera:
-            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-            
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z &lt; self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3&amp; trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+
+        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            import sip
+            info = self.x11Info()
+            disp =  str(sip.unwrapinstance(info.display()))
+            scr = str(info.screen())
+            win = str(int(self.winId()))
+            winHandle = disp + ':' + scr + ':' + win
+            
+            self.renderParameters['parentWindowHandle'] = winHandle
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+
+            if platform.system() == &quot;Linux&quot;:
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z &lt; self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3&amp; trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001826.html">[Dsa-hl-svn] r4769 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
	<LI>Next message: <A HREF="001828.html">[Dsa-hl-svn] r4771 - rl/trunk/engine/script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1827">[ date ]</a>
              <a href="thread.html#1827">[ thread ]</a>
              <a href="subject.html#1827">[ subject ]</a>
              <a href="author.html#1827">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
