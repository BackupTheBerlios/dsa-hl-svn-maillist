<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4741 - in rl/trunk/editors/Lockenwickler: .	_eric4project src src/media
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4741%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%0A%09_eric4project%20src%20src/media&In-Reply-To=%3C200902071913.n17JD3Gq008974%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001797.html">
   <LINK REL="Next"  HREF="001799.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4741 - in rl/trunk/editors/Lockenwickler: .	_eric4project src src/media</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4741%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%0A%09_eric4project%20src%20src/media&In-Reply-To=%3C200902071913.n17JD3Gq008974%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4741 - in rl/trunk/editors/Lockenwickler: .	_eric4project src src/media">fusion2 at mail.berlios.de
       </A><BR>
    <I>Sat Feb  7 20:13:03 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001797.html">[Dsa-hl-svn] r4740 - in rl/branches/persistence2/engine: core	core/src script
</A></li>
        <LI>Next message: <A HREF="001799.html">[Dsa-hl-svn] r4742 - in	rl/branches/persistence2/editors/Lockenwickler: .	_eric4project src src/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1798">[ date ]</a>
              <a href="thread.html#1798">[ thread ]</a>
              <a href="subject.html#1798">[ subject ]</a>
              <a href="author.html#1798">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2009-02-07 20:12:52 +0100 (Sat, 07 Feb 2009)
New Revision: 4741

Added:
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/media/
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
Log:
- work on the selection buffer began

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
+&lt;!-- Saved: 2009-02-07, 20:03:18 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.6&quot;&gt;
   &lt;Language&gt;en&lt;/Language&gt;
@@ -37,6 +37,7 @@
     &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
     &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
     &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
+    &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE UserProject SYSTEM &quot;UserProject-4.0.dtd&quot;&gt;
 &lt;!-- eric4 user project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
+&lt;!-- Saved: 2009-02-07, 20:03:18 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;UserProject version=&quot;4.0&quot;&gt;
 &lt;/UserProject&gt;
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,12 +1,12 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Tasks SYSTEM &quot;Tasks-4.2.dtd&quot;&gt;
 &lt;!-- eric4 tasks file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
+&lt;!-- Saved: 2009-02-07, 20:03:18 --&gt;
 &lt;Tasks version=&quot;4.2&quot;&gt;
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: implement save here&lt;/Summary&gt;
     &lt;Description&gt;&lt;/Description&gt;
-    &lt;Created&gt;2009-01-26, 17:23:59&lt;/Created&gt;
+    &lt;Created&gt;2009-02-07, 17:52:11&lt;/Created&gt;
     &lt;Resource&gt;
       &lt;Filename&gt;src/Lockenwickler.py&lt;/Filename&gt;
       &lt;Linenumber&gt;416&lt;/Linenumber&gt;


Property changes on: rl/trunk/editors/Lockenwickler/src
___________________________________________________________________
Name: svn:ignore
   - ogre.cfg

   + ogre.cfg
SelectionBuffer - Kopie.py


Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -260,11 +260,11 @@
         self.moduleName = &quot;&quot;
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
-
+        
         og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
@@ -298,7 +298,7 @@
         self.moduleManager.cutObjects()
 
     def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
 
     def actionSelectSlot(self):
         self.moduleManager.pivot.hide()
@@ -397,11 +397,11 @@
 
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
+            self.ogreMainWindow.keyPressEvent(event)
 
     def keyReleaseEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
+            self.ogreMainWindow.keyReleaseEvent(event)
         pass
 
     def connectActionButtons(self):

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,174 +1,176 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream &lt;&lt; self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData(&quot;application/x-static_model&quot;, data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName(&quot;modelPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName(&quot;splitter&quot;)
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(&quot;.mesh&quot;):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() &lt; 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-static_model&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName(&quot;modelPreviewDialog&quot;)
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName(&quot;splitter&quot;)
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName(&quot;listWidget&quot;)
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
+                                                         self.splitter)
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(&quot;.mesh&quot;):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() &lt; 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -30,6 +30,7 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
@@ -339,7 +340,8 @@
             cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-
+            
+        
     def loadScenes(self, sceneFiles):
         for f in sceneFiles:
             self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
@@ -414,6 +416,8 @@
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
+        self.selectionBuffer = None
+    
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -486,20 +490,27 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-        self.moduleExplorer.updateView()
+#        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-#        e.setMaterialName(&quot;Lockenwickler_Area&quot;)
+#        e.setMaterialName(&quot;PlainColor&quot;)
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
 #
 #        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
-#        e2.setMaterialName(&quot;Lockenwickler_Area&quot;)
-
+#        e2.setMaterialName(&quot;PlainColor&quot;)
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
 #        n.attachObject(e)
 #        n.attachObject(e2)
 #        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
 
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        if self.selectionBuffer is not None:
+            self.selectionBuffer.update()
+            
         self.listenerDings.reset()
         self.lastRay = ray
         self.listenerDings.currentRay = ray

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,317 +1,323 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreRenderWindow = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
-        self.setupUi(self)
-
-
-    def setupUi(self, Form):
-        Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName(&quot;splitter&quot;)
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreRenderWindow.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow.setObjectName(&quot;ogreWidget&quot;)
-        self.splitterV.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreRenderWindow.viewport)
-        self.viewportGrid.enable()
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreRenderWindow.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print &quot;dbg: DragLeave&quot;
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            data = event.mimeData().data(&quot;application/x-static_model&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            data = event.mimeData().data(&quot;application/x-game_object&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        return self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        mouseRay = self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(mouseRay)
-
-
-    def updateCamera(self):
-        if self.moveCamForward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+
+        self.setupUi(self)
+
+
+    def setupUi(self, Form):
+        Form.setObjectName(&quot;Form&quot;)
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName(&quot;splitter&quot;)
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print &quot;dbg: DragLeave&quot;
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            data = event.mimeData().data(&quot;application/x-static_model&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            data = event.mimeData().data(&quot;application/x-game_object&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -93,7 +93,13 @@
     def getCamera(self):
         assert(self.camera)
         return self.camera
-
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
     #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
     def orbitCamera( self, horz, vert):
         #orbit around focus node

Added: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -0,0 +1,160 @@
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = &quot;&quot;
+        self.lastTechnique = None
+        
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+
+                self.lastEntity = subEntity.getParent().getName()
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = &quot;&quot;
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera(&quot;MainCam&quot;)
+
+        self.viewport = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+#        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+#                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+#                                                                    og.TEX_TYPE_2D, 
+#                                                                    self.viewport.getActualWidth(), 
+#                                                                    self.viewport.getActualHeight(), 
+#                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        width = self.viewport.getWidth()
+        height = self.viewport.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
+        
+        self.createRTTOverlays()
+
+    def update(self):
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        buff = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(buff))
+
+        pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+        self.renderTexture.writeContentsToTimestampedFile(&quot;editor&quot;, &quot;.png&quot;)
+        i = 0
+        
+        while i &lt; len(buff):
+            #print str(buff[i + 2]) + &quot; &quot; + str(buff[i+1]) + &quot; &quot; + str(buff[i])
+            
+            i += 4
+        #for a in buff:
+            #print a
+
+        #pBox = pixelBuffer.getCurrentLock()
+        
+        #storageclass = ctypes.c_uint8 * (self.renderTexture.getWidth()*self.renderTexture.getHeight()*3) 
+        
+        
+        #pixelBuffer.unlock()
+        
+
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName(&quot;Lockenwickler_Pivot_X&quot;)
+        SelectionBufferTexture = baseWhite.clone(&quot;SelectionDebugMaterial&quot;)
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName(&quot;SelectionPassTex&quot;)
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create(&quot;OverlayName&quot;)
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement(&quot;Panel&quot;, &quot;PanelName0&quot;)
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName(&quot;SelectionDebugMaterial&quot;) 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+


Property changes on: rl/trunk/editors/Lockenwickler/src/media
___________________________________________________________________
Name: svn:ignore
   - .Bpib
skelett.blend

   + .Bpib
skelett.blend
skelett_merged.blend


Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-07 19:12:52 UTC (rev 4741)
@@ -19,6 +19,8 @@
 
 		pass
 		{
+			lighting off
+
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -94,4 +96,48 @@
 	}
 }
 
- 
+vertex_program PlainColor_VS cg
+{
+	source PlainColor.cg
+	entry_point main_plain_color_vp
+	profiles vs_1_1 arbvp1
+
+	default_params
+	{
+		param_named_auto worldViewProj worldviewproj_matrix		
+	}
+
+}
+
+fragment_program PlainColor_PS cg			
+{
+	source PlainColor.cg		
+	entry_point main_plain_color_fp	
+	profiles ps_1_1 arbfp1
+  
+	default_params
+	{
+		param_named inColor float4 1 1 1 1
+	}
+}	
+
+material PlainColor
+{
+        // Material has one technique
+	technique					
+	{
+                // This technique has one pass
+		pass					
+		{
+                        // Make this pass use the vertex shader defined above
+			vertex_program_ref PlainColor_VS	
+			{
+			}
+                        // Make this pass use the pixel shader defined above
+			fragment_program_ref PlainColor_PS	
+			{
+			      param_named_auto inColor custom 1
+			}
+		}
+	}
+}

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-07 19:12:52 UTC (rev 4741)
@@ -0,0 +1,32 @@
+void main_plain_color_vp(
+		// Vertex Inputs
+		float4 position		: POSITION,	// Vertex position in model space
+		float2 texCoord0	: TEXCOORD0,	// Texture UV set 0
+
+		// Outputs
+		out float4 oPosition	: POSITION,	// Transformed vertex position
+		out float2 uv0		: TEXCOORD0,	// UV0
+
+		// Model Level Inputs
+		uniform float4x4 worldViewProj)
+{
+	// Calculate output position
+	oPosition = mul(worldViewProj, position);
+
+	// Simply copy the input vertex UV to the output
+	uv0 = texCoord0;
+}
+
+void main_plain_color_fp(
+		// Pixel Inputs
+		float2 uv0		: TEXCOORD0,	// UV interpolated for current pixel	 
+		// Outputs
+		out float4 color	: COLOR,	// Output color we want to write
+		uniform float4 inColor
+		)
+{	 
+	// Just sample texture using supplied UV
+	//color = float4(0, 1, 0, 1);
+	//color = float4(inColor.r, inColor.g, inColor.b, 1);
+	color = inColor;
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001797.html">[Dsa-hl-svn] r4740 - in rl/branches/persistence2/engine: core	core/src script
</A></li>
	<LI>Next message: <A HREF="001799.html">[Dsa-hl-svn] r4742 - in	rl/branches/persistence2/editors/Lockenwickler: .	_eric4project src src/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1798">[ date ]</a>
              <a href="thread.html#1798">[ thread ]</a>
              <a href="subject.html#1798">[ subject ]</a>
              <a href="author.html#1798">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
