<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4616 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/include engine/core/src	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui/include engine/ui/src plugins	plugins/fmod4driver plugins/fmod4driver/include	plugins/fmod4driver/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4616%20-%20in%20rl/branches/newton20%3A%20.%0A%09Mac/Rastullah.xcodeproj%20cmake%20editors/Lockenwickler%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai/include%0A%09engine/ai/src%20engine/core/include%20engine/core/src%0A%09engine/rules/include%20engine/rules/src%20engine/script/src%0A%09engine/script/swig%20engine/ui/include%20engine/ui/src%20plugins%0A%09plugins/fmod4driver%20plugins/fmod4driver/include%0A%09plugins/fmod4driver/src&In-Reply-To=%3C200811302247.mAUMlROF009065%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001672.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4616 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/include engine/core/src	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui/include engine/ui/src plugins	plugins/fmod4driver plugins/fmod4driver/include	plugins/fmod4driver/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4616%20-%20in%20rl/branches/newton20%3A%20.%0A%09Mac/Rastullah.xcodeproj%20cmake%20editors/Lockenwickler%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai/include%0A%09engine/ai/src%20engine/core/include%20engine/core/src%0A%09engine/rules/include%20engine/rules/src%20engine/script/src%0A%09engine/script/swig%20engine/ui/include%20engine/ui/src%20plugins%0A%09plugins/fmod4driver%20plugins/fmod4driver/include%0A%09plugins/fmod4driver/src&In-Reply-To=%3C200811302247.mAUMlROF009065%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4616 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/include engine/core/src	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui/include engine/ui/src plugins	plugins/fmod4driver plugins/fmod4driver/include	plugins/fmod4driver/src">melven at mail.berlios.de
       </A><BR>
    <I>Sun Nov 30 23:47:27 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001672.html">[Dsa-hl-svn] r4615 - in modules/branch_persistenz: maps scripts/maps
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1673">[ date ]</a>
              <a href="thread.html#1673">[ thread ]</a>
              <a href="subject.html#1673">[ subject ]</a>
              <a href="author.html#1673">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2008-11-30 23:46:52 +0100 (Sun, 30 Nov 2008)
New Revision: 4616

Added:
   rl/branches/newton20/CMakeLists.txt
   rl/branches/newton20/cmake/
   rl/branches/newton20/cmake/FindCEGUI.cmake
   rl/branches/newton20/cmake/FindFMODEx.cmake
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/CodeDump.py
   rl/branches/newton20/editors/Lockenwickler/src/GOIntEditor.py
   rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/cursor.png
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
   rl/branches/newton20/engine/ui/include/CharacterSelectionWindow.h
   rl/branches/newton20/engine/ui/src/CharacterSelectionWindow.cpp
   rl/branches/newton20/plugins/CMakeLists.txt
   rl/branches/newton20/plugins/fmod4driver/CMakeLists.txt
Removed:
   rl/branches/newton20/cmake/FindCEGUI.cmake
   rl/branches/newton20/cmake/FindFMODEx.cmake
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
Modified:
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/bootstrap
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/newton20/engine/ai/include/AgentCombatState.h
   rl/branches/newton20/engine/ai/src/AgentCombatState.cpp
   rl/branches/newton20/engine/core/include/ListenerMovable.h
   rl/branches/newton20/engine/core/include/MovableText.h
   rl/branches/newton20/engine/core/include/Sound.h
   rl/branches/newton20/engine/core/include/SoundResource.h
   rl/branches/newton20/engine/core/include/SoundStitching.h
   rl/branches/newton20/engine/core/src/Actor.cpp
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
   rl/branches/newton20/engine/core/src/JobScheduler.cpp
   rl/branches/newton20/engine/core/src/ListenerMovable.cpp
   rl/branches/newton20/engine/core/src/MovableText.cpp
   rl/branches/newton20/engine/core/src/PhysicalThing.cpp
   rl/branches/newton20/engine/core/src/PhysicsManager.cpp
   rl/branches/newton20/engine/core/src/Sound.cpp
   rl/branches/newton20/engine/core/src/SoundResource.cpp
   rl/branches/newton20/engine/core/src/SoundStitching.cpp
   rl/branches/newton20/engine/rules/include/Combat.h
   rl/branches/newton20/engine/rules/include/Container.h
   rl/branches/newton20/engine/rules/include/GameObject.h
   rl/branches/newton20/engine/rules/include/Item.h
   rl/branches/newton20/engine/rules/include/PartyManager.h
   rl/branches/newton20/engine/rules/src/Combat.cpp
   rl/branches/newton20/engine/rules/src/Container.cpp
   rl/branches/newton20/engine/rules/src/GameObject.cpp
   rl/branches/newton20/engine/rules/src/Item.cpp
   rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/newton20/engine/script/swig/RlUi.swig
   rl/branches/newton20/engine/ui/include/AbstractWindow.h
   rl/branches/newton20/engine/ui/include/CombatGui.h
   rl/branches/newton20/engine/ui/include/GameSettings.h
   rl/branches/newton20/engine/ui/include/Makefile.am
   rl/branches/newton20/engine/ui/include/WindowFactory.h
   rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
   rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp
   rl/branches/newton20/engine/ui/src/CombatControlState.cpp
   rl/branches/newton20/engine/ui/src/CombatGui.cpp
   rl/branches/newton20/engine/ui/src/DebugWindow.cpp
   rl/branches/newton20/engine/ui/src/DialogControlState.cpp
   rl/branches/newton20/engine/ui/src/GameSettings.cpp
   rl/branches/newton20/engine/ui/src/InputManager.cpp
   rl/branches/newton20/engine/ui/src/InventoryWindow.cpp
   rl/branches/newton20/engine/ui/src/Makefile.am
   rl/branches/newton20/engine/ui/src/WindowFactory.cpp
   rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h
   rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp
Log:
merged changes from trunk (not working yet)


Copied: rl/branches/newton20/CMakeLists.txt (from rev 4613, rl/trunk/CMakeLists.txt)

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-30 22:46:52 UTC (rev 4616)
@@ -663,6 +663,8 @@
 		48A52CC00E0EF77D008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC20E0EF77E008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC30E0EF785008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
+		48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */; };
+		48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */; };
 		48B0B0350E6534690023B198 /* PlaneNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */; };
 		48B0B0370E6534810023B198 /* PlaneNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */; };
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
@@ -1490,6 +1492,8 @@
 		48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libboost_system.dylib; path = /usr/local/lib/libboost_system.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ApplyDamageJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ApplyDamageJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterSelectionWindow.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterSelectionWindow.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaneNodeProcessor.cpp; path = ../engine/script/src/PlaneNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaneNodeProcessor.h; path = ../engine/script/include/PlaneNodeProcessor.h; sourceTree = SOURCE_ROOT; };
 		48B0B0480E65BBB30023B198 /* libfmodex.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libfmodex.dylib; path = &quot;FMOD Programmers API/api/lib/libfmodex.dylib&quot;; sourceTree = SYSTEM_DEVELOPER_DIR; };
@@ -1519,7 +1523,7 @@
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
-		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
+		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = mkdmg.sh; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -2170,6 +2174,97 @@
 			path = src;
 			sourceTree = &quot;&lt;group&gt;&quot;;
 		};
+		48B006C30ECABFB0008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
+				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
+				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
+				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
+				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
+				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
+				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
+				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
+				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
+				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
+				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
+				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
+				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
+				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
+				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
+				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
+				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
+				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
+				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
+				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
+				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
+				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
+				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
+				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
+				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
+				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
+				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
+				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
+				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
+				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
+				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
+				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
+				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
+				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
+				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
+				48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */,
+			);
+			name = windows;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		48B006C60ECAC097008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
+				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
+				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
+				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
+				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
+				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
+				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
+				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
+				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
+				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
+				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
+				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
+				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
+				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
+				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
+				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
+				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
+				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
+				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
+				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
+				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
+				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
+				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
+				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
+				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
+				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
+				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
+				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
+				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
+				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
+				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
+				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
+				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
+				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
+				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
+				48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */,
+			);
+			name = windows;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
 		48B0B0230E6533940023B198 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
@@ -2235,55 +2330,19 @@
 		48EFE0880E8B6822007EB7F8 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
-				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
-				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
-				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
-				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				48B006C60ECAC097008141C2 /* windows */,
 				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
-				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
 				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
-				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
 				446BF4840C45335A0013C214 /* ControlState.h */,
 				446BF4850C45335A0013C214 /* CutsceneControlState.h */,
 				446BF4860C45335A0013C214 /* DialogControlState.h */,
 				446BF4870C45335A0013C214 /* FreeflightControlState.h */,
-				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
-				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
 				446BF48A0C45335A0013C214 /* MovementControlState.h */,
-				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
-				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
-				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
-				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
-				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
-				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
 				444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */,
-				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
-				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
-				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
-				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
-				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
-				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
-				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
-				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
 				444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */,
-				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
 				444EAD180BD0E58C00C6D4A0 /* InputManager.h */,
-				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
-				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
-				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
-				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
-				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
-				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
-				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
-				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
-				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
-				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
-				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
-				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
-				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
-				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
 				444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */,
 				444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */,
 				444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */,
@@ -2298,58 +2357,21 @@
 		48EFE0890E8B6900007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
-				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
-				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
-				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				48B006C30ECABFB0008141C2 /* windows */,
 				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
 				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
 				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
 				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
-				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
 				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
-				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
-				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
 				48389B910D86741F00AFAB66 /* stdinc.cpp */,
-				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
 				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
-				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
 				446BF4960C4533BD0013C214 /* ControlState.cpp */,
 				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
 				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
 				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
-				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
 				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
-				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
-				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
-				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
-				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
-				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
-				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
-				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
-				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
 				444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */,
-				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
-				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
-				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
-				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
-				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
-				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
-				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
-				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
-				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
-				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
 				444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */,
-				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
-				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
-				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
-				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
-				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
-				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
-				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
-				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
-				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
-				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
-				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
 			);
 			name = Source;
 			path = src;
@@ -2832,6 +2854,7 @@
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
 				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
+				48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3427,6 +3450,7 @@
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
 				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
+				48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/bootstrap
===================================================================
--- rl/branches/newton20/bootstrap	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/bootstrap	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,32 +1,4 @@
 #!/bin/sh
-
-# Check for proper versions of autotools
-# We require:
-#  - autoconf 2.50+
-#  - automake 1.6+
-#  - libtool 1.4+
-
-# Deal with some gentoo-specific issues
-export WANT_AUTOMAKE='1.7'
-export WANT_AUTOCONF_2_5=1
-
-## Using prereq in autoconf rather than here, mostly for the debian systems at
-## this point
-if test -z &quot;`autoconf --version 2&gt;&amp;1|head -n 1|egrep '2.[5-9]'`&quot;; then
-	echo &quot;Autoconf 2.50 or above is required. Aborting build...&quot;;
-    exit 1;
-fi
-
-if test -z &quot;`automake --version 2&gt;&amp;1|head -n 1|egrep '1.([6-9]|[1-9][0-9])'`&quot;; then
-	echo &quot;Automake 1.6 or above is required. Aborting build...&quot;;
-	exit 1;
-fi
-
-if test -z &quot;`libtool --version 2&gt;&amp;1|head -n 1|egrep '1.[4-5]'`&quot;; then
-	echo &quot;Libtool 1.4 or above is required. Aborting build...&quot;;
-	exit 1;
-fi
-
 echo &quot;Bootstrap...&quot;
 
 # Fire up autotools

Copied: rl/branches/newton20/cmake (from rev 4613, rl/trunk/cmake)

Deleted: rl/branches/newton20/cmake/FindCEGUI.cmake
===================================================================
--- rl/trunk/cmake/FindCEGUI.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindCEGUI.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,124 +0,0 @@
-# - Find CEGUI includes and library
-#
-# This module defines
-#  CEGUI_INCLUDE_DIRS
-#  CEGUI_LIBRARIES, the libraries to link against to use CEGUI.
-#  CEGUI_LIBRARY_DIRS, the location of the libraries
-#  CEGUI_FOUND, If false, do not try to use CEGUI
-#
-# Copyright &#194;&#169; 2007-2008, Matt Williams
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-IF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
-	SET(CEGUI_FIND_QUIETLY TRUE)
-ENDIF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
-
-#SET(OGRESDK $ENV{OGRE_HOME})
-#STRING(REGEX REPLACE &quot;[\\]&quot; &quot;/&quot; OGRESDK &quot;${OGRESDK}&quot;)
-FILE(TO_CMAKE_PATH &quot;$ENV{OGRE_HOME}&quot; OGRESDK)
-SET(CEGUI_INCLUDE_SEARCH_DIRS
-	${INCLUDE_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/include
-	/usr/local/include
-	/usr/include/CEGUI
-	/usr/local/include/CEGUI
-	/opt/include/CEGUI
-	/opt/CEGUI/include
-	$ENV{OGRE_HOME}/samples/CEGUI
-	$ENV{OGRE_HOME}/Dependencies/include
-	$ENV{OGRE_HOME}/Dependencies/include/CEGUI
-	CACHE STRING &quot;&quot;
-)
-
-SET(CEGUI_LIBRARY_SEARCH_DIRS
-	${LIBRARY_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/lib
-	/usr/lib64
-	/usr/local/lib
-	/usr/local/lib64
-	/opt/lib
-	/opt/lib64
-	/opt/CEGUI/lib
-	/opt/CEGUI/lib64
-	$ENV{OGRE_HOME}/lib
-	$ENV{OGRE_HOME}/lib64
-	CACHE STRING &quot;&quot;
-)
-
-IF (WIN32) #Windows
-	MESSAGE(STATUS &quot;Looking for CEGUI&quot;)
-	FIND_PATH(CEGUI_INCLUDE_DIRS CEGUI.h ${CEGUI_INCLUDE_SEARCH_DIRS})
-	FIND_LIBRARY(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
-	
-# 	SET(OGRESOURCE $ENV{OGRE_NEW})
-# 	IF (OGRESDK)
-# 		MESSAGE(STATUS &quot;Using CEGUI in OGRE SDK&quot;)
-# 		SET(OGRESDK $ENV{OGRE_HOME})
-# 		STRING(REGEX REPLACE &quot;[\\]&quot; &quot;/&quot; OGRESDK &quot;${OGRESDK}&quot; )
-# 		SET(CEGUI_INCLUDE_DIRS ${OGRESDK}/include/CEGUI)
-# 		SET(CEGUI_LIBRARY_DIRS ${OGRESDK}/lib)
-# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
-# 	ELSEIF (OGRESOURCE)
-# 		MESSAGE(STATUS &quot;Using CEGUI in OGRE dependencies&quot;)
-# 		SET(CEGUI_INCLUDE_DIRS C:/ogrenew/Dependencies/include C:/ogrenew/Dependencies/include/CEGUI)
-# 		SET(CEGUI_LIBRARY_DIRS C:/ogrenew/Dependencies/lib/Release C:/ogrenew/Dependencies/lib/Debug)
-# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
-# 	ELSE (OGRESDK)
-# 		IF (NOT DEPENDENCIES_PATH)
-# 			MESSAGE(STATUS &quot;Please set DEPENDENCIES_PATH (the directory containing 'common' and 'dependencies')&quot;)
-# 		ELSE (NOT DEPENDENCIES_PATH)
-# 			SET(CEGUI_INCLUDE_DIRS ${DEPENDENCIES_PATH}/dependencies/Ogre/CEGUI)
-# 			SET(CEGUI_LIBRARIES optimized CEGUIBase debug CEGUIBase_d)
-# 			SET(CEGUI_LIBRARY_DIRS optimized ${DEPENDENCIES_PATH}/dependencies/lib/release debug ${DEPENDENCIES_PATH}/dependencies/lib/debug)
-# 		ENDIF (NOT DEPENDENCIES_PATH)
-# 	ENDIF (OGRESDK)
-ELSE (WIN32) #Unix
-	SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRSS})
-	SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
-	SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
-
-	CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
-	FIND_PACKAGE(PkgConfig)
-	IF(PKG_CONFIG_FOUND)
-		PKG_SEARCH_MODULE(CEGUI CEGUI)
-		SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
-		SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
-		SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES} CACHE STRING &quot;&quot;)
-	ENDIF(PKG_CONFIG_FOUND)
-	IF(NOT CEGUI_FOUND) #If PkgConfig couldn't find OGRE...
-		IF (NOT CEGUI_FIND_QUIETLY)
-			MESSAGE(STATUS &quot; Manually searching for CEGUI&quot;)
-		ENDIF (NOT CEGUI_FIND_QUIETLY)
-		FIND_PATH(CEGUI_INCLUDE_DIRS Ogre.h ${CEGUI_INCLUDE_SEARCH_DIRS})
-		FIND_LIBRARY(CEGUI_LIBRARIES CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
-	ENDIF(NOT CEGUI_FOUND)
-ENDIF (WIN32)
-
-#Do some preparation
-SEPARATE_ARGUMENTS(CEGUI_INCLUDE_DIRS)
-SEPARATE_ARGUMENTS(CEGUI_LIBRARIES)
-
-SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
-SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
-SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBRARY_DIRS})
-
-MARK_AS_ADVANCED(CEGUI_INCLUDE_DIRS CEGUI_LIBRARIES CEGUI_LIBRARY_DIRS)
-
-IF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
-	SET(CEGUI_FOUND TRUE)
-ENDIF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
-
-IF (CEGUI_FOUND)
-	IF (NOT CEGUI_FIND_QUIETLY)
-		MESSAGE(STATUS &quot;  libraries : ${CEGUI_LIBRARIES} from ${CEGUI_LIBRARY_DIRS}&quot;)
-		MESSAGE(STATUS &quot;  includes  : ${CEGUI_INCLUDE_DIRS}&quot;)
-	ENDIF (NOT CEGUI_FIND_QUIETLY)
-ELSE (CEGUI_FOUND)
-	IF (CEGUI_FIND_REQUIRED)
-		MESSAGE(FATAL_ERROR &quot;Could not find CEGUI. Make sure you have the CEGUI development headers are installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place CEGUI was installed with -DLIBRARY_SEARCH_DIRS=&lt;path/to/lib&gt; -DINCLUDE_SEARCH_DIRS=&lt;path/to/include&gt;&quot;)
-	ENDIF (CEGUI_FIND_REQUIRED)
-ENDIF (CEGUI_FOUND)

Copied: rl/branches/newton20/cmake/FindCEGUI.cmake (from rev 4613, rl/trunk/cmake/FindCEGUI.cmake)

Deleted: rl/branches/newton20/cmake/FindFMODEx.cmake
===================================================================
--- rl/trunk/cmake/FindFMODEx.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindFMODEx.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,122 +0,0 @@
-# Find FMODEx
-#
-# This module defines
-# FMODEX_FOUND
-# FMODEX_INCLUDE_DIR
-# FMODEX_LIBRARY
-#
-# Based on the CMakeLists.txt of zdoom and FindFMOD.cmake of openfrag
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-# On a new cmake run, we do not need to be verbose
-IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-	SET(FMODEX_FIND_QUIETLY TRUE)
-ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-
-# Check for for 32/64 bit architecture
-IF(CMAKE_SIZEOF_VOID_P MATCHES &quot;8&quot;)
-	SET(X64 64)
-ENDIF(CMAKE_SIZEOF_VOID_P MATCHES &quot;8&quot;)
-
-IF(WIN32)
-	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES inc)
-	SET(FMODEX_LIB_DIR_SUFFIXES PATH_SUFFIXES lib)
-ELSE(WIN32)
-	SET(FMODEX_INCLUDE_SEARCH_DIRS
-	    /usr/include
-	    /usr/local/include
-	    /opt/fmodex/fmodex/include
-            /opt/include)
-	SET(FMODEX_LIBRARY_SEARCH_DIRS
-	    /usr/lib
-	    /usr/lib64
-	    /usr/local/lib
-	    /usr/local/lib64
-	    /opt/fmodex/lib
-	    /opt/fmodex/lib64)
-	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES fmodex)
-ENDIF(WIN32)
-
-# Decide on the name of the FMODEx library we want to use
-IF(NOT FMODEX_LIBRARY_NAME AND MSVC)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64}_vc)
-ENDIF(NOT FMODEX_LIBRARY_NAME AND MSVC)
-
-IF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64}_bc)
-ENDIF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
-
-IF(NOT FMODEX_LIBRARY_NAME)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64})
-ENDIF(NOT FMODEX_LIBRARY_NAME)
-
-IF (NOT FMODEX_FIND_QUIETLY)
-	MESSAGE(STATUS &quot;Checking for FMODEx&quot;)
-ENDIF(NOT FMODEX_FIND_QUIETLY)
-
-# Search for header files and libraries
-FIND_PATH(FMODEX_INCLUDE_DIR fmod.h
-          PATHS ${FMODEX_INCLUDE_SEARCH_PATHS}
-          PATH_SUFFIXES ${FMODEX_INC_DIR_SUFFIXES})
-IF(FMODEX_INCLUDE_DIR)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS &quot;  includes: ${FMODEX_INCLUDE_DIR}&quot;)
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_INCLUDE_DIR)
-	MESSAGE(SEND_ERROR &quot;FMODEx include files could not be found.&quot;)
-ENDIF(FMODEX_INCLUDE_DIR)
-
-FIND_LIBRARY(FMODEX_LIBRARY ${FMODEX_LIBRARY_NAME}
-             PATHS ${FMODEX_LIBRARY_SEARCH_DIRS}
-             PATH_SUFFIXES ${FMOD_LIB_DIR_SUFFIXES})
-IF(FMODEX_LIBRARY)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS &quot;  libraries: ${FMODEX_LIBRARY}&quot;)
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_LIBRARY)
-	MESSAGE(SEND_ERROR, &quot;FMODex library could not be found.&quot;)
-ENDIF(FMODEX_LIBRARY)
-
-IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-	SET(FMODEX_FOUND TRUE)
-ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-
-# Allow customisation of paths
-SET(FMODEX_INCLUDE_DIR ${FMODEX_INCLUDE_DIR})
-SET(FMODEX_LIBRARY ${FMODEX_LIBRARY})
-
-IF(FMODEX_INCLUDE_DIR)
-	# Extract the library version from the header file
-	SET(FMODEX_VERSION 0)
-	FILE(READ &quot;${FMODEX_INCLUDE_DIR}/fmod.h&quot;
-	     _FMODEX_FMOD_H_CONTENTS)
-	STRING(REGEX REPLACE &quot;.*#define FMOD_VERSION    0x([0-9]+).*&quot; &quot;\\1&quot;
-	       FMODEX_VERSION &quot;${_FMODEX_FMOD_H_CONTENTS}&quot;)
-	IF(NOT &quot;${FMODEX_VERSION}&quot; STREQUAL 0)
-		MATH(EXPR FMODEX_MAJOR_VERSION &quot;${FMODEX_VERSION} / 10000&quot;)
-		MATH(EXPR FMODEX_MINOR_VERSION &quot;${FMODEX_VERSION} / 100 % 100&quot;)
-		MATH(EXPR FMODEX_PATCH_VERSION &quot;${FMODEX_VERSION} % 100&quot;)
-		SET(FMODEX_VERSION &quot;${FMODEX_MAJOR_VERSION}.${FMODEX_MINOR_VERSION}.${FMODEX_PATCH_VERSION}&quot;)
-	ENDIF(NOT &quot;${FMODEX_VERSION}&quot; STREQUAL 0)
-
-	# Compare installed and required version
-	IF(FMODEx_FIND_VERSION)
-		# Major and minor version are required
-		IF(NOT FMODEx_FIND_VERSION_MINOR)
-			MESSAGE(SEND_ERROR &quot;When requesting a specific version of FMODEx , you must provide at least the major and minor version numbers, e.g., 4.20&quot;)
-		ENDIF(NOT FMODEx_FIND_VERSION_MINOR)
-
-		IF (&quot;${FMOD_VERSION}&quot; VERSION_LESS &quot;${FMODEx_FIND_VERSION}&quot;)
-			SET(FMODEX_FOUND FALSE)
-			MESSAGE(STATUS &quot;Detected version of FMODEx ${FMODEX_VERSION} is too old. At least version ${FMODEx_FIND_VERSION} is required.&quot;)
-		ENDIF(&quot;${FMOD_VERSION}&quot; VERSION_LESS &quot;${FMODEx_FIND_VERSION}&quot;)
-	ENDIF(FMODEx_FIND_VERSION)
-ENDIF(FMODEX_INCLUDE_DIR)
-
-IF(FMODEX_FOUND)
-	IF(NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS &quot;  version: ${FMODEX_VERSION}&quot;)
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ENDIF(FMODEX_FOUND)
\ No newline at end of file

Copied: rl/branches/newton20/cmake/FindFMODEx.cmake (from rev 4613, rl/trunk/cmake/FindFMODEx.cmake)

Deleted: rl/branches/newton20/cmake/FindOGRE.cmake
===================================================================
--- rl/trunk/cmake/FindOGRE.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindOGRE.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,96 +0,0 @@
-# Find OGRE includes and library
-#
-# This module defines
-#  OGRE_INCLUDE_DIRS
-#  OGRE_LIBRARIES, the libraries to link against to use OGRE.
-#  OGRE_LIBRARY_DIRS, the location of the libraries
-#  OGRE_FOUND, If false, do not try to use OGRE
-#
-# Copyright &#194;&#169; 2007-2008, Matt Williams
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-IF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
-	SET(OGRE_FIND_QUIETLY TRUE) # Already in cache, be silent
-ENDIF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
-
-#Set the library and include search paths
-#SET(OGRESDK $ENV{OGRE_HOME})
-#STRING(REGEX REPLACE &quot;[\\]&quot; &quot;/&quot; OGRESDK &quot;${OGRESDK}&quot;)
-FILE(TO_CMAKE_PATH &quot;$ENV{OGRE_HOME}&quot; OGRESDK)
-SET(OGRE_INCLUDE_SEARCH_DIRS #                 this &lt;-
-	${INCLUDE_SEARCH_DIRS} #TODO Cache this, not ^
-	${CMAKE_LIBRARY_PATH}
-	/usr/include/OGRE
-	/usr/local/include/OGRE
-	/opt/include/OGRE
-	/opt/OGRE/include
-	${OGRESDK}/include
-	${OGRESDK}/OgreMain/include
-	CACHE STRING &quot;&quot;
-)
-
-SET(OGRE_LIBRARY_SEARCH_DIRS
-	${LIBRARY_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/lib
-	/usr/lib64
-	/usr/local/lib
-	/usr/local/lib64
-	/opt/lib
-	/opt/lib64
-	/opt/OGRE/lib
-	/opt/OGRE/lib64
-	${OGRESDK}/lib
-	${OGRESDK}/lib64
-	CACHE STRING &quot;&quot;
-)
-
-#Search for the headers and libraries
-IF (WIN32) #Windows
-	MESSAGE(STATUS &quot;Looking for OGRE&quot;)
-	FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
-	FIND_LIBRARY(OGRE_LIBRARIES debug OgreMain_d optimized OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
-ELSE (WIN32) #Unix/OSX
-	FIND_PACKAGE(PkgConfig)
-	IF(PKG_CONFIG_FOUND)
-		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
-		PKG_SEARCH_MODULE(OGRE OGRE)
-		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
-		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
-		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING &quot;&quot;)
-	ENDIF(PKG_CONFIG_FOUND)
-	IF(NOT OGRE_FOUND) #If PkgConfig couldn't find OGRE...
-		IF (NOT OGRE_FIND_QUIETLY)
-			MESSAGE(STATUS &quot; Manually searching for OGRE&quot;)
-		ENDIF (NOT OGRE_FIND_QUIETLY)
-		FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
-		FIND_LIBRARY(OGRE_LIBRARIES OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
-	ENDIF(NOT OGRE_FOUND)
-ENDIF (WIN32)
-
-#Do some preparation
-SEPARATE_ARGUMENTS(OGRE_INCLUDE_DIRS)
-SEPARATE_ARGUMENTS(OGRE_LIBRARIES)
-
-SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
-SET(OGRE_LIBRARIES ${OGRE_LIBRARIES})
-SET(OGRE_LIBRARY_DIRS ${OGRE_LIBRARY_DIRS})
-
-MARK_AS_ADVANCED(OGRE_INCLUDE_DIRS OGRE_LIBRARIES OGRE_LIBRARY_DIRS) #So they don't show in the default GUI
-
-IF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
-	SET(OGRE_FOUND TRUE)
-ENDIF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
-
-IF (OGRE_FOUND)
-	IF (NOT OGRE_FIND_QUIETLY)
-		MESSAGE(STATUS &quot;  libraries : ${OGRE_LIBRARIES} from ${OGRE_LIBRARY_DIRS}&quot;)
-		MESSAGE(STATUS &quot;  includes  : ${OGRE_INCLUDE_DIRS}&quot;)
-	ENDIF (NOT OGRE_FIND_QUIETLY)
-ELSE (OGRE_FOUND)
-	IF (OGRE_FIND_REQUIRED)
-		MESSAGE(FATAL_ERROR &quot;Could not find OGRE. Make sure you have the OGRE development headers installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place OGRE was installed with -DLIBRARY_SEARCH_DIRS=&lt;path/to/lib&gt; -DINCLUDE_SEARCH_DIRS=&lt;path/to/include&gt;&quot;)
-	ENDIF (OGRE_FIND_REQUIRED)
-ENDIF (OGRE_FOUND)

Copied: rl/branches/newton20/cmake/FindOGRE.cmake (from rev 4613, rl/trunk/cmake/FindOGRE.cmake)

Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.5.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2008-10-31, 11:20:58 --&gt;
+&lt;!-- Saved: 2008-11-09, 21:48:49 --&gt;
 &lt;!-- Copyright (C) 2008 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.5&quot;&gt;
   &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
@@ -22,7 +22,6 @@
     &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
     &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
     &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_pref_dialog.py&lt;/Source&gt;
     &lt;Source&gt;src/SceneExplorer.py&lt;/Source&gt;
     &lt;Source&gt;src/Property.py&lt;/Source&gt;
     &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
@@ -33,10 +32,14 @@
     &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
     &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
     &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
+    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
     &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
   &lt;/Forms&gt;
   &lt;Translations&gt;
   &lt;/Translations&gt;

Copied: rl/branches/newton20/editors/Lockenwickler/src/CodeDump.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/CodeDump.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,74 +1,74 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from ui_ConsoleWindow import *
-import ogre.renderer.OGRE as og
-
-
-
-class LockenLog(og.LogListener):
-    def __init__(self, logFunction):
-        og.LogListener.__init__(self)
-        self.logFunction = logFunction
-
-    def messageLogged(self, message, level, debug, logName):
-        self.logFunction(str(message))
-
-class ConsoleWindow(QtGui.QDialog):
-    def __init__(self, filterLog, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-        self.filterLog = filterLog
-
-        self.consoleWindow = Ui_ConsoleWindow()
-        self.consoleWindow.setupUi(self)
-        self.consoleWindow.textEdit.setReadOnly(True)
-        self.lockenLog = LockenLog(self.write)
-
-        sys.stdout = self
-        sys.stderr = self
-
-        clearAction= QAction(&quot;Clear Window&quot;,  self)
-        self.consoleWindow.textEdit.addAction(clearAction)
-        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-        clearAction.setShortcut(&quot;Ctrl + R&quot;)
-        self.connect(clearAction, SIGNAL(&quot;triggered()&quot;), self.consoleWindow.textEdit.clear)
-
-
-    def write(self, text):
-        if self.filterLog:
-            if text.isspace():
-                return
-            elif text.startswith(&quot;Error&quot;):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith(&quot;OGRE EXCEPTION&quot;):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith(&quot;dbg:&quot;):
-                self.consoleWindow.textEdit.append(text)
-                return
-        else:
-            self.consoleWindow.textEdit.append(text)
-
-    def clear(self):
-        self.consoleWindow.textEdit.clear()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from ui_ConsoleWindow import *
+import ogre.renderer.OGRE as og
+
+
+
+class LockenLog(og.LogListener):
+    def __init__(self, logFunction):
+        og.LogListener.__init__(self)
+        self.logFunction = logFunction
+
+    def messageLogged(self, message, level, debug, logName):
+        self.logFunction(str(message))
+
+class ConsoleWindow(QtGui.QDialog):
+    def __init__(self, filterLog, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.filterLog = filterLog
+
+        self.consoleWindow = Ui_ConsoleWindow()
+        self.consoleWindow.setupUi(self)
+        self.consoleWindow.textEdit.setReadOnly(True)
+        self.lockenLog = LockenLog(self.write)
+
+        sys.stdout = self
+        sys.stderr = self
+
+        clearAction= QAction(&quot;Clear Window&quot;,  self)
+        self.consoleWindow.textEdit.addAction(clearAction)
+        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+        clearAction.setShortcut(&quot;Ctrl + R&quot;)
+        self.connect(clearAction, SIGNAL(&quot;triggered()&quot;), self.consoleWindow.textEdit.clear)
+
+
+    def write(self, text):
+        if self.filterLog:
+            if text.isspace():
+                return
+            elif text.startswith(&quot;Error&quot;):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith(&quot;OGRE EXCEPTION&quot;):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith(&quot;dbg:&quot;):
+                self.consoleWindow.textEdit.append(text)
+                return
+        else:
+            self.consoleWindow.textEdit.append(text)
+
+    def clear(self):
+        self.consoleWindow.textEdit.clear()

Copied: rl/branches/newton20/editors/Lockenwickler/src/GOIntEditor.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/GOIntEditor.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,176 +1,207 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from GOStringEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;STRING&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;REAL&quot;
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;BOOL&quot;
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INT&quot;
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTPAIR&quot;
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTTRIPPLE&quot;
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return &quot;MAP&quot;
-
-class GameObjectRepresentation():
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        self.inWorldId = inWorldId
-        self.goc = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get(&quot;classid&quot;)
-        self.baseclass = parentElement.get(&quot;baseclass&quot;)
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator(&quot;property&quot;):
-            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
-                pass
-            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return &quot;GAME_OBJECT&quot;
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get(&quot;name&quot;))
-        for subProperty in property:
-            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == &quot;STRING&quot;:
-                    if prop.name == &quot;meshfile&quot;:
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCStringProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCRealProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCBoolProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntPairProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get(&quot;type&quot;)
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;STRING&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;REAL&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;BOOL&quot;
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INT&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTPAIR&quot;
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTTRIPPLE&quot;
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return &quot;MAP&quot;
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = gameObjectClass
+        self.node = node
+        self.meshFile = meshFile
+
+    def getType(self):
+        return &quot;GAME_OBJECT_REPRESENTATION&quot;
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get(&quot;classid&quot;)
+        self.baseclass = parentElement.get(&quot;baseclass&quot;)
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator(&quot;property&quot;):
+            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
+                pass
+            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return &quot;GAME_OBJECT&quot;
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get(&quot;name&quot;))
+        for subProperty in property:
+            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == &quot;STRING&quot;:
+                    if prop.name == &quot;meshfile&quot;:
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCStringProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCRealProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCBoolProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntPairProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get(&quot;type&quot;)
+
+
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,52 +1,52 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,499 +1,440 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-#sys.path.insert(0,'..')
-#import PythonOgreConfig
-
-from random import randint
-from os.path import isfile
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from SceneExplorer import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
-        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-        splash.setMask(pixmap.mask())
-        splash.showMessage(&quot;Starting...&quot;)
-        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self.loadModule, self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.sceneExplorerWin = SceneExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
-        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
-
-        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
-        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-#        # Import Psyco if available
-#        try:
-#            import psyco
-#            psyco.full()
-#            #psyco.log()
-#            #psyco.profile()
-#        except ImportError:
-#            pass
-
-        #QtGui.QApplication.setKeyboardInputInterval(5000)
-
-        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName(&quot;MainWindow&quot;)
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName(&quot;menubar&quot;)
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(&quot;menuFile&quot;)
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName(&quot;menuView&quot;)
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName(&quot;statusbar&quot;)
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction(&quot;&amp;New&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New&quot;)
-        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
-
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionQuit&quot;)
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
-        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
-
-        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
-        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
-
-        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
-        self.actionCut.setObjectName(&quot;actionCut&quot;)
-
-        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
-        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
-
-        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
-        self.actionMove.setObjectName(&quot;actionMove&quot;)
-
-        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleSceneExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Scene Explorer&quot;,  False)
-        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
-
-        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
-        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
-
-        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
-        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
-
-        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
-        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
-        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
-        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Scene Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
-        if platform.system() == &quot;Windows&quot;:
-            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
-        else:
-            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = &quot;&quot;
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-
-        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def update(self):
-#        try:
-#            self.OgreMainWinSceneMgr.getSceneNode(&quot;saeule_076_node&quot;).yaw(0.02)
-#        except Exception,  e:
-#            pass
-
-        self.ogreRoot.renderOneFrame()
-
-    def actionNewSlot(self):
-        print &quot;dbg: new&quot;
-        return
-
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleSceneExplorer(self):
-        if self.sceneExplorerDock.isHidden():
-            self.sceneExplorerDock.show()
-        else:
-            self.sceneExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    # parses the moduleconfig.rb and searches for all loader.loadmap(&quot; statements in the ruby script
-    # and parses them too
-    def loadModule(self, modulePath, moduleName):
-        if self.moduleName == moduleName:
-            return
-
-        self.moduleName = moduleName
-        self.workingDir = modulePath + moduleName # the module path
-        self.workingDirCommon = modulePath + &quot;common&quot; # the module path of the common module
-
-        import codecs
-        import glob
-
-        modConfig = self.workingDir + &quot;/scripts/moduleconfig.rb&quot;
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Error: couldn't find module config&quot;)
-            pass
-
-        self.mapFiles = [] # a list in case the module has more than one map file
-        self.gofFiles = [] # gof File list
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-
-            # get the map file(s)
-            if lStripped.startswith(&quot;loader.loadMap(&quot;): # all loadMap commands begin with loader.loadMap(
-                spl = lStripped.split('&quot;')
-                for a in spl:
-                    if a.endswith(&quot;.xml&quot;):
-                        pathToMapFile = self.workingDir + &quot;/maps/&quot; + a
-                        self.mapFiles.append(pathToMapFile)
-
-        self.setWindowTitle(moduleName)
-
-        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
-        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, &quot;common&quot;)
-
-        self.setResourcePaths(self.workingDir, moduleName)
-        self.setResourcePaths(self.workingDirCommon, &quot;common&quot;)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        command = (os.path.join(self.workingDir,  &quot;maps&quot;) + &quot;/*.xml&quot;)
-        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  &quot;maps&quot;) + &quot;/*.scene&quot;)
-        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  &quot;dsa&quot;) + &quot;/*.gof&quot;)
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
-            self.gofFiles.append(gf)
-
-        command = (os.path.join(self.workingDirCommon,  &quot;dsa&quot;) + &quot;/*.gof&quot;)
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
-            self.gofFiles.append(gf)
-
-        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
-        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
-        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
-        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.sceneExplorerDock = QtGui.QDockWidget(self.tr(&quot;Scene Explorer&quot;), self)
-        self.sceneExplorerDock.setObjectName(&quot;SceneExplorerDockWindow&quot;)
-        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
-        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
-        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
-        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print&quot;&quot;
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == &quot;__main__&quot;:
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName(&quot;Team Pantheon&quot;)
-    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
-    app.setApplicationName(&quot;Lockenwickler&quot;)
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from SceneExplorer import *
+from NewModuleWizard import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
+        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+        splash.setMask(pixmap.mask())
+        splash.showMessage(&quot;Starting...&quot;)
+        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.sceneExplorerWin = SceneExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
+        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
+            self.prefDialog.show()
+
+        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
+        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
+
+
+#        # Import Psyco if available
+#        try:
+#            import psyco
+#            psyco.full()
+#            #psyco.log()
+#            #psyco.profile()
+#        except ImportError:
+#            pass
+
+        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName(&quot;MainWindow&quot;)
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName(&quot;menubar&quot;)
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName(&quot;menuFile&quot;)
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName(&quot;menuView&quot;)
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName(&quot;statusbar&quot;)
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
+        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
+
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
+
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
+
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
+        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
+        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
+
+        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
+        self.actionMove.setObjectName(&quot;actionMove&quot;)
+
+        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleSceneExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Scene Explorer&quot;,  False)
+        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
+
+        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
+        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
+
+        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
+        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
+
+        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
+        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
+        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
+        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Scene Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
+        if platform.system() == &quot;Windows&quot;:
+            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
+        else:
+            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = &quot;&quot;
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+
+        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+
+    def actionOpenSlot(self):
+        self.moduleManager.openLoadModuleDialog(self.prefDialog.lineEdit.text(), self)
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self)
+        newModuleWiz.exec_()
+        return
+
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleSceneExplorer(self):
+        if self.sceneExplorerDock.isHidden():
+            self.sceneExplorerDock.show()
+        else:
+            self.sceneExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
+        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
+        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
+        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.sceneExplorerDock = QtGui.QDockWidget(self.tr(&quot;Scene Explorer&quot;), self)
+        self.sceneExplorerDock.setObjectName(&quot;SceneExplorerDockWindow&quot;)
+        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
+        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
+        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
+        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print&quot;&quot;
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == &quot;__main__&quot;:
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName(&quot;Team Pantheon&quot;)
+    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
+    app.setApplicationName(&quot;Lockenwickler&quot;)
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,360 +1,550 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import xml.dom.minidom as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-
-class ModuleManager(object):
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
-        self.gocManager = GameObjectClassManager()
-
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
-        self.lastRay = None
-#        self.rayLine = None
-
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
-
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName(&quot;entity&quot;)
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes[&quot;name&quot;].nodeValue # get the name of the ent
-            meshFile = ent.attributes[&quot;meshfile&quot;].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == &quot;position&quot;:
-                        px = float(cn.attributes[&quot;x&quot;].nodeValue)
-                        py = float(cn.attributes[&quot;y&quot;].nodeValue)
-                        pz = float(cn.attributes[&quot;z&quot;].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == &quot;rotation&quot;:
-                        qw = float(cn.attributes[&quot;qw&quot;].nodeValue)
-                        qx = float(cn.attributes[&quot;qx&quot;].nodeValue)
-                        qy = float(cn.attributes[&quot;qy&quot;].nodeValue)
-                        qz = float(cn.attributes[&quot;qz&quot;].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == &quot;scale&quot;:
-                        px = float(cn.attributes[&quot;x&quot;].nodeValue)
-                        py = float(cn.attributes[&quot;y&quot;].nodeValue)
-                        pz = float(cn.attributes[&quot;z&quot;].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass
-
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None:
-            if not so.isPivot:
-                if self.pivot is not None:
-                    self.pivot.show()
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
-#
-#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = &quot;&quot;
-        split = name.split(&quot;_&quot;)
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + &quot;_1&quot;
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        newSelectionList = []
-        print &quot;dbg: &quot;
-        for so in self.userSelectionList:
-            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-            entityName = self.incrementNameSuffixNumber(so.entity.getName())
-            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-            newNode.attachObject(newEntity)
-            newNode.setPosition(so.entity.getParentNode().getPosition())
-            newNode.setOrientation(so.entity.getParentNode().getOrientation())
-            newNode.setScale(so.entity.getParentNode().getScale())
-
-            newSO = SelectionObject(newEntity, so.distance)
-            newSO.setSelected(True)
-            newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-    def pasteObjects(self,  ray):
-        if len(self.cutList) &lt; 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.pivot.stopTransforming()
-
-#    def iterateEntityUnderMouse(self):
-#        self.listenerDings.iterateEntityUnderMouse()
-#
-#        pass
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-        self.listenerDings.reset()
-        pass
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        pass
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
-
-        if go is not None:
-            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print &quot;sd&quot;
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+
+import elementtree.ElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot):
+        self.pathToMapFile = pathToFile
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+
+        xmlTree = xml.parse(pathToFile)
+        root = xmlTree.getroot()
+
+        if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
+            self.parseMap(root)
+        else:
+            print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
+            return
+
+    def parseMap(self, rootElement):
+        nodes = rootElement.getiterator(&quot;entity&quot;)
+        for n in nodes:
+            entityName = n.attrib[&quot;name&quot;]
+            meshFile = n.attrib[&quot;meshfile&quot;]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = n.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == &quot;scale&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(x, y, z)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
+                return
+
+            n = self.mapNode.createChild(entityName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+
+
+
+class Scene():
+    def __init__(self):
+        return
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.mapFiles = [] # a list in case the module has more than one map file
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Error: couldn't find module config&quot;)
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;super(&quot;):
+                split = lStripped.split(&quot;,&quot;)
+                if split[2].strip() == unicode(&quot;true&quot;):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == &quot;end&quot;:
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
+
+            elif lStripped == &quot;def getDependencies()&quot;:
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Error: couldn't find module config&quot;)
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, &quot;maps/*.rlmap.xml&quot;)
+            maps = glob.glob(cmd)
+            for m in maps:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
+
+            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
+            sceneFile = glob.glob(cmd)
+            #self.loadScenes(sceneFile)
+
+    def saveMaps(self):
+        return
+
+    def saveScenes(self):
+        return
+
+    def setResourcePaths(self, recurseFolder = &quot;&quot;):
+        if recurseFolder == &quot;&quot;:
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                pass
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.gocManager = GameObjectClassManager()
+
+        self.mainModule = []
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.lastRay = None
+#        self.rayLine = None
+
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot))
+
+        self.moduleConfigIsParsed = True
+
+    def openLoadModuleDialog(self, moduleConfigPath, lw):
+        self.moduleCfgPath = str(moduleConfigPath)
+        self.moduleFolder = str(moduleConfigPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
+        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies:
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.mainModule = m
+
+
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        self.listenerDings.reset()
+        self.lastRay = ray
+        self.listenerDings.currentRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+
+        if so is not None:
+            if not so.isPivot:
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#
+#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = &quot;&quot;
+        split = name.split(&quot;_&quot;)
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + &quot;_1&quot;
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) &lt; 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+        meshFile = go.getMeshFileName()
+
+        if go is not None:
+            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+            dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print &quot;sd&quot;
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -26,6 +26,12 @@
         self.entity = entity #the selected entity
         self.distance = distance # the distance from camera at the time of selection
         self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
     #if True this instance will show its bounding box else it will hide it
     def setSelected(self,  selected):
         if selected == True:

Copied: rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,106 +1,89 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import string
-from ui_pref_dialog import *
-
-class PreferencesDialog(QtGui.QDialog):
-    def __init__(self, loadModuleCallback, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-
-        self.loadModuleCallback = loadModuleCallback
-
-        self.prefDialog = Ui_PreferencesDialog()
-        self.prefDialog.setupUi(self)
-
-        QtCore.QObject.connect(self.prefDialog.modulConfigSelector, QtCore.SIGNAL(&quot;clicked()&quot;),
-                               self.openModulConfigSelector)
-
-        QtCore.QObject.connect(self.prefDialog.loadModuleBtn, QtCore.SIGNAL(&quot;clicked()&quot;),
-                               self.onLoadSelectedModule)
-
-        QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL(&quot;itemDoubleClicked(QListWidgetItem *)&quot;),
-                               self.onLoadSelectedModule)
-
-        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
-            pass
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText(&quot;C:/a11/modules/modules.cfg&quot;)
-            self.moduleCfgPath = 'C:/a11/modules/modules.cfg'
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
-            self.readInModules()
-            # end delete
-        else:
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText(&quot;/home/stefan/blubb/rl_modules/modules/modules.cfg&quot;)
-            self.moduleCfgPath = &quot;/home/stefan/blubb/rl_modules/modules/modules.cfg&quot;
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
-            self.readInModules()
-            # end delete
-
-        self.moduleCfgIsSelected = False
-
-        self.setModal(True)
-
-    def openModulConfigSelector(self):
-        dialog = QtGui.QFileDialog(self)
-        self.moduleCfgPath = str(dialog.getOpenFileName(self, &quot;Select modules.cfg&quot;, &quot;/home/stefan/blubb/rl_modules/modules/&quot;, &quot;modules.cfg (*.cfg)&quot;))
-        self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
-
-        from os.path import isfile
-
-        if isfile(self.moduleCfgPath):
-            self.prefDialog.lineEdit.setText(self.moduleCfgPath)
-            self.moduleCfgIsSelected = True
-            self.readInModules()
-
-    def readInModules(self):
-        if self.moduleCfgIsSelected:
-            import codecs
-            f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-            for line in f:
-                if line.startswith('#'):
-                    continue
-
-                if line.startswith('module='):
-                    splines = line.split('=')
-                    str = splines[1].rstrip().rstrip()
-                    if str != &quot;common&quot;:
-                        self.prefDialog.listWidget.addItem(str)
-
-    def onLoadSelectedModule(self):
-        item = self.prefDialog.listWidget.currentItem()
-
-        if item == None:
-            mbox = QtGui.QMessageBox(self)
-            mbox.setModal(True)
-            mbox.setText(&quot;Please select a module.&quot;)
-            mbox.show()
-        else:
-            tempo = str(item.text())
-            self.loadModuleCallback(self.modulePath, tempo)
-            self.hide()
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import string
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+class PreferencesDialog(QDialog):
+    def __init__(self, parent=None):
+        QDialog.__init__(self, parent)
+
+        self.label = QLabel()
+        self.label.setText(&quot;Please select the modules.cfg file.&quot;)
+        self.modulConfigSelector = QPushButton()
+        self.modulConfigSelector.setText(&quot;...&quot;)
+        self.lineEdit = QLineEdit()
+
+        layout = QGridLayout()
+        layout.addWidget(self.label, 0, 0, 1, 2)
+        layout.addWidget(self.lineEdit, 1, 0)
+        layout.addWidget(self.modulConfigSelector, 1, 1)
+
+        self.setLayout(layout)
+
+        QObject.connect(self.modulConfigSelector, SIGNAL(&quot;clicked()&quot;),
+                               self.openModulConfigSelector)
+
+        self.setModal(True)
+
+    def setCfgPath(self, inPath):
+        path = str(inPath)
+
+        from os.path import isfile
+
+        if isfile(path):
+            self.moduleCfgPath = path
+            self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
+            self.lineEdit.setText(self.moduleCfgPath)
+            return True
+        else:
+            return False
+
+    def openModulConfigSelector(self):
+        dialog = QFileDialog(self)
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, &quot;Select modules.cfg&quot;, &quot;/home/stefan/blubb/rl_modules/modules/&quot;, &quot;modules.cfg (*.cfg)&quot;))
+        self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
+
+        from os.path import isfile
+
+        if isfile(self.moduleCfgPath):
+            self.lineEdit.setText(self.moduleCfgPath)
+
+
+
+    def onLoadSelectedModule(self):
+        item = self.prefDialog.listWidget.currentItem()
+
+        if item == None:
+            mbox = QMessageBox(self)
+            mbox.setModal(True)
+            mbox.setText(&quot;Please select a module.&quot;)
+            mbox.show()
+        else:
+            tempo = str(item.text())
+            self.loadModuleCallback(self.modulePath, tempo)
+            self.hide()
+
+    def getModuleConfigPath(self):
+        return self.lineEdit
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/cursor.png (from rev 4613, rl/trunk/editors/Lockenwickler/src/media/icons/cursor.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend (from rev 4613, rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,85 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon Jun 23 19:28:46 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName(&quot;PreferencesDialog&quot;)
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName(&quot;toolBox&quot;)
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName(&quot;ResourcePaths&quot;)
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName(&quot;gridlayout1&quot;)
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName(&quot;groupBox&quot;)
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName(&quot;layoutWidget&quot;)
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName(&quot;gridlayout2&quot;)
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName(&quot;lineEdit&quot;)
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName(&quot;loadModuleBtn&quot;)
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName(&quot;modulConfigSelector&quot;)
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,&quot;&quot;)
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName(&quot;OgreSettings&quot;)
-        self.toolBox.addItem(self.OgreSettings,&quot;&quot;)
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName(&quot;buttonBox&quot;)
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL(&quot;accepted()&quot;),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL(&quot;rejected()&quot;),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL(&quot;clicked(QAbstractButton*)&quot;),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;GroupBox&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;Load Selected Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;...&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;Resource Paths&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate(&quot;PreferencesDialog&quot;, &quot;Ogre Settings&quot;, None, QtGui.QApplication.UnicodeUTF8))
-

Modified: rl/branches/newton20/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/branches/newton20/engine/ai/include/AgentCombatState.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ai/include/AgentCombatState.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -18,6 +18,7 @@
 
 #include &quot;AiPrerequisites.h&quot;
 #include &quot;AgentState.h&quot;
+#include &quot;Combat.h&quot;
 #include &quot;Combatant.h&quot;
 
 namespace rl
@@ -46,6 +47,10 @@
     protected:
         typedef enum {} CombatState;
         CombatState mState;
+
+    private:
+        Combatant* findOpponent(const Combat::CombatantSet&amp; opponents) const;
+        Ogre::Vector3 getFleeTarget(const Combat::CombatantSet&amp; opponents) const;
 	};
 }
 #endif

Modified: rl/branches/newton20/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/AgentCombatState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ai/src/AgentCombatState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -19,6 +19,7 @@
 #include &quot;AgentCombatState.h&quot;
 #include &quot;Combat.h&quot;
 #include &quot;CombatManager.h&quot;
+#include &quot;Creature.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
 
 namespace rl
@@ -45,13 +46,19 @@
     void AgentCombatState::requestCombatantAction()
     {
         // Think!
-		const Combat::CombatantSet&amp; allies = mCombat-&gt;getAllAllies();
-		if (!allies.empty())
+        Combat::CombatantSet opponents = mCombat-&gt;getAllOpponents(this);
+		if (!opponents.empty())
 		{
-			Combatant* target = *allies.begin();
-			// Are we in weapon range to opponent
-			if (target)
-			{
+			Combatant* target = findOpponent(opponents);
+            
+            mCombat-&gt;registerParade(target);
+
+            if (getCreature()-&gt;getLe() &lt;= 5)
+            {
+                mCombat-&gt;registerBewegen(this, getFleeTarget(opponents));
+            }
+            else if (target)
+            {
 				// Are we in weapon range to opponent
 				if (mCombat-&gt;canAttack(this, target))
 				{
@@ -72,4 +79,47 @@
     {
         mAgent-&gt;updateVehicle(0, elapsedTime);
     }
+
+    class DistanceComparator
+		: std::binary_function&lt;Combatant*, Combatant*, bool&gt;
+    {
+    private:
+        const Combatant* mActingCombatant;
+
+    public:
+        DistanceComparator(const Combatant* actingCombatant)
+            : mActingCombatant(actingCombatant)
+        {
+        }
+
+        bool operator()(const Combatant* c1, const Combatant* c2) const
+        {
+            Vector3 pos = mActingCombatant-&gt;getPosition();
+            return pos.squaredDistance(c1-&gt;getPosition())
+                &lt; pos.squaredDistance(c2-&gt;getPosition());
+        }
+    };
+
+
+    Combatant* AgentCombatState::findOpponent(const Combat::CombatantSet&amp; opponents) const
+    {
+        ///@todo support different search patterns (search for most dangerous, weakest, ... opponent)
+        Combat::CombatantSet::const_iterator minIt = 
+            std::min_element(opponents.begin(), opponents.end(), DistanceComparator(this));
+        return *minIt;
+    }
+
+    Vector3 AgentCombatState::getFleeTarget(const Combat::CombatantSet&amp; opponents) const
+    {
+        Vector3 oppPosition;
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); ++it)
+        {
+            oppPosition += (*it)-&gt;getPosition();
+        }
+        oppPosition /= opponents.size();
+
+        Vector3 pos = getPosition();
+        Vector3 oppositeDirection = (pos - oppPosition).normalisedCopy();
+        return pos + 10 * oppositeDirection;
+    }
 }

Modified: rl/branches/newton20/engine/core/include/ListenerMovable.h
===================================================================
--- rl/branches/newton20/engine/core/include/ListenerMovable.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/ListenerMovable.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,94 +1,98 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __ListenerMovable_H__
-#define __ListenerMovable_H__
-
-#include &quot;CorePrerequisites.h&quot;
-
-
-namespace rl {
-    
-   /** Diese Klasse dient der Interaktion mit Ogre3d und
-    * kapselt den H&#246;rer.
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
-    {
-    public:
-        /// Konstruktor
-        ListenerMovable(const Ogre::String&amp; name);
-        /// Destruktor
-        virtual ~ListenerMovable() = 0;
-        /// Name zur&#252;ckgeben
-        virtual const Ogre::String&amp; getName() const;
-        /// Moveable-Typ
-        virtual const Ogre::String&amp; getMovableType() const;
-        /// Kamera informieren
-        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-    
-        /// Gibt die Hauptlautstaerke zurueck
-        virtual const int getGain() const;
-        /// Setzt die Hauptlautstaerke.
-        virtual void setGain(const int direction);
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3&amp; direction);
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getOrientation() const;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setOrientation(const Ogre::Quaternion &amp;orientation);
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&amp;);
-        
-        /// Ist dies der aktuelle Listener
-        bool isActive() const;
-		void setActive(bool active);
-        
-    protected:
-         /// Shared class-level name for Movable type
-        static Ogre::String msMovableType;
-        /// Alignment-Box: gebraucht von MovableObject.
-        static Ogre::AxisAlignedBox msAABox;
-        /// Position
-        Ogre::Vector3 mPosition;
-        /// Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// Orientierung
-        Ogre::Quaternion mOrientation;
-        /// Hauptlautst&#228;rke
-        int mGain;
-
-    private:
-        /// Der Name des ListenerMovable
-        Ogre::String mName;
-		bool mActive;
-    };
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __ListenerMovable_H__
+#define __ListenerMovable_H__
+
+#include &quot;CorePrerequisites.h&quot;
+
+
+namespace rl {
+    
+   /** Diese Klasse dient der Interaktion mit Ogre3d und
+    * kapselt den H&#246;rer.
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
+    {
+    public:
+        /// Konstruktor
+        ListenerMovable(const Ogre::String&amp; name);
+        /// Destruktor
+        virtual ~ListenerMovable() = 0;
+        /// Name zur&#252;ckgeben
+        virtual const Ogre::String&amp; getName() const;
+        /// Moveable-Typ
+        virtual const Ogre::String&amp; getMovableType() const;
+        /// Kamera informieren
+        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+    
+        /// Gibt die Hauptlautstaerke zurueck
+        virtual const int getGain() const;
+        /// Setzt die Hauptlautstaerke.
+        virtual void setGain(const int direction);
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3&amp; direction);
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getOrientation() const;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setOrientation(const Ogre::Quaternion &amp;orientation);
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&amp;);
+        
+        /// Ist dies der aktuelle Listener
+        bool isActive() const;
+		void setActive(bool active);
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+        
+    protected:
+         /// Shared class-level name for Movable type
+        static Ogre::String msMovableType;
+        /// Alignment-Box: gebraucht von MovableObject.
+        static Ogre::AxisAlignedBox msAABox;
+        /// Position
+        Ogre::Vector3 mPosition;
+        /// Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// Orientierung
+        Ogre::Quaternion mOrientation;
+        /// Hauptlautst&#228;rke
+        int mGain;
+
+    private:
+        /// Der Name des ListenerMovable
+        Ogre::String mName;
+		bool mActive;
+    };
+
+}
+#endif

Modified: rl/branches/newton20/engine/core/include/MovableText.h
===================================================================
--- rl/branches/newton20/engine/core/include/MovableText.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/MovableText.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -63,6 +63,7 @@
         const Ogre::String&amp; getMovableType(void) const { return msType; }
         Ogre::Real getBoundingRadius(void) const {return mRadius;}
         Ogre::Real getSquaredViewDepth(const Ogre::Camera* cam) const { return 0; }
+		void visitRenderables(Ogre::Renderable::Visitor* visitor,  bool debugRenderables = false);
  
         // from renderable
         void getRenderOperation(Ogre::RenderOperation &amp;op);

Modified: rl/branches/newton20/engine/core/include/Sound.h
===================================================================
--- rl/branches/newton20/engine/core/include/Sound.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/Sound.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,163 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Sound_H__
-#define __Sound_H__
-
-#include &quot;CorePrerequisites.h&quot;
-#include &lt;set&gt;
-
-#include &quot;Exception.h&quot;
-#include &quot;EventCaster.h&quot;
-#include &quot;SoundEvents.h&quot;
-#include &quot;SoundResource.h&quot;
-
-namespace rl {
-
-    class SoundDriver;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport Sound : public Ogre::MovableObject, 
-        public EventCaster&lt;SoundEvent&gt;, public EventSource
-    {
-    public:
-        // Einige Standardwerte f&#195;&#188;r Soundpriorit&#195;&#164;ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        Sound(const SoundResourcePtr&amp; soundres, SoundDriver* creator);
-        /// Destruktor
-        virtual ~Sound();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr&amp; getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        virtual float getLength() const = 0;
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Zurueck auf Anfang.
-    //        virtual void rewind() throw (RuntimeException) = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-        
-    }; 
-
-
-    typedef std::set&lt;Sound*&gt; SoundSet;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Sound_H__
+#define __Sound_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &lt;set&gt;
+
+#include &quot;Exception.h&quot;
+#include &quot;EventCaster.h&quot;
+#include &quot;SoundEvents.h&quot;
+#include &quot;SoundResource.h&quot;
+
+namespace rl {
+
+    class SoundDriver;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport Sound : public Ogre::MovableObject, 
+        public EventCaster&lt;SoundEvent&gt;, public EventSource
+    {
+    public:
+        // Einige Standardwerte f&#195;&#188;r Soundpriorit&#195;&#164;ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        Sound(const SoundResourcePtr&amp; soundres, SoundDriver* creator);
+        /// Destruktor
+        virtual ~Sound();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr&amp; getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        virtual float getLength() const = 0;
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Zurueck auf Anfang.
+    //        virtual void rewind() throw (RuntimeException) = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+	/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+	
+	protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+        
+    }; 
+
+
+    typedef std::set&lt;Sound*&gt; SoundSet;
+
+}
+#endif

Modified: rl/branches/newton20/engine/core/include/SoundResource.h
===================================================================
--- rl/branches/newton20/engine/core/include/SoundResource.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/SoundResource.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -33,10 +33,6 @@
  */
 class _RlCoreExport SoundResource: public Ogre::Resource
 {
-    private:
-        /// Unsere Daten von Ogres ResourceManager.
-        Ogre::DataStreamPtr mDataStream;
-                       
     public:
         /// Der Standardkonstruktor
         SoundResource(Ogre::ResourceManager* creator, const Ogre::String&amp; name, 
@@ -44,10 +40,8 @@
             Ogre::ManualResourceLoader* loader);
         /// Der Destruktor
         virtual ~SoundResource();
-        /// Den Datenstrom zur&#239;&#191;&#189;ckgeben
+        /// Den Datenstrom zurueckgeben
         const Ogre::DataStreamPtr &amp;getDataStream() const;
-        /// Groesse zurueckgeben.
-        int getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.
@@ -57,6 +51,10 @@
 		/// Bestimmt die Groesse im Speicher (wird erst nach dem Laden aufgerufen)
 		virtual size_t calculateSize() const;        
         
+
+	private:
+        /// Unsere Daten von Ogres ResourceManager.
+        Ogre::DataStreamPtr mDataStream;
 };
 
 class _RlCoreExport SoundResourcePtr :

Modified: rl/branches/newton20/engine/core/include/SoundStitching.h
===================================================================
--- rl/branches/newton20/engine/core/include/SoundStitching.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/SoundStitching.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,178 +1,182 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __SoundStitching_H__
-#define __SoundStitching_H__
-
-#include &quot;CorePrerequisites.h&quot;
-#include &lt;set&gt;
-
-#include &quot;Exception.h&quot;
-#include &quot;EventCaster.h&quot;
-#include &quot;SoundEvents.h&quot;
-#include &quot;SoundResource.h&quot;
-
-namespace rl {
-
-    class SoundDriver;
-
-    typedef std::map&lt;CeGuiString, SoundResourcePtr&gt; SoundCache;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
-        public EventCaster&lt;SoundEvent&gt;, public EventSource
-    {
-    public:
-        // Einige Standardwerte f&#195;&#188;r Soundpriorit&#195;&#164;ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        SoundStitching(unsigned int numSlots, const CeGuiString&amp; name, SoundDriver* creator);
-        /// Destruktor
-        virtual ~SoundStitching();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        virtual float getLength() const;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr&amp; getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-        /// Count of configured slots.
-        unsigned int getNumSlots();
-        /// Add a sound resource to the cache overwritting existing sound resource.
-        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
-        /// Assign a sound recource to a slot.
-        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
-        /// Get the slot of the plaing sound.
-        virtual unsigned int getPlayingSlot() = 0;
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-        // Sound-Cache
-        SoundCache mSoundCache;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-
-        // Anzahl der Soundslots
-        unsigned int mNumSlots;
-
-        // Name
-        CeGuiString mName;
-        
-    }; 
-
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __SoundStitching_H__
+#define __SoundStitching_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &lt;set&gt;
+
+#include &quot;Exception.h&quot;
+#include &quot;EventCaster.h&quot;
+#include &quot;SoundEvents.h&quot;
+#include &quot;SoundResource.h&quot;
+
+namespace rl {
+
+    class SoundDriver;
+
+    typedef std::map&lt;CeGuiString, SoundResourcePtr&gt; SoundCache;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
+        public EventCaster&lt;SoundEvent&gt;, public EventSource
+    {
+    public:
+        // Einige Standardwerte f&#195;&#188;r Soundpriorit&#195;&#164;ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        SoundStitching(unsigned int numSlots, const CeGuiString&amp; name, SoundDriver* creator);
+        /// Destruktor
+        virtual ~SoundStitching();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        virtual float getLength() const;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr&amp; getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+        /// Count of configured slots.
+        unsigned int getNumSlots();
+        /// Add a sound resource to the cache overwritting existing sound resource.
+        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
+        /// Assign a sound recource to a slot.
+        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
+        /// Get the slot of the plaing sound.
+        virtual unsigned int getPlayingSlot() = 0;
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+
+    protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+        // Sound-Cache
+        SoundCache mSoundCache;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+
+        // Anzahl der Soundslots
+        unsigned int mNumSlots;
+
+        // Name
+        CeGuiString mName;
+        
+    }; 
+
+}
+#endif
+

Modified: rl/branches/newton20/engine/core/src/Actor.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/Actor.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/Actor.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -466,17 +466,17 @@
             node-&gt;setScale( vec );
 
             // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()-&gt;isMeshObject() )
+/*            if( getControlledObject()-&gt;isMeshObject() )
             {
                 MeshObject* meshObj = dynamic_cast&lt;MeshObject*&gt;( getControlledObject() );
 
                 // ... und gr&#246;&#223;er/kleiner als normal skaliert wird ...
                 if( vec != Vector3(1,1,1) )
                     // ... m&#252;ssen die Normalen neu berechnet werden.
-                    meshObj-&gt;getEntity()-&gt;setNormaliseNormals( true );
+					meshObj-&gt;getEntity()-&gt;setNormaliseNormals( true );
                 else
                     meshObj-&gt;getEntity()-&gt;setNormaliseNormals( false );
-            }
+            }*/
         }
     }
 

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -111,6 +111,7 @@
         addSetting(&quot;Action keys&quot;, &quot;showjournalwindow&quot;, &quot;J&quot;);
         addSetting(&quot;Action keys&quot;, &quot;showcharactersheet&quot;, &quot;C&quot;);
         addSetting(&quot;Action keys&quot;, &quot;togglecharacterstatewindow&quot;, &quot;O&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;togglecharacterselectionwindow&quot;, &quot;Y&quot;);
         addSetting(&quot;Action keys&quot;, &quot;toggleingameglobalmenu&quot;, &quot;F10&quot;);
         addSetting(&quot;Action keys&quot;, &quot;shownextdebugwindowpage&quot;, &quot;Ctrl+M&quot;);
         addSetting(&quot;Action keys&quot;, &quot;showobjectactions&quot;, &quot;U&quot;);
@@ -388,9 +389,14 @@
 	
 	void ConfigurationManager::setExecutable(const Ogre::String&amp; path)
 	{
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+		return;
+		fs::path exeAbsolute(path);
+#       else
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		mExecutablePath = exeAbsolute.remove_leaf().string();
-        std::cout &lt;&lt; &quot;ConfigurationManager&quot; &lt;&lt; &quot;Executable is &quot; &lt;&lt; path &lt;&lt; &quot; &quot; &lt;&lt; mExecutablePath;
+#		endif
+		mExecutablePath = exeAbsolute.branch_path().string();
+        std::cout &lt;&lt; &quot;ConfigurationManager &quot; &lt;&lt; &quot;Executable is &quot; &lt;&lt; path &lt;&lt; &quot; &quot; &lt;&lt; mExecutablePath;
 	}
 
 	const Ogre::String&amp; ConfigurationManager::getExecutablePath() const
@@ -440,17 +446,14 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename) &lt;&lt; std::endl;
-            if (fs::exists(filename))
+			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename).string() &lt;&lt; std::endl;
+            return fs::exists(filename);
 #           else
 			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; 
 				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
                  &lt;&lt; std::endl;
-			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+			return fs::exists(fs::path(filename, fs::portable_posix_name));
 #           endif
-            {
-                return true;
-            }
         }
         catch (fs::filesystem_error&amp;) 
         {

Modified: rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -771,8 +771,10 @@
               return;
         }
 
-        if (parentNode-&gt;getScale() != Vector3::UNIT_SCALE)
+        /*if (parentNode-&gt;getScale() != Vector3::UNIT_SCALE) 
+		{
             newEnt-&gt;setNormaliseNormals(true);
+		}*/
 
         parentNode-&gt;attachObject(newEnt);
 

Modified: rl/branches/newton20/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/JobScheduler.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/JobScheduler.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,323 +1,350 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;JobScheduler.h&quot;
-#include &quot;Job.h&quot;
-#include &quot;JobListener.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;TimeSource.h&quot;
-#include &quot;SaveGameManager.h&quot;
-
-using namespace Ogre;
-
-template&lt;&gt; rl::JobScheduler* Singleton&lt;rl::JobScheduler&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    JobScheduler::JobScheduler()
-        : GameTask(true),
-        mJobQueue(), 
-        mAddedJobs(),
-        mTokenThreshold(JP_NORMAL), 
-        mTicketCounter(0)
-    {
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-    }
-
-    JobScheduler::~JobScheduler()
-    {
-    }
-
-    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
-        JobListener* listener)
-    {
-        unsigned long ticket = ++mTicketCounter;
-        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
-            job-&gt;getTimeSource());
-        unsigned long clock = ts-&gt;getClock();
-        unsigned long start = clock + delay*1000;
-        unsigned long end = maxRuntime &gt;= Math::POS_INFINITY ?
-            0xffffffff : static_cast&lt;unsigned long&gt;(start + maxRuntime*1000);
-        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job-&gt;getTimeSource(), false, false};
-        mAddedJobs.push_back(entry);
-        return ticket;
-    }
-
-    void JobScheduler::run(Ogre::Real time)
-    {
-        ///@todo use different buckets for jobs not yet started, instead of
-        ///      iterating over those each time.
-
-        ///@todo dynamically determine token threshold. Maybe make it work load depending.
-
-
-        // Queue for finished jobs
-        JobQueue notDone;
-
-        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
-        {
-            JobEntry entry = *it;
-
-            TimeSource::TimeSourceType tst = entry.job-&gt;getTimeSource();
-            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
-            Time clock = ts-&gt;getClock();
-            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
-            {
-                entry.timeLastCall = clock;
-                entry.timeSourceLastCall = tst;
-            }
-
-            if (entry.markedToRemove)
-            {
-                // Notify listener, the job was removed
-                if (entry.listener != NULL)
-                {
-                    entry.listener-&gt;jobRemoved(entry.ticket);
-                }
-
-                if (entry.job-&gt;destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-            else if (entry.start &lt;= clock &amp;&amp; clock &lt; entry.end)
-            {
-                // Is the token threshold reached?
-                if (entry.tokens &gt;= mTokenThreshold)
-                {
-                    // Yes, pay run fee and execute.
-                    entry.tokens = 0;
-                    bool runAgain = !entry.job-&gt;execute(clock - entry.timeLastCall);
-
-                    if (!entry.called)
-                    {
-                        // Notify listener, the job started for the first time
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener-&gt;jobStarted(entry.ticket);
-                        }
-                        entry.called = true;
-                    }
-
-                    if (runAgain)
-                    {
-                        // Job is not done, reset token count and requeue.
-                        entry.tokens = entry.priority;
-                        entry.timeLastCall = clock;
-                        notDone.push_back(entry);
-                    }
-                    else
-                    {
-                        // Notify listener, the job finished regularly.
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener-&gt;jobFinished(entry.ticket);
-                        }
-
-                        // If we are supposed to delete the Job, do so now.
-                        if (entry.job-&gt;destroyWhenDone())
-                        {
-                            delete entry.job;
-                        }
-                    }
-                }
-                else
-                {
-                    // No, increase token count
-                    entry.tokens += entry.priority;
-                    notDone.push_back(entry);
-                }
-            }
-            else if (clock &lt; entry.end)
-            {
-                // Start time not yet reached. Queue again.
-                notDone.push_back(entry);
-            }
-            else
-            {
-                // Job reached its end time and didn't want to finish itself, so we do it.
-                if (entry.job-&gt;isDiscardable())
-                {
-                    entry.job-&gt;discard();
-                    if (entry.listener != NULL)
-                    {
-                        entry.listener-&gt;jobDiscarded(entry.ticket);
-                    }
-                }
-                if (entry.job-&gt;destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-        }
-
-        // Copy requeued jobs for next run.
-        mJobQueue = notDone;
-		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
-		mAddedJobs.clear();
-    }
-
-    void JobScheduler::removeJob(unsigned long ticket)
-    {
-        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
-            std::bind2nd(FindJobEntryByTicket(), ticket));
-        if (it != mJobQueue.end())
-        {
-            //mRemovedJobs.push_back(*it);
-            (*it).markedToRemove = true;
-        }
-        else
-        {
-			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
-				std::bind2nd(FindJobEntryByTicket(), ticket));
-			if (it != mAddedJobs.end())
-			{
-				mAddedJobs.erase(it);
-			}
-			else
-			{
-				///@todo Log missing job for the ticket.
-			}
-        }
-    }
-
-    const Ogre::String&amp; JobScheduler::getName() const
-    {
-        static Ogre::String NAME = &quot;JobScheduler&quot;;
-
-        return NAME;
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-
-    void JobScheduler::writeData(SaveGameFileWriter* writer)
-    {
-        DOMElement* jobSchedulerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
-        {
-            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT &amp;&amp; !(iter-&gt;markedToRemove) )
-            {
-                DOMElement* jobNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), jobSchedulerParentNode, &quot;job&quot;);
-                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;priority&quot;, iter-&gt;priority);
-                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;tokens&quot;, iter-&gt;tokens);
-                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;start&quot;, iter-&gt;start);
-                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;end&quot;, iter-&gt;end);
-                writer-&gt;setAttributeValueAsInt64(jobNode, &quot;timeLastCall&quot;, iter-&gt;timeLastCall);
-                writer-&gt;setAttributeValueAsBool(jobNode, &quot;called&quot;, iter-&gt;called);
-                writer-&gt;setAttributeValueAsString(jobNode, &quot;classname&quot;, iter-&gt;job-&gt;getClassName());
-
-                PropertyMap map = iter-&gt;job-&gt;getAllProperties()-&gt;toPropertyMap();
-                writer-&gt;writeEachPropertyToElem(jobNode, map);
-            }
-        }
-    }
-
-    void JobScheduler::readData(SaveGameFileReader* reader)
-    {
-        // delete and discard old jobs
-        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
-        {
-            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT )
-            {
-                // delete the job, but do not discard it!
-                iter-&gt;markedToRemove = true;
-            }
-            else if( iter-&gt;job-&gt;getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
-            {
-                // discard the job, then delete it
-                if( iter-&gt;job-&gt;isDiscardable() )
-                    iter-&gt;job-&gt;discard();
-                iter-&gt;markedToRemove = true;
-            }
-        }
-
-        
-        // load jobs from savegamefile
-
-        reader-&gt;initializeXml();
-
-
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-        
-        if(rootNodeList-&gt;getLength())
-        {
-            DOMNodeList* xmlJobs = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;job&quot;).data());
-            if (xmlJobs-&gt;getLength())
-            {
-                for (XMLSize_t childIdx1 = 0; childIdx1 &lt; xmlJobs-&gt;getLength(); childIdx1++)
-                {
-                    DOMNode* xmlJob_ = xmlJobs-&gt;item(childIdx1);
-                    if (xmlJob_-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        DOMElement* xmlJob = static_cast&lt;DOMElement*&gt;(xmlJob_);
-                        JobPriority priority;
-                        unsigned short tokens;
-                        int start, end;
-                        Time timeLastCall;
-                        bool called;
-                        priority = JobPriority(reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;priority&quot;));
-                        tokens = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;tokens&quot;);
-                        start = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;start&quot;);
-                        end = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;end&quot;);
-                        timeLastCall = reader-&gt;getAttributeValueAsInt64(xmlJob, &quot;timeLastCall&quot;);
-                        called = reader-&gt;getAttributeValueAsBool(xmlJob, &quot;called&quot;);
-
-                        Ogre::String className = reader-&gt;getAttributeValueAsStdString(xmlJob, &quot;classname&quot;);
-
-                        JobCreationMap::iterator it = mJobCreationMap.find(className);
-                        if (it == mJobCreationMap.end())
-                        {
-                            LOG_ERROR(Logger::CORE, &quot;Die Job-Klasse '&quot; + className + &quot;' ist nicht beim JobScheduler registriert!&quot;);
-                            continue;
-                        }
-
-                        AbstractJob* job = it-&gt;second();
-                        if (job == NULL)
-                        {
-                            LOG_ERROR(Logger::CORE, &quot;Fehler beim Erstellen eines Objekts der Job-Klasse '&quot; + className + &quot;'!&quot;);
-                            continue;
-                        }
-                        PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(xmlJob);
-                        job-&gt;setProperties(properties);
-                        
-                        
-                        unsigned long ticket = ++mTicketCounter;
-                        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(job-&gt;getTimeSource());
-                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, TimeSource::UNKNOWN, called, false};
-                        mJobQueue.push_back(entry);
-                    }
-                }
-            }
-        }
-
-        reader-&gt;shutdownXml();
-    }
-
-    int JobScheduler::getPriority() const
-    {
-        return 0; // must be loaded before triggers!
-    }
-
-    CeGuiString JobScheduler::getXmlNodeIdentifier() const
-    {
-        static const CeGuiString name = &quot;jobscheduler&quot;;
-        return name;
-    }
-
-    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;JobScheduler.h&quot;
+#include &quot;Job.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;TimeSource.h&quot;
+#include &quot;SaveGameManager.h&quot;
+
+using namespace Ogre;
+
+template&lt;&gt; rl::JobScheduler* Singleton&lt;rl::JobScheduler&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    JobScheduler::JobScheduler()
+        : GameTask(true),
+        mJobQueue(), 
+        mAddedJobs(),
+        mTokenThreshold(JP_NORMAL), 
+        mTicketCounter(0)
+    {
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+    }
+
+    JobScheduler::~JobScheduler()
+    {
+    }
+
+    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
+        JobListener* listener)
+    {
+        unsigned long ticket = ++mTicketCounter;
+        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+            job-&gt;getTimeSource());
+        unsigned long clock = ts-&gt;getClock();
+        unsigned long start = clock + delay*1000;
+        unsigned long end = maxRuntime &gt;= Math::POS_INFINITY ?
+            0xffffffff : static_cast&lt;unsigned long&gt;(start + maxRuntime*1000);
+        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job-&gt;getTimeSource(), false, false};
+        mAddedJobs.push_back(entry);
+        return ticket;
+    }
+
+    void JobScheduler::run(Ogre::Real time)
+    {
+        ///@todo use different buckets for jobs not yet started, instead of
+        ///      iterating over those each time.
+
+        ///@todo dynamically determine token threshold. Maybe make it work load depending.
+
+
+        // Queue for finished jobs
+        JobQueue notDone;
+
+        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
+        {
+            JobEntry entry = *it;
+
+            TimeSource::TimeSourceType tst = entry.job-&gt;getTimeSource();
+            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
+            Time clock = ts-&gt;getClock();
+            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
+            {
+                entry.timeLastCall = clock;
+                entry.timeSourceLastCall = tst;
+            }
+
+            if (entry.markedToRemove)
+            {
+                // Notify listener, the job was removed
+                if (entry.listener != NULL)
+                {
+                    entry.listener-&gt;jobRemoved(entry.ticket);
+                }
+
+                if (entry.job-&gt;destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+            else if (entry.start &lt;= clock &amp;&amp; clock &lt; entry.end)
+            {
+                // Is the token threshold reached?
+                if (entry.tokens &gt;= mTokenThreshold)
+                {
+                    // Yes, pay run fee and execute.
+                    entry.tokens = 0;
+                    bool runAgain = !entry.job-&gt;execute(clock - entry.timeLastCall);
+
+                    if (!entry.called)
+                    {
+                        // Notify listener, the job started for the first time
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener-&gt;jobStarted(entry.ticket);
+                        }
+                        entry.called = true;
+                    }
+
+                    if (runAgain)
+                    {
+                        // Job is not done, reset token count and requeue.
+                        entry.tokens = entry.priority;
+                        entry.timeLastCall = clock;
+                        notDone.push_back(entry);
+                    }
+                    else
+                    {
+                        // Notify listener, the job finished regularly.
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener-&gt;jobFinished(entry.ticket);
+                        }
+
+                        // If we are supposed to delete the Job, do so now.
+                        if (entry.job-&gt;destroyWhenDone())
+                        {
+                            delete entry.job;
+                        }
+                    }
+                }
+                else
+                {
+                    // No, increase token count
+                    entry.tokens += entry.priority;
+                    notDone.push_back(entry);
+                }
+            }
+            else if (clock &lt; entry.end)
+            {
+                // Start time not yet reached. Queue again.
+                notDone.push_back(entry);
+            }
+            else
+            {
+                // Job reached its end time and didn't want to finish itself, so we do it.
+                if (entry.job-&gt;isDiscardable())
+                {
+                    entry.job-&gt;discard();
+                    if (entry.listener != NULL)
+                    {
+                        entry.listener-&gt;jobDiscarded(entry.ticket);
+                    }
+                }
+                if (entry.job-&gt;destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+        }
+
+        // Copy requeued jobs for next run.
+        mJobQueue = notDone;
+		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
+		mAddedJobs.clear();
+    }
+
+    void JobScheduler::removeJob(unsigned long ticket)
+    {
+        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+            std::bind2nd(FindJobEntryByTicket(), ticket));
+        if (it != mJobQueue.end())
+        {
+            //mRemovedJobs.push_back(*it);
+            (*it).markedToRemove = true;
+        }
+        else
+        {
+			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
+				std::bind2nd(FindJobEntryByTicket(), ticket));
+			if (it != mAddedJobs.end())
+			{
+				mAddedJobs.erase(it);
+			}
+			else
+			{
+				///@todo Log missing job for the ticket.
+			}
+        }
+    }
+
+    const Ogre::String&amp; JobScheduler::getName() const
+    {
+        static Ogre::String NAME = &quot;JobScheduler&quot;;
+
+        return NAME;
+    }
+
+    using namespace XERCES_CPP_NAMESPACE;
+
+    void JobScheduler::writeData(SaveGameFileWriter* writer)
+    {
+        DOMElement* jobSchedulerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+
+        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
+        {
+            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT &amp;&amp; !(iter-&gt;markedToRemove) )
+            {
+                DOMElement* jobNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), jobSchedulerParentNode, &quot;job&quot;);
+                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;priority&quot;, iter-&gt;priority);
+                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;tokens&quot;, iter-&gt;tokens);
+                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;start&quot;, iter-&gt;start);
+                writer-&gt;setAttributeValueAsInteger(jobNode, &quot;end&quot;, iter-&gt;end);
+                writer-&gt;setAttributeValueAsInt64(jobNode, &quot;timeLastCall&quot;, iter-&gt;timeLastCall);
+                writer-&gt;setAttributeValueAsBool(jobNode, &quot;called&quot;, iter-&gt;called);
+                writer-&gt;setAttributeValueAsString(jobNode, &quot;classname&quot;, iter-&gt;job-&gt;getClassName());
+                CeGuiString timeSource = &quot;unknown&quot;;
+                switch (iter-&gt;job-&gt;getTimeSource())
+                {
+                    case TimeSource::GAMETIME:
+                        timeSource = &quot;gametime&quot;;
+                        break;
+                    case TimeSource::REALTIME_CONTINUOUS:
+                        timeSource = &quot;realtime_continuous&quot;;
+                        break;
+                    case TimeSource::REALTIME_INTERRUPTABLE:
+                        timeSource = &quot;realtime_interruptable&quot;;
+                        break;
+                }
+                writer-&gt;setAttributeValueAsString(jobNode, &quot;time&quot;, timeSource);
+
+                PropertyMap map = iter-&gt;job-&gt;getAllProperties()-&gt;toPropertyMap();
+                writer-&gt;writeEachPropertyToElem(jobNode, map);
+            }
+        }
+    }
+
+    void JobScheduler::readData(SaveGameFileReader* reader)
+    {
+        // delete and discard old jobs
+        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
+        {
+            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT )
+            {
+                // delete the job, but do not discard it!
+                iter-&gt;markedToRemove = true;
+            }
+            else if( iter-&gt;job-&gt;getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
+            {
+                // discard the job, then delete it
+                if( iter-&gt;job-&gt;isDiscardable() )
+                    iter-&gt;job-&gt;discard();
+                iter-&gt;markedToRemove = true;
+            }
+        }
+
+        
+        // load jobs from savegamefile
+
+        reader-&gt;initializeXml();
+
+
+        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+        
+        if(rootNodeList-&gt;getLength())
+        {
+            DOMNodeList* xmlJobs = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;job&quot;).data());
+            if (xmlJobs-&gt;getLength())
+            {
+                for (XMLSize_t childIdx1 = 0; childIdx1 &lt; xmlJobs-&gt;getLength(); childIdx1++)
+                {
+                    DOMNode* xmlJob_ = xmlJobs-&gt;item(childIdx1);
+                    if (xmlJob_-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+                    {
+                        DOMElement* xmlJob = static_cast&lt;DOMElement*&gt;(xmlJob_);
+                        JobPriority priority;
+                        unsigned short tokens;
+                        int start, end;
+                        Time timeLastCall;
+                        bool called;
+                        priority = JobPriority(reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;priority&quot;));
+                        tokens = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;tokens&quot;);
+                        start = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;start&quot;);
+                        end = reader-&gt;getAttributeValueAsInteger(xmlJob, &quot;end&quot;);
+                        timeLastCall = reader-&gt;getAttributeValueAsInt64(xmlJob, &quot;timeLastCall&quot;);
+                        called = reader-&gt;getAttributeValueAsBool(xmlJob, &quot;called&quot;);
+
+                        Ogre::String className = reader-&gt;getAttributeValueAsStdString(xmlJob, &quot;classname&quot;);
+
+                        JobCreationMap::iterator it = mJobCreationMap.find(className);
+                        if (it == mJobCreationMap.end())
+                        {
+                            LOG_ERROR(Logger::CORE, &quot;Die Job-Klasse '&quot; + className + &quot;' ist nicht beim JobScheduler registriert!&quot;);
+                            continue;
+                        }
+
+                        AbstractJob* job = it-&gt;second();
+                        if (job == NULL)
+                        {
+                            LOG_ERROR(Logger::CORE, &quot;Fehler beim Erstellen eines Objekts der Job-Klasse '&quot; + className + &quot;'!&quot;);
+                            continue;
+                        }
+                        PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(xmlJob);
+                        job-&gt;setProperties(properties);
+                        
+                        CeGuiString timeSourceStr = reader-&gt;getAttributeValueAsString(xmlJob, &quot;time&quot;);
+                        TimeSource::TimeSourceType ts = TimeSource::UNKNOWN;
+                        if (timeSourceStr == &quot;gametime&quot;) 
+                        {
+                            ts = TimeSource::GAMETIME;
+                        }
+                        else if (timeSourceStr == &quot;realtime_continuous&quot;) 
+                        {
+                            ts = TimeSource::REALTIME_CONTINUOUS;
+                        }
+                        else if (timeSourceStr == &quot;realtime_interruptable&quot;) 
+                        {
+                            ts = TimeSource::REALTIME_INTERRUPTABLE;
+                        }
+                        
+                        unsigned long ticket = ++mTicketCounter;
+                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, ts, called, false};
+                        mJobQueue.push_back(entry);
+                    }
+                }
+            }
+        }
+
+        reader-&gt;shutdownXml();
+    }
+
+    int JobScheduler::getPriority() const
+    {
+        return 0; // must be loaded before triggers!
+    }
+
+    CeGuiString JobScheduler::getXmlNodeIdentifier() const
+    {
+        static const CeGuiString name = &quot;jobscheduler&quot;;
+        return name;
+    }
+
+    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
+}

Modified: rl/branches/newton20/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ListenerMovable.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/ListenerMovable.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -203,4 +203,9 @@
 	mActive = active;
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
 }
+
+}

Modified: rl/branches/newton20/engine/core/src/MovableText.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/MovableText.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/MovableText.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -554,4 +554,11 @@
     {
         return mAlignment;
     }
+
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+	{
+		visitor-&gt;visit(this, 0, debugRenderables);
+	}
 }

Modified: rl/branches/newton20/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -130,8 +130,8 @@
 		if (mBody &amp;&amp; mActor)
 		{
 			mBody-&gt;setPositionOrientation(
-				mActor-&gt;_getSceneNode()-&gt;getWorldPosition(),
-				mActor-&gt;_getSceneNode()-&gt;getWorldOrientation());
+				mActor-&gt;_getSceneNode()-&gt;_getDerivedPosition(),
+				mActor-&gt;_getSceneNode()-&gt;_getDerivedOrientation());
 			mActor-&gt;_update(Actor::UF_ALL &amp; ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/branches/newton20/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -333,8 +333,8 @@
 
 
             body-&gt;attachNode(node);
-            body-&gt;setPositionOrientation(node-&gt;getWorldPosition(),
-                node-&gt;getWorldOrientation());
+            body-&gt;setPositionOrientation(node-&gt;_getDerivedPosition(),
+                node-&gt;_getDerivedOrientation());
             body-&gt;setMaterialGroupID(getMaterialID(&quot;level&quot;));
 
             mLevelBodiesQuadTree.add(body);

Modified: rl/branches/newton20/engine/core/src/Sound.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/Sound.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/Sound.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,148 +1,153 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Sound.h&quot;
-#include &quot;SoundDriver.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-Sound::Sound(const SoundResourcePtr &amp;soundres, SoundDriver* creator)
-: MovableObject(soundres-&gt;getName()),
-   EventSource(),
-   EventCaster&lt;SoundEvent&gt;(),
-   mCreator(creator),
-   mVolume(1.0),
-   mSoundResource(soundres),
-   mIsLooping(false),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0)
-{
-}
-
-Sound::~Sound()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur&#252;ckgeben.
- * @return Der Pointer auf die zugeh&#246;rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &amp;Sound::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox&amp; Sound::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real Sound::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void Sound::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void Sound::setRolloffStartDistance(const Ogre::Real&amp; distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void Sound::setRolloffEndDistance(const Ogre::Real&amp; distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-};
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Sound.h&quot;
+#include &quot;SoundDriver.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+Sound::Sound(const SoundResourcePtr &amp;soundres, SoundDriver* creator)
+: MovableObject(soundres-&gt;getName()),
+   EventSource(),
+   EventCaster&lt;SoundEvent&gt;(),
+   mCreator(creator),
+   mVolume(1.0),
+   mSoundResource(soundres),
+   mIsLooping(false),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0)
+{
+}
+
+Sound::~Sound()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur&#252;ckgeben.
+ * @return Der Pointer auf die zugeh&#246;rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &amp;Sound::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox&amp; Sound::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real Sound::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void Sound::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void Sound::setRolloffStartDistance(const Ogre::Real&amp; distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void Sound::setRolloffEndDistance(const Ogre::Real&amp; distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};

Modified: rl/branches/newton20/engine/core/src/SoundResource.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SoundResource.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/SoundResource.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -85,15 +85,6 @@
 }
 
 /**
- * @author JoSch
- * @date 03-14-2005
- */
-int SoundResource::getSize() const
-{
-    return calculateSize();
-}
-
-/**
  * @author Blakharaz
  * @date 03-14-2005
  */

Modified: rl/branches/newton20/engine/core/src/SoundStitching.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SoundStitching.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/SoundStitching.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,166 +1,171 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;SoundStitching.h&quot;
-#include &quot;SoundDriver.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString&amp; name, SoundDriver* creator)
-:  MovableObject(name.c_str()),
-   EventSource(),
-   EventCaster&lt;SoundEvent&gt;(),
-   mCreator(creator),
-   mVolume(1.0),
-   mName(name),
-   mIsLooping(true),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0),
-   mNumSlots(numSlots)
-{
-}
-
-SoundStitching::~SoundStitching()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur&#252;ckgeben.
- * @return Der Pointer auf die zugeh&#246;rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &amp;SoundStitching::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox&amp; SoundStitching::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real SoundStitching::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void SoundStitching::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void SoundStitching::setRolloffStartDistance(const Ogre::Real&amp; distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void SoundStitching::setRolloffEndDistance(const Ogre::Real&amp; distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-
-void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
-{
-    mSoundCache[label] = sound;
-}
-
-unsigned int SoundStitching::getNumSlots()
-{
-    return mNumSlots;
-}
-
-float SoundStitching::getLength() const
-{
-    return 0.0f;
-}
-
-};
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;SoundStitching.h&quot;
+#include &quot;SoundDriver.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString&amp; name, SoundDriver* creator)
+:  MovableObject(name.c_str()),
+   EventSource(),
+   EventCaster&lt;SoundEvent&gt;(),
+   mCreator(creator),
+   mVolume(1.0),
+   mName(name),
+   mIsLooping(true),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0),
+   mNumSlots(numSlots)
+{
+}
+
+SoundStitching::~SoundStitching()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur&#252;ckgeben.
+ * @return Der Pointer auf die zugeh&#246;rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &amp;SoundStitching::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox&amp; SoundStitching::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real SoundStitching::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void SoundStitching::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void SoundStitching::setRolloffStartDistance(const Ogre::Real&amp; distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void SoundStitching::setRolloffEndDistance(const Ogre::Real&amp; distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+
+void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
+{
+    mSoundCache[label] = sound;
+}
+
+unsigned int SoundStitching::getNumSlots()
+{
+    return mNumSlots;
+}
+
+float SoundStitching::getLength() const
+{
+    return 0.0f;
+}
+
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};
+

Modified: rl/branches/newton20/engine/rules/include/Combat.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combat.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Combat.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -41,7 +41,7 @@
     public:
         typedef std::set&lt;Combatant*&gt; CombatantSet;
 
-        Combat();
+        Combat(Ogre::Real maxDistance = 10.0f);
         ~Combat();
 
         void addOpponent(Combatant*);
@@ -54,8 +54,9 @@
 
         void removeAlly(Combatant*);
 
-        const CombatantSet&amp; getAllOpponents() const;
-        const CombatantSet&amp; getAllAllies() const;
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet&amp; getAllPlayerOpponents() const;
+        const CombatantSet&amp; getAllPlayerAllies() const;
 
         void start();
         void pause();
@@ -119,6 +120,10 @@
 
         unsigned short mCurrentRound;
 		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
 
 		MessagePump::ScopedConnection mLifeStateChangeConnection;
 
@@ -138,8 +143,9 @@
 		/// destroy combatants owned by this combat instance.
 		void clearRemovedCombatantSet();
 
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
+
         // Message handlers
-
         bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
     };
 }

Modified: rl/branches/newton20/engine/rules/include/Container.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Container.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Container.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -71,8 +71,22 @@
 		 * @return &lt;code&gt;true&lt;/code&gt; if adding was successful, &lt;code&gt;false&lt;/code&gt; otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item, IntPair position = IntPair(0,0));
+
+        /**
+         * Remove an item from the container
+         *
+		 * @param item the item
+         */
         void removeItem(Item* item);
 
+        /**
+         * Remove an item from the container
+         * Note: This method must only be called by Item, use removeItem in all other cases
+         *
+		 * @param item the item
+         */
+        void _doRemoveItem(Item* item);
+
         ItemSet getItems() const;
 
 		int getItemCount() const;

Modified: rl/branches/newton20/engine/rules/include/GameObject.h
===================================================================
--- rl/branches/newton20/engine/rules/include/GameObject.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/GameObject.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -64,6 +64,7 @@
         static const Ogre::String PROPERTY_MASS; 
         static const Ogre::String PROPERTY_ACTIONS; 
         static const Ogre::String PROPERTY_DEFAULT_ACTION;
+        static const Ogre::String PROPERTY_IMAGENAME;
 
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
@@ -82,6 +83,9 @@
         const CeGuiString&amp; getDescription() const;
         void setDescription(const CeGuiString&amp; description);
 
+		const CeGuiString&amp; getImageName() const;
+		void setImageName(const CeGuiString&amp; name);
+        
         const CeGuiString&amp; getMeshfile() const;
         void setMeshfile(const CeGuiString&amp; meshfile);
 
@@ -204,6 +208,7 @@
         
         CeGuiString mName;
         CeGuiString mDescription;
+        CeGuiString mImageName;
         CeGuiString mMeshfile;
 		MeshPartMap mMeshParts;
         CeGuiString mSubmeshPreName;

Modified: rl/branches/newton20/engine/rules/include/Item.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Item.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Item.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,124 +1,119 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __ITEM_H__
-#define __ITEM_H__
-
-#include &quot;GameObject.h&quot;
-
-namespace rl
-{
-	class _RlRulesExport Item;
-    class Slot;
-    class Container;
-
-	typedef std::vector&lt;Item*&gt; ContainerColumn;
-	typedef std::vector&lt;ContainerColumn&gt; ContainerLayout;
-
-
-    /// Aufnehmbare Objekte in der Spielwelt.
-    class _RlRulesExport Item : public GameObject
-    {
-    public:
-		enum ItemType{
-			ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
-			ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
-			ITEMTYPE_RING       = 1 &lt;&lt; 2,
-			ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
-			ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
-			ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
-			ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
-			ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
-			ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
-			ITEMTYPE_BELT       = 1 &lt;&lt; 9,
-			ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
-			ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
-			ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
-			ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
-			ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
-            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
-			ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-		};
-
-
-        static const Ogre::String CLASS_NAME;
-
-        static const Ogre::String PROPERTY_ITEMTYPE;
-        static const Ogre::String PROPERTY_IMAGENAME;
-        static const Ogre::String PROPERTY_SIZE;
-        static const Ogre::String PROPERTY_SUBMESHNAME;
-
-		Item(unsigned int id);
-        virtual ~Item(void);
-
-		void setItemType(ItemType itemType);
-		ItemType getItemType() const;
-
-		const CeGuiString&amp; getImageName() const;
-		void setImageName(const CeGuiString&amp; name);
-
-        const CeGuiString&amp; getSubmeshName() const;
-        void setSubmeshName(const CeGuiString&amp; name);
-
-		/**
-		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden koennen
-		 */
-        virtual bool isContainer() const;
-		
-		std::pair&lt;int,int&gt; getSize() const;
-		void setSize(int width, int height);
-
-
-        /**
-         * F&#252;gt das Verhalten f&#252;r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
-         * @warning Bevor einer der drei States gesetzt wird, sollte zun&#228;chst die Funktion removeOldState
-         * aufgerufen werden, dann m&#252;ssen Owner und ParentSlot/ParentContainer gesetzt werden und
-         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
-         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k&#246;nnen!
-         **/
-        virtual void setState(GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(Slot* slot);
-        Slot* getParentSlot() const;
-
-        void setParentContainer(Container* cont);
-        Container* getParentContainer() const;
-
-        virtual void setOwner(GameObject* go);
-        GameObject* getOwner() const;
-
-        virtual const Property getProperty(const CeGuiString&amp; key) const;
-        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-        void doCreateActor();
-    protected:
-		ItemType mItemType;
-		CeGuiString mImageName;
-        CeGuiString mSubmeshName;
-		std::pair&lt;int,int&gt; mSize;
-        GameObject* mOwner;
-        Slot* mParentSlot;
-        Container* mParentContainer;
-
-		void doLoose();
-	};
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __ITEM_H__
+#define __ITEM_H__
+
+#include &quot;GameObject.h&quot;
+
+namespace rl
+{
+	class _RlRulesExport Item;
+    class Slot;
+    class Container;
+
+	typedef std::vector&lt;Item*&gt; ContainerColumn;
+	typedef std::vector&lt;ContainerColumn&gt; ContainerLayout;
+
+
+    /// Aufnehmbare Objekte in der Spielwelt.
+    class _RlRulesExport Item : public GameObject
+    {
+    public:
+		enum ItemType{
+			ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
+			ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
+			ITEMTYPE_RING       = 1 &lt;&lt; 2,
+			ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
+			ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
+			ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
+			ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
+			ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
+			ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
+			ITEMTYPE_BELT       = 1 &lt;&lt; 9,
+			ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
+			ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
+			ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
+			ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
+			ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
+            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
+			ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+		};
+
+
+        static const Ogre::String CLASS_NAME;
+
+        static const Ogre::String PROPERTY_ITEMTYPE;
+        static const Ogre::String PROPERTY_SIZE;
+        static const Ogre::String PROPERTY_SUBMESHNAME;
+
+		Item(unsigned int id);
+        virtual ~Item(void);
+
+		void setItemType(ItemType itemType);
+		ItemType getItemType() const;
+
+        const CeGuiString&amp; getSubmeshName() const;
+        void setSubmeshName(const CeGuiString&amp; name);
+
+		/**
+		 * @return ob es sich um ein Item handelt,
+		 * in dem andere gespeichert werden koennen
+		 */
+        virtual bool isContainer() const;
+		
+		std::pair&lt;int,int&gt; getSize() const;
+		void setSize(int width, int height);
+
+
+        /**
+         * F&#194;&#184;gt das Verhalten f&#194;&#184;r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
+         * @warning Bevor einer der drei States gesetzt wird, sollte zun&#226;&#128;&#176;chst die Funktion removeOldState
+         * aufgerufen werden, dann m&#194;&#184;ssen Owner und ParentSlot/ParentContainer gesetzt werden und
+         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
+         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k&#203;&#134;nnen!
+         **/
+        virtual void setState(GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(Slot* slot);
+        Slot* getParentSlot() const;
+
+        void setParentContainer(Container* cont);
+        Container* getParentContainer() const;
+
+        virtual void setOwner(GameObject* go);
+        GameObject* getOwner() const;
+
+        virtual const Property getProperty(const CeGuiString&amp; key) const;
+        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+        void doCreateActor();
+    protected:
+		ItemType mItemType;
+        CeGuiString mSubmeshName;
+		std::pair&lt;int,int&gt; mSize;
+        GameObject* mOwner;
+        Slot* mParentSlot;
+        Container* mParentContainer;
+
+		void doLoose();
+	};
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/PartyManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/PartyManager.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/PartyManager.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -25,11 +25,11 @@
 {
     class Creature;
 
+    typedef std::vector&lt;Creature*&gt; Party;
+
     class _RlRulesExport PartyManager : public Ogre::Singleton&lt;PartyManager&gt;
     {
     public:
-		typedef std::vector&lt;Creature*&gt; Party;
-
 		PartyManager();
         
         Creature* getActiveCharacter() const;

Modified: rl/branches/newton20/engine/rules/src/Combat.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combat.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Combat.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -59,7 +59,7 @@
         }
     };
 
-    Combat::Combat()
+    Combat::Combat(Ogre::Real maxDistance)
         : mOwnedCombatants(),
 		  mOpponents(),
           mAllies(),
@@ -70,7 +70,8 @@
 		  mRemovedCombatants(),
           mCurrentRound(0),
 		  mNextActionId(0),
-		  mAnimationSequenceTicket(0)
+		  mAnimationSequenceTicket(0),
+		  mMaxDistance(maxDistance)
     {
         LOG_MESSAGE(&quot;Combat&quot;, &quot;Register message handler&quot;);
 		mLifeStateChangeConnection =
@@ -165,16 +166,31 @@
 		mRemovedCombatants.clear();
 	}
 
-    const Combat::CombatantSet&amp; Combat::getAllOpponents() const
+    const Combat::CombatantSet&amp; Combat::getAllPlayerOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CombatantSet&amp; Combat::getAllAllies() const
+    const Combat::CombatantSet&amp; Combat::getAllPlayerAllies() const
     {
         return mAllies;
     }
 
+    const Combat::CombatantSet Combat::getAllOpponents(Combatant* combatant) const
+    {
+        if (mOpponents.find(combatant) != mOpponents.end())
+        {
+            return mAllies;
+        }
+        
+        if (mAllies.find(combatant) != mAllies.end())
+        {
+            return mOpponents;
+        }
+        
+        return Combat::CombatantSet(); // not in combat -&gt; no opponents
+    }
+
     void Combat::start()
     {
 		GameEventLog::getSingleton().logEvent(&quot;Kampf beginnt.&quot;, GET_COMBAT);
@@ -384,6 +400,25 @@
     void Combat::endRound()
     {
 		clearRemovedCombatantSet();
+
+        // check for fleeing from combat
+        for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mOpponents))
+            {
+                removeAlly(*it);
+            }
+        }
+        for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mAllies))
+            {
+                removeOpponent(*it);
+            }
+        }
+
+		clearRemovedCombatantSet();
+
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -544,4 +579,19 @@
 		}
 		return false;
 	}
+
+	bool Combat::isOutOfCombatRange(Combatant* combatant, const Combat::CombatantSet&amp; enemies) const
+	{
+		Vector3 pos = combatant-&gt;getPosition();
+		Ogre::Real sqD = mMaxDistance * mMaxDistance;
+		for (CombatantSet::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+		{
+			if (pos.squaredDistance((*it)-&gt;getPosition()) &lt;= sqD)
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
 }

Modified: rl/branches/newton20/engine/rules/src/Container.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Container.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Container.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -168,16 +168,25 @@
 		}
     }
 
-    void Container::removeItem(Item* item)
+    void Container::_doRemoveItem(Item* item)
     {
         ItemSet::iterator it = mItems.find(item);
         if (it != mItems.end())
         {
             mItems.erase(it);
             mItemPositions.erase(mItemPositions.find(item));
-            
-            // this is the case, if the item is removed automatically
-            // don't change this without looking at Item::setState
+        }
+        else
+        {
+            Throw(IllegalArgumentException, &quot;Item not in Container.&quot;);
+        }
+    }
+
+    void Container::removeItem(Item* item)
+    {
+        ItemSet::iterator it = mItems.find(item);
+        if (it != mItems.end())
+        {
             item-&gt;removeOldState();
             item-&gt;setScene(&quot;&quot;);
         }

Modified: rl/branches/newton20/engine/rules/src/GameObject.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GameObject.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/GameObject.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -57,11 +57,13 @@
     const Ogre::String GameObject::PROPERTY_MASS = &quot;mass&quot;;
     const Ogre::String GameObject::PROPERTY_ACTIONS = &quot;actions&quot;;
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = &quot;defaultaction&quot;;
-
+    const Ogre::String GameObject::PROPERTY_IMAGENAME = &quot;imagename&quot;;
+    
     GameObject::GameObject(unsigned int id)
         :   mId(id),
             mName(&quot;&quot;),
             mDescription(&quot;&quot;),
+            mImageName(&quot;&quot;),
             mMeshfile(&quot;&quot;),
 			mMeshParts(),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
@@ -141,6 +143,16 @@
         mDescription = description;
     }
 
+	void GameObject::setImageName(const CeGuiString&amp; name)
+	{
+		mImageName = name;
+	}
+    
+	const CeGuiString&amp; GameObject::getImageName() const
+	{
+		return mImageName;
+	}
+    
     const CeGuiString&amp; GameObject::getMeshfile() const
     {
         return mMeshfile;
@@ -540,6 +552,10 @@
         {
             prop.setValue(mDescription);
         }
+        else if (key == PROPERTY_IMAGENAME)
+        {
+            prop.setValue(mImageName);
+        }
         else if (key == PROPERTY_MESHFILE)
         {
             prop.setValue(mMeshfile);
@@ -594,6 +610,10 @@
             {
                 setDescription(value.toString());
             }
+            else if (key == PROPERTY_IMAGENAME)
+            {
+                setImageName(value.toString());
+            }
             else if (key == PROPERTY_MESHFILE)
             {
                 setMeshfile(value.toString());
@@ -682,6 +702,7 @@
         keys.insert(PROPERTY_MESHPARTS);
         keys.insert(PROPERTY_GEOMETRY_TYPE);
         keys.insert(PROPERTY_MASS);
+        keys.insert(PROPERTY_IMAGENAME);
         return keys;
     }
 

Modified: rl/branches/newton20/engine/rules/src/Item.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Item.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Item.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,278 +1,258 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Item.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;Slot.h&quot;
-#include &quot;GameObjectManager.h&quot;
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Item::CLASS_NAME = &quot;Item&quot;;
-
-    const Ogre::String Item::PROPERTY_IMAGENAME = &quot;imagename&quot;;
-    const Ogre::String Item::PROPERTY_ITEMTYPE = &quot;itemtype&quot;;
-    const Ogre::String Item::PROPERTY_SIZE = &quot;size&quot;;
-    const Ogre::String Item::PROPERTY_SUBMESHNAME = &quot;submeshfile&quot;;
-
-    Item::Item(unsigned int id)
-        : GameObject(id),
-		mItemType(ITEMTYPE_OTHER),
-		mImageName(&quot;&quot;),
-		mSize(pair&lt;int,int&gt;(1,1)),
-        mOwner(NULL),
-        mParentSlot(NULL),
-        mParentContainer(NULL),
-        mSubmeshName(&quot;&quot;)
-    {
-        mQueryFlags |= QUERYFLAG_ITEM;
-    }
-
-    Item::~Item(void)
-    {
-        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
-    }
-
-	void Item::setItemType(ItemType itemType)
-	{
-		mItemType = itemType;
-	}
-
-	Item::ItemType Item::getItemType() const
-	{
-		return mItemType;
-	}
-
-	void Item::setImageName(const CeGuiString&amp; name)
-	{
-		mImageName = name;
-	}
-
-	const CeGuiString&amp; Item::getImageName() const
-	{
-		return mImageName;
-	}
-
-	bool Item::isContainer() const
-	{
-		return false;
-	}
-
-	pair&lt;int,int&gt; Item::getSize() const
-	{
-		return mSize;
-	}
-
-	void Item::setSize(int widthSize,int heightSize)
-	{
-		mSize = pair&lt;int,int&gt;(widthSize,heightSize);
-	}
-
-    void Item::doLoose()
-    {
-        if (mActor != NULL)
-        {
-            mActor-&gt;detachFromParent();
-        }
-        if (mParentContainer != NULL)
-        {
-            mParentContainer-&gt;removeItem(this);
-            mParentContainer = NULL;
-        }
-        if (mParentSlot != NULL)
-        {
-            mParentSlot-&gt;setItem(NULL);
-            mParentSlot = NULL;
-        }
-        setOwner(NULL);
-    }
-
-    void Item::removeOldState()
-    {
-        setState(GOS_LOADED);
-    }
-
-// --------------- Warning ------------
-// do not change this function without
-// having a look at the containers and slots
-    void Item::setState(GameObjectState targetState)
-    {
-        if (mState == targetState)
-        {
-            return;
-        }
-
-        // do only things that are possible
-        if( targetState &amp; (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) &amp;&amp; mState &amp; (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
-        {
-            LOG_ERROR(Logger::RULES,
-                &quot;Item '&quot; + getName() + &quot;' could not change state from '&quot;
-                + Ogre::StringConverter::toString(mState) + &quot;' to state '&quot;
-                + Ogre::StringConverter::toString(targetState) + &quot;'!&quot;
-                + &quot;\nYou need to call 'Item::removeOldState()' first.&quot;);
-            
-            // first remove the old state (thats a recursive function call)
-            //removeOldState();
-        }
-
-        // everything else is not handled here, so give it to the parent
-        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
-            &amp;&amp; (mState == GOS_IN_SCENE || mState == GOS_LOADED))
-        {
-            GameObject::setState(targetState);
-            return;
-        }
-
-        GameObjectState oldState = mState;
-        onBeforeStateChange(oldState, targetState);        
-
-        if (targetState == GOS_LOADED 
-            &amp;&amp; (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
-        {
-            mState = targetState; // this is needed here to prevent an endless recursion
-            // &quot;remove old state&quot;
-            doLoose();
-            destroyActor();
-        }
-        else if (mState == GOS_LOADED &amp;&amp;
-                 (targetState == GOS_HELD || targetState == GOS_READY))
-        {
-            createActor();
-            mState = targetState;
-            // do nothing, the user has to do what he needs himself
-        }
-        else if ((mState == GOS_LOADED &amp;&amp; targetState == GOS_IN_POSSESSION)
-            || (mState == GOS_IN_POSSESSION &amp;&amp; targetState == GOS_LOADED))
-        {
-            mState = targetState;
-        }
-        else
-        {
-            Throw(rl::IllegalStateException, &quot;Unhandled state change&quot;);
-        }
-
-        onAfterStateChange(oldState, targetState);
-        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
-    }
-
-    void Item::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            mImageName = value.toString();
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            mSize = value.toIntPair();
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            mItemType = static_cast&lt;Item::ItemType&gt;(value.toInt());
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            mSubmeshName = value.toString();
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Item::getProperty(const CeGuiString&amp; key) const
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            return Property(mImageName);
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            return Property(mSize);
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            return Property(mItemType);
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            return Property(mSubmeshName);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Item::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Item::PROPERTY_IMAGENAME);
-        keys.insert(Item::PROPERTY_SIZE);
-        keys.insert(Item::PROPERTY_ITEMTYPE);
-        return keys;
-    }
-
-    void Item::setOwner(GameObject* owner)
-    {
-        mOwner = owner;
-    }
-
-    GameObject* Item::getOwner() const
-    {
-        return mOwner;
-    }
-
-    void Item::setParentSlot(Slot* slot)
-    {
-        mParentSlot = slot;
-    }
-
-    Slot* Item::getParentSlot() const
-    {
-        return mParentSlot;
-    }
-
-    void Item::doCreateActor()
-    {
-        setActor(createActor());
-    }
-
-    void Item::setParentContainer(Container* cont)
-    {
-        mParentContainer = cont;
-    }
-
-    Container* Item::getParentContainer() const
-    {
-        return mParentContainer;
-    }
-
-    const CeGuiString&amp; Item::getSubmeshName() const
-    {
-        return mSubmeshName;
-    }
-
-    void Item::setSubmeshName(const CeGuiString&amp; name)
-    {
-        mSubmeshName = name;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Item.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;Slot.h&quot;
+#include &quot;GameObjectManager.h&quot;
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Item::CLASS_NAME = &quot;Item&quot;;
+
+    const Ogre::String Item::PROPERTY_ITEMTYPE = &quot;itemtype&quot;;
+    const Ogre::String Item::PROPERTY_SIZE = &quot;size&quot;;
+    const Ogre::String Item::PROPERTY_SUBMESHNAME = &quot;submeshfile&quot;;
+
+    Item::Item(unsigned int id)
+        : GameObject(id),
+		mItemType(ITEMTYPE_OTHER),
+		mSize(pair&lt;int,int&gt;(1,1)),
+        mOwner(NULL),
+        mParentSlot(NULL),
+        mParentContainer(NULL),
+        mSubmeshName(&quot;&quot;)
+    {
+        mQueryFlags |= QUERYFLAG_ITEM;
+    }
+
+    Item::~Item(void)
+    {
+        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
+    }
+
+	void Item::setItemType(ItemType itemType)
+	{
+		mItemType = itemType;
+	}
+
+	Item::ItemType Item::getItemType() const
+	{
+		return mItemType;
+	}
+
+	bool Item::isContainer() const
+	{
+		return false;
+	}
+
+	pair&lt;int,int&gt; Item::getSize() const
+	{
+		return mSize;
+	}
+
+	void Item::setSize(int widthSize,int heightSize)
+	{
+		mSize = pair&lt;int,int&gt;(widthSize,heightSize);
+	}
+
+    void Item::doLoose()
+    {
+        if (mActor != NULL)
+        {
+            mActor-&gt;detachFromParent();
+        }
+        if (mParentContainer != NULL)
+        {
+            mParentContainer-&gt;_doRemoveItem(this);
+            mParentContainer = NULL;
+        }
+        if (mParentSlot != NULL)
+        {
+            mParentSlot-&gt;setItem(NULL);
+            mParentSlot = NULL;
+        }
+        setOwner(NULL);
+    }
+
+    void Item::removeOldState()
+    {
+        setState(GOS_LOADED);
+    }
+
+// --------------- Warning ------------
+// do not change this function without
+// having a look at the containers and slots
+    void Item::setState(GameObjectState targetState)
+    {
+        if (mState == targetState)
+        {
+            return;
+        }
+
+        // do only things that are possible
+        if( targetState &amp; (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) &amp;&amp; mState &amp; (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
+        {
+            LOG_ERROR(Logger::RULES,
+                &quot;Item '&quot; + getName() + &quot;' could not change state from '&quot;
+                + Ogre::StringConverter::toString(mState) + &quot;' to state '&quot;
+                + Ogre::StringConverter::toString(targetState) + &quot;'!&quot;
+                + &quot;\nYou need to call 'Item::removeOldState()' first.&quot;);
+            
+            // first remove the old state (thats a recursive function call)
+            //removeOldState();
+        }
+
+        // everything else is not handled here, so give it to the parent
+        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
+            &amp;&amp; (mState == GOS_IN_SCENE || mState == GOS_LOADED))
+        {
+            GameObject::setState(targetState);
+            return;
+        }
+
+        GameObjectState oldState = mState;
+        onBeforeStateChange(oldState, targetState);        
+
+        if (targetState == GOS_LOADED 
+            &amp;&amp; (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
+        {
+            mState = targetState; // this is needed here to prevent an endless recursion
+            // &quot;remove old state&quot;
+            doLoose();
+            destroyActor();
+        }
+        else if (mState == GOS_LOADED &amp;&amp;
+                 (targetState == GOS_HELD || targetState == GOS_READY))
+        {
+            createActor();
+            mState = targetState;
+            // do nothing, the user has to do what he needs himself
+        }
+        else if ((mState == GOS_LOADED &amp;&amp; targetState == GOS_IN_POSSESSION)
+            || (mState == GOS_IN_POSSESSION &amp;&amp; targetState == GOS_LOADED))
+        {
+            mState = targetState;
+        }
+        else
+        {
+            Throw(rl::IllegalStateException, &quot;Unhandled state change&quot;);
+        }
+
+        onAfterStateChange(oldState, targetState);
+        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
+    }
+
+    void Item::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            mSize = value.toIntPair();
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            mItemType = static_cast&lt;Item::ItemType&gt;(value.toInt());
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            mSubmeshName = value.toString();
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Item::getProperty(const CeGuiString&amp; key) const
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            return Property(mSize);
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            return Property(mItemType);
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            return Property(mSubmeshName);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Item::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Item::PROPERTY_SUBMESHNAME);
+        keys.insert(Item::PROPERTY_SIZE);
+        keys.insert(Item::PROPERTY_ITEMTYPE);
+        return keys;
+    }
+
+    void Item::setOwner(GameObject* owner)
+    {
+        mOwner = owner;
+    }
+
+    GameObject* Item::getOwner() const
+    {
+        return mOwner;
+    }
+
+    void Item::setParentSlot(Slot* slot)
+    {
+        mParentSlot = slot;
+    }
+
+    Slot* Item::getParentSlot() const
+    {
+        return mParentSlot;
+    }
+
+    void Item::doCreateActor()
+    {
+        setActor(createActor());
+    }
+
+    void Item::setParentContainer(Container* cont)
+    {
+        mParentContainer = cont;
+    }
+
+    Container* Item::getParentContainer() const
+    {
+        return mParentContainer;
+    }
+
+    const CeGuiString&amp; Item::getSubmeshName() const
+    {
+        return mSubmeshName;
+    }
+
+    void Item::setSubmeshName(const CeGuiString&amp; name)
+    {
+        mSubmeshName = name;
+    }
+}

Modified: rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -222,8 +222,8 @@
 
 	void PlaneReflectionTextureListener::preRenderTargetUpdate(const RenderTargetEvent &amp;evt)
 	{
-		mCamera-&gt;setPosition(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldPosition());
-		mCamera-&gt;setOrientation(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldOrientation());
+		mCamera-&gt;setPosition(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getDerivedPosition());
+		mCamera-&gt;setOrientation(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getDerivedOrientation());
 		mEntity-&gt;setVisible(false);
 		mCamera-&gt;enableReflection((MovablePlane*)mPlane);
 	}
@@ -242,8 +242,8 @@
 
 	void PlaneRefractionTextureListener::preRenderTargetUpdate(const Ogre::RenderTargetEvent&amp; evt)
 	{
-		mCamera-&gt;setPosition(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldPosition());
-		mCamera-&gt;setOrientation(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldOrientation());
+		mCamera-&gt;setPosition(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getDerivedPosition());
+		mCamera-&gt;setOrientation(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getDerivedOrientation());
 		mEntity-&gt;setVisible(false);
 	}
 

Modified: rl/branches/newton20/engine/script/swig/RlUi.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlUi.swig	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/script/swig/RlUi.swig	2008-11-30 22:46:52 UTC (rev 4616)
@@ -103,6 +103,7 @@
     void toggleConsole();
     void toggleDebugWindow();
     void toggleGameLogWindow();
+    void toggleCharacterSelectionWindow();
     void toggleCharacterStateWindow();
     void toggleInGameGlobalMenu();
     void toggleInventoryWindow();

Modified: rl/branches/newton20/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,140 +1,142 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __AbstractWindow_H__
-#define __AbstractWindow_H__
-
-#include &quot;UiPrerequisites.h&quot;
-
-
-#include &lt;CEGUIWindow.h&gt;
-#include &lt;elements/CEGUIEditbox.h&gt;
-#include &lt;elements/CEGUIListbox.h&gt;
-#include &lt;elements/CEGUIMultiColumnList.h&gt;
-#include &lt;elements/CEGUIMultiLineEditbox.h&gt;
-#include &lt;elements/CEGUIProgressBar.h&gt;
-#include &lt;elements/CEGUIMenuBase.h&gt;
-#include &lt;elements/CEGUIMenuItem.h&gt;
-#include &lt;elements/CEGUIPushButton.h&gt;
-#include &lt;elements/CEGUICombobox.h&gt;
-#include &lt;elements/CEGUIComboDropList.h&gt;
-#include &lt;elements/CEGUIScrollablePane.h&gt;
-#include &lt;elements/CEGUISlider.h&gt;
-#include &lt;elements/CEGUITabControl.h&gt;
-
-namespace rl {
-
-	class WindowUpdateTask;
-
-	/**
-	 * This is the base class for all UI windows
-	 */
-	class _RlUiExport AbstractWindow
-	{
-	public:
-
-		enum WindowInputType
-		{
-			WIT_NONE = 0x00,
-			WIT_MOUSE_INPUT = 0x01,
-			WIT_KEYBOARD_INPUT = 0x02
-		};
-
-		virtual ~AbstractWindow();	
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString&amp; xmlfile);
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString&amp; xmlfile, CeGuiString&amp; prefix);
-
-		/// gets the CEGUI root
-		static CEGUI::Window* getRoot();
-
-		/// gets the wrapped CEGUI window
-		CEGUI::Window* getWindow();
-
-		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
-		CEGUI::Editbox* getEditbox(const char* name);
-		CEGUI::Listbox* getListbox(const char* name);
-		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
-		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
-		CEGUI::ProgressBar* getProgressBar(const char* name);
-		CEGUI::MenuBase* getMenu(const char* name);
-		CEGUI::MenuItem* getMenuItem(const char* name);
-		CEGUI::PushButton* getPushButton(const char* name);
-		CEGUI::Combobox* getCombobox(const char* name);
-		CEGUI::ComboDropList* getComboDropList(const char* name);
-        CEGUI::ScrollablePane* getScrollablePane(const char* name);
-		CEGUI::Slider* getSlider(const char* name);
-		CEGUI::TabControl* getTabControl(const char* name);
-
-		int getWindowInputType();
-
-        virtual bool isVisible();
-        virtual void setVisible(bool visible, bool destroyAfterHide = false);
-
-		bool isModal();
-		bool isClosingOnEscape();
-
-		const CeGuiString&amp; getName() const;
-		const Ogre::Real&amp; getNormalAlpha() const;
-
-		virtual void windowHid();
-
-        // return true, if the specified key should be repeated if pressed down
-        virtual bool wantsKeyToRepeat(const int &amp;key) {return false;}
-
-	protected:
-		AbstractWindow(
-			const CeGuiString&amp; xmlfile, 
-			int inputType, 
-			bool closeOnEscape = true,
-			bool modal = false);
-
-		const CeGuiString&amp; getNamePrefix() const;
-		
-		void centerWindow();
-		bool destroyWindow();		
-		bool hideWindow();
-
-		void bindDestroyWindowToClick(CEGUI::Window* button);
-        void bindHideWindowToClick(CEGUI::Window* button);
-		void bindDestroyWindowToXButton();
-		void bindHideWindowToXButton();
-
-		const CeGuiString&amp; getUserDataType(CEGUI::Window* window) const;
-		void setUserDataType(CEGUI::Window* window, const CeGuiString&amp; typeDescription) const;
-
-		CEGUI::Window* mWindow;
-		bool mVisible;
-
-	private:
-		
-		int mWindowInputType;
-		CeGuiString mNamePrefix;
-		CeGuiString mName;
-		bool mModal;
-		bool mCloseOnEscape;
-		Ogre::Real mNormalAlpha;
-
-		static int sNumAbstractWindows;
-
-	};
-
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __AbstractWindow_H__
+#define __AbstractWindow_H__
+
+#include &quot;UiPrerequisites.h&quot;
+
+
+#include &lt;CEGUIWindow.h&gt;
+#include &lt;elements/CEGUICheckbox.h&gt;
+#include &lt;elements/CEGUIEditbox.h&gt;
+#include &lt;elements/CEGUIListbox.h&gt;
+#include &lt;elements/CEGUIMultiColumnList.h&gt;
+#include &lt;elements/CEGUIMultiLineEditbox.h&gt;
+#include &lt;elements/CEGUIProgressBar.h&gt;
+#include &lt;elements/CEGUIMenuBase.h&gt;
+#include &lt;elements/CEGUIMenuItem.h&gt;
+#include &lt;elements/CEGUIPushButton.h&gt;
+#include &lt;elements/CEGUICombobox.h&gt;
+#include &lt;elements/CEGUIComboDropList.h&gt;
+#include &lt;elements/CEGUIScrollablePane.h&gt;
+#include &lt;elements/CEGUISlider.h&gt;
+#include &lt;elements/CEGUITabControl.h&gt;
+
+namespace rl {
+
+	class WindowUpdateTask;
+
+	/**
+	 * This is the base class for all UI windows
+	 */
+	class _RlUiExport AbstractWindow
+	{
+	public:
+
+		enum WindowInputType
+		{
+			WIT_NONE = 0x00,
+			WIT_MOUSE_INPUT = 0x01,
+			WIT_KEYBOARD_INPUT = 0x02
+		};
+
+		virtual ~AbstractWindow();	
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString&amp; xmlfile);
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString&amp; xmlfile, CeGuiString&amp; prefix);
+
+		/// gets the CEGUI root
+		static CEGUI::Window* getRoot();
+
+		/// gets the wrapped CEGUI window
+		CEGUI::Window* getWindow();
+
+		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
+		CEGUI::Editbox* getEditbox(const char* name);
+		CEGUI::Listbox* getListbox(const char* name);
+		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
+		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
+		CEGUI::ProgressBar* getProgressBar(const char* name);
+		CEGUI::MenuBase* getMenu(const char* name);
+		CEGUI::MenuItem* getMenuItem(const char* name);
+		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::Combobox* getCombobox(const char* name);
+		CEGUI::ComboDropList* getComboDropList(const char* name);
+        CEGUI::ScrollablePane* getScrollablePane(const char* name);
+		CEGUI::Slider* getSlider(const char* name);
+		CEGUI::TabControl* getTabControl(const char* name);
+        CEGUI::Checkbox* getCheckbox(const char* name);
+
+		int getWindowInputType();
+
+        virtual bool isVisible();
+        virtual void setVisible(bool visible, bool destroyAfterHide = false);
+
+		bool isModal();
+		bool isClosingOnEscape();
+
+		const CeGuiString&amp; getName() const;
+		const Ogre::Real&amp; getNormalAlpha() const;
+
+		virtual void windowHid();
+
+        // return true, if the specified key should be repeated if pressed down
+        virtual bool wantsKeyToRepeat(const int &amp;key) {return false;}
+
+	protected:
+		AbstractWindow(
+			const CeGuiString&amp; xmlfile, 
+			int inputType, 
+			bool closeOnEscape = true,
+			bool modal = false);
+
+		const CeGuiString&amp; getNamePrefix() const;
+		
+		void centerWindow();
+		bool destroyWindow();		
+		bool hideWindow();
+
+		void bindDestroyWindowToClick(CEGUI::Window* button);
+        void bindHideWindowToClick(CEGUI::Window* button);
+		void bindDestroyWindowToXButton();
+		void bindHideWindowToXButton();
+
+		const CeGuiString&amp; getUserDataType(CEGUI::Window* window) const;
+		void setUserDataType(CEGUI::Window* window, const CeGuiString&amp; typeDescription) const;
+
+		CEGUI::Window* mWindow;
+		bool mVisible;
+
+	private:
+		
+		int mWindowInputType;
+		CeGuiString mNamePrefix;
+		CeGuiString mName;
+		bool mModal;
+		bool mCloseOnEscape;
+		Ogre::Real mNormalAlpha;
+
+		static int sNumAbstractWindows;
+
+	};
+
+}
+
+#endif

Copied: rl/branches/newton20/engine/ui/include/CharacterSelectionWindow.h (from rev 4613, rl/trunk/engine/ui/include/CharacterSelectionWindow.h)

Modified: rl/branches/newton20/engine/ui/include/CombatGui.h
===================================================================
--- rl/branches/newton20/engine/ui/include/CombatGui.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/CombatGui.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -73,6 +73,8 @@
 		/// Needed to only close it after combat if it was not shown before.
 		bool mGameLoggerWindowOpened;
 
+        bool mVisible;
+
         Ogre::FloatRect getScreenRectFromWorldAabb(const Ogre::AxisAlignedBox&amp; aabb) const;
 	};
 }

Modified: rl/branches/newton20/engine/ui/include/GameSettings.h
===================================================================
--- rl/branches/newton20/engine/ui/include/GameSettings.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/GameSettings.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -82,11 +82,17 @@
 		 * configuration section.
 		 */
 		bool onRenderSystemChanged();
+        
+        void update();
 
 		std::list&lt;SoundDriverConfigComponent*&gt; mSoundDriverConfigs;   //!&lt; List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!&lt; Configuration component of currently selected sound driver
 		std::list&lt;RenderSystemConfigComponent*&gt; mRenderSystemConfigs; //!&lt; List of registered rendersystem configuration components
 		RenderSystemConfigComponent* mCurrentRenderSystemConfig;      //!&lt; Configuration component of currently selected rendersystem
+        
+        CEGUI::Combobox* mVideoRenderer;
+        CEGUI::Combobox* mVideoResolution;
+        CEGUI::Checkbox* mVideoFullscreen;
 	};
 }
 

Modified: rl/branches/newton20/engine/ui/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/include/Makefile.am	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/Makefile.am	2008-11-30 22:46:52 UTC (rev 4616)
@@ -5,6 +5,7 @@
     CeGuiHelper.h \
     CharacterSheetWindow.h \
     CharacterStateWindow.h \
+	CharacterSelectionWindow.h \
     CloseConfirmationWindow.h \
     CombatControlState.h \
     CombatGui.h \

Modified: rl/branches/newton20/engine/ui/include/WindowFactory.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,142 +1,145 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __WindowFactory_H__
-#define __WindowFactory_H__
-
-#include &quot;UiPrerequisites.h&quot;
-
-#include &quot;FixRubyHeaders.h&quot;        // die Makros sind hier vor Ruby schon definiert
-#include &lt;ruby.h&gt;
-#include &quot;FixRubyHeaders.h&quot;
-
-namespace rl {
-
-    class Actor;
-    class AbstractWindow;
-    class CharacterStateWindow;
-    class CharacterSheetWindow;
-    class CloseConfirmationWindow;
-    class CombatWindow;
-    class Console;
-    class Container;
-    class Creature;
-    class DebugWindow;
-    class DialogCharacter;
-    class GameLoggerWindow;
-    class GameObject;
-    class PropertiesWindow;
-    class GameSettings;
-    class InfoPopup;
-    class InGameMenuWindow;
-    class InventoryWindow;
-    class JournalWindow;
-    class LogWindow;
-    class MainMenuWindow;
-    class ObjectDescriptionWindow;
-    class GameSaveLoadWindow;
-    class MainMenuLoadWindow;
-    class WindowUpdater;
-
-    class _RlUiExport WindowFactory : public Ogre::Singleton&lt;WindowFactory&gt;
-    {
-    public:
-        enum PopupIcon
-        {
-            ICON_ERROR = 1,
-            ICON_QUEST
-        };
-
-        WindowFactory();
-        ~WindowFactory();
-
-        void initialize();
-
-        void setActiveCharacter(Creature* character);
-
-        void showActionChoice(GameObject* obj);
-        void showAboutWindow();
-        void showCharacterActionChoice();
-        void showCharacterSheet();
-        void showCharacterSheet(Creature* chara);
-        void showContainerContent(Container* container);
-        void showDescriptionWindow(GameObject* obj);
-        void showPropertiesWindow(GameObject* obj);
-        void showExitConfirmation();
-        void showJournalWindow();
-        void showLogfiles();
-        void showMessageWindow(const CeGuiString&amp; message);
-        void showMainMenu();
-        void showObjectDescription(GameObject* object);
-        void showPlaylist();
-        void showGameSaveLoadWindow();
-        void showMainMenuLoadWindow(MainMenuWindow* win);
-		void hideMainMenuLoadWindow();
-        void showPopupMessage(int popupTypes);
-        void showGameOverWindow();
-        /**
-         * Creates a GameSettings object and displays its layout file on screen
-         */
-        void showGameSettings();
-
-        void toggleConsole();
-        void toggleDebugWindow();
-        void toggleGameLogWindow();
-        void toggleCharacterStateWindow();
-        void toggleInGameGlobalMenu();
-        void toggleInventoryWindow();
-        void notifyInventoryWindowDestroyed();
-		bool isInventoryWindowDestroyed();
-
-        CombatWindow* getCombatWindow();
-
-        void checkForErrors();
-        GameLoggerWindow* getGameLogger();
-
-        void update();
-
-        /// Writes Text into the Console or other output media
-        void writeToConsole(std::string text);
-        static VALUE consoleWrite(VALUE self, VALUE str);
-
-        /// Change shown DebugWindow page
-        void showNextDebugWindowPage();
-
-    private:
-        void logAllWindows();
-
-        GameLoggerWindow* mGameLogger;
-        CharacterStateWindow* mCharacterStateWindow;
-        InGameMenuWindow* mInGameMenuWindow;
-        CharacterSheetWindow* mCharacterSheet;
-        JournalWindow* mJournalWindow;
-        InventoryWindow* mInventoryWindow;
-        LogWindow* mLogWindow;
-        DebugWindow* mDebugWindow;
-        Console* mConsole;
-        InfoPopup* mInfoPopup;
-        Actor* mObjectNameText;
-        GameObject* mShownObject;
-        ObjectDescriptionWindow* mObjectDescriptionWindow;
-        MainMenuWindow* mMainMenuWindow;
-		MainMenuLoadWindow* mMainMenuLoadWindow;
-        CloseConfirmationWindow* mCloseConfirmationWindow;
-        GameSettings* mGameSettings;
-        CombatWindow* mCombatWindow;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __WindowFactory_H__
+#define __WindowFactory_H__
+
+#include &quot;UiPrerequisites.h&quot;
+
+#include &quot;FixRubyHeaders.h&quot;        // die Makros sind hier vor Ruby schon definiert
+#include &lt;ruby.h&gt;
+#include &quot;FixRubyHeaders.h&quot;
+
+namespace rl {
+
+    class Actor;
+    class AbstractWindow;
+    class CharacterSelectionWindow;
+    class CharacterSheetWindow;
+    class CharacterStateWindow;
+    class CloseConfirmationWindow;
+    class CombatWindow;
+    class Console;
+    class Container;
+    class Creature;
+    class DebugWindow;
+    class DialogCharacter;
+    class GameLoggerWindow;
+    class GameObject;
+    class PropertiesWindow;
+    class GameSettings;
+    class InfoPopup;
+    class InGameMenuWindow;
+    class InventoryWindow;
+    class JournalWindow;
+    class LogWindow;
+    class MainMenuWindow;
+    class ObjectDescriptionWindow;
+    class GameSaveLoadWindow;
+    class MainMenuLoadWindow;
+    class WindowUpdater;
+
+    class _RlUiExport WindowFactory : public Ogre::Singleton&lt;WindowFactory&gt;
+    {
+    public:
+        enum PopupIcon
+        {
+            ICON_ERROR = 1,
+            ICON_QUEST
+        };
+
+        WindowFactory();
+        ~WindowFactory();
+
+        void initialize();
+
+        void setActiveCharacter(Creature* character);
+
+        void showActionChoice(GameObject* obj);
+        void showAboutWindow();
+        void showCharacterActionChoice();
+        void showCharacterSheet();
+        void showCharacterSheet(Creature* chara);
+        void showContainerContent(Container* container);
+        void showDescriptionWindow(GameObject* obj);
+        void showPropertiesWindow(GameObject* obj);
+        void showExitConfirmation();
+        void showJournalWindow();
+        void showLogfiles();
+        void showMessageWindow(const CeGuiString&amp; message);
+        void showMainMenu();
+        void showObjectDescription(GameObject* object);
+        void showPlaylist();
+        void showGameSaveLoadWindow();
+        void showMainMenuLoadWindow(MainMenuWindow* win);
+		void hideMainMenuLoadWindow();
+        void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
+        /**
+         * Creates a GameSettings object and displays its layout file on screen
+         */
+        void showGameSettings();
+
+        void toggleConsole();
+        void toggleDebugWindow();
+        void toggleGameLogWindow();
+        void toggleCharacterStateWindow();
+        void toggleCharacterSelectionWindow();
+        void toggleInGameGlobalMenu();
+        void toggleInventoryWindow();
+        void notifyInventoryWindowDestroyed();
+		bool isInventoryWindowDestroyed();
+
+        CombatWindow* getCombatWindow();
+
+        void checkForErrors();
+        GameLoggerWindow* getGameLogger();
+
+        void update();
+
+        /// Writes Text into the Console or other output media
+        void writeToConsole(std::string text);
+        static VALUE consoleWrite(VALUE self, VALUE str);
+
+        /// Change shown DebugWindow page
+        void showNextDebugWindowPage();
+
+    private:
+        void logAllWindows();
+
+        GameLoggerWindow* mGameLogger;
+        CharacterStateWindow* mCharacterStateWindow;
+        InGameMenuWindow* mInGameMenuWindow;
+        CharacterSheetWindow* mCharacterSheet;
+        JournalWindow* mJournalWindow;
+        InventoryWindow* mInventoryWindow;
+        LogWindow* mLogWindow;
+        DebugWindow* mDebugWindow;
+        Console* mConsole;
+        InfoPopup* mInfoPopup;
+        Actor* mObjectNameText;
+        GameObject* mShownObject;
+        ObjectDescriptionWindow* mObjectDescriptionWindow;
+        MainMenuWindow* mMainMenuWindow;
+		MainMenuLoadWindow* mMainMenuLoadWindow;
+        CloseConfirmationWindow* mCloseConfirmationWindow;
+        GameSettings* mGameSettings;
+        CombatWindow* mCombatWindow;
+        CharacterSelectionWindow* mCharacterSelectionWindow;
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,319 +1,325 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &lt;boost/bind.hpp&gt;
-#include &lt;CEGUIWindowManager.h&gt;
-#include &lt;elements/CEGUIFrameWindow.h&gt;
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;Exception.h&quot;
-
-#include &quot;UiSubsystem.h&quot;
-#include &quot;AbstractWindow.h&quot;
-#include &quot;CeGuiHelper.h&quot;
-#include &quot;WindowManager.h&quot;
-#include &quot;WindowFadeJob.h&quot;
-#include &quot;JobScheduler.h&quot;
-
-using namespace std;
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-
-	int AbstractWindow::sNumAbstractWindows = 0;
-
-	AbstractWindow::AbstractWindow(const CeGuiString&amp; xmlfile, int inputType, bool closeOnEscape, bool modal)
-	: mVisible(false),
-		mModal(modal),
-		mWindowInputType(inputType),
-		mCloseOnEscape(closeOnEscape)
-	{
-        LOG_MESSAGE(Logger::UI,
-		    &quot;Lade Fenster '&quot; + Ogre::String(xmlfile.c_str()) + &quot;'&quot;);
-   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
-		if (mWindow == NULL)
-		{
-			Throw(rl::IllegalStateException, Ogre::String(&quot;Could not load window '&quot;)+xmlfile.c_str()+&quot;'.&quot;);
-		}
-
-		getRoot()-&gt;addChildWindow(mWindow);
-
-        if (modal)
-		{
-			mWindow-&gt;setModalState(true);
-			mWindow-&gt;setAlwaysOnTop(true);
-            mWindow-&gt;moveToFront();
-            mWindow-&gt;show();
-		}
-        else
-        {
-       		mWindow-&gt;hide();
-        }
-
-		mNormalAlpha = mWindow-&gt;getAlpha();
-		mName = mWindow-&gt;getName();
-		WindowManager::getSingleton().registerWindow(this);
-		mWindow-&gt;subscribeEvent(Window::EventActivated,
-			boost::bind(
-				&amp;rl::WindowManager::handleMovedToFront,
-				rl::WindowManager::getSingletonPtr(),
-				this));
-	}
-
-	AbstractWindow::~AbstractWindow()
-	{
-		mWindow-&gt;hide();
-		mWindow-&gt;removeAllEvents();
-		WindowManager::getSingleton().unregisterWindow(this);
-		getRoot()-&gt;removeChildWindow(mWindow);
-		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
-	}
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString&amp; xmlfile)
-	{
-		CeGuiString prefix = &quot;&quot;;
-		return loadWindow(xmlfile, prefix);
-	}
-
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString&amp; xmlfile, CeGuiString&amp; prefix)
-	{
-		CeGuiString namePrefix;
-		if (prefix == &quot;&quot;)
-			prefix.assign(StringConverter::toString(sNumAbstractWindows));
-		sNumAbstractWindows++;
-
-		CEGUI::Window* window = NULL;
-		try
-		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
-		}
-		catch(...)
-		{
-		}
-
-		return window;
-	}
-
-	bool AbstractWindow::isVisible()
-	{
-		return mVisible;
-	}
-
-	void AbstractWindow::setVisible(bool visible, bool destroy)
-	{
-		if(mVisible != visible)
-		{
-			if (visible)
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
-			}
-			else
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this,
-                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
-                    0.0f));
-			}
-            WindowManager::getSingleton()._visiblityChanged(this, visible);
-            mVisible = visible;
-		}
-	}
-
-	const Ogre::Real&amp; AbstractWindow::getNormalAlpha() const
-	{
-		return mNormalAlpha;
-	}
-
-	bool AbstractWindow::isModal()
-	{
-		return mModal;
-	}
-
-	bool AbstractWindow::isClosingOnEscape()
-	{
-		return mCloseOnEscape;
-	}
-
-	int AbstractWindow::getWindowInputType()
-	{
-		return mWindowInputType;
-	}
-
-	CEGUI::Window* AbstractWindow::getRoot()
-	{
-		return CEGUI::WindowManager::getSingleton().getWindow(
-			(utf8*)UiSubsystem::CEGUI_ROOT);
-	}
-
-	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
-	{
-		CEGUI::Window* wnd =
-			CEGUI::WindowManager::getSingleton().getWindow(
-				mNamePrefix + (utf8*)name);
-
-		if (wnd == NULL)
-			Throw(
-				rl::NullPointerException,
-				&quot;Window &quot;
-				+ Ogre::String(name)
-				+ &quot; is NULL&quot;);
-
-		if (requiredClass != NULL &amp;&amp; !wnd-&gt;testClassName(requiredClass))
-			Throw(
-				rl::NullPointerException,
-				&quot;Window &quot;
-				+ Ogre::String(name)
-				+ &quot; has not the required class &quot;
-				+ Ogre::String(requiredClass));
-
-		return wnd;
-	}
-
-	Editbox* AbstractWindow::getEditbox(const char* name)
-	{
-		return static_cast&lt;Editbox*&gt;(getWindow(name, &quot;Editbox&quot;));
-	}
-
-	Listbox* AbstractWindow::getListbox(const char* name)
-	{
-		return static_cast&lt;Listbox*&gt;(getWindow(name, &quot;Listbox&quot;));
-	}
-
-	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
-	{
-		return static_cast&lt;MultiColumnList*&gt;(getWindow(name, &quot;MultiColumnList&quot;));
-	}
-
-	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
-	{
-		return static_cast&lt;MultiLineEditbox*&gt;(getWindow(name, &quot;MultiLineEditbox&quot;));
-	}
-
-	ProgressBar* AbstractWindow::getProgressBar(const char* name)
-	{
-		return static_cast&lt;ProgressBar*&gt;(getWindow(name, &quot;ProgressBar&quot;));
-	}
-
-	MenuBase* AbstractWindow::getMenu(const char* name)
-	{
-		return static_cast&lt;MenuBase*&gt;(getWindow(name, &quot;MenuBase&quot;));
-	}
-
-	MenuItem* AbstractWindow::getMenuItem(const char* name)
-	{
-		return static_cast&lt;MenuItem*&gt;(getWindow(name, &quot;MenuItem&quot;));
-	}
-
-	PushButton* AbstractWindow::getPushButton(const char* name)
-	{
-		return static_cast&lt;PushButton*&gt;(getWindow(name, &quot;PushButton&quot;));
-	}
-
-	Combobox* AbstractWindow::getCombobox(const char* name)
-	{
-		return static_cast&lt;Combobox*&gt;(getWindow(name, &quot;Combobox&quot;));
-	}
-
-	ComboDropList* AbstractWindow::getComboDropList(const char* name)
-	{
-		return static_cast&lt;ComboDropList*&gt;(getWindow(name, &quot;ComboDropList&quot;));
-	}
-
-    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
-    {
-		return static_cast&lt;ScrollablePane*&gt;(getWindow(name, &quot;ScrollablePane&quot;));
-    }
-
-	Slider* AbstractWindow::getSlider(const char* name)
-	{
-		return static_cast&lt;Slider*&gt;(getWindow(name, &quot;Slider&quot;));
-	}
-
-	TabControl* AbstractWindow::getTabControl(const char* name)
-	{
-		return static_cast&lt;TabControl*&gt;(getWindow(name, &quot;TabControl&quot;));
-	}
-
-	const CeGuiString&amp; AbstractWindow::getName() const
-	{
-		return mName;
-	}
-
-	void AbstractWindow::centerWindow()
-	{
-		CEGUI::Size screenSize = System::getSingleton().getRenderer()-&gt;getSize();
-		CEGUI::Size windowSize = mWindow-&gt;getPixelSize();
-		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
-		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
-		mWindow-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
-	}
-
-	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
-	{
-		button-&gt;subscribeEvent(Window::EventMouseClick,
-			boost::bind(&amp;AbstractWindow::destroyWindow, this));
-	}
-
-    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
-	{
-		button-&gt;subscribeEvent(Window::EventMouseClick,
-			boost::bind(&amp;AbstractWindow::hideWindow, this));
-	}
-
-	void AbstractWindow::bindDestroyWindowToXButton()
-	{
-		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&amp;AbstractWindow::destroyWindow, this));
-	}
-
-	void AbstractWindow::bindHideWindowToXButton()
-	{
-		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&amp;AbstractWindow::hideWindow, this));
-	}
-
-	bool AbstractWindow::destroyWindow()
-	{
-		setVisible(false, true);
-		return true;
-	}
-
-	bool AbstractWindow::hideWindow()
-	{
-		setVisible(false);
-		return true;
-	}
-
-	CEGUI::Window* AbstractWindow::getWindow()
-	{
-		return mWindow;
-	}
-
-	const CeGuiString&amp; AbstractWindow::getNamePrefix() const
-	{
-		return mNamePrefix;
-	}
-
-	void AbstractWindow::windowHid()
-	{
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &lt;boost/bind.hpp&gt;
+#include &lt;CEGUIWindowManager.h&gt;
+#include &lt;elements/CEGUIFrameWindow.h&gt;
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;Exception.h&quot;
+
+#include &quot;UiSubsystem.h&quot;
+#include &quot;AbstractWindow.h&quot;
+#include &quot;CeGuiHelper.h&quot;
+#include &quot;WindowManager.h&quot;
+#include &quot;WindowFadeJob.h&quot;
+#include &quot;JobScheduler.h&quot;
+
+using namespace std;
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+
+	int AbstractWindow::sNumAbstractWindows = 0;
+
+	AbstractWindow::AbstractWindow(const CeGuiString&amp; xmlfile, int inputType, bool closeOnEscape, bool modal)
+	: mVisible(false),
+		mModal(modal),
+		mWindowInputType(inputType),
+		mCloseOnEscape(closeOnEscape)
+	{
+        LOG_MESSAGE(Logger::UI,
+		    &quot;Lade Fenster '&quot; + Ogre::String(xmlfile.c_str()) + &quot;'&quot;);
+   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
+		if (mWindow == NULL)
+		{
+			Throw(rl::IllegalStateException, Ogre::String(&quot;Could not load window '&quot;)+xmlfile.c_str()+&quot;'.&quot;);
+		}
+
+		getRoot()-&gt;addChildWindow(mWindow);
+
+        if (modal)
+		{
+			mWindow-&gt;setModalState(true);
+			mWindow-&gt;setAlwaysOnTop(true);
+            mWindow-&gt;moveToFront();
+            mWindow-&gt;show();
+		}
+        else
+        {
+       		mWindow-&gt;hide();
+        }
+
+		mNormalAlpha = mWindow-&gt;getAlpha();
+		mName = mWindow-&gt;getName();
+		WindowManager::getSingleton().registerWindow(this);
+		mWindow-&gt;subscribeEvent(Window::EventActivated,
+			boost::bind(
+				&amp;rl::WindowManager::handleMovedToFront,
+				rl::WindowManager::getSingletonPtr(),
+				this));
+	}
+
+	AbstractWindow::~AbstractWindow()
+	{
+		mWindow-&gt;hide();
+		mWindow-&gt;removeAllEvents();
+		WindowManager::getSingleton().unregisterWindow(this);
+		getRoot()-&gt;removeChildWindow(mWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
+	}
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString&amp; xmlfile)
+	{
+		CeGuiString prefix = &quot;&quot;;
+		return loadWindow(xmlfile, prefix);
+	}
+
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString&amp; xmlfile, CeGuiString&amp; prefix)
+	{
+		CeGuiString namePrefix;
+		if (prefix == &quot;&quot;)
+			prefix.assign(StringConverter::toString(sNumAbstractWindows));
+		sNumAbstractWindows++;
+
+		CEGUI::Window* window = NULL;
+		try
+		{
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
+		}
+		catch(...)
+		{
+		}
+
+		return window;
+	}
+
+	bool AbstractWindow::isVisible()
+	{
+		return mVisible;
+	}
+
+	void AbstractWindow::setVisible(bool visible, bool destroy)
+	{
+		if(mVisible != visible)
+		{
+			if (visible)
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
+			}
+			else
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
+			}
+            WindowManager::getSingleton()._visiblityChanged(this, visible);
+            mVisible = visible;
+		}
+	}
+
+	const Ogre::Real&amp; AbstractWindow::getNormalAlpha() const
+	{
+		return mNormalAlpha;
+	}
+
+	bool AbstractWindow::isModal()
+	{
+		return mModal;
+	}
+
+	bool AbstractWindow::isClosingOnEscape()
+	{
+		return mCloseOnEscape;
+	}
+
+	int AbstractWindow::getWindowInputType()
+	{
+		return mWindowInputType;
+	}
+
+	CEGUI::Window* AbstractWindow::getRoot()
+	{
+		return CEGUI::WindowManager::getSingleton().getWindow(
+			(utf8*)UiSubsystem::CEGUI_ROOT);
+	}
+
+	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
+	{
+		CEGUI::Window* wnd =
+			CEGUI::WindowManager::getSingleton().getWindow(
+				mNamePrefix + (utf8*)name);
+
+		if (wnd == NULL)
+			Throw(
+				rl::NullPointerException,
+				&quot;Window &quot;
+				+ Ogre::String(name)
+				+ &quot; is NULL&quot;);
+
+		if (requiredClass != NULL &amp;&amp; !wnd-&gt;testClassName(requiredClass)) {
+            Throw(
+				rl::NullPointerException,
+				&quot;Window &quot;
+				+ Ogre::String(name)
+				+ &quot; has not the required class &quot;
+				+ Ogre::String(requiredClass));
+        }
+
+		return wnd;
+	}
+
+	Editbox* AbstractWindow::getEditbox(const char* name)
+	{
+		return static_cast&lt;Editbox*&gt;(getWindow(name, &quot;Editbox&quot;));
+	}
+    
+	Checkbox* AbstractWindow::getCheckbox(const char* name)
+	{
+		return static_cast&lt;Checkbox*&gt;(getWindow(name, &quot;Checkbox&quot;));
+	}
+    
+	Listbox* AbstractWindow::getListbox(const char* name)
+	{
+		return static_cast&lt;Listbox*&gt;(getWindow(name, &quot;Listbox&quot;));
+	}
+
+	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
+	{
+		return static_cast&lt;MultiColumnList*&gt;(getWindow(name, &quot;MultiColumnList&quot;));
+	}
+
+	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
+	{
+		return static_cast&lt;MultiLineEditbox*&gt;(getWindow(name, &quot;MultiLineEditbox&quot;));
+	}
+
+	ProgressBar* AbstractWindow::getProgressBar(const char* name)
+	{
+		return static_cast&lt;ProgressBar*&gt;(getWindow(name, &quot;ProgressBar&quot;));
+	}
+
+	MenuBase* AbstractWindow::getMenu(const char* name)
+	{
+		return static_cast&lt;MenuBase*&gt;(getWindow(name, &quot;MenuBase&quot;));
+	}
+
+	MenuItem* AbstractWindow::getMenuItem(const char* name)
+	{
+		return static_cast&lt;MenuItem*&gt;(getWindow(name, &quot;MenuItem&quot;));
+	}
+
+	PushButton* AbstractWindow::getPushButton(const char* name)
+	{
+		return static_cast&lt;PushButton*&gt;(getWindow(name, &quot;PushButton&quot;));
+	}
+
+	Combobox* AbstractWindow::getCombobox(const char* name)
+	{
+		return static_cast&lt;Combobox*&gt;(getWindow(name, &quot;Combobox&quot;));
+	}
+
+	ComboDropList* AbstractWindow::getComboDropList(const char* name)
+	{
+		return static_cast&lt;ComboDropList*&gt;(getWindow(name, &quot;ComboDropList&quot;));
+	}
+
+    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
+    {
+		return static_cast&lt;ScrollablePane*&gt;(getWindow(name, &quot;ScrollablePane&quot;));
+    }
+
+	Slider* AbstractWindow::getSlider(const char* name)
+	{
+		return static_cast&lt;Slider*&gt;(getWindow(name, &quot;Slider&quot;));
+	}
+
+	TabControl* AbstractWindow::getTabControl(const char* name)
+	{
+		return static_cast&lt;TabControl*&gt;(getWindow(name, &quot;TabControl&quot;));
+	}
+
+	const CeGuiString&amp; AbstractWindow::getName() const
+	{
+		return mName;
+	}
+
+	void AbstractWindow::centerWindow()
+	{
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()-&gt;getSize();
+		CEGUI::Size windowSize = mWindow-&gt;getPixelSize();
+		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
+		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
+		mWindow-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
+	}
+
+	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
+	{
+		button-&gt;subscribeEvent(Window::EventMouseClick,
+			boost::bind(&amp;AbstractWindow::destroyWindow, this));
+	}
+
+    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
+	{
+		button-&gt;subscribeEvent(Window::EventMouseClick,
+			boost::bind(&amp;AbstractWindow::hideWindow, this));
+	}
+
+	void AbstractWindow::bindDestroyWindowToXButton()
+	{
+		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&amp;AbstractWindow::destroyWindow, this));
+	}
+
+	void AbstractWindow::bindHideWindowToXButton()
+	{
+		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&amp;AbstractWindow::hideWindow, this));
+	}
+
+	bool AbstractWindow::destroyWindow()
+	{
+		setVisible(false, true);
+		return true;
+	}
+
+	bool AbstractWindow::hideWindow()
+	{
+		setVisible(false);
+		return true;
+	}
+
+	CEGUI::Window* AbstractWindow::getWindow()
+	{
+		return mWindow;
+	}
+
+	const CeGuiString&amp; AbstractWindow::getNamePrefix() const
+	{
+		return mNamePrefix;
+	}
+
+	void AbstractWindow::windowHid()
+	{
+	}
+
+}

Copied: rl/branches/newton20/engine/ui/src/CharacterSelectionWindow.cpp (from rev 4613, rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp)

Modified: rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,118 +1,134 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &lt;boost/bind.hpp&gt;
-#include &quot;UiPrerequisites.h&quot;
-
-#include &quot;DsaManager.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Talent.h&quot;
-
-#include &quot;CharacterStateWindow.h&quot;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-
-namespace rl {
-
-CharacterStateWindow::CharacterStateWindow()
-: AbstractWindow(&quot;characterstatewindow.xml&quot;, WIT_NONE, false),
-	mCharacter(NULL)
-{
-	mLP = getProgressBar(&quot;CharacterStateWindow/LP&quot;);
-	mAP = getProgressBar(&quot;CharacterStateWindow/AP&quot;);
-	mAU = getProgressBar(&quot;CharacterStateWindow/AU&quot;);
-	mName = getWindow(&quot;CharacterStateWindow/Name&quot;);
-}
-
-CharacterStateWindow::~CharacterStateWindow()
-{
-    if (mCharacter != NULL)
-		mCharacter-&gt;removeObjectStateChangeListener(this);
-}
-
-void CharacterStateWindow::setCharacter(Creature* person)
-{
-	if (mCharacter != NULL)
-		mCharacter-&gt;removeObjectStateChangeListener(this);
-
-	mCharacter = person;
-    if(mCharacter)
-        mCharacter-&gt;addObjectStateChangeListener(this);
-	update();
-}
-
-void CharacterStateWindow::update()
-{
-	if (!isVisible())
-		return;
-	if (mCharacter == NULL)
-		return;
-
-	mName-&gt;setText(mCharacter-&gt;getName());
-
-	float lep;
-	if (mCharacter-&gt;getLeMax() &lt;= 0)
-		lep = 0.0;
-	else
-		lep = (float)mCharacter-&gt;getLe() / (float)mCharacter-&gt;getLeMax();
-	mLP-&gt;setProgress(lep);
-
-	float au;
-	if (mCharacter-&gt;getAuMax() &lt;= 0)
-		au = 0.0;
-	else
-		au = (float)mCharacter-&gt;getAu() / (float)mCharacter-&gt;getAuMax();
-	mAU-&gt;setProgress(au);
-
-	if (!mCharacter-&gt;isMagic())
-	{
-		if (mAP-&gt;isVisible())
-			mAP-&gt;setVisible(false);
-		return;
-	}
-
-	if (!mAP-&gt;isVisible())
-		mAP-&gt;setVisible(true);
-
-	float asp;
-	if (mCharacter-&gt;getAeMax() &lt;= 0)
-		asp = 0.0;
-	else
-		asp = (float)mCharacter-&gt;getAe() / (float)mCharacter-&gt;getAeMax();
-	mAP-&gt;setProgress(asp);
-
-}
-
-void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
-{
-	update();
-}
-
-void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
-{
-	AbstractWindow::setVisible(visible, destroyAfterHide);
-	if (visible)
-	{
-		update();
-	}
-}
-
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &lt;boost/bind.hpp&gt;
+#include &quot;UiPrerequisites.h&quot;
+
+#include &quot;DsaManager.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;Talent.h&quot;
+
+#include &quot;CharacterStateWindow.h&quot;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+
+namespace rl {
+
+CharacterStateWindow::CharacterStateWindow()
+: AbstractWindow(&quot;characterstatewindow.xml&quot;, WIT_NONE, false),
+	mCharacter(NULL)
+{
+	mLP = getProgressBar(&quot;CharacterStateWindow/LP&quot;);
+	mAP = getProgressBar(&quot;CharacterStateWindow/AP&quot;);
+	mAU = getProgressBar(&quot;CharacterStateWindow/AU&quot;);
+	mName = getWindow(&quot;CharacterStateWindow/Name&quot;);
+}
+
+CharacterStateWindow::~CharacterStateWindow()
+{
+    if (mCharacter != NULL)
+		mCharacter-&gt;removeObjectStateChangeListener(this);
+}
+
+void CharacterStateWindow::setCharacter(Creature* person)
+{
+	if (mCharacter != NULL)
+		mCharacter-&gt;removeObjectStateChangeListener(this);
+
+	mCharacter = person;
+    if(mCharacter)
+        mCharacter-&gt;addObjectStateChangeListener(this);
+	update();
+}
+
+void CharacterStateWindow::update()
+{
+	if (!isVisible() || mCharacter == NULL)
+    {
+		return;
+    }
+        
+	mName-&gt;setText(mCharacter-&gt;getName());
+
+	float lep;
+	if (mCharacter-&gt;getLeMax() &lt;= 0)
+    {
+		lep = 0.0;        
+    }
+	else
+    {
+		lep = (float)mCharacter-&gt;getLe() / (float)mCharacter-&gt;getLeMax();        
+    }
+	mLP-&gt;setProgress(lep);
+
+	float au;
+	if (mCharacter-&gt;getAuMax() &lt;= 0)
+    {
+		au = 0.0;        
+    }
+	else
+    {
+		au = (float)mCharacter-&gt;getAu() / (float)mCharacter-&gt;getAuMax();        
+    }
+	mAU-&gt;setProgress(au);
+
+	if (!mCharacter-&gt;isMagic())
+	{
+		if (mAP-&gt;isVisible()) 
+        {
+			mAP-&gt;setVisible(false);            
+        }
+	}
+    else 
+    {
+     	if (!mAP-&gt;isVisible()) 
+        {
+            mAP-&gt;setVisible(true);            
+        }
+        
+        float asp;
+        if (mCharacter-&gt;getAeMax() &lt;= 0)
+        {
+            asp = 0.0;
+        }
+        else
+        {
+            asp = (float)mCharacter-&gt;getAe() / (float)mCharacter-&gt;getAeMax();
+        }
+        mAP-&gt;setProgress(asp);        
+    }
+}
+
+void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
+{
+	update();
+}
+
+void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
+{
+	AbstractWindow::setVisible(visible, destroyAfterHide);
+	if (visible)
+	{
+		update();
+	}
+}
+
+
+}

Modified: rl/branches/newton20/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -318,14 +318,14 @@
         int n = 0;
         Vector3 pos = Vector3::ZERO;
 
-        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllAllies() );
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
         for(Combat::CombatantSet::iterator it = allies.begin(); it != allies.end(); it++)
         {
             pos += (*it)-&gt;getCreature()-&gt;getPosition();
             n++;
         }
 
-        const Combat::CombatantSet &amp;opponents (mCombat-&gt;getAllOpponents());
+        const Combat::CombatantSet &amp;opponents (mCombat-&gt;getAllPlayerOpponents());
         for(Combat::CombatantSet::iterator it = opponents.begin(); it != opponents.end(); it++)
         {
             pos += (*it)-&gt;getCreature()-&gt;getPosition();
@@ -346,12 +346,12 @@
     {
         // get the greatest distance from center from all persons
         Real distance = 0;
-        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllAllies() );
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
         for(Combat::CombatantSet::iterator it = allies.begin(); it != allies.end(); it++)
         {
             distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
         }
-        const Combat::CombatantSet &amp;opponents = mCombat-&gt;getAllOpponents();
+        const Combat::CombatantSet &amp;opponents = mCombat-&gt;getAllPlayerOpponents();
         for(Combat::CombatantSet::iterator it = opponents.begin(); it != opponents.end(); it++)
         {
             distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );

Modified: rl/branches/newton20/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -37,7 +37,8 @@
 		  mCombat(combat),
 		  mCamera(camera),
 		  mUserInputEnabled(false),
-		  mGameLoggerWindowOpened(false)
+		  mGameLoggerWindowOpened(false),
+          mVisible(false)
     {
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
 		mGameLoggerWindow = WindowFactory::getSingleton().getGameLogger();
@@ -68,7 +69,7 @@
         sceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(mHud);
 
 		// Create an attack/parry/(goto) button set for all opponents present at the beginning.
-        const Combat::CombatantSet&amp; opponents = mCombat-&gt;getAllOpponents();
+        const Combat::CombatantSet&amp; opponents = mCombat-&gt;getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -82,6 +83,7 @@
 	CombatGui::~CombatGui()
 	{
 		hide();
+        mHud-&gt;getParentSceneNode()-&gt;detachObject(mHud);
         SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager();
 		sceneMgr-&gt;destroyManualObject(mHud);
 	}
@@ -96,7 +98,7 @@
         mHud-&gt;clear();
 
         mHud-&gt;begin(&quot;alpha_red&quot;, RenderOperation::OT_LINE_LIST);
-        const Combat::CombatantSet&amp; opponents = mCombat-&gt;getAllOpponents();
+        const Combat::CombatantSet&amp; opponents = mCombat-&gt;getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -161,16 +163,25 @@
 
 	void CombatGui::show()
 	{
-		mGameLoggerWindowOpened = !mGameLoggerWindow-&gt;isVisible();
-        mCombatWindow-&gt;setVisible(true);
-		mGameLoggerWindow-&gt;setVisible(true);
+        if (!mVisible)
+        {
+		    mGameLoggerWindowOpened = !mGameLoggerWindow-&gt;isVisible();
+            mCombatWindow-&gt;setVisible(true);
+		    mGameLoggerWindow-&gt;setVisible(true);
+            mHud-&gt;setVisible(true);
+            mVisible = true;
+        }
 	}
 
 	void CombatGui::hide()
 	{
-        mCombatWindow-&gt;setVisible(false);
-		mGameLoggerWindow-&gt;setVisible(!mGameLoggerWindowOpened);
-		mHud-&gt;clear();
+        if (mVisible)
+        {
+            mCombatWindow-&gt;setVisible(false);
+		    mGameLoggerWindow-&gt;setVisible(!mGameLoggerWindowOpened);
+            mHud-&gt;setVisible(false);
+            mVisible = false;
+        }
 	}
 
 	bool CombatGui::enemyButtonClicked(int handle, int buttonIndex)

Modified: rl/branches/newton20/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -186,8 +186,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
-                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
+                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;_getDerivedPosition();
+                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;_getDerivedOrientation();
 
                 textSt += &quot;\nPlayer Position [ &quot;
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;

Modified: rl/branches/newton20/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DialogControlState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/DialogControlState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
-            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;_getDerivedOrientation().Inverse()*
+            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/branches/newton20/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -25,6 +25,8 @@
 #include &quot;SoundManager.h&quot;
 #include &quot;SoundDriver.h&quot;
 
+using namespace Ogre;
+
 namespace rl
 {
     GameSettings::GameSettings()
@@ -46,8 +48,12 @@
         getWindow()-&gt;subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
                                     boost::bind(&amp;GameSettings::onCancel, this));
 
+        mVideoRenderer = getCombobox(&quot;GameOptionsWindow/Video/Renderer&quot;);
+        mVideoResolution = getCombobox(&quot;GameOptionsWindow/Video/Resolution&quot;);
+        mVideoFullscreen = getCheckbox(&quot;GameOptionsWindow/Video/Fullscreen&quot;);
         centerWindow();
         setVisible(false);
+        update();
     }
 
     GameSettings::~GameSettings()
@@ -127,4 +133,54 @@
     {
         return true;
     }
+    
+    void GameSettings::update()
+    {
+        Root* root = Ogre::Root::getSingletonPtr();
+        RenderSystem* renderer = root-&gt;getRenderSystem();
+        
+        ConfigOptionMap config = renderer-&gt;getConfigOptions();
+        
+		ConfigOptionMap::iterator cfi;
+		
+		cfi = config.find( &quot;Full Screen&quot; );
+		if( cfi != config.end() )
+		{
+			mVideoFullscreen-&gt;setSelected(cfi-&gt;second.currentValue == &quot;Yes&quot;);
+		}
+        
+/*		cfi = config.find( &quot;FSAA&quot; );
+		if( cfi != config.end() )
+		{
+			if( cfi-&gt;second.currentValue == &quot;0&quot; )
+			{
+				SetControlValue( iFSAARef, 1 );
+			}
+			else if( cfi-&gt;second.currentValue == &quot;2&quot; )
+			{
+				SetControlValue( iFSAARef, 2 );
+			}
+			else if( cfi-&gt;second.currentValue == &quot;4&quot; )
+			{
+				SetControlValue( iFSAARef, 3 );
+			}
+			else if( cfi-&gt;second.currentValue == &quot;6&quot; )
+			{
+				SetControlValue( iFSAARef, 4 );
+			}
+		}
+        
+		cfi = config.find( &quot;Colour Depth&quot; );
+		if( cfi != config.end() )
+		{
+			if( cfi-&gt;second.currentValue == &quot;32&quot; )
+			{
+				SetControlValue( iColorDepthRef, 1 );
+			}
+			else
+			{
+				SetControlValue( iColorDepthRef, 2 );
+			}
+		}*/
+    }
 }

Modified: rl/branches/newton20/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -446,7 +446,10 @@
     {
         while (!mControlStates.empty())
         {
-            popControlState();
+            ControlState* controller = mControlStates.top();
+            mControlStates.pop();
+            controller-&gt;pause();
+            mFinishedControlStates.push_back(controller);
         }
     }
 

Modified: rl/branches/newton20/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InventoryWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/InventoryWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -175,7 +175,6 @@
     ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
     {
 		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
-		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
         if( iter != mWorldDragContainers.end() )
@@ -453,7 +452,7 @@
 		mousePos.d_y /= getRoot()-&gt;getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera-&gt;getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera-&gt;getCamera()-&gt;getWorldPosition();
+		Ogre::Vector3 rayStart = camera-&gt;getCamera()-&gt;getDerivedPosition();
 		Ogre::Vector3 rayDir = camera-&gt;getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 

Modified: rl/branches/newton20/engine/ui/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/src/Makefile.am	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/Makefile.am	2008-11-30 22:46:52 UTC (rev 4616)
@@ -13,6 +13,7 @@
     AbstractWindow.cpp \
     CharacterSheetWindow.cpp \
     CharacterStateWindow.cpp \
+	CharacterSelectionWindow.cpp \
     CloseConfirmationWindow.cpp \
     CombatControlState.cpp \
     CombatGui.cpp \

Modified: rl/branches/newton20/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -20,6 +20,7 @@
 #include &quot;AboutWindow.h&quot;
 #include &quot;ActionChoiceWindow.h&quot;
 #include &quot;ActorManager.h&quot;
+#include &quot;CharacterSelectionWindow.h&quot;
 #include &quot;CharacterSheetWindow.h&quot;
 #include &quot;CharacterStateWindow.h&quot;
 #include &quot;CloseConfirmationWindow.h&quot;
@@ -85,7 +86,8 @@
         mMainMenuWindow(NULL),
 		mMainMenuLoadWindow(NULL),
         mGameSettings(NULL),
-        mCombatWindow(NULL)
+        mCombatWindow(NULL),
+        mCharacterSelectionWindow(NULL)
     {
     }
 
@@ -111,6 +113,8 @@
         RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mJournalWindow);
         //RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mInfoPopup);
         mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+        
+        mCharacterSelectionWindow = new CharacterSelectionWindow();
 
         logAllWindows();
     }
@@ -294,7 +298,13 @@
     {
         mCharacterStateWindow-&gt;setVisible(!mCharacterStateWindow-&gt;isVisible());
     }
-
+    
+    void WindowFactory::toggleCharacterSelectionWindow()
+    {
+        mCharacterSelectionWindow-&gt;setVisible(!mCharacterSelectionWindow-&gt;isVisible());
+        mCharacterSelectionWindow-&gt;update();
+    }
+    
     void WindowFactory::toggleInGameGlobalMenu()
     {
         mInGameMenuWindow-&gt;setVisible(!mInGameMenuWindow-&gt;isVisible());

Copied: rl/branches/newton20/plugins/CMakeLists.txt (from rev 4613, rl/trunk/plugins/CMakeLists.txt)

Copied: rl/branches/newton20/plugins/fmod4driver/CMakeLists.txt (from rev 4613, rl/trunk/plugins/fmod4driver/CMakeLists.txt)

Modified: rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -137,9 +137,8 @@
         static FMOD_RESULT F_CALLBACK channelCallback(
             FMOD_CHANNEL* channel,
             FMOD_CHANNEL_CALLBACKTYPE type,
-            int command,
-            unsigned int commanddata1,
-            unsigned int commanddata2
+            void* commanddata1,
+            void* commanddata2
         );
 
         typedef std::map&lt;const Ogre::String, FMOD_REVERB_PROPERTIES&gt; EaxPresetMap;

Modified: rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -209,17 +209,22 @@
 
         int numPlugins;
         mFmod4System-&gt;getNumPlugins(FMOD_PLUGINTYPE_CODEC, &amp;numPlugins);
-        for (int i = 0; i &lt; numDrivers; i++)
+        for (int i = 0; i &lt; numPlugins; i++)
         {
             char pluginName[128];
             unsigned int version;
+			FMOD_PLUGINTYPE type = FMOD_PLUGINTYPE_CODEC;
+			unsigned int handle;
+			FMOD_RESULT result = mFmod4System-&gt;getPluginHandle(FMOD_PLUGINTYPE_CODEC, i, &amp;handle);
+			CHECK_FMOD4_ERRORS(result);
 
-            mFmod4System-&gt;getPluginInfo(
-                FMOD_PLUGINTYPE_CODEC,
-                i,
-                pluginName,
+            result = mFmod4System-&gt;getPluginInfo(
+                handle,
+                &amp;type,
+				pluginName,
                 127,
                 &amp;version);
+			CHECK_FMOD4_ERRORS(result);
             LOG_MESSAGE(Logger::MULTIMEDIA,
                 String(&quot;Fmod4Driver Plugin '&quot;)
                 + pluginName
@@ -407,9 +412,8 @@
 FMOD_RESULT F_CALLBACK Fmod4Driver::channelCallback(
     FMOD_CHANNEL *_channel,
     FMOD_CHANNEL_CALLBACKTYPE type,
-    int command,
-    unsigned int commanddata1, 
-    unsigned int commanddata2)
+    void* commanddata1, 
+    void* commanddata2)
 {
     /// Extract the Fmod channel and then our Sound object.
     FMOD::Channel* channel = (FMOD::Channel*)_channel;
@@ -444,7 +448,7 @@
         
                     // We get the time point of the sync point and put it in a timing event.
                     sound-&gt;getFmodChannel()-&gt;getCurrentSound(&amp;fmodsound);
-                    fmodsound-&gt;getSyncPoint(commanddata1, &amp;syncpoint);
+                    fmodsound-&gt;getSyncPoint(*static_cast&lt;int*&gt;(commanddata1), &amp;syncpoint);
                     fmodsound-&gt;getSyncPointInfo(syncpoint, NULL, 0, &amp;event.mTime, FMOD_TIMEUNIT_MS);
                     sound-&gt;dispatchEvent(&amp;event);
                 }
@@ -480,12 +484,8 @@
 
     void Fmod4Driver::_registerChannel(FMOD::Channel* channel, Fmod4Sound* sound)
     {
-        FMOD_RESULT res = channel-&gt;setCallback(FMOD_CHANNEL_CALLBACKTYPE_END, channelCallback, 0);
+        FMOD_RESULT res = channel-&gt;setCallback(channelCallback);
         CHECK_FMOD4_ERRORS(res);
-        res = channel-&gt;setCallback(FMOD_CHANNEL_CALLBACKTYPE_SYNCPOINT, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
-        res = channel-&gt;setCallback(FMOD_CHANNEL_CALLBACKTYPE_VIRTUALVOICE, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
         mChannelSoundMap.insert(std::make_pair(channel, sound));
     }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001672.html">[Dsa-hl-svn] r4615 - in modules/branch_persistenz: maps scripts/maps
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1673">[ date ]</a>
              <a href="thread.html#1673">[ thread ]</a>
              <a href="subject.html#1673">[ subject ]</a>
              <a href="author.html#1673">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
