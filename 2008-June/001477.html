<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4406 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4406%20-%20in%20rl/trunk/engine%3A%20ai/src%20rules/include%0A%09rules/src%20script/swig%20ui/src&In-Reply-To=%3C200806231345.m5NDjWHN008949%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001476.html">
   <LINK REL="Next"  HREF="001478.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4406 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4406%20-%20in%20rl/trunk/engine%3A%20ai/src%20rules/include%0A%09rules/src%20script/swig%20ui/src&In-Reply-To=%3C200806231345.m5NDjWHN008949%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4406 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Mon Jun 23 15:45:32 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001476.html">[Dsa-hl-svn] r4405 - in rl/trunk/engine: core/include core/src	script/src
</A></li>
        <LI>Next message: <A HREF="001478.html">[Dsa-hl-svn] r4407 - in rl/trunk/editors: . Lockenwickler	Lockenwickler/src Lockenwickler/src/media Lockenwickler/ui files
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1477">[ date ]</a>
              <a href="thread.html#1477">[ thread ]</a>
              <a href="subject.html#1477">[ subject ]</a>
              <a href="author.html#1477">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2008-06-23 15:45:18 +0200 (Mon, 23 Jun 2008)
New Revision: 4406

Added:
   rl/trunk/engine/rules/include/AbstractMovement.h
   rl/trunk/engine/rules/include/FallDownMovement.h
   rl/trunk/engine/rules/include/JogBackwardsMovement.h
   rl/trunk/engine/rules/include/JogFastMovement.h
   rl/trunk/engine/rules/include/JogMovement.h
   rl/trunk/engine/rules/include/JumpHighMovement.h
   rl/trunk/engine/rules/include/JumpLongMovement.h
   rl/trunk/engine/rules/include/JumpToTargetMovement.h
   rl/trunk/engine/rules/include/LieDownMovement.h
   rl/trunk/engine/rules/include/RotateMovement.h
   rl/trunk/engine/rules/include/SneakMovement.h
   rl/trunk/engine/rules/include/SprintMovement.h
   rl/trunk/engine/rules/include/StandAroundMovement.h
   rl/trunk/engine/rules/include/StepRecognitionMovement.h
   rl/trunk/engine/rules/include/StrafeMovement.h
   rl/trunk/engine/rules/include/WalkBackwardsMovement.h
   rl/trunk/engine/rules/include/WalkMovement.h
   rl/trunk/engine/rules/src/FallDownMovement.cpp
   rl/trunk/engine/rules/src/JogFastMovement.cpp
   rl/trunk/engine/rules/src/JogMovement.cpp
   rl/trunk/engine/rules/src/JumpHighMovement.cpp
   rl/trunk/engine/rules/src/JumpLongMovement.cpp
   rl/trunk/engine/rules/src/JumpToTargetMovement.cpp
   rl/trunk/engine/rules/src/LieDownMovement.cpp
   rl/trunk/engine/rules/src/RotateMovement.cpp
   rl/trunk/engine/rules/src/SneakMovement.cpp
   rl/trunk/engine/rules/src/SprintMovement.cpp
   rl/trunk/engine/rules/src/StandAroundMovement.cpp
   rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
   rl/trunk/engine/rules/src/StrafeMovement.cpp
   rl/trunk/engine/rules/src/WalkMovement.cpp
Modified:
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Put each movement (from CreatureController.cpp) in an own class with .cpp- and .h-file


Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -52,7 +52,7 @@
 
     void AgentDialogState::update(const Ogre::Real elapsedTime)
     {
-        static CreatureController* ctrl = 
+        CreatureController* ctrl = 
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent-&gt;getControlledCreature());
 

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -17,6 +17,7 @@
 
 #include &quot;SteeringVehicle.h&quot;
 
+#include &quot;AbstractMovement.h&quot;
 #include &quot;AiSubsystem.h&quot;
 #include &quot;AiWorld.h&quot; 
 #include &quot;Agent.h&quot;

Added: rl/trunk/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/trunk/engine/rules/include/AbstractMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/AbstractMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,125 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+
+#ifndef __AbstractMovement_H__
+#define __AbstractMovement_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+#include &quot;CreatureController.h&quot;
+
+
+
+namespace rl
+{
+    /// this is the base class of all movements and provides a general interface for movements
+    class AbstractMovement : 
+        public OgreNewt::ContactCallback
+    {
+    public:
+        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
+        virtual ~AbstractMovement() {}
+
+        /// returns the id of this movement
+        virtual CreatureController::MovementType getId() const = 0;
+
+        /// returns the id of the movement that is used, if this movement isn't possible (any more)
+        virtual CreatureController::MovementType getFallBackMovement() const = 0;
+
+        /**
+         * this method calculates the basis velocity (without any changes due to Talentproben etc)
+         * @param velocity this parameter returns the calculated &quot;velocity&quot; ( m/s, rpm, or width/height of a jump)
+         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
+         */
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity) = 0;
+
+        /**
+         * this method specifies, if the movement is possible
+         */
+        virtual bool isPossible() const = 0;
+
+        /**
+         * this method is called, when this movement is currently used to enable 
+         * an individual procession of collisions contacts for each movement
+         */
+        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+
+        /**
+         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
+         * the PhysicalThing can be acquired via the Creature
+         */
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep) = 0;
+
+        /**
+         * this method indicates if it is possible to change to the specified movement at this moment
+         */
+        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
+
+        /**
+         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
+         */
+        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
+
+        /**
+         * here all the stuff not (directly) relating the physics should be done
+         * this function is called every frame if this movement is activated and the
+         * Creature is in an active moving state. It is important to handle all 
+         * &quot;Talentproben&quot; etc here and not in the physics function!
+         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
+         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
+         */
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
+
+        /**
+         * this function is called if this movement is activated.
+         * it can be used to determine if a new &quot;Talentprobe&quot; is needed
+         * if you ovveride it, please make sure to call the base class method
+         */
+        virtual void activate() {mActive = true;}
+
+        /**
+         * this function is called every time this movement is deactivated.
+         * if you ovveride it, please make sure to call the base class method
+         */
+        virtual void deactivate() {mActive = false;}
+
+        /**
+         * this method is used to get to know if a movement can be used with a certain direction
+         * @retval true if this movement can be used with the direction, false otherwise
+         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
+         */
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const = 0;
+
+        /**
+         * this method is used to get to know if the given rotation can be used with this movement
+         * @retval true if the creature can perform this rotation with this movement
+         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
+         */
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const = 0;
+
+
+        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
+        bool isActive() const {return mActive;}
+
+        /// this method is used to return the yaw value of rotation movemenrts etc
+        virtual Ogre::Real getMovementDefinedValue() {return 0;}
+    protected:
+        CreatureController *mMovingCreature;
+        bool mActive;
+    };
+}
+#endif
+

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/CreatureController.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -80,9 +80,10 @@
             MT_SCHLEICHEN,
             MT_HOCHSPRUNG,
             MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
             // these movements are only for internal purposes and should not be used directly
             // instead use one of the movements above
-            MT_DREHEN,
+            MT_DREHEN = 100,  // if new movements are added, the old numbers can stay the same
             MT_STUFENERKENNUNG,
             MT_FALLEN,
 	    MT_LIEGEN
@@ -192,100 +193,6 @@
         MessagePump::ScopedConnection mMessageType_GameObjectsLoaded_Handler;
         MessagePump::ScopedConnection mLifeStateChangedHandler;
     };
-
-    /// this is the base class of all movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
-    {
-    public:
-        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
-
-        /// returns the id of this movement
-        virtual CreatureController::MovementType getId() const = 0;
-
-        /// returns the id of the movement that is used, if this movement isn't possible (any more)
-        virtual CreatureController::MovementType getFallBackMovement() const = 0;
-
-        /**
-         * this method calculates the basis velocity (without any changes due to Talentproben etc)
-         * @param velocity this parameter returns the calculated &quot;velocity&quot; ( m/s, rpm, or width/height of a jump)
-         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
-         */
-        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity) = 0;
-
-        /**
-         * this method specifies, if the movement is possible
-         */
-        virtual bool isPossible() const = 0;
-
-        /**
-         * this method is called, when this movement is currently used to enable 
-         * an individual procession of collisions contacts for each movement
-         */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
-
-        /**
-         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
-         * the PhysicalThing can be acquired via the Creature
-         */
-        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep) = 0;
-
-        /**
-         * this method indicates if it is possible to change to the specified movement at this moment
-         */
-        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
-
-        /**
-         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
-         */
-        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
-
-        /**
-         * here all the stuff not (directly) relating the physics should be done
-         * this function is called every frame if this movement is activated and the
-         * Creature is in an active moving state. It is important to handle all 
-         * &quot;Talentproben&quot; etc here and not in the physics function!
-         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
-         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
-         */
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
-
-        /**
-         * this function is called if this movement is activated.
-         * it can be used to determine if a new &quot;Talentprobe&quot; is needed
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void activate() {mActive = true;}
-
-        /**
-         * this function is called every time this movement is deactivated.
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void deactivate() {mActive = false;}
-
-        /**
-         * this method is used to get to know if a movement can be used with a certain direction
-         * @retval true if this movement can be used with the direction, false otherwise
-         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
-         */
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const = 0;
-
-        /**
-         * this method is used to get to know if the given rotation can be used with this movement
-         * @retval true if the creature can perform this rotation with this movement
-         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
-         */
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const = 0;
-
-
-        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
-        bool isActive() const {return mActive;}
-
-        /// this method is used to return the yaw value of rotation movemenrts etc
-        virtual Ogre::Real getMovementDefinedValue() {return 0;}
-    protected:
-        CreatureController *mMovingCreature;
-        bool mActive;
-    };
 }
 #endif
+

Added: rl/trunk/engine/rules/include/FallDownMovement.h
===================================================================
--- rl/trunk/engine/rules/include/FallDownMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/FallDownMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __FallDownMovement_H__
+#define __FallDownMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+namespace rl
+{
+    class FallDownMovement : public AbstractMovement
+    {
+    public:
+        FallDownMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_FALLEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+        Ogre::Real mVel;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogBackwardsMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogBackwardsMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogBackwardsMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __JogBackwardsMovement_H__
+#define __JogBackwardsMovement_H__
+
+#include &quot;JogMovement.h&quot;
+
+
+namespace rl
+{
+    class JogBackwardsMovement : public JogMovement
+    {
+    public:
+        JogBackwardsMovement(CreatureController *creature) : JogMovement(creature)
+        {
+            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;joggen_rueckwaerts&quot;);
+        }
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity)
+        {
+            velocity = mMovingCreature-&gt;getCurrentGS() / 3.2;
+            return isPossible();
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogFastMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogFastMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogFastMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __JogFastMovement_H__
+#define __JogFastMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class JogFastMovement : public WalkMovement
+    {
+    public:
+        JogFastMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual void doTalentProbeIfNecessary();
+    protected:
+        Ogre::Real mTimePerAu;
+        Date mLastProbe;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,39 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __JogMovement_H__
+#define __JogMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class JogMovement : public WalkMovement
+    {
+    public:
+        JogMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JumpHighMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpHighMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpHighMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+
+#ifndef __JumpHighMovement_H__
+#define __JumpHighMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+
+namespace rl
+{
+    class JumpHighMovement : public AbstractMovement
+    {
+    public:
+        JumpHighMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mHeight;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+        Ogre::Real mMoveForward;
+        Creature::AnimationSpeedPair mAnimation;
+        Creature::AnimationSpeedPair mAnimationAbsprung;
+        Creature::AnimationSpeedPair mAnimationLandung;
+        Creature::AnimationSpeedPair mAnimationForCollision;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JumpLongMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpLongMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpLongMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,59 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __JumpLongMovement_H__
+#define __JumpLongMovement_H__
+
+
+#include &quot;AbstractMovement.h&quot;
+
+
+
+namespace rl
+{
+    class JumpLongMovement : public AbstractMovement
+    {
+    public:
+        JumpLongMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mWidth;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+        Ogre::Real mApplyForceTime;
+        Ogre::Real mApplyForceTimer;
+        Ogre::Vector3 mLastForce;
+        Ogre::Real mVelocityBeforeJump;
+        Ogre::Real mTanJumpAngle;
+        Creature::AnimationSpeedPair mAnimation;
+        Creature::AnimationSpeedPair mAnimationAbsprung;
+        Creature::AnimationSpeedPair mAnimationLandung;
+        Creature::AnimationSpeedPair mAnimationForCollision;
+    };
+}
+
+#endif

Added: rl/trunk/engine/rules/include/JumpToTargetMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpToTargetMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpToTargetMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,38 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __JumpToTargetMovement_H__
+#define __JumpToTargetMovement_H__
+
+#include &quot;JumpLongMovement.h&quot;
+
+
+namespace rl
+{
+    class JumpToTargetMovement : public JumpLongMovement
+    {
+    public:
+        JumpToTargetMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_ZIELSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual void activate();
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/LieDownMovement.h
===================================================================
--- rl/trunk/engine/rules/include/LieDownMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/LieDownMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __LieDownMovement_H__
+#define __LieDownMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+namespace rl
+{
+    // auch wenn Fallen nicht m&#246;glich ist (auf dem Boden und bewusstlos / Tod)
+    class LieDownMovement : public AbstractMovement
+    {
+    public:
+	LieDownMovement(CreatureController *creature);
+	virtual CreatureController::MovementType getId() const {return CreatureController::MT_LIEGEN;}
+	virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+	virtual void activate();
+	virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+        Creature::AnimationSpeedPair mAnim1;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/Makefile.am	2008-06-23 13:45:18 UTC (rev 4406)
@@ -48,10 +48,28 @@
 	TalentStateSet.h \
 	WaitJob.h \
 	Weapon.h \
-	ZauberStateSet.h
+	ZauberStateSet.h \
+	AbstractMovement.h \
+	FallDownMovement.h \
+	JogBackwardsMovement.h \
+	JogFastMovement.h \
+	JogMovement.h \
+	JumpHighMovement.h \
+	JumpLongMovement.h \
+	JumpToTargetMovement.h \
+	LieDownMovement.h \
+	RotateMovement.h \
+	SneakMovement.h \
+	SprintMovement.h \
+	StandAroundMovement.h \
+	StepRecognitionMovement.h \
+	StrafeMovement.h \
+	WalkBackwardsMovement.h \
+	WalkMovement.h
 
 CLEANFILES = stdinc.h.gch
 all-local: stdinc.h.gch
 stdinc.h.gch: $(noinst_HEADERS) stdinc.h
 	@echo Creating GCH file
 	g++ -I. stdinc.h
+

Added: rl/trunk/engine/rules/include/RotateMovement.h
===================================================================
--- rl/trunk/engine/rules/include/RotateMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/RotateMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RotateMovement_H__
+#define __RotateMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+namespace rl
+{
+    class RotateMovement : public AbstractMovement
+    {
+    public:
+        RotateMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void activate();
+        virtual void deactivate();
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+    protected:
+        Ogre::Radian mYaw;
+        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
+        virtual Ogre::Real getMovementDefinedValue() {return mYaw.valueRadians();}
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/SneakMovement.h
===================================================================
--- rl/trunk/engine/rules/include/SneakMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/SneakMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __SneakMovement_H__
+#define __SneakMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class SneakMovement : public WalkMovement
+    {
+    public:
+        SneakMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+        virtual void requestChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mTimer;
+        Creature::AnimationSpeedPair mAnim1;
+        Creature::AnimationSpeedPair mAnim2;
+        Creature::AnimationSpeedPair mAnim3;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/SprintMovement.h
===================================================================
--- rl/trunk/engine/rules/include/SprintMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/SprintMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __SprintMovement_H__
+#define __SprintMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class SprintMovement : public WalkMovement
+    {
+    public:
+        SprintMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual void doTalentProbeIfNecessary();
+    protected:
+        Ogre::Real mVelocityImprovement;
+        Date mLastProbe;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StandAroundMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StandAroundMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StandAroundMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,83 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __StandAroundMovement_H__
+#define __StandAroundMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+namespace rl
+{
+    class StandAroundMovement : public AbstractMovement
+    {
+    public:
+        StandAroundMovement(CreatureController *creature);
+        virtual ~StandAroundMovement();
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const
+        {
+            if( mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR )
+                return CreatureController::MT_LIEGEN;
+
+            return CreatureController::MT_FALLEN;
+        }
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+    protected:
+        Ogre::Vector3 mVelocity;
+        Creature::AnimationSpeedPair mAnimStehenRechts;
+        Creature::AnimationSpeedPair mAnimStehenLinks;
+        Creature::AnimationSpeedPair mAnimStehen;
+        mutable AbstractMovement *mRotationMovement;
+        mutable AbstractMovement *mStepRecognitionMovement;
+        virtual AbstractMovement* getRotationMovement() const
+        {
+            if( mRotationMovement == NULL)
+            {
+                mRotationMovement = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+            }
+            if( mRotationMovement == NULL )
+            {
+                Throw(NullPointerException, &quot;Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.&quot;);
+            }
+            return mRotationMovement;
+        }
+        virtual AbstractMovement* getStepRecognitionMovement() const
+        {
+            if( mStepRecognitionMovement == NULL )
+            {
+                mStepRecognitionMovement = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_STUFENERKENNUNG);
+            }
+            if( mStepRecognitionMovement == NULL )
+            {
+                Throw(NullPointerException, &quot;Konnte Movement mit der Id MT_STUFENERKENNUNG nicht finden.&quot;);
+            }
+            return mStepRecognitionMovement;
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StepRecognitionMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StepRecognitionMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StepRecognitionMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,50 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __StepRecognitionMovement_H__
+#define __StepRecognitionMovement_H__
+
+#include &quot;AbstractMovement.h&quot;
+
+
+namespace rl
+{
+    class StepRecognitionMovement : public AbstractMovement
+    {
+    public:
+        StepRecognitionMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STUFENERKENNUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const;
+    protected:
+        bool mMoveToNextTarget;
+        Ogre::Vector3 mNextTarget;
+        Ogre::Real mLastSquaredDistance;
+        Ogre::Real mLinearSpringK, mLinearDampingK;
+        PhysicsMaterialRaycast mRaycast;
+    };
+
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StrafeMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StrafeMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StrafeMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __StrafeMovement_H__
+#define __StrafeMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class StrafeMovement : public WalkMovement
+    {
+    public:
+        StrafeMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    protected:
+        bool mLeft;
+        Creature::AnimationSpeedPair mAnim1;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/WalkBackwardsMovement.h
===================================================================
--- rl/trunk/engine/rules/include/WalkBackwardsMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/WalkBackwardsMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __WalkBackwardsMovement_H__
+#define __WalkBackwardsMovement_H__
+
+#include &quot;WalkMovement.h&quot;
+
+
+namespace rl
+{
+    class WalkBackwardsMovement : public WalkMovement
+    {
+    public:
+        WalkBackwardsMovement(CreatureController *creature) : WalkMovement(creature)
+        {
+            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;gehen_rueckwaerts&quot;);
+        }
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity)
+        {
+            velocity = mMovingCreature-&gt;getCurrentGS() / 4.0;
+            return isPossible();
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/WalkMovement.h
===================================================================
--- rl/trunk/engine/rules/include/WalkMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/WalkMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __WalkMovement_H__
+#define __WalkMovement_H__
+
+#include &quot;StandAroundMovement.h&quot;
+
+
+namespace rl
+{
+    class WalkMovement : public StandAroundMovement
+    {
+    public:
+        WalkMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &amp;velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const;
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -15,6 +15,7 @@
 */
 #include &quot;stdinc.h&quot; //precompiled header
 
+#include &quot;AbstractMovement.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;DsaManager.h&quot;
@@ -28,6 +29,24 @@
 #include &quot;GameObjectManager.h&quot;
 #include &quot;RulesMessages.h&quot;
 
+// included Movements
+#include &quot;AbstractMovement.h&quot;
+#include &quot;FallDownMovement.h&quot;
+#include &quot;JogBackwardsMovement.h&quot;
+#include &quot;JogFastMovement.h&quot;
+#include &quot;JogMovement.h&quot;
+#include &quot;JumpHighMovement.h&quot;
+#include &quot;JumpLongMovement.h&quot;
+#include &quot;JumpToTargetMovement.h&quot;
+#include &quot;LieDownMovement.h&quot;
+#include &quot;RotateMovement.h&quot;
+#include &quot;SneakMovement.h&quot;
+#include &quot;SprintMovement.h&quot;
+#include &quot;StandAroundMovement.h&quot;
+#include &quot;StepRecognitionMovement.h&quot;
+#include &quot;StrafeMovement.h&quot;
+#include &quot;WalkBackwardsMovement.h&quot;
+#include &quot;WalkMovement.h&quot;
 
 
 using namespace Ogre;
@@ -37,1625 +56,7 @@
 {
     const Ogre::String CreatureController::PROPERTY_CREATUREID = &quot;creature_id&quot;;
 
-    const Real minSquaredSpeed = 0.6;
 
-    // auch wenn Fallen nicht m&#246;glich ist (auf dem Boden und bewusstlos / Tod)
-    class Liegen : public AbstractMovement
-    {
-    public:
-	Liegen(CreatureController *creature) :
-	    AbstractMovement(creature)
-	{
-	    mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;liegen&quot;);
-            mAnim1 = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;sterben&quot;);
-	}
-	virtual CreatureController::MovementType getId() const {return CreatureController::MT_LIEGEN;}
-	virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-	virtual void activate()
-	{
-	    LOG_MESSAGE(Logger::RULES, &quot;Creature '&quot;+mMovingCreature-&gt;getCreature()-&gt;getName()+&quot;' liegt (evt bewusstlos) auf dem Boden.&quot;);
-	}
-	virtual void deactivate()
-	{
-	}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-	{
-	    velocity = 0.0f;
-	    return isPossible();
-	}
-        virtual bool isPossible() const
-	{
-	    return true;
-	}
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-	{
-	}
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-	{
-            // todo: wieder aufstehen
-            if( mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_DEAD | Effect::LS_UNCONSCIOUS) )
-                mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second, 1);
-            else
-                mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second, 1);
-	    return true;
-	}
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-	{
-	}
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-	{
-	    direction = Vector3::ZERO;
-		return false;
-	}
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-	{
-	    rotation = Vector3::ZERO;
-		return false;
-	}
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-        Creature::AnimationSpeedPair mAnim1;
-    };
-
-
-
-
-    class Fallen : public AbstractMovement
-    {
-    public:
-        Fallen(CreatureController *creature) :
-          AbstractMovement(creature)
-          {
-              mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen&quot;);
-              //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_anfang&quot;);
-              //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_landung_aufgefangen&quot;);
-              //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_landung_verletzt&quot;);
-          }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_FALLEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual void activate()
-        {
-	    mVel = 0;
-        }
-        virtual void deactivate()
-        {
-            std::ostringstream oss;
-            oss &lt;&lt; &quot;Fallen v: &quot; &lt;&lt; mVel &lt;&lt; &quot;   ermittelte Hoehe: &quot; &lt;&lt; mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y));
-            int h = int(mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y)));
-	    oss &lt;&lt; &quot;    verwendete Hoehe: &quot; &lt;&lt; h &lt;&lt; &quot;m&quot;;
-
-	    if( h &lt; 6 &amp;&amp; h &gt; 0 ) // nicht in den Regeln, aber angenehmer, bei gelunger GE-Probe noch aufgefangen
-	    {
-		int probe = mMovingCreature-&gt;getCreature()-&gt;doEigenschaftsprobe(&quot;GE&quot;, 2*h-6);
-		if( probe == RESULT_PATZER )
-		{
-		    h++;
-		    oss &lt;&lt; &quot;    GE-Patzer!&quot;;
-		}
-		else if( probe &gt;= 0 )
-		{
-		    h = 0;
-		    oss &lt;&lt; &quot;    Nochmal geschickt gelandet!&quot;;
-		}
-	    }
-
-
-            if( h &gt; 0 )
-            {
-
-                std::multiset&lt;int&gt; wuerfel;
-                for(int i = 0; i &lt; h; i++)
-                    wuerfel.insert( DsaManager::getSingleton().rollD6() );
-                int probenErschwernis = h;
-                if( probenErschwernis &gt; 10 )
-                    probenErschwernis = 10;
-
-                int taw = 0;
-                if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;K&#239;&#191;&#189;rperbeherrschung&quot;) )
-                {
-                    taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;K&#239;&#191;&#189;rperbeherrschung&quot;, probenErschwernis);
-                }
-
-		int abgefangenerSchaden = 0;
-                for( int i = 0; i &lt; taw; i++)
-                {
-                    if( wuerfel.size() &lt;= 0 )
-                        break;
-		    abgefangenerSchaden += *(--(wuerfel.end()));
-                    wuerfel.erase(--(wuerfel.end()));
-                }
-
-
-                int sum = 0;
-                for( std::multiset&lt;int&gt;::iterator it = wuerfel.begin(); it != wuerfel.end(); it++)
-                    sum += *it;
-
-                mMovingCreature-&gt;getCreature()-&gt;damageLe(sum, Creature::LEDAMAGE_TP_A);
-
-                oss &lt;&lt; &quot;    Schaden: &quot; &lt;&lt; sum &lt;&lt; &quot;    abgefangener Schaden: &quot; &lt;&lt; abgefangenerSchaden;
-            }
-            LOG_MESSAGE(Logger::RULES, oss.str());
-
-        }
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE
-                &amp;&amp; !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mVel = max(-mMovingCreature-&gt;getVelocity().y,mVel);
-            mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second, 0);
-            return true;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            direction = Vector3::ZERO;
-            return false;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-        Real mVel;
-    };
-
-
-
-
-    class Stehen : public AbstractMovement
-    {
-    public:
-        Stehen(CreatureController *creature) : 
-            AbstractMovement(creature), 
-            mVelocity(Vector3::ZERO), 
-            mRotationMovement(NULL), 
-            mStepRecognitionMovement(NULL)
-            {
-                mAnimStehenLinks = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_links&quot;);
-                mAnimStehenRechts = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_rechts&quot;);
-                mAnimStehen = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);
-            }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const
-	{
-	    if( mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR )
-		return CreatureController::MT_LIEGEN;
-
-	    return CreatureController::MT_FALLEN;
-	}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            getRotationMovement()-&gt;activate();
-            getStepRecognitionMovement()-&gt;activate();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-            getRotationMovement()-&gt;deactivate();
-            getStepRecognitionMovement()-&gt;deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 0 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-            getRotationMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
-
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-            body-&gt;getMassMatrix(mass, inertia);
-
-            Vector3 vel = mMovingCreature-&gt;getVelocity();
-            vel.y = 0;
-            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
-            //if(vel.squaredLength() &gt; mVelocity.squaredLength())
-            //    delay *= 1.5;
-            Vector3 diff = (mVelocity - vel);
-            force = mass * diff / delay;
-            // additional remove movement in wrong direction
-            force += mass * (mVelocity.normalisedCopy() * vel.length() - vel) / delay; // do we need this, does this improve the movement behaviour
-            // (changing direction during slow movement makes char slide sideways)
-            force.y = 0;
-
-            getStepRecognitionMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            direction.normalise();
-            Real velocity;
-            calculateBaseVelocity(velocity);
-            mVelocity = direction * velocity;
-            applyAuChanges(elapsedTime);
-            setAnimation(elapsedTime);
-            bool ret = false;
-            if( getRotationMovement()-&gt;isPossible() )
-                if( getRotationMovement()-&gt;run(elapsedTime, direction, rotation) )
-                    ret = true;
-            if( getStepRecognitionMovement()-&gt;isPossible() )
-                if (getStepRecognitionMovement()-&gt;run(elapsedTime, direction, rotation) )
-                    ret = true;
-            return ret;
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real omegaY = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega().y;
-            if( omegaY &gt; Degree(20).valueRadians() )
-                mMovingCreature-&gt;setAnimation(mAnimStehenRechts.first, mAnimStehenRechts.second);
-            else
-            {
-                if( omegaY &lt; Degree(-20).valueRadians() )
-                    mMovingCreature-&gt;setAnimation(mAnimStehenLinks.first, mAnimStehenLinks.second);
-                else
-                    mMovingCreature-&gt;setAnimation(mAnimStehen.first, mAnimStehen.second);
-            }
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature-&gt;getCreature()-&gt;regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            return getRotationMovement()-&gt;isRotationPossible(rotation);
-        }
-    protected:
-        Ogre::Vector3 mVelocity;
-        Creature::AnimationSpeedPair mAnimStehenRechts;
-        Creature::AnimationSpeedPair mAnimStehenLinks;
-        Creature::AnimationSpeedPair mAnimStehen;
-        mutable AbstractMovement *mRotationMovement;
-        mutable AbstractMovement *mStepRecognitionMovement;
-        virtual AbstractMovement* getRotationMovement() const
-        {
-            if( mRotationMovement == NULL)
-            {
-                mRotationMovement = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
-            }
-            if( mRotationMovement == NULL )
-            {
-                Throw(NullPointerException, &quot;Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.&quot;);
-            }
-            return mRotationMovement;
-        }
-        virtual AbstractMovement* getStepRecognitionMovement() const
-        {
-            if( mStepRecognitionMovement == NULL )
-            {
-                mStepRecognitionMovement = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_STUFENERKENNUNG);
-            }
-            if( mStepRecognitionMovement == NULL )
-            {
-                Throw(NullPointerException, &quot;Konnte Movement mit der Id MT_STUFENERKENNUNG nicht finden.&quot;);
-            }
-            return mStepRecognitionMovement;
-        }
-    };
-
-    class Drehen : public AbstractMovement
-    {
-    public:
-        Drehen(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
-        {
-            mRotLinearSpringK = 600.0f;
-            Real relationCoefficient = 1.0f;
-            mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = 0.3f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-        }
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mYaw = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-            body-&gt;getMassMatrix(mass, inertia);
-
-            Quaternion orientation;
-            Vector3 position;
-            body-&gt;getPositionOrientation(position, orientation);
-            // Calculate angular velocity
-            // We first need the yaw rotation from actual yaw to desired yaw
-            Vector3 src = orientation*Vector3::UNIT_Z;
-            src.y = 0;
-            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
-            dst.y = 0;
-            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
-
-            // using a spring system to apply the rotation
-            Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
-            Vector3 omega = body-&gt;getOmega();
-            omega.x = omega.z = 0;
-            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-
-            torque = springAcc * inertia;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mYaw += Radian(rotation.y);
-            while (mYaw.valueDegrees() &gt; 360.0f) mYaw -= Degree(360.0f);
-            while (mYaw.valueDegrees() &lt; -360.0f) mYaw += Degree(360.0f);
-
-            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-            Quaternion orientation;
-            Vector3 position;
-            body-&gt;getPositionOrientation(position, orientation);
-
-            Real diff = (orientation.getYaw() - mYaw).valueDegrees();
-            return diff &lt;= 0.5f &amp;&amp; diff &gt;= -0.5f;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            Vector3 oldRotation(rotation);
-            rotation.x = rotation.z = 0;
-            return oldRotation.x == 0 &amp;&amp; oldRotation.z == 0;
-        }
-    protected:
-        Ogre::Radian mYaw;
-        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
-        virtual Real getMovementDefinedValue() {return mYaw.valueRadians();}
-    };
-
-
-    class Gehen : public Stehen
-    {
-    public:
-        Gehen(CreatureController *creature) : Stehen(creature)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;gehen&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 3.6f * 0.7f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            Stehen::run(elapsedTime, direction, rotation);
-            return true;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = direction.y = 0;
-            if( direction.z &gt; 0 )
-                direction.z = 0;
-            return oldDirection.x == 0 &amp;&amp; oldDirection.y == 0 &amp;&amp; oldDirection.z &gt; 0;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature-&gt;getCreature()-&gt;regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real speed =  -mMovingCreature-&gt;getVelocity().z;
-            if( fabs(speed) &lt; 0.1 )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-            switch( mMovingCreature-&gt;getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_JOGGEN:
-            case CreatureController::MT_LAUFEN:
-            case CreatureController::MT_RENNEN:
-                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
-                if( mMovingCreature-&gt;getLastMovementChange() &lt; 1.0f )
-                    weight = mMovingCreature-&gt;getLastMovementChange() / 1.0f;
-                break;
-            default:
-                break;
-            }
-
-
-            // apply relTimeOffset only once
-            if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, speed * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL &amp;&amp; relTimeOffset != 0 )
-                meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
-        }
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-    };
-
-    class Joggen : public Gehen
-    {
-    public:
-        Joggen(CreatureController *creature) : Gehen(creature)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;joggen&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 2.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return Gehen::isPossible() &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed)
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature-&gt;getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
-                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
-                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, -mMovingCreature-&gt;getVelocity().z * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL &amp;&amp; relTimeOffset != 0)
-                meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
-        }
-    };
-
-    class Laufen : public Gehen
-    {
-    public:
-        Laufen(CreatureController *creature) : Gehen(creature), mTimePerAu(1L), mLastProbe(0)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;laufen&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 1.6f; // was 2.0
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature-&gt;getMovement() == this )
-                return Gehen::isPossible() &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
-            else
-                return Gehen::isPossible() &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength()&lt; minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-            else
-                mMovingCreature-&gt;getCreature()-&gt;damageAu(elapsedTime/mTimePerAu);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature-&gt;getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
-                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
-                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, -mMovingCreature-&gt;getVelocity().z * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL &amp;&amp; relTimeOffset != 0)
-                meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
-        }
-        virtual void activate()
-        {
-            Gehen::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + Date::ONE_SPIELRUNDE &gt;= now || mLastProbe == 0 )
-            {
-                mTimePerAu = 120; // was 180
-                if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 5;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 10;
-                    }
-                    else
-                    {
-                        mTimePerAu += taw * 5;
-                    }
-                }
-                else
-                {
-                    mTimePerAu = 120; // was 180
-                }
-            }
-        }
-    protected:
-        Real mTimePerAu;
-        Date mLastProbe;
-    };
-
-
-    class Rennen : public Gehen
-    {
-    public:
-        Rennen(CreatureController *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;rennen&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS();
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature-&gt;getMovement() == this )
-                return Gehen::isPossible() &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax() * 0.3 &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
-            else
-                return Gehen::isPossible() &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax() * 0.5 &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            bool ret = Gehen::run(elapsedTime, direction, rotation);
-            mVelocity += mVelocityImprovement;
-            return ret;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-            else
-                mMovingCreature-&gt;getCreature()-&gt;damageAu(elapsedTime/1.5);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature-&gt;getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
-                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
-                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, fabs(mMovingCreature-&gt;getVelocity().z) *mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL &amp;&amp; relTimeOffset )
-                meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
-        }
-        virtual void activate()
-        {
-            Gehen::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + mMovingCreature-&gt;getCreature()-&gt;getAuMax() * Date::ONE_SECOND &gt;= now || mLastProbe == 0)
-            {
-                mVelocityImprovement = 0;
-                if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 0.2;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 0.3;
-                    }
-                    else
-                    {
-                        mVelocityImprovement += taw * 0.1;
-                    }
-                }
-                else
-                {
-                    mVelocityImprovement = 0;
-                }
-            }
-        }
-    protected:
-        Real mVelocityImprovement;
-        Date mLastProbe;
-    };
-
-    class RueckwaertsGehen : public Gehen
-    {
-    public:
-        RueckwaertsGehen(CreatureController *creature) : Gehen(creature)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;gehen_rueckwaerts&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 4.0;
-            return isPossible();
-        }
-    };
-
-    class RueckwaertsJoggen : public Joggen
-    {
-    public:
-        RueckwaertsJoggen(CreatureController *creature) : Joggen(creature)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;joggen_rueckwaerts&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 3.2;
-            return isPossible();
-        }
-    };
-
-
-    class SeitwaertsGehen : public Gehen
-    {
-    public:
-        SeitwaertsGehen(CreatureController *creature) : Gehen(creature), mLeft(true)
-        {
-            mAnim1 = creature-&gt;getCreature()-&gt;getAnimation(&quot;seitwaerts_rechts&quot;);
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;seitwaerts_links&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 4.0;
-            return isPossible();
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.z = direction.y = 0;
-            return oldDirection.z == 0 &amp;&amp; oldDirection.y == 0;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mLeft = direction.x &lt; 0;
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mLeft )
-                mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature-&gt;getVelocity().x);
-            else
-                mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second * -mMovingCreature-&gt;getVelocity().x);
-        }
-    protected:
-        bool mLeft;
-        Creature::AnimationSpeedPair mAnim1;
-    };
-
-    class Schleichen : public Gehen
-    {
-    public:
-        Schleichen(CreatureController *creature) : Gehen(creature), mState(UP), mTimer(0)
-        {
-            mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen&quot;);
-            mAnim1= creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen_vorwaerts&quot;);
-            mAnim2 = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_zu_schleichen&quot;);
-            mAnim3= creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen_zu_stehen&quot;);
-            mAnimStehen= creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = mMovingCreature-&gt;getCurrentGS() / 6.0;
-            return isPossible();
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt; 0.5f )
-                    mState = DOWN;
-            }
-            if( mState == UP )
-            {
-                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt; 0.5f )
-                    mState = UP;
-            }
-            if( mState == DOWN )
-            {
-                //setAnimation(elapsedTime);
-                direction.normalise();
-                Real velocity;
-                calculateBaseVelocity(velocity);
-                mVelocity = direction * velocity;
-                if( direction == Vector3::ZERO || (-mMovingCreature-&gt;getVelocity().z) &lt; 0.1)
-                    mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second);
-                else
-                    mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature-&gt;getVelocity().z);
-                applyAuChanges(elapsedTime);
-                if( getRotationMovement()-&gt;isPossible() )
-                    getRotationMovement()-&gt;run(elapsedTime, direction, rotation);
-            }
-            else
-                mVelocity = Vector3::ZERO;
-            return true;
-        }
-        void applyAuChanges(Ogre::Real elapsedTime) {}
-        virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
-        virtual void activate()
-        {
-            Gehen::activate();
-            mState = UPTODOWN;
-            mMovingCreature-&gt;setAnimation(mAnim2.first,mAnim2.second,1,mAnimStehen.first);
-            mTimer = 0;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == UP;
-        }
-        virtual void requestChangeToMovement(CreatureController::MovementType id)
-        {
-            if( mState == DOWN )
-            {
-                mState = DOWNTOUP;
-                mMovingCreature-&gt;setAnimation(mAnim3.first,mAnim3.second,1,mAnimStehen.first);
-                mTimer = 0;
-            }
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Real mTimer;
-        Creature::AnimationSpeedPair mAnim1;
-        Creature::AnimationSpeedPair mAnim2;
-        Creature::AnimationSpeedPair mAnim3;
-    };
-
-
-    class Hochsprung : public AbstractMovement
-    {
-    public:
-        Hochsprung(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0), mMoveForward(0)
-        {
-            mAnimation = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung&quot;);
-            mAnimationAbsprung = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung_absprung&quot;);
-            mAnimationLandung = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung_landung&quot;);
-            mAnimationForCollision = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);  // wird das hier gebraucht?
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature-&gt;setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
-            mTimer = 0;
-            calculateBaseVelocity(mHeight);
-
-            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
-            {
-                int tap = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
-                if( tap &gt; 0 )
-                {
-                    if( tap == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 12.5;
-                    }
-                    else if( tap == RESULT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 25.0;
-                    }
-                    else
-                    {
-                        mHeight += tap / 25.0;
-                    }
-                }
-            }
-            else
-            {
-            }
-            mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = (mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;GE&quot;) +
-                        mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;KK&quot;)) / 4.0 / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch&#239;&#191;&#189;pfung ein KK abziehen
-            //if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
-            //    velocity -= (mErschoepfung - getEigenschaft(&quot;KO&quot;)) / 4.0 / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() &lt; getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft(&quot;GE&quot;) / 4.0 / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature-&gt;getMovement() == this )
-                return
-                    (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
-                    mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
-                    !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-            else
-                return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-            body-&gt;getMassMatrix(mass, inertia);
-
-            if( mJumpNow )
-            {
-                mJumpNow = false;
-
-                Real m = mass;
-                Real g = PhysicsManager::getSingleton().getGravity().length();
-                Real t = timestep;
-                Real h = mHeight;
-                Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
-                force = Vector3(0,
-                    jumpForce,
-                    0);
-                mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
-            }
-            else if (mState == UP &amp;&amp; mMoveForward != 0) // try to move forward, if wanted
-            {
-                // low velocity towards this direction
-                if(mMoveForward &gt; 0)
-                    mMoveForward = 1.0;
-                else
-                    mMoveForward = -1.0;
-
-
-
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-                body-&gt;getMassMatrix(mass, inertia);
-
-                Vector3 vel = mMovingCreature-&gt;getVelocity();
-                Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
-                Real diff = (mMoveForward - vel.z);
-                force.z += mass * diff / delay;
-            }
-
-            Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mMoveForward = direction.z;
-
-            if( mState == DOWN )
-            {
-                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt;= 0.5f )
-                {
-                    mState = DOWN;
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &lt; 0.5f )
-                {
-                    mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
-                }
-                else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature-&gt;setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
-                    mTimer = 0;
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt;= 0.25f )
-                {
-                    mState = UP;
-                    mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
-                    mMovingCreature-&gt;setAnimation(mAnimation.first, mAnimation.second);
-                    mJumpNow = true;
-                    mTimer = 0;
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = 0;
-            if(direction.y &lt; 0)
-                direction.y = 0;
-            return oldDirection.x == 0 &amp;&amp; oldDirection.y &gt; 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mHeight;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-        Ogre::Real mMoveForward;
-        Creature::AnimationSpeedPair mAnimation;
-        Creature::AnimationSpeedPair mAnimationAbsprung;
-        Creature::AnimationSpeedPair mAnimationLandung;
-        Creature::AnimationSpeedPair mAnimationForCollision;
-    };
-
-
-    class Weitsprung : public AbstractMovement
-    {
-    public:
-        Weitsprung(CreatureController *creature) :
-          AbstractMovement(creature), mState(DOWN), mWidth(0),
-              mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
-              mApplyForceTimer(0), mLastForce(Vector3::ZERO),
-              mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17)))
-        {
-            mAnimation = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung&quot;);
-            mAnimationAbsprung = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung_absprung&quot;);
-            mAnimationLandung = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung_landung&quot;);
-            mAnimationForCollision = creature-&gt;getCreature()-&gt;getAnimation(&quot;rennen&quot;); // wird das hier gebraucht?
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature-&gt;setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
-            mTimer = 0;
-            calculateBaseVelocity(mWidth);
-
-
-            // the person will only achieve this width if it is running
-            // retrieve run movement
-            AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
-            if( run != NULL )
-            {
-                Real vel(0);
-                run-&gt;calculateBaseVelocity(vel);
-                Real factor = -mMovingCreature-&gt;getVelocity().z / vel;
-                factor = std::max(Real(0),factor);
-                // without moving before, the width will be 1/3
-                mWidth = mWidth/3. + mWidth * 2./3. * factor;
-            }
-
-            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
-            {
-                int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
-                if( taw &gt; 0 )
-                {
-                    if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 25.0;
-                    }
-                    else if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 50.0;
-                    }
-                    else
-                    {
-                        mWidth += taw / 50.0;
-                    }
-                }
-            }
-
-            mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = (mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;GE&quot;) +
-                        mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;KK&quot;)) / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch&#239;&#191;&#189;pfung ein KK abziehen
-            //if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
-            //    velocity -= (mErschoepfung - getEigenschaft(&quot;KO&quot;)) / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() &lt; getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft(&quot;GE&quot;) / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature-&gt;getMovement() == this )
-                return
-                    (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
-                    mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
-                    mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
-                    !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-            else
-                return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-            body-&gt;getMassMatrix(mass, inertia);
-
-
-            if( mJumpNow &amp;&amp; timestep != 0 )
-            {
-                mApplyForceTimer += timestep;
-
-                if( mApplyForceTimer == timestep // first time
-                    &amp;&amp; mApplyForceTimer &lt; mApplyForceTime )// this is handled below
-                {
-                    Real t1 = mApplyForceTime;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx &gt;= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-                        ax =  (v1x - v0) / t1;
-                        ay = v1y/t1 + g;
-                    }
-
-                    mLastForce.x = 0;
-                    mLastForce.y = ay * mass;
-                    mLastForce.z = -ax * mass;
-                }
-
-                if( mApplyForceTimer &lt; mApplyForceTime )
-                {
-                    force = mLastForce;
-                }
-                else
-                {
-                    mJumpNow = false;
-                    // adoption of the formula to our real jump time
-                    Real t1 = mApplyForceTimer;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx &gt;= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-
-                        Vector3 v_now = mMovingCreature-&gt;getVelocity();
-                        ax =  (v1x - -v_now.z) / timestep;
-                        ay = (v1y- v_now.y)/timestep + g;
-                    }
-
-                    force.x = 0;
-                    force.y = ay * mass;
-                    force.z = -ax * mass;
-                }
-            }
-
-            Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == DOWN )
-            {
-                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt;= 0.2f )
-                {
-                    mState = DOWN;
-LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: DOWN&quot;);
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &lt; 0.2f )
-                {
-                    mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
-                }
-                else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature-&gt;setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
-                    mTimer = 0;
-LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: UPTODOWN&quot;);
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer &gt;= 0.3f )
-                {
-                    mState = UP;
-                    mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
-                    mMovingCreature-&gt;setAnimation(mAnimation.first, mAnimation.second, 1, mAnimationForCollision.first);
-                    mJumpNow = true;
-                    mApplyForceTimer = 0;
-                    mVelocityBeforeJump = -mMovingCreature-&gt;getVelocity().z;
-                    mTimer = 0;
-LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: UP&quot;);
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = 0;
-            if(direction.y &lt;= 0 || direction.z &gt;= 0)
-                direction.y = direction.z = 0;
-            return oldDirection.x == 0 &amp;&amp; oldDirection.z &lt; 0 &amp;&amp; oldDirection.y &gt; 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mWidth;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-        Ogre::Real mApplyForceTime;
-        Ogre::Real mApplyForceTimer;
-        Ogre::Vector3 mLastForce;
-        Ogre::Real mVelocityBeforeJump;
-        Ogre::Real mTanJumpAngle;
-        Creature::AnimationSpeedPair mAnimation;
-        Creature::AnimationSpeedPair mAnimationAbsprung;
-        Creature::AnimationSpeedPair mAnimationLandung;
-        Creature::AnimationSpeedPair mAnimationForCollision;
-    };
-
-
-    class StepRecognition : public AbstractMovement
-    {
-    public:
-        StepRecognition(CreatureController *creature) : 
-            AbstractMovement(creature), 
-            mMoveToNextTarget(false)
-        {
-            mLinearSpringK = 600.0f;
-            Real relationCoefficient = 1.2f;
-            mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STUFENERKENNUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mMoveToNextTarget = false;
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &amp;velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
-                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 0 &amp;&amp;
-                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
-        {
-            // move to nextTarget
-            if( mMoveToNextTarget )
-            {
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-                body-&gt;getMassMatrix(mass, inertia);
-
-                Vector3 pos = mMovingCreature-&gt;getCreature()-&gt;getPosition();
-                Vector3 diff = mNextTarget - pos;
-
-                Vector3 vel = body-&gt;getVelocity();
-
-                force.y = mass*( mLinearSpringK*diff.y - mLinearDampingK*vel.y );
-                std::ostringstream oss;
-                oss &lt;&lt; &quot;Step-Recognition: diff: &quot; &lt;&lt; diff.y &lt;&lt; &quot;    vel: &quot; &lt;&lt; vel.y &lt;&lt; &quot;    Step force: &quot; &lt;&lt; force.y;
-		oss &lt;&lt; &quot;    DiffToTarget: &quot; &lt;&lt; 
-		    mMovingCreature-&gt;getCreature()-&gt;getOrientation().Inverse() * 
-		    (mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition());
-                LOG_MESSAGE(Logger::RULES, oss.str());
-            }
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            Vector3 vel = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;getVelocity();
-	    Real velY = vel.y;
-            vel.y = 0;
-
-            if( !mMoveToNextTarget ) // check if we need to move up for a step
-            {
-                // raycast in the direction we should move to
-                Vector3 globalDir = mMovingCreature-&gt;getCreature()-&gt;getOrientation() * direction; // the direction in global space
-                if( globalDir == Vector3::ZERO )
-                    return true;
-
-                Real raylen = vel.length() / 3;  // use longer ray, if higher velocity
-                if ( raylen &lt; 0.5 )
-                    raylen = 0.4;
-
-                //std::ostringstream oss;
-                //oss &lt;&lt; &quot;StepRecognition Raylen: &quot; &lt;&lt; raylen;
-                //LOG_MESSAGE(Logger::RULES, oss.str());
-
-
-                // raycasts
-                PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-
-                Vector3 start = mMovingCreature-&gt;getCreature()-&gt;getPosition() + Vector3::UNIT_Y * 0.1f;
-                globalDir.y = 0;
-                globalDir.normalise();
-                Vector3 end = start + globalDir*raylen;
-
-                bool foundbody = false;
-                Real foundDistance = 0;
-
-                RaycastInfo info;
-                do
-                {
-                    info = 
-                        mRaycast.execute(
-                            PhysicsManager::getSingleton()._getNewtonWorld(),
-                            &amp;materialVector,
-                            start, end);
-
-                    // do we need to check bodies left and right of this ray? (step width?)
-
-
-                    // already found nearer body
-                    if( foundbody )
-                    {
-                        if( info.mBody &amp;&amp; (info.mDistance*raylen &gt;= foundDistance*raylen + 0.19) || // step deep enough
-                            !info.mBody )
-                        {
-                            // found a step
-                            mMoveToNextTarget = true;
-                            mNextTarget = start + globalDir*raylen*foundDistance + 0.1 * globalDir;
-                            std::ostringstream oss;
-			    Vector3 stepInLocalCoords = mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition();
-			    Quaternion ori = mMovingCreature-&gt;getCreature()-&gt;getOrientation();
-			    stepInLocalCoords = ori.Inverse() * stepInLocalCoords;
-                            oss &lt;&lt; &quot;Step-Recognition: Next Step: &quot; &lt;&lt; stepInLocalCoords;
-                            LOG_MESSAGE(Logger::RULES, oss.str());
-                            break;
-                        }
-                    }
-
-                    if( info.mBody )
-                    {
-                        foundbody = true;
-                        foundDistance = info.mDistance;
-                    }
-
-
-                    start += Vector3::UNIT_Y * 0.05f;
-                    end += Vector3::UNIT_Y * 0.05f;
-                }
-                while( info.mBody &amp;&amp; (start - mMovingCreature-&gt;getCreature()-&gt;getPosition()).y &lt;= 0.5 );
-            }
-
-
-            // check if the target is still needed
-            // perform check also to verify found step
-            if( mMoveToNextTarget )
-            {
-                Vector3 diffToTarget = mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition();
-		Real diffToTargetY = diffToTarget.y;
-                diffToTarget.y = 0;
-                
-                // different direction
-                Vector3 globalDir = mMovingCreature-&gt;getCreature()-&gt;getOrientation() * direction; // the direction in global space
-		globalDir.y = 0;
-
-
-                if( globalDir == Vector3::ZERO )
-                {
-                    mMoveToNextTarget = false;
-                    LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction null&quot;);
-                    return false;
-                }
-
-                // target reached
-                if( diffToTarget.squaredLength() &lt; 0.01)
-                {
-                    mMoveToNextTarget = false;
-                    LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step reached&quot;);
-                    return false;
-                }
-
-                // different direction
-                Quaternion oriDiff = diffToTarget.getRotationTo(globalDir, Vector3::UNIT_Y);
-                Degree angleDiff;
-                Vector3 axis = Vector3::UNIT_Y;
-                oriDiff.ToAngleAxis(angleDiff, axis);
-                Real f = angleDiff.valueDegrees();
-                //std::ostringstream oss;
-                //oss &lt;&lt; &quot;Step-Recognition: angle: &quot; &lt;&lt; f &lt;&lt; &quot;    axis: &quot; &lt;&lt; axis;
-                //LOG_MESSAGE(Logger::RULES, oss.str());
-               //if( !diffToTarget.directionEquals(globalDir, Degree(15)) )
-		if( f &gt; 2.0f )
-                {
-                    mMoveToNextTarget = false;
-                    //LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction wrong&quot;);
-                    return false;
-                }
-
-
-		// already above target, but slow velocity
-		if( diffToTargetY &lt; 0 &amp;&amp; fabs(velY) &lt; 0.01 )
-		{
-                    mMoveToNextTarget = false;
-                    //LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: slow and abov target-height!&quot;);
-                    return false;
-		}
-            }
-
-            return mMoveToNextTarget;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
-        {
-            Vector3 oldRotation(rotation);
-            rotation = Vector3::ZERO;
-            return oldRotation == Vector3::ZERO;
-        }
-    protected:
-        bool mMoveToNextTarget;
-        Vector3 mNextTarget;
-        Real mLastSquaredDistance;
-        Real mLinearSpringK, mLinearDampingK;
-        PhysicsMaterialRaycast mRaycast;
-    };
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-// ---------------------------- CreatureController -----------------------------
-
     CreatureController::CreatureController(Creature *creature) :
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),
@@ -1685,49 +86,52 @@
         movementPair.second = NULL;
         mMovementMap.insert(movementPair);
         movementPair.first = MT_LIEGEN;
-        movementPair.second = new Liegen (this);
+        movementPair.second = new LieDownMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_FALLEN;
-        movementPair.second = new Fallen (this);
+        movementPair.second = new FallDownMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_DREHEN;
-        movementPair.second = new Drehen (this);
+        movementPair.second = new RotateMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_STEHEN;
-        movementPair.second = new Stehen (this);
+        movementPair.second = new StandAroundMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_GEHEN;
-        movementPair.second = new Gehen (this);
+        movementPair.second = new WalkMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_JOGGEN;
-        movementPair.second = new Joggen (this);
+        movementPair.second = new JogMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_LAUFEN;
-        movementPair.second = new Laufen (this);
+        movementPair.second = new JogFastMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RENNEN;
-        movementPair.second = new Rennen (this);
+        movementPair.second = new SprintMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RUECKWAERTS_GEHEN;
-        movementPair.second = new RueckwaertsGehen (this);
+        movementPair.second = new WalkBackwardsMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RUECKWAERTS_JOGGEN;
-        movementPair.second = new RueckwaertsJoggen (this);
+        movementPair.second = new JogBackwardsMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_SEITWAERTS_GEHEN;
-        movementPair.second = new SeitwaertsGehen (this);
+        movementPair.second = new StrafeMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_SCHLEICHEN;
-        movementPair.second = new Schleichen (this);
+        movementPair.second = new SneakMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_HOCHSPRUNG;
-        movementPair.second = new Hochsprung (this);
+        movementPair.second = new JumpHighMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_WEITSPRUNG;
-        movementPair.second = new Weitsprung (this);
+        movementPair.second = new JumpLongMovement (this);
         mMovementMap.insert(movementPair);
+        movementPair.first = MT_ZIELSPRUNG;
+        movementPair.second = new JumpToTargetMovement (this);
+        mMovementMap.insert(movementPair);
         movementPair.first = MT_STUFENERKENNUNG;
-        movementPair.second = new StepRecognition (this);
+        movementPair.second = new StepRecognitionMovement (this);
         mMovementMap.insert(movementPair);
 
         mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
@@ -2184,8 +588,5 @@
         }
 	mAbstractLocation = location;
     }
-    
-
-
 }
 

Added: rl/trunk/engine/rules/src/FallDownMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/FallDownMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/FallDownMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,147 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+
+#include &quot;FallDownMovement.h&quot;
+#include &quot;DsaManager.h&quot;
+
+
+using namespace std;
+using namespace Ogre;
+
+namespace rl
+{
+    FallDownMovement::FallDownMovement(CreatureController *creature) :
+        AbstractMovement(creature)
+    {
+        mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen&quot;);
+        //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_anfang&quot;);
+        //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_landung_aufgefangen&quot;);
+        //mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;fallen_landung_verletzt&quot;);
+    }
+    
+        
+    void FallDownMovement::activate()
+    {
+        mVel = 0;
+    }
+        
+    void FallDownMovement::deactivate()
+    {    
+        std::ostringstream oss;
+        oss &lt;&lt; &quot;Fallen v: &quot; &lt;&lt; mVel &lt;&lt; &quot;   ermittelte Hoehe: &quot; &lt;&lt; mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y));
+        int h = int(mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y)));
+        oss &lt;&lt; &quot;    verwendete Hoehe: &quot; &lt;&lt; h &lt;&lt; &quot;m&quot;;
+
+        if( h &lt; 6 &amp;&amp; h &gt; 0 ) // nicht in den Regeln, aber angenehmer, bei gelunger GE-Probe noch aufgefangen
+        {
+            int probe = mMovingCreature-&gt;getCreature()-&gt;doEigenschaftsprobe(&quot;GE&quot;, 2*h-6);
+	
+            if( probe == RESULT_PATZER )
+            {
+                h++;
+                oss &lt;&lt; &quot;    GE-Patzer!&quot;;
+            }
+            else if( probe &gt;= 0 )
+            {
+                h = 0;
+                oss &lt;&lt; &quot;    Nochmal geschickt gelandet!&quot;;
+            }
+        }
+
+        
+        if( h &gt; 0 )
+        {
+            std::multiset&lt;int&gt; wuerfel;
+            for(int i = 0; i &lt; h; i++)
+                wuerfel.insert( DsaManager::getSingleton().rollD6() );
+
+            int probenErschwernis = h;
+            if( probenErschwernis &gt; 10 )
+                probenErschwernis = 10;
+
+            int taw = 0;
+            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;K&#239;&#191;&#189;rperbeherrschung&quot;) )
+            {
+                taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;K&#239;&#191;&#189;rperbeherrschung&quot;, probenErschwernis);
+            }
+
+            int abgefangenerSchaden = 0;
+            for( int i = 0; i &lt; taw; i++)
+            {
+                if( wuerfel.size() &lt;= 0 )
+                    break;
+                abgefangenerSchaden += *(--(wuerfel.end()));
+                wuerfel.erase(--(wuerfel.end()));
+            }
+
+
+            int sum = 0;
+            for( std::multiset&lt;int&gt;::iterator it = wuerfel.begin(); it != wuerfel.end(); it++)
+                sum += *it;
+
+            mMovingCreature-&gt;getCreature()-&gt;damageLe(sum, Creature::LEDAMAGE_TP_A);
+
+            oss &lt;&lt; &quot;    Schaden: &quot; &lt;&lt; sum &lt;&lt; &quot;    abgefangener Schaden: &quot; &lt;&lt; abgefangenerSchaden;
+        }
+        LOG_MESSAGE(Logger::RULES, oss.str());
+
+    }
+    
+    bool FallDownMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+        
+    
+    bool FallDownMovement::isPossible() const
+    {
+        return
+            mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE
+            &amp;&amp; !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
+    }
+
+    
+    void FallDownMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+    }
+    
+    bool FallDownMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mVel = max(-mMovingCreature-&gt;getVelocity().y,mVel);
+        mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second, 0);
+        return true;
+    }
+    
+    void FallDownMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+    
+    bool FallDownMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        direction = Vector3::ZERO;
+        return false;
+    }
+    
+    bool FallDownMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+}
+

Added: rl/trunk/engine/rules/src/JogFastMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JogFastMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JogFastMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,149 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+
+#include &quot;JogFastMovement.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;MeshAnimation.h&quot;
+
+
+using namespace std;
+using namespace Ogre;
+
+
+const Real minSquaredSpeed = 0.6f;
+
+namespace rl
+{
+    JogFastMovement::JogFastMovement(CreatureController *creature) : WalkMovement(creature), mTimePerAu(1L), mLastProbe(0)
+    {
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;laufen&quot;);
+    }
+    
+    
+    
+    bool JogFastMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS() / 1.6f; // was 2.0
+        return isPossible();
+    }
+    
+    bool JogFastMovement::isPossible() const
+    {
+        if( mMovingCreature-&gt;getMovement() == this )
+            return WalkMovement::isPossible() &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
+        else
+            return WalkMovement::isPossible() &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8;
+    }
+
+
+    
+    bool JogFastMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        doTalentProbeIfNecessary();
+        return WalkMovement::run(elapsedTime, direction, rotation);
+    }
+        
+    void JogFastMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength()&lt; minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+        else
+            mMovingCreature-&gt;getCreature()-&gt;damageAu(elapsedTime/mTimePerAu);
+    }
+
+    
+    void JogFastMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature-&gt;getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
+                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
+                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+
+        // apply relTimeOffset only once
+        if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, -mMovingCreature-&gt;getVelocity().z * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL &amp;&amp; relTimeOffset != 0)
+            meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
+    }
+
+    
+    void JogFastMovement::activate()
+    {
+        WalkMovement::activate();
+        doTalentProbeIfNecessary();
+    }
+    
+    void JogFastMovement::doTalentProbeIfNecessary()
+    {
+        Date now = DsaManager::getSingleton().getCurrentDate();
+        if( mLastProbe + Date::ONE_SPIELRUNDE &gt;= now || mLastProbe == 0 )
+        {
+            mTimePerAu = 120; // was 180
+            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
+            {
+                mLastProbe = now;
+                int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
+                if( taw == RESULT_AUTOERFOLG )
+                {
+                    mTimePerAu += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 5;
+                }
+                else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mTimePerAu += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 10;
+                }
+                else
+                {
+                    mTimePerAu += taw * 5;
+                }
+            }
+            else
+            {
+                mTimePerAu = 120; // was 180
+            }
+        }
+    }
+}
+

Added: rl/trunk/engine/rules/src/JogMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JogMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JogMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,93 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;JogMovement.h&quot;
+#include &quot;MeshAnimation.h&quot;
+
+
+using namespace std;
+using namespace Ogre;
+
+
+const Real minSquaredSpeed = 0.6f;
+
+
+namespace rl
+{
+    JogMovement::JogMovement(CreatureController *creature) : WalkMovement(creature)
+    {
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;joggen&quot;);
+    }
+        
+    bool JogMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS() / 2.0f;
+        return isPossible();
+    }
+    
+    bool JogMovement::isPossible() const
+    {
+        return WalkMovement::isPossible() &amp;&amp;
+            mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
+    }
+
+    void JogMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+    }
+    
+    void JogMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed)
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature-&gt;getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
+                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
+                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+        // apply relTimeOffset only once
+        if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, -mMovingCreature-&gt;getVelocity().z * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL &amp;&amp; relTimeOffset != 0)
+            meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/JumpHighMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpHighMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpHighMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,219 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;JumpHighMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+
+namespace rl
+{
+    JumpHighMovement::JumpHighMovement(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0), mMoveForward(0)
+    {
+        mAnimation = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung&quot;);
+        mAnimationAbsprung = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung_absprung&quot;);
+        mAnimationLandung = creature-&gt;getCreature()-&gt;getAnimation(&quot;hochsprung_landung&quot;);
+        mAnimationForCollision = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);  // wird das hier gebraucht?
+    }
+
+    void JumpHighMovement::activate()
+    {
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature-&gt;setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mHeight);
+
+        if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
+        {
+            int tap = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
+            if( tap &gt; 0 )
+            {
+                if( tap == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mHeight += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 12.5;
+                }
+                else if( tap == RESULT_AUTOERFOLG )
+                {
+                    mHeight += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 25.0;
+                }
+                else
+                {
+                    mHeight += tap / 25.0;
+                }
+            }
+        }
+        else
+        {
+        }
+        mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
+    }
+
+    void JumpHighMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool JumpHighMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = (mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;GE&quot;) +
+                mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;KK&quot;)) / 4.0 / 5.0;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch&#239;&#191;&#189;pfung ein KK abziehen
+        //if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
+        //    velocity -= (mErschoepfung - getEigenschaft(&quot;KO&quot;)) / 4.0 / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() &lt; getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft(&quot;GE&quot;) / 4.0 / 5.0;
+        return isPossible();
+    }
+
+    bool JumpHighMovement::isPossible() const
+    {
+        if( mMovingCreature-&gt;getMovement() == this )
+            return
+                (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
+                 mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
+                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+        else
+            return
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
+                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+    }
+
+    void JumpHighMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        body-&gt;getMassMatrix(mass, inertia);
+
+        if( mJumpNow )
+        {
+            mJumpNow = false;
+
+            Real m = mass;
+            Real g = PhysicsManager::getSingleton().getGravity().length();
+            Real t = timestep;
+            Real h = mHeight;
+            Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
+            force = Vector3(0,
+                    jumpForce,
+                    0);
+            mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
+        }
+        else if (mState == UP &amp;&amp; mMoveForward != 0) // try to move forward, if wanted
+        {
+            // low velocity towards this direction
+            if(mMoveForward &gt; 0)
+                mMoveForward = 1.0;
+            else
+                mMoveForward = -1.0;
+
+
+
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+            body-&gt;getMassMatrix(mass, inertia);
+
+            Vector3 vel = mMovingCreature-&gt;getVelocity();
+            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
+            Real diff = (mMoveForward - vel.z);
+            force.z += mass * diff / delay;
+        }
+
+        Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+    }
+
+    bool JumpHighMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mMoveForward = direction.z;
+
+        if( mState == DOWN )
+        {
+            mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt;= 0.5f )
+            {
+                mState = DOWN;
+            }
+        }
+        if( mState == UP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &lt; 0.5f )
+            {
+                mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
+            }
+            else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
+            {
+                mState = UPTODOWN;
+                mMovingCreature-&gt;setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
+                mTimer = 0;
+            }
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt;= 0.25f )
+            {
+                mState = UP;
+                mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
+                mMovingCreature-&gt;setAnimation(mAnimation.first, mAnimation.second);
+                mJumpNow = true;
+                mTimer = 0;
+            }
+        }
+        return false;
+    }
+
+    bool JumpHighMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = 0;
+        if(direction.y &lt; 0)
+            direction.y = 0;
+        return oldDirection.x == 0 &amp;&amp; oldDirection.y &gt; 0;
+    }
+
+    bool JumpHighMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+
+    bool JumpHighMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == DOWN;
+    }
+}
+
+

Added: rl/trunk/engine/rules/src/JumpLongMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpLongMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpLongMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,260 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;JumpLongMovement.h&quot;
+
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    JumpLongMovement::JumpLongMovement(CreatureController *creature) :
+        AbstractMovement(creature), mState(DOWN), mWidth(0),
+        mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
+        mApplyForceTimer(0), mLastForce(Vector3::ZERO),
+        mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(27)))
+    {
+        mAnimation = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung&quot;);
+        mAnimationAbsprung = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung_absprung&quot;);
+        mAnimationLandung = creature-&gt;getCreature()-&gt;getAnimation(&quot;weitsprung_landung&quot;);
+        mAnimationForCollision = creature-&gt;getCreature()-&gt;getAnimation(&quot;rennen&quot;); // wird das hier gebraucht?
+    }
+
+    void JumpLongMovement::activate()
+    {
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature-&gt;setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mWidth);
+
+
+        // the person will only achieve this width if it is running
+        // retrieve run movement
+        AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
+        if( run != NULL )
+        {
+            Real vel(0);
+            run-&gt;calculateBaseVelocity(vel);
+            Real factor = -mMovingCreature-&gt;getVelocity().z / vel;
+            factor = std::max(Real(0),factor);
+            // without moving before, the width will be 1/3
+            mWidth = mWidth/3. + mWidth * 2./3. * factor;
+        }
+
+        if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
+        {
+            int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
+            if( taw &gt; 0 )
+            {
+                if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mWidth += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 25.0;
+                }
+                else if( taw == RESULT_AUTOERFOLG )
+                {
+                    mWidth += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) / 50.0;
+                }
+                else
+                {
+                    mWidth += taw / 50.0;
+                }
+            }
+        }
+
+        mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
+    }
+
+    void JumpLongMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool JumpLongMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = (mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;GE&quot;) +
+                mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;KK&quot;)) / 5.0;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch&#239;&#191;&#189;pfung ein KK abziehen
+        //if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
+        //    velocity -= (mErschoepfung - getEigenschaft(&quot;KO&quot;)) / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() &lt; getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft(&quot;GE&quot;) / 5.0;
+        return isPossible();
+    }
+
+    bool JumpLongMovement::isPossible() const
+    {
+        if( mMovingCreature-&gt;getMovement() == this )
+            return
+                (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
+                 mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
+                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+        else
+            return
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
+                !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+    }
+
+    void JumpLongMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        body-&gt;getMassMatrix(mass, inertia);
+
+
+        if( mJumpNow &amp;&amp; timestep != 0 )
+        {
+            mApplyForceTimer += timestep;
+
+            if( mApplyForceTimer == timestep // first time
+                    &amp;&amp; mApplyForceTimer &lt; mApplyForceTime )// this is handled below
+            {
+                Real t1 = mApplyForceTime;
+                Real sx = mWidth;
+                Real g = -PhysicsManager::getSingleton().getGravity().y;
+                Real v0 = mVelocityBeforeJump;
+                Real ax = 0;
+                Real ay = 0;
+
+                if( t1 != 0 || 2 * sx &gt;= v0 * t1 )
+                {
+                    Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                    Real v1y = mTanJumpAngle * v1x;
+                    ax =  (v1x - v0) / t1;
+                    ay = v1y/t1 + g;
+                }
+
+                mLastForce.x = 0;
+                mLastForce.y = ay * mass;
+                mLastForce.z = -ax * mass;
+            }
+
+            if( mApplyForceTimer &lt; mApplyForceTime )
+            {
+                force = mLastForce;
+            }
+            else
+            {
+                mJumpNow = false;
+                // adoption of the formula to our real jump time
+                Real t1 = mApplyForceTimer;
+                Real sx = mWidth;
+                Real g = -PhysicsManager::getSingleton().getGravity().y;
+                Real v0 = mVelocityBeforeJump;
+                Real ax = 0;
+                Real ay = 0;
+
+                if( t1 != 0 || 2 * sx &gt;= v0 * t1 )
+                {
+                    Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                    Real v1y = mTanJumpAngle * v1x;
+
+                    Vector3 v_now = mMovingCreature-&gt;getVelocity();
+                    ax =  (v1x - -v_now.z) / timestep;
+                    ay = (v1y- v_now.y)/timestep + g;
+                }
+
+                force.x = 0;
+                force.y = ay * mass;
+                force.z = -ax * mass;
+            }
+        }
+
+        Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+    }
+
+    bool JumpLongMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        if( mState == DOWN )
+        {
+            mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt;= 0.2f )
+            {
+                mState = DOWN;
+                LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: DOWN&quot;);
+            }
+        }
+        if( mState == UP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &lt; 0.2f )
+            {
+                mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
+            }
+            else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
+            {
+                mState = UPTODOWN;
+                mMovingCreature-&gt;setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
+                mTimer = 0;
+                LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: UPTODOWN&quot;);
+            }
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt;= 0.3f )
+            {
+                mState = UP;
+                mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
+                mMovingCreature-&gt;setAnimation(mAnimation.first, mAnimation.second, 1, mAnimationForCollision.first);
+                mJumpNow = true;
+                mApplyForceTimer = 0;
+                mVelocityBeforeJump = -mMovingCreature-&gt;getVelocity().z;
+                mTimer = 0;
+                LOG_MESSAGE(Logger::RULES, &quot;Weitsprung: UP&quot;);
+            }
+        }
+        return false;
+    }
+
+    bool JumpLongMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = 0;
+        if(direction.y &lt;= 0 || direction.z &gt;= 0)
+            direction.y = direction.z = 0;
+        return oldDirection.x == 0 &amp;&amp; oldDirection.z &lt; 0 &amp;&amp; oldDirection.y &gt; 0;
+    }
+
+    bool JumpLongMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+
+    bool JumpLongMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == DOWN;
+    }
+}
+

Added: rl/trunk/engine/rules/src/JumpToTargetMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpToTargetMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpToTargetMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,94 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;JumpToTargetMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    JumpToTargetMovement::JumpToTargetMovement(CreatureController *creature) : 
+        JumpLongMovement(creature) 
+    {
+    }
+
+    bool JumpToTargetMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        // Code from Weitsprung but do not jump as far
+        velocity = (mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;GE&quot;) +
+                mMovingCreature-&gt;getCreature()-&gt;getEigenschaft(&quot;KK&quot;)) / 5.0;
+        velocity*=0.8f;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch&#239;&#191;&#189;pfung ein KK abziehen
+        //if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
+        //    velocity -= (mErschoepfung - getEigenschaft(&quot;KO&quot;)) / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() &lt; getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft(&quot;GE&quot;) / 5.0;
+        return isPossible();
+    }
+
+    void JumpToTargetMovement::activate()
+    {
+        // Code from Weitsprung without Talentprobe
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature-&gt;setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mWidth);
+
+
+        // the person will only achieve this width if it is running
+        // retrieve run movement
+        AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
+        if( run != NULL )
+        {
+            Real vel(0);
+            run-&gt;calculateBaseVelocity(vel);
+            Real factor = -mMovingCreature-&gt;getVelocity().z / vel;
+            factor = std::max(Real(0),factor);
+            // without moving before, the width will be 1/3
+            mWidth = mWidth/3. + mWidth * 2./3. * factor;
+        }
+
+        mMovingCreature-&gt;getCreature()-&gt;damageAu(1./3); // not as much AU as Weitsprung
+    }
+
+    bool JumpToTargetMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        // this is the main difference to Weitsprung
+        // use direction as target in local coordinates (only in -z - direction!), so direction.z is -mWidth
+        // TODO: Talentprobe
+        LOG_MESSAGE(Logger::RULES, &quot;Zielsprung aktiviert!&quot;);
+        std::ostringstream oss;
+        oss &lt;&lt; &quot;Alte Sprungweite: &quot; &lt;&lt; mWidth &lt;&lt; &quot;Zielweite: &quot; &lt;&lt; -direction.z;
+        if( direction.z &lt; 0 &amp;&amp; direction.z &gt; -mWidth )
+        {
+            mWidth = - direction.z;
+            oss &lt;&lt; &quot;Zielweite: &quot; &lt;&lt; mWidth;
+        }
+        LOG_MESSAGE(Logger::RULES, oss.str());
+
+        return JumpLongMovement::run(elapsedTime, direction, rotation);
+    }
+}
+

Added: rl/trunk/engine/rules/src/LieDownMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/LieDownMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/LieDownMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,86 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;LieDownMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    // auch wenn Fallen nicht m&#246;glich ist (auf dem Boden und bewusstlos / Tod)
+    LieDownMovement::LieDownMovement(CreatureController *creature) :
+        AbstractMovement(creature)
+    {
+        mAnim = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;liegen&quot;);
+        mAnim1 = mMovingCreature-&gt;getCreature()-&gt;getAnimation(&quot;sterben&quot;);
+    }
+
+    void LieDownMovement::activate()
+    {
+        LOG_MESSAGE(Logger::RULES, &quot;Creature '&quot;+mMovingCreature-&gt;getCreature()-&gt;getName()+&quot;' liegt (evt bewusstlos) auf dem Boden.&quot;);
+    }
+
+    void LieDownMovement::deactivate()
+    {
+    }
+    
+    bool LieDownMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool LieDownMovement::isPossible() const
+    {
+        return true;
+    }
+
+    void LieDownMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+    }
+
+    bool LieDownMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        // todo: wieder aufstehen
+        if( mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_DEAD | Effect::LS_UNCONSCIOUS) )
+            mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second, 1);
+        else
+            mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second, 1);
+        return true;
+    }
+
+    void LieDownMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+
+    bool LieDownMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        direction = Vector3::ZERO;
+        return false;
+    }
+
+    bool LieDownMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+}
+

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/Makefile.am	2008-06-23 13:45:18 UTC (rev 4406)
@@ -52,4 +52,18 @@
 	TalentStateSet.cpp \
 	WaitJob.cpp \
 	Weapon.cpp \
-	ZauberStateSet.cpp
+	ZauberStateSet.cpp \
+	FallDownMovement.cpp \
+	JogFastMovement.cpp \
+	JogMovement.cpp \
+	JumpHighMovement.cpp \
+	JumpLongMovement.cpp \
+	JumpToTargetMovement.cpp \
+	LieDownMovement.cpp \
+	RotateMovement.cpp \
+	SneakMovement.cpp \
+	SprintMovement.cpp \
+	StandAroundMovement.cpp \
+	StepRecognitionMovement.cpp \
+	StrafeMovement.cpp \
+	WalkMovement.cpp

Added: rl/trunk/engine/rules/src/RotateMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/RotateMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/RotateMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,119 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;RotateMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    RotateMovement::RotateMovement(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
+    {
+        mRotLinearSpringK = 600.0f;
+        Real relationCoefficient = 1.0f;
+        mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
+    }
+
+    bool RotateMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = 0.3f;
+        return isPossible();
+    }
+
+    bool RotateMovement::isPossible() const
+    {
+        return
+            mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+            mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
+            !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+    }
+
+    void RotateMovement::activate()
+    {
+        AbstractMovement::activate();
+        mYaw = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getWorldOrientation().getYaw();
+    }
+
+    void RotateMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    void RotateMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        body-&gt;getMassMatrix(mass, inertia);
+
+        Quaternion orientation;
+        Vector3 position;
+        body-&gt;getPositionOrientation(position, orientation);
+        // Calculate angular velocity
+        // We first need the yaw rotation from actual yaw to desired yaw
+        Vector3 src = orientation*Vector3::UNIT_Z;
+        src.y = 0;
+        Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
+        dst.y = 0;
+        Quaternion quatDiff = src.getRotationTo(dst, Vector3::UNIT_Y);
+        quatDiff.normalise();
+        Radian yaw = quatDiff.getYaw();
+
+        // using a spring system to apply the rotation
+        Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
+        Vector3 omega = body-&gt;getOmega();
+        omega.x = omega.z = 0;
+        Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
+
+        torque = springAcc * inertia;
+    }
+
+    bool RotateMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mYaw += Radian(rotation.y);
+        while (mYaw.valueDegrees() &gt; 360.0f) mYaw -= Degree(360.0f);
+        while (mYaw.valueDegrees() &lt; -360.0f) mYaw += Degree(360.0f);
+
+        OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        Quaternion orientation;
+        Vector3 position;
+        body-&gt;getPositionOrientation(position, orientation);
+
+        Real diff = (orientation.getYaw() - mYaw).valueDegrees();
+        return diff &lt;= 0.5f &amp;&amp; diff &gt;= -0.5f;
+    }
+
+    bool RotateMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool RotateMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        Vector3 oldRotation(rotation);
+        rotation.x = rotation.z = 0;
+        return oldRotation.x == 0 &amp;&amp; oldRotation.z == 0;
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/SneakMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/SneakMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/SneakMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,112 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;SneakMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    SneakMovement::SneakMovement(CreatureController *creature) : WalkMovement(creature), mState(UP), mTimer(0)
+    {
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen&quot;);
+        mAnim1= creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen_vorwaerts&quot;);
+        mAnim2 = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_zu_schleichen&quot;);
+        mAnim3= creature-&gt;getCreature()-&gt;getAnimation(&quot;schleichen_zu_stehen&quot;);
+        mAnimStehen= creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);
+    }
+
+    bool SneakMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS() / 6.0;
+        return isPossible();
+    }
+
+    bool SneakMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt; 0.5f )
+                mState = DOWN;
+        }
+        if( mState == UP )
+        {
+            mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer &gt; 0.5f )
+                mState = UP;
+        }
+        if( mState == DOWN )
+        {
+            //setAnimation(elapsedTime);
+            direction.normalise();
+            Real velocity;
+            calculateBaseVelocity(velocity);
+            mVelocity = direction * velocity;
+            if( direction == Vector3::ZERO || (-mMovingCreature-&gt;getVelocity().z) &lt; 0.1)
+                mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second);
+            else
+                mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature-&gt;getVelocity().z);
+            applyAuChanges(elapsedTime);
+            if( getRotationMovement()-&gt;isPossible() )
+                getRotationMovement()-&gt;run(elapsedTime, direction, rotation);
+        }
+        else
+            mVelocity = Vector3::ZERO;
+        return true;
+    }
+
+    void SneakMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+
+    void SneakMovement::setAnimation(Ogre::Real elapsedTime) // is not used
+    {
+    }
+
+    void SneakMovement::activate()
+    {
+        WalkMovement::activate();
+        mState = UPTODOWN;
+        mMovingCreature-&gt;setAnimation(mAnim2.first,mAnim2.second,1,mAnimStehen.first);
+        mTimer = 0;
+    }
+
+    bool SneakMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == UP;
+    }
+
+    void SneakMovement::requestChangeToMovement(CreatureController::MovementType id)
+    {
+        if( mState == DOWN )
+        {
+            mState = DOWNTOUP;
+            mMovingCreature-&gt;setAnimation(mAnim3.first,mAnim3.second,1,mAnimStehen.first);
+            mTimer = 0;
+        }
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/SprintMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/SprintMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/SprintMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;SprintMovement.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;MeshAnimation.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+Real minSquaredSpeed = 0.6f;
+
+
+namespace rl
+{
+    SprintMovement::SprintMovement(CreatureController *creature) : WalkMovement(creature), mVelocityImprovement(0), mLastProbe(0)
+    {
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;rennen&quot;);
+    }
+
+    bool SprintMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS();
+        return isPossible();
+    }
+
+    bool SprintMovement::isPossible() const
+    {
+        if( mMovingCreature-&gt;getMovement() == this )
+            return WalkMovement::isPossible() &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax() * 0.3 &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6;
+        else
+            return WalkMovement::isPossible() &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax() * 0.5 &amp;&amp;
+                mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8;
+    }
+
+    bool SprintMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        doTalentProbeIfNecessary();
+        bool ret = WalkMovement::run(elapsedTime, direction, rotation);
+        mVelocity += mVelocityImprovement;
+        return ret;
+    }
+
+    void SprintMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+        else
+            mMovingCreature-&gt;getCreature()-&gt;damageAu(elapsedTime/1.5);
+    }
+
+    void SprintMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature-&gt;getVelocity().squaredLength() &lt; minSquaredSpeed )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature-&gt;getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
+                if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
+                    weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+        // apply relTimeOffset only once
+        if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, fabs(mMovingCreature-&gt;getVelocity().z) *mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL &amp;&amp; relTimeOffset )
+            meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
+    }
+
+    void SprintMovement::activate()
+    {
+        WalkMovement::activate();
+        doTalentProbeIfNecessary();
+    }
+
+    void SprintMovement::doTalentProbeIfNecessary()
+    {
+        Date now = DsaManager::getSingleton().getCurrentDate();
+        if( mLastProbe + mMovingCreature-&gt;getCreature()-&gt;getAuMax() * Date::ONE_SECOND &gt;= now || mLastProbe == 0)
+        {
+            mVelocityImprovement = 0;
+            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
+            {
+                mLastProbe = now;
+                int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
+                if( taw == RESULT_AUTOERFOLG )
+                {
+                    mVelocityImprovement += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 0.2;
+                }
+                else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mVelocityImprovement += mMovingCreature-&gt;getCreature()-&gt;getTalent(&quot;Athletik&quot;) * 0.3;
+                }
+                else
+                {
+                    mVelocityImprovement += taw * 0.1;
+                }
+            }
+            else
+            {
+                mVelocityImprovement = 0;
+            }
+        }
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StandAroundMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StandAroundMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StandAroundMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;StandAroundMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StandAroundMovement::StandAroundMovement(CreatureController *creature) : 
+        AbstractMovement(creature), 
+        mVelocity(Vector3::ZERO), 
+        mRotationMovement(NULL), 
+        mStepRecognitionMovement(NULL)
+    {
+        mAnimStehenLinks = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_links&quot;);
+        mAnimStehenRechts = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen_rechts&quot;);
+        mAnimStehen = creature-&gt;getCreature()-&gt;getAnimation(&quot;stehen&quot;);
+    }
+
+    StandAroundMovement::~StandAroundMovement()
+    {
+    }
+
+    void StandAroundMovement::activate()
+    {
+        AbstractMovement::activate();
+        getRotationMovement()-&gt;activate();
+        getStepRecognitionMovement()-&gt;activate();
+    }
+
+    void StandAroundMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+        getRotationMovement()-&gt;deactivate();
+        getStepRecognitionMovement()-&gt;deactivate();
+    }
+
+    bool StandAroundMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool StandAroundMovement::isPossible() const
+    {
+        return
+            mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+            mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 0 &amp;&amp;
+            !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
+    }
+
+    void StandAroundMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+        getRotationMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
+
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        body-&gt;getMassMatrix(mass, inertia);
+
+        Vector3 vel = mMovingCreature-&gt;getVelocity();
+        vel.y = 0;
+        Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
+        //if(vel.squaredLength() &gt; mVelocity.squaredLength())
+        //    delay *= 1.5;
+        Vector3 diff = (mVelocity - vel);
+        force = mass * diff / delay;
+        // additional remove movement in wrong direction
+        force += mass * (mVelocity.normalisedCopy() * vel.length() - vel) / delay; // do we need this, does this improve the movement behaviour
+        // (changing direction during slow movement makes char slide sideways)
+        force.y = 0;
+
+        getStepRecognitionMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
+    }
+
+    bool StandAroundMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        direction.normalise();
+        Real velocity;
+        calculateBaseVelocity(velocity);
+        mVelocity = direction * velocity;
+        applyAuChanges(elapsedTime);
+        setAnimation(elapsedTime);
+        bool ret = false;
+        if( getRotationMovement()-&gt;isPossible() )
+            if( getRotationMovement()-&gt;run(elapsedTime, direction, rotation) )
+                ret = true;
+        if( getStepRecognitionMovement()-&gt;isPossible() )
+            if (getStepRecognitionMovement()-&gt;run(elapsedTime, direction, rotation) )
+                ret = true;
+        return ret;
+    }
+
+    void StandAroundMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        Real omegaY = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega().y;
+        if( omegaY &gt; Degree(20).valueRadians() )
+            mMovingCreature-&gt;setAnimation(mAnimStehenRechts.first, mAnimStehenRechts.second);
+        else
+        {
+            if( omegaY &lt; Degree(-20).valueRadians() )
+                mMovingCreature-&gt;setAnimation(mAnimStehenLinks.first, mAnimStehenLinks.second);
+            else
+                mMovingCreature-&gt;setAnimation(mAnimStehen.first, mAnimStehen.second);
+        }
+    }
+
+    void StandAroundMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        mMovingCreature-&gt;getCreature()-&gt;regenerateAu(2, 0.5, elapsedTime);
+    }
+
+    bool StandAroundMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool StandAroundMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        return getRotationMovement()-&gt;isRotationPossible(rotation);
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,263 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;StepRecognitionMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StepRecognitionMovement::StepRecognitionMovement(CreatureController *creature) : 
+        AbstractMovement(creature), 
+        mMoveToNextTarget(false)
+    {
+        mLinearSpringK = 600.0f;
+        Real relationCoefficient = 1.2f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+    }
+
+    void StepRecognitionMovement::activate()
+    {
+        AbstractMovement::activate();
+        mMoveToNextTarget = false;
+    }
+
+    void StepRecognitionMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool StepRecognitionMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool StepRecognitionMovement::isPossible() const
+    {
+        return
+            mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+            mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 0 &amp;&amp;
+            !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; (Effect::LS_IMMOBILE));
+    }
+
+    void StepRecognitionMovement::calculateForceAndTorque(Vector3 &amp;force, Vector3 &amp;torque, Real timestep)
+    {
+        // move to nextTarget
+        if( mMoveToNextTarget )
+        {
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+            body-&gt;getMassMatrix(mass, inertia);
+
+            Vector3 pos = mMovingCreature-&gt;getCreature()-&gt;getPosition();
+            Vector3 diff = mNextTarget - pos;
+
+            Vector3 vel = body-&gt;getVelocity();
+
+            force.y = mass*( mLinearSpringK*diff.y - mLinearDampingK*vel.y );
+            std::ostringstream oss;
+            oss &lt;&lt; &quot;Step-Recognition: diff: &quot; &lt;&lt; diff.y &lt;&lt; &quot;    vel: &quot; &lt;&lt; vel.y &lt;&lt; &quot;    Step force: &quot; &lt;&lt; force.y;
+            oss &lt;&lt; &quot;    DiffToTarget: &quot; &lt;&lt; 
+                mMovingCreature-&gt;getCreature()-&gt;getOrientation().Inverse() * 
+                (mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition());
+            LOG_MESSAGE(Logger::RULES, oss.str());
+        }
+    }
+
+    bool StepRecognitionMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        Vector3 vel = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;getVelocity();
+        Real velY = vel.y;
+        vel.y = 0;
+        // raycast in the direction we should move to
+        Vector3 globalDir = mMovingCreature-&gt;getCreature()-&gt;getOrientation() * direction; // the direction in global space
+        if( globalDir == Vector3::ZERO )
+            return true;
+
+
+
+        // the materials that are triggered here
+        PhysicsMaterialRaycast::MaterialVector materialVector;
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+
+
+
+        // first of all check if we are not standing in front of a wall or sth like this
+        PhysicalThing *thing = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing();
+        Real height = thing-&gt;_getBody()-&gt;getCollision()-&gt;getAABB().getSize().y;
+        Vector3 start = mMovingCreature-&gt;getCreature()-&gt;getPosition() + Vector3(0,height/2,0);
+        Vector3 end = start + globalDir * 0.5;
+        RaycastInfo info;
+        info = mRaycast.execute(
+                PhysicsManager::getSingleton()._getNewtonWorld(),
+                &amp;materialVector,
+                start,
+                end);
+        if(info.mBody)
+        {
+            mMoveToNextTarget = false;
+            return false;
+        }
+
+
+
+        if( !mMoveToNextTarget ) // check if we need to move up for a step
+        {
+            Real raylen = vel.length() / 3;  // use longer ray, if higher velocity
+            if ( raylen &lt; 0.5 )
+                raylen = 0.4;
+
+            //std::ostringstream oss;
+            //oss &lt;&lt; &quot;StepRecognition Raylen: &quot; &lt;&lt; raylen;
+            //LOG_MESSAGE(Logger::RULES, oss.str());
+
+
+            // raycasts
+            Vector3 start = mMovingCreature-&gt;getCreature()-&gt;getPosition() + Vector3::UNIT_Y * 0.1f;
+            globalDir.y = 0;
+            globalDir.normalise();
+            Vector3 end = start + globalDir*raylen;
+
+            bool foundbody = false;
+            Real foundDistance = 0;
+
+            RaycastInfo info;
+            do
+            {
+                info = 
+                    mRaycast.execute(
+                            PhysicsManager::getSingleton()._getNewtonWorld(),
+                            &amp;materialVector,
+                            start, end);
+
+                // do we need to check bodies left and right of this ray? (step width?)
+
+
+                // already found nearer body
+                if( foundbody )
+                {
+                    if( info.mBody &amp;&amp; (info.mDistance*raylen &gt;= foundDistance*raylen + 0.19) || // step deep enough
+                            !info.mBody )
+                    {
+                        // found a step
+                        mMoveToNextTarget = true;
+                        mNextTarget = start + globalDir*raylen*foundDistance + 0.1 * globalDir;
+                        std::ostringstream oss;
+                        Vector3 stepInLocalCoords = mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition();
+                        Quaternion ori = mMovingCreature-&gt;getCreature()-&gt;getOrientation();
+                        stepInLocalCoords = ori.Inverse() * stepInLocalCoords;
+                        oss &lt;&lt; &quot;Step-Recognition: Next Step: &quot; &lt;&lt; stepInLocalCoords;
+                        LOG_MESSAGE(Logger::RULES, oss.str());
+                        break;
+                    }
+                }
+
+                if( info.mBody )
+                {
+                    foundbody = true;
+                    foundDistance = info.mDistance;
+                }
+
+
+                start += Vector3::UNIT_Y * 0.05f;
+                end += Vector3::UNIT_Y * 0.05f;
+            }
+            while( info.mBody &amp;&amp; (start - mMovingCreature-&gt;getCreature()-&gt;getPosition()).y &lt;= 0.5 );
+        }
+
+
+        // check if the target is still needed
+        // perform check also to verify found step
+        if( mMoveToNextTarget )
+        {
+            Vector3 diffToTarget = mNextTarget - mMovingCreature-&gt;getCreature()-&gt;getPosition();
+            Real diffToTargetY = diffToTarget.y;
+            diffToTarget.y = 0;
+
+            // different direction
+            Vector3 globalDir = mMovingCreature-&gt;getCreature()-&gt;getOrientation() * direction; // the direction in global space
+            globalDir.y = 0;
+
+
+            if( globalDir == Vector3::ZERO )
+            {
+                mMoveToNextTarget = false;
+                LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction null&quot;);
+                return false;
+            }
+
+            // target reached
+            if( diffToTarget.squaredLength() &lt; 0.01)
+            {
+                mMoveToNextTarget = false;
+                LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step reached&quot;);
+                return false;
+            }
+
+            // different direction
+            Quaternion oriDiff = diffToTarget.getRotationTo(globalDir, Vector3::UNIT_Y);
+            Degree angleDiff;
+            Vector3 axis = Vector3::UNIT_Y;
+            oriDiff.ToAngleAxis(angleDiff, axis);
+            Real f = angleDiff.valueDegrees();
+            //std::ostringstream oss;
+            //oss &lt;&lt; &quot;Step-Recognition: angle: &quot; &lt;&lt; f &lt;&lt; &quot;    axis: &quot; &lt;&lt; axis;
+            //LOG_MESSAGE(Logger::RULES, oss.str());
+            //if( !diffToTarget.directionEquals(globalDir, Degree(15)) )
+            if( f &gt; 2.0f )
+            {
+                mMoveToNextTarget = false;
+                //LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction wrong&quot;);
+                return false;
+            }
+
+
+            // already above target, but slow velocity
+            if( diffToTargetY &lt; 0 &amp;&amp; fabs(velY) &lt; 0.01 )
+            {
+                mMoveToNextTarget = false;
+                //LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: slow and abov target-height!&quot;);
+                return false;
+            }
+        }
+
+        return mMoveToNextTarget;
+    }
+
+    bool StepRecognitionMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool StepRecognitionMovement::isRotationPossible(Ogre::Vector3 &amp;rotation) const
+    {
+        Vector3 oldRotation(rotation);
+        rotation = Vector3::ZERO;
+        return oldRotation == Vector3::ZERO;
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StrafeMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StrafeMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StrafeMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,62 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;StrafeMovement.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StrafeMovement::StrafeMovement(CreatureController *creature) : WalkMovement(creature), mLeft(true)
+    {
+        mAnim1 = creature-&gt;getCreature()-&gt;getAnimation(&quot;seitwaerts_rechts&quot;);
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;seitwaerts_links&quot;);
+    }
+
+    bool StrafeMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS() / 4.0;
+        return isPossible();
+    }
+    
+    bool StrafeMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.z = direction.y = 0;
+        return oldDirection.z == 0 &amp;&amp; oldDirection.y == 0;
+    }
+
+    bool StrafeMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mLeft = direction.x &lt; 0;
+        return WalkMovement::run(elapsedTime, direction, rotation);
+    }
+
+    void StrafeMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mLeft )
+            mMovingCreature-&gt;setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature-&gt;getVelocity().x);
+        else
+            mMovingCreature-&gt;setAnimation(mAnim.first, mAnim.second * -mMovingCreature-&gt;getVelocity().x);
+    }
+}
+
+

Added: rl/trunk/engine/rules/src/WalkMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/WalkMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/WalkMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,109 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;WalkMovement.h&quot;
+#include &quot;MeshAnimation.h&quot;
+
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    WalkMovement::WalkMovement(CreatureController *creature) : StandAroundMovement(creature)
+    {
+        mAnim = creature-&gt;getCreature()-&gt;getAnimation(&quot;gehen&quot;);
+    }
+
+    bool WalkMovement::calculateBaseVelocity(Real &amp;velocity)
+    {
+        velocity = mMovingCreature-&gt;getCurrentGS() / 3.6f * 0.7f;
+        return isPossible();
+    }
+
+    bool WalkMovement::isPossible() const
+    {
+        return
+            mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
+            mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
+            !(mMovingCreature-&gt;getCreature()-&gt;getLifeState() &amp; Effect::LS_IMMOBILE);
+    }
+
+    bool WalkMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        StandAroundMovement::run(elapsedTime, direction, rotation);
+        return true;
+    }
+
+    bool WalkMovement::isDirectionPossible(Ogre::Vector3 &amp;direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = direction.y = 0;
+        if( direction.z &gt; 0 )
+            direction.z = 0;
+        return oldDirection.x == 0 &amp;&amp; oldDirection.y == 0 &amp;&amp; oldDirection.z &gt; 0;
+    }
+
+    void WalkMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        mMovingCreature-&gt;getCreature()-&gt;regenerateAu(2, 0.5, elapsedTime);
+    }
+
+    void WalkMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        Real speed =  -mMovingCreature-&gt;getVelocity().z;
+        if( fabs(speed) &lt; 0.1 )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+        switch( mMovingCreature-&gt;getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_JOGGEN:
+            case CreatureController::MT_LAUFEN:
+            case CreatureController::MT_RENNEN:
+                relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
+                if( mMovingCreature-&gt;getLastMovementChange() &lt; 1.0f )
+                    weight = mMovingCreature-&gt;getLastMovementChange() / 1.0f;
+                break;
+            default:
+                break;
+        }
+
+
+        // apply relTimeOffset only once
+        if( mMovingCreature-&gt;getLastMovementChange() &gt; elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature-&gt;setAnimation(mAnim.first, speed * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL &amp;&amp; relTimeOffset != 0 )
+            meshAnim-&gt;doAddTime(relTimeOffset*meshAnim-&gt;getLength());
+    }
+}
+

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-06-23 13:45:18 UTC (rev 4406)
@@ -816,13 +816,17 @@
             MT_SCHLEICHEN,
             MT_HOCHSPRUNG,
             MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
             // these movements are only for internal purposes and should not be used directly
             // instead use one of the movements above
-            MT_DREHEN
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
         } MovementType;
         
         Creature *getCreature();
-        //bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
         MovementType getMovementId() const;
         Ogre::Vector3 getDirection() const;
         Ogre::Vector3 getRotation() const;

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -20,6 +20,7 @@
 
 #include &lt;utility&gt;
 
+#include &quot;AbstractMovement.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;ActorManager.h&quot;
 #include &quot;CameraObject.h&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001476.html">[Dsa-hl-svn] r4405 - in rl/trunk/engine: core/include core/src	script/src
</A></li>
	<LI>Next message: <A HREF="001478.html">[Dsa-hl-svn] r4407 - in rl/trunk/editors: . Lockenwickler	Lockenwickler/src Lockenwickler/src/media Lockenwickler/ui files
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1477">[ date ]</a>
              <a href="thread.html#1477">[ thread ]</a>
              <a href="subject.html#1477">[ subject ]</a>
              <a href="author.html#1477">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
