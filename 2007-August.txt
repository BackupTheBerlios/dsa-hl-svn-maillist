From melven at mail.berlios.de  Wed Aug  1 13:41:30 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 1 Aug 2007 13:41:30 +0200
Subject: [Dsa-hl-svn] r3653 - in rl/trunk/engine/rules: include src
Message-ID: <200708011141.l71BfUr8005512@sheep.berlios.de>

Author: melven
Date: 2007-08-01 13:41:16 +0200 (Wed, 01 Aug 2007)
New Revision: 3653

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
Log:
removed static variables in regenerateAu, which could cause errors

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-07-31 16:53:07 UTC (rev 3652)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-01 11:41:16 UTC (rev 3653)
@@ -783,6 +783,11 @@
 
             Alignment mAlignment;
 
+            /// this variable is only used in regenerateAu
+            float mTimeSinceLastRegeneration;
+            /// this variable is only used in regenerateAu (must be initialized with 3W6)
+            int mLastCalculatedAuToRegenerate;
+
             /**
              *  Sets a the status \a statusVariable. It uses a reference counting
              *  System to do this, so if for example severeal effects put the creature

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-07-31 16:53:07 UTC (rev 3652)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-01 11:41:16 UTC (rev 3653)
@@ -90,7 +90,12 @@
         mSonderfertigkeiten(),
         mErschoepfung(0),
         mMovementType(0),
-        mAlignment(ALIGNMENT_NEUTRAL)
+        mAlignment(ALIGNMENT_NEUTRAL),
+        mTimeSinceLastRegeneration(0),
+        mLastCalculatedAuToRegenerate(
+                  DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6())
     {
         mQueryFlags |= QUERYFLAG_CREATURE;
 
@@ -888,28 +893,24 @@
     void Creature::regenerateAu(int modifier, float factor, float time)
     {
         // das Ganze nur jede Spielrunde machen
-        static float lastSpielrunde = 0;
-        static int regeneratedAu = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6();
-        lastSpielrunde += time;
+        mTimeSinceLastRegeneration += time;
 
 
         if( getAu() == getAuMax() )
         {
-            lastSpielrunde = 0;
+            mTimeSinceLastRegeneration = 0;
             return;
         }
 
 
-        while( lastSpielrunde >= Date::ONE_SPIELRUNDE )
+        while( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE )
         {
-            lastSpielrunde -= Date::ONE_SPIELRUNDE;
+            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
 
 
             ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
             //Grundregeneration von 3W6
-            regeneratedAu = DsaManager::getSingleton().rollD6()
+            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
                 + DsaManager::getSingleton().rollD6()
                 + DsaManager::getSingleton().rollD6();
             //Addiere eventuelle Modifikatoren hinzu
@@ -921,22 +922,22 @@
                 modifyAu(6*factor);
             }
 
-            if( lastSpielrunde >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            if( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
             {
                 //modifiziere die aktuellen AU
                 time -= Date::ONE_SPIELRUNDE;
-                modifyAu((regeneratedAu-modifier)*factor);
+                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
             }
 
             if( getAu() == getAuMax() )
             {
-                lastSpielrunde = 0;
+                mTimeSinceLastRegeneration = 0;
                 return;
             }
         }
 
         // Restbetrag regenerieren:
-        float regeneratedAuPerTime = float(regeneratedAu-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
         modifyAu(regeneratedAuPerTime*factor);
     }
 



From pnyx at mail.berlios.de  Thu Aug  2 14:30:12 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 2 Aug 2007 14:30:12 +0200
Subject: [Dsa-hl-svn] r3654 - in modules: common/materials
	common/materials/programs ruchin/maps
	ruchin/materials/textures ruchin/models ruchin/scripts
	ruchin/scripts/maps
Message-ID: <200708021230.l72CUCH1001513@sheep.berlios.de>

Author: pnyx
Date: 2007-08-02 14:28:37 +0200 (Thu, 02 Aug 2007)
New Revision: 3654

Added:
   modules/common/materials/programs/Skin_Vertex_Shader.material
   modules/common/materials/programs/Skin_Vertex_Shader.source
   modules/common/materials/programs/Torso_Vertex_Shader.source
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
   modules/ruchin/materials/textures/Ligthingmap_default.png
Modified:
   modules/common/materials/men_human_female_hand_nude.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_Shader.source
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
   modules/common/materials/programs/Basic_Vertex_Shader_ground.material
   modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
   modules/common/materials/programs/Torso_Pixel_Shader.source
   modules/common/materials/programs/Torso_Pixel_Shader_2.source
   modules/common/materials/programs/Torso_Vertex_Shader.material
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/models/House_dummies.mesh
   modules/ruchin/models/Ruchin_ground.material
   modules/ruchin/models/Ruchin_ground.mesh
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/ruchin.material
   modules/ruchin/models/ruchin_terrain.material
   modules/ruchin/scripts/maps/maptest.rb
   modules/ruchin/scripts/particle.rb
Log:
Added Skin shader
Added 3rd lightsource to Vertexshaders


Modified: modules/common/materials/men_human_female_hand_nude.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hand_nude.mesh.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/men_human_female_hand_nude.mesh.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -1,5 +1,5 @@
 
-material men_human_female_hand_nude : Basic_Vertex_Shader
+material men_human_female_hand_nude : Skin_Vertex_Shader
 {
 set_texture_alias diffuse rl_mensch_female.png
 

Modified: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/men_human_female_head02.mesh.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -1,5 +1,5 @@
 
-material men_human_female_head_02 : Basic_Vertex_Shader
+material men_human_female_head_02 : Skin_Vertex_Shader
 {
 set_texture_alias diffuse men_human_female_head02.png
 

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -50,7 +50,12 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
 				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Modified: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -10,6 +10,12 @@
 float4 Light2_position;
 float4 Light2_color;
 float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
 float4 vViewPosition;
 
 struct VS_INPUT 
@@ -58,9 +64,30 @@
                               Light1_attenuation.w * Dist * Dist)
                           ,0,1);
    
-   Output.Color += (Light1_color * DistAttn * AngleAttn) + SpecAttn;
+   Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
    
    
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   EyeVect = normalize(Input.Position - vViewPosition);
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
    // Light2
    
    LightDir = Light2_position - Input.Position * Light2_position.w;
@@ -78,7 +105,7 @@
                         Light2_attenuation.w * Dist * Dist)
                         ,0,1);
    
-   Output.Color += (Light2_color * DistAttn * AngleAttn) + SpecAttn;
+   Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
    
    Output.Texcoord = Input.Texcoord;
    Output.Texcoord1 = Input.Texcoord1;

Modified: modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -25,14 +25,21 @@
 				// param_named_auto
 
 				param_named_auto Light1_attenuation light_attenuation 0
-				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
-				
 				param_named_auto Light1_color light_diffuse_colour 0
-				//param_named Light1_color float4 1.0 1.0 1.0 1.0
 				param_named_auto Light1_position light_position_object_space 0
-				//param_named Light1_position float4 1.0 1.0 1.0 1.0
 				param_named Light1_spec_power float 0.3
 				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -33,7 +33,12 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
 				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				
@@ -69,14 +74,21 @@
 				// param_named_auto
 
 				param_named_auto Light1_attenuation light_attenuation 0
-				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
-				
 				param_named_auto Light1_color light_diffuse_colour 0
-				//param_named Light1_color float4 1.0 1.0 1.0 1.0
 				param_named_auto Light1_position light_position_object_space 0
-				//param_named Light1_position float4 1.0 1.0 1.0 1.0
 				param_named Light1_spec_power float 0.3
 				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -35,7 +35,12 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
 				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Modified: modules/common/materials/programs/Basic_Vertex_Shader_ground.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -27,7 +27,12 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
 				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Added: modules/common/materials/programs/Skin_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -0,0 +1,69 @@
+vertex_program Skin_Vertex_Shader hlsl
+{
+	source Skin_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+
+material Skin_Vertex_Shader
+{
+	receive_shadows off
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
+}

Added: modules/common/materials/programs/Skin_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Skin_Vertex_Shader.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -0,0 +1,126 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
+float4 subsurfcolor;
+
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = float4(0,0,0,0);
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   EyeVect = normalize(Input.Position - vViewPosition);
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)
+                        ,0,1);
+   
+   Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   // fake SSS
+   Output.Color = lerp((subsurfcolor*Output.Color),Output.Color,( saturate(abs(Output.Color*3 -0.2))));
+   
+   Output.Color += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord1 = Input.Texcoord1;
+   Output.Texcoord2 = Input.Texcoord2;
+   
+   return( Output );
+   
+}
+
+
+

Modified: modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -27,7 +27,7 @@
    TexColor = lerp(float4(tex2D(Texture4,UV4.xy).rgb,tex2D(Texture4,UV4.zw * scale_Detail4).a),TexColor,Color.a);
    
 
-  return TexColor * (TexColor.a+ 0.5) * (tex2D(Texture5,UV4.zw) + Light);
+  return TexColor * (TexColor.a+ 0.5) * ((tex2D(Texture5,UV4.zw)-0.5) + Light);
   //return float4(Color.aaaa);
 
 }

Modified: modules/common/materials/programs/Torso_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Torso_Pixel_Shader.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -7,15 +7,16 @@
    float2 Texcoord1: TEXCOORD1;
    float2 Texcoord2: TEXCOORD2;
    float4 Color    : TEXCOORD3;
+   float4 SubColor : TEXCOORD4;
    
 };
 
 float4 ps_main( PS_INPUT Input ) : COLOR0
 {
 
-   float4 skin = tex2D( baseMap, Input.Texcoord );	
-   float4 cloth = tex2D( clothMap, Input.Texcoord1 );
-   return float4(lerp(skin.rgb,cloth.rgb, cloth.a )* Input.Color.rgb,skin.a+cloth.a);
+   float4 skin = tex2D( baseMap, Input.Texcoord )* float4(Input.SubColor.rgb,1);
+   float4 cloth = tex2D( clothMap, Input.Texcoord1 )* float4(Input.Color.rgb,1);
+   return float4(lerp(skin.rgb,cloth.rgb, cloth.a ),skin.a+cloth.a);
 }
 
 

Modified: modules/common/materials/programs/Torso_Pixel_Shader_2.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader_2.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Torso_Pixel_Shader_2.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -7,15 +7,16 @@
    float2 Texcoord1: TEXCOORD1;
    float2 Texcoord2: TEXCOORD2;
    float4 Color    : TEXCOORD3;
+   float4 SubColor : TEXCOORD4;
    
 };
 
 float4 ps_main( PS_INPUT Input ) : COLOR0
 {
 
-   float4 skin = tex2D( baseMap, Input.Texcoord );	
-   float4 cloth = tex2D( clothMap, Input.Texcoord2 );
-   return float4(lerp(skin.rgb,cloth.rgb, cloth.a )* Input.Color.rgb,skin.a+cloth.a);
+   float4 skin = tex2D( baseMap, Input.Texcoord )* float4(Input.SubColor.rgb,1);	
+   float4 cloth = tex2D( clothMap, Input.Texcoord2 )* float4(Input.Color.rgb,1);
+   return float4(lerp(skin.rgb,cloth.rgb, cloth.a ),skin.a+cloth.a);
 }
 
 

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -14,6 +14,15 @@
 	entry_point ps_main
 }
 
+vertex_program Torso_Vertex_Shader hlsl
+{
+	source Torso_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+
+
+
 material Torso_Vertex_Shader_Short
 {
 	technique
@@ -27,7 +36,7 @@
 			{
 			}
 			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
+			vertex_program_ref Torso_Vertex_Shader
 			{
 				// param_named_auto
 
@@ -41,9 +50,15 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				
+				param_named subsurfcolor float4 0.8 0 0 1
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
 				param_named groundcolor float4 0.10 0.10 0.10 1.0
@@ -93,7 +108,7 @@
 			{
 			}
 			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
+			vertex_program_ref Torso_Vertex_Shader
 			{
 				// param_named_auto
 
@@ -110,6 +125,7 @@
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				
+				param_named subsurfcolor float4 0.8 0 0 1
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
 				param_named groundcolor float4 0.10 0.10 0.10 1.0

Added: modules/common/materials/programs/Torso_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-02 12:28:37 UTC (rev 3654)
@@ -0,0 +1,128 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
+float4 subsurfcolor;
+
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   float4 SubColor : TEXCOORD4;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = float4(0,0,0,0);
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   EyeVect = normalize(Input.Position - vViewPosition);
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)
+                        ,0,1);
+   
+   Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   // fake SSS
+   Output.SubColor = lerp((subsurfcolor*Output.Color),Output.Color,( saturate(abs(Output.Color*3 -0.2))));
+   
+   Output.Color += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   Output.SubColor += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord1 = Input.Texcoord1;
+   Output.Texcoord2 = Input.Texcoord2;
+   
+   return( Output );
+   
+}
+
+
+

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/maps/ruchin.scene	2007-08-02 12:28:37 UTC (rev 3654)
@@ -120,21 +120,7 @@
   
 
 		</node>
-		<node name="Ruchin_l_innen" id="17" >
-			<position x="65.2876" y="6.02141" z="-66.9458" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_l_innen"
-				id="18"
-				meshFile ="Ruchin_l_innen.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
+		
 		<node name="Ruchin_map" id="19" >
 			<position x="68.5845" y="-0.00679748" z="-47.3902" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
@@ -359,7 +345,7 @@
 		</node>
 		
 		<node name="Ruchin_ground" id="3" >
-			<position x="0.0" y="0.0" z="0.0" />
+			<position x="35.0" y="0.0" z="-20.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<entity

Added: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-02 12:28:37 UTC (rev 3654)
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<rastullahmap formatVersion="0.4.0">
+	<nodes>
+		<entity name="Ruchin_l_innen" meshFile="Ruchin_l_innen.mesh" visible="true" receivesShadow="true">
+			<position x="65.2876" y="6.02141" z="-66.9458" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			 <renderingdistance data="100" /> 
+		</entity>	
+		
+		<light name="red pointlight" type="point" visible="false"
+			castShadows="false">
+			<position x="65.2876" y="6.02141" z="-66.9458" />
+			<colourDiffuse r="1" g="0" b="0" />
+			<colourSpecular r="1" g="0" b="0" />
+			<lightAttenuation range="20.0" constant="1.0" linear="0.1"
+				quadratic="0.1" />
+		</light>	
+		
+		<light name="green spotlight" type="spot" visible="false"
+			castShadows="false">
+			<position x="65.2876" y="6.02141" z="-66.9458" />
+			<colourDiffuse r="0" g="1" b="0" />
+			<colourSpecular r="0" g="1" b="0" />
+			<lightAttenuation range="20.0" constant="1.0" linear="0.1"
+				quadratic="0.1" />
+			<spotlightrange inner="10" outer="20" falloff="1" />
+			<direction x="0" y="-1" z="0.5" />
+		</light>
+		<light name="sun" type="directional" visible="true" castShadows="false">
+			<colourDiffuse r="0.8" g="0.8" b="0.8" />
+			<colourSpecular r="0" g="0" b="1" />
+			<direction x="-0.17101" y="-0.873647" z="0.969846" />
+		</light>
+	</nodes>
+	<zones>
+		<zone type="default">
+			<light name="sun"/>
+		</zone>
+		<zone type="mesh" name="Ruchin_l_innen">
+			<light name="red pointlight"/>
+			<light name="green spotlight"/>
+			<sound name="lachen.ogg"/>
+		</zone>
+	</zones>
+</rastullahmap>

Added: modules/ruchin/materials/textures/Ligthingmap_default.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Ligthingmap_default.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/House_dummies.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_ground.material
===================================================================
--- modules/ruchin/models/Ruchin_ground.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/models/Ruchin_ground.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -5,8 +5,8 @@
    set_texture_alias red         laub01.dds
    set_texture_alias green       nat_gras_01.dds
    set_texture_alias blue        nat_steingrund_01.dds
-   set_texture_alias alpha       Tiles.dds
-   set_texture_alias Lightingmap Lightingmap2.png
+   set_texture_alias alpha       nat_steingrund_01.dds
+   set_texture_alias Lightingmap Ligthingmap_default.png
    
    technique
    {
@@ -30,7 +30,7 @@
             param_named scale_Texture2 float 0.28500 // Gruen
             param_named scale_Detail2 float 0.60000
 
-            param_named scale_Texture3 float 0.58000 // Blau
+            param_named scale_Texture3 float 0.88000 // Blau
             param_named scale_Detail3 float 1.00000
 
             param_named scale_Texture4 float 0.016000 // Alpha

Modified: modules/ruchin/models/Ruchin_ground.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ruchin.material
===================================================================
--- modules/ruchin/models/ruchin.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/models/ruchin.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -2,21 +2,75 @@
 {
 	technique
 	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
-			lighting off
-			alpha_rejection greater 128
 
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_Variation
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			// HLSL Vertex Shader
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+
 			texture_unit
 			{
-				texture_alias 0
+				texture ruchin_atlasmap.dds
+
+			}
+			texture_unit
+			{
 				texture Ruchin_ao_l_inside.dds
-				tex_coord_set 1
+
 			}
 		}
-
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
+//set_texture_alias diffuse ruchin_atlasmap.dds
 
+//set_texture_alias variation Ruchin_ao_l_inside.dds
+
 }
 
 material Material_#25/02_-_Default

Modified: modules/ruchin/models/ruchin_terrain.material
===================================================================
--- modules/ruchin/models/ruchin_terrain.material	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/models/ruchin_terrain.material	2007-08-02 12:28:37 UTC (rev 3654)
@@ -6,8 +6,8 @@
    set_texture_alias red         nat_felsen_01.dds
    set_texture_alias green       boden_02.png
    set_texture_alias blue        nat_steingrund_01.dds
-   set_texture_alias alpha       Tiles.dds
-   set_texture_alias Lightingmap Lightingmap2.png
+   set_texture_alias alpha       nat_steingrund_01.dds
+   set_texture_alias Lightingmap Ligthingmap_default.png
    
    technique
    {

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/scripts/maps/maptest.rb	2007-08-02 12:28:37 UTC (rev 3654)
@@ -10,13 +10,13 @@
 
 $CORE.getWorld().setSkyBox(true, "rl/dsa07", 100.0)
 
-$SCRIPT.log("Tageslicht erstellen..");
-sunlight = $AM.createLightActor("sunlight", LightObject::LT_DIRECTIONAL);
-sunlight.getControlledObject().setDirection(-0.17101, -0.873647, 0.969846);
-sunlight.getControlledObject().setCastShadows(true);
+#$SCRIPT.log("Tageslicht erstellen..");
+#sunlight = $AM.createLightActor("sunlight", LightObject::LT_DIRECTIONAL);
+#sunlight.getControlledObject().setDirection(-0.17101, -0.873647, 0.969846);
+#sunlight.getControlledObject().setCastShadows(true);
 
-sunlight.getControlledObject().setDiffuseColour(0.8,0.8,0.8);
-sunlight.getControlledObject().setSpecularColour(1.0,1.0,1.0);
+#sunlight.getControlledObject().setDiffuseColour(0.8,0.8,0.8);
+#sunlight.getControlledObject().setSpecularColour(1.0,1.0,1.0);
 
 #sunlight.getControlledObject().setDiffuseColour(0.1,0.1,0.2);
 $SCRIPT.log("Tageslicht erstellt.");
@@ -29,8 +29,6 @@
 
 
 
-
-
 $World.setFog( World::FOG_EXP, [0.658,0.7568,0.9137,1.0], 0.00049, 0.8, 4.0);
 #$World.setAmbientLight( 0.3, 0.3, 0.3  );
 
@@ -75,6 +73,11 @@
 #BoxAnim = BoxActor.getControlledObject().startAnimation("Speak");
 #$SCRIPT.log("animation abgespielt.");
 
+
+
+loader = MapLoader.new("ruchin");
+loader.loadMap("ruchin_lightzones.rlmap.xml");
+
 ##########################
 
 load "particle.rb"

Modified: modules/ruchin/scripts/particle.rb
===================================================================
--- modules/ruchin/scripts/particle.rb	2007-08-01 11:41:16 UTC (rev 3653)
+++ modules/ruchin/scripts/particle.rb	2007-08-02 12:28:37 UTC (rev 3654)
@@ -9,11 +9,11 @@
 templefire2 = $AM.createParticleSystemActor("templefire2", "feuertest" );
 templefire2.placeIntoScene( 123.28,3.0,-18.93, 1.0, 0.0, 0.0, 0.0 );
 
-nebel = $AM.createParticleSystemActor("nebel", "nebel" );
-nebel.placeIntoScene( 32.02, -2.26, -24.40, 1.0, 0.0, 0.0, 0.0 );
+#nebel = $AM.createParticleSystemActor("nebel", "nebel" );
+#nebel.placeIntoScene( 32.02, -2.26, -24.40, 1.0, 0.0, 0.0, 0.0 );
 
-nebel2 = $AM.createParticleSystemActor("nebel2", "nebel" );
-nebel2.placeIntoScene( 26.47, -2.5, -37.92, 1.0, 0.0, 0.0, 0.0 );
+#nebel2 = $AM.createParticleSystemActor("nebel2", "nebel" );
+#nebel2.placeIntoScene( 26.47, -2.5, -37.92, 1.0, 0.0, 0.0, 0.0 );
 
 qualm1 = $AM.createParticleSystemActor("qualm1", "qualm" );
 qualm1.placeIntoScene( -4.28, 3.00, -1.66, 1.0, 0.0, 0.0, 0.0 );



From blakharaz at mail.berlios.de  Thu Aug  2 22:38:13 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 2 Aug 2007 22:38:13 +0200
Subject: [Dsa-hl-svn] r3655 - rl/trunk/docs/documents
Message-ID: <200708022038.l72KcD9k019665@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-02 22:38:07 +0200 (Thu, 02 Aug 2007)
New Revision: 3655

Modified:
   rl/trunk/docs/documents/scene_format_proposal.xml
Log:
fix

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2007-08-02 12:28:37 UTC (rev 3654)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2007-08-02 20:38:07 UTC (rev 3655)
@@ -5,8 +5,8 @@
 		<!-- static mesh -->
 		<entity
 			name="nat_grasplane_01"
-			meshFile ="nat_grasplane_01.mesh"
-			receivesShadow="true">
+			meshfile ="nat_grasplane_01.mesh"
+			receiveShadow="true">
 
 			<position x="5.7285" y="-7.94034" z="18.4169" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
@@ -28,7 +28,7 @@
 		<!-- static mesh with custom collision-->
 		<entity
 			name="nat_tree_01"
-			meshFile="nat_tree_01.mesh"
+			meshfile="nat_tree_01.mesh"
 			visible="true"
 			castShadow="true" >
 



From blakharaz at mail.berlios.de  Thu Aug  2 22:38:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 2 Aug 2007 22:38:46 +0200
Subject: [Dsa-hl-svn] r3656 - modules/ruchin/maps
Message-ID: <200708022038.l72KckUM019708@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-02 22:38:42 +0200 (Thu, 02 Aug 2007)
New Revision: 3656

Modified:
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
Log:
meshFile -> meshfile

Modified: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-02 20:38:07 UTC (rev 3655)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-02 20:38:42 UTC (rev 3656)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <rastullahmap formatVersion="0.4.0">
 	<nodes>
-		<entity name="Ruchin_l_innen" meshFile="Ruchin_l_innen.mesh" visible="true" receivesShadow="true">
+		<entity name="Ruchin_l_innen" meshfile="Ruchin_l_innen.mesh" visible="true" receivesShadow="true">
 			<position x="65.2876" y="6.02141" z="-66.9458" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />



From pnyx at mail.berlios.de  Fri Aug  3 10:05:53 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Fri, 3 Aug 2007 10:05:53 +0200
Subject: [Dsa-hl-svn] r3657 - modules/common/materials/programs
Message-ID: <200708030805.l7385rZ5023852@sheep.berlios.de>

Author: pnyx
Date: 2007-08-03 10:05:47 +0200 (Fri, 03 Aug 2007)
New Revision: 3657

Modified:
   modules/common/materials/programs/TerrainVColorBlending.material
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
   modules/common/materials/programs/Torso_Vertex_Shader.source
Log:
added hemisphere lightingmodell for Terrainshader

Modified: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-08-02 20:38:42 UTC (rev 3656)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-08-03 08:05:47 UTC (rev 3657)
@@ -47,10 +47,11 @@
 				param_named_auto Light_Position0 light_position 0
 				param_named_auto Light_Position1 light_position 1
 
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
 				
 				
 				
-				
 				param_named scale_Texture0 float 0.018000 // Schwarz
 				param_named scale_Detail0 float 0.020000
 

Modified: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-08-02 20:38:42 UTC (rev 3656)
+++ modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-08-03 08:05:47 UTC (rev 3657)
@@ -20,7 +20,10 @@
 uniform float4 Light_Position1;
 uniform float4 Light_Attenuation1;
 
+float4 skycolor;
+float4 groundcolor;
 
+
 struct VS_OUTPUT 
 {
    float4 Position : POSITION0;
@@ -75,7 +78,7 @@
    
    
    // Light Output
-   Output.Light = (Light_Ambient-0.5 + ((Light_Color0 * DistAttn0 * AngleAttn0) + (Light_Color1 * DistAttn1 * AngleAttn1))*1.25);
+   Output.Light =lerp(skycolor,groundcolor,(dot(Normal, float3(0,-1,0))+1)/2 ) +(Light_Ambient-0.5 + ((Light_Color0 * DistAttn0 * AngleAttn0) + (Light_Color1 * DistAttn1 * AngleAttn1))*1.25);
    
    return( Output );
    

Modified: modules/common/materials/programs/Torso_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-02 20:38:42 UTC (rev 3656)
+++ modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-03 08:05:47 UTC (rev 3657)
@@ -69,7 +69,6 @@
    
    Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
    
-   
    // Light3
    
    LightDir = Light3_position - Input.Position * Light3_position.w;
@@ -90,7 +89,6 @@
    
    Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
    
-   
    // Light2
    
    LightDir = Light2_position - Input.Position * Light2_position.w;
@@ -109,13 +107,15 @@
                         ,0,1);
    
    Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
-   
+
    // fake SSS
-   Output.SubColor = lerp((subsurfcolor*Output.Color),Output.Color,( saturate(abs(Output.Color*3 -0.2))));
+   Output.SubColor = lerp((subsurfcolor*Output.Color),Output.Color,(saturate(abs(Output.Color*3 -0.2))));
    
-   Output.Color += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
-   Output.SubColor += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
    
+   float4 ambient= lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   Output.Color += ambient;
+   Output.SubColor += ambient;;
+   
    Output.Texcoord = Input.Texcoord;
    Output.Texcoord1 = Input.Texcoord1;
    Output.Texcoord2 = Input.Texcoord2;



From pnyx at mail.berlios.de  Sat Aug  4 19:06:32 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 4 Aug 2007 19:06:32 +0200
Subject: [Dsa-hl-svn] r3658 - in modules: common/materials
	common/materials/model common/materials/programs
	common/models ruchin/models
Message-ID: <200708041706.l74H6WHI002820@sheep.berlios.de>

Author: pnyx
Date: 2007-08-04 19:05:24 +0200 (Sat, 04 Aug 2007)
New Revision: 3658

Added:
   modules/common/materials/model/men_eye_blue.png
   modules/common/materials/model/men_eyeshadow.png
   modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
   modules/common/materials/programs/Face_Pixel_Shader.source
   modules/common/materials/programs/Face_Vertex_Shader.material
   modules/common/materials/programs/Face_Vertex_Shader.source
   modules/ruchin/models/Ruchin_inside.material
Modified:
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/model/men_human_female_head02.png
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Skin_Vertex_Shader.material
   modules/common/materials/programs/Skin_Vertex_Shader.source
   modules/common/materials/programs/Torso_Vertex_Shader.material
   modules/common/materials/programs/Torso_Vertex_Shader.source
   modules/common/models/men_human_female_head_02.mesh
   modules/ruchin/models/Ruchin_l_innen.mesh
   modules/ruchin/models/Ruchintest.material
   modules/ruchin/models/ruchin.material
Log:
* added eye-movement shader and skin color variation
* using basic vertex shader for windows now

Modified: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -1,5 +1,5 @@
 
-material men_human_female_hair_long_01_normal : Basic_Vertex_Shader_Alpha
+material men_human_female_hair_long_01_normal : Basic_Vertex_Shader_Hair
 {
 set_texture_alias diffuse men_human_female_hair_long_01.png
 }

Modified: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/men_human_female_head02.mesh.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -1,6 +1,8 @@
 
-material men_human_female_head_02 : Skin_Vertex_Shader
+material men_human_female_head_02 : Face_Vertex_Shader
 {
 set_texture_alias diffuse men_human_female_head02.png
+set_texture_alias eyeColor men_eye_blue.png
+set_texture_alias eyeShadow men_eyeshadow.png
 
 }

Added: modules/common/materials/model/men_eye_blue.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_eye_blue.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_eyeshadow.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_eyeshadow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/materials/model/men_human_female_head02.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -2,68 +2,15 @@
 material Basic_Vertex_Shader_Alpha
 {
 	technique
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
+	{	
 		pass
 		{
-			scene_blend alpha_blend 
+			scene_blend alpha_blend
       		// Tiefenpuffer aus
       		depth_write off
-      		//alpha_rejection greater 50
       		
-      		cull_hardware anticlockwise 
-      		cull_software back 
-      		
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-		
-		pass
-		{
-			scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		depth_write off
       		//alpha_rejection greater 50
       		
-      		cull_hardware clockwise 
-      		cull_software front 
-      		
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
 			{

Added: modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -0,0 +1,120 @@
+//Effect: Textured
+material Basic_Vertex_Shader_Hair
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+      		//alpha_rejection greater 128
+      		
+      		cull_hardware anticlockwise 
+      		cull_software back 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+      		//alpha_rejection greater 128
+      		
+      		cull_hardware clockwise 
+      		cull_software front 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		
+	}	
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
+}

Added: modules/common/materials/programs/Face_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Face_Pixel_Shader.source	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Face_Pixel_Shader.source	2007-08-04 17:05:24 UTC (rev 3658)
@@ -0,0 +1,23 @@
+sampler2D baseMap;
+sampler2D Texture1;
+sampler2D Texture2;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+	float4 eyeColor = tex2D (Texture1, Input.Texcoord1) * tex2D (Texture2, Input.Texcoord2);
+	float4 faceColor = tex2D( baseMap, Input.Texcoord );
+   return float4(lerp(eyeColor.rgb ,faceColor.rgb, faceColor.a)* Input.Color.rgb,1);
+   
+}
+
+
+

Added: modules/common/materials/programs/Face_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -0,0 +1,88 @@
+vertex_program Face_Vertex_Shader hlsl
+{
+	source Face_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+
+
+fragment_program Face_Pixel_Shader hlsl
+{
+	source Face_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+material Face_Vertex_Shader
+{
+	receive_shadows off
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Face_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Face_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				param_named eyeDirection float3 0.0 0 0.0
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias eyeColor
+
+			}
+			texture_unit
+			{
+				texture_alias eyeShadow
+
+			}
+		}
+	}
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
+}

Added: modules/common/materials/programs/Face_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader.source	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Face_Vertex_Shader.source	2007-08-04 17:05:24 UTC (rev 3658)
@@ -0,0 +1,140 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
+float3 eyeDirection;
+
+float4 subsurfcolor;
+float4 skincolor;
+
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = float4(0,0,0,0);
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
+   float accDistAttn = DistAttn;
+   
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   EyeVect = normalize(Input.Position - vViewPosition);
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   accDistAttn += DistAttn;
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)
+                        ,0,1);
+   
+   Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   accDistAttn += DistAttn;
+   
+   // fake SSS
+   Output.Color = lerp((saturate(accDistAttn)*subsurfcolor*Output.Color),Output.Color,( saturate(Output.Color*3 -0.2)));
+   
+   Output.Color += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   
+   Output.Color *= skincolor+0.5;
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord2 = Input.Texcoord1;
+   
+   float2 eyeDir; 
+   eyeDir.x = clamp(-eyeDirection.x/3,-0.3,0.3);
+   eyeDir.y = clamp(-eyeDirection.z/3,-0.3,0.3);
+     
+   Output.Texcoord1.x        = Input.Texcoord1.x + eyeDir.x;
+   Output.Texcoord1.y        = Input.Texcoord1.y + eyeDir.y;
+   
+   return( Output );
+   
+}
+
+
+

Modified: modules/common/materials/programs/Skin_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -39,6 +39,7 @@
 				param_named Light3_spec_power float 0.3
 				
 				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
 				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space

Modified: modules/common/materials/programs/Skin_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.source	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Skin_Vertex_Shader.source	2007-08-04 17:05:24 UTC (rev 3658)
@@ -17,6 +17,7 @@
 float4 Light3_spec_power;
 
 float4 subsurfcolor;
+float4 skincolor;
 
 float4 vViewPosition;
 
@@ -67,8 +68,8 @@
                           ,0,1);
    
    Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
+   float accDistAttn = DistAttn;
    
-   
    // Light3
    
    LightDir = Light3_position - Input.Position * Light3_position.w;
@@ -89,6 +90,7 @@
    
    Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
    
+   accDistAttn += DistAttn;
    
    // Light2
    
@@ -109,11 +111,15 @@
    
    Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
    
+   accDistAttn += DistAttn;
+   
    // fake SSS
-   Output.Color = lerp((subsurfcolor*Output.Color),Output.Color,( saturate(abs(Output.Color*3 -0.2))));
+   Output.Color = lerp((saturate(accDistAttn)*subsurfcolor*Output.Color),Output.Color,( saturate(Output.Color*3 -0.2)));
    
    Output.Color += lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
    
+   Output.Color *= skincolor*2;
+   
    Output.Texcoord = Input.Texcoord;
    Output.Texcoord1 = Input.Texcoord1;
    Output.Texcoord2 = Input.Texcoord2;

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -59,6 +59,7 @@
 				param_named_auto vViewPosition camera_position_object_space
 				
 				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
 				param_named groundcolor float4 0.10 0.10 0.10 1.0

Modified: modules/common/materials/programs/Torso_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/common/materials/programs/Torso_Vertex_Shader.source	2007-08-04 17:05:24 UTC (rev 3658)
@@ -17,6 +17,7 @@
 float4 Light3_spec_power;
 
 float4 subsurfcolor;
+float4 skincolor;
 
 float4 vViewPosition;
 
@@ -69,6 +70,9 @@
    
    Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
    
+   float accDistAttn = DistAttn;
+   
+   
    // Light3
    
    LightDir = Light3_position - Input.Position * Light3_position.w;
@@ -89,6 +93,8 @@
    
    Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
    
+   accDistAttn += DistAttn;
+   
    // Light2
    
    LightDir = Light2_position - Input.Position * Light2_position.w;
@@ -108,14 +114,19 @@
    
    Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
 
+   accDistAttn += DistAttn;
+   
    // fake SSS
-   Output.SubColor = lerp((subsurfcolor*Output.Color),Output.Color,(saturate(abs(Output.Color*3 -0.2))));
+   Output.SubColor = lerp((saturate(accDistAttn)*subsurfcolor*Output.Color),Output.Color,(saturate(Output.Color*3 -0.2)));
    
    
    float4 ambient= lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   
    Output.Color += ambient;
-   Output.SubColor += ambient;;
+   Output.SubColor += ambient;
    
+   Output.SubColor *= skincolor+0.5;
+   
    Output.Texcoord = Input.Texcoord;
    Output.Texcoord1 = Input.Texcoord1;
    Output.Texcoord2 = Input.Texcoord2;

Modified: modules/common/models/men_human_female_head_02.mesh
===================================================================
(Binary files differ)

Added: modules/ruchin/models/Ruchin_inside.material
===================================================================
--- modules/ruchin/models/Ruchin_inside.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/ruchin/models/Ruchin_inside.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -0,0 +1,13 @@
+
+material Ruchin_inside/base : Basic_Vertex_Shader
+{
+set_texture_alias diffuse ruchin_atlasmap.png
+
+}
+
+
+material Ruchin_inside/windows : Basic_Vertex_Shader_Alpha
+{
+set_texture_alias diffuse ruchin_atlasmap.dds
+
+}

Modified: modules/ruchin/models/Ruchin_l_innen.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchintest.material
===================================================================
--- modules/ruchin/models/Ruchintest.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/ruchin/models/Ruchintest.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -140,64 +140,8 @@
 
 }
 
-material Ruchin/glas
+material Ruchin/glas : Basic_Vertex_Shader_Alpha
 {
-//lighting off
-	receive_shadows off
-	lod_distances 40
-	
-	technique
-	{
-		lod_index 0
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
-			
-			// ?berblenden aktiviert
-      		scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		depth_write off
-			
-			texture_unit
-			{
-				texture ruchin_atlasmap.dds
-			}
+set_texture_alias diffuse ruchin_atlasmap.dds
 
-			
-		}
-
-	}
-	
-	technique
-	{
-	lod_index 1
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
-			
-			texture_unit
-			{
-				texture ruchin_atlasmap.dds
-			}
-
-			
-		}
-
-	}
 }
\ No newline at end of file

Modified: modules/ruchin/models/ruchin.material
===================================================================
--- modules/ruchin/models/ruchin.material	2007-08-03 08:05:47 UTC (rev 3657)
+++ modules/ruchin/models/ruchin.material	2007-08-04 17:05:24 UTC (rev 3658)
@@ -7,7 +7,7 @@
 		{
 
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader_Variation
+			fragment_program_ref Basic_Pixel_Shader
 			{
 			}
 			//DirectX 9.0 HLSL Vertex Shader vs_2_0
@@ -25,13 +25,18 @@
 				param_named_auto Light2_position light_position_object_space 1
 				param_named Light2_spec_power float 0.3
 				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
 				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				
 				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
+				param_named skycolor float4 0.2 0.2 0.2 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
 			}
 			
 			// HLSL Vertex Shader
@@ -50,11 +55,11 @@
 				texture ruchin_atlasmap.dds
 
 			}
-			texture_unit
-			{
-				texture Ruchin_ao_l_inside.dds
+			//texture_unit
+			//{
+			//	texture Ruchin_ao_l_inside.dds
 
-			}
+			//}
 		}
 	}
 	technique



From twel at mail.berlios.de  Sun Aug  5 14:45:09 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Sun, 5 Aug 2007 14:45:09 +0200
Subject: [Dsa-hl-svn] r3659 - in rl/trunk/engine: core/src rules/src
Message-ID: <200708051245.l75Cj9Mr015404@sheep.berlios.de>

Author: twel
Date: 2007-08-05 14:45:06 +0200 (Sun, 05 Aug 2007)
New Revision: 3659

Modified:
   rl/trunk/engine/core/src/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
Log:
updated Makefile.am files

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-08-04 17:05:24 UTC (rev 3658)
+++ rl/trunk/engine/core/src/Makefile.am	2007-08-05 12:45:06 UTC (rev 3659)
@@ -9,14 +9,12 @@
 	Actor.cpp \
 	ActorControlledObject.cpp \
 	ActorManager.cpp \
-	AnimationListener.cpp \
 	AnimationManager.cpp \
 	BaseAnimation.cpp \
 	BoxPrimitive.cpp \
 	CameraObject.cpp \
 	ConfigurationManager.cpp \
 	ContentModule.cpp \
-	CoreEvents.cpp \
 	CoreSubsystem.cpp \
 	DebugVisualisable.cpp \
 	DebugVisualsManager.cpp \
@@ -30,6 +28,7 @@
 	GameEventManager.cpp \
 	GameLoop.cpp \
 	Job.cpp \
+	JobQueue.cpp \
 	JobScheduler.cpp \
 	LightObject.cpp \
 	LightFadeJob.cpp \
@@ -61,6 +60,7 @@
 	SoundResource.cpp \
 	SoundFadeJob.cpp \
 	SoundFadeFunctor.cpp \
+	TimeSource.cpp \
 	TrackAnimation.cpp \
 	World.cpp \
 	Zone.cpp \

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-08-04 17:05:24 UTC (rev 3658)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-08-05 12:45:06 UTC (rev 3659)
@@ -22,6 +22,7 @@
 	EigenschaftenStateSet.cpp \
 	GameObject.cpp \
 	GameObjectManager.cpp \
+	GameTimeSource.cpp \
 	Item.cpp \
 	Inventory.cpp \
 	JournalEntry.cpp \
@@ -43,9 +44,5 @@
 	Talent.cpp \
 	Talentgruppe.cpp \
 	TalentStateSet.cpp \
-	TimerEvent.cpp \
-	TimerEventSource.cpp \
-	TimerListener.cpp \
-	TimerManager.cpp  \
 	Weapon.cpp \
 	ZauberStateSet.cpp



From twel at mail.berlios.de  Sun Aug  5 14:47:29 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Sun, 5 Aug 2007 14:47:29 +0200
Subject: [Dsa-hl-svn] r3660 - rl/trunk/engine/core/include
Message-ID: <200708051247.l75ClT19015512@sheep.berlios.de>

Author: twel
Date: 2007-08-05 14:47:28 +0200 (Sun, 05 Aug 2007)
New Revision: 3660

Modified:
   rl/trunk/engine/core/include/TimeSource.h
Log:
removed unnecessary static keyword which caused a gcc error

Modified: rl/trunk/engine/core/include/TimeSource.h
===================================================================
--- rl/trunk/engine/core/include/TimeSource.h	2007-08-05 12:45:06 UTC (rev 3659)
+++ rl/trunk/engine/core/include/TimeSource.h	2007-08-05 12:47:28 UTC (rev 3660)
@@ -28,7 +28,7 @@
     class _RlCoreExport TimeSource : public GameTask
     {
     public:
-        static enum TimeSourceType
+        enum TimeSourceType
         {
             REALTIME_CONTINUOUS,
             REALTIME_INTERRUPTABLE,



From pnyx at mail.berlios.de  Sun Aug  5 14:53:05 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sun, 5 Aug 2007 14:53:05 +0200
Subject: [Dsa-hl-svn] r3661 - in modules/ruchin: maps models
Message-ID: <200708051253.l75Cr5lH016086@sheep.berlios.de>

Author: pnyx
Date: 2007-08-05 14:53:01 +0200 (Sun, 05 Aug 2007)
New Revision: 3661

Modified:
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
   modules/ruchin/models/Statue_01.mesh
   modules/ruchin/models/Statue_02.mesh
Log:
* moved meshes to rlmap.xml

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-08-05 12:47:28 UTC (rev 3660)
+++ modules/ruchin/maps/ruchin.scene	2007-08-05 12:53:01 UTC (rev 3661)
@@ -1,361 +1,4 @@
 <scene formatVersion="0.0" >
-	<nodes>
-		<node name="Stadtmauer" id="1" >
-			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Stadtmauer"
-				id="2"
-				meshFile ="Stadtmauer.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_s" id="3" >
-			<position x="-6.85993" y="0.405498" z="11.2053" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_s"
-				id="4"
-				meshFile ="Ruchin_s.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_n" id="5" >
-			<position x="9.28835" y="4.25027" z="-52.6695" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_n"
-				id="6"
-				meshFile ="Ruchin_n.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_p" id="7" >
-			<position x="29.574" y="2.872" z="-7.966" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_p"
-				id="8"
-				meshFile ="Ruchin_p.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_m" id="9" >
-			<position x="36.6777" y="2.04379" z="-51.148" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_m"
-				id="10"
-				meshFile ="Ruchin_m.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_l" id="11" >
-			<position x="65.2876" y="6.02141" z="-66.9458" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_l"
-				id="12"
-				meshFile ="Ruchin_l.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_r" id="13" >
-			<position x="70.0" y="0.0" z="30.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_r"
-				id="14"
-				meshFile ="Ruchin_r.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Ruchin_v" id="15" >
-			<position x="88.3245" y="1.09103" z="78.1543" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_v"
-				id="16"
-				meshFile ="Ruchin_v.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="Ruchin_map" id="19" >
-			<position x="68.5845" y="-0.00679748" z="-47.3902" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_map"
-				id="20"
-				meshFile ="Ruchin_map.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="dome_sun" id="21" >
-			<position x="614.1" y="1980.49" z="-3609.07" />
-			<rotation qx="0.838383" qy="-0.00269342" qz="0.163517" qw="0.51997" />
-			<scale x="38.9469" y="38.9469" z="38.9469" />
-			<entity
-				name="dome_sun"
-				id="22"
-				meshFile ="dome_sun.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="dome_clouds_near" id="23" >
-			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="5.08402" y="4.00516" z="4.00516" />
-			<entity
-				name="dome_clouds_near"
-				id="24"
-				meshFile ="dome_clouds_near.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="dome_clouds_far" id="25" >
-			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.7353" y="1.7353" z="1.7353" />
-			<entity
-				name="dome_clouds_far"
-				id="26"
-				meshFile ="dome_clouds_far.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="dome" id="27" >
-			<position x="170.899" y="-451.645" z="-112.896" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="3.14024" y="3.14024" z="3.14024" />
-			<entity
-				name="dome"
-				id="28"
-				meshFile ="dome.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="Ruchin_Stadtwache" id="28" >
-			<position x="105.0" y="0.0" z="45.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_Stadtwache"
-				id="2"
-				meshFile ="Ruchin_Stadtwache.mesh"
-				materialFile="Stadtwache.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="temple_outside" id="1" >
-			<position x="122.11" y="0.076957" z="-20.5749" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="temple_outside"
-				id="2"
-				meshFile ="temple_outside.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="temple_outside" id="1" >
-			<position x="122.11" y="0.076957" z="-20.5749" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="temple_outside"
-				id="2"
-				meshFile ="temple_innen.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="Statue_02" id="1" >
-			<position x="112.486" y="1.53497" z="-17.18" />
-			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Statue_02"
-				id="2"
-				meshFile ="Statue_01.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		<node name="Statue_01" id="3" >
-			<position x="112.486" y="1.53497" z="-24.0179" />
-			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Statue_01"
-				id="4"
-				meshFile ="Statue_02.mesh"
-				materialFile="ruchin_terrainlayout19.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-		
-		<node name="Terrain" id="3" >
-			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Statue_01"
-				id="4"
-				meshFile ="ruchin_terrain.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-
-		</node>
-		
-		<node name="Dummies" id="3" >
-			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Statue_01"
-				id="4"
-				meshFile ="House_dummies.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-		</node>
-	
-	<node name="Ruchin_u" id="3" >
-			<position x="100.0" y="0.0" z="50.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Statue_0dsf1"
-				id="4"
-				meshFile ="Ruchin_u.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-		</node>
-			
-			<node name="Ruchin_j" id="3" >
-			<position x="40.0" y="0.0" z="-100.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_j"
-				id="4"
-				meshFile ="Ruchin_j.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-
-		</node>
-		
-		<node name="Ruchin_i" id="3" >
-			<position x="-5.0" y="0.0" z="-100.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_i"
-				id="4"
-				meshFile ="Ruchin_i.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-
-		</node>
-		
-		<node name="Ruchin_ground" id="3" >
-			<position x="35.0" y="0.0" z="-20.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ruchin_ground"
-				id="4"
-				meshFile ="Ruchin_ground.mesh"
-				materialFile="ruchin_terrain.material"
-				castsShadow="false"
-			/>
-
-		</node>
+	<nodes>		
 	</nodes>
-</scene>
\ No newline at end of file
+</scene>

Modified: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-05 12:47:28 UTC (rev 3660)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-05 12:53:01 UTC (rev 3661)
@@ -6,9 +6,189 @@
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<staticgeometrygroup id="0"/>
-			 <renderingdistance data="100" /> 
+			<renderingdistance data="100" /> 
+		</entity>
+		<entity name="Stadtmauer" meshfile ="Stadtmauer.mesh" visible="true" receivesShadow="true">
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="1"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_Stadtwache" meshfile ="Ruchin_Stadtwache.mesh" visible="true" receivesShadow="true">
+			<position x="105.0" y="0.0" z="45.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="1"/>
+			<renderingdistance data="100" />
+		</entity>
+		
+		<entity name="Ruchin_s" meshfile ="Ruchin_s.mesh" visible="true" receivesShadow="true">
+			<position x="-6.85993" y="0.405498" z="11.2053" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
 		</entity>	
+		<entity name="Ruchin_n" meshfile ="Ruchin_n.mesh" visible="true" receivesShadow="true">
+			<position x="9.28835" y="4.25027" z="-52.6695" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_p" meshfile ="Ruchin_p.mesh" visible="true" receivesShadow="true">
+			<position x="29.574" y="2.872" z="-7.966" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_m" meshfile ="Ruchin_m.mesh" visible="true" receivesShadow="true">
+			<position x="36.6777" y="2.04379" z="-51.148" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_l" meshfile ="Ruchin_l.mesh" visible="true" receivesShadow="true">
+			<position x="65.2876" y="6.02141" z="-66.9458" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_r" meshfile ="Ruchin_r.mesh" visible="true" receivesShadow="true">
+			<position x="70.0" y="0.0" z="30.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_v" meshfile ="Ruchin_v.mesh" visible="true" receivesShadow="true">
+			<position x="88.3245" y="1.09103" z="78.1543" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_i" meshfile ="Ruchin_i.mesh" visible="true" receivesShadow="true">
+			<position x="-5.0" y="0.0" z="-100.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_j" meshfile ="Ruchin_j.mesh" visible="true" receivesShadow="true">
+			<position x="40.0" y="0.0" z="-100.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_u" meshfile ="Ruchin_u.mesh" visible="true" receivesShadow="true">
+			<position x="100.0" y="0.0" z="50.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="House_dummies" meshfile ="House_dummies.mesh" visible="true" receivesShadow="true">
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="0"/>
+			<renderingdistance data="100" />
+		</entity>
 		
+		
+		
+		<entity name="Ruchin_map" meshfile ="Ruchin_map.mesh" visible="true" receivesShadow="true">
+			<position x="68.5845" y="-0.00679748" z="-47.3902" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="ruchin_terrain" meshfile ="ruchin_terrain.mesh" visible="true" receivesShadow="true">
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Ruchin_ground" meshfile ="Ruchin_ground.mesh" visible="true" receivesShadow="true">
+			<position x="35.0" y="0.0" z="-20.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="100" />
+		</entity>
+		
+		
+		<entity name="temple_outside" meshfile ="temple_outside.mesh" visible="true" receivesShadow="true">
+			<position x="122.11" y="0.076957" z="-20.5749" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="3"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="temple_innen" meshfile ="temple_innen.mesh" visible="true" receivesShadow="true">
+			<position x="122.11" y="0.076957" z="-20.5749" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="3"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Statue_01" meshfile ="Statue_01.mesh" visible="true" receivesShadow="true">
+			<position x="112.486" y="1.53497" z="-17.18" />
+			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="39"/>
+			<renderingdistance data="100" />
+		</entity>
+		<entity name="Statue_02" meshfile ="Statue_02.mesh" visible="true" receivesShadow="true">
+			<position x="112.486" y="1.53497" z="-24.0179" />
+			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<staticgeometrygroup id="40"/>
+			<renderingdistance data="100" />
+		</entity>
+		
+		
+		
+		<entity name="dome_sun" meshfile ="dome_sun.mesh" visible="true" receivesShadow="true">
+			<position x="614.1" y="1980.49" z="-3609.07" />
+			<rotation qx="0.838383" qy="-0.00269342" qz="0.163517" qw="0.51997" />
+			<scale x="38.9469" y="38.9469" z="38.9469" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="10000" />
+		</entity>
+		<entity name="dome_clouds_near" meshfile ="dome_clouds_near.mesh" visible="true" receivesShadow="true">
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="5.08402" y="4.00516" z="4.00516" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="10000" />
+		</entity>
+		<entity name="dome_clouds_far" meshfile ="dome_clouds_far.mesh" visible="true" receivesShadow="true">
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.7353" y="1.7353" z="1.7353" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="10000" />
+		</entity>
+		<entity name="dome" meshfile ="dome.mesh" visible="true" receivesShadow="true">
+			<position x="170.899" y="-451.645" z="-112.896" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="3.14024" y="3.14024" z="3.14024" />
+			<staticgeometrygroup id="2"/>
+			<renderingdistance data="10000" />
+		</entity>
+		
+		
+		
+		
 		<light name="red pointlight" type="point" visible="false"
 			castShadows="false">
 			<position x="65.2876" y="6.02141" z="-66.9458" />

Modified: modules/ruchin/models/Statue_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Statue_02.mesh
===================================================================
(Binary files differ)



From twel at mail.berlios.de  Sun Aug  5 15:28:44 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Sun, 5 Aug 2007 15:28:44 +0200
Subject: [Dsa-hl-svn] r3662 - in rl/trunk/engine: core/include rules/include
Message-ID: <200708051328.l75DSiLT018720@sheep.berlios.de>

Author: twel
Date: 2007-08-05 15:28:41 +0200 (Sun, 05 Aug 2007)
New Revision: 3662

Modified:
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/rules/include/Makefile.am
Log:
updated Makefile.am files for includes

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-08-05 12:53:01 UTC (rev 3661)
+++ rl/trunk/engine/core/include/Makefile.am	2007-08-05 13:28:41 UTC (rev 3662)
@@ -2,7 +2,6 @@
 	Actor.h \
 	ActorControlledObject.h \
 	ActorManager.h \
-	AnimationListener.h \
 	AnimationManager.h \
 	BaseAnimation.h \
 	BoxPrimitive.h \
@@ -10,7 +9,6 @@
 	ConfigurationManager.h \
 	ContentModule.h \
 	CoreDefines.h \
-	CoreEvents.h \
 	CoreMessages.h \
 	CorePrerequisites.h \
 	CoreSubsystem.h \
@@ -27,6 +25,7 @@
 	GameLoop.h \
 	Job.h \
 	JobListener.h \
+	JobQueue.h \
 	JobScheduler.h \
 	LightFadeJob.h \
 	LightObject.h \
@@ -63,6 +62,7 @@
 	SoundResource.h \
 	SoundFadeJob.h \
 	SoundFadeFunctor.h \
+	TimeSource.h \
 	TrackAnimation.h \
 	Trigger.h \
 	World.h \

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-08-05 12:53:01 UTC (rev 3661)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-08-05 13:28:41 UTC (rev 3662)
@@ -18,6 +18,7 @@
 	EigenschaftenStateSet.h \
 	GameObject.h \
 	GameObjectStateListener.h \
+	GameTimeSource.h \
 	Item.h \
 	Inventory.h \
 	JournalEntry.h \
@@ -41,9 +42,5 @@
 	Talentgruppe.h \
 	TalentInputIterator.h \
 	TalentStateSet.h \
-	TimerEvent.h \
-	TimerEventSource.h \
-	TimerListener.h \
-	TimerManager.h \
 	Weapon.h \
 	ZauberStateSet.h



From twel at mail.berlios.de  Sun Aug  5 16:10:03 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Sun, 5 Aug 2007 16:10:03 +0200
Subject: [Dsa-hl-svn] r3663 - modules/ruchin/materials
Message-ID: <200708051410.l75EA3me021541@sheep.berlios.de>

Author: twel
Date: 2007-08-05 16:10:01 +0200 (Sun, 05 Aug 2007)
New Revision: 3663

Modified:
   modules/ruchin/materials/maptest.material
Log:
fixed a comment

Modified: modules/ruchin/materials/maptest.material
===================================================================
--- modules/ruchin/materials/maptest.material	2007-08-05 13:28:41 UTC (rev 3662)
+++ modules/ruchin/materials/maptest.material	2007-08-05 14:10:01 UTC (rev 3663)
@@ -33,7 +33,8 @@
 			texture_unit SplattingMap
 			{
                 
-				texture alpha.dds // eigentlich alpha.dds, die funktioniert aber nicht.
+				// eigentlich alpha.dds, die funktioniert aber nicht.
+				texture alpha.dds
 			}
 			// Texture containing the LightingMap
 			texture_unit LightingMap



From melven at mail.berlios.de  Mon Aug  6 00:44:23 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 6 Aug 2007 00:44:23 +0200
Subject: [Dsa-hl-svn] r3664 - rl/trunk/engine/ui/src
Message-ID: <200708052244.l75MiNel031885@sheep.berlios.de>

Author: melven
Date: 2007-08-06 00:44:06 +0200 (Mon, 06 Aug 2007)
New Revision: 3664

Modified:
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
Log:
Removed bug " FS#18 ?\226?\128?\148 Schwarzer Bildschirm nach Kamera-Char Kollision"

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-05 14:10:01 UTC (rev 3663)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-05 22:44:06 UTC (rev 3664)
@@ -186,7 +186,6 @@
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
         mCameraActor->setOrientation(Quaternion::IDENTITY);
-        mCameraActor->getPhysicalThing()->clearUpConstraint();
         mCameraActor->yaw(mYaw.valueDegrees());
         mCameraActor->pitch(mPitch.valueDegrees());
     }



From melven at mail.berlios.de  Mon Aug  6 00:52:10 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 6 Aug 2007 00:52:10 +0200
Subject: [Dsa-hl-svn] r3665 - in rl/trunk/engine/rules: include src
Message-ID: <200708052252.l75MqA1Q006437@sheep.berlios.de>

Author: melven
Date: 2007-08-06 00:51:58 +0200 (Mon, 06 Aug 2007)
New Revision: 3665

Modified:
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
-now using TimeSource for the time since last floor contact
-some small fixes

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-05 22:44:06 UTC (rev 3664)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-05 22:51:58 UTC (rev 3665)
@@ -172,7 +172,7 @@
         Ogre::String mStillWeightedAnimationName;
 
         // only used in userProcess
-        Ogre::Real mLastFloorContact;
+        Time mLastFloorContact;
 
         // used to reset the material
         const OgreNewt::MaterialID *mOldMaterialId;

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-05 22:44:06 UTC (rev 3664)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-05 22:51:58 UTC (rev 3665)
@@ -24,6 +24,7 @@
 #include "CreatureControllerManager.h"
 #include "PhysicsManager.h"
 #include "PhysicalThing.h"
+#include "TimeSource.h"
 
 
 
@@ -153,7 +154,7 @@
         virtual bool isPossible() const
         {
             return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR;// &&
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
@@ -190,9 +191,7 @@
             omega.x = omega.z = 0;
             Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
 
-            /// @ todo change this
-            torque = springAcc * inertia; // this would be correct
-            //torque = springAcc * mass * 40;
+            torque = springAcc * inertia;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -205,7 +204,8 @@
             Vector3 position;
             body->getPositionOrientation(position, orientation);
 
-            return orientation.getYaw() != mYaw;
+            Real diff = (orientation.getYaw() - mYaw).valueDegrees();
+            return diff <= 0.5f && diff >= -0.5f;
         }
         virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
         {
@@ -1139,7 +1139,7 @@
         mLastCollisionName(""),
         mLastAnimationSpeed(1),
         mStillWeightedAnimationName(""),
-        mLastFloorContact(0)
+        mLastFloorContact(TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_INTERRUPTABLE)->getClock())
     {
         CreatureControllerManager::getSingleton().add(this);
 
@@ -1324,6 +1324,12 @@
 
     bool CreatureController::run(Real elapsedTime)
     {
+        Time timeSinceLastFloorContact = 
+            TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_INTERRUPTABLE)->getClock()
+            - mLastFloorContact;
+        if(timeSinceLastFloorContact >= Time(Date::ONE_SECOND*2) || getAbstractLocation() == AL_AIRBORNE) // 2 seconds?
+                setAbstractLocation(AL_AIRBORNE);
+
         if(mMovement != NULL)
         {
             mLastMovementChange += elapsedTime;
@@ -1338,6 +1344,7 @@
             mRotation = Vector3::ZERO;
             return mMovement->run(elapsedTime, mDirection, rotation);
         }
+
         return false;
     }
 
@@ -1398,16 +1405,9 @@
             if(stepHeight > 0.1f)
                 setContactNormalAcceleration(10);
             setContactElasticity(0.0f);
-            mLastFloorContact = 0.0f;
+            mLastFloorContact = TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_INTERRUPTABLE)->getClock();
         }
-        else
-        {
-            mLastFloorContact += PhysicsManager::getSingleton()._getNewtonWorld()->getTimeStep();
-            if(mLastFloorContact >= 2.2f || getAbstractLocation() == AL_AIRBORNE)
-                setAbstractLocation(AL_AIRBORNE);
-        }
 
-
         if(mMovement != NULL)
         {
             // i hope this will copy the protected members of the contact callback



From pnyx at mail.berlios.de  Mon Aug  6 13:57:02 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Mon, 6 Aug 2007 13:57:02 +0200
Subject: [Dsa-hl-svn] r3666 - in modules: common/materials/model
	common/materials/programs regressiontest/maps ruchin/maps
	ruchin/models
Message-ID: <200708061157.l76Bv2XP007087@sheep.berlios.de>

Author: pnyx
Date: 2007-08-06 13:56:40 +0200 (Mon, 06 Aug 2007)
New Revision: 3666

Added:
   modules/common/materials/model/gras_plane_02.dds
   modules/ruchin/models/nat_grasplane_02.material
   modules/ruchin/models/nat_grasplane_02.mesh
Modified:
   modules/common/materials/model/men_eyeshadow.png
   modules/common/materials/programs/Basic_Pixel_Shader.source
   modules/common/materials/programs/Face_Vertex_Shader.material
   modules/common/materials/programs/Skin_Vertex_Shader.material
   modules/common/materials/programs/TerrainVColorBlending.material
   modules/common/materials/programs/Torso_Vertex_Shader.material
   modules/regressiontest/maps/regressiontest_lights.rlmap.xml
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
   modules/ruchin/models/fass.material
   modules/ruchin/models/kiste.material
Log:
* fixed Basic_Pixel_Shader.source, Light affected alpha value
* set higher ambient value for Skin

Added: modules/common/materials/model/gras_plane_02.dds
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/gras_plane_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/materials/model/men_eyeshadow.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/programs/Basic_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Pixel_Shader.source	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/common/materials/programs/Basic_Pixel_Shader.source	2007-08-06 11:56:40 UTC (rev 3666)
@@ -11,7 +11,8 @@
 
 float4 ps_main( PS_INPUT Input ) : COLOR0
 {
-   return tex2D( baseMap, Input.Texcoord )* Input.Color;
+	float4 SurfColor = tex2D( baseMap, Input.Texcoord );
+   return float4(SurfColor.rgb * Input.Color.rgb, SurfColor.a);
    
 }
 

Modified: modules/common/materials/programs/Face_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -54,7 +54,7 @@
 				
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
 			}
 			
 			texture_unit

Modified: modules/common/materials/programs/Skin_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -46,7 +46,7 @@
 				
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
 			}
 			
 			texture_unit

Modified: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -47,7 +47,7 @@
 				param_named_auto Light_Position0 light_position 0
 				param_named_auto Light_Position1 light_position 1
 
-				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named skycolor float4 0.2 0.2 0.2 1.0
 				param_named groundcolor float4 0.10 0.10 0.10 1.0
 				
 				

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -62,7 +62,7 @@
 				param_named skincolor float4 0.5 0.5 0.5 1
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
 			}
 
 			texture_unit

Modified: modules/regressiontest/maps/regressiontest_lights.rlmap.xml
===================================================================
--- modules/regressiontest/maps/regressiontest_lights.rlmap.xml	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/regressiontest/maps/regressiontest_lights.rlmap.xml	2007-08-06 11:56:40 UTC (rev 3666)
@@ -20,7 +20,7 @@
 			<direction x="0" y="-1" z="0.5" />
 		</light>
 		<light name="blue sun" type="directional" visible="true" castShadows="false">
-			<colourDiffuse r="0" g="0" b="1" />
+			<colourDiffuse r="0.8" g="0.8" b="0.8" />
 			<colourSpecular r="0" g="0" b="1" />
 			<direction x="1" y="-1" z="0" />
 		</light>

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/ruchin/maps/ruchin.scene	2007-08-06 11:56:40 UTC (rev 3666)
@@ -1,4 +1,1009 @@
 <scene formatVersion="0.0" >
-	<nodes>		
+	<nodes>
+		<node name="nat_grasplane_02" id="1" >
+			<position x="12.1403" y="-3.91876" z="5.95557" />
+			<rotation qx="0.0" qy="-0.989197" qz="0.0" qw="0.146591" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="2"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="3" >
+			<position x="12.3358" y="-4.03544" z="7.53353" />
+			<rotation qx="0.0" qy="0.405238" qz="0.0" qw="0.914211" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="4"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="5" >
+			<position x="12.476" y="-4.03544" z="8.98822" />
+			<rotation qx="0.0" qy="0.666179" qz="0.0" qw="0.745792" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="6"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="7" >
+			<position x="12.8264" y="-4.03544" z="9.49756" />
+			<rotation qx="0.0" qy="-0.95198" qz="0.0" qw="-0.306161" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="8"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="9" >
+			<position x="9.09544" y="-3.87379" z="-2.47816" />
+			<rotation qx="0.0" qy="-0.984611" qz="0.0" qw="-0.174758" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="10"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="11" >
+			<position x="9.39308" y="-3.87379" z="-3.66449" />
+			<rotation qx="0.0" qy="-0.942332" qz="0.0" qw="0.334681" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="12"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="13" >
+			<position x="9.24327" y="-3.91142" z="-5.39481" />
+			<rotation qx="0.0" qy="-0.501617" qz="0.0" qw="0.86509" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="14"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="15" >
+			<position x="9.15217" y="-3.91142" z="-6.50291" />
+			<rotation qx="0.0" qy="-0.113387" qz="0.0" qw="0.993551" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="16"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="17" >
+			<position x="12.9885" y="-3.91142" z="-5.11572" />
+			<rotation qx="0.0" qy="-0.501617" qz="0.0" qw="0.86509" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="18"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="19" >
+			<position x="12.1658" y="-3.91142" z="-10.6737" />
+			<rotation qx="0.0" qy="-0.97359" qz="0.0" qw="0.228303" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="20"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="21" >
+			<position x="13.8819" y="-3.91142" z="-11.7534" />
+			<rotation qx="0.0" qy="-0.408354" qz="0.0" qw="0.912824" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="22"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="23" >
+			<position x="12.2524" y="-3.91142" z="-11.6312" />
+			<rotation qx="0.0" qy="-0.408354" qz="0.0" qw="0.912824" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="24"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="25" >
+			<position x="15.0392" y="-3.91142" z="-11.5606" />
+			<rotation qx="0.0" qy="-0.408354" qz="0.0" qw="0.912824" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="26"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="27" >
+			<position x="19.9692" y="-3.70595" z="-11.5549" />
+			<rotation qx="0.0" qy="-0.408354" qz="0.0" qw="0.912824" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="28"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="29" >
+			<position x="20.9144" y="-3.70595" z="-10.5164" />
+			<rotation qx="0.0" qy="-0.35324" qz="0.0" qw="0.935533" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="30"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="31" >
+			<position x="20.9425" y="-3.70595" z="-9.26164" />
+			<rotation qx="0.0" qy="0.203603" qz="0.0" qw="0.979053" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="32"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="33" >
+			<position x="21.9024" y="-3.70595" z="-8.25762" />
+			<rotation qx="0.0" qy="0.203603" qz="0.0" qw="0.979053" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="34"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="35" >
+			<position x="21.1804" y="-3.70595" z="-6.86191" />
+			<rotation qx="0.0" qy="-0.792591" qz="0.0" qw="0.609754" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="36"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="37" >
+			<position x="20.5812" y="-3.70595" z="-7.56438" />
+			<rotation qx="0.0" qy="-0.792591" qz="0.0" qw="0.609754" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="38"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="39" >
+			<position x="20.8044" y="-3.70595" z="-5.55248" />
+			<rotation qx="0.0" qy="-0.194314" qz="0.0" qw="0.980939" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="40"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="41" >
+			<position x="28.5135" y="-3.16373" z="0.139418" />
+			<rotation qx="0.0" qy="-0.792591" qz="0.0" qw="0.609754" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="42"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="43" >
+			<position x="28.8595" y="-3.16373" z="-0.931836" />
+			<rotation qx="0.0" qy="-0.180642" qz="0.0" qw="0.983549" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="44"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="45" >
+			<position x="27.4877" y="-3.25496" z="-1.50989" />
+			<rotation qx="0.0" qy="-0.180642" qz="0.0" qw="0.983549" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="46"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="47" >
+			<position x="28.9248" y="-3.25496" z="-2.93235" />
+			<rotation qx="0.0" qy="-0.180642" qz="0.0" qw="0.983549" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="48"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="49" >
+			<position x="28.7387" y="-3.06082" z="-4.54553" />
+			<rotation qx="0.0" qy="-0.998828" qz="0.0" qw="0.0484063" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="50"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="51" >
+			<position x="30.0858" y="-2.95868" z="-11.7367" />
+			<rotation qx="0.0" qy="-0.998828" qz="0.0" qw="0.0484063" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="52"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="53" >
+			<position x="29.6842" y="-3.05748" z="-12.8235" />
+			<rotation qx="0.0" qy="-0.0760536" qz="0.0" qw="0.997104" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="54"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="55" >
+			<position x="32.5652" y="-2.44728" z="-20.2423" />
+			<rotation qx="0.0" qy="-0.0760536" qz="0.0" qw="0.997104" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="56"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="57" >
+			<position x="34.0081" y="-2.03419" z="-20.2407" />
+			<rotation qx="0.0" qy="-0.694851" qz="0.0" qw="0.719154" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="58"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="59" >
+			<position x="34.5363" y="-1.75477" z="-26.356" />
+			<rotation qx="0.0" qy="-0.694851" qz="0.0" qw="0.719154" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="60"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="61" >
+			<position x="35.1525" y="-1.67279" z="-27.8483" />
+			<rotation qx="0.0" qy="-0.97766" qz="0.0" qw="-0.210194" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="62"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="63" >
+			<position x="36.5599" y="-1.54971" z="-29.0771" />
+			<rotation qx="0.0" qy="-0.244601" qz="0.0" qw="0.969624" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="64"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="65" >
+			<position x="37.2404" y="-2.03294" z="-38.6101" />
+			<rotation qx="0.0" qy="-0.244601" qz="0.0" qw="0.969624" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="66"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="67" >
+			<position x="38.7016" y="-2.03294" z="-38.9248" />
+			<rotation qx="0.0" qy="-0.244601" qz="0.0" qw="0.969624" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="68"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="69" >
+			<position x="39.0755" y="-2.03294" z="-40.5132" />
+			<rotation qx="0.0" qy="-0.889388" qz="0.0" qw="-0.457153" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="70"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="71" >
+			<position x="40.1157" y="-1.65864" z="-41.3999" />
+			<rotation qx="0.0" qy="-0.244601" qz="0.0" qw="0.969624" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="72"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="73" >
+			<position x="39.9943" y="-1.65864" z="-40.221" />
+			<rotation qx="0.0" qy="-0.697901" qz="0.0" qw="0.716194" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="74"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="75" >
+			<position x="41.0767" y="-1.65864" z="-42.6901" />
+			<rotation qx="0.0" qy="-0.290427" qz="0.0" qw="0.956897" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="76"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="77" >
+			<position x="42.0851" y="-1.21236" z="-44.0211" />
+			<rotation qx="0.158806" qy="-0.286729" qz="0.00725725" qw="0.94473" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="78"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="79" >
+			<position x="43.5726" y="-0.893272" z="-44.0895" />
+			<rotation qx="0.101684" qy="-0.317873" qz="-0.0529547" qw="0.941176" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="80"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="81" >
+			<position x="45.5496" y="-0.893272" z="-41.1356" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="82"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="83" >
+			<position x="44.5142" y="-1.0719" z="-39.8392" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="84"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="85" >
+			<position x="12.9912" y="-3.46375" z="-32.8881" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="86"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="87" >
+			<position x="12.3675" y="-3.46375" z="-31.818" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="88"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="89" >
+			<position x="10.988" y="-3.7524" z="-27.1143" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="90"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="91" >
+			<position x="9.32595" y="-3.7524" z="-26.3154" />
+			<rotation qx="0.0227564" qy="-0.0997783" qz="0.0331077" qw="0.994198" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="92"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="93" >
+			<position x="7.66068" y="-4.02819" z="-15.8127" />
+			<rotation qx="0.0" qy="0.283339" qz="0.0" qw="0.95902" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="94"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="95" >
+			<position x="7.99852" y="-4.04079" z="-13.464" />
+			<rotation qx="0.0" qy="0.283339" qz="0.0" qw="0.95902" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="96"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="97" >
+			<position x="4.41469" y="-4.208" z="-0.585596" />
+			<rotation qx="0.0" qy="-0.984611" qz="0.0" qw="-0.174758" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="98"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="99" >
+			<position x="3.19021" y="-4.47254" z="-1.41885" />
+			<rotation qx="0.0" qy="0.322921" qz="0.0" qw="0.946426" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="100"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="101" >
+			<position x="2.25649" y="-4.49495" z="-2.93467" />
+			<rotation qx="0.0" qy="0.322921" qz="0.0" qw="0.946426" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="102"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="103" >
+			<position x="-1.44903" y="-4.69279" z="-8.82443" />
+			<rotation qx="0.0" qy="0.322921" qz="0.0" qw="0.946426" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="104"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="105" >
+			<position x="-2.9223" y="-4.69279" z="-10.7786" />
+			<rotation qx="0.0" qy="0.567675" qz="0.0" qw="0.823253" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="106"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="107" >
+			<position x="-3.9129" y="-4.69279" z="-12.1025" />
+			<rotation qx="0.0" qy="0.567675" qz="0.0" qw="0.823253" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="108"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="nat_grasplane_02" id="109" >
+			<position x="-5.30253" y="-4.69279" z="-13.6467" />
+			<rotation qx="0.0" qy="-0.947239" qz="0.0" qw="0.320528" />
+			<scale x="0.0237419" y="0.0237419" z="0.0237419" />
+			<entity
+				name="nat_grasplane_02"
+				id="110"
+				meshFile ="nat_grasplane_02.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+ <userData><property type="INT" name="staticgeom_group" data="0"/><property type="STRING" name="physical_body" data="none"/><property type="FLOAT" name="renderingdistance" data="20000"/></userData> 
+
+		</node>
+		<node name="arc_kiste" id="111" >
+			<position x="33.2876" y="-2.19409" z="-34.0233" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_kiste"
+				id="112"
+				meshFile ="arc_kiste.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_kiste" id="113" >
+			<position x="33.8888" y="-2.13416" z="-34.871" />
+			<rotation qx="0.0203078" qy="-0.853874" qz="-0.0123657" qw="0.519937" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_kiste"
+				id="114"
+				meshFile ="arc_kiste.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_kiste" id="115" >
+			<position x="14.6649" y="-3.1104" z="-37.7968" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_kiste"
+				id="116"
+				meshFile ="arc_kiste.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_kiste" id="117" >
+			<position x="8.10038" y="-3.25085" z="-54.1215" />
+			<rotation qx="0.00294125" qy="0.0410633" qz="0.0713836" qw="0.996599" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_kiste"
+				id="118"
+				meshFile ="arc_kiste.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="119" >
+			<position x="22.4811" y="-2.48196" z="-41.9093" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="120"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="121" >
+			<position x="23.1653" y="-2.45864" z="-41.0896" />
+			<rotation qx="0.0" qy="0.74303" qz="0.0" qw="0.669258" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="122"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="123" >
+			<position x="23.9028" y="-2.04331" z="-40.3259" />
+			<rotation qx="-0.493429" qy="0.501984" qz="0.547819" qw="0.452144" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="124"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="125" >
+			<position x="34.4667" y="-2.13166" z="-35.6118" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="126"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="127" >
+			<position x="27.4965" y="-2.55635" z="-31.9899" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="128"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="129" >
+			<position x="28.3967" y="-2.40527" z="-32.5144" />
+			<rotation qx="0.0" qy="-0.939693" qz="0.0" qw="0.34202" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="130"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="131" >
+			<position x="14.7184" y="-3.74856" z="-19.0846" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="132"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="arc_fass" id="133" >
+			<position x="25.2417" y="-3.24874" z="0.0529724" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="arc_fass"
+				id="134"
+				meshFile ="arc_fass.mesh"
+				materialFile="ruchin.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
 	</nodes>
-</scene>
+</scene>
\ No newline at end of file

Modified: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2007-08-06 11:56:40 UTC (rev 3666)
@@ -208,7 +208,7 @@
 			<spotlightrange inner="10" outer="20" falloff="1" />
 			<direction x="0" y="-1" z="0.5" />
 		</light>
-		<light name="sun" type="directional" visible="true" castShadows="false">
+		<light name="sun" type="directional" visible="true" castShadows="true">
 			<colourDiffuse r="0.8" g="0.8" b="0.8" />
 			<colourSpecular r="0" g="0" b="1" />
 			<direction x="-0.17101" y="-0.873647" z="0.969846" />

Modified: modules/ruchin/models/fass.material
===================================================================
--- modules/ruchin/models/fass.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/ruchin/models/fass.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -1,7 +1,7 @@
 
-material arc_fass : NormalMapMaterialSpecular2Lights1UV
+material arc_fass : Basic_Vertex_Shader
 {
-			set_texture_alias normalmap arc_fass_normal.dds
-			set_texture_alias diffusemap arc_fass_diffuse.dds
-			set_texture_alias specmap arc_fass_spec.dds
+			
+			set_texture_alias diffuse arc_fass_diffuse.dds
+
 }
\ No newline at end of file

Modified: modules/ruchin/models/kiste.material
===================================================================
--- modules/ruchin/models/kiste.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/ruchin/models/kiste.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -1,7 +1,6 @@
 
-material arc_kiste : NormalMapMaterialSpecular2Lights1UV
+material arc_kiste : Basic_Vertex_Shader
 {
-			set_texture_alias normalmap arc_kiste_normal.dds
-			set_texture_alias diffusemap arc_kiste_diffuse.dds
-			set_texture_alias specmap arc_kiste_spec.dds
+			set_texture_alias diffuse arc_kiste_diffuse.dds
+
 }
\ No newline at end of file

Added: modules/ruchin/models/nat_grasplane_02.material
===================================================================
--- modules/ruchin/models/nat_grasplane_02.material	2007-08-05 22:51:58 UTC (rev 3665)
+++ modules/ruchin/models/nat_grasplane_02.material	2007-08-06 11:56:40 UTC (rev 3666)
@@ -0,0 +1,64 @@
+
+material nat_grasplanes_02: Basic_Vertex_Shader
+{
+	receive_shadows off
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 1.0 1.0 1.0 1.0
+				param_named groundcolor float4 0.6 0.6 0.6 1.0
+			}
+			
+			texture_unit
+			{
+				texture gras_plane_02.dds
+
+			}
+		}
+	}
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture gras_plane_02.dds
+            }
+        }
+    }
+}
+//set_texture_alias diffuse gras_planes.dds
+

Added: modules/ruchin/models/nat_grasplane_02.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/nat_grasplane_02.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pnyx at mail.berlios.de  Mon Aug  6 13:59:24 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Mon, 6 Aug 2007 13:59:24 +0200
Subject: [Dsa-hl-svn] r3667 - modules/common/materials/programs
Message-ID: <200708061159.l76BxOtH007384@sheep.berlios.de>

Author: pnyx
Date: 2007-08-06 13:59:23 +0200 (Mon, 06 Aug 2007)
New Revision: 3667

Modified:
   modules/common/materials/programs/Basic_Pixel_ShaderUV1.source
Log:
* fixed Basic_Pixel_Shader.source, Light affected alpha value

Modified: modules/common/materials/programs/Basic_Pixel_ShaderUV1.source
===================================================================
--- modules/common/materials/programs/Basic_Pixel_ShaderUV1.source	2007-08-06 11:56:40 UTC (rev 3666)
+++ modules/common/materials/programs/Basic_Pixel_ShaderUV1.source	2007-08-06 11:59:23 UTC (rev 3667)
@@ -11,8 +11,8 @@
 
 float4 ps_main( PS_INPUT Input ) : COLOR0
 {
-   return tex2D( baseMap, Input.Texcoord1 )* Input.Color;
-   
+   float4 SurfColor = tex2D( baseMap, Input.Texcoord1 );
+   return float4(SurfColor.rgb * Input.Color.rgb, SurfColor.a);
 }
 
 



From melven at mail.berlios.de  Mon Aug  6 19:36:00 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 6 Aug 2007 19:36:00 +0200
Subject: [Dsa-hl-svn] r3668 - in rl/trunk/engine/core: include src
Message-ID: <200708061736.l76Ha02R017563@sheep.berlios.de>

Author: melven
Date: 2007-08-06 19:35:52 +0200 (Mon, 06 Aug 2007)
New Revision: 3668

Modified:
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
added possibility to log the properties of all newton-bodies

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-08-06 11:59:23 UTC (rev 3667)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-08-06 17:35:52 UTC (rev 3668)
@@ -352,6 +352,11 @@
 
         //! generic physics contact callback handler object
         PhysicsGenericContactCallback* mGenericCallback;
+
+#ifdef _DEBUG
+        static void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body );
+#endif
+
     };
 
     class PhysicsCollisionFactory

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-06 11:59:23 UTC (rev 3667)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-06 17:35:52 UTC (rev 3668)
@@ -99,11 +99,6 @@
 
         // below here starts 'old' stale fix code that should be removed
 
-        // setup character material
-        // actually this is needed here, because the actor is created in advance before the
-        // character controller who actually does create 'character' material too.
-        createMaterialID("character");
-
         // setup level quadtree extents
         mLevelBodiesQuadTree.setMaxData(20);
         mLevelBodiesQuadTree.setMaxDepth(10);
@@ -148,14 +143,62 @@
         {
             mWorld->update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
+#ifdef _DEBUG
+            if( mDebugMode )
+            {
+                LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
+                    "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
+                    "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
+                NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
+            }
+#endif
         }
         if( mElapsed > mMinTimestep)
         {
             mWorld->update(mElapsed);
             mElapsed = 0;
+#ifdef _DEBUG
+            if( mDebugMode )
+            {
+                LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
+                    "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
+                    "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
+                NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
+            }
+#endif
         }
     }
 
+#ifdef _DEBUG
+    void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body )
+    {
+        std::ostringstream oss;
+        Quaternion orient;
+        Vector3 pos;
+        float matrix[16];
+        NewtonBodyGetMatrix(body,matrix);
+        OgreNewt::Converters::MatrixToQuatPos(matrix,orient,pos);
+        Vector3 force;
+        NewtonBodyGetForce(body, &force.x);
+        Vector3 torque;
+        NewtonBodyGetTorque(body, &torque.x);
+        Vector3 omega;
+        NewtonBodyGetOmega(body, &omega.x);
+        Vector3 velocity;
+        NewtonBodyGetVelocity(body, &velocity.x);
+        Vector3 invMass, invIxx, invIyy, invIzz;
+        NewtonBodyGetInvMass(body, &invMass.x, &invIxx.x, &invIyy.x, &invIzz.x);
+        oss << "\tNewtonBodyLog: " << body << "  " << pos << "  " << orient << "  " << velocity << "  "
+            << omega << "  " << force << "  " << torque << "  " << NewtonBodyGetSleepingState(body)
+            << "  " << NewtonBodyGetAutoFreeze(body) << "  " << NewtonBodyGetContinuousCollisionMode(body) << "  ( "
+            << invMass << "  " << invIxx << "  " << invIyy << "  " << invIzz << " )";
+        LOG_DEBUG(Logger::CORE, oss.str());
+    }
+#endif
+
+
+
+
     void PhysicsManager::setGravity( Real x, Real y, Real z )
     {
         mGravity = Vector3(x, y, z);



From melven at mail.berlios.de  Mon Aug  6 19:40:55 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 6 Aug 2007 19:40:55 +0200
Subject: [Dsa-hl-svn] r3669 - rl/trunk/engine/core/src
Message-ID: <200708061740.l76HetsR017717@sheep.berlios.de>

Author: melven
Date: 2007-08-06 19:40:43 +0200 (Mon, 06 Aug 2007)
New Revision: 3669

Modified:
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
better performance, if the properties of bodies are not logged

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-06 17:35:52 UTC (rev 3668)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-06 17:40:43 UTC (rev 3669)
@@ -149,7 +149,8 @@
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
-                NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
+                if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
+                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
             }
 #endif
         }
@@ -163,8 +164,8 @@
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
-                NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
-            }
+                if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
+                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);            }
 #endif
         }
     }



From pnyx at mail.berlios.de  Tue Aug  7 11:22:27 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 7 Aug 2007 11:22:27 +0200
Subject: [Dsa-hl-svn] r3670 - in modules: common/materials/model
	common/materials/programs ruchin/models
Message-ID: <200708070922.l779MRmB028466@sheep.berlios.de>

Author: pnyx
Date: 2007-08-07 11:21:23 +0200 (Tue, 07 Aug 2007)
New Revision: 3670

Added:
   modules/common/materials/programs/Basic_Pixel_ShaderUV1_glsl.source
   modules/common/materials/programs/Basic_Pixel_Shader_Variation_glsl.source
   modules/common/materials/programs/Basic_Pixel_Shader_glsl.source
   modules/common/materials/programs/Basic_Vertex_Shader_glsl.source
   modules/common/materials/programs/Face_Pixel_Shader_glsl.source
   modules/common/materials/programs/Face_Vertex_Shader_glsl.source
   modules/common/materials/programs/Skin_Vertex_Shader_glsl.source
   modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.source
   modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader_glsl.source
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.source
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader_glsl.source
   modules/common/materials/programs/Torso_Pixel_Shader_2_glsl.source
   modules/common/materials/programs/Torso_Pixel_Shader_glsl.source
   modules/common/materials/programs/Torso_Vertex_Shader_glsl.source
Removed:
   modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
Modified:
   modules/common/materials/model/gras_plane_02.dds
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
   modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
   modules/common/materials/programs/Face_Vertex_Shader.material
   modules/common/materials/programs/Skin_Vertex_Shader.material
   modules/common/materials/programs/TerrainVColorBlending.material
   modules/common/materials/programs/Torso_Vertex_Shader.material
   modules/ruchin/models/Ruchin_ground.material
   modules/ruchin/models/nat_grasplane_02.material
   modules/ruchin/models/ruchin_terrain.material
Log:
*converted most shaders to glsl

Modified: modules/common/materials/model/gras_plane_02.dds
===================================================================
(Binary files differ)

Added: modules/common/materials/programs/Basic_Pixel_ShaderUV1_glsl.source
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/programs/Basic_Pixel_ShaderUV1_glsl.source
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/programs/Basic_Pixel_Shader_Variation_glsl.source
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/programs/Basic_Pixel_Shader_Variation_glsl.source
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/programs/Basic_Pixel_Shader_glsl.source
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/programs/Basic_Pixel_Shader_glsl.source
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -15,6 +15,16 @@
 	entry_point ps_main
 }
 
+vertex_program Basic_Vertex_Shader_glsl glsl
+{
+	source Basic_Vertex_Shader_glsl.source
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Basic_Pixel_Shader_glsl glsl
+{
+	source Basic_Pixel_Shader_glsl.source
+}
+
 vertex_program Basic_Vertex_Shader_SR hlsl
 {
   source SimpleShadowReceiver.hlsl
@@ -25,13 +35,61 @@
 material Basic_Vertex_Shader
 {
 	receive_shadows off
-	technique
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+	
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
 			{
 			}

Modified: modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -5,17 +5,69 @@
 	target ps_2_0
 	entry_point ps_main
 }
+fragment_program Basic_Pixel_ShaderUV1_glsl glsl
+{
+	source Basic_Pixel_ShaderUV1_glsl.source
 
+}
 
+
 material Basic_Vertex_ShaderUV1
 {
-	technique
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_ShaderUV1_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_ShaderUV1
 			{
 			}

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -1,7 +1,8 @@
 //Effect: Textured
 material Basic_Vertex_Shader_Alpha
 {
-	technique
+
+	technique glsl
 	{	
 		pass
 		{
@@ -12,6 +13,59 @@
       		//alpha_rejection greater 50
       		
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		
+	}
+	technique hlsl
+	{	
+		pass
+		{
+			scene_blend alpha_blend
+      		// Tiefenpuffer aus
+      		depth_write off
+      		
+      		//alpha_rejection greater 50
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
 			{
 			}

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -1,20 +1,127 @@
 //Effect: Textured
 material Basic_Vertex_Shader_Hair
 {
-	technique
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			scene_blend alpha_blend 
       		// Tiefenpuffer aus
-      		depth_write off
-      		//alpha_rejection greater 128
+      		//depth_write off
+      		alpha_rejection greater 128
       		
       		cull_hardware anticlockwise 
       		cull_software back 
       		
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 20
+      		
+      		cull_hardware clockwise 
+      		cull_software front 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		
+	}
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 128
+      		
+      		cull_hardware anticlockwise 
+      		cull_software back 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
 			{
 			}
@@ -58,8 +165,8 @@
 		{
 			scene_blend alpha_blend 
       		// Tiefenpuffer aus
-      		depth_write off
-      		//alpha_rejection greater 128
+      		//depth_write off
+      		alpha_rejection greater 20
       		
       		cull_hardware clockwise 
       		cull_software front 

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -7,16 +7,85 @@
 	target ps_2_0
 	entry_point ps_main
 }
+fragment_program Basic_Pixel_Shader_Variation_glsl glsl
+{
+	source Basic_Pixel_Shader_Variation_glsl.source
 
+}
+
 material Basic_Vertex_Shader_Variation
 {
-	technique
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_Variation_glsl
+			{
+				param_named baseMap int 0
+				param_named varMap int 1
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			// HLSL Vertex Shader
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias variation
+
+			}
+		}
+	}
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader_Variation
 			{
 			}

Added: modules/common/materials/programs/Basic_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Basic_Vertex_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,153 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+};
+
+struct VS_INPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec3 Normal;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light1_attenuation;
+uniform vec4 Light1_color;
+uniform vec4 Light1_position;
+uniform vec4 Light1_spec_power;
+uniform vec4 Light2_attenuation;
+uniform vec4 Light2_color;
+uniform vec4 Light2_position;
+uniform vec4 Light2_spec_power;
+uniform vec4 Light3_attenuation;
+uniform vec4 Light3_color;
+uniform vec4 Light3_position;
+uniform vec4 Light3_spec_power;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform vec4 skycolor;
+uniform vec4 vViewPosition;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input ) {
+    VS_OUTPUT Output;
+    vec3 LightDir;
+    float Dist;
+    float AngleAttn;
+    vec3 EyeVect;
+    vec3 HalfVect;
+    float SpecAttn;
+    float DistAttn;
+
+    Output.Color = mix( skycolor, groundcolor, vec4( ((dot( Input.Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000)));
+    Output.Position = ( matViewProjection * Input.Position );
+    LightDir = vec3( (Light1_position - (Input.Position * Light1_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light1_color * Light1_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light1_attenuation.y  + (Light1_attenuation.z  * Dist)) + ((Light1_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light1_color * AngleAttn) + SpecAttn) * DistAttn);
+    LightDir = vec3( (Light3_position - (Input.Position * Light3_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light3_color * Light3_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light3_attenuation.y  + (Light3_attenuation.z  * Dist)) + ((Light3_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light3_color * AngleAttn) + SpecAttn) * DistAttn);
+    LightDir = vec3( (Light2_position - (Input.Position * Light2_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light2_color * Light2_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light2_attenuation.y  + (Light2_attenuation.z  * Dist)) + ((Light2_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light2_color * AngleAttn) + SpecAttn) * DistAttn);
+    Output.Texcoord = Input.Texcoord;
+    Output.Texcoord1 = Input.Texcoord1;
+    Output.Texcoord2 = Input.Texcoord2;
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+    VS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Position = vec4( gl_Vertex);
+    xlat_temp_Input.Texcoord = vec2( gl_MultiTexCoord0);
+    xlat_temp_Input.Texcoord1 = vec2( gl_MultiTexCoord1);
+    xlat_temp_Input.Texcoord2 = vec2( gl_MultiTexCoord2);
+    xlat_temp_Input.Normal = vec3( gl_Normal);
+
+    xlat_retVal = vs_main( xlat_temp_Input);
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_TexCoord[0] = vec4( xlat_retVal.Texcoord, 0.0, 0.0);
+    gl_TexCoord[1] = vec4( xlat_retVal.Texcoord1, 0.0, 0.0);
+    gl_TexCoord[2] = vec4( xlat_retVal.Texcoord2, 0.0, 0.0);
+    gl_TexCoord[3] = vec4( xlat_retVal.Color);
+}
+
+
+
\ No newline at end of file

Added: modules/common/materials/programs/Face_Pixel_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Face_Pixel_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Face_Pixel_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,58 @@
+//
+// Structure definitions
+//
+
+struct PS_INPUT {
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform sampler2D Texture1;
+uniform sampler2D Texture2;
+uniform sampler2D baseMap;
+
+//
+// Function declarations
+//
+
+vec4 ps_main( in PS_INPUT Input );
+
+//
+// Function definitions
+//
+
+vec4 ps_main( in PS_INPUT Input ) {
+    vec4 eyeColor;
+    vec4 faceColor;
+	
+	
+    eyeColor = (texture2D( Texture1, Input.Texcoord1) * texture2D( Texture2, Input.Texcoord2));
+    faceColor = texture2D( baseMap, Input.Texcoord);
+    return vec4( (mix( eyeColor.xyz , faceColor.xyz , vec3( faceColor.w )) * Input.Color.xyz ), 1.00000);
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    vec4 xlat_retVal;
+    PS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Texcoord = vec2( gl_TexCoord[0]);
+    xlat_temp_Input.Texcoord1 = vec2( gl_TexCoord[1]);
+    xlat_temp_Input.Texcoord2 = vec2( gl_TexCoord[2]);
+    xlat_temp_Input.Color = vec4( gl_TexCoord[3]);
+
+    xlat_retVal = ps_main( xlat_temp_Input);
+
+    gl_FragData[0] = vec4( xlat_retVal);
+}
+
+

Modified: modules/common/materials/programs/Face_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -13,15 +13,90 @@
 	entry_point ps_main
 }
 
+vertex_program Face_Vertex_Shader_glsl glsl
+{
+	source Face_Vertex_Shader_glsl.source
+}
+
+
+fragment_program Face_Pixel_Shader_glsl glsl
+{
+	source Face_Pixel_Shader_glsl.source
+}
+
+
 material Face_Vertex_Shader
 {
-	receive_shadows off
-	technique
+	
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Face_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+				param_named Texture1 int 1
+				param_named Texture2 int 2
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Face_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				param_named eyeDirection float3 0.0 0 0.0
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias eyeColor
+
+			}
+			texture_unit
+			{
+				texture_alias eyeShadow
+
+			}
+		}
+	}
+	
+
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Face_Pixel_Shader
 			{
 			}
@@ -75,7 +150,7 @@
 		}
 	}
 
-	technique
+	technique fixed_function
 	{
         pass
         {

Added: modules/common/materials/programs/Face_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Face_Vertex_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,166 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+};
+
+struct VS_INPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec3 Normal;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light1_attenuation;
+uniform vec4 Light1_color;
+uniform vec4 Light1_position;
+uniform vec4 Light1_spec_power;
+uniform vec4 Light2_attenuation;
+uniform vec4 Light2_color;
+uniform vec4 Light2_position;
+uniform vec4 Light2_spec_power;
+uniform vec4 Light3_attenuation;
+uniform vec4 Light3_color;
+uniform vec4 Light3_position;
+uniform vec4 Light3_spec_power;
+uniform vec3 eyeDirection;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform vec4 skincolor;
+uniform vec4 skycolor;
+uniform vec4 subsurfcolor;
+uniform vec4 vViewPosition;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input ) {
+    VS_OUTPUT Output;
+    vec3 LightDir;
+    float Dist;
+    float AngleAttn;
+    vec3 EyeVect;
+    vec3 HalfVect;
+    float SpecAttn;
+    float DistAttn;
+    float accDistAttn;
+    vec2 eyeDir;
+
+    Output.Color = vec4( 0.000000, 0.000000, 0.000000, 0.000000);
+    Output.Position = ( matViewProjection * Input.Position );
+    LightDir = vec3( (Light1_position - (Input.Position * Light1_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light1_color * Light1_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light1_attenuation.y  + (Light1_attenuation.z  * Dist)) + ((Light1_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light1_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn = DistAttn;
+    LightDir = vec3( (Light3_position - (Input.Position * Light3_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light3_color * Light3_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light3_attenuation.y  + (Light3_attenuation.z  * Dist)) + ((Light3_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light3_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    LightDir = vec3( (Light2_position - (Input.Position * Light2_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light2_color * Light2_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light2_attenuation.y  + (Light2_attenuation.z  * Dist)) + ((Light2_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light2_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    Output.Color = mix( ((xlat_lib_saturate( accDistAttn ) * subsurfcolor) * Output.Color), Output.Color, xlat_lib_saturate( ((Output.Color * 3.00000) - 0.200000) ));
+    Output.Color += mix( skycolor, groundcolor, vec4( ((dot( Input.Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000)));
+    Output.Color *= (skincolor + 0.500000);
+    Output.Texcoord = Input.Texcoord;
+    Output.Texcoord2 = Input.Texcoord1;
+    eyeDir.x  = clamp( (( -eyeDirection.x  ) / 3.00000), -0.300000, 0.300000);
+    eyeDir.y  = clamp( (( -eyeDirection.z  ) / 3.00000), -0.300000, 0.300000);
+    Output.Texcoord1.x  = (Input.Texcoord1.x  + eyeDir.x );
+    Output.Texcoord1.y  = (Input.Texcoord1.y  + eyeDir.y );
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+    VS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Position = vec4( gl_Vertex);
+    xlat_temp_Input.Texcoord = vec2( gl_MultiTexCoord0);
+    xlat_temp_Input.Texcoord1 = vec2( gl_MultiTexCoord1);
+    xlat_temp_Input.Texcoord2 = vec2( gl_MultiTexCoord2);
+    xlat_temp_Input.Normal = vec3( gl_Normal);
+
+    xlat_retVal = vs_main( xlat_temp_Input);
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_TexCoord[0] = vec4( xlat_retVal.Texcoord, 0.0, 0.0);
+    gl_TexCoord[1] = vec4( xlat_retVal.Texcoord1, 0.0, 0.0);
+    gl_TexCoord[2] = vec4( xlat_retVal.Texcoord2, 0.0, 0.0);
+    gl_TexCoord[3] = vec4( xlat_retVal.Color);
+}
+
+

Modified: modules/common/materials/programs/Skin_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -4,17 +4,71 @@
 	target vs_2_0
 	entry_point vs_main
 }
+vertex_program Skin_Vertex_Shader_glsl glsl
+{
+	source Skin_Vertex_Shader_glsl.source
+}
 
 material Skin_Vertex_Shader
 {
 	receive_shadows off
-	technique
+	
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
 			{
 			}

Added: modules/common/materials/programs/Skin_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Skin_Vertex_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,162 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+};
+
+struct VS_INPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec3 Normal;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light1_attenuation;
+uniform vec4 Light1_color;
+uniform vec4 Light1_position;
+uniform vec4 Light1_spec_power;
+uniform vec4 Light2_attenuation;
+uniform vec4 Light2_color;
+uniform vec4 Light2_position;
+uniform vec4 Light2_spec_power;
+uniform vec4 Light3_attenuation;
+uniform vec4 Light3_color;
+uniform vec4 Light3_position;
+uniform vec4 Light3_spec_power;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform vec4 skincolor;
+uniform vec4 skycolor;
+uniform vec4 subsurfcolor;
+uniform vec4 vViewPosition;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input ) {
+    VS_OUTPUT Output;
+    vec3 LightDir;
+    float Dist;
+    float AngleAttn;
+    vec3 EyeVect;
+    vec3 HalfVect;
+    float SpecAttn;
+    float DistAttn;
+    float accDistAttn;
+
+    Output.Color = vec4( 0.000000, 0.000000, 0.000000, 0.000000);
+    Output.Position = ( matViewProjection * Input.Position );
+    LightDir = vec3( (Light1_position - (Input.Position * Light1_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light1_color * Light1_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light1_attenuation.y  + (Light1_attenuation.z  * Dist)) + ((Light1_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light1_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn = DistAttn;
+    LightDir = vec3( (Light3_position - (Input.Position * Light3_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light3_color * Light3_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light3_attenuation.y  + (Light3_attenuation.z  * Dist)) + ((Light3_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light3_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    LightDir = vec3( (Light2_position - (Input.Position * Light2_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light2_color * Light2_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light2_attenuation.y  + (Light2_attenuation.z  * Dist)) + ((Light2_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light2_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    Output.Color = mix( ((xlat_lib_saturate( accDistAttn ) * subsurfcolor) * Output.Color), Output.Color, xlat_lib_saturate( ((Output.Color * 3.00000) - 0.200000) ));
+    Output.Color += mix( skycolor, groundcolor, vec4( ((dot( Input.Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000)));
+    Output.Color *= (skincolor * 2.00000);
+    Output.Texcoord = Input.Texcoord;
+    Output.Texcoord1 = Input.Texcoord1;
+    Output.Texcoord2 = Input.Texcoord2;
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+    VS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Position = vec4( gl_Vertex);
+    xlat_temp_Input.Texcoord = vec2( gl_MultiTexCoord0);
+    xlat_temp_Input.Texcoord1 = vec2( gl_MultiTexCoord1);
+    xlat_temp_Input.Texcoord2 = vec2( gl_MultiTexCoord2);
+    xlat_temp_Input.Normal = vec3( gl_Normal);
+
+    xlat_retVal = vs_main( xlat_temp_Input);
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_TexCoord[0] = vec4( xlat_retVal.Texcoord, 0.0, 0.0);
+    gl_TexCoord[1] = vec4( xlat_retVal.Texcoord1, 0.0, 0.0);
+    gl_TexCoord[2] = vec4( xlat_retVal.Texcoord2, 0.0, 0.0);
+    gl_TexCoord[3] = vec4( xlat_retVal.Color);
+}
+
+
+
\ No newline at end of file

Modified: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -2,7 +2,7 @@
 //DirectX 9.0 HLSL Vertex Shader vs_2_0
 vertex_program TerrainVColorBlending_Vertex_Shader hlsl
 {
-	source TerrainVColorBlending_Vertex_Shader.program.source
+	source TerrainVColorBlending_Vertex_Shader.source
 	target vs_2_0
 	entry_point vs_main
 }
@@ -10,20 +10,142 @@
 //DirectX 9.0 HLSL Pixel Shader ps_2_0
 fragment_program TerrainVColorBlending_Pixel_Shader hlsl
 {
-	source TerrainVColorBlending_Pixel_Shader.program.source
+	source TerrainVColorBlending_Pixel_Shader.source
 	target ps_2_0
 	entry_point ps_main
 }
 
+vertex_program TerrainVColorBlending_Vertex_Shader_glsl glsl
+{
+	source TerrainVColorBlending_Vertex_Shader_glsl.source
+}
 
-material TerrainVColorBlending
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program TerrainVColorBlending_Pixel_Shader_glsl glsl
 {
-	technique
+	source TerrainVColorBlending_Pixel_Shader_glsl.source
+}
+
+
+material TerrainVColorBlendingd
+{
+	technique glsl
 	{
 
 		pass
 		{
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref TerrainVColorBlending_Pixel_Shader_glsl
+			{
+				param_named Texture0 int 0
+				param_named Texture1 int 1
+				param_named Texture2 int 2
+				param_named Texture3 int 3
+				param_named Texture4 int 4
+				param_named Texture5 int 5
+				
+
+				param_named scale_Detail4 float 0.050000 // Alpha
+			}
+			
+			
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref TerrainVColorBlending_Vertex_Shader_glsl
+			{
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named Light_Ambient float4 0.000000 0.000000 0.000000 1.000000
+				
+				//Lights:
+				param_named_auto Light_Attenuation0 light_attenuation 0
+				param_named_auto Light_Attenuation1 light_attenuation 1
+				
+				param_named_auto Light_Color0  light_diffuse_colour 0
+				param_named_auto Light_Color1  light_diffuse_colour 1
+				
+				param_named_auto Light_Position0 light_position 0
+				param_named_auto Light_Position1 light_position 1
+
+				param_named skycolor float4 0.2 0.2 0.2 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+				
+				
+				
+				param_named scale_Texture0 float 0.018000 // Schwarz
+				param_named scale_Detail0 float 0.020000
+
+				param_named scale_Texture1 float 0.007000 // Rot
+				param_named scale_Detail1 float 0.020000
+
+				param_named scale_Texture2 float 0.008500 // Gruen
+				param_named scale_Detail2 float 0.060000
+
+				param_named scale_Texture3 float 0.008000 // Blau
+				param_named scale_Detail3 float 0.050000
+
+				param_named scale_Texture4 float 0.016000 // Alpha 
+														  // fuer scale_Detail4 siehe Oben (Pixelshader)
+								
+			}
+			
+			
+			
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+			
+			
+			
+			//Texture Schwarz
+			texture_unit
+			{
+				texture_alias black
+				texture nat_felsen_01.dds 2d
+			}
+			//Texture Rot
+			texture_unit
+			{
+				texture_alias red
+				texture nat_gras_01.dds 2d
+			}
+			//Texture Gruen
+			texture_unit
+			{
+				texture_alias green
+				texture nat_steingrund_01.dds 2d
+			}
+			//Texture Blau
+			texture_unit
+			{
+				texture_alias blue
+				texture nat_erdboden_01.dds 2d
+			}
+			//Texture Alpha
+			texture_unit
+			{
+				texture_alias alpha
+				texture Tiles.dds 2d
+			}
+			//Lightingmap
+			texture_unit
+			{
+				texture_alias Lightingmap
+				texture Lightingmap2.png 2d
+			}
+		}
+	}
+
+	technique hlsl
+	{
+
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref TerrainVColorBlending_Pixel_Shader
 			{
 

Deleted: modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -1,36 +0,0 @@
-uniform sampler Texture0;
-uniform sampler Texture1;
-uniform sampler Texture2;
-uniform sampler Texture3;
-uniform sampler Texture4;
-uniform sampler Texture5;
-
-uniform float scale_Detail4;
-
-float4 ps_main(float4 Color: COLOR0,
-               float4 UV0 : TEXCOORD0,
-               float4 UV1 : TEXCOORD1,
-               float4 UV2 : TEXCOORD2,
-               float4 UV3 : TEXCOORD3,
-               float4 UV4 : TEXCOORD4,
-               float4 Light:COLOR1) : COLOR0
-{   
-   
-///*   
-
-
-   
-   float4 TexColor = float4(tex2D(Texture0,UV0.xy).rgb,tex2D(Texture0,UV0.zw).a);
-   TexColor = lerp(TexColor,float4(tex2D(Texture1,UV1.xy).rgb,tex2D(Texture1,UV1.zw).a),Color.r);
-   TexColor = lerp(TexColor,float4(tex2D(Texture2,UV2.xy).rgb,tex2D(Texture2,UV2.zw).a),Color.g);
-   TexColor = lerp(TexColor,float4(tex2D(Texture3,UV3.xy).rgb,tex2D(Texture3,UV3.zw).a),Color.b);
-   TexColor = lerp(float4(tex2D(Texture4,UV4.xy).rgb,tex2D(Texture4,UV4.zw * scale_Detail4).a),TexColor,Color.a);
-   
-
-  return TexColor * (TexColor.a+ 0.5) * ((tex2D(Texture5,UV4.zw)-0.5) + Light);
-  //return float4(Color.aaaa);
-
-}
-
-
-

Copied: modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.source (from rev 3656, modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source)

Added: modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,48 @@
+
+//
+// Global variable definitions
+//
+
+uniform sampler2D Texture0;
+uniform sampler2D Texture1;
+uniform sampler2D Texture2;
+uniform sampler2D Texture3;
+uniform sampler2D Texture4;
+uniform sampler2D Texture5;
+uniform float scale_Detail4;
+
+//
+// Function declarations
+//
+
+vec4 ps_main( in vec4 Color, in vec4 UV0, in vec4 UV1, in vec4 UV2, in vec4 UV3, in vec4 UV4, in vec4 Light );
+
+//
+// Function definitions
+//
+
+vec4 ps_main( in vec4 Color, in vec4 UV0, in vec4 UV1, in vec4 UV2, in vec4 UV3, in vec4 UV4, in vec4 Light ) {
+    vec4 TexColor;
+
+    TexColor = vec4( texture2D( Texture0, UV0.xy ).xyz , texture2D( Texture0, UV0.zw ).w );
+    TexColor = mix( TexColor, vec4( texture2D( Texture1, UV1.xy ).xyz , texture2D( Texture1, UV1.zw ).w ), vec4( Color.x ));
+    TexColor = mix( TexColor, vec4( texture2D( Texture2, UV2.xy ).xyz , texture2D( Texture2, UV2.zw ).w ), vec4( Color.y ));
+    TexColor = mix( TexColor, vec4( texture2D( Texture3, UV3.xy ).xyz , texture2D( Texture3, UV3.zw ).w ), vec4( Color.z ));
+    TexColor = mix( vec4( texture2D( Texture4, UV4.xy ).xyz , texture2D( Texture4, (UV4.zw  * scale_Detail4)).w ), TexColor, vec4( Color.w ));
+    return ((TexColor * (TexColor.w  + 0.500000)) * ((texture2D( Texture5, UV4.zw ) - 0.500000) + Light));
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    vec4 xlat_retVal;
+
+    xlat_retVal = ps_main( vec4(gl_Color), vec4(gl_TexCoord[0]), vec4(gl_TexCoord[1]), vec4(gl_TexCoord[2]), vec4(gl_TexCoord[3]), vec4(gl_TexCoord[4]), vec4(gl_SecondaryColor));
+
+    gl_FragData[0] = vec4( xlat_retVal);
+}
+
+
+
\ No newline at end of file

Deleted: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -1,88 +0,0 @@
-float4x4 matViewProjection;
-
-uniform float scale_Texture0;
-uniform float scale_Texture1;
-uniform float scale_Texture2;
-uniform float scale_Texture3;
-uniform float scale_Texture4;
-
-uniform float scale_Detail0;
-uniform float scale_Detail1;
-uniform float scale_Detail2;
-uniform float scale_Detail3;
-
-uniform float4 Light_Ambient;
-uniform float4 Light_Color0;
-uniform float4 Light_Position0;
-uniform float4 Light_Attenuation0;
-
-uniform float4 Light_Color1;
-uniform float4 Light_Position1;
-uniform float4 Light_Attenuation1;
-
-float4 skycolor;
-float4 groundcolor;
-
-
-struct VS_OUTPUT 
-{
-   float4 Position : POSITION0;
-   float4 Color:   COLOR0;
-   float4 UV0 : TEXCOORD0;
-   float4 UV1 : TEXCOORD1;
-   float4 UV2 : TEXCOORD2;
-   float4 UV3 : TEXCOORD3;
-   float4 UV4 : TEXCOORD4;
-   float4 Light: COLOR1;
-};
-
-VS_OUTPUT vs_main( float4 Position : POSITION0,
-                   float4 Color:COLOR0,
-                   float2 UV:TEXCOORD0,
-                   float3 Normal: NORMAL)
-{
-   VS_OUTPUT Output;
-   UV = Position.xz /4;
-   
-   Output.UV0 = float4(UV*scale_Texture0,UV*scale_Detail0);
-   Output.UV1 = float4(UV*scale_Texture1,UV*scale_Detail1);
-   Output.UV2 = float4(UV*scale_Texture2,UV*scale_Detail2);
-   Output.UV3 = float4(UV*scale_Texture3,UV*scale_Detail3);
-   Output.UV4 = float4(UV*scale_Texture4,UV);
-   
-   
-   Output.Position = mul( matViewProjection, Position );
-   
-   Output.Color = Color;
-   
-   // ######## Light 0 #########
-   float3 LightDir0 = Light_Position0 - Position * Light_Position0.w;
-   float Dist0 = length(LightDir0);
-   LightDir0 /= Dist0;
-   
-   float DistAttn0 = saturate(1/(Light_Attenuation0.y +
-                                Light_Attenuation0.z * Dist0 +
-                                Light_Attenuation0.w * Dist0 * Dist0));
-   float AngleAttn0= saturate(dot(Normal,LightDir0));
-   
-   
-   // ######## Light 1 #########
-   float3 LightDir1 = Light_Position1 - Position * Light_Position1.w;
-   float Dist1 = length(LightDir1);
-   LightDir1 /= Dist1;
-   
-   float DistAttn1 = saturate(1/(Light_Attenuation1.y +
-                                Light_Attenuation1.z * Dist1 +
-                                Light_Attenuation1.w * Dist1 * Dist1));
-   float AngleAttn1= saturate(dot(Normal,LightDir1));
-   
-   
-   // Light Output
-   Output.Light =lerp(skycolor,groundcolor,(dot(Normal, float3(0,-1,0))+1)/2 ) +(Light_Ambient-0.5 + ((Light_Color0 * DistAttn0 * AngleAttn0) + (Light_Color1 * DistAttn1 * AngleAttn1))*1.25);
-   
-   return( Output );
-   
-}
-
-
-

Copied: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.source (from rev 3657, modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source)

Added: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,137 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec4 Color;
+    vec4 UV0;
+    vec4 UV1;
+    vec4 UV2;
+    vec4 UV3;
+    vec4 UV4;
+    vec4 Light;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light_Ambient;
+uniform vec4 Light_Attenuation0;
+uniform vec4 Light_Attenuation1;
+uniform vec4 Light_Color0;
+uniform vec4 Light_Color1;
+uniform vec4 Light_Position0;
+uniform vec4 Light_Position1;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform float scale_Detail0;
+uniform float scale_Detail1;
+uniform float scale_Detail2;
+uniform float scale_Detail3;
+uniform float scale_Texture0;
+uniform float scale_Texture1;
+uniform float scale_Texture2;
+uniform float scale_Texture3;
+uniform float scale_Texture4;
+uniform vec4 skycolor;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in vec4 Position, in vec4 Color, in vec2 UV, in vec3 Normal );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in vec4 Position, in vec4 Color, in vec2 UV, in vec3 Normal ) {
+    VS_OUTPUT Output;
+    vec3 LightDir0;
+    float Dist0;
+    float DistAttn0;
+    float AngleAttn0;
+    vec3 LightDir1;
+    float Dist1;
+    float DistAttn1;
+    float AngleAttn1;
+
+    UV = (Position.xz  / 4.00000);
+    Output.UV0 = vec4( (UV * scale_Texture0), (UV * scale_Detail0));
+    Output.UV1 = vec4( (UV * scale_Texture1), (UV * scale_Detail1));
+    Output.UV2 = vec4( (UV * scale_Texture2), (UV * scale_Detail2));
+    Output.UV3 = vec4( (UV * scale_Texture3), (UV * scale_Detail3));
+    Output.UV4 = vec4( (UV * scale_Texture4), UV);
+    Output.Position = ( matViewProjection * Position );
+    Output.Color = Color;
+    LightDir0 = vec3( (Light_Position0 - (Position * Light_Position0.w )));
+    Dist0 = length( LightDir0 );
+    LightDir0 /= Dist0;
+    DistAttn0 = xlat_lib_saturate( (1.00000 / ((Light_Attenuation0.y  + (Light_Attenuation0.z  * Dist0)) + ((Light_Attenuation0.w  * Dist0) * Dist0))) );
+    AngleAttn0 = xlat_lib_saturate( dot( Normal, LightDir0) );
+    LightDir1 = vec3( (Light_Position1 - (Position * Light_Position1.w )));
+    Dist1 = length( LightDir1 );
+    LightDir1 /= Dist1;
+    DistAttn1 = xlat_lib_saturate( (1.00000 / ((Light_Attenuation1.y  + (Light_Attenuation1.z  * Dist1)) + ((Light_Attenuation1.w  * Dist1) * Dist1))) );
+    AngleAttn1 = xlat_lib_saturate( dot( Normal, LightDir1) );
+    Output.Light = (mix( skycolor, groundcolor, vec4( ((dot( Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000))) + ((Light_Ambient - 0.500000) + ((((Light_Color0 * DistAttn0) * AngleAttn0) + ((Light_Color1 * DistAttn1) * AngleAttn1)) * 1.25000)));
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+
+    xlat_retVal = vs_main( vec4(gl_Vertex), vec4(gl_Color), vec2(gl_MultiTexCoord0), vec3(gl_Normal));
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_FrontColor = vec4( xlat_retVal.Color);
+    gl_TexCoord[0] = vec4( xlat_retVal.UV0);
+    gl_TexCoord[1] = vec4( xlat_retVal.UV1);
+    gl_TexCoord[2] = vec4( xlat_retVal.UV2);
+    gl_TexCoord[3] = vec4( xlat_retVal.UV3);
+    gl_TexCoord[4] = vec4( xlat_retVal.UV4);
+    gl_FrontSecondaryColor = vec4( xlat_retVal.Light);
+}
+
+
+
\ No newline at end of file

Added: modules/common/materials/programs/Torso_Pixel_Shader_2_glsl.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader_2_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Torso_Pixel_Shader_2_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,59 @@
+//
+// Structure definitions
+//
+
+struct PS_INPUT {
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+    vec4 SubColor;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform sampler2D baseMap;
+uniform sampler2D clothMap;
+
+//
+// Function declarations
+//
+
+vec4 ps_main( in PS_INPUT Input );
+
+//
+// Function definitions
+//
+
+vec4 ps_main( in PS_INPUT Input ) {
+    vec4 skin;
+    vec4 cloth;
+
+    skin = (texture2D( baseMap, Input.Texcoord) * vec4( Input.SubColor.xyz , 1.00000));
+    cloth = (texture2D( clothMap, Input.Texcoord2) * vec4( Input.Color.xyz , 1.00000));
+    return vec4( mix( skin.xyz , cloth.xyz , vec3( cloth.w )), (skin.w  + cloth.w ));
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    vec4 xlat_retVal;
+    PS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Texcoord = vec2( gl_TexCoord[0]);
+    xlat_temp_Input.Texcoord1 = vec2( gl_TexCoord[1]);
+    xlat_temp_Input.Texcoord2 = vec2( gl_TexCoord[2]);
+    xlat_temp_Input.Color = vec4( gl_TexCoord[3]);
+    xlat_temp_Input.SubColor = vec4( gl_TexCoord[4]);
+
+    xlat_retVal = ps_main( xlat_temp_Input);
+
+    gl_FragData[0] = vec4( xlat_retVal);
+}
+
+
+
\ No newline at end of file

Added: modules/common/materials/programs/Torso_Pixel_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Torso_Pixel_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,59 @@
+//
+// Structure definitions
+//
+
+struct PS_INPUT {
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+    vec4 SubColor;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform sampler2D baseMap;
+uniform sampler2D clothMap;
+
+//
+// Function declarations
+//
+
+vec4 ps_main( in PS_INPUT Input );
+
+//
+// Function definitions
+//
+
+vec4 ps_main( in PS_INPUT Input ) {
+    vec4 skin;
+    vec4 cloth;
+
+    skin = (texture2D( baseMap, Input.Texcoord) * vec4( Input.SubColor.xyz , 1.00000));
+    cloth = (texture2D( clothMap, Input.Texcoord1) * vec4( Input.Color.xyz , 1.00000));
+    return vec4( mix( skin.xyz , cloth.xyz , vec3( cloth.w )), (skin.w  + cloth.w ));
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    vec4 xlat_retVal;
+    PS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Texcoord = vec2( gl_TexCoord[0]);
+    xlat_temp_Input.Texcoord1 = vec2( gl_TexCoord[1]);
+    xlat_temp_Input.Texcoord2 = vec2( gl_TexCoord[2]);
+    xlat_temp_Input.Color = vec4( gl_TexCoord[3]);
+    xlat_temp_Input.SubColor = vec4( gl_TexCoord[4]);
+
+    xlat_retVal = ps_main( xlat_temp_Input);
+
+    gl_FragData[0] = vec4( xlat_retVal);
+}
+
+
+
\ No newline at end of file

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -22,16 +22,88 @@
 }
 
 
+fragment_program Torso_Pixel_Shader_glsl glsl
+{
+	source Torso_Pixel_Shader_glsl.source
+}
 
+fragment_program Torso_Pixel_Shader_2_glsl glsl
+{
+	source Torso_Pixel_Shader_2_glsl.source
+}
+
+vertex_program Torso_Vertex_Shader_glsl glsl
+{
+	source Torso_Vertex_Shader_glsl.source
+}
+
+
 material Torso_Vertex_Shader_Short
 {
-	technique
+	technique glsl
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
 		pass
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Torso_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+				param_named clothMap int 1
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Torso_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0				
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.25 0.25 0.25 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias skin
+				//texture nat_felsen_01.dds 2d
+			}
+			
+			texture_unit
+			{
+				texture_alias cloth
+				//texture nat_felsen_01.dds 2d
+			}
+		}
+	}
+	
+	
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Torso_Pixel_Shader
 			{
 			}

Added: modules/common/materials/programs/Torso_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader_glsl.source	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/common/materials/programs/Torso_Vertex_Shader_glsl.source	2007-08-07 09:21:23 UTC (rev 3670)
@@ -0,0 +1,167 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+    vec4 SubColor;
+};
+
+struct VS_INPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec3 Normal;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light1_attenuation;
+uniform vec4 Light1_color;
+uniform vec4 Light1_position;
+uniform vec4 Light1_spec_power;
+uniform vec4 Light2_attenuation;
+uniform vec4 Light2_color;
+uniform vec4 Light2_position;
+uniform vec4 Light2_spec_power;
+uniform vec4 Light3_attenuation;
+uniform vec4 Light3_color;
+uniform vec4 Light3_position;
+uniform vec4 Light3_spec_power;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform vec4 skincolor;
+uniform vec4 skycolor;
+uniform vec4 subsurfcolor;
+uniform vec4 vViewPosition;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input ) {
+    VS_OUTPUT Output;
+    vec3 LightDir;
+    float Dist;
+    float AngleAttn;
+    vec3 EyeVect;
+    vec3 HalfVect;
+    float SpecAttn;
+    float DistAttn;
+    float accDistAttn;
+    vec4 ambient;
+
+    Output.Color = vec4( 0.000000, 0.000000, 0.000000, 0.000000);
+    Output.Position = ( matViewProjection * Input.Position );
+    LightDir = vec3( (Light1_position - (Input.Position * Light1_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light1_color * Light1_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light1_attenuation.y  + (Light1_attenuation.z  * Dist)) + ((Light1_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light1_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn = DistAttn;
+    LightDir = vec3( (Light3_position - (Input.Position * Light3_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light3_color * Light3_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light3_attenuation.y  + (Light3_attenuation.z  * Dist)) + ((Light3_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light3_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    LightDir = vec3( (Light2_position - (Input.Position * Light2_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    HalfVect = normalize( (LightDir - EyeVect) );
+    SpecAttn = float( ((Light2_color * Light2_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 32.0000)));
+    DistAttn = clamp( (1.00000 / ((Light2_attenuation.y  + (Light2_attenuation.z  * Dist)) + ((Light2_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Color += (((Light2_color * AngleAttn) + SpecAttn) * DistAttn);
+    accDistAttn += DistAttn;
+    Output.SubColor = mix( ((xlat_lib_saturate( accDistAttn ) * subsurfcolor) * Output.Color), Output.Color, xlat_lib_saturate( ((Output.Color * 3.00000) - 0.200000) ));
+    ambient = mix( skycolor, groundcolor, vec4( ((dot( Input.Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000)));
+    Output.Color += ambient;
+    Output.SubColor += ambient;
+    Output.SubColor *= (skincolor + 0.500000);
+    Output.Texcoord = Input.Texcoord;
+    Output.Texcoord1 = Input.Texcoord1;
+    Output.Texcoord2 = Input.Texcoord2;
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+    VS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Position = vec4( gl_Vertex);
+    xlat_temp_Input.Texcoord = vec2( gl_MultiTexCoord0);
+    xlat_temp_Input.Texcoord1 = vec2( gl_MultiTexCoord1);
+    xlat_temp_Input.Texcoord2 = vec2( gl_MultiTexCoord2);
+    xlat_temp_Input.Normal = vec3( gl_Normal);
+
+    xlat_retVal = vs_main( xlat_temp_Input);
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_TexCoord[0] = vec4( xlat_retVal.Texcoord, 0.0, 0.0);
+    gl_TexCoord[1] = vec4( xlat_retVal.Texcoord1, 0.0, 0.0);
+    gl_TexCoord[2] = vec4( xlat_retVal.Texcoord2, 0.0, 0.0);
+    gl_TexCoord[3] = vec4( xlat_retVal.Color);
+    gl_TexCoord[4] = vec4( xlat_retVal.SubColor);
+}
+
+
+
\ No newline at end of file

Modified: modules/ruchin/models/Ruchin_ground.material
===================================================================
--- modules/ruchin/models/Ruchin_ground.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/ruchin/models/Ruchin_ground.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -8,7 +8,8 @@
    set_texture_alias alpha       nat_steingrund_01.dds
    set_texture_alias Lightingmap Ligthingmap_default.png
    
-   technique
+   
+   technique glsl
    {
       pass
       {
@@ -37,4 +38,34 @@
          }
       }
    }
+   
+   technique hlsl
+   {
+      pass
+      {
+         fragment_program_ref
+         {
+            param_named scale_Detail4 float 0.050000 // Alpha
+         }
+
+         vertex_program_ref
+         {
+            param_named Light_Ambient float4 0.500000 0.500000 0.500000 1.000000
+
+            param_named scale_Texture0 float 0.58000 // Schwarz
+            param_named scale_Detail0 float 0.020000
+
+            param_named scale_Texture1 float 0.5700 // Rot
+            param_named scale_Detail1 float 1.00000
+
+            param_named scale_Texture2 float 0.28500 // Gruen
+            param_named scale_Detail2 float 0.60000
+
+            param_named scale_Texture3 float 0.88000 // Blau
+            param_named scale_Detail3 float 1.00000
+
+            param_named scale_Texture4 float 0.016000 // Alpha
+         }
+      }
+   }
 }

Modified: modules/ruchin/models/nat_grasplane_02.material
===================================================================
--- modules/ruchin/models/nat_grasplane_02.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/ruchin/models/nat_grasplane_02.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -1,64 +1,7 @@
 
 material nat_grasplanes_02: Basic_Vertex_Shader
 {
-	receive_shadows off
-	technique
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
 
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 1.0 1.0 1.0 1.0
-				param_named groundcolor float4 0.6 0.6 0.6 1.0
-			}
-			
-			texture_unit
-			{
-				texture gras_plane_02.dds
-
-			}
-		}
-	}
-
-	technique
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture gras_plane_02.dds
-            }
-        }
-    }
+set_texture_alias diffuse gras_planes.dds
 }
-//set_texture_alias diffuse gras_planes.dds
 

Modified: modules/ruchin/models/ruchin_terrain.material
===================================================================
--- modules/ruchin/models/ruchin_terrain.material	2007-08-06 17:40:43 UTC (rev 3669)
+++ modules/ruchin/models/ruchin_terrain.material	2007-08-07 09:21:23 UTC (rev 3670)
@@ -9,7 +9,7 @@
    set_texture_alias alpha       nat_steingrund_01.dds
    set_texture_alias Lightingmap Ligthingmap_default.png
    
-   technique
+   technique glsl
    {
       pass
       {
@@ -38,4 +38,34 @@
          }
       }
    }
+   
+   technique hlsl
+   {
+      pass
+      {
+         fragment_program_ref
+         {
+            param_named scale_Detail4 float 0.050000 // Alpha
+         }
+
+         vertex_program_ref
+         {
+            param_named Light_Ambient float4 0.500000 0.500000 0.500000 1.000000
+
+            param_named scale_Texture0 float 0.018000 // Schwarz
+            param_named scale_Detail0 float 0.020000
+
+            param_named scale_Texture1 float 0.005700 // Rot
+            param_named scale_Detail1 float 0.100000
+
+            param_named scale_Texture2 float 0.028500 // Gruen
+            param_named scale_Detail2 float 0.060000
+
+            param_named scale_Texture3 float 0.008000 // Blau
+            param_named scale_Detail3 float 0.050000
+
+            param_named scale_Texture4 float 0.016000 // Alpha
+         }
+      }
+   }
 }
\ No newline at end of file



From pnyx at mail.berlios.de  Tue Aug  7 11:27:02 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 7 Aug 2007 11:27:02 +0200
Subject: [Dsa-hl-svn] r3671 - modules/common/materials/programs
Message-ID: <200708070927.l779R2oM028691@sheep.berlios.de>

Author: pnyx
Date: 2007-08-07 11:27:01 +0200 (Tue, 07 Aug 2007)
New Revision: 3671

Modified:
   modules/common/materials/programs/TerrainVColorBlending.material
Log:
ups

Modified: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-08-07 09:21:23 UTC (rev 3670)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-08-07 09:27:01 UTC (rev 3671)
@@ -27,7 +27,7 @@
 }
 
 
-material TerrainVColorBlendingd
+material TerrainVColorBlending
 {
 	technique glsl
 	{



From pnyx at mail.berlios.de  Tue Aug  7 17:54:48 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 7 Aug 2007 17:54:48 +0200
Subject: [Dsa-hl-svn] r3672 - in modules/common: materials materials/model
	materials/programs models
Message-ID: <200708071554.l77FsmTp016328@sheep.berlios.de>

Author: pnyx
Date: 2007-08-07 17:54:19 +0200 (Tue, 07 Aug 2007)
New Revision: 3672

Removed:
   modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
Modified:
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/model/men_human_female_hair_long_01.png
   modules/common/models/men_human_female_hair_long_01_normal.mesh
Log:
*hairshader test added, glsl version did not convert properly, no clue yet

Modified: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-07 09:27:01 UTC (rev 3671)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-07 15:54:19 UTC (rev 3672)
@@ -1,5 +1,6 @@
 
-material men_human_female_hair_long_01_normal : Basic_Vertex_Shader_Hair
+material men_human_female_hair_long_01_normal : Hair_Vertex_Shader
 {
 set_texture_alias diffuse men_human_female_hair_long_01.png
+set_texture_alias spec men_human_female_hair_long_01_spec.png
 }

Modified: modules/common/materials/model/men_human_female_hair_long_01.png
===================================================================
(Binary files differ)

Deleted: modules/common/materials/programs/Basic_Vertex_Shader_Hair.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-07 09:27:01 UTC (rev 3671)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Hair.material	2007-08-07 15:54:19 UTC (rev 3672)
@@ -1,227 +0,0 @@
-//Effect: Textured
-material Basic_Vertex_Shader_Hair
-{
-	technique glsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		//depth_write off
-      		alpha_rejection greater 128
-      		
-      		cull_hardware anticlockwise 
-      		cull_software back 
-      		
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader_glsl
-			{
-				param_named baseMap int 0
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-		
-		pass
-		{
-			scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		//depth_write off
-      		alpha_rejection greater 20
-      		
-      		cull_hardware clockwise 
-      		cull_software front 
-      		
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader_glsl
-			{
-				param_named baseMap int 0
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-		
-		
-	}
-	technique hlsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		//depth_write off
-      		alpha_rejection greater 128
-      		
-      		cull_hardware anticlockwise 
-      		cull_software back 
-      		
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-		
-		pass
-		{
-			scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		//depth_write off
-      		alpha_rejection greater 20
-      		
-      		cull_hardware clockwise 
-      		cull_software front 
-      		
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-		
-		
-	}	
-
-	technique
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture_alias diffuse
-            }
-        }
-    }
-}

Modified: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Tue Aug  7 17:56:55 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 7 Aug 2007 17:56:55 +0200
Subject: [Dsa-hl-svn] r3673 - in modules/common/materials: model programs
Message-ID: <200708071556.l77Futja016482@sheep.berlios.de>

Author: pnyx
Date: 2007-08-07 17:56:25 +0200 (Tue, 07 Aug 2007)
New Revision: 3673

Added:
   modules/common/materials/model/hair_lookup.png
   modules/common/materials/model/men_human_female_hair_long_01_spec.png
   modules/common/materials/programs/Hair_Pixel_Shader.source
   modules/common/materials/programs/Hair_Pixel_Shader_glsl.source
   modules/common/materials/programs/Hair_Vertex_Shader.material
   modules/common/materials/programs/Hair_Vertex_Shader.source
   modules/common/materials/programs/Hair_Vertex_Shader_glsl.source
Log:
*hairshader test added, glsl version did not convert properly, no clue yet

Added: modules/common/materials/model/hair_lookup.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/hair_lookup.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_hair_long_01_spec.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_hair_long_01_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/programs/Hair_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Hair_Pixel_Shader.source	2007-08-07 15:54:19 UTC (rev 3672)
+++ modules/common/materials/programs/Hair_Pixel_Shader.source	2007-08-07 15:56:25 UTC (rev 3673)
@@ -0,0 +1,26 @@
+sampler2D baseMap;
+sampler2D specMap;
+sampler lookup;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   float4 Specular : TEXCOORD4;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+   float4 texcolor =tex2D( baseMap, Input.Texcoord );
+   float4 speccolor=tex2D( specMap, Input.Texcoord );
+   float4 endcolor =texcolor*(Input.Color +tex1D(lookup, clamp(pow(speccolor,2)*Input.Specular*4 ,0.01,0.99))/2);
+   endcolor.a = texcolor.a;
+   return endcolor;
+
+}
+
+
+

Added: modules/common/materials/programs/Hair_Pixel_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Hair_Pixel_Shader_glsl.source	2007-08-07 15:54:19 UTC (rev 3672)
+++ modules/common/materials/programs/Hair_Pixel_Shader_glsl.source	2007-08-07 15:56:25 UTC (rev 3673)
@@ -0,0 +1,63 @@
+//
+// Structure definitions
+//
+
+struct PS_INPUT {
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+    vec4 Specular;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform sampler2D baseMap;
+uniform sampler1D lookup;
+uniform sampler2D specMap;
+
+//
+// Function declarations
+//
+
+vec4 ps_main( in PS_INPUT Input );
+
+//
+// Function definitions
+//
+
+vec4 ps_main( in PS_INPUT Input ) {
+    vec4 texcolor;
+    vec4 speccolor;
+    vec4 endcolor;
+
+    texcolor = texture2D( baseMap, Input.Texcoord);
+    speccolor = texture2D( specMap, Input.Texcoord);
+    endcolor = (texcolor * (Input.Color + (texture1D( lookup, float( clamp( ((pow( speccolor, vec4( 2.00000)) * Input.Specular) * 4.00000), vec4( 0.0100000), vec4( 0.990000)))) / 2.00000)));
+    endcolor.w  = texcolor.w ;
+    return endcolor;
+    //return vec4( ((speccolor.xyz  * Input.Specular.xyz ) * 4.00000), 1.00000);
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    vec4 xlat_retVal;
+    PS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Texcoord = vec2( gl_TexCoord[0]);
+    xlat_temp_Input.Texcoord1 = vec2( gl_TexCoord[1]);
+    xlat_temp_Input.Texcoord2 = vec2( gl_TexCoord[2]);
+    xlat_temp_Input.Color = vec4( gl_TexCoord[3]);
+    xlat_temp_Input.Specular = vec4( gl_TexCoord[4]);
+
+    xlat_retVal = ps_main( xlat_temp_Input);
+
+    gl_FragData[0] = vec4( xlat_retVal);
+}
+
+

Added: modules/common/materials/programs/Hair_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Hair_Vertex_Shader.material	2007-08-07 15:54:19 UTC (rev 3672)
+++ modules/common/materials/programs/Hair_Vertex_Shader.material	2007-08-07 15:56:25 UTC (rev 3673)
@@ -0,0 +1,304 @@
+//Effect: Textured
+
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Hair_Vertex_Shader hlsl
+{
+	source Hair_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Hair_Pixel_Shader hlsl
+{
+	source Hair_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Hair_Vertex_Shader_glsl glsl
+{
+	source Hair_Vertex_Shader_glsl.source
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Hair_Pixel_Shader_glsl glsl
+{
+	source Hair_Pixel_Shader_glsl.source
+}
+
+material Hair_Vertex_Shader
+{	
+	technique glsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 128
+      		
+      		cull_hardware anticlockwise 
+      		cull_software back 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Hair_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+				param_named specMap int 1
+				param_named lookup int 2
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Hair_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 1.0
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias spec
+
+			}
+			texture_unit
+			{
+				texture hair_lookup.png
+				texture_alias lookup
+
+			}
+		}
+		
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 20
+      		
+      		cull_hardware clockwise 
+      		cull_software front 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Hair_Pixel_Shader_glsl
+			{
+				param_named baseMap int 0
+				param_named specMap int 1
+				param_named lookup int 2
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Hair_Vertex_Shader_glsl
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 1.0
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias spec
+
+			}
+			texture_unit
+			{
+				texture hair_lookup.png
+				texture_alias lookup
+
+			}
+		}
+		
+		
+	}
+		
+	technique hlsl
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 128
+      		
+      		cull_hardware anticlockwise 
+      		cull_software back 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Hair_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Hair_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 1.0
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias spec
+
+			}
+			texture_unit
+			{
+				texture hair_lookup.png
+				texture_alias lookup
+
+			}
+		}
+		
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		//depth_write off
+      		alpha_rejection greater 20
+      		
+      		cull_hardware clockwise 
+      		cull_software front 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Hair_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Hair_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 1.0
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias spec
+
+			}
+			texture_unit
+			{
+				texture hair_lookup.png
+				texture_alias lookup
+
+			}
+		}
+		
+		
+	}	
+
+	technique fixed_function
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias spec
+            }
+        }
+    }
+}

Added: modules/common/materials/programs/Hair_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Hair_Vertex_Shader.source	2007-08-07 15:54:19 UTC (rev 3672)
+++ modules/common/materials/programs/Hair_Vertex_Shader.source	2007-08-07 15:56:25 UTC (rev 3673)
@@ -0,0 +1,124 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   float4 Specular   : TEXCOORD4;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+                          
+   Output.Specular = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),8) * DistAttn;
+   
+   Output.Color += (Light1_color * AngleAttn) * DistAttn ;
+   
+   
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   EyeVect = normalize(Input.Position - vViewPosition);
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)
+                          ,0,1);
+   Output.Specular += Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),8)*DistAttn;
+   
+   
+   Output.Color += (Light3_color * AngleAttn) * DistAttn ;
+   
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)
+                        ,0,1);
+                        
+   Output.Specular += Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),8)*DistAttn;
+   
+   
+   Output.Color += (Light2_color * AngleAttn) * DistAttn ;
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord1 = Input.Texcoord1;
+   Output.Texcoord2 = Input.Texcoord2;
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Hair_Vertex_Shader_glsl.source
===================================================================
--- modules/common/materials/programs/Hair_Vertex_Shader_glsl.source	2007-08-07 15:54:19 UTC (rev 3672)
+++ modules/common/materials/programs/Hair_Vertex_Shader_glsl.source	2007-08-07 15:56:25 UTC (rev 3673)
@@ -0,0 +1,154 @@
+//
+// Translator library functions
+//
+
+float xlat_lib_saturate( float x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec2 xlat_lib_saturate( vec2 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec3 xlat_lib_saturate( vec3 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+vec4 xlat_lib_saturate( vec4 x) {
+  return clamp( x, 0.0, 1.0);
+}
+
+mat2 xlat_lib_saturate(mat2 m) {
+  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
+}
+
+mat3 xlat_lib_saturate(mat3 m) {
+  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
+}
+
+mat4 xlat_lib_saturate(mat4 m) {
+  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
+}
+
+
+//
+// Structure definitions
+//
+
+struct VS_OUTPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec4 Color;
+    vec4 Specular;
+};
+
+struct VS_INPUT {
+    vec4 Position;
+    vec2 Texcoord;
+    vec2 Texcoord1;
+    vec2 Texcoord2;
+    vec3 Normal;
+};
+
+
+//
+// Global variable definitions
+//
+
+uniform vec4 Light1_attenuation;
+uniform vec4 Light1_color;
+uniform vec4 Light1_position;
+uniform vec4 Light1_spec_power;
+uniform vec4 Light2_attenuation;
+uniform vec4 Light2_color;
+uniform vec4 Light2_position;
+uniform vec4 Light2_spec_power;
+uniform vec4 Light3_attenuation;
+uniform vec4 Light3_color;
+uniform vec4 Light3_position;
+uniform vec4 Light3_spec_power;
+uniform vec4 groundcolor;
+uniform mat4 matViewProjection;
+uniform vec4 skycolor;
+uniform vec4 vViewPosition;
+
+//
+// Function declarations
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input );
+
+//
+// Function definitions
+//
+
+VS_OUTPUT vs_main( in VS_INPUT Input ) {
+    VS_OUTPUT Output;
+    vec3 LightDir;
+    float Dist;
+    float AngleAttn;
+    vec3 EyeVect;
+    vec3 HalfVect;
+    float DistAttn;
+
+    Output.Color = mix( skycolor, groundcolor, vec4( ((dot( Input.Normal, vec3( 0.000000, -1.00000, 0.000000)) + 1.00000) / 2.00000)));
+    Output.Position = ( matViewProjection * Input.Position );
+    LightDir = vec3( (Light1_position - (Input.Position * Light1_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    DistAttn = clamp( (1.00000 / ((Light1_attenuation.y  + (Light1_attenuation.z  * Dist)) + ((Light1_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Specular = (((Light1_color * Light1_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 8.00000)) * DistAttn);
+    Output.Color += ((Light1_color * AngleAttn) * DistAttn);
+    LightDir = vec3( (Light3_position - (Input.Position * Light3_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    EyeVect = vec3( normalize( (Input.Position - vViewPosition) ));
+    HalfVect = normalize( (LightDir - EyeVect) );
+    DistAttn = clamp( (1.00000 / ((Light3_attenuation.y  + (Light3_attenuation.z  * Dist)) + ((Light3_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Specular += (((Light3_color * Light3_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 8.00000)) * DistAttn);
+    Output.Color += ((Light3_color * AngleAttn) * DistAttn);
+    LightDir = vec3( (Light2_position - (Input.Position * Light2_position.w )));
+    Dist = length( LightDir );
+    LightDir = (LightDir / Dist);
+    AngleAttn = xlat_lib_saturate( dot( Input.Normal, LightDir) );
+    HalfVect = normalize( (LightDir - EyeVect) );
+    DistAttn = clamp( (1.00000 / ((Light2_attenuation.y  + (Light2_attenuation.z  * Dist)) + ((Light2_attenuation.w  * Dist) * Dist))), 0.000000, 1.00000);
+    Output.Specular += (((Light2_color * Light2_spec_power) * pow( clamp( dot( Input.Normal, HalfVect), 0.000000, 1.00000), 8.00000)) * DistAttn);
+    Output.Color += ((Light2_color * AngleAttn) * DistAttn);
+    Output.Texcoord = Input.Texcoord;
+    Output.Texcoord1 = Input.Texcoord1;
+    Output.Texcoord2 = Input.Texcoord2;
+    return Output;
+}
+
+
+//
+// Translator's entry point
+//
+void main() {
+    VS_OUTPUT xlat_retVal;
+    VS_INPUT xlat_temp_Input;
+    xlat_temp_Input.Position = vec4( gl_Vertex);
+    xlat_temp_Input.Texcoord = vec2( gl_MultiTexCoord0);
+    xlat_temp_Input.Texcoord1 = vec2( gl_MultiTexCoord1);
+    xlat_temp_Input.Texcoord2 = vec2( gl_MultiTexCoord2);
+    xlat_temp_Input.Normal = vec3( gl_Normal);
+
+    xlat_retVal = vs_main( xlat_temp_Input);
+
+    gl_Position = vec4( xlat_retVal.Position);
+    gl_TexCoord[0] = vec4( xlat_retVal.Texcoord, 0.0, 0.0);
+    gl_TexCoord[1] = vec4( xlat_retVal.Texcoord1, 0.0, 0.0);
+    gl_TexCoord[2] = vec4( xlat_retVal.Texcoord2, 0.0, 0.0);
+    gl_TexCoord[3] = vec4( xlat_retVal.Color);
+    gl_TexCoord[4] = vec4( xlat_retVal.Specular);
+}
+
+
+
\ No newline at end of file



From tanis at mail.berlios.de  Tue Aug  7 23:21:23 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 7 Aug 2007 23:21:23 +0200
Subject: [Dsa-hl-svn] r3674 - in rl/trunk/engine: ai ai/include ai/src rules
	rules/include rules/src script/swig ui/include ui/src
Message-ID: <200708072121.l77LLN54023087@sheep.berlios.de>

Author: tanis
Date: 2007-08-07 23:20:27 +0200 (Tue, 07 Aug 2007)
New Revision: 3674

Added:
   rl/trunk/engine/ai/include/AgentCombatState.h
   rl/trunk/engine/ai/include/AgentState.h
   rl/trunk/engine/ai/include/AgentSteeringState.h
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/AgentSteeringState.cpp
   rl/trunk/engine/rules/include/Combatant.h
   rl/trunk/engine/rules/src/Combatant.cpp
Removed:
   rl/trunk/engine/ai/include/PlayerVehicle.h
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/include/CombatManager.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/rules/src/CombatManager.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Intermediate state of combat development.
Changed the way AI works. OpenSteer is no longer the top agent layer, instead steering is one discrete agent state among others (combat, dialog).
Changed CreatureController-API so that CreatureControllers are created transparently if one is requested. This way higher level layers like AI and UI have better access to controllers.
Every module save combattest should work fine.

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-07 21:20:27 UTC (rev 3674)
@@ -299,10 +299,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\AgentCombatState.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\AgentManager.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\src\AgentSteeringState.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\AiSubsystem.cpp"
 				>
 			</File>
@@ -347,10 +355,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\PlayerVehicle.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\stdinc.cpp"
 				>
 				<FileConfiguration
@@ -405,10 +409,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\AgentCombatState.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\AgentManager.h"
 				>
 			</File>
 			<File
+				RelativePath=".\include\AgentState.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AgentSteeringState.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\AiPrerequisites.h"
 				>
 			</File>
@@ -465,10 +481,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\PlayerVehicle.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\stdinc.h"
 				>
 			</File>

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/Agent.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -16,16 +16,15 @@
 #ifndef __RlAI_Agent_H__
 #define __RlAI_Agent_H__
 
-#include "FuzzyState.h"
 #include "AgentManager.h"
+#include "AgentState.h"
 
+#include <stack>
+
 namespace rl
 {
-	class SteeringVehicle;
-	class SteeringMachine;
-	class DialogCharacter;
-	class Creature;
 	class Actor;
+	class Creature;
 
 	/** Represents a single entity that has got AI.
 	 * Instantiated objects are normally registered with AgentManager.
@@ -40,11 +39,6 @@
 		 * @param character Creature object
 		 */
 		Agent(Creature* character);
-		/** Constructor by Creature object.
-		 * @param character Creature object
-		 * @param vehicle SteeringVehicle object for the specified creature
-		 */
-		Agent(Creature* character, SteeringVehicle* vehicle);
 
 		/** explicit virtual destructor
 		 */
@@ -55,17 +49,10 @@
 		 * supplied on object creation. Creates a behaviour state machine and
 		 * registers itself as a PhysicsController with PhysicalManager for the
 		 * stored creature object.
+         * Also pushes the SteeringState as the default state onto the state stack.
 		 */
 		void initialize();
 
-		/** Returns the agent type (Player, NPC, etc.).
-		 */
-		AgentManager::AgentType getType();
-		/** Sets the agent type (Player, NPC, etc. ).
-		 * @param type AgentType sets the type to the given one.
-		 */
-		void setType(AgentManager::AgentType type);
-
 		/** Function invoked by AgentManager to let Agents advance their AI.
 		 * Is invoked with time since last invocation. Here the behaviour and
 		 * the vehicle are updated.
@@ -74,50 +61,22 @@
 		/** Adds a steering behaviour to the internal steering machine.
 		 * @param behaviour SteeringBehaviour is initialized and registered to mBehaviour.
 		 */
-		void addSteeringBehaviour(SteeringBehaviour* behaviour);
-		/** Removes all steering behaviours.
-		 */
-        void clearSteeringBehaviours();
 
-		/** Retrieves the stored SteeringVehicle.
-		 */
-		SteeringVehicle* getVehicle();
-
 		/** Retrieves the Creature object controlled by this agent
 		 * @returns Creature object controlled
 		 */
         Creature* getControlledCreature() const;
 
+        AgentState* getCurrentState() const;
+
+        void pushState(AgentStateType);
+        void popState();
+
 	protected:
-		//! stores the type of the agent (Player, NPC, ...)
-		AgentManager::AgentType mType;
-		//! stores the behaviour FuzzyStateMachine for behaviour
-		SteeringMachine* mBehaviour;
-		//! stores the vehicle representation of the creature
-		SteeringVehicle* mVehicle;
+        typedef std::deque<AgentState*> AgentStateStack;
 		//! stores the creature whose AI is simulated
 		Creature* mCreature;
+        std::stack<AgentState*> mAgentStates;
 	};
-
-	inline AgentManager::AgentType Agent::getType()
-	{
-		return mType;
-	}
-
-	inline SteeringVehicle* Agent::getVehicle()
-	{
-		return mVehicle;
-	}
-
-	inline void Agent::setType(AgentManager::AgentType type)
-	{
-		mType = type;
-	}
-
-/*	inline PerceptionPool* Agent::getPerceptionPool()
-	{
-		return mPerceptionPool;
-	}
-*/
 }
 #endif

Added: rl/trunk/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,46 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AgentCombatState_H__
+#define __RlAI_AgentCombatState_H__
+
+#include "AiPrerequisites.h"
+#include "AgentState.h"
+#include "Combatant.h"
+
+namespace rl
+{
+	/** Represents a discrete state an Agent can be in.
+     * The Agent delegates the decision making to the currently active state, wich can
+     * further deligate decision making.
+	 */
+    class _RlAiExport AgentCombatState : public AgentState, public Combatant
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentCombatState(Agent* agent);
+
+        virtual ~AgentCombatState();
+
+        virtual Ogre::String getTypeName();
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		virtual void update(const float elapsedTime);
+	};
+}
+#endif

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -18,6 +18,7 @@
 
 #include <OgreSingleton.h>
 #include "AiPrerequisites.h"
+#include "Combatant.h"
 #include "GameTask.h"
 #include "GameObjectStateListener.h"
 #include "FuzzyState.h"
@@ -47,22 +48,11 @@
 	class _RlAiExport AgentManager
 		: public Ogre::Singleton<AgentManager>,
 		  public GameTask,
-          public GameObjectStateListener
+          public GameObjectStateListener,
+          public CombatantFactory
 		  
 	{
 	public:
-		/** Different types of agents.
-		 * Implemented in order to recognise different types of agents, because
-		 * the AI needs to handle them differently.
-		 */
-		enum AgentType
-		{
-			AGENT_NONE = -1,	//!< when the type is unknown/unset
-			AGENT_PLAYER = 0,	//!< when the agent represents a player
-			AGENT_STD_NPC = 1,	//!< when the agent is a nonplayercharacter
-			AGENT_FLOCKING = 2	//!< hmm, possibly for groups behaviour of NPCs
-		};
-
 		//! defines a std::vector list of Vehicle objects for OpenSteer
 		typedef std::vector<SteeringVehicle*> VehicleList;
 
@@ -76,14 +66,11 @@
 		 * @param type defines the type of the agent \see AgentType
 		 * @param character the associated creature
 		 */
-		Agent* createAgent(AgentType type, Creature* character);
+		Agent* createAgent(Creature* character);
 
         //! Destroys an Agent and all its behaviours. (if any)
         void destroyAgent(Agent*);
 
-		//! ??? purpose ??? needed for opensteer ?
-		VehicleList getNeighbors(Agent* agent);
-
 		/** Interface executed as a GameTask by GameLoop.
 		 * is responsible for advancing the ai logik about the time specified.
 		 * Each registered Agent is executed can advance the specified time.
@@ -107,6 +94,11 @@
 
         /// Set the factory to be used to create behaviours.
         virtual void setBehaviourFactory(BehaviourFactory*);
+
+        // overrides from CombatantFactory
+        virtual Combatant* createCombatant(Creature* creature);
+        virtual void destroyCombatant(Combatant*);
+
 	private:
 
 		/** Used to register an agent internally.
@@ -116,15 +108,13 @@
 		void addAgent(Agent* agent);
 
 		//! defines a std::vector of Agents to ease understanding
-		typedef std::vector<Agent*> AgentList;
+		typedef std::map<Creature*, Agent*> AgentMap;
 
         //! Factory to create behaviours with.
         BehaviourFactory* mBehaviourFactory;
 		
-		//! List of Vehicle objects from the Agents in mAgents (might be needed for opensteer)
-		VehicleList mAllNeighbors;
 		//! List of registered agents (includes mPlayer)
-		AgentList mAgents;
+		AgentMap mAgents;
 		//! Agent representing the player
 		Agent* mPlayer;
 	};

Added: rl/trunk/engine/ai/include/AgentState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AgentState_H__
+#define __RlAI_AgentState_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+	class Agent;
+
+    typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
+
+	/** Represents a discrete state an Agent can be in.
+     * The Agent delegates the decision making to the currently active state, wich can
+     * further deligate decision making.
+	 */
+	class _RlAiExport AgentState
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentState(Agent* agent) : mAgent(agent) {}
+
+        virtual ~AgentState() {}
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		virtual void update(const float elapsedTime) = 0;
+
+        Agent* getAgent() const { return mAgent; }
+
+	protected:
+		Agent* mAgent;
+	};
+}
+#endif

Added: rl/trunk/engine/ai/include/AgentSteeringState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,59 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_SteeringAgentState_H__
+#define __RlAI_SteeringAgentState_H__
+
+#include "AiPrerequisites.h"
+#include "AgentState.h"
+#include "SteeringVehicle.h"
+#include "SteeringMachine.h"
+
+namespace rl
+{
+    /// AgentState that is used when an Agent is idling or walking from A to B.
+    /// This state uses a fuzzy state machine to incorporate one or more behaviours
+    /// for decision making.
+    class _RlAiExport AgentSteeringState : public AgentState
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentSteeringState(Agent* agent);
+
+        virtual ~AgentSteeringState();
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		void update(const float elapsedTime);
+
+		void addSteeringBehaviour(SteeringBehaviour* behaviour);
+		/** Removes all steering behaviours.
+		 */
+        void clearSteeringBehaviours();
+
+		/** Retrieves the stored SteeringVehicle.
+		 */
+		SteeringVehicle* getVehicle();
+
+	protected:
+		//! stores the behaviour FuzzyStateMachine for behaviour
+		SteeringMachine* mBehaviour;
+		//! stores the vehicle representation of the creature
+		SteeringVehicle* mVehicle;
+	};
+}
+#endif

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,9 @@
 noinst_HEADERS =
 	Agent.h \
 	AgentManager.h \
+	AgentCombatState.h \
+	AgentState.h \
+	AgentSteeringState.h \
 	AiPrerequisites.h \
 	AiSubsystem.h \
 	AiWorld.h \

Deleted: rl/trunk/engine/ai/include/PlayerVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/PlayerVehicle.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/PlayerVehicle.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-#ifndef __RlAI_PlayerVehicle_H__
-#define __RlAI_PlayerVehicle_H__
-
-#include "SteeringVehicle.h"
-
-namespace rl
-{
-	class Agent;
-	class Creature;
-	/** Represents the player as a vehicle.
-	 */
-	class PlayerVehicle :
-		public SteeringVehicle
-	{
-	public:
-		/** Constructor
-		 * @param Actor gives the Actor representing the Player
-		 */
-		PlayerVehicle(Creature* character);
-		/** explicit destructor
-		 */
-		virtual ~PlayerVehicle(void);
-
-		/** Updates the steering of the vehicle.
-		 * Update is done by fetching position and orientation from the
-		 * attached PhysicalThing object representing the player. Those
-		 * are then used to set the state of the OpenSteer Obstacle
-		 * accordingly.
-		 * @param currentTime const float current time
-		 * @param elapsedTime const float elapsed time since last call
-		 */
-        // same as SteeringVehicle if mMovingCreature is not set
-		//virtual void update(const float currentTime, const float elapsedTime);
-    protected:
-        virtual void createMovingCreature() {}
-        virtual void destroyMovingCreature() {}
-	};
-}
-
-#endif

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -58,9 +58,8 @@
 	public:
 		/** Constructor.
 		 * @param parent Agent owning this vehicle
-		 * @param character Actor controlled by Agent
 		 */
-		SteeringVehicle(Agent* parent, Creature* character);
+		SteeringVehicle(Agent* parent);
 		/** explicit virtual destructor.
 		 */
 		virtual ~SteeringVehicle(void);
@@ -263,9 +262,6 @@
 		 */
 		void initialize();
 
-        virtual void createMovingCreature(); // permit PlayerVehicle to override this functions!
-        virtual void destroyMovingCreature();
-
 		/** retrieves the neighbours of this SteeringVehicle
 		 */
 		OpenSteer::AVGroup getNeighbors() const;
@@ -299,7 +295,7 @@
         //! Creature object steered by this vehicle (and controlled by Agent).
         Creature* mCreature;
 
-        CreatureController* mMovingCreature;
+        CreatureController* mController;
 
         // derived from debugvisualisable
         virtual void doCreatePrimitive();

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,11 +13,12 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
 #include "Agent.h"
 
 #include "Actor.h"
+#include "AgentSteeringState.h"
 #include "Creature.h"
 #include "DialogCharacter.h"
 #include "Exception.h"
@@ -31,28 +32,15 @@
 namespace rl {
 
 Agent::Agent(Creature* character)
-	: mType(AgentManager::AGENT_NONE),
-      mBehaviour(NULL),
-      mVehicle(NULL),
-	  mCreature(character)
+	: mCreature(character),
+      mAgentStates()
 {
 	initialize();
 	ScriptWrapper::getSingleton().owned(character);
 }
 
-Agent::Agent(Creature* character, SteeringVehicle* vehicle)
-	: mType(AgentManager::AGENT_NONE),
-      mBehaviour(NULL),
-      mVehicle(vehicle),
-	  mCreature(character)
-{
-	initialize();
-}
-
 Agent::~Agent(void)
 {
-    delete mVehicle;
-    delete mBehaviour;
 	if (mCreature != NULL)
 		ScriptWrapper::getSingleton().disowned(mCreature);
 }
@@ -64,47 +52,53 @@
 	{
 		Throw(NullPointerException, "Agent has no creature");
 	}
+}
 
-    //  if there is no vehicle, create a standard vehicle
-	if(mVehicle == NULL)
-	{
-		mType = AgentManager::AGENT_STD_NPC;
-		mVehicle = new SteeringVehicle(this, mCreature);
-	}
-    LOG_MESSAGE(Logger::AI,
-        "created SteeringVehicle for Agent");
-
-	mBehaviour = new SteeringMachine(NULL, mVehicle);
-    LOG_MESSAGE(Logger::AI,
-        "created SteeringMachine for Agent");
+void Agent::update(const float elapsedTime)
+{
 }
 
-void Agent::addSteeringBehaviour(SteeringBehaviour* behaviour)
+Creature* Agent::getControlledCreature() const
 {
-    behaviour->setParent(mBehaviour);
-    behaviour->setController(mVehicle);
-    mBehaviour->addState(behaviour);
-    LOG_MESSAGE(Logger::AI,
-        "added SteeringBehaviour for Agent");
+    return mCreature;
 }
 
-void Agent::clearSteeringBehaviours()
+void Agent::pushState(AgentStateType stateType)
 {
-    mBehaviour->clearStates();
-    LOG_MESSAGE(Logger::AI,
-        "Cleared all SteeringBehaviours for Agent");
+    AgentState* state = NULL;
+    if (stateType == AST_STEERING)
+    {
+        state = new AgentSteeringState(this);
+    }
+    else if (stateType == AST_COMBAT)
+    {
+    }
+    else if (stateType == AST_DIALOG)
+    {
+    }
+    else
+    {
+        Throw(IllegalArgumentException, "Unknown AgentStateType");
+    }
+
+    mAgentStates.push(state);
 }
 
-void Agent::update(const float elapsedTime)
+void Agent::popState()
 {
-	mBehaviour->update(elapsedTime);
-    //  currentTime not needed yet, only elapsedTime
-    mVehicle->update(0.0f, elapsedTime);
+    mAgentStates.pop();
 }
 
-Creature* Agent::getControlledCreature() const
+AgentState* Agent::getCurrentState() const
 {
-    return mCreature;
+    if (mAgentStates.empty())
+    {
+        return NULL;
+    }
+    else
+    {
+        return mAgentStates.top();
+    }
 }
 
 }

Added: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,44 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "stdinc.h"
+
+#include "Agent.h"
+#include "AgentCombatState.h"
+#include "CreatureControllerManager.h"
+
+namespace rl
+{
+
+    AgentCombatState::AgentCombatState(Agent* agent)
+        : AgentState(agent),
+        Combatant(CreatureControllerManager::getSingleton().getCreatureController(
+            agent->getControlledCreature()))
+    {
+    }
+
+    AgentCombatState::~AgentCombatState()
+    {
+    }
+
+    Ogre::String AgentCombatState::getTypeName()
+    {
+        return "AgentCombatState";
+    }
+
+	void AgentCombatState::update(const float elapsedTime)
+    {
+    }
+}

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,11 +13,12 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
 #include "AgentManager.h"
+
 #include "Agent.h"
-#include "PlayerVehicle.h"
+#include "AgentCombatState.h"
 #include "Creature.h"
 #include "GameObjectManager.h"
 
@@ -27,20 +28,15 @@
 
 namespace rl {
 
-struct FindAgentByControlledCreature : public std::binary_function<Agent*, Creature*, bool>
-{
-    bool operator()(Agent* agent, Creature* creature) const
-    {
-        return agent->getControlledCreature() == creature;
-    }
-};
-
 AgentManager::AgentManager(void)
-    : mBehaviourFactory(NULL), mAllNeighbors(), mAgents(), mPlayer(NULL)
+    : mBehaviourFactory(NULL), mAgents(), mPlayer(NULL)
 {
     // Subscribe as listener to the GameObjectManager, in order to attach Agents to
     // Creatures that are placed into the scene.
     GameObjectManager::getSingleton().registerGameObjectStateListener(this);
+
+    // Register the AgentCombatStateFactory with the CombatManager, so that they can
+    // be created when a creature is taking part the combat.
 }
 
 AgentManager::~AgentManager(void)
@@ -49,66 +45,50 @@
 	removeAllAgents();
 }
 
-Agent* AgentManager::createAgent(AgentType type, Creature* character)
+Agent* AgentManager::createAgent(Creature* character)
 {
-	SteeringVehicle* vehicle = NULL;
-	if(type == AGENT_PLAYER)
-	{
-		vehicle = new PlayerVehicle(character);
-	}
-
-    Agent* agent = new Agent(character, vehicle);
-	agent->setType(type);
-	if(type == AGENT_PLAYER)
-	{
-		mPlayer = agent;
-	}
-
-
+    Agent* agent = new Agent(character);
 	addAgent(agent);
     return agent;
 }
 
 void AgentManager::destroyAgent(Agent* agent)
 {
-    AgentList::iterator it = std::find(mAgents.begin(), mAgents.end(), agent);
+    AgentMap::iterator it = mAgents.find(agent->getControlledCreature());
     if (it != mAgents.end())
     {
-        delete *it;
+        delete it->second;
         mAgents.erase(it);
     }
+    else
+    {
+        LOG_ERROR(Logger::AI, "AgentManager::destroyAgent: agent not found.");
+    }
 }
 
 void AgentManager::addAgent(Agent* agent)
 {
-	mAgents.push_back(agent);
-    LOG_MESSAGE(Logger::AI,
+    mAgents.insert(std::make_pair(agent->getControlledCreature(), agent));
+    LOG_MESSAGE(Logger::AI, 
         "created AI Agent");
-	mAllNeighbors.push_back(agent->getVehicle());
 }
 
-AgentManager::VehicleList AgentManager::getNeighbors(Agent* agent)
+void AgentManager::run( Ogre::Real elapsedTime ) 
 {
-	return mAllNeighbors;
-}
-
-void AgentManager::run( Ogre::Real elapsedTime )
-{
     //	update agents
-    for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
+    for(AgentMap::iterator it = mAgents.begin(); it != mAgents.end(); ++it)
     {
-	    (*itr)->update(elapsedTime);
+	    it->second->update(elapsedTime);
     }
 }
 
 void AgentManager::removeAllAgents()
 {
-    for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
+    for(AgentMap::iterator it = mAgents.begin(); it != mAgents.end(); ++it)
     {
-        delete (*itr);
+	    delete it->second;
     }
     mAgents.clear();
-    mAllNeighbors.clear();
     mPlayer = NULL;
 }
 
@@ -129,35 +109,34 @@
     if (oldState == GOS_IN_SCENE && newState != GOS_IN_SCENE)
     {
         // Remove the Agent and destroy it. Later we should pool them...
-        AgentList::iterator it = std::find_if(mAgents.begin(), mAgents.end(),
-            std::bind2nd(FindAgentByControlledCreature(), creature));
+        AgentMap::iterator it = mAgents.find(creature);
         if (it != mAgents.end())
         {
-            destroyAgent(*it);
+            destroyAgent(it->second);
         }
     }
     else if (newState == GOS_IN_SCENE)
     {
         // Create an Agent and add the behaviours of the creature to it.
-        Property behaviorProperty = creature->getProperty(Creature::PROPERTY_BEHAVIOURS);
-        if (behaviorProperty.isArray())
-        {
-            PropertyVector behaviors = behaviorProperty.toArray();
-            if (!behaviors.empty())
-            {
-                Agent* agent = createAgent(AGENT_STD_NPC, creature);
-                for (PropertyVector::const_iterator it = behaviors.begin(),
-                    end = behaviors.end(); it != end; ++it)
-                {
-                    if (it->isString())
-                    {
-                        SteeringBehaviour* behavior =
-                            mBehaviourFactory->createBehaviour(it->toString().c_str());
-                        agent->addSteeringBehaviour(behavior);
-                    }
-                }
-            }
-        }
+        Property aiProperty = creature->getProperty(Creature::PROPERTY_AI);
+        //if (behaviorProperty.isArray())
+        //{
+        //    PropertyVector behaviors = aiProperty.toArray();
+        //    if (!behaviors.empty())
+        //    {
+        //        Agent* agent = createAgent(creature);
+        //        for (PropertyVector::const_iterator it = behaviors.begin(),
+        //            end = behaviors.end(); it != end; ++it)
+        //        {
+        //            if (it->isString())
+        //            {
+        //                SteeringBehaviour* behavior =
+        //                    mBehaviourFactory->createBehaviour(it->toString().c_str());
+        //                agent->addSteeringBehaviour(behavior);
+        //            }
+        //        }
+        //    }
+        //}
     }
 }
 
@@ -166,4 +145,37 @@
     mBehaviourFactory = factory;
 }
 
+Combatant* AgentManager::createCombatant(Creature* creature)
+{
+    Agent* agent = NULL;
+    // Get agent from the creature.
+    AgentMap::iterator it = mAgents.find(creature);
+    if (it == mAgents.end())
+    {
+        // Create agent, since there is none yet.
+        agent = createAgent(creature);
+    }
+    else
+    {
+        agent = it->second;
+    }
+    // Put the Agent into combat state and return the state.
+    agent->pushState(AST_COMBAT);
+    Combatant* combatant = dynamic_cast<AgentCombatState*>(agent->getCurrentState());
+    return combatant;
 }
+
+void AgentManager::destroyCombatant(Combatant* combatant)
+{
+    // Get agent from combatant
+    AgentCombatState* combatState = dynamic_cast<AgentCombatState*>(combatant);
+    if (combatState == NULL)
+    {
+        Throw(IllegalArgumentException,
+            "Given combatant was not created by this Factory.(AgentManager)");
+    }
+    // Pop state
+    combatState->getAgent()->popState();
+}
+
+}

Added: rl/trunk/engine/ai/src/AgentSteeringState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,75 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "stdinc.h"
+
+#include "Agent.h"
+#include "AgentSteeringState.h"
+
+using namespace Ogre;
+using namespace OpenSteer;
+
+namespace rl {
+
+    AgentSteeringState::AgentSteeringState(Agent* agent)
+        : AgentState(agent),
+        mBehaviour(NULL),
+        mVehicle(NULL)
+    {
+        mVehicle = new SteeringVehicle(agent);
+
+        LOG_MESSAGE(Logger::AI, 
+            "created SteeringVehicle for Agent");
+
+        mBehaviour = new SteeringMachine(NULL, mVehicle);
+        LOG_MESSAGE(Logger::AI, 
+            "created SteeringMachine for Agent");
+    }
+
+    AgentSteeringState::~AgentSteeringState(void)
+    {
+        delete mVehicle;
+        delete mBehaviour;
+    }
+
+    void AgentSteeringState::addSteeringBehaviour(SteeringBehaviour* behaviour)
+    {
+        behaviour->setParent(mBehaviour);
+        behaviour->setController(mVehicle);
+        mBehaviour->addState(behaviour);
+        LOG_MESSAGE(Logger::AI, 
+            "added SteeringBehaviour for Agent");
+    }
+
+    void AgentSteeringState::clearSteeringBehaviours()
+    {
+        mBehaviour->clearStates();
+        LOG_MESSAGE(Logger::AI, 
+            "Cleared all SteeringBehaviours for Agent");
+    }
+
+    void AgentSteeringState::update(const float elapsedTime)
+    {
+        mBehaviour->update(elapsedTime);
+        //  currentTime not needed yet, only elapsedTime
+        mVehicle->update(0.0f, elapsedTime);
+    }
+
+    SteeringVehicle* AgentSteeringState::getVehicle()
+    {
+        return mVehicle;
+    }
+
+}

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -5,7 +5,9 @@
 libRlAi_la_LDFLAGS = $(OGRE_LIBS) $(LIBS)
 libRlAi_la_SOURCES = \
 	Agent.cpp \
+	AgentCombatState.cpp \
 	AgentManager.cpp \
+	AgentSteeringState.cpp \
 	AiSubsystem.cpp \
 	AiWorld.cpp \
 	AStarCosts.cpp \

Deleted: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,68 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-#include "stdinc.h" //precompiled header
-
-#include "PlayerVehicle.h"
-#include "Actor.h"
-#include "Creature.h"
-#include "MeshObject.h"
-#include "PhysicalThing.h"
-
-using namespace OpenSteer;
-using namespace Ogre;
-
-namespace rl {
-
-PlayerVehicle::PlayerVehicle(Creature* character)
-	: SteeringVehicle(NULL, character)
-{
-}
-
-PlayerVehicle::~PlayerVehicle(void)
-{
-}
-/*
-void PlayerVehicle::update(const float currentTime, const float elapsedTime)
-{
-	PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
-	OgreNewt::Body* body = NULL;
-	if(pt) pt->_getBody();
-	if(body)
-	{
-		Vector3 position;
-		Quaternion orientation;
-		body->getPositionOrientation(position, orientation);
-		setPosition(Vec3(position.x, position.y, position.z));
-
-	//  Get the velocity vector
-		mCurrentVelocity = body->getVelocity();
-	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
-	//  update speed
-		setSpeed(mCurrentVelocity.length());
-		Vec3 newVelocity(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);
-
-	//  regenerate local space (by default: align vehicle's forward axis with
-	//  new velocity, but this behavior may be overridden by derived classes.)
-		if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
-
-	//  prevent adding a counter force against gravity
-		if (mCurrentVelocity.y < 0.0f) mCurrentVelocity.y = 0.0f;
-	}
-	mCurrentForce = Ogre::Vector3::ZERO;
-}
-*/
-}

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,14 +13,16 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
 #include "SteeringVehicle.h"
+
 #include "AiSubsystem.h"
-#include "AiWorld.h"
+#include "AiWorld.h" 
 #include "Agent.h"
 #include "Actor.h"
 #include "Creature.h"
+#include "CreatureControllerManager.h"
 #include "MeshObject.h"
 #include "CreatureController.h"
 #include "PhysicalThing.h"
@@ -30,44 +32,30 @@
 
 namespace rl {
 
-SteeringVehicle::SteeringVehicle(Agent* parent, Creature* character)
+SteeringVehicle::SteeringVehicle(Agent* parent)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO),
+	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
 	  mParent(parent),
-	  mCreature(character),
-      mMovingCreature(NULL),
+	  mCreature(NULL),
+      mController(NULL),
       mDebugSteer(Vector3::ZERO),
       mDebugWander(Vector3::ZERO),
       mDebugAvoidObstacles(Vector3::ZERO)
 {
-	initialize();
+    mCreature = parent->getControlledCreature();
 
-    createMovingCreature();
+	initialize();
+    mController = CreatureControllerManager::getSingleton().getCreatureController(mCreature);
 }
 
 SteeringVehicle::~SteeringVehicle(void)
 {
-    destroyMovingCreature();
 }
 
-void SteeringVehicle::createMovingCreature()
-{
-    if( mMovingCreature == NULL )
-    {
-        mMovingCreature = new CreatureController(mCreature);
-    }
-}
-
-void SteeringVehicle::destroyMovingCreature()
-{
-    if( mMovingCreature != NULL )
-        delete mMovingCreature;
-}
-
 void SteeringVehicle::resetLocalSpace()
 {
 	setForward(Vec3(mForwardVector.x, mForwardVector.y, mForwardVector.z));
@@ -86,7 +74,7 @@
 {
     // reset LocalSpace state
 	resetLocalSpace();
-
+	
     // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();
 
@@ -122,7 +110,7 @@
     //  regenerate local space (by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
-    orientation = Quaternion(mMovingCreature->getYaw(), Ogre::Vector3::UNIT_Y);
+    orientation = Quaternion(mController->getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
     regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
 
@@ -131,13 +119,13 @@
 
 
     // only process if mMovingCreature not NULL
-    if( mMovingCreature == NULL )
+    if( mController == NULL )
     {
         mCurrentForce = Vector3::ZERO;
         return;
     }
-
-// calculate the result of the force
+    
+// calculate the result of the force    
     Vector3 result = mCurrentForce;// + mCurrentVelocity;
 
      mDebugSteer = mCurrentForce;
@@ -147,7 +135,7 @@
         mCreature->modifyAu(20,true);
 
 
-    AbstractMovement *mov_drehen = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
+    AbstractMovement *mov_drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
     Real vel_drehen(0);
     Radian max_drehen = Degree(0);
     if( mov_drehen->calculateBaseVelocity(vel_drehen) )
@@ -155,7 +143,7 @@
         max_drehen = Degree(vel_drehen * 360 * elapsedTime);
     }
 
-    Ogre::Quaternion future_orientation(mMovingCreature->getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Quaternion future_orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
     Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
     Radian yaw(0);
     creatureDirection.y = result.y = 0;
@@ -175,7 +163,7 @@
     }
 
 
-    mMovingCreature->setMovement(movement, direction, rotation);
+    mController->setMovement(movement, direction, rotation);
 
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
@@ -183,7 +171,7 @@
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
 	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
-
+	
     rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
 
     Vector3 steering(rVal.x, rVal.y, rVal.z);
@@ -207,9 +195,17 @@
 
 Vector3 SteeringVehicle::calcPursuit(Agent* agent)
 {
-	Vec3 rVal = steerForPursuit(*(agent->getVehicle())).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
-	return steering;
+    /// @todo Think up an OpenSteer compatible solution if this is none.
+    /// Not all Agents have a SteeringVehicle, so it is not possible to
+    /// to use steerForPursuit like this in all cases.
+	/// Vec3 rVal = steerForPursuit(*(agent->getVehicle())).setYtoZero();
+    /// So here is my naive solution without regarding
+    /// Just returning a direction vector on the xz-plane
+    /// towards the other agent.
+    Vector3 dir = agent->getControlledCreature()->getPosition() -
+        mParent->getControlledCreature()->getPosition();
+    dir.y = 0;
+	return dir;
 }
 
 Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
@@ -226,7 +222,7 @@
 	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
 	return Vector3(rVal.x, rVal.y, rVal.z);
 }
-
+		
 Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
 {
 	return Vector3();
@@ -234,7 +230,7 @@
 
 bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
 {
-	Vector3 target = agent->getVehicle()->getPosition();
+    Vector3 target = agent->getControlledCreature()->getPosition();
 	//target.y = position.y;
 	return (SimpleVehicle_2::isAhead(Vec3(target.x, target.y, target.z), threshold));
 }
@@ -252,15 +248,15 @@
 AVGroup SteeringVehicle::getNeighbors() const
 {
 	AVGroup group;
-	AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	AgentManager::VehicleList::const_iterator itr = list.begin();
-	for(; itr != list.end(); ++itr)
-	{
-		if( (*itr) != this )
-		{
-			group.push_back( (*itr) );
-		}
-	}
+	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
+	//AgentManager::VehicleList::const_iterator itr = list.begin();
+	//for(; itr != list.end(); ++itr)
+	//{
+	//	if( (*itr) != this )
+	//	{
+	//		group.push_back( (*itr) );
+	//	}
+	//}
 	return group;
 }
 
@@ -275,75 +271,75 @@
 	return Vector3(position().x, position().y, position().z);
 }
 
-float SteeringVehicle::mass (void) const
+float SteeringVehicle::mass (void) const 
 {
     return mCreature->getActor()->getPhysicalThing()->getMass();
 }
 
-float SteeringVehicle::setMass (float m)
+float SteeringVehicle::setMass (float m) 
 {
 	// don't set mass here TODO: throw exception
 
 	return 1;
-}
+} 
 
-float SteeringVehicle::speed (void) const
+float SteeringVehicle::speed (void) const 
 {
 	return mSpeed;
 }
 
-float SteeringVehicle::setSpeed (float s)
+float SteeringVehicle::setSpeed (float s) 
 {
 	return mSpeed = s;
 }
 
-float SteeringVehicle::radius (void) const
+float SteeringVehicle::radius (void) const 
 {
 	// this is only the radius in x axis, but i think, this is the value that should be used here
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
     return (aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
-float SteeringVehicle::setRadius (float m)
+float SteeringVehicle::setRadius (float m) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-float SteeringVehicle::height (void) const
+float SteeringVehicle::height (void) const 
 {
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
     return aab.getMaximum().y - aab.getMinimum().y;
 }
 
-float SteeringVehicle::setHeight (float h)
+float SteeringVehicle::setHeight (float h) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-const Actor* SteeringVehicle::getActor(void) const
-{
-	return mCreature->getActor();
+const Actor* SteeringVehicle::getActor(void) const  
+{ 
+	return mCreature->getActor(); 
 }
 
-float SteeringVehicle::maxForce (void) const
+float SteeringVehicle::maxForce (void) const 
 {
 	return 10000.0f;
-}
+} 
 
-float SteeringVehicle::setMaxForce (float mf)
+float SteeringVehicle::setMaxForce (float mf) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxForce = mf;
 }
 
-float SteeringVehicle::maxSpeed (void) const
+float SteeringVehicle::maxSpeed (void) const 
 {
-	return 100000;
+	return 100000; 
 }
 
-float SteeringVehicle::setMaxSpeed (float ms)
+float SteeringVehicle::setMaxSpeed (float ms) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxSpeed = ms;
@@ -396,7 +392,7 @@
 
     LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
     lineSet->clear();
-
+    
     if(mDebugSteer != Vector3::ZERO)
     {
         lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-08-07 21:20:27 UTC (rev 3674)
@@ -303,6 +303,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\Combatant.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\CombatManager.cpp"
 				>
 			</File>
@@ -513,6 +517,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\Combatant.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\CombatManager.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Combat.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -23,29 +23,29 @@
 
 namespace rl
 {
-    class Creature;
+    class Combatant;
 
     class _RlRulesExport Combat
     {
     public:
-        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<Combatant*> CombatantSet;
 
-        Combat(Creature* character);
+        Combat(Combatant* character);
         ~Combat();
 
-        void addOpponent(Creature*);
-        void removeOpponent(Creature*);
+        void addOpponent(Combatant*);
+        void removeOpponent(Combatant*);
 
-        void addAlly(Creature*);
-        void removeAlly(Creature*);
+        void addAlly(Combatant*);
+        void removeAlly(Combatant*);
 
-        const CreatureSet& getAllOpponents() const;
-        const CreatureSet& getAllAllies() const;
+        const CombatantSet& getAllOpponents() const;
+        const CombatantSet& getAllAllies() const;
 
     private:
-        Creature* mCharacter;
-        CreatureSet mOpponents;
-        CreatureSet mAllies;
+        Combatant* mCharacter;
+        CombatantSet mOpponents;
+        CombatantSet mAllies;
     };
 }
 

Modified: rl/trunk/engine/rules/include/CombatManager.h
===================================================================
--- rl/trunk/engine/rules/include/CombatManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CombatManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -21,9 +21,13 @@
 
 #include <OgreSingleton.h>
 
+#include <map>
+
 namespace rl
 {
 	class Combat;
+    class Combatant;
+    class CombatantFactory;
     class Creature;
 	
     class _RlRulesExport CombatManager : public Ogre::Singleton<CombatManager>
@@ -36,12 +40,27 @@
         /// @param character the player character
         /// @param firstOpponent the opponent, that caused the combat.
         /// @throw IllegalStateException if there is already a combat running.
-        Combat* startCombat(Creature* character, Creature* firstOpponent);
+        Combat* startCombat(Combatant* character, Combatant* firstOpponent);
 
         /// Return the combat currently running, NULL if there is none.
         Combat* getCurrentCombat() const;
 
+        /// Returns a Combatant instance for the given Creature with the given name.
+        /// If no name is given, the default Creature-Combatant is chosen, which is
+        /// the default one registered by RlAi.
+        /// Caller is resonsible for calling destroyCombatant in order to
+        /// All undestroyed instances are destroyed when CombatManager is destroyed.
+        /// @param creature Creature to create a Combatant for
+        /// @param combatantType Name of the type to be used.
+        Combatant* createCombatant(Creature* creature, const Ogre::String& combatantType = "default");
+        void destroyCombatant(Combatant* combatant);
+
+        void registerCombatantFactory(const Ogre::String& name, CombatantFactory* factory);
+        void unregisterCombatantFactory(CombatantFactory* factory);
+
     private:
+        typedef std::map<Ogre::String, CombatantFactory*> CombatantFactoryMap;
+        CombatantFactoryMap mCombatantFactories;
         Combat* mCurrentCombat;
     };
 }

Added: rl/trunk/engine/rules/include/Combatant.h
===================================================================
--- rl/trunk/engine/rules/include/Combatant.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Combatant.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include "RulesPrerequisites.h"
+
+namespace rl
+{
+    class Creature;
+    class CreatureController;
+
+    class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(CreatureController* controller);
+        virtual ~Combatant();
+
+        virtual Ogre::String getTypeName() = 0;
+
+        CreatureController* getCreatureController() const;
+
+    protected:
+        CreatureController* mController;
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -107,7 +107,7 @@
             typedef std::map<const CeGuiString, int> TalentMap;
 
             static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_BEHAVIOURS;
+            static const Ogre::String PROPERTY_AI;
 			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
             static const Ogre::String PROPERTY_CURRENT_LE;
             static const Ogre::String PROPERTY_CURRENT_AE;
@@ -779,7 +779,7 @@
             Inventory* mInventory;
             Ogre::String mInventoryWindowType;
 
-            Property mBehaviours;
+            Property mAiProperties;
 
             Alignment mAlignment;
 

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -61,7 +61,7 @@
         /// Newton contact callback called by the movingCreatureManager
         int userProcess();
 
-        Creature *getCreature() {return mCreature;}
+        Creature* getCreature() {return mCreature;}
 
         /** 
          * the different movements a creature can perform, 

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -30,6 +30,10 @@
 {
     class CreatureController;
 
+    /// This class manages CreatureControllers, which provide an API for moving the creature
+    /// around in the scene.
+    /// CreatureControllers are created on demand and a reference is kept here, so that no more
+    /// than one CreatureController is created per Creature.
     class _RlRulesExport CreatureControllerManager : 
         public GameTask,
         public Ogre::Singleton<CreatureControllerManager>,
@@ -39,45 +43,27 @@
         CreatureControllerManager();
         ~CreatureControllerManager();
 
-        /**
-         * adds a new movingCreature, this function is not intended to be used directly; 
-         * each CreatureController is automatically added. a creature is always added in a
-         * idle state
-         */
-        void add(CreatureController *movingCreature);
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        CreatureController* getCreatureController(Creature* creature);
 
-        /**
-         * removes a movingCreature, this function is not intended to be used directly, 
-         * destroy the movingCreature instead.
-         */
-        void remove(CreatureController *movingCreature);
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(Creature* creature);
 
         void run(Ogre::Real elapsedTime);
 
-        /**
-         * Sets a movingCreature in an active state, this means that it is updated every
-         * frame. This must be the case, if the creature is moving. If a creature is in an
-         * idle state, it is only updated less often
-         */
-        void setActive(CreatureController* movingCreature);
+        // override from GameTask
+        const Ogre::String& getName() const;
 
-        const Ogre::String & getName() const {return mName;}
-
         // Newton Contact Callback
         int userProcess();
     protected:
-        typedef std::vector<CreatureController*> MovingCreatureVector;
-        MovingCreatureVector mActiveCreatures;
-        MovingCreatureVector mIdleCreatures;
-        MovingCreatureVector mAddToActiveCreatures;
-        Ogre::Real mUpdateIdleTime;
-        Ogre::Real mTimeSinceLastIdleUpdate;
-        Ogre::String mName;
+        typedef std::map<Creature*, CreatureController*> ControllerMap;
+        ControllerMap mControllers;
 
-        typedef std::map<OgreNewt::Body*,CreatureController*> MovingCreatureBodyMap;
-        MovingCreatureBodyMap mMovingCreatureFromBody;
+        typedef std::map<OgreNewt::Body*, CreatureController*> BodyControllerMap;
+        BodyControllerMap mBodyControllers;
     };
 }
-
-
 #endif

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -3,6 +3,7 @@
 	ActionManager.h \
 	Armor.h \
 	Combat.h \
+	Combatant.h \
 	CombatManager.h \
 	Container.h \
 	Creature.h \

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Combat.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,13 +13,13 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
 #include "Combat.h"
 
 namespace rl
 {
-    Combat::Combat(Creature* character) : mCharacter(character)
+    Combat::Combat(Combatant* character) : mCharacter(character)
     {
     }
 
@@ -27,32 +27,32 @@
     {
     }
 
-    void Combat::addOpponent(Creature* creature)
+    void Combat::addOpponent(Combatant* Combatant)
     {
-        mOpponents.insert(creature);
+        mOpponents.insert(Combatant);
     }
 
-    void Combat::removeOpponent(Creature* creature)
+    void Combat::removeOpponent(Combatant* Combatant)
     {
-        mOpponents.erase(creature);
+        mOpponents.erase(Combatant);
     }
 
-    void Combat::addAlly(Creature* creature)
+    void Combat::addAlly(Combatant* Combatant)
     {
-        mAllies.insert(creature);
+        mAllies.insert(Combatant);
     }
 
-    void Combat::removeAlly(Creature* creature)
+    void Combat::removeAlly(Combatant* Combatant)
     {
-        mAllies.erase(creature);
+        mAllies.erase(Combatant);
     }
 
-    const Combat::CreatureSet& Combat::getAllOpponents() const
+    const Combat::CombatantSet& Combat::getAllOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CreatureSet& Combat::getAllAllies() const
+    const Combat::CombatantSet& Combat::getAllAllies() const
     {
         return mAllies;
     }

Modified: rl/trunk/engine/rules/src/CombatManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
+* 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,12 +13,12 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
-
 #include "CombatManager.h"
 
 #include "Combat.h"
+#include "Combatant.h"
 #include "Exception.h"
 
 using namespace Ogre;
@@ -36,7 +36,7 @@
     {
     }
 
-    Combat* CombatManager::startCombat(Creature* character, Creature* firstOpponent)
+    Combat* CombatManager::startCombat(Combatant* character, Combatant* firstOpponent)
     {
         if (mCurrentCombat != NULL)
         {
@@ -53,4 +53,29 @@
     {
         return mCurrentCombat;
     }
+
+    Combatant* CombatManager::createCombatant(Creature* creature, const String& combatantType)
+    {
+        CombatantFactoryMap::iterator it = mCombatantFactories.find(combatantType);
+        if (it != mCombatantFactories.end())
+        {
+            return it->second->createCombatant(creature);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "No such CombatantType registered: " + combatantType);
+        }
+    }
+
+    void CombatManager::destroyCombatant(Combatant* combatant)
+    {
+    }
+
+    void CombatManager::registerCombatantFactory(const String& name, CombatantFactory* factory)
+    {
+    }
+
+    void CombatManager::unregisterCombatantFactory(CombatantFactory* factory)
+    {
+    }
 }

Added: rl/trunk/engine/rules/src/Combatant.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combatant.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Combatant.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "Combatant.h"
+
+namespace rl
+{
+    Combatant::Combatant(CreatureController* controller) : mController(controller)
+    {
+    }
+
+    Combatant::~Combatant()
+    {
+    }
+
+    CreatureController* Combatant::getCreatureController() const
+    {
+        return mController;
+    }
+}

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -40,7 +40,7 @@
 {
     const Ogre::String Creature::CLASS_NAME = "Creature";
 
-    const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
+    const Ogre::String Creature::PROPERTY_AI = "ai";
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
     const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
     const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
@@ -953,9 +953,9 @@
 
     void Creature::setProperty(const Ogre::String &key, const rl::Property &value)
     {
-        if (key == Creature::PROPERTY_BEHAVIOURS)
+        if (key == Creature::PROPERTY_AI)
         {
-            mBehaviours = value;
+            mAiProperties = value;
         }
         else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
         {
@@ -1033,9 +1033,9 @@
 
     const Property Creature::getProperty(const Ogre::String &key) const
     {
-        if (key == Creature::PROPERTY_BEHAVIOURS)
+        if (key == Creature::PROPERTY_AI)
         {
-            return mBehaviours;
+            return mAiProperties;
         }
         else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
         {
@@ -1112,7 +1112,7 @@
     PropertySet* Creature::getAllProperties() const
     {
         PropertySet* ps = GameObject::getAllProperties();
-        ps->setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
+        ps->setProperty(Creature::PROPERTY_AI, mAiProperties);
         ps->setProperty(Creature::PROPERTY_INVENTORY_WINDOW_TYPE, Property(mInventoryWindowType));
         ps->setProperty(Creature::PROPERTY_CURRENT_LE, getProperty(Creature::PROPERTY_CURRENT_LE));
         ps->setProperty(Creature::PROPERTY_CURRENT_AE, getProperty(Creature::PROPERTY_CURRENT_AE));

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1141,8 +1141,6 @@
         mStillWeightedAnimationName(""),
         mLastFloorContact(TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_INTERRUPTABLE)->getClock())
     {
-        CreatureControllerManager::getSingleton().add(this);
-
         mOldMaterialId = mCreature->getActor()->getPhysicalThing()->_getBody()->getMaterialGroupID();
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
         mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
@@ -1202,7 +1200,6 @@
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
 
         mCreature->getActor()->getPhysicalThing()->setMaterialID(mOldMaterialId);
-        CreatureControllerManager::getSingleton().remove(this);
     }
 
     CreatureController::MovementType CreatureController::getMovementId() const
@@ -1410,7 +1407,10 @@
 
         if(mMovement != NULL)
         {
-            // i hope this will copy the protected members of the contact callback
+            // @XXX Evil code!
+            // Protected members from type OgreNewt::ContactCallback have to be overridden in order
+            // for the movements to work. This is because these members are used by OgreNewt functions
+            // for processing this contact. Should probably be solved in OgreNewt directly.
             OgreNewt::ContactCallback *movement = mMovement;
             *movement = (OgreNewt::ContactCallback)(*this);
             return movement->userProcess();
@@ -1437,7 +1437,6 @@
         {
             if( mMovement->getId() == type )
             {
-                CreatureControllerManager::getSingleton().setActive(this);
                 mDirection = direction;
                 mRotation = rotation;
                 return true;
@@ -1455,12 +1454,11 @@
 
         AbstractMovement *movement = getMovementFromId(type);
 
-
         while(movement != NULL)
         {
             if(movement->isPossible())
             {
-                CreatureControllerManager::getSingleton().setActive(this); // runs the old movement if idle!
+                // runs the old movement if idle!
                 if(mMovement == NULL)
                 {
                     mLastMovementType = MT_NONE;

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -25,22 +25,19 @@
 
 
 using namespace Ogre;
-using namespace std;
 
-
 template<> rl::CreatureControllerManager* Singleton<rl::CreatureControllerManager>::ms_Singleton = 0;
 
 
 namespace rl
 {
     CreatureControllerManager::CreatureControllerManager() :
-            mUpdateIdleTime(1.0f),
-            mTimeSinceLastIdleUpdate(0.0f),
-            mName("CreatureControllerManager")
+            mControllers(),
+            mBodyControllers()
     {
         GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
 
-        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
+        PhysicsManager* physicsManager = PhysicsManager::getSingletonPtr();
         // the material of moving creatures
         const OgreNewt::MaterialID *char_mat = physicsManager->createMaterialID("character");
 
@@ -66,163 +63,88 @@
         GameLoop::getSingleton().removeTask(this);
     }
 
-    void CreatureControllerManager::add(CreatureController *movingCreature)
+    CreatureController* CreatureControllerManager::getCreatureController(Creature* creature)
     {
-        if(movingCreature == NULL)
+        // valid Creature is needed as argument
+        if (creature == NULL)
         {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
+            Throw(NullPointerException, "Argument creature darf nicht NULL sein.");
         }
 
-        MovingCreatureVector::const_iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+        CreatureController* rval = NULL;
+
+        // do we have a controller attached to this creature?
+        ControllerMap::const_iterator it = mControllers.find(creature);
+        if ( it == mControllers.end())
         {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, "CreatureController wird schon vom CreatureControllerManager verwaltet.");
-            }
+            // No, so create one and put it into the map.
+            rval = new CreatureController(creature);
+            mControllers.insert(std::make_pair(creature, rval));
+            mBodyControllers.insert(std::make_pair(
+                creature->getActor()->getPhysicalThing()->_getBody(), rval));
         }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
+        else
         {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, "CreatureController wird schon vom CreatureControllerManager verwaltet.");
-            }
+            rval = it->second;
         }
 
-        mMovingCreatureFromBody.insert(make_pair(
-            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody(),
-            movingCreature));
-        mIdleCreatures.push_back(movingCreature);
+        return rval;
     }
 
 
-    void CreatureControllerManager::remove(CreatureController *movingCreature)
+    void CreatureControllerManager::detachController(Creature* creature)
     {
-        if(movingCreature == NULL)
+        if( creature == NULL)
         {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
+            Throw(NullPointerException, "Argument creature darf nicht NULL sein.");
         }
 
-        MovingCreatureBodyMap::iterator body_iter = mMovingCreatureFromBody.find(
-            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody());
-
-        if( body_iter == mMovingCreatureFromBody.end() )
+        mControllers.find(creature);
+        ControllerMap::iterator it = mControllers.find(creature);
+        if (it == mControllers.end())
         {
-            Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
+            delete it->second;
+            mControllers.erase(it);
         }
 
-        mMovingCreatureFromBody.erase(body_iter);
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mIdleCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mActiveCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mAddToActiveCreatures.begin(); iter != mAddToActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mAddToActiveCreatures.erase(iter);
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
+        mBodyControllers.erase(creature->getActor()->getPhysicalThing()->_getBody());
     }
 
     void CreatureControllerManager::run(Real elapsedTime)
     {
-        mTimeSinceLastIdleUpdate += elapsedTime;
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter ++)
+        for (ControllerMap::iterator it = mControllers.begin(); it != mControllers.end(); ++it)
         {
-            (*iter)->run(elapsedTime);
+            it->second->run(elapsedTime);
         }
-
-        if( mTimeSinceLastIdleUpdate >= mUpdateIdleTime )
-        {
-            for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-            {
-                (*iter)->run(mTimeSinceLastIdleUpdate);
-            }
-            mTimeSinceLastIdleUpdate = 0.0f;
-        }
     }
 
-
-    void CreatureControllerManager::setActive(CreatureController* movingCreature)
+    int CreatureControllerManager::userProcess()
     {
-        if(movingCreature == NULL)
+        BodyControllerMap::iterator it = mBodyControllers.find(m_body0);
+        if (it == mBodyControllers.end())
         {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
-        }
+            it = mBodyControllers.find(m_body1);
 
-        // we cannot simply add the item to the other list, since it needs to be updated first!!
-        // i hope there are no errors, if this update is not at the proposed time in the game loop
-        // since it is not executed with the other runs!!!
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
+            if (it == mBodyControllers.end())
             {
-                movingCreature->run(mTimeSinceLastIdleUpdate);
-
-                mActiveCreatures.push_back(movingCreature);
-                mIdleCreatures.erase(iter);
-                return;
+                LOG_ERROR(Logger::RULES,
+                    "Der Kollisionsk?rper konnte keiner Creature zugeordner werden.");
+                return 1;
             }
         }
 
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
-            {
-                LOG_DEBUG(Logger::RULES, "Die angegebene CreatureController ist schon aktiv.");
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
+        // @XXX Evil code!
+        // Protected members from type OgreNewt::ContactCallback have to be overridden in order
+        // for the controllers to work. This is because these members are used by OgreNewt functions
+        // for processing this contact. Should probably be solved in OgreNewt directly.
+        OgreNewt::ContactCallback* controller = it->second;
+        *controller = (OgreNewt::ContactCallback)(*this);
+        return controller->userProcess();
     }
 
-
-    int CreatureControllerManager::userProcess()
+    const Ogre::String& CreatureControllerManager::getName() const
     {
-        MovingCreatureBodyMap::iterator iter;
-        iter = mMovingCreatureFromBody.find(m_body0);
-
-        if( iter == mMovingCreatureFromBody.end() )
-        {
-            iter = mMovingCreatureFromBody.find(m_body1);
-
-            if( iter == mMovingCreatureFromBody.end() )
-            {
-                LOG_ERROR(Logger::RULES, "Der Kollisionsk?rper konnte keiner Creature zugeordner werden.");
-                return 1;
-            }
-        }
-
-        // i hope this will copy the protected members of the contact callback
-        OgreNewt::ContactCallback *movingCreature = iter->second;
-        *movingCreature = (OgreNewt::ContactCallback)(*this);
-        return movingCreature->userProcess();
+        static String name = "CreatureControllerManager";
+        return name;
     }
-}
+ }

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -7,6 +7,7 @@
 	ActionManager.cpp \
 	Armor.cpp \
 	Combat.cpp \
+	Combatant.cpp \
 	CombatManager.cpp \
 	Container.cpp \
 	Creature.cpp \

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-07 21:20:27 UTC (rev 3674)
@@ -29,7 +29,7 @@
 	class SteeringVehicle
 	{
 	public:
-		SteeringVehicle(rl::Agent* agent, rl::Creature* character);
+		SteeringVehicle(rl::Agent* agent);
 		
 		void addForce(const Ogre::Vector3& force);
 
@@ -82,8 +82,7 @@
 	public:
 		Agent(rl::Creature* character);
 		virtual ~Agent();
-		void addSteeringBehaviour(rl::SteeringBehaviour* behaviour);
-		void clearSteeringBehaviours();
+        rl::Creature* getControlledCreature() const;
 	};
 	class AiSubsystem 
 	{
@@ -103,17 +102,9 @@
     
 	class AgentManager
 	{
-	public:
-		enum AgentType
-		{
-			AGENT_NONE = -1,
-			AGENT_PLAYER = 0,
-			AGENT_STD_NPC = 1,
-			AGENT_FLOCKING = 2
-		};
-		
+	public:		
 		static AgentManager& getSingleton(void);
-		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
+		rl::Agent* createAgent(rl::Creature* character);
 		
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -20,6 +20,7 @@
 #include "UiPrerequisites.h"
 
 #include "ControlState.h"
+#include "Combatant.h"
 #include "Selector.h"
 
 #include <OgreRectangle.h>
@@ -31,7 +32,7 @@
     class CombatManager;
     class CombatWindow;
 
-	class _RlUiExport CombatControlState : public ControlState
+	class _RlUiExport CombatControlState : public ControlState, public Combatant
 	{
 	public:
 		/**
@@ -45,6 +46,9 @@
 
 		void run(Ogre::Real elapsedTime);
 
+        // Combatant override
+        virtual Ogre::String getTypeName();
+
     private:
         CombatManager* mCombatManager;
         // Current combat that is controlled.

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -85,7 +85,7 @@
 
     protected:
         virtual void doCreatePrimitive();
-        CreatureController *mMovingCreature;
+        CreatureController* mController;
 
     private:
 

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -13,7 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
-#include "stdinc.h" //precompiled header
+#include "stdinc.h"
 
 #include "CombatControlState.h"
 
@@ -24,6 +24,8 @@
 #include "CombatWindow.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
 #include "InputManager.h"
 #include "MeshObject.h"
 #include "Person.h"
@@ -39,6 +41,7 @@
     CombatControlState::CombatControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_COMBAT),
+          Combatant(CreatureControllerManager::getSingleton().getCreatureController(character)),
           mCombatManager(CombatManager::getSingletonPtr()),
           mCombat(NULL),
           mCombatWindow(NULL),
@@ -97,12 +100,15 @@
             const Selector::GameObjectVector& enemies = mEnemySelector.getAllSelectedObjects();
             if (!enemies.empty())
             {
+                Combatant* firstOpponent = mCombatManager->createCombatant(
+                    static_cast<Creature*>(enemies[0]));
                 // There are enemies in vicinity, so start a new combat and set it up properly.
-                mCombat = mCombatManager->startCombat(mCharacter,
-                    static_cast<Creature*>(enemies[0]));
+                mCombat = mCombatManager->startCombat(this, firstOpponent);
                 for (size_t i = 1; i < enemies.size(); ++i)
                 {
-                    mCombat->addOpponent(static_cast<Creature*>(enemies[i]));
+                    Combatant* opponent = mCombatManager->createCombatant(
+                        static_cast<Creature*>(enemies[i]));
+                    mCombat->addOpponent(opponent);
                 }
             }
             else
@@ -133,12 +139,13 @@
         mHud->clear();
 
         mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_LINE_STRIP);
-        const Combat::CreatureSet& opponents = mCombat->getAllOpponents();
-        for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();
+        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
             Ogre::Rectangle rec = getScreenRectFromWorldAABB(
-                (*it)->getActor()->_getSceneNode()->_getWorldAABB());
+                (*it)->getCreatureController()->getCreature()->getActor()
+                    ->_getSceneNode()->_getWorldAABB());
             mHud->position(rec.left,  rec.top,    0.0f);
             mHud->position(rec.left,  rec.bottom, 0.0f);
             mHud->position(rec.right, rec.top,    0.0f);
@@ -175,4 +182,9 @@
         Ogre::Rectangle rval = {left,top, right, bottom};
         return rval;
     }
+
+    Ogre::String CombatControlState::getTypeName()
+    {
+        return "CombatControlState";
+    }
 }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -35,6 +35,7 @@
 #include "ConfigurationManager.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
+#include "CreatureControllerManager.h"
 #include "DebugWindow.h"
 #include "Exception.h"
 #include "InputManager.h"
@@ -70,7 +71,7 @@
     MovementControlState::MovementControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mMovingCreature(NULL),
+        mController(NULL),
         mCharacterState(),
         mDesiredDistance(2.00),
         mDistanceRange(0.60, 7.00),
@@ -156,11 +157,7 @@
     //------------------------------------------------------------------------
     void MovementControlState::pause()
     {
-        if( mMovingCreature != NULL )
-        {
-            delete mMovingCreature;
-            mMovingCreature = NULL;
-        }
+        mController = NULL;
 
         // actors aren't controlled anymore
         //mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
@@ -189,8 +186,11 @@
     //------------------------------------------------------------------------
     void MovementControlState::resume()
     {
-        if( mMovingCreature == NULL )
-            mMovingCreature = new CreatureController(mCharacter);
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -292,12 +292,12 @@
     void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
-        if( mMovingCreature != NULL )
+        if( mController != NULL )
         {
             int movement = mCharacterState.mCurrentMovementState;
             Degree rotation(0);
 
-            AbstractMovement *drehen = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
+            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
             Real baseVelocity = 0;
             if( drehen->calculateBaseVelocity(baseVelocity) )
             {
@@ -345,13 +345,13 @@
                     direction.z = -1;
                 else if( movement & MOVE_BACKWARD)
                     direction.z = 1;
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     CreatureController::MT_SCHLEICHEN,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else if( movement & MOVE_JUMP && 
-                mMovingCreature->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
+                mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
             {
                 CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
                 Vector3 direction = Vector3::UNIT_Y;
@@ -360,7 +360,7 @@
                     type = CreatureController::MT_WEITSPRUNG;
                     direction += Vector3::NEGATIVE_UNIT_Z;
                 }
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     type,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -382,7 +382,7 @@
                     else
                         type = CreatureController::MT_JOGGEN;
                 }
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     type,
                     Vector3(0,0,-1), 
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -392,7 +392,7 @@
                 CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
                 if( !(movement & MOVE_RUN) )
                     type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     type,
                     Vector3(0,0,1), 
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -402,14 +402,14 @@
                 Vector3 direction = Vector3::UNIT_X;
                 if( movement & MOVE_LEFT )
                     direction = Vector3::NEGATIVE_UNIT_X;
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     CreatureController::MT_SEITWAERTS_GEHEN,
                     direction, 
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else
             {
-                mMovingCreature->setMovement(
+                mController->setMovement(
                     CreatureController::MT_STEHEN, 
                     Vector3(0,0,0),
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -548,16 +548,14 @@
         mCamBody->getPositionOrientation(bodpos,egal);
         ss
             << "scene node : " << playpos << std::endl
-            << "player velocity : " << -mMovingCreature->getVelocity().z << std::endl
-            << "player orientation : " << mMovingCreature->getCreature()->getActor()->getOrientation() << std::endl
+            << "player velocity : " << -mController->getVelocity().z << std::endl
+            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
             << "camera posder : " << static_cast<Camera*>(
                 mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-//                << "camera pos : " << static_cast<Camera*>(
-//                    mCameraActor->_getMovableObject())->getPosition() << std::endl
             << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
             << "camera pos : " << bodpos << std::endl
             << "camera distance : " << mDesiredDistance << std::endl
-            << "is airborne: " << (mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
+            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());



From tanis at mail.berlios.de  Tue Aug  7 23:22:52 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 7 Aug 2007 23:22:52 +0200
Subject: [Dsa-hl-svn] r3675 - modules/combattest/dsa
Message-ID: <200708072122.l77LMqM8023341@sheep.berlios.de>

Author: tanis
Date: 2007-08-07 23:22:49 +0200 (Tue, 07 Aug 2007)
New Revision: 3675

Modified:
   modules/combattest/dsa/gameobjectdefinitions.gof
Log:
reorganised AI components of a creature. There is a atop-level ai property map, which has all other ai related properties as childs.

Modified: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-08-07 21:20:27 UTC (rev 3674)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-08-07 21:22:49 UTC (rev 3675)
@@ -9,9 +9,11 @@
     <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
     <property name="mass" type="REAL" data="30"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
-    <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="DefaultWanderBehaviour"/>
-    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
+    <property name="ai" type="MAP">
+        <property name="behaviours" type="ARRAY">
+    	    <property type="STRING" data="DefaultWanderBehaviour"/>
+    	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
+        </property>
     </property>
   </gameobjectclass>
   



From tanis at mail.berlios.de  Wed Aug  8 21:02:50 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 8 Aug 2007 21:02:50 +0200
Subject: [Dsa-hl-svn] r3676 - rl/trunk/engine/ai/src
Message-ID: <200708081902.l78J2oEv011576@sheep.berlios.de>

Author: tanis
Date: 2007-08-08 21:02:48 +0200 (Wed, 08 Aug 2007)
New Revision: 3676

Modified:
   rl/trunk/engine/ai/src/Agent.cpp
Log:
Agent now properly notifies its current state about a frame update.

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-07 21:22:49 UTC (rev 3675)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-08 19:02:48 UTC (rev 3676)
@@ -56,6 +56,10 @@
 
 void Agent::update(const float elapsedTime)
 {
+    if (!mAgentStates.empty())
+    {
+        mAgentStates.top()->update(elapsedTime);
+    }
 }
 
 Creature* Agent::getControlledCreature() const



From tanis at mail.berlios.de  Wed Aug  8 21:34:03 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 8 Aug 2007 21:34:03 +0200
Subject: [Dsa-hl-svn] r3677 - in rl/trunk/engine: ai/include ai/src
	rules/include rules/src ui/include ui/src
Message-ID: <200708081934.l78JY31M013085@sheep.berlios.de>

Author: tanis
Date: 2007-08-08 21:33:50 +0200 (Wed, 08 Aug 2007)
New Revision: 3677

Modified:
   rl/trunk/engine/ai/include/AgentCombatState.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/rules/include/Combatant.h
   rl/trunk/engine/rules/src/CombatManager.cpp
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
Log:
Fixed combat too now so that it works with new AgentStates. ("Works" as in "Does not crash right away")

Modified: rl/trunk/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-08 19:33:50 UTC (rev 3677)
@@ -34,7 +34,7 @@
 
         virtual ~AgentCombatState();
 
-        virtual Ogre::String getTypeName();
+        virtual Ogre::String getCombatantTypeName() const;
 
 		/** Function invoked by Agents to advance the AI.
 		 * Decision making is done here.

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-08 19:33:50 UTC (rev 3677)
@@ -18,6 +18,7 @@
 #include "Agent.h"
 
 #include "Actor.h"
+#include "AgentCombatState.h"
 #include "AgentSteeringState.h"
 #include "Creature.h"
 #include "DialogCharacter.h"
@@ -76,6 +77,7 @@
     }
     else if (stateType == AST_COMBAT)
     {
+        state = new AgentCombatState(this);
     }
     else if (stateType == AST_DIALOG)
     {

Modified: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-08 19:33:50 UTC (rev 3677)
@@ -33,9 +33,9 @@
     {
     }
 
-    Ogre::String AgentCombatState::getTypeName()
+    Ogre::String AgentCombatState::getCombatantTypeName() const
     {
-        return "AgentCombatState";
+        return "default";
     }
 
 	void AgentCombatState::update(const float elapsedTime)

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-08 19:33:50 UTC (rev 3677)
@@ -19,6 +19,7 @@
 
 #include "Agent.h"
 #include "AgentCombatState.h"
+#include "CombatManager.h"
 #include "Creature.h"
 #include "GameObjectManager.h"
 
@@ -35,8 +36,9 @@
     // Creatures that are placed into the scene.
     GameObjectManager::getSingleton().registerGameObjectStateListener(this);
 
-    // Register the AgentCombatStateFactory with the CombatManager, so that they can
-    // be created when a creature is taking part the combat.
+    // Register self as CombatantFactory with the CombatManager, so that State is switched
+    // when agent is taking part in a combat.
+    CombatManager::getSingleton().registerCombatantFactory("default", this);
 }
 
 AgentManager::~AgentManager(void)

Modified: rl/trunk/engine/rules/include/Combatant.h
===================================================================
--- rl/trunk/engine/rules/include/Combatant.h	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/rules/include/Combatant.h	2007-08-08 19:33:50 UTC (rev 3677)
@@ -30,7 +30,7 @@
         Combatant(CreatureController* controller);
         virtual ~Combatant();
 
-        virtual Ogre::String getTypeName() = 0;
+        virtual Ogre::String getCombatantTypeName() const = 0;
 
         CreatureController* getCreatureController() const;
 

Modified: rl/trunk/engine/rules/src/CombatManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-08 19:33:50 UTC (rev 3677)
@@ -69,13 +69,34 @@
 
     void CombatManager::destroyCombatant(Combatant* combatant)
     {
+        String name = combatant->getCombatantTypeName();
+        CombatantFactoryMap::iterator it = mCombatantFactories.find(name);
+        if (it != mCombatantFactories.end())
+        {
+            return it->second->destroyCombatant(combatant);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "No such CombatantType registered: " + name);
+        }
     }
 
     void CombatManager::registerCombatantFactory(const String& name, CombatantFactory* factory)
     {
+        // If there was one already, it is overwritten.
+        mCombatantFactories[name] = factory;
     }
 
     void CombatManager::unregisterCombatantFactory(CombatantFactory* factory)
     {
+        for (CombatantFactoryMap::iterator it = mCombatantFactories.begin();
+            it != mCombatantFactories.end(); ++it)
+        {
+            if (it->second == factory)
+            {
+                mCombatantFactories.erase(it);
+                break;
+            }
+        }
     }
 }

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2007-08-08 19:33:50 UTC (rev 3677)
@@ -47,7 +47,7 @@
 		void run(Ogre::Real elapsedTime);
 
         // Combatant override
-        virtual Ogre::String getTypeName();
+        virtual Ogre::String getCombatantTypeName() const;
 
     private:
         CombatManager* mCombatManager;

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-08 19:02:48 UTC (rev 3676)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-08 19:33:50 UTC (rev 3677)
@@ -183,7 +183,7 @@
         return rval;
     }
 
-    Ogre::String CombatControlState::getTypeName()
+    Ogre::String CombatControlState::getCombatantTypeName() const
     {
         return "CombatControlState";
     }



From tanis at mail.berlios.de  Thu Aug  9 19:38:35 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 9 Aug 2007 19:38:35 +0200
Subject: [Dsa-hl-svn] r3678 - rl/trunk/engine/common/src
Message-ID: <200708091738.l79HcZ4w022585@sheep.berlios.de>

Author: tanis
Date: 2007-08-09 19:38:31 +0200 (Thu, 09 Aug 2007)
New Revision: 3678

Modified:
   rl/trunk/engine/common/src/PropertyReader.cpp
Log:
fixed line endings.

Modified: rl/trunk/engine/common/src/PropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/PropertyReader.cpp	2007-08-08 19:33:50 UTC (rev 3677)
+++ rl/trunk/engine/common/src/PropertyReader.cpp	2007-08-09 17:38:31 UTC (rev 3678)
@@ -13,7 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
-
+
 #include "stdinc.h" //precompiled header
 
 #include <xercesc/dom/DOM.hpp>



From blakharaz at mail.berlios.de  Thu Aug  9 21:48:43 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 9 Aug 2007 21:48:43 +0200
Subject: [Dsa-hl-svn] r3679 - in rl/trunk: engine/ai/include engine/ai/src
	engine/common/include engine/common/src engine/core/include
	engine/core/src engine/core/src/nulldriver
	engine/dialog/include engine/dialog/include/predicates
	engine/dialog/src engine/dialog/src/predicates
	engine/rules/include engine/rules/src engine/script/include
	engine/script/src engine/script/swig engine/ui/include
	engine/ui/src plugins/fmod4driver/src
Message-ID: <200708091948.l79Jmh1q032505@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-09 21:47:19 +0200 (Thu, 09 Aug 2007)
New Revision: 3679

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/include/AStarNodePool.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AgentState.h
   rl/trunk/engine/ai/include/AgentSteeringState.h
   rl/trunk/engine/ai/include/AiPrerequisites.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/include/FuzzyState.h
   rl/trunk/engine/ai/include/FuzzyStateMachine.h
   rl/trunk/engine/ai/include/Landmark.h
   rl/trunk/engine/ai/include/LandmarkPath.h
   rl/trunk/engine/ai/include/PhysicalObstacle.h
   rl/trunk/engine/ai/include/SteeringMachine.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/include/stdinc.h
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarCosts.cpp
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/AStarNodePool.cpp
   rl/trunk/engine/ai/src/AStarWayPointNode.cpp
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/AgentSteeringState.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/ai/src/Landmark.cpp
   rl/trunk/engine/ai/src/LandmarkPath.cpp
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/ai/src/WayPointGraphManager.cpp
   rl/trunk/engine/ai/src/WayPointNode.cpp
   rl/trunk/engine/ai/src/stdinc.cpp
   rl/trunk/engine/common/include/Properties.h
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/common/include/Sleep.h
   rl/trunk/engine/common/include/stdinc.h
   rl/trunk/engine/common/src/Properties.cpp
   rl/trunk/engine/common/src/Property.cpp
   rl/trunk/engine/common/src/XmlErrorHandler.cpp
   rl/trunk/engine/common/src/stdinc.cpp
   rl/trunk/engine/core/include/ListenerObject.h
   rl/trunk/engine/core/include/stdinc.h
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
   rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
   rl/trunk/engine/core/src/stdinc.cpp
   rl/trunk/engine/dialog/include/AimlNodeImplRl.h
   rl/trunk/engine/dialog/include/AimlParserImplRl.h
   rl/trunk/engine/dialog/include/ContextConditionProcessor.h
   rl/trunk/engine/dialog/include/ContextInterpreter.h
   rl/trunk/engine/dialog/include/DialogCharacter.h
   rl/trunk/engine/dialog/include/DialogOption.h
   rl/trunk/engine/dialog/include/DialogPrerequisites.h
   rl/trunk/engine/dialog/include/DialogResponse.h
   rl/trunk/engine/dialog/include/DialogScriptProcessor.h
   rl/trunk/engine/dialog/include/DialogSubsystem.h
   rl/trunk/engine/dialog/include/ScriptProcessor.h
   rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h
   rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h
   rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h
   rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h
   rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h
   rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h
   rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h
   rl/trunk/engine/dialog/include/stdinc.h
   rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
   rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
   rl/trunk/engine/dialog/src/ContextInterpreter.cpp
   rl/trunk/engine/dialog/src/DialogCharacter.cpp
   rl/trunk/engine/dialog/src/DialogOption.cpp
   rl/trunk/engine/dialog/src/DialogResponse.cpp
   rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
   rl/trunk/engine/dialog/src/DialogSubsystem.cpp
   rl/trunk/engine/dialog/src/ScriptProcessor.cpp
   rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
   rl/trunk/engine/dialog/src/stdinc.cpp
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/SelectionHelper.h
   rl/trunk/engine/rules/include/Selector.h
   rl/trunk/engine/rules/include/stdinc.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/rules/src/Selector.cpp
   rl/trunk/engine/rules/src/stdinc.cpp
   rl/trunk/engine/script/include/stdinc.h
   rl/trunk/engine/script/src/stdinc.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCommon.head.swig
   rl/trunk/engine/script/swig/RlCommon.swig
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlDialog.head.swig
   rl/trunk/engine/script/swig/RlDialog.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlScript.head.swig
   rl/trunk/engine/script/swig/RlScript.swig
   rl/trunk/engine/script/swig/RlUi.head.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/include/ControlState.h
   rl/trunk/engine/ui/include/CutsceneControlState.h
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/include/FreeflightControlState.h
   rl/trunk/engine/ui/include/ListboxWrappedTextItem.h
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/include/stdinc.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/ControlState.cpp
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
   rl/trunk/engine/ui/src/stdinc.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp
Log:
Changed all license headers to clarified artistic license and copyright 2003-2007

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AStar.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AStar_H__
 #define __RlAI_AStar_H__

Modified: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AStarCosts_H__
 #define __RlAI_AStarCosts_H__

Modified: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AStarHeuristic_H__
 #define __RlAI_AStarHeuristic_H__

Modified: rl/trunk/engine/ai/include/AStarNodePool.h
===================================================================
--- rl/trunk/engine/ai/include/AStarNodePool.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AStarNodePool.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AStarNodeManager_H__
 #define __RlAI_AStarNodeManager_H__

Modified: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AStarWayPointNode_H__
 #define __RlAI_AStarWayPointNode_H__

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/Agent.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_Agent_H__
 #define __RlAI_Agent_H__

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AgentManager_H__
 #define __RlAI_AgentManager_H__

Modified: rl/trunk/engine/ai/include/AgentState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AgentState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_AgentState_H__
 #define __RlAI_AgentState_H__

Modified: rl/trunk/engine/ai/include/AgentSteeringState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_SteeringAgentState_H__
 #define __RlAI_SteeringAgentState_H__

Modified: rl/trunk/engine/ai/include/AiPrerequisites.h
===================================================================
--- rl/trunk/engine/ai/include/AiPrerequisites.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AiPrerequisites.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __AiPrerequisites_H__
 #define __AiPrerequisites_H__

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __AiSubsystem_H__
 #define __AiSubsystem_H__

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_World_H__
 #define __RlAI_World_H__

Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 * 
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #ifndef __CreatureWalkPathJob_H__

Modified: rl/trunk/engine/ai/include/FuzzyState.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/FuzzyState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_FuzzyState_H__
 #define __RlAI_FuzzyState_H__

Modified: rl/trunk/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_FuzzyStateMachine_H__
 #define __RlAI_FuzzyStateMachine_H__

Modified: rl/trunk/engine/ai/include/Landmark.h
===================================================================
--- rl/trunk/engine/ai/include/Landmark.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/Landmark.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Landmark_H__
 #define __Landmark_H__

Modified: rl/trunk/engine/ai/include/LandmarkPath.h
===================================================================
--- rl/trunk/engine/ai/include/LandmarkPath.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/LandmarkPath.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __LandmarkPath_H__
 #define __LandmarkPath_H__

Modified: rl/trunk/engine/ai/include/PhysicalObstacle.h
===================================================================
--- rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef PHYSICALOBSTACLE_H_
 #define PHYSICALOBSTACLE_H_

Modified: rl/trunk/engine/ai/include/SteeringMachine.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringMachine.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/SteeringMachine.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAi_SteeringMachine_H__
 #define __RlAi_SteeringMachine_H__

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_SteeringVehicle_H__
 #define __RlAI_SteeringVehicle_H__

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_WayPointGraph_H__
 #define __RlAI_WayPointGraph_H__

Modified: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_WayPointGraphManager_H__
 #define __RlAI_WayPointGraphManager_H__

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __RlAI_WayPointNode_H__
 #define __RlAI_WayPointNode_H__

Modified: rl/trunk/engine/ai/include/stdinc.h
===================================================================
--- rl/trunk/engine/ai/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 
@@ -32,24 +32,24 @@
 namespace rl {
 
 AStarStatistics::AStarStatistics()
-: mNodesSearched(0),
-  mNodesAdded(0),
-  mNodesRemoved(0),
-  mNodesVisited(0),
-  mNodesLeft(0),
-  mPathLength(0),
+: mNodesSearched(0),
+  mNodesAdded(0),
+  mNodesRemoved(0),
+  mNodesVisited(0),
+  mNodesLeft(0),
+  mPathLength(0),
   mPathCost(0)
 {
 }
 
 void AStarStatistics::reset()
 {
-  mNodesSearched = 0;
-  mNodesAdded = 0;
-  mNodesRemoved = 0;
-  mNodesVisited = 0;
-  mNodesLeft = 0;
-  mPathLength = 0;
+  mNodesSearched = 0;
+  mNodesAdded = 0;
+  mNodesRemoved = 0;
+  mNodesVisited = 0;
+  mNodesLeft = 0;
+  mPathLength = 0;
   mPathCost = 0;
 }
 

Modified: rl/trunk/engine/ai/src/AStarCosts.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarCosts.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AStarCosts.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/AStarNodePool.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/AStarWayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ai/src/AgentSteeringState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/Landmark.cpp
===================================================================
--- rl/trunk/engine/ai/src/Landmark.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/Landmark.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/LandmarkPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/WayPointGraphManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/WayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointNode.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/WayPointNode.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ai/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/ai/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ai/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/common/include/Properties.h
===================================================================
--- rl/trunk/engine/common/include/Properties.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/include/Properties.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here:
- *  http://www.perldoc.com/perl5.6/Artistic.html
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm
  */
 #ifndef __Properties_H__
 #define __Properties_H__

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/include/Property.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here:
- *  http://www.perldoc.com/perl5.6/Artistic.html
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm
  */
 #ifndef __Property_H__
 #define __Property_H__

Modified: rl/trunk/engine/common/include/Sleep.h
===================================================================
--- rl/trunk/engine/common/include/Sleep.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/include/Sleep.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * (C) 2004. Team Pantheon. www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here:
- *  http://www.perldoc.com/perl5.6/Artistic.html
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm
  */
 
 

Modified: rl/trunk/engine/common/include/stdinc.h
===================================================================
--- rl/trunk/engine/common/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/common/src/Properties.cpp
===================================================================
--- rl/trunk/engine/common/src/Properties.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/src/Properties.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
-/* 
+/* This source file is part of Rastullahs Lockenpracht.
  * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here:
- *  http://www.perldoc.com/perl5.6/Artistic.html
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm
  */
 
 #include "stdinc.h" //precompiled header

Modified: rl/trunk/engine/common/src/Property.cpp
===================================================================
--- rl/trunk/engine/common/src/Property.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/src/Property.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here:
- *  http://www.perldoc.com/perl5.6/Artistic.html
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm
  */
 
 #include "stdinc.h" //precompiled header

Modified: rl/trunk/engine/common/src/XmlErrorHandler.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
@@ -14,7 +14,7 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-#include "stdinc.h" //precompiled header
+#include "stdinc.h" //precompiled header
 
 #include <sstream>
 #include <xercesc/sax/SAXParseException.hpp>

Modified: rl/trunk/engine/common/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/common/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/common/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/core/include/ListenerObject.h
===================================================================
--- rl/trunk/engine/core/include/ListenerObject.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/core/include/ListenerObject.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 * 
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #ifndef __ListenerObject_H__

Modified: rl/trunk/engine/core/include/stdinc.h
===================================================================
--- rl/trunk/engine/core/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/core/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -74,7 +74,7 @@
 }
 
 /**
- * Gibt den Anzeigename des Treiber zur?ck.
+ * Gibt den Anzeigename des Treiber zurueck.
  * @return Anzeigename
  * @author JoSch
  * @date 12-23-2005

Modified: rl/trunk/engine/core/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/core/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/core/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/dialog/include/AimlNodeImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_AimlNodeImplRl_H__
 #define __Rl_AimlNodeImplRl_H__

Modified: rl/trunk/engine/dialog/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_AimlParserImplRl_H__
 #define __Rl_AimlParserImplRl_H__

Modified: rl/trunk/engine/dialog/include/ContextConditionProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_ContextConditionProcessor_H__
 #define __Rl_ContextConditionProcessor_H__

Modified: rl/trunk/engine/dialog/include/ContextInterpreter.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_AimlContextInterpreter_H__
 #define __Rl_AimlContextInterpreter_H__

Modified: rl/trunk/engine/dialog/include/DialogCharacter.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogCharacter.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogCharacter.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_DialogCharacter_H__
 #define __Rl_DialogCharacter_H__

Modified: rl/trunk/engine/dialog/include/DialogOption.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogOption.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogOption.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_DialogOption_H__
 #define __Rl_DialogOption_H__

Modified: rl/trunk/engine/dialog/include/DialogPrerequisites.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __DialogPrerequisites_H__
 #define __DialogPrerequisites_H__

Modified: rl/trunk/engine/dialog/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogResponse.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogResponse.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_DialogResponse_H__
 #define __Rl_DialogResponse_H__

Modified: rl/trunk/engine/dialog/include/DialogScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_DialogScriptProcessor_H__
 #define __Rl_DialogScriptProcessor_H__

Modified: rl/trunk/engine/dialog/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __DialogSubsystem_H__
 #define __DialogSubsystem_H__

Modified: rl/trunk/engine/dialog/include/ScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_ScriptProcessor_H__
 #define __Rl_ScriptProcessor_H__

Modified: rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_CreaturePredicates_H__
 #define __Rl_CreaturePredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_EigenschaftsProbePredicates_H__
 #define __Rl_EigenschaftsProbePredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_EigenschaftsWertPredicates_H__
 #define __Rl_EigenschaftsWertPredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_GrundWertPredicates_H__
 #define __Rl_GrundWertPredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_QuestKnownPredicates_H__
 #define __Rl_QuestKnownPredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_QuestPartsPredicates_H__
 #define __Rl_QuestPartsPredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_QuestStatePredicates_H__
 #define __Rl_QuestStatePredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_ScriptPredicates_H__
 #define __Rl_ScriptPredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_TalentProbePredicates_H__
 #define __Rl_TalentProbePredicates_H__

Modified: rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #ifndef __Rl_TalentWertPredicates_H__
 #define __Rl_TalentWertPredicates_H__

Modified: rl/trunk/engine/dialog/include/stdinc.h
===================================================================
--- rl/trunk/engine/dialog/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/ContextInterpreter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/DialogCharacter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogOption.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/DialogOption.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/ScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 
@@ -83,5 +83,5 @@
 	return "grundwert";
 }
 
-}
-
+}
+

Modified: rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 
@@ -100,5 +100,5 @@
 	return "questparts";
 }
 
-}
-
+}
+

Modified: rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/dialog/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/dialog/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/dialog/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 

Modified: rl/trunk/engine/rules/include/SelectionHelper.h
===================================================================
--- rl/trunk/engine/rules/include/SelectionHelper.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/include/SelectionHelper.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __RL_SELECTION_HELPER_H__

Modified: rl/trunk/engine/rules/include/Selector.h
===================================================================
--- rl/trunk/engine/rules/include/Selector.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/include/Selector.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __RL_SELECTOR_H__

Modified: rl/trunk/engine/rules/include/stdinc.h
===================================================================
--- rl/trunk/engine/rules/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/rules/src/Selector.cpp
===================================================================
--- rl/trunk/engine/rules/src/Selector.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/src/Selector.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/rules/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/rules/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/rules/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/script/include/stdinc.h
===================================================================
--- rl/trunk/engine/script/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/script/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/script/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlCommon.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlCommon.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlCommon.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlCommon.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 namespace Ogre {

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlDialog.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlDialog.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlDialog.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlDialog.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlScript.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlScript.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlUi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.head.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlUi.head.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __CombatCharacterController_H__

Modified: rl/trunk/engine/ui/include/ControlState.h
===================================================================
--- rl/trunk/engine/ui/include/ControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/ControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __CharacterController_H__

Modified: rl/trunk/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/CutsceneControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __CutsceneCharacterController_H__

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __DialogCharacterController_H__

Modified: rl/trunk/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/trunk/engine/ui/include/FreeflightControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/FreeflightControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 * 
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #ifndef __FreeFlightCharacterController_H__

Modified: rl/trunk/engine/ui/include/ListboxWrappedTextItem.h
===================================================================
--- rl/trunk/engine/ui/include/ListboxWrappedTextItem.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/ListboxWrappedTextItem.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -9,16 +9,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 * 
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #ifndef _ListboxWrappedTextItem_h_
 #define _ListboxWrappedTextItem_h_

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #ifndef __MovementCharacterController_H__

Modified: rl/trunk/engine/ui/include/stdinc.h
===================================================================
--- rl/trunk/engine/ui/include/stdinc.h	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/include/stdinc.h	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 /*

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -3,16 +3,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -3,16 +3,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
===================================================================
--- rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -9,16 +9,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 #include "stdinc.h" //precompiled header
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -2,16 +2,16 @@
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
+*  it under the terms of the Clarified Artistic License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
+*  Clarified Artistic License for more details.
 *
-*  You should have received a copy of the Perl Artistic License
+*  You should have received a copy of the Clarified Artistic License
 *  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #include "stdinc.h"

Modified: rl/trunk/engine/ui/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/ui/src/stdinc.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/engine/ui/src/stdinc.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,17 +1,17 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
+ *  it under the terms of the Clarified Artistic License.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
+ *  Clarified Artistic License for more details.
  *
- *  You should have received a copy of the Perl Artistic License
+ *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
 #include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp	2007-08-09 17:38:31 UTC (rev 3678)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp	2007-08-09 19:47:19 UTC (rev 3679)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.



From tanis at mail.berlios.de  Sat Aug 11 00:57:42 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sat, 11 Aug 2007 00:57:42 +0200
Subject: [Dsa-hl-svn] r3680 - in rl/trunk/engine: ai/include ai/src
	rules/include rules/src ui/src
Message-ID: <200708102257.l7AMvgr5028935@sheep.berlios.de>

Author: tanis
Date: 2007-08-11 00:57:24 +0200 (Sat, 11 Aug 2007)
New Revision: 3680

Modified:
   rl/trunk/engine/ai/include/AgentCombatState.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/ui/src/CombatControlState.cpp
Log:
AgentSteeringstate works again, after having been broken. Still anything but intelligent behaviour.

Modified: rl/trunk/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-10 22:57:24 UTC (rev 3680)
@@ -41,6 +41,9 @@
          * @param elapsedTime time since last update call.
 		 */
 		virtual void update(const float elapsedTime);
+    protected:
+        typedef enum {} CombatState;
+        CombatState mState;
 	};
 }
 #endif

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-10 22:57:24 UTC (rev 3680)
@@ -53,6 +53,8 @@
 	{
 		Throw(NullPointerException, "Agent has no creature");
 	}
+    // We need a state to start with. Per default the Agent is steering.
+    pushState(AST_STEERING);
 }
 
 void Agent::update(const float elapsedTime)

Modified: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-10 22:57:24 UTC (rev 3680)
@@ -25,7 +25,8 @@
     AgentCombatState::AgentCombatState(Agent* agent)
         : AgentState(agent),
         Combatant(CreatureControllerManager::getSingleton().getCreatureController(
-            agent->getControlledCreature()))
+            agent->getControlledCreature())),
+        mState()
     {
     }
 

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-10 22:57:24 UTC (rev 3680)
@@ -19,6 +19,7 @@
 
 #include "Agent.h"
 #include "AgentCombatState.h"
+#include "AgentSteeringState.h"
 #include "CombatManager.h"
 #include "Creature.h"
 #include "GameObjectManager.h"
@@ -119,26 +120,38 @@
     }
     else if (newState == GOS_IN_SCENE)
     {
-        // Create an Agent and add the behaviours of the creature to it.
+        /// Create an Agent and add the behaviours of the creature to it.
+        /// /XXX setting of the actual properties should be delegated to the agent itself
+        /// this is one level above what is sensible.
         Property aiProperty = creature->getProperty(Creature::PROPERTY_AI);
-        //if (behaviorProperty.isArray())
-        //{
-        //    PropertyVector behaviors = aiProperty.toArray();
-        //    if (!behaviors.empty())
-        //    {
-        //        Agent* agent = createAgent(creature);
-        //        for (PropertyVector::const_iterator it = behaviors.begin(),
-        //            end = behaviors.end(); it != end; ++it)
-        //        {
-        //            if (it->isString())
-        //            {
-        //                SteeringBehaviour* behavior =
-        //                    mBehaviourFactory->createBehaviour(it->toString().c_str());
-        //                agent->addSteeringBehaviour(behavior);
-        //            }
-        //        }
-        //    }
-        //}
+        if (aiProperty.isMap())
+        {
+            PropertyMap aiProps = aiProperty.toMap();
+            Property behaviorsProperty = aiProps["behaviours"];
+            if (behaviorsProperty.isArray())
+            {
+                PropertyVector behaviours = behaviorsProperty.toArray();
+                if (!behaviours.empty())
+                {
+                    Agent* agent = createAgent(creature);
+                    // Agent is created with AgentSteeringState as default.
+                    // So it is save to cast current AgentState to AgentSteeringState.
+                    // Nevertheless see above comment for how to improve this situation.
+                    AgentSteeringState* ass =
+                        dynamic_cast<AgentSteeringState*>(agent->getCurrentState());
+                    for (PropertyVector::const_iterator it = behaviours.begin(),
+                        end = behaviours.end(); it != end; ++it)
+                    {
+                        if (it->isString())
+                        {
+                            SteeringBehaviour* behavior =
+                                mBehaviourFactory->createBehaviour(it->toString().c_str());
+                            ass->addSteeringBehaviour(behavior);
+                        }
+                    }
+                }
+            }
+        }
     }
 }
 

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/rules/include/Combat.h	2007-08-10 22:57:24 UTC (rev 3680)
@@ -20,6 +20,7 @@
 #include "RulesPrerequisites.h"
 
 #include <set>
+#include <vector>
 
 namespace rl
 {
@@ -42,10 +43,20 @@
         const CombatantSet& getAllOpponents() const;
         const CombatantSet& getAllAllies() const;
 
+        void start();
+        void stop();
+
     private:
         Combatant* mCharacter;
         CombatantSet mOpponents;
         CombatantSet mAllies;
+        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
+        // Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        // Combatants in order of their initiative for the next round.
+        // Will be copied to the current round after current round is done
+        // and then it will be emptied.
+        CombatantQueue mNextCombatQueue;
     };
 }
 

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/rules/src/Combat.cpp	2007-08-10 22:57:24 UTC (rev 3680)
@@ -17,8 +17,22 @@
 
 #include "Combat.h"
 
+#include "Combatant.h"
+#include "CreatureController.h"
+
 namespace rl
 {
+    struct InitiativeComparator
+    {
+        /// \todo take into account other values of the combatant according to TDE rules,
+        /// in case initiative is equal.
+        bool operator()(const std::pair<int, Combatant*>& c1,
+            const std::pair<int, Combatant*>& c2) const
+        {
+            return c1.first < c2.first;
+        }
+    };
+
     Combat::Combat(Combatant* character) : mCharacter(character)
     {
     }
@@ -56,4 +70,24 @@
     {
         return mAllies;
     }
+
+    void Combat::start()
+    {
+        mCombatantQueue.clear();
+        std::vector<Combatant*> combatants;
+        combatants.insert(combatants.end(), mAllies.begin(), mAllies.end());
+        combatants.insert(combatants.end(), mOpponents.begin(), mOpponents.end());
+        // Calculate initiative for all participiants
+        for (std::vector<Combatant*>::const_iterator it = combatants.begin();
+            it != combatants.end(); ++it)
+        {
+            mCombatantQueue.push_back(std::make_pair(
+                (*it)->getCreatureController()->getCreature()->getInitiativeBasis(), *it));
+        }
+        std::sort(mCombatantQueue.begin(), mCombatantQueue.end(), InitiativeComparator());
+    }
+
+    void Combat::stop()
+    {
+    }
 }

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-09 19:47:19 UTC (rev 3679)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-10 22:57:24 UTC (rev 3680)
@@ -119,6 +119,8 @@
             }
         }
         mCombatWindow->setVisible(true);
+
+        mCombat->start();
     }
 
     void CombatControlState::pause()
@@ -130,6 +132,7 @@
         static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
 
         // reset current combat, in order to avoid a potential dangling pointer
+        mCombat->stop();
         mCombat = NULL;
     }
 



From tanis at mail.berlios.de  Sat Aug 11 00:58:30 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sat, 11 Aug 2007 00:58:30 +0200
Subject: [Dsa-hl-svn] r3681 - in modules: aitest/dsa common/scripts
Message-ID: <200708102258.l7AMwUBU029263@sheep.berlios.de>

Author: tanis
Date: 2007-08-11 00:58:21 +0200 (Sat, 11 Aug 2007)
New Revision: 3681

Modified:
   modules/aitest/dsa/gameobjectdefinitions.gof
   modules/common/scripts/steering.rb
Log:
AgentSteeringstate works again, after having been broken. Still anything but intelligent behaviour.

Modified: modules/aitest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/aitest/dsa/gameobjectdefinitions.gof	2007-08-10 22:57:24 UTC (rev 3680)
+++ modules/aitest/dsa/gameobjectdefinitions.gof	2007-08-10 22:58:21 UTC (rev 3681)
@@ -26,10 +26,11 @@
         <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
-        <property name="behaviours" type="ARRAY">
-	    <property type="STRING" data="DefaultWanderBehaviour"/>
-	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
-            <property type="STRING" data="DialogBehaviour"/>
+        <property name="ai" type="MAP">
+            <property name="behaviours" type="ARRAY">
+    	        <property type="STRING" data="DefaultWanderBehaviour"/>
+    	        <property type="STRING" data="AvoidObstaclesBehaviour"/>
+            </property>
         </property>
     </gameobjectclass>
 
@@ -42,9 +43,11 @@
         <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
-	<property name="behaviours" type="ARRAY">
-	    <property type="STRING" data="DefaultWanderBehaviour"/>
-	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
+        <property name="ai" type="MAP">
+            <property name="behaviours" type="ARRAY">
+    	        <property type="STRING" data="DefaultWanderBehaviour"/>
+    	        <property type="STRING" data="AvoidObstaclesBehaviour"/>
+            </property>
         </property>
     </gameobjectclass>
 
@@ -57,9 +60,11 @@
     <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
     <property name="mass" type="REAL" data="40"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
-    <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="DefaultWanderBehaviour"/>
-    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
+    <property name="ai" type="MAP">
+        <property name="behaviours" type="ARRAY">
+    	    <property type="STRING" data="DefaultWanderBehaviour"/>
+    	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
+        </property>
     </property>
   </gameobjectclass>
 

Modified: modules/common/scripts/steering.rb
===================================================================
--- modules/common/scripts/steering.rb	2007-08-10 22:57:24 UTC (rev 3680)
+++ modules/common/scripts/steering.rb	2007-08-10 22:58:21 UTC (rev 3681)
@@ -32,11 +32,7 @@
 	end
 	
 	def calculateActivation()
-		if(getController().isDialogActive())
-			setActivationLevel(getActivationLevel()*0.0);
-		else
-			setActivationLevel(1.0);
-		end
+		setActivationLevel(1.0);
 		if(getController().needAvoidance(5.0))
 			setActivationLevel(getActivationLevel()*5.0);
 		end
@@ -167,11 +163,7 @@
 	end
 	
 	def calculateActivation()
-		if(getController().isDialogActive())
-			setActivationLevel(0.0);
-		else
-			setActivationLevel(1.0);
-		end
+		setActivationLevel(1.0);
 		return getActivationLevel();
 	end
 end



From twel at mail.berlios.de  Sun Aug 12 13:05:04 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Sun, 12 Aug 2007 13:05:04 +0200
Subject: [Dsa-hl-svn] r3682 - in rl/trunk/engine/ai: include src
Message-ID: <200708121105.l7CB54l4016852@sheep.berlios.de>

Author: twel
Date: 2007-08-12 13:04:59 +0200 (Sun, 12 Aug 2007)
New Revision: 3682

Modified:
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/Makefile.am
Log:
removed PlayerVehicle from Makefile.am

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-08-10 22:58:21 UTC (rev 3681)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-08-12 11:04:59 UTC (rev 3682)
@@ -18,7 +18,6 @@
 	Landmark.h \
 	LandmarkPath.h \
 	PhysicalObstacle.h \
-	PlayerVehicle.h \
 	SteeringMachine.h \
 	SteeringVehicle.h \
 	WayPointNode.h \

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-08-10 22:58:21 UTC (rev 3681)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-08-12 11:04:59 UTC (rev 3682)
@@ -21,8 +21,7 @@
 	Landmark.cpp \
 	LandmarkPath.cpp \
 	PhysicalObstacle.cpp \
-	PlayerVehicle.cpp \
 	SteeringVehicle.cpp \
-    WayPointNode.cpp \
+	WayPointNode.cpp \
 	WayPointGraph.cpp \
 	WayPointGraphManager.cpp



From melven at mail.berlios.de  Sun Aug 12 22:51:38 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 12 Aug 2007 22:51:38 +0200
Subject: [Dsa-hl-svn] r3683 - in rl/trunk/engine/ui: include src
Message-ID: <200708122051.l7CKpc2U003605@sheep.berlios.de>

Author: melven
Date: 2007-08-12 22:51:30 +0200 (Sun, 12 Aug 2007)
New Revision: 3683

Modified:
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
pnyx idea for movementcontroller-mode (VM_PNYX_MODE) 4xf to active ingame, simple movements for testing (no jumps etc)

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-08-12 11:04:59 UTC (rev 3682)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-08-12 20:51:30 UTC (rev 3683)
@@ -45,7 +45,7 @@
         public DebugVisualisable
     {
     public:
-        typedef enum {VM_THIRD_PERSON, VM_FIRST_PERSON, VM_FREE_CAMERA} ViewMode;
+        typedef enum {VM_THIRD_PERSON, VM_FIRST_PERSON, VM_FREE_CAMERA, VM_PNYX_MODE} ViewMode;
         /**
          *  @throw NullPointerException if camera or character is NULL.
          *  @throw InvalidArgumentException if character is not placed in the scene.

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-12 11:04:59 UTC (rev 3682)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-12 20:51:30 UTC (rev 3683)
@@ -301,119 +301,183 @@
             Real baseVelocity = 0;
             if( drehen->calculateBaseVelocity(baseVelocity) )
             {
-                Degree baseVel(baseVelocity*360);
-                if (movement & TURN_LEFT)
-                    rotation = elapsedTime * baseVel;
-                if (movement & TURN_RIGHT)
-                    rotation = -elapsedTime * baseVel;
-
-                // mouse
-                if( !isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
                 {
-                    if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
                     {
-                        rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                        if (movement & TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement & TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
                     }
+
+                    // mouse
+                    if( !isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                    {
+                        if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                        {
+                            rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                        }
+                    }
                 }
 
 
-                // virtual yaw
-                Degree newVirtualYaw(0);
-                if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                    ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                if( mViewMode != VM_PNYX_MODE )
                 {
-                    newVirtualYaw = Degree(45);
+                    // virtual yaw
+                    Degree newVirtualYaw(0);
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        newVirtualYaw = Degree(45);
+                    }
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        newVirtualYaw = Degree(-45);
+                    }
+                    if( mCamVirtualYaw != newVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - newVirtualYaw;
+                        mCamVirtualYaw = newVirtualYaw;
+                    }
                 }
-                if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                    ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                {
-                    newVirtualYaw = Degree(-45);
-                }
-                if( mCamVirtualYaw != newVirtualYaw )
-                {
-                    rotation += mCamVirtualYaw - newVirtualYaw;
-                    mCamVirtualYaw = newVirtualYaw;
-                }
             }
 
 
 
-            if( movement & MOVE_SNEAK )
+            if( mViewMode != VM_PNYX_MODE )
             {
-                Vector3 direction(Vector3::ZERO);
-                if (movement & MOVE_FORWARD)
-                    direction.z = -1;
-                else if( movement & MOVE_BACKWARD)
-                    direction.z = 1;
-                mController->setMovement(
-                    CreatureController::MT_SCHLEICHEN,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement & MOVE_JUMP && 
-                mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
-            {
-                CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                Vector3 direction = Vector3::UNIT_Y;
-                if( movement & MOVE_FORWARD )
+                if( movement & MOVE_SNEAK )
                 {
-                    type = CreatureController::MT_WEITSPRUNG;
-                    direction += Vector3::NEGATIVE_UNIT_Z;
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement & MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement & MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController->setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
                 }
-                mController->setMovement(
-                    type,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement & MOVE_FORWARD )
-            {
-                CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                if( movement & MOVE_RUN_LOCK )
+                else if( movement & MOVE_JUMP && 
+                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
                 {
-                    if( movement & MOVE_RUN )
-                        type = CreatureController::MT_RENNEN;
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController->setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement & MOVE_RUN_LOCK )
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
                     else
-                        type = CreatureController::MT_LAUFEN;
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
                 }
+                else if (movement & MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement & MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement & MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController->setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
                 else
                 {
-                    if( movement & MOVE_RUN )
-                        type = CreatureController::MT_GEHEN;
-                    else
-                        type = CreatureController::MT_JOGGEN;
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
                 }
-                mController->setMovement(
-                    type,
-                    Vector3(0,0,-1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
             }
-            else if (movement & MOVE_BACKWARD )
+            else // VM_PNYX_MODE
             {
-                CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                if( !(movement & MOVE_RUN) )
-                    type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                mController->setMovement(
-                    type,
-                    Vector3(0,0,1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
+                // turn to the direction entered
+                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+                    mController->setMovement(
+                        CreatureController::MT_JOGGEN,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
             }
-            else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-            {
-                Vector3 direction = Vector3::UNIT_X;
-                if( movement & MOVE_LEFT )
-                    direction = Vector3::NEGATIVE_UNIT_X;
-                mController->setMovement(
-                    CreatureController::MT_SEITWAERTS_GEHEN,
-                    direction, 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else
-            {
-                mController->setMovement(
-                    CreatureController::MT_STEHEN, 
-                    Vector3(0,0,0),
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
         }
     }
 
@@ -433,7 +497,7 @@
             mDesiredDistance = mDistanceRange.second;
         }
 
-        if( !isCeguiActive() && mViewMode == VM_FREE_CAMERA )
+        if( !isCeguiActive() && mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
         {
             mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
 
@@ -476,7 +540,7 @@
                 Node::TS_WORLD);
 
         }
-        else if( mViewMode == VM_FREE_CAMERA )
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
         {
             cameraNode->lookAt(
                 charPos + charOri * virtualCamOri * mLookAtOffset,
@@ -595,7 +659,7 @@
 
 
 
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
         {
 
             // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
@@ -797,13 +861,24 @@
 
 
 
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
         {
             charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_THIRD_PERSON)
+            if(mViewMode == VM_PNYX_MODE)
             {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
                 targetCamPos =
                     charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
                     + charOri * virtualCamOri * Vector3(
                                     0,
                                     Math::Sin(mPitch) * mDesiredDistance,
@@ -1040,7 +1115,7 @@
             LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
             resetCamera();
         }
-        else // mode == VM_FREE_CAMERA
+        else if(mode == VM_FREE_CAMERA)
         {
             mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
             mDistanceRange.first = 0.60;
@@ -1053,6 +1128,19 @@
             LOG_MESSAGE(Logger::UI, "Switch to free camera view");
             resetCamera();
         }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
+            resetCamera();
+        }
     }
 
     //------------------------------------------------------------------------
@@ -1105,6 +1193,8 @@
             setViewMode(VM_FIRST_PERSON);
         else if(getViewMode() == VM_FIRST_PERSON)
             setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
         else
             setViewMode(VM_THIRD_PERSON);
     }



From blakharaz at mail.berlios.de  Sun Aug 12 23:30:52 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 12 Aug 2007 23:30:52 +0200
Subject: [Dsa-hl-svn] r3684 - dependencies/opensteer/include/OpenSteer
	dependencies/opensteer/plugins dependencies/opensteer/src
	modules/aitest/scripts rl/trunk/engine/ai/include
	rl/trunk/engine/ai/src rl/trunk/engine/script/swig
Message-ID: <200708122130.l7CLUqsF005585@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-12 23:30:22 +0200 (Sun, 12 Aug 2007)
New Revision: 3684

Modified:
   dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
   dependencies/opensteer/include/OpenSteer/Annotation.h
   dependencies/opensteer/include/OpenSteer/Camera.h
   dependencies/opensteer/include/OpenSteer/Color.h
   dependencies/opensteer/include/OpenSteer/Draw.h
   dependencies/opensteer/include/OpenSteer/LocalSpace.h
   dependencies/opensteer/include/OpenSteer/Obstacle.h
   dependencies/opensteer/include/OpenSteer/OldPathway.h
   dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h
   dependencies/opensteer/include/OpenSteer/Path.h
   dependencies/opensteer/include/OpenSteer/Pathway.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   dependencies/opensteer/include/OpenSteer/Proximity.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlike.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h
   dependencies/opensteer/include/OpenSteer/SegmentedPath.h
   dependencies/opensteer/include/OpenSteer/SegmentedPathway.h
   dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
   dependencies/opensteer/include/OpenSteer/SteerLibrary.h
   dependencies/opensteer/include/OpenSteer/Vec3.h
   dependencies/opensteer/include/OpenSteer/Vec3Utilities.h
   dependencies/opensteer/plugins/Boids.cpp
   dependencies/opensteer/plugins/CaptureTheFlag.cpp
   dependencies/opensteer/plugins/LowSpeedTurn.cpp
   dependencies/opensteer/plugins/MapDrive.cpp
   dependencies/opensteer/plugins/MultiplePursuit.cpp
   dependencies/opensteer/plugins/OneTurning.cpp
   dependencies/opensteer/plugins/Pedestrian.cpp
   dependencies/opensteer/plugins/Soccer.cpp
   dependencies/opensteer/src/Camera.cpp
   dependencies/opensteer/src/Color.cpp
   dependencies/opensteer/src/Draw.cpp
   dependencies/opensteer/src/Obstacle.cpp
   dependencies/opensteer/src/OldPathway.cpp
   dependencies/opensteer/src/OpenSteerDemo.cpp
   dependencies/opensteer/src/PolylineSegmentedPath.cpp
   dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp
   dependencies/opensteer/src/SimpleVehicle.cpp
   dependencies/opensteer/src/Vec3.cpp
   dependencies/opensteer/src/Vec3Utilities.cpp
   modules/aitest/scripts/NpcTest.rb
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/include/stdinc.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Replace OpenSteer's Vec3 by Ogre's Vector3, additional functions are moved to Vec3Utils

Modified: dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
         virtual float setRadius (float) = 0;
 
         // velocity of vehicle
-        virtual Vec3 velocity (void) const = 0;
+        virtual Vector3 velocity (void) const = 0;
 
         // speed of vehicle  (may be faster than taking magnitude of velocity)
         virtual float speed (void) const = 0;
@@ -77,7 +77,7 @@
 
         // predict position of this vehicle at some time in the future
         // (assumes velocity remains constant)
-        virtual Vec3 predictFuturePosition (const float predictionTime) const = 0;
+        virtual Vector3 predictFuturePosition (const float predictionTime) const = 0;
 
         // ----------------------------------------------------------------------
         // XXX this vehicle-model-specific functionality functionality seems out

Modified: dependencies/opensteer/include/OpenSteer/Annotation.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -85,7 +85,7 @@
         // XXX Annotation would "has-a" one (or more))
 
         // record a position for the current time, called once per update
-        void recordTrailVertex (const float currentTime, const Vec3& position);
+        void recordTrailVertex (const float currentTime, const Vector3& position);
 
         // draw the trail as a dotted line, fading away with age
         void drawTrail (void) {drawTrail (grayColor (0.7f), gWhite);}
@@ -111,13 +111,13 @@
         //       "segments" is the number of line segments used to draw the circle
 
         // draw an opaque colored line segment between two locations in space
-        void annotationLine (const Vec3& startPoint,
-                             const Vec3& endPoint,
+        void annotationLine (const Vector3& startPoint,
+                             const Vector3& endPoint,
                              const Color& color) const;
 
         // draw a circle on the XZ plane
         void annotationXZCircle (const float radius,
-                                 const Vec3& center,
+                                 const Vector3& center,
                                  const Color& color,
                                  const int segments) const
         {
@@ -127,7 +127,7 @@
 
         // draw a disk on the XZ plane
         void annotationXZDisk (const float radius,
-                               const Vec3& center,
+                               const Vector3& center,
                                const Color& color,
                                const int segments) const
         {
@@ -137,8 +137,8 @@
 
         // draw a circle perpendicular to the given axis
         void annotation3dCircle (const float radius,
-                                 const Vec3& center,
-                                 const Vec3& axis,
+                                 const Vector3& center,
+                                 const Vector3& axis,
                                  const Color& color,
                                  const int segments) const
         {
@@ -148,8 +148,8 @@
 
         // draw a disk perpendicular to the given axis
         void annotation3dDisk (const float radius,
-                               const Vec3& center,
-                               const Vec3& axis,
+                               const Vector3& center,
+                               const Vector3& axis,
                                const Color& color,
                                const int segments) const
         {
@@ -162,13 +162,13 @@
         // support for annotation circles
 
         void annotationXZCircleOrDisk (const float radius,
-                                       const Vec3& center,
+                                       const Vector3& center,
                                        const Color& color,
                                        const int segments,
                                        const bool filled) const
         {
             annotationCircleOrDisk (radius,
-                                    Vec3::zero,
+                                    Vector3::ZERO,
                                     center,
                                     color,
                                     segments,
@@ -178,8 +178,8 @@
 
 
         void annotation3dCircleOrDisk (const float radius,
-                                       const Vec3& center,
-                                       const Vec3& axis,
+                                       const Vector3& center,
+                                       const Vector3& axis,
                                        const Color& color,
                                        const int segments,
                                        const bool filled) const
@@ -194,8 +194,8 @@
         }
 
         void annotationCircleOrDisk (const float radius,
-                                     const Vec3& axis,
-                                     const Vec3& center,
+                                     const Vector3& axis,
+                                     const Vector3& center,
                                      const Color& color,
                                      const int segments,
                                      const bool filled,
@@ -211,8 +211,8 @@
         float trailSampleInterval;  // desired interval between taking samples
         float trailLastSampleTime;  // global time when lat sample was taken
         int trailDottedPhase;       // dotted line: draw segment or not
-        Vec3 curPosition;           // last reported position of vehicle
-        Vec3* trailVertices;        // array (ring) of recent points along trail
+        Vector3 curPosition;           // last reported position of vehicle
+        Vector3* trailVertices;        // array (ring) of recent points along trail
         char* trailFlags;           // array (ring) of flag bits for trail points
     };
 
@@ -269,7 +269,7 @@
 
     // prepare trailVertices array: free old one if needed, allocate new one
     delete[] trailVertices;
-    trailVertices = new Vec3[trailVertexCount];
+    trailVertices = new Vector3[trailVertexCount];
 
     // prepare trailFlags array: free old one if needed, allocate new one
     delete[] trailFlags;
@@ -303,7 +303,7 @@
 template<class Super>
 void 
 OpenSteer::AnnotationMixin<Super>::recordTrailVertex (const float currentTime,
-                                                      const Vec3& position)
+                                                      const Vector3& position)
 {
     const float timeSinceLastTrailSample = currentTime - trailLastSampleTime;
     if (timeSinceLastTrailSample > trailSampleInterval)
@@ -382,8 +382,8 @@
 #ifndef NOT_OPENSTEERDEMO  // only when building OpenSteerDemo
 template<class Super>
 void 
-OpenSteer::AnnotationMixin<Super>::annotationLine (const Vec3& startPoint,
-                                                   const Vec3& endPoint,
+OpenSteer::AnnotationMixin<Super>::annotationLine (const Vector3& startPoint,
+                                                   const Vector3& endPoint,
                                                    const Color& color) const
 {
     if (enableAnnotation)
@@ -400,7 +400,7 @@
 }
 #else
 template<class Super> void OpenSteer::AnnotationMixin<Super>::annotationLine
- (const Vec3&, const Vec3&, const Vec3&) const {}
+ (const Vector3&, const Vector3&, const Vector3&) const {}
 #endif // NOT_OPENSTEERDEMO
 
 
@@ -416,8 +416,8 @@
 template<class Super>
 void 
 OpenSteer::AnnotationMixin<Super>::annotationCircleOrDisk (const float radius,
-                                                           const Vec3& axis,
-                                                           const Vec3& center,
+                                                           const Vector3& axis,
+                                                           const Vector3& center,
                                                            const Color& color,
                                                            const int segments,
                                                            const bool filled,
@@ -440,7 +440,7 @@
 #else
 template<class Super>
 void OpenSteer::AnnotationMixin<Super>::annotationCircleOrDisk
-(const float, const Vec3&, const Vec3&, const Vec3&, const int,
+(const float, const Vector3&, const Vector3&, const Vector3&, const int,
  const bool, const bool) const {}
 #endif // NOT_OPENSTEERDEMO
 

Modified: dependencies/opensteer/include/OpenSteer/Camera.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
         void reset (void);
 
         // "look at" point, center of view
-        Vec3 target;
+        Vector3 target;
 
         // vehicle being tracked
         const AbstractVehicle* vehicleToTrack;
@@ -81,12 +81,12 @@
         {update (currentTime, elapsedTime, false);};
 
         // helper function for "drag behind" mode
-        Vec3 constDistHelper (const float elapsedTime);
+        Vector3 constDistHelper (const float elapsedTime);
 
         // Smoothly move camera ...
-        void smoothCameraMove (const Vec3& newPosition,
-                               const Vec3& newTarget,
-                               const Vec3& newUp,
+        void smoothCameraMove (const Vector3& newPosition,
+                               const Vector3& newTarget,
+                               const Vector3& newUp,
                                const float elapsedTime);
 
         void doNotSmoothNextMove (void) {smoothNextMove = false;};
@@ -96,15 +96,15 @@
 
         // adjust the offset vector of the current camera mode based on a
         // "mouse adjustment vector" from OpenSteerDemo (xxx experiment 10-17-02)
-        void mouseAdjustOffset (const Vec3& adjustment);
-        Vec3 mouseAdjust2 (const bool polar,
-                           const Vec3& adjustment,
-                           const Vec3& offsetToAdjust);
-        Vec3 mouseAdjustPolar (const Vec3& adjustment,
-                               const Vec3& offsetToAdjust)
+        void mouseAdjustOffset (const Vector3& adjustment);
+        Vector3 mouseAdjust2 (const bool polar,
+                           const Vector3& adjustment,
+                           const Vector3& offsetToAdjust);
+        Vector3 mouseAdjustPolar (const Vector3& adjustment,
+                               const Vector3& offsetToAdjust)
         {return mouseAdjust2 (true, adjustment, offsetToAdjust);};
-        Vec3 mouseAdjustOrtho (const Vec3& adjustment,
-                               const Vec3& offsetToAdjust)
+        Vector3 mouseAdjustOrtho (const Vector3& adjustment,
+                               const Vector3& offsetToAdjust)
         {return mouseAdjust2 (false, adjustment, offsetToAdjust);};
 
         // xxx since currently (10-21-02) the camera's Forward and Side basis
@@ -160,9 +160,9 @@
         cameraMode successorMode (const cameraMode cm) const;
 
         // "static" camera mode parameters
-        Vec3 fixedPosition;
-        Vec3 fixedTarget;
-        Vec3 fixedUp;
+        Vector3 fixedPosition;
+        Vector3 fixedTarget;
+        Vector3 fixedUp;
 
         // "constant distance from vehicle" camera mode parameters
         float fixedDistDistance;             // desired distance from it
@@ -172,10 +172,10 @@
         float lookdownDistance;             // fixed vertical offset from it
 
         // "fixed local offset" camera mode parameters
-        Vec3 fixedLocalOffset;
+        Vector3 fixedLocalOffset;
 
         // "offset POV" camera mode parameters
-        Vec3 povOffset;
+        Vector3 povOffset;
     };
 
 } // namespace OpenSteer

Modified: dependencies/opensteer/include/OpenSteer/Color.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Color.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Color.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,21 +39,17 @@
 #ifndef OPENSTEER_COLOR_H
 #define OPENSTEER_COLOR_H
 
+#include "OpenSteer/Vec3.h"
 
 
-
 namespace OpenSteer {
     
-    // Forward declaration. Full declaration in Vec3.h
-    class Vec3;
-    
-    
     class Color {
     public:
         Color();
         explicit Color( float greyValue );
         Color( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        explicit Color( Vec3 const& vector );
+        explicit Color( Vector3 const& vector );
         
         float r() const;
         float g() const;
@@ -66,7 +62,7 @@
 		void setA( float value );
         void set( float rValue, float gValue, float bValue, float aValue = 1.0f );
         
-        Vec3 convertToVec3() const;
+        Vector3 convertToVec3() const;
     
 		// this is necessary so that graphics API's such as DirectX
 		// requiring a pointer to colors can do their conversion

Modified: dependencies/opensteer/include/OpenSteer/Draw.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Draw.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Draw.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -85,9 +85,9 @@
     // ----------------------------------------------------------------------------
     // this is a typedef for a triangle draw routine which can be passed in
     // when using rendering API's of the user's choice.
-    typedef void (*drawTriangleRoutine) (const Vec3& a,
-                                         const Vec3& b,
-                                         const Vec3& c,
+    typedef void (*drawTriangleRoutine) (const Vector3& a,
+                                         const Vector3& b,
+                                         const Vector3& c,
                                          const Color& color);
 
     // ------------------------------------------------------------------------
@@ -97,7 +97,7 @@
 
 
     void drawAxes  (const AbstractLocalSpace& localSpace,
-                    const Vec3& size,
+                    const Vector3& size,
                     const Color& color);
 
 
@@ -109,7 +109,7 @@
 
 
     void drawBoxOutline  (const AbstractLocalSpace& localSpace,
-                          const Vec3& size,
+                          const Vector3& size,
                           const Color& color);
 
 
@@ -125,7 +125,7 @@
 
     void drawXZCheckerboardGrid (const float size,
                                  const int subsquares,
-                                 const Vec3& center,
+                                 const Vector3& center,
                                  const Color& color1,
                                  const Color& color2);
 
@@ -141,7 +141,7 @@
 
     void drawXZLineGrid (const float size,
                          const int subsquares,
-                         const Vec3& center,
+                         const Vector3& center,
                          const Color& color);
 
 
@@ -150,28 +150,28 @@
 
 
     void drawCircleOrDisk (const float radius,
-                           const Vec3& axis,
-                           const Vec3& center,
+                           const Vector3& axis,
+                           const Vector3& center,
                            const Color& color,
                            const int segments,
                            const bool filled,
                            const bool in3d);
 
     void drawXZCircleOrDisk (const float radius,
-                             const Vec3& center,
+                             const Vector3& center,
                              const Color& color,
                              const int segments,
                              const bool filled);
 
     void draw3dCircleOrDisk (const float radius,
-                             const Vec3& center,
-                             const Vec3& axis,
+                             const Vector3& center,
+                             const Vector3& axis,
                              const Color& color,
                              const int segments,
                              const bool filled);
 
     inline void drawXZCircle (const float radius,
-                              const Vec3& center,
+                              const Vector3& center,
                               const Color& color,
                               const int segments)
     {
@@ -180,7 +180,7 @@
     }
 
     inline void drawXZDisk (const float radius,
-                            const Vec3& center,
+                            const Vector3& center,
                             const Color& color,
                             const int segments)
     {
@@ -189,8 +189,8 @@
     }
 
     inline void draw3dCircle (const float radius,
-                              const Vec3& center,
-                              const Vec3& axis,
+                              const Vector3& center,
+                              const Vector3& axis,
                               const Color& color,
                               const int segments)
     {
@@ -199,8 +199,8 @@
     }
 
     inline void draw3dDisk (const float radius,
-                            const Vec3& center,
-                            const Vec3& axis,
+                            const Vector3& center,
+                            const Vector3& axis,
                             const Color& color,
                             const int segments)
     {
@@ -213,8 +213,8 @@
     // for a given arc length, in a given number of segments and color.  The
     // sign of arcLength determines the direction in which the arc is drawn.
 
-    void drawXZArc (const Vec3& start,
-                    const Vec3& center,
+    void drawXZArc (const Vector3& start,
+                    const Vector3& center,
                     const float arcLength,
                     const int segments,
                     const Color& color);
@@ -225,21 +225,21 @@
 
 
     // draw a sphere (wireframe or opaque, with front/back/both culling)
-    void drawSphere (const Vec3 center,
+    void drawSphere (const Vector3 center,
                      const float radius,
                      const float maxEdgeLength,
                      const bool filled,
                      const Color& color,
                      const bool drawFrontFacing = true,
                      const bool drawBackFacing = true,
-                     const Vec3& viewpoint = Vec3::zero);
+                     const Vector3& viewpoint = Vector3::ZERO);
 
     // draw a SphereObstacle
     void drawSphereObstacle (const SphereObstacle& so,
                              const float maxEdgeLength,
                              const bool filled,
                              const Color& color,
-                             const Vec3& viewpoint);
+                             const Vector3& viewpoint);
 
 
     // ------------------------------------------------------------------------
@@ -268,42 +268,42 @@
     // for every graphics API
 
     void draw2dTextAt3dLocation (const char& text,
-                                 const Vec3& location,
+                                 const Vector3& location,
                                  const Color& color, float w, float h);
 
     void draw2dTextAt3dLocation (const std::ostringstream& text,
-                                 const Vec3& location,
+                                 const Vector3& location,
                                  const Color& color, float w, float h);
 
     void draw2dTextAt2dLocation (const char& text,
-                                 const Vec3 location,
+                                 const Vector3 location,
                                  const Color& color, float w, float h);
 
     void draw2dTextAt2dLocation (const std::ostringstream& text,
-                                 const Vec3 location,
+                                 const Vector3 location,
                                  const Color& color, float w, float h);
 
     // ------------------------------------------------------------------------
-    // emit an OpenGL vertex based on a Vec3
+    // emit an OpenGL vertex based on a Vector3
 
 
-    void glVertexVec3 (const Vec3& v);
+    void glVertexVec3 (const Vector3& v);
 
 
     // ----------------------------------------------------------------------------
     // draw 3d "graphical annotation" lines, used for debugging
 
 
-    void drawLine (const Vec3& startPoint,
-                   const Vec3& endPoint,
+    void drawLine (const Vector3& startPoint,
+                   const Vector3& endPoint,
                    const Color& color);
 
 
     // ----------------------------------------------------------------------------
     // draw 2d lines in screen space: x and y are the relevant coordinates
     // w and h are the dimensions of the viewport in pixels
-    void draw2dLine (const Vec3& startPoint,
-                    const Vec3& endPoint,
+    void draw2dLine (const Vector3& startPoint,
+                    const Vector3& endPoint,
                     const Color& color,
                     float w, float h);
 
@@ -311,8 +311,8 @@
     // ----------------------------------------------------------------------------
     // draw a line with alpha blending
 
-    void drawLineAlpha (const Vec3& startPoint,
-                        const Vec3& endPoint,
+    void drawLineAlpha (const Vector3& startPoint,
+                        const Vector3& endPoint,
                         const Color& color,
                         const float alpha);
 
@@ -321,13 +321,13 @@
     // deferred drawing of lines, circles and (filled) disks
 
 
-    void deferredDrawLine (const Vec3& startPoint,
-                           const Vec3& endPoint,
+    void deferredDrawLine (const Vector3& startPoint,
+                           const Vector3& endPoint,
                            const Color& color);
 
     void deferredDrawCircleOrDisk (const float radius,
-                                   const Vec3& axis,
-                                   const Vec3& center,
+                                   const Vector3& axis,
+                                   const Vector3& center,
                                    const Color& color,
                                    const int segments,
                                    const bool filled,
@@ -338,23 +338,23 @@
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL triangle given three Vec3 vertices.
+    // Draw a single OpenGL triangle given three Vector3 vertices.
 
 
-    void drawTriangle (const Vec3& a,
-                       const Vec3& b,
-                       const Vec3& c,
+    void drawTriangle (const Vector3& a,
+                       const Vector3& b,
+                       const Vector3& c,
                        const Color& color);
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL quadrangle given four Vec3 vertices, and color.
+    // Draw a single OpenGL quadrangle given four Vector3 vertices, and color.
 
 
-    void drawQuadrangle (const Vec3& a,
-                         const Vec3& b,
-                         const Vec3& c,
-                         const Vec3& d,
+    void drawQuadrangle (const Vector3& a,
+                         const Vector3& b,
+                         const Vector3& c,
+                         const Vector3& d,
                          const Color& color);
 
 
@@ -363,8 +363,8 @@
     // whose mid-line connects two given endpoints
 
 
-    void drawXZWideLine (const Vec3& startPoint,
-                         const Vec3& endPoint,
+    void drawXZWideLine (const Vector3& startPoint,
+                         const Vector3& endPoint,
                          const Color& color,
                          float width);
 
@@ -372,9 +372,9 @@
     // ----------------------------------------------------------------------------
 
 
-    void drawCameraLookAt (const Vec3& cameraPosition,
-                           const Vec3& pointToLookAt,
-                           const Vec3& up);
+    void drawCameraLookAt (const Vector3& cameraPosition,
+                           const Vector3& pointToLookAt,
+                           const Vector3& up);
 
 
     // ----------------------------------------------------------------------------
@@ -390,7 +390,7 @@
     // given point on the screen: the ray that would be traced for that pixel
 
 
-    Vec3 directionFromCameraToScreenPosition (int x, int y, int h);
+    Vector3 directionFromCameraToScreenPosition (int x, int y, int h);
 
 
 

Modified: dependencies/opensteer/include/OpenSteer/LocalSpace.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -80,14 +80,14 @@
         
 
         // accessors (get and set) for side, up, forward and position
-        virtual Vec3 side (void) const = 0;
-        virtual Vec3 setSide (Vec3 s) = 0;
-        virtual Vec3 up (void) const = 0;
-        virtual Vec3 setUp (Vec3 u) = 0;
-        virtual Vec3 forward (void) const = 0;
-        virtual Vec3 setForward (Vec3 f) = 0;
-        virtual Vec3 position (void) const = 0;
-        virtual Vec3 setPosition (Vec3 p) = 0;
+        virtual Vector3 side (void) const = 0;
+        virtual Vector3 setSide (Vector3 s) = 0;
+        virtual Vector3 up (void) const = 0;
+        virtual Vector3 setUp (Vector3 u) = 0;
+        virtual Vector3 forward (void) const = 0;
+        virtual Vector3 setForward (Vector3 f) = 0;
+        virtual Vector3 position (void) const = 0;
+        virtual Vector3 setPosition (Vector3 p) = 0;
 
         // use right-(or left-)handed coordinate space
         virtual bool rightHanded (void) const = 0;
@@ -96,34 +96,34 @@
         virtual void resetLocalSpace (void) = 0;
 
         // transform a direction in global space to its equivalent in local space
-        virtual Vec3 localizeDirection (const Vec3& globalDirection) const = 0;
+        virtual Vector3 localizeDirection (const Vector3& globalDirection) const = 0;
 
         // transform a point in global space to its equivalent in local space
-        virtual Vec3 localizePosition (const Vec3& globalPosition) const = 0;
+        virtual Vector3 localizePosition (const Vector3& globalPosition) const = 0;
 
         // transform a point in local space to its equivalent in global space
-        virtual Vec3 globalizePosition (const Vec3& localPosition) const = 0;
+        virtual Vector3 globalizePosition (const Vector3& localPosition) const = 0;
 
         // transform a direction in local space to its equivalent in global space
-        virtual Vec3 globalizeDirection (const Vec3& localDirection) const = 0;
+        virtual Vector3 globalizeDirection (const Vector3& localDirection) const = 0;
 
         // set "side" basis vector to normalized cross product of forward and up
         virtual void setUnitSideFromForwardAndUp (void) = 0;
 
         // regenerate the orthonormal basis vectors given a new forward
         // (which is expected to have unit length)
-        virtual void regenerateOrthonormalBasisUF (const Vec3& newUnitForward) = 0;
+        virtual void regenerateOrthonormalBasisUF (const Vector3& newUnitForward) = 0;
 
         // for when the new forward is NOT of unit length
-        virtual void regenerateOrthonormalBasis (const Vec3& newForward) = 0;
+        virtual void regenerateOrthonormalBasis (const Vector3& newForward) = 0;
 
         // for supplying both a new forward and and new up
-        virtual void regenerateOrthonormalBasis (const Vec3& newForward,
-                                                 const Vec3& newUp) = 0;
+        virtual void regenerateOrthonormalBasis (const Vector3& newForward,
+                                                 const Vector3& newUp) = 0;
 
         // rotate 90 degrees in the direction implied by rightHanded()
-        virtual Vec3 localRotateForwardToSide (const Vec3& v) const = 0;
-        virtual Vec3 globalRotateForwardToSide (const Vec3& globalForward) const=0;
+        virtual Vector3 localRotateForwardToSide (const Vector3& v) const = 0;
+        virtual Vector3 globalRotateForwardToSide (const Vector3& globalForward) const=0;
     };
 
 
@@ -141,26 +141,26 @@
 
     private:
 
-        Vec3 _side;     //    side-pointing unit basis vector
-        Vec3 _up;       //  upward-pointing unit basis vector
-        Vec3 _forward;  // forward-pointing unit basis vector
-        Vec3 _position; // origin of local space
+        Vector3 _side;     //    side-pointing unit basis vector
+        Vector3 _up;       //  upward-pointing unit basis vector
+        Vector3 _forward;  // forward-pointing unit basis vector
+        Vector3 _position; // origin of local space
 
     public:
 
         // accessors (get and set) for side, up, forward and position
-        Vec3 side     (void) const {return _side;};
-        Vec3 up       (void) const {return _up;};
-        Vec3 forward  (void) const {return _forward;};
-        Vec3 position (void) const {return _position;};
-        Vec3 setSide     (Vec3 s) {return _side = s;};
-        Vec3 setUp       (Vec3 u) {return _up = u;};
-        Vec3 setForward  (Vec3 f) {return _forward = f;};
-        Vec3 setPosition (Vec3 p) {return _position = p;};
-        Vec3 setSide     (float x, float y, float z){return _side.set    (x,y,z);};
-        Vec3 setUp       (float x, float y, float z){return _up.set      (x,y,z);};
-        Vec3 setForward  (float x, float y, float z){return _forward.set (x,y,z);};
-        Vec3 setPosition (float x, float y, float z){return _position.set(x,y,z);};
+        Vector3 side     (void) const {return _side;}
+        Vector3 up       (void) const {return _up;}
+        Vector3 forward  (void) const {return _forward;}
+        Vector3 position (void) const {return _position;}
+        Vector3 setSide     (Vector3 s) {return _side = s;}
+        Vector3 setUp       (Vector3 u) {return _up = u;}
+        Vector3 setForward  (Vector3 f) {return _forward = f;}
+        Vector3 setPosition (Vector3 p) {return _position = p;}
+        Vector3 setSide     (float x, float y, float z){return _side = Vector3(x,y,z);}
+        Vector3 setUp       (float x, float y, float z){return _up = Vector3(x,y,z);}
+        Vector3 setForward  (float x, float y, float z){return _forward = Vector3(x,y,z);}
+        Vector3 setPosition (float x, float y, float z){return _position = Vector3(x,y,z);}
 
 
         // ------------------------------------------------------------------------
@@ -180,16 +180,16 @@
             resetLocalSpace ();
         };
 
-        LocalSpaceMixin (const Vec3& Side,
-                         const Vec3& Up,
-                         const Vec3& Forward,
-                         const Vec3& Position)
+        LocalSpaceMixin (const Vector3& Side,
+                         const Vector3& Up,
+                         const Vector3& Forward,
+                         const Vector3& Position)
             : _side( Side ), _up( Up ), _forward( Forward ), _position( Position ) {}
 
 
-        LocalSpaceMixin (const Vec3& Up,
-                         const Vec3& Forward,
-                         const Vec3& Position)
+        LocalSpaceMixin (const Vector3& Up,
+                         const Vector3& Forward,
+                         const Vector3& Position)
             : _side(), _up( Up ), _forward( Forward ), _position( Position )
         {
             setUnitSideFromForwardAndUp ();
@@ -212,10 +212,10 @@
 
         void resetLocalSpace (void)
         {
-            _forward.set (0, 0, 1);
+            _forward = Vector3(0, 0, 1);
             _side = localRotateForwardToSide (_forward);
-            _up.set (0, 1, 0);
-            _position.set (0, 0, 0);
+            _up = Vector3(0, 1, 0);
+            _position = Vector3(0, 0, 0);
         };
 
 
@@ -223,12 +223,12 @@
         // transform a direction in global space to its equivalent in local space
 
 
-        Vec3 localizeDirection (const Vec3& globalDirection) const
+        Vector3 localizeDirection (const Vector3& globalDirection) const
         {
             // dot offset with local basis vectors to obtain local coordiantes
-            return Vec3 (globalDirection.dot (_side),
-                         globalDirection.dot (_up),
-                         globalDirection.dot (_forward));
+            return Vector3 (globalDirection.dotProduct(_side),
+                         globalDirection.dotProduct(_up),
+                         globalDirection.dotProduct(_forward));
         };
 
 
@@ -236,10 +236,10 @@
         // transform a point in global space to its equivalent in local space
 
 
-        Vec3 localizePosition (const Vec3& globalPosition) const
+        Vector3 localizePosition (const Vector3& globalPosition) const
         {
             // global offset from local origin
-            Vec3 globalOffset = globalPosition - _position;
+            Vector3 globalOffset = globalPosition - _position;
 
             // dot offset with local basis vectors to obtain local coordiantes
             return localizeDirection (globalOffset);
@@ -250,7 +250,7 @@
         // transform a point in local space to its equivalent in global space
 
 
-        Vec3 globalizePosition (const Vec3& localPosition) const
+        Vector3 globalizePosition (const Vector3& localPosition) const
         {
             return _position + globalizeDirection (localPosition);
         };
@@ -260,7 +260,7 @@
         // transform a direction in local space to its equivalent in global space
 
 
-        Vec3 globalizeDirection (const Vec3& localDirection) const
+        Vector3 globalizeDirection (const Vector3& localDirection) const
         {
             return ((_side    * localDirection.x) +
                     (_up      * localDirection.y) +
@@ -276,10 +276,10 @@
         {
             // derive new unit side basis vector from forward and up
             if (rightHanded())
-                _side.cross (_forward, _up);
+                _side = _forward.crossProduct(_up);
             else
-                _side.cross (_up, _forward);
-            _side = _side.normalize ();
+                _side = _up.crossProduct(_forward);
+            _side = _side.normalisedCopy();
         }
 
 
@@ -288,7 +288,7 @@
         // (which is expected to have unit length)
 
 
-        void regenerateOrthonormalBasisUF (const Vec3& newUnitForward)
+        void regenerateOrthonormalBasisUF (const Vector3& newUnitForward)
         {
             _forward = newUnitForward;
 
@@ -299,27 +299,27 @@
             // (should have unit length since Side and Forward are
             // perpendicular and unit length)
             if (rightHanded())
-                _up.cross (_side, _forward);
+                _up = _side.crossProduct(_forward);
             else
-                _up.cross (_forward, _side);
+                _up = _forward.crossProduct(_side);
         }
 
 
         // for when the new forward is NOT know to have unit length
 
-        void regenerateOrthonormalBasis (const Vec3& newForward)
+        void regenerateOrthonormalBasis (const Vector3& newForward)
         {
-            regenerateOrthonormalBasisUF (newForward.normalize());
+            regenerateOrthonormalBasisUF (newForward.normalisedCopy());
         }
 
 
         // for supplying both a new forward and and new up
 
-        void regenerateOrthonormalBasis (const Vec3& newForward,
-                                         const Vec3& newUp)
+        void regenerateOrthonormalBasis (const Vector3& newForward,
+                                         const Vector3& newUp)
         {
             _up = newUp;
-            regenerateOrthonormalBasis (newForward.normalize());
+            regenerateOrthonormalBasis (newForward.normalisedCopy());
         }
 
 
@@ -328,19 +328,19 @@
         // "forward" (+Z) direction to the "side" (+/-X) direction
 
 
-        Vec3 localRotateForwardToSide (const Vec3& v) const
+        Vector3 localRotateForwardToSide (const Vector3& v) const
         {
-            return Vec3 (rightHanded () ? -v.z : +v.z,
+            return Vector3 (rightHanded () ? -v.z : +v.z,
                          v.y,
                          v.x);
         }
 
         // not currently used, just added for completeness
 
-        Vec3 globalRotateForwardToSide (const Vec3& globalForward) const
+        Vector3 globalRotateForwardToSide (const Vector3& globalForward) const
         {
-            const Vec3 localForward = localizeDirection (globalForward);
-            const Vec3 localSide = localRotateForwardToSide (localForward);
+            const Vector3 localForward = localizeDirection (globalForward);
+            const Vector3 localSide = localRotateForwardToSide (localForward);
             return globalizeDirection (localSide);
         }
     };

Modified: dependencies/opensteer/include/OpenSteer/Obstacle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Obstacle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Obstacle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -67,7 +67,7 @@
         
         
         // compute steering for a vehicle to avoid this obstacle, if needed
-        virtual Vec3 steerToAvoid (const AbstractVehicle& v,
+        virtual Vector3 steerToAvoid (const AbstractVehicle& v,
                                    const float minTimeToCollision) const = 0;
 
         // PathIntersection object: used internally to analyze and store
@@ -77,14 +77,14 @@
         public:
             bool intersect; // was an intersection found?
             float distance; // how far was intersection point from vehicle?
-            Vec3 surfacePoint; // position of intersection
-            Vec3 surfaceNormal; // unit normal at point of intersection
-            Vec3 steerHint; // where to steer away from intersection
+            Vector3 surfacePoint; // position of intersection
+            Vector3 surfaceNormal; // unit normal at point of intersection
+            Vector3 steerHint; // where to steer away from intersection
             bool vehicleOutside; // is the vehicle outside the obstacle?
             const AbstractObstacle* obstacle; // obstacle the path intersects
 
             // determine steering based on path intersection tests
-            Vec3 steerToAvoidIfNeeded (const AbstractVehicle& vehicle,
+            Vector3 steerToAvoidIfNeeded (const AbstractVehicle& vehicle,
                                        const float minTimeToCollision) const;
 
         };
@@ -101,7 +101,7 @@
         // specialized by derived types to provide graphics for obstacles
         virtual void draw (const bool filled,
                            const Color& color,
-                           const Vec3& viewpoint)
+                           const Vector3& viewpoint)
             const
             = 0 ;
 
@@ -134,13 +134,13 @@
         virtual ~Obstacle() { /* Nothing to do. */ }
         
         // compute steering for a vehicle to avoid this obstacle, if needed 
-        Vec3 steerToAvoid (const AbstractVehicle& v,
+        Vector3 steerToAvoid (const AbstractVehicle& v,
                            const float minTimeToCollision)
             const;
 
         // static method to apply steerToAvoid to nearest obstacle in an
         // ObstacleGroup
-        static Vec3 steerToAvoidObstacles (const AbstractVehicle& vehicle,
+        static Vector3 steerToAvoidObstacles (const AbstractVehicle& vehicle,
                                            const float minTimeToCollision,
                                            const ObstacleGroup& obstacles);
 
@@ -153,7 +153,7 @@
                                                 PathIntersection& next);
 
         // default do-nothing draw function (derived class can overload this)
-        void draw (const bool, const Color&, const Vec3&) const {}
+        void draw (const bool, const Color&, const Vector3&) const {}
 
         seenFromState seenFrom (void) const {return _seenFrom;}
         void setSeenFrom (seenFromState s) {_seenFrom = s;}
@@ -170,11 +170,11 @@
     {
     public:
         float radius;
-        Vec3 center;
+        Vector3 center;
 
         // constructors
-        SphereObstacle (float r, Vec3 c) : radius(r), center (c) {}
-        SphereObstacle (void) : radius(1), center (Vec3::zero) {}
+        SphereObstacle (float r, Vector3 c) : radius(r), center (c) {}
+        SphereObstacle (void) : radius(1), center (Vector3::ZERO) {}
 
         virtual ~SphereObstacle() { /* Nothing to do. */ }
         
@@ -235,10 +235,10 @@
     public:
         // constructors
         PlaneObstacle (void) {}
-        PlaneObstacle (const Vec3& s,
-                       const Vec3& u,
-                       const Vec3& f,
-                       const Vec3& p)
+        PlaneObstacle (const Vector3& s,
+                       const Vector3& u,
+                       const Vector3& f,
+                       const Vector3& p)
         : LocalSpaceObstacle( s, u, f, p )
         {
             /*
@@ -255,7 +255,7 @@
             const;
 
         // determines if a given point on XY plane is inside obstacle shape
-        virtual bool xyPointInsideShape (const Vec3& /*point*/,
+        virtual bool xyPointInsideShape (const Vector3& /*point*/,
                                          float /*radius*/) const
         {
             return true; // always true for PlaneObstacle
@@ -278,8 +278,8 @@
         // constructors
         RectangleObstacle (float w, float h) : width(w), height(h) {}
         RectangleObstacle (void) :  width(1.0f), height(1.0f) {}
-        RectangleObstacle (float w, float h, const Vec3& s,
-                           const Vec3& u, const Vec3& f, const Vec3& p,
+        RectangleObstacle (float w, float h, const Vector3& s,
+                           const Vector3& u, const Vector3& f, const Vector3& p,
                            seenFromState sf) 
             : PlaneObstacle( s, u, f, p ), width(w), height(h)
         {
@@ -295,7 +295,7 @@
         virtual ~RectangleObstacle() { /* Nothing to do. */ }
 
         // determines if a given point on XY plane is inside obstacle shape
-        bool xyPointInsideShape (const Vec3& point, float radius) const;
+        bool xyPointInsideShape (const Vector3& point, float radius) const;
     };
 
 

Modified: dependencies/opensteer/include/OpenSteer/OldPathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/OldPathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/OldPathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,28 +65,28 @@
             // this path.  Also returns, via output arguments, the path tangent at
             // P and a measure of how far A is outside the Pathway's "tube".  Note
             // that a negative distance indicates A is inside the Pathway.
-            virtual Vec3 mapPointToPath (const Vec3& point,
-                Vec3& tangent,
+            virtual Vector3 mapPointToPath (const Vector3& point,
+                Vector3& tangent,
                 float& outside) = 0;
 
             // given a distance along the path, convert it to a point on the path
-            virtual Vec3 mapPathDistanceToPoint (float pathDistance) = 0;
+            virtual Vector3 mapPathDistanceToPoint (float pathDistance) = 0;
 
             // Given an arbitrary point, convert it to a distance along the path.
-            virtual float mapPointToPathDistance (const Vec3& point) = 0;
+            virtual float mapPointToPathDistance (const Vector3& point) = 0;
 
             // is the given point inside the path tube?
-            bool isInsidePath (const Vec3& point)
+            bool isInsidePath (const Vector3& point)
             {
-                float outside; Vec3 tangent;
+                float outside; Vector3 tangent;
                 mapPointToPath (point, tangent, outside);
                 return outside < 0;
             }
 
             // how far outside path tube is the given point?  (negative is inside)
-            float howFarOutsidePath (const Vec3& point)
+            float howFarOutsidePath (const Vector3& point)
             {
-                float outside; Vec3 tangent;
+                float outside; Vector3 tangent;
                 mapPointToPath (point, tangent, outside);
                 return outside;
             }
@@ -106,7 +106,7 @@
         public:
 
             int pointCount;
-            Vec3* points;
+            Vector3* points;
             float radius;
             bool cyclic;
 
@@ -116,13 +116,13 @@
             // construct a PolylinePathway given the number of points (vertices),
             // an array of points, and a path radius.
             PolylinePathway (const int _pointCount,
-                const Vec3 _points[],
+                const Vector3 _points[],
                 const float _radius,
                 const bool _cyclic);
 
             // utility for constructors in derived classes
             void initialize (const int _pointCount,
-                const Vec3 _points[],
+                const Vector3 _points[],
                 const float _radius,
                 const bool _cyclic);
 
@@ -133,27 +133,27 @@
             // move existing points safely
             void movePoints (const int _firstPoint,
                             const int _numPoints,
-                            const Vec3 _points[]);
+                            const Vector3 _points[]);
 
             // Given an arbitrary point ("A"), returns the nearest point ("P") on
             // this path.  Also returns, via output arguments, the path tangent at
             // P and a measure of how far A is outside the Pathway's "tube".  Note
             // that a negative distance indicates A is inside the Pathway.
-            Vec3 mapPointToPath (const Vec3& point, Vec3& tangent, float& outside);
+            Vector3 mapPointToPath (const Vector3& point, Vector3& tangent, float& outside);
 
 
             // given an arbitrary point, convert it to a distance along the path
-            float mapPointToPathDistance (const Vec3& point);
+            float mapPointToPathDistance (const Vector3& point);
 
             // given a distance along the path, convert it to a point on the path
-            Vec3 mapPathDistanceToPoint (float pathDistance);
+            Vector3 mapPathDistanceToPoint (float pathDistance);
 
             // utility methods
 
             // compute minimum distance from a point to a line segment
-            float pointToSegmentDistance (const Vec3& point,
-                const Vec3& ep0,
-                const Vec3& ep1);
+            float pointToSegmentDistance (const Vector3& point,
+                const Vector3& ep0,
+                const Vector3& ep1);
 
             // assessor for total path length;
             float getTotalPathLength (void) {return totalPathLength;};
@@ -167,12 +167,12 @@
             // xxx seems like a bad design
             float segmentLength;
             float segmentProjection;
-            Vec3 local;
-            Vec3 chosen;
-            Vec3 segmentNormal;
+            Vector3 local;
+            Vector3 chosen;
+            Vector3 segmentNormal;
 
             float* lengths;
-            Vec3* normals;
+            Vector3* normals;
             float totalPathLength;
         };
 

Modified: dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -52,13 +52,10 @@
 #include "OpenSteer/PlugIn.h"
 #include "OpenSteer/Camera.h"
 #include "OpenSteer/Utilities.h"
+#include "OpenSteer/Color.h"
 
-
 namespace OpenSteer {
 
-    class Color;
-    class Vec3;
-    
 
     class OpenSteerDemo
     {
@@ -206,7 +203,7 @@
         // some camera-related default constants
         static const float camera2dElevation;
         static const float cameraTargetDistance;
-        static const Vec3 cameraTargetOffset;
+        static const Vector3 cameraTargetOffset;
 
         // ------------------------------------------------ graphics and annotation
 
@@ -214,7 +211,7 @@
         static void initializeGraphics (void);
 
         // ground plane grid-drawing utility used by several plug-ins
-        static void gridUtility (const Vec3& gridTarget);
+        static void gridUtility (const Vector3& gridTarget);
 
         // draws a gray disk on the XZ plane under a given vehicle
         static void highlightVehicleUtility (const AbstractVehicle& vehicle);

Modified: dependencies/opensteer/include/OpenSteer/Path.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Path.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Path.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -31,15 +31,12 @@
 #define OPENSTEER_PATH_H
 
 
+#include "OpenSteer/Vec3.h"
 
 
-
 namespace OpenSteer {
 
-    // Forward declaration.
-    class Vec3;
     
-    
     /**
      * Path in space that might be cyclic.
      *
@@ -66,21 +63,21 @@
          *
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPointToPath (const Vec3& point,
-                                     Vec3& tangent,
+		virtual Vector3 mapPointToPath (const Vector3& point,
+                                     Vector3& tangent,
                                      float& outside) const = 0;
         
 		/**
          * Given a distance along the path, convert it to a point on the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const = 0;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
         
 		/**
          * Given an arbitrary point, convert it to a distance along the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual float mapPointToPathDistance (const Vec3& point) const = 0;
+		virtual float mapPointToPathDistance (const Vector3& point) const = 0;
         
         /**
          * Returns @c true f the path is closed, otherwise @c false.

Modified: dependencies/opensteer/include/OpenSteer/Pathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Pathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Pathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -30,14 +30,11 @@
 #ifndef OPENSTEER_PATHWAY_H
 #define OPENSTEER_PATHWAY_H
 
+#include "OpenSteer/Vec3.h"
+
 namespace OpenSteer {
     
-    // Forward declaration, include Vec3.h if needed.
-    // @todo Include Vec3.h?
-    class Vec3;
     
-    
-    
     /**
      * Pure virtual base class representing an abstract pathway in space.
      * Could be used for example in path following.
@@ -60,21 +57,21 @@
          *
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPointToPath (const Vec3& point,
-                                     Vec3& tangent,
+		virtual Vector3 mapPointToPath (const Vector3& point,
+                                     Vector3& tangent,
                                      float& outside) const = 0;
         
 		/**
          * Given a distance along the path, convert it to a point on the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const = 0;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
         
 		/**
          * Given an arbitrary point, convert it to a distance along the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual float mapPointToPathDistance (const Vec3& point) const = 0;
+		virtual float mapPointToPathDistance (const Vector3& point) const = 0;
         
         /**
          * Returns @c true f the path is closed, otherwise @c false.

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -43,7 +43,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::distance
@@ -81,7 +81,7 @@
          *                    cycle closing segment.
          */
         PolylineSegmentedPath( size_type numOfPoints,
-                               Vec3 const newPoints[],
+                               Vector3 const newPoints[],
                                bool closedCycle );
         
         PolylineSegmentedPath( PolylineSegmentedPath const& other );
@@ -105,7 +105,7 @@
          *                    cycle closing segment.
          */
         void setPath( size_type numOfPoints,
-                      Vec3 const newPoints[],
+                      Vector3 const newPoints[],
                       bool closedCycle );
         
         /**
@@ -127,49 +127,49 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const newPoints[]);
+                         Vector3 const newPoints[]);
         
         
         
         virtual bool isValid() const;
-        virtual Vec3 mapPointToPath (const Vec3& point,
-                                     Vec3& tangent,
+        virtual Vector3 mapPointToPath (const Vector3& point,
+                                     Vector3& tangent,
                                      float& outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3& point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3& point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;        
+        virtual Vector3 point( size_type pointIndex ) const;        
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const& point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const& point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                           float distance,
-                                                          Vec3& pointOnPath,
-                                                          Vec3& tangent ) const;
+                                                          Vector3& pointOnPath,
+                                                          Vector3& tangent ) const;
         
         virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vec3 const& point,
+                                                                  Vector3 const& point,
                                                                   float& distance,
-                                                                  Vec3& pointOnPath,
-                                                                  Vec3& tangent ) const;
+                                                                  Vector3& pointOnPath,
+                                                                  Vector3& tangent ) const;
         
     private:
-        std::vector< Vec3 > points_;
-        std::vector< Vec3 > segmentTangents_;
+        std::vector< Vector3 > points_;
+        std::vector< Vector3 > segmentTangents_;
         std::vector< float > segmentLengths_;
         bool closedCycle_;
     }; // class PolylineSegmentedPath
@@ -192,12 +192,12 @@
         
         static void extract( PolylineSegmentedPath const& pathAlike,
                              PolylineSegmentedPath::size_type segmentIndex,
-                             Vec3 const& point, 
+                             Vector3 const& point, 
                              float& segmentDistance, 
                              float&, 
                              float& distancePointToPath, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent ) {
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent );
             distancePointToPath = distance( point, pointOnPathCenterLine );
         }
@@ -213,8 +213,8 @@
         static void extract( PolylineSegmentedPath const& pathAlike,
                              PolylineSegmentedPath::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent, 
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent, 
                              float&  )  {
             pathAlike.mapDistanceToSegmentPointAndTangent( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent );     
         }

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -48,7 +48,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::distance
@@ -79,7 +79,7 @@
          * last point mustn't be identical, too.
          */
         PolylineSegmentedPathwaySegmentRadii( size_type numOfPoints,
-                                              Vec3 const points[],
+                                              Vector3 const points[],
                                               float const radii[],
                                               bool closedCycle );
         PolylineSegmentedPathwaySegmentRadii( PolylineSegmentedPathwaySegmentRadii const& other );
@@ -111,7 +111,7 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const points[] );
+                         Vector3 const points[] );
         /**
          * Replaces the pathway information completely.
          *
@@ -133,7 +133,7 @@
          *        otherwise.
          */
         void setPathway( size_type numOfPoints,
-                         Vec3 const points[],
+                         Vector3 const points[],
                          float const radii[],
                          bool closedCycle );
         
@@ -162,43 +162,43 @@
         
         
         virtual bool isValid() const;
-        virtual Vec3 mapPointToPath (const Vec3& point,
-                                     Vec3& tangent,
+        virtual Vector3 mapPointToPath (const Vector3& point,
+                                     Vector3& tangent,
                                      float& outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3& point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3& point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;  
+        virtual Vector3 point( size_type pointIndex ) const;  
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const& point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const& point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
         virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
                                                   float distanceOnSegment ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3& pointOnPath,
-                                                                   Vec3& tangent,
+                                                                   Vector3& pointOnPath,
+                                                                   Vector3& tangent,
                                                                    float& radius ) const;
             
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const& point,
+                                                                           Vector3 const& point,
                                                                            float& distance,
-                                                                           Vec3& pointOnPath,
-                                                                           Vec3& tangent,
+                                                                           Vector3& pointOnPath,
+                                                                           Vector3& tangent,
                                                                            float& radius) const;
 
     private:
@@ -225,12 +225,12 @@
             
         static void extract( PolylineSegmentedPathwaySegmentRadii const& pathAlike,
                              PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex,
-                             Vec3 const& point, 
+                             Vector3 const& point, 
                              float& segmentDistance, 
                              float& radius, 
                              float& distancePointToPath, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent ) {
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
             distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
         }
@@ -247,8 +247,8 @@
         static void extract( PolylineSegmentedPathwaySegmentRadii const& pathAlike,
                              PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent, 
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent, 
                              float& radius )  {
             pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
         }

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -42,7 +42,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::distance
@@ -61,7 +61,7 @@
         PolylineSegmentedPathwaySingleRadius();
         explicit PolylineSegmentedPathwaySingleRadius( float r );
         PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                              Vec3 const points[],
+                                              Vector3 const points[],
                                               float r,
                                               bool closeCycle );
         PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const& other );
@@ -92,7 +92,7 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const newPointValues[] );
+                         Vector3 const newPointValues[] );
         /**
          * Replaces the pathway information completely.
          *
@@ -109,7 +109,7 @@
          *        otherwise.
          */
         void setPathway( size_type numOfPoints,
-                         Vec3 const points[],
+                         Vector3 const points[],
                          float r,
                          bool closedCycle );
         
@@ -125,43 +125,43 @@
         
         
         virtual bool isValid() const;
-		virtual Vec3 mapPointToPath (const Vec3& point,
-                                     Vec3& tangent,
+		virtual Vector3 mapPointToPath (const Vector3& point,
+                                     Vector3& tangent,
                                      float& outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3& point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3& point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;
+        virtual Vector3 point( size_type pointIndex ) const;
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const& point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const& point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
         virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
                                                  float distanceOnSegment ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3& pointOnPath,
-                                                                   Vec3& tangent,
+                                                                   Vector3& pointOnPath,
+                                                                   Vector3& tangent,
                                                                    float& radius ) const;
         
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const& point,
+                                                                           Vector3 const& point,
                                                                            float& distance,
-                                                                           Vec3& pointOnPath,
-                                                                           Vec3& tangent,
+                                                                           Vector3& pointOnPath,
+                                                                           Vector3& tangent,
                                                                            float& radius) const;
          
     private:
@@ -188,12 +188,12 @@
             
         static void extract( PolylineSegmentedPathwaySingleRadius const& pathAlike,
                              PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             Vec3 const& point, 
+                             Vector3 const& point, 
                              float& segmentDistance, 
                              float& radius, 
                              float& distancePointToPath, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent ) {
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
             distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
         }
@@ -210,8 +210,8 @@
         static void extract( PolylineSegmentedPathwaySingleRadius const& pathAlike,
                              PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3& pointOnPathCenterLine, 
-                             Vec3& tangent, 
+                             Vector3& pointOnPathCenterLine, 
+                             Vector3& tangent, 
                              float& radius )  {
             pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
         }

Modified: dependencies/opensteer/include/OpenSteer/Proximity.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Proximity.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Proximity.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -64,10 +64,10 @@
         virtual ~AbstractTokenForProximityDatabase () {}
 
         // the client object calls this each time its position changes
-        virtual void updateForNewPosition (const Vec3& position) = 0;
+        virtual void updateForNewPosition (const Vector3& position) = 0;
 
         // find all neighbors within the given sphere (as center and radius)
-        virtual void findNeighbors (const Vec3& center,
+        virtual void findNeighbors (const Vector3& center,
                                     const float radius,
                                     std::vector<ContentType>& results) = 0;
 
@@ -155,13 +155,13 @@
             }
 
             // the client object calls this each time its position changes
-            void updateForNewPosition (const Vec3& newPosition)
+            void updateForNewPosition (const Vector3& newPosition)
             {
                 position = newPosition;
             }
 
             // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vec3& center,
+            void findNeighbors (const Vector3& center,
                                 const float radius,
                                 std::vector<ContentType>& results)
             {
@@ -171,7 +171,7 @@
                      i != bfpd->group.end();
                      i++)
                 {
-                    const Vec3 offset = center - (**i).position;
+                    const Vector3 offset = center - (**i).position;
                     const float d2 = offset.lengthSquared();
 
                     // push onto result vector when within given radius
@@ -182,7 +182,7 @@
         private:
             BruteForceProximityDatabase* bfpd;
             ContentType object;
-            Vec3 position;
+            Vector3 position;
         };
 
         typedef std::vector<tokenType*> tokenVector;
@@ -216,12 +216,12 @@
     public:
 
         // constructor
-        LQProximityDatabase (const Vec3& center,
-                             const Vec3& dimensions,
-                             const Vec3& divisions)
+        LQProximityDatabase (const Vector3& center,
+                             const Vector3& dimensions,
+                             const Vector3& divisions)
         {
-            const Vec3 halfsize (dimensions * 0.5f);
-            const Vec3 origin (center - halfsize);
+            const Vector3 halfsize (dimensions * 0.5f);
+            const Vector3 origin (center - halfsize);
 
             lq = lqCreateDatabase (origin.x, origin.y, origin.z, 
                                    dimensions.x, dimensions.y, dimensions.z,  
@@ -256,13 +256,13 @@
             }
 
             // the client object calls this each time its position changes
-            void updateForNewPosition (const Vec3& p)
+            void updateForNewPosition (const Vector3& p)
             {
                 lqUpdateForNewLocation (lq, &proxy, p.x, p.y, p.z);
             }
 
             // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vec3& center,
+            void findNeighbors (const Vector3& center,
                                 const float radius,
                                 std::vector<ContentType>& results)
             {

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlike.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlike.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlike.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,7 +39,7 @@
 
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::distance
@@ -77,10 +77,10 @@
          * empty member function calls and the associated calculations for its
          * parameters away.
          *
-         * <code> void setPointOnPathCenterLine( Vec3 const& ) </code>
-         * <code> void setPointOnPathBoundary( Vec3 const& ) </code>
+         * <code> void setPointOnPathCenterLine( Vector3 const& ) </code>
+         * <code> void setPointOnPathBoundary( Vector3 const& ) </code>
          * <code> void setRadius( float ) </code>
-         * <code> void setTangent( Vec3 const& ) </code>
+         * <code> void setTangent( Vector3 const& ) </code>
          * <code> void setSegmentIndex( typename SegmentedPathAlike::size_type ) </code>
          * <code> void setDistancePointToPath( float ) </code>
          * <code> void setDistancePointToPathCenterLine( float ) </code>
@@ -99,7 +99,7 @@
          * @c QueryPathAlikeUtilities.h provides some base classes to inherit
          * from to automatically get some of the functionality described above.
          */
-        static void map( PathAlike const& pathAlike, Vec3 const& queryPoint, Mapping& mapping ) {
+        static void map( PathAlike const& pathAlike, Vector3 const& queryPoint, Mapping& mapping ) {
             float minDistancePointToPath = std::numeric_limits< float >::max();
             mapping.setDistanceOnPathFlag( 0.0f );
             
@@ -110,15 +110,15 @@
                 float segmentDistance = 0.0f;
                 float radius = 0.0f;
                 float distancePointToPath = 0.0f;
-                Vec3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-                Vec3 tangent( 0.0f, 0.0f, 0.0f );
+                Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+                Vector3 tangent( 0.0f, 0.0f, 0.0f );
                 
                 BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, queryPoint, segmentDistance, radius, distancePointToPath, pointOnPathCenterLine, tangent );
                 
                 if ( distancePointToPath < minDistancePointToPath ) {
                     minDistancePointToPath = distancePointToPath;
                     mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalize() * radius ) );
+                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalisedCopy() * radius ) );
                     mapping.setRadius( radius );
                     mapping.setTangent( tangent );
                     mapping.setSegmentIndex( segmentIndex );
@@ -141,7 +141,7 @@
      * See @c MapPointToPathAlike::map for further information.
      */
     template< class PathAlike, class Mapping >
-    void mapPointToPathAlike( PathAlike const& pathAlike, Vec3 const& point, Mapping& mapping ) {
+    void mapPointToPathAlike( PathAlike const& pathAlike, Vector3 const& point, Mapping& mapping ) {
         PointToPathAlikeMapping< PathAlike, Mapping >::map( pathAlike, point, mapping );
     }
     
@@ -165,9 +165,9 @@
          * empty member function calls and the associated calculations for its
          * parameters away.
          *
-         * <code> void setPointOnPathCenterLine( Vec3 const& ) </code>
+         * <code> void setPointOnPathCenterLine( Vector3 const& ) </code>
          * <code> void setRadius( float ) </code>
-         * <code> void setTangent( Vec3 const& ) </code>
+         * <code> void setTangent( Vector3 const& ) </code>
          * <code> void setSegmentIndex( typename SegmentedPathAlike::size_type ) </code>
          * <code> void setDistanceOnPath( float ) </code>
          * <code> void setDistanceOnSegment( float ) </code>
@@ -194,8 +194,8 @@
             
             // Extract the path related data associated with the segment reached
             // by @c distanceOnPath.
-            Vec3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-            Vec3 tangent( 0.0f, 0.0f, 0.0f );
+            Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+            Vector3 tangent( 0.0f, 0.0f, 0.0f );
             float radius = 0.0f;
             BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, remainingDistance, pointOnPathCenterLine, tangent, radius );
             

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -43,7 +43,7 @@
      * Specialize it for the path alike to use and provide a static member
      * function with the following signature:
      *
-     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, Vec3 const& point, float& segmentDistance, float& radius, float& distancePointToPath, Vec3& pointOnPathCenterLine, Vec3& tangent )</code>
+     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, Vector3 const& point, float& segmentDistance, float& radius, float& distancePointToPath, Vector3& pointOnPathCenterLine, Vector3& tangent )</code>
      *
      * @attention Be aware of the references that are passed in.
      */
@@ -58,7 +58,7 @@
      * Specialize it for the path alike to use and provide a static member
      * function with the following signature:
      *
-     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vec3& pointOnPathCenterLine, Vec3& tangent, float& radius )</code>
+     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vector3& pointOnPathCenterLine, Vector3& tangent, float& radius )</code>
      *
      * @attention Be aware of the references that are passed in.
      */    

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,7 +38,7 @@
 // Include OpenSteer::HasNoRadius, OpenSteer::ExtractPathDistance, OpenSteer::DontExtractPathDistance
 #include "OpenSteer/QueryPathAlikeUtilities.h"
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::size_t
@@ -59,14 +59,14 @@
     public:
         PointToPathMapping() : pointOnPathCenterLine( 0.0f, 0.0f, 0.0f ), tangent( 0.0f, 0.0f, 0.0f ), distancePointToPath( 0.0f ) {}
             
-        void setPointOnPathCenterLine( Vec3 const& point ) {
+        void setPointOnPathCenterLine( Vector3 const& point ) {
             pointOnPathCenterLine = point;
         }
-        void setPointOnPathBoundary( Vec3 const& ) {
+        void setPointOnPathBoundary( Vector3 const& ) {
             // pointOnPathBoundary = point;
         }
         void setRadius( float ) {}
-        void setTangent( Vec3 const& t) {
+        void setTangent( Vector3 const& t) {
             tangent = t;
         }
         void setSegmentIndex( size_t ) {}
@@ -77,9 +77,9 @@
         void setDistanceOnPath( float ) {}
         void setDistanceOnSegment( float ) {}
             
-        Vec3 pointOnPathCenterLine;
-        // Vec3 pointOnPathBoundary; 
-        Vec3 tangent;
+        Vector3 pointOnPathCenterLine;
+        // Vector3 pointOnPathBoundary; 
+        Vector3 tangent;
         float distancePointToPath;
             
             
@@ -95,17 +95,17 @@
             
     public:
         
-        void setPointOnPathCenterLine( Vec3 const& vec ){
+        void setPointOnPathCenterLine( Vector3 const& vec ){
             pointOnPathCenterLine = vec;
         }
         void setRadius( float ) {}
-        void setTangent( Vec3 const& ){}
+        void setTangent( Vector3 const& ){}
         void setSegmentIndex( size_t ){}
         void setDistanceOnPath( float ){}
         void setDistanceOnSegment( float ){}
             
             
-        Vec3 pointOnPathCenterLine; 
+        Vector3 pointOnPathCenterLine; 
             
             
     }; // class PathDistanceToPointMapping
@@ -121,10 +121,10 @@
     public:
         PointToPathDistanceMapping() : distanceOnPath( 0.0f ) {}
             
-        void setPointOnPathCenterLine( Vec3 const& ) {}
-        void setPointOnPathBoundary( Vec3 const&  ) {}
+        void setPointOnPathCenterLine( Vector3 const& ) {}
+        void setPointOnPathBoundary( Vector3 const&  ) {}
         void setRadius( float ) {}
-        void setTangent( Vec3 const& ) {}
+        void setTangent( Vector3 const& ) {}
         void setSegmentIndex( size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}

Modified: dependencies/opensteer/include/OpenSteer/SegmentedPath.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SegmentedPath.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SegmentedPath.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -63,7 +63,7 @@
          * If the path is cyclic also the last point that is the duplicated
          * first one is accessible.
          */
-        virtual Vec3 point( size_type pointIndex ) const = 0;
+        virtual Vector3 point( size_type pointIndex ) const = 0;
         
         
         
@@ -80,12 +80,12 @@
         /**
          * Returns the start point of the segment @a segmentIndex.
          */
-        virtual Vec3 segmentStart( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
         
         /**
          * Returns the end point of segment @a segmentIndex.
          */
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
         
         
         /**
@@ -94,7 +94,7 @@
          * this point.
          */
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const& point ) const = 0;
+                                                 Vector3 const& point ) const = 0;
         
         
         /**
@@ -104,7 +104,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const = 0;
         
         /**
@@ -115,7 +115,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const = 0;
         
         
@@ -125,8 +125,8 @@
          */
         virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                           float distance,
-                                                          Vec3& pointOnPath,
-                                                          Vec3& tangent ) const = 0;
+                                                          Vector3& pointOnPath,
+                                                          Vector3& tangent ) const = 0;
         
         
         /**
@@ -134,10 +134,10 @@
          * and @c mapSegmentDistanceToTangent.
          */
         virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vec3 const& point,
+                                                                  Vector3 const& point,
                                                                   float& distance,
-                                                                  Vec3& pointOnPath,
-                                                                  Vec3& tangent ) const = 0;
+                                                                  Vector3& pointOnPath,
+                                                                  Vector3& tangent ) const = 0;
 
     protected:
         /**

Modified: dependencies/opensteer/include/OpenSteer/SegmentedPathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SegmentedPathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SegmentedPathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -42,9 +42,6 @@
 
 namespace OpenSteer {
 
-    // Forward declaration
-    class Vec3;
-    
     /**
      * Path defined by path segments.
      *
@@ -71,7 +68,7 @@
          * If the path is cyclic also the last point that is the duplicated
          * first one is accessible.
          */
-        virtual Vec3 point( size_type pointIndex ) const = 0;
+        virtual Vector3 point( size_type pointIndex ) const = 0;
         
         
         /**
@@ -87,12 +84,12 @@
         /**
          * Returns the start point of the segment @a segmentIndex.
          */
-        virtual Vec3 segmentStart( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
         
         /**
          * Returns the end point of segment @a segmentIndex.
          */
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
         
         
         
@@ -102,7 +99,7 @@
          * this point.
          */
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const& point ) const = 0;
+                                                 Vector3 const& point ) const = 0;
         
         
         /**
@@ -112,7 +109,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const = 0;
         
         /**
@@ -133,7 +130,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const = 0;
         
         /**
@@ -142,8 +139,8 @@
          */
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3& pointOnPath,
-                                                                   Vec3& tangent,
+                                                                   Vector3& pointOnPath,
+                                                                   Vector3& tangent,
                                                                    float& radius ) const = 0;        
         
         /**
@@ -151,10 +148,10 @@
          * @c mapSegmentDistanceToRadius, and @c mapSegmentDistanceToTangent.
          */
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const& point,
+                                                                           Vector3 const& point,
                                                                            float& distance,
-                                                                           Vec3& pointOnPath,
-                                                                           Vec3& tangent,
+                                                                           Vector3& pointOnPath,
+                                                                           Vector3& tangent,
                                                                            float& radius) const = 0;
         
        

Modified: dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -127,7 +127,7 @@
         float setMass (float m) {return _mass = m;}
 
         // get velocity of vehicle
-        Vec3 velocity (void) const {return forward() * _speed;}
+        Vector3 velocity (void) const {return forward() * _speed;}
 
         // get/set speed of vehicle  (may be faster than taking mag of velocity)
         float speed (void) const {return _speed;}
@@ -148,24 +148,24 @@
 
         // apply a given steering force to our momentum,
         // adjusting our orientation to maintain velocity-alignment.
-        void applySteeringForce (const Vec3& force, const float deltaTime);
+        void applySteeringForce (const Vector3& force, const float deltaTime);
 
         // the default version: keep FORWARD parallel to velocity, change
         // UP as little as possible.
-        virtual void regenerateLocalSpace (const Vec3& newVelocity,
+        virtual void regenerateLocalSpace (const Vector3& newVelocity,
                                            const float elapsedTime);
 
         // alternate version: keep FORWARD parallel to velocity, adjust UP
         // according to a no-basis-in-reality "banking" behavior, something
         // like what birds and airplanes do.  (XXX experimental cwr 6-5-03)
-        void regenerateLocalSpaceForBanking (const Vec3& newVelocity,
+        void regenerateLocalSpaceForBanking (const Vector3& newVelocity,
                                              const float elapsedTime);
 
         // adjust the steering force passed to applySteeringForce.
         // allows a specific vehicle class to redefine this adjustment.
         // default is to disallow backward-facing steering at low speed.
         // xxx experimental 8-20-02
-        virtual Vec3 adjustRawSteeringForce (const Vec3& force,
+        virtual Vector3 adjustRawSteeringForce (const Vector3& force,
                                              const float deltaTime);
 
         // apply a given braking force (for a given dt) to our momentum.
@@ -174,7 +174,7 @@
 
         // predict position of this vehicle at some time in the future
         // (assumes velocity remains constant)
-        Vec3 predictFuturePosition (const float predictionTime) const;
+        Vector3 predictFuturePosition (const float predictionTime) const;
 
         // get instantaneous curvature (since last update)
         float curvature (void) const {return _curvature;}
@@ -183,17 +183,17 @@
         float smoothedCurvature (void) {return _smoothedCurvature;}
         float resetSmoothedCurvature (float value = 0)
         {
-            _lastForward = Vec3::zero;
-            _lastPosition = Vec3::zero;
+            _lastForward = Vector3::ZERO;
+            _lastPosition = Vector3::ZERO;
             return _smoothedCurvature = _curvature = value;
         }
-        Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
-        Vec3 resetSmoothedAcceleration (const Vec3& value = Vec3::zero)
+        Vector3 smoothedAcceleration (void) {return _smoothedAcceleration;}
+        Vector3 resetSmoothedAcceleration (const Vector3& value = Vector3::ZERO)
         {
             return _smoothedAcceleration = value;
         }
-        Vec3 smoothedPosition (void) {return _smoothedPosition;}
-        Vec3 resetSmoothedPosition (const Vec3& value = Vec3::zero)
+        Vector3 smoothedPosition (void) {return _smoothedPosition;}
+        Vector3 resetSmoothedPosition (const Vector3& value = Vector3::ZERO)
         {
             return _smoothedPosition = value;
         }
@@ -213,7 +213,7 @@
         // rotate about it by a random angle (pick random forward, derive side).
         void randomizeHeadingOnXZPlane (void)
         {
-            setUp (Vec3::up);
+            setUp (Vector3::UNIT_Y);
             setForward (RandomUnitVectorOnXZPlane ());
             setSide (localRotateForwardToSide (forward()));
         }
@@ -234,11 +234,11 @@
                            // (velocity is clipped to this magnitude)
 
         float _curvature;
-        Vec3 _lastForward;
-        Vec3 _lastPosition;
-        Vec3 _smoothedPosition;
+        Vector3 _lastForward;
+        Vector3 _lastPosition;
+        Vector3 _smoothedPosition;
         float _smoothedCurvature;
-        Vec3 _smoothedAcceleration;
+        Vector3 _smoothedAcceleration;
 
         // measure path curvature (1/turning-radius), maintain smoothed version
         void measurePathCurvature (const float elapsedTime);

Modified: dependencies/opensteer/include/OpenSteer/SteerLibrary.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -100,23 +100,23 @@
         // Wander behavior
         float WanderSide;
         float WanderUp;
-        Vec3 steerForWander (float dt);
+        Vector3 steerForWander (float dt);
 
         // Seek behavior
-        Vec3 steerForSeek (const Vec3& target);
+        Vector3 steerForSeek (const Vector3& target);
 
         // Flee behavior
-        Vec3 steerForFlee (const Vec3& target);
+        Vector3 steerForFlee (const Vector3& target);
 
         // xxx proposed, experimental new seek/flee [cwr 9-16-02]
-        Vec3 xxxsteerForFlee (const Vec3& target);
-        Vec3 xxxsteerForSeek (const Vec3& target);
+        Vector3 xxxsteerForFlee (const Vector3& target);
+        Vector3 xxxsteerForSeek (const Vector3& target);
 
         // Path Following behaviors
-        Vec3 steerToFollowPath (const int direction,
+        Vector3 steerToFollowPath (const int direction,
                                 const float predictionTime,
                                 Pathway& path);
-        Vec3 steerToStayOnPath (const float predictionTime, Pathway& path);
+        Vector3 steerToStayOnPath (const float predictionTime, Pathway& path);
 
         // ------------------------------------------------------------------------
         // Obstacle Avoidance behavior
@@ -126,17 +126,17 @@
         // of the obstacle.  Avoidance is required when (1) the obstacle
         // intersects the vehicle's current path, (2) it is in front of the
         // vehicle, and (3) is within minTimeToCollision seconds of travel at the
-        // vehicle's current velocity.  Returns a zero vector value (Vec3::zero)
+        // vehicle's current velocity.  Returns a zero vector value (Vector3::ZERO)
         // when no avoidance is required.
 
 
-        Vec3 steerToAvoidObstacle (const float minTimeToCollision,
+        Vector3 steerToAvoidObstacle (const float minTimeToCollision,
                                    const Obstacle& obstacle);
 
 
         // avoids all obstacles in an ObstacleGroup
 
-        Vec3 steerToAvoidObstacles (const float minTimeToCollision,
+        Vector3 steerToAvoidObstacles (const float minTimeToCollision,
                                     const ObstacleGroup& obstacles);
 
 
@@ -148,7 +148,7 @@
         // force vector, which is zero length if there is no impending collision.
 
 
-        Vec3 steerToAvoidNeighbors (const float minTimeToCollision,
+        Vector3 steerToAvoidNeighbors (const float minTimeToCollision,
                                     const AVGroup& others);
 
 
@@ -164,8 +164,8 @@
 
 
         /// XXX globals only for the sake of graphical annotation
-        Vec3 hisPositionAtNearestApproach;
-        Vec3 ourPositionAtNearestApproach;
+        Vector3 hisPositionAtNearestApproach;
+        Vector3 ourPositionAtNearestApproach;
 
 
         // ------------------------------------------------------------------------
@@ -176,7 +176,7 @@
         // XXX  to steerForSeparation.
 
 
-        Vec3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
+        Vector3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
                                          const AVGroup& others);
 
 
@@ -194,7 +194,7 @@
         // Separation behavior -- determines the direction away from nearby boids
 
 
-        Vec3 steerForSeparation (const float maxDistance,
+        Vector3 steerForSeparation (const float maxDistance,
                                  const float cosMaxAngle,
                                  const AVGroup& flock);
 
@@ -202,7 +202,7 @@
         // ------------------------------------------------------------------------
         // Alignment behavior
 
-        Vec3 steerForAlignment (const float maxDistance,
+        Vector3 steerForAlignment (const float maxDistance,
                                 const float cosMaxAngle,
                                 const AVGroup& flock);
 
@@ -211,7 +211,7 @@
         // Cohesion behavior
 
 
-        Vec3 steerForCohesion (const float maxDistance,
+        Vector3 steerForCohesion (const float maxDistance,
                                const float cosMaxAngle,
                                const AVGroup& flock);
 
@@ -220,9 +220,9 @@
         // pursuit of another vehicle (& version with ceiling on prediction time)
 
 
-        Vec3 steerForPursuit (const AbstractVehicle& quarry);
+        Vector3 steerForPursuit (const AbstractVehicle& quarry);
 
-        Vec3 steerForPursuit (const AbstractVehicle& quarry,
+        Vector3 steerForPursuit (const AbstractVehicle& quarry,
                               const float maxPredictionTime);
 
         // for annotation
@@ -233,7 +233,7 @@
         // evasion of another vehicle
 
 
-        Vec3 steerForEvasion (const AbstractVehicle& menace,
+        Vector3 steerForEvasion (const AbstractVehicle& menace,
                               const float maxPredictionTime);
 
 
@@ -242,7 +242,7 @@
         // force along the forward/backward axis
 
 
-        Vec3 steerForTargetSpeed (const float targetSpeed);
+        Vector3 steerForTargetSpeed (const float targetSpeed);
 
 
         // ----------------------------------------------------------- utilities
@@ -251,25 +251,25 @@
         // XXX ("utility vehicle"?)
 
         // xxx cwr experimental 9-9-02 -- names OK?
-        bool isAhead (const Vec3& target) const {return isAhead (target, 0.707f);};
-        bool isAside (const Vec3& target) const {return isAside (target, 0.707f);};
-        bool isBehind (const Vec3& target) const {return isBehind (target, -0.707f);};
+        bool isAhead (const Vector3& target) const {return isAhead (target, 0.707f);};
+        bool isAside (const Vector3& target) const {return isAside (target, 0.707f);};
+        bool isBehind (const Vector3& target) const {return isBehind (target, -0.707f);};
 
-        bool isAhead (const Vec3& target, float cosThreshold) const
+        bool isAhead (const Vector3& target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position ()).normalize ();
-            return forward().dot(targetDirection) > cosThreshold;
+            const Vector3 targetDirection = (target - position ()).normalisedCopy();
+            return forward().dotProduct(targetDirection) > cosThreshold;
         };
-        bool isAside (const Vec3& target, float cosThreshold) const
+        bool isAside (const Vector3& target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position ()).normalize ();
-            const float dp = forward().dot(targetDirection);
+            const Vector3 targetDirection = (target - position ()).normalisedCopy();
+            const float dp = forward().dotProduct(targetDirection);
             return (dp < cosThreshold) && (dp > -cosThreshold);
         };
-        bool isBehind (const Vec3& target, float cosThreshold) const
+        bool isBehind (const Vector3& target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position()).normalize ();
-            return forward().dot(targetDirection) < cosThreshold;
+            const Vector3 targetDirection = (target - position()).normalisedCopy();
+            return forward().dotProduct(targetDirection) < cosThreshold;
         };
 
 
@@ -285,9 +285,9 @@
 
         // called when steerToFollowPath decides steering is required
         // (default action is to do nothing, layered classes can overload it)
-        virtual void annotatePathFollowing (const Vec3& /*future*/,
-                                            const Vec3& /*onPath*/,
-                                            const Vec3& /*target*/,
+        virtual void annotatePathFollowing (const Vector3& /*future*/,
+                                            const Vector3& /*onPath*/,
+                                            const Vector3& /*target*/,
                                             const float /*outside*/)
         {
         }
@@ -303,8 +303,8 @@
         // (default action is to do nothing, layered classes can overload it)
         virtual void annotateAvoidNeighbor (const AbstractVehicle& /*threat*/,
                                             const float /*steer*/,
-                                            const Vec3& /*ourFuture*/,
-                                            const Vec3& /*threatFuture*/)
+                                            const Vector3& /*ourFuture*/,
+                                            const Vector3& /*threatFuture*/)
         {
         }
     };
@@ -316,7 +316,7 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForWander (float dt)
 {
@@ -335,11 +335,11 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
-steerForSeek (const Vec3& target)
+steerForSeek (const Vector3& target)
 {
-    const Vec3 desiredVelocity = target - position();
+    const Vector3 desiredVelocity = target - position();
     return desiredVelocity - velocity();
 }
 
@@ -349,11 +349,11 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
-steerForFlee (const Vec3& target)
+steerForFlee (const Vector3& target)
 {
-    const Vec3 desiredVelocity = position() - target;
+    const Vector3 desiredVelocity = position() - target;
     return desiredVelocity - velocity();
 }
 
@@ -363,25 +363,25 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
-xxxsteerForFlee (const Vec3& target)
+xxxsteerForFlee (const Vector3& target)
 {
-//  const Vec3 offset = position - target;
-    const Vec3 offset = position() - target;
-    const Vec3 desiredVelocity = offset.truncateLength (maxSpeed ()); //xxxnew
+//  const Vector3 offset = position - target;
+    const Vector3 offset = position() - target;
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
     return desiredVelocity - velocity();
 }
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
-xxxsteerForSeek (const Vec3& target)
+xxxsteerForSeek (const Vector3& target)
 {
-//  const Vec3 offset = target - position;
-    const Vec3 offset = target - position();
-    const Vec3 desiredVelocity = offset.truncateLength (maxSpeed ()); //xxxnew
+//  const Vector3 offset = target - position;
+    const Vector3 offset = target - position();
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
     return desiredVelocity - velocity();
 }
 
@@ -391,17 +391,17 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToStayOnPath (const float predictionTime, Pathway& path)
 {
     // predict our future position
-    const Vec3 futurePosition = predictFuturePosition (predictionTime);
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // find the point on the path nearest the predicted future position
-    Vec3 tangent;
+    Vector3 tangent;
     float outside;
-    const Vec3 onPath = path.mapPointToPath (futurePosition,
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
                                              tangent,     // output argument
                                              outside);    // output argument
 
@@ -409,7 +409,7 @@
     {
         // our predicted future position was in the path,
         // return zero steering.
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
     else
     {
@@ -423,7 +423,7 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToFollowPath (const int direction,
                    const float predictionTime,
@@ -433,7 +433,7 @@
     const float pathDistanceOffset = direction * predictionTime * speed();
 
     // predict our future position
-    const Vec3 futurePosition = predictFuturePosition (predictionTime);
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // measure distance along path of our current and predicted positions
     const float nowPathDistance =
@@ -450,9 +450,9 @@
     // XXX need to improve calling sequence, maybe change to return a
     // XXX special path-defined object which includes two Vec3s and a 
     // XXX bool (onPath,tangent (ignored), withinPath)
-    Vec3 tangent;
+    Vector3 tangent;
     float outside;
-    const Vec3 onPath = path.mapPointToPath (futurePosition,
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
                                              // output arguments:
                                              tangent,
                                              outside);
@@ -462,7 +462,7 @@
     if ((outside < 0) && rightway)
     {
         // all is well, return zero steering
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
     else
     {
@@ -470,7 +470,7 @@
         // by adding pathDistanceOffset to our current path position
 
         float const targetPathDistance = nowPathDistance + pathDistanceOffset;
-        Vec3 const target = path.mapPathDistanceToPoint (targetPathDistance);
+        Vector3 const target = path.mapPathDistanceToPoint (targetPathDistance);
 
         annotatePathFollowing (futurePosition, onPath, target, outside);
 
@@ -488,7 +488,7 @@
 // obstacle.  Avoidance is required when (1) the obstacle intersects the
 // vehicle's current path, (2) it is in front of the vehicle, and (3) is
 // within minTimeToCollision seconds of travel at the vehicle's current
-// velocity.  Returns a zero vector value (Vec3::zero) when no avoidance is
+// velocity.  Returns a zero vector value (Vector3::ZERO) when no avoidance is
 // required.
 //
 // XXX The current (4-23-03) scheme is to dump all the work on the various
@@ -502,15 +502,15 @@
 // XXX to avoid a non-grouped obstacle)
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToAvoidObstacle (const float minTimeToCollision,
                       const Obstacle& obstacle)
 {
-    const Vec3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
+    const Vector3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vec3::zero)
+    if (avoidance != Vector3::ZERO)
         annotateAvoidObstacle (minTimeToCollision * speed());
 
     return avoidance;
@@ -520,17 +520,17 @@
 // this version avoids all of the obstacles in an ObstacleGroup
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToAvoidObstacles (const float minTimeToCollision,
                        const ObstacleGroup& obstacles)
 {
-    const Vec3 avoidance = Obstacle::steerToAvoidObstacles (*this,
+    const Vector3 avoidance = Obstacle::steerToAvoidObstacles (*this,
                                                             minTimeToCollision,
                                                             obstacles);
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vec3::zero)
+    if (avoidance != Vector3::ZERO)
         annotateAvoidObstacle (minTimeToCollision * speed());
 
     return avoidance;
@@ -546,14 +546,14 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToAvoidNeighbors (const float minTimeToCollision,
                        const AVGroup& others)
 {
     // first priority is to prevent immediate interpenetration
-    const Vec3 separation = steerToAvoidCloseNeighbors (0, others);
-    if (separation != Vec3::zero) return separation;
+    const Vector3 separation = steerToAvoidCloseNeighbors (0, others);
+    if (separation != Vector3::ZERO) return separation;
 
     // otherwise, go on to consider potential future collisions
     float steer = 0;
@@ -565,8 +565,8 @@
     float minTime = minTimeToCollision;
 
     // xxx solely for annotation
-    Vec3 xxxThreatPositionAtNearestApproach;
-    Vec3 xxxOurPositionAtNearestApproach;
+    Vector3 xxxThreatPositionAtNearestApproach;
+    Vector3 xxxOurPositionAtNearestApproach;
 
     // for each of the other vehicles, determine which (if any)
     // pose the most immediate threat of collision.
@@ -605,15 +605,15 @@
     if (threat != NULL)
     {
         // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = forward().dot(threat->forward());
+        float parallelness = forward().dotProduct(threat->forward());
         float angle = 0.707f;
 
         if (parallelness < -angle)
         {
             // anti-parallel "head on" paths:
             // steer away from future threat position
-            Vec3 offset = xxxThreatPositionAtNearestApproach - position();
-            float sideDot = offset.dot(side());
+            Vector3 offset = xxxThreatPositionAtNearestApproach - position();
+            float sideDot = offset.dotProduct(side());
             steer = (sideDot > 0) ? -1.0f : 1.0f;
         }
         else
@@ -621,8 +621,8 @@
             if (parallelness > angle)
             {
                 // parallel paths: steer away from threat
-                Vec3 offset = threat->position() - position();
-                float sideDot = offset.dot(side());
+                Vector3 offset = threat->position() - position();
+                float sideDot = offset.dotProduct(side());
                 steer = (sideDot > 0) ? -1.0f : 1.0f;
             }
             else
@@ -631,7 +631,7 @@
                 // (only the slower of the two does this)
                 if (threat->speed() <= speed())
                 {
-                    float sideDot = side().dot(threat->velocity());
+                    float sideDot = side().dotProduct(threat->velocity());
                     steer = (sideDot > 0) ? -1.0f : 1.0f;
                 }
             }
@@ -660,9 +660,9 @@
 {
     // imagine we are at the origin with no velocity,
     // compute the relative velocity of the other vehicle
-    const Vec3 myVelocity = velocity();
-    const Vec3 otherVelocity = otherVehicle.velocity();
-    const Vec3 relVelocity = otherVelocity - myVelocity;
+    const Vector3 myVelocity = velocity();
+    const Vector3 otherVelocity = otherVehicle.velocity();
+    const Vector3 relVelocity = otherVelocity - myVelocity;
     const float relSpeed = relVelocity.length();
 
     // for parallel paths, the vehicles will always be at the same distance,
@@ -675,12 +675,12 @@
     // the nearest approach.
 
     // Take the unit tangent along the other vehicle's path
-    const Vec3 relTangent = relVelocity / relSpeed;
+    const Vector3 relTangent = relVelocity / relSpeed;
 
     // find distance from its path to origin (compute offset from
     // other to us, find length of projection onto path)
-    const Vec3 relPosition = position() - otherVehicle.position();
-    const float projection = relTangent.dot(relPosition);
+    const Vector3 relPosition = position() - otherVehicle.position();
+    const float projection = relTangent.dotProduct(relPosition);
 
     return projection / relSpeed;
 }
@@ -697,17 +697,17 @@
 computeNearestApproachPositions (AbstractVehicle& otherVehicle,
                                  float time)
 {
-    const Vec3    myTravel =       forward () *       speed () * time;
-    const Vec3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
+    const Vector3    myTravel =       forward () *       speed () * time;
+    const Vector3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
 
-    const Vec3    myFinal =       position () +    myTravel;
-    const Vec3 otherFinal = otherVehicle.position () + otherTravel;
+    const Vector3    myFinal =       position () +    myTravel;
+    const Vector3 otherFinal = otherVehicle.position () + otherTravel;
 
     // xxx for annotation
     ourPositionAtNearestApproach = myFinal;
     hisPositionAtNearestApproach = otherFinal;
 
-    return Vec3::distance (myFinal, otherFinal);
+    return myFinal.distance(otherFinal);
 }
 
 
@@ -721,7 +721,7 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerToAvoidCloseNeighbors (const float minSeparationDistance,
                             const AVGroup& others)
@@ -734,19 +734,19 @@
         {
             const float sumOfRadii = radius() + other.radius();
             const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vec3 offset = other.position() - position();
+            const Vector3 offset = other.position() - position();
             const float currentDistance = offset.length();
 
             if (currentDistance < minCenterToCenter)
             {
                 annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return (-offset).perpendicularComponent (forward());
+                return Vec3Utils::perpendicularComponent(-offset, forward());
             }
         }
     }
 
     // otherwise return zero
-    return Vec3::zero;
+    return Vector3::ZERO;
 }
 
 
@@ -768,8 +768,8 @@
     }
     else
     {
-        const Vec3 offset = otherVehicle.position() - position();
-        const float distanceSquared = offset.lengthSquared ();
+        const Vector3 offset = otherVehicle.position() - position();
+        const float distanceSquared = offset.squaredLength();
 
         // definitely in neighborhood if inside minDistance sphere
         if (distanceSquared < (minDistance * minDistance))
@@ -786,8 +786,8 @@
             else
             {
                 // otherwise, test angular offset from forward axis
-                const Vec3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = forward().dot (unitOffset);
+                const Vector3 unitOffset = offset / sqrt (distanceSquared);
+                const float forwardness = forward().dotProduct(unitOffset);
                 return forwardness > cosMaxAngle;
             }
         }
@@ -800,14 +800,14 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForSeparation (const float maxDistance,
                     const float cosMaxAngle,
                     const AVGroup& flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -819,8 +819,8 @@
             // add in steering contribution
             // (opposite of the offset direction, divided once by distance
             // to normalize, divided another time to get 1/d falloff)
-            const Vec3 offset = (**otherVehicle).position() - position();
-            const float distanceSquared = offset.dot(offset);
+            const Vector3 offset = (**otherVehicle).position() - position();
+            const float distanceSquared = offset.dotProduct(offset);
             steering += (offset / -distanceSquared);
 
             // count neighbors
@@ -835,10 +835,10 @@
     /*
     if (neighbors > 0) {
         steering /= neighbors;
-        steering = steering.normalize();
+        steering = steering.normalisedCopy();
     }
     */
-    steering = steering.normalize();
+    steering = steering.normalisedCopy();
     
     return steering;
 }
@@ -849,14 +849,14 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForAlignment (const float maxDistance,
                    const float cosMaxAngle,
                    const AVGroup& flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -874,7 +874,7 @@
 
     // divide by neighbors, subtract off current heading to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - forward()).normalize();
+    if (neighbors > 0) steering = ((steering / (float)neighbors) - forward()).normalisedCopy();
 
     return steering;
 }
@@ -886,14 +886,14 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForCohesion (const float maxDistance,
                   const float cosMaxAngle,
                   const AVGroup& flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -911,7 +911,7 @@
 
     // divide by neighbors, subtract off current position to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - position()).normalize();
+    if (neighbors > 0) steering = ((steering / (float)neighbors) - position()).normalisedCopy();
 
     return steering;
 }
@@ -922,7 +922,7 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForPursuit (const AbstractVehicle& quarry)
 {
@@ -931,23 +931,23 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForPursuit (const AbstractVehicle& quarry,
                  const float maxPredictionTime)
 {
     // offset from this to quarry, that distance, unit vector toward quarry
-    const Vec3 offset = quarry.position() - position();
+    const Vector3 offset = quarry.position() - position();
     const float distance = offset.length ();
-    const Vec3 unitOffset = offset / distance;
+    const Vector3 unitOffset = offset / distance;
 
     // how parallel are the paths of "this" and the quarry
     // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = forward().dot (quarry.forward());
+    const float parallelness = forward().dotProduct(quarry.forward());
 
     // how "forward" is the direction to the quarry
     // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = forward().dot (unitOffset);
+    const float forwardness = forward().dotProduct(unitOffset);
 
     const float directTravelTime = distance / speed ();
     const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
@@ -1021,7 +1021,7 @@
     const float etl = (et > maxPredictionTime) ? maxPredictionTime : et;
 
     // estimated position of quarry at intercept
-    const Vec3 target = quarry.predictFuturePosition (etl);
+    const Vector3 target = quarry.predictFuturePosition (etl);
 
     // annotation
 /*    annotationLine (position(),
@@ -1036,13 +1036,13 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForEvasion (const AbstractVehicle& menace,
                  const float maxPredictionTime)
 {
     // offset from this to menace, that distance, unit vector toward menace
-    const Vec3 offset = menace.position() - position();
+    const Vector3 offset = menace.position() - position();
     const float distance = offset.length ();
 
     const float roughTime = distance / menace.speed();
@@ -1050,7 +1050,7 @@
                                   maxPredictionTime :
                                   roughTime);
 
-    const Vec3 target = menace.predictFuturePosition (predictionTime);
+    const Vector3 target = menace.predictFuturePosition (predictionTime);
 
     return steerForFlee (target);
 }
@@ -1062,7 +1062,7 @@
 
 
 template<class Super>
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin<Super>::
 steerForTargetSpeed (const float targetSpeed)
 {

Modified: dependencies/opensteer/include/OpenSteer/Vec3.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Vec3.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -27,15 +27,15 @@
 //
 // ----------------------------------------------------------------------------
 //
-// Vec3: OpenSteer's generic type for 3d vectors
+// Vector3: OpenSteer's generic type for 3d vectors
 //
-// This file defines the class Vec3, which is used throughout OpenSteer to
+// This file defines the class Vector3, which is used throughout OpenSteer to
 // manipulate 3d geometric data.  It includes standard vector operations (like
 // vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
 // utility functions.
 //
 // When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vec3
+// important to use the 3d vector type of that application.  In that case Vector3
 // can be changed to inherit from the preexisting application' vector type and
 // to match the interface used by OpenSteer to the interface provided by the
 // preexisting 3d vector type.
@@ -47,117 +47,36 @@
 // ----------------------------------------------------------------------------
 
 
-#ifndef OPENSTEER_VEC3_H
-#define OPENSTEER_VEC3_H
+#ifndef OPENSTEER_Vector3_H
+#define OPENSTEER_Vector3_H
 
 
 #include "OpenSteer/Utilities.h"  // for interpolate, etc.
+#include <OgreVector3.h>
 
+using Ogre::Vector3;
 
 namespace OpenSteer {
 
     // ----------------------------------------------------------------------------
-
-
-    class Vec3
+    class Vec3Utils
     {
     public:
-
-        // ----------------------------------------- generic 3d vector operations
-
-        // three-dimensional Cartesian coordinates
-        float x, y, z;
-
-        // constructors
-        Vec3 (void): x( 0.0f ), y( 0.0f ), z( 0.0f ) {}
-        Vec3 (float X, float Y, float Z) : x( X ), y( Y ), z( Z ) {}
-
-        // vector addition
-        Vec3 operator+ (const Vec3& v) const {return Vec3 (x+v.x, y+v.y, z+v.z);}
-
-        // vector subtraction
-        Vec3 operator- (const Vec3& v) const {return Vec3 (x-v.x, y-v.y, z-v.z);}
-
-        // unary minus
-        Vec3 operator- (void) const {return Vec3 (-x, -y, -z);}
-
-        // vector times scalar product (scale length of vector times argument)
-        Vec3 operator* (const float s) const {return Vec3 (x * s, y * s, z * s);}
-
-        // vector divided by a scalar (divide length of vector by argument)
-        Vec3 operator/ (const float s) const {return Vec3 (x / s, y / s, z / s);}
-
-        // dot product
-        float dot (const Vec3& v) const {return (x * v.x) + (y * v.y) + (z * v.z);}
-
-        // length
-        float length (void) const {return sqrtXXX (lengthSquared ());}
-
-        // length squared
-        float lengthSquared (void) const {return this->dot (*this);}
-
-        // normalize: returns normalized version (parallel to this, length = 1)
-        Vec3 normalize (void) const
-        {
-            // skip divide if length is zero
-            const float len = length ();
-            return (len>0) ? (*this)/len : (*this);
-        }
-
-        // cross product (modify "*this" to be A x B)
-        // [XXX  side effecting -- deprecate this function?  XXX]
-        void cross(const Vec3& a, const Vec3& b)
-        {
-            *this = Vec3 ((a.y * b.z) - (a.z * b.y),
-                          (a.z * b.x) - (a.x * b.z),
-                          (a.x * b.y) - (a.y * b.x));
-        }
-
-        // assignment
-        Vec3 operator= (const Vec3& v) {x=v.x; y=v.y; z=v.z; return *this;}
-
-        // set XYZ coordinates to given three floats
-        Vec3 set (const float _x, const float _y, const float _z)
-        {x = _x; y = _y; z = _z; return *this;}
-
-        // +=
-        Vec3 operator+= (const Vec3& v) {return *this = (*this + v);}
-
-        // -=
-        Vec3 operator-= (const Vec3& v) {return *this = (*this - v);}
-
-        // *=
-        Vec3 operator*= (const float& s) {return *this = (*this * s);}
-
-        
-        Vec3 operator/=( float d ) { return *this = (*this / d);  }
-        
-        // equality/inequality
-        bool operator== (const Vec3& v) const {return x==v.x && y==v.y && z==v.z;}
-        bool operator!= (const Vec3& v) const {return !(*this == v);}
-
-        // @todo Remove - use @c distance from the Vec3Utilitites header instead.
-        // XXX experimental (4-1-03 cwr): is this the right approach?  defining
-        // XXX "Vec3 distance (vec3, Vec3)" collided with STL's distance template.
-        static float distance (const Vec3& a, const Vec3& b){ return(a-b).length();}
-
-        // --------------------------- utility member functions used in OpenSteer
-
         // return component of vector parallel to a unit basis vector
         // (IMPORTANT NOTE: assumes "basis" has unit magnitude (length==1))
 
-        inline Vec3 parallelComponent (const Vec3& unitBasis) const
+        static Vector3 parallelComponent (const Vector3& vector, const Vector3& unitBasis)
         {
-            const float projection = this->dot (unitBasis);
+            const float projection = vector.dotProduct(unitBasis);
             return unitBasis * projection;
         }
 
         // return component of vector perpendicular to a unit basis vector
         // (IMPORTANT NOTE: assumes "basis" has unit magnitude (length==1))
 
-        inline Vec3 perpendicularComponent (const Vec3& unitBasis) const
+        static Vector3 perpendicularComponent (const Vector3& vector, const Vector3& unitBasis)
         {
-            return (*this) - parallelComponent (unitBasis);
+            return vector - parallelComponent(vector, unitBasis);
         }
 
         // clamps the length of a given vector to maxLength.  If the vector is
@@ -165,33 +84,35 @@
         // the value returned has length of maxLength and is paralle to the
         // original input.
 
-        Vec3 truncateLength (const float maxLength) const
+        static Vector3 truncateLength (const Vector3& vector, const float maxLength)
         {
-            const float maxLengthSquared = maxLength * maxLength;
-            const float vecLengthSquared = this->lengthSquared ();
-            if (vecLengthSquared <= maxLengthSquared)
-                return *this;
+            const float vecLength = vector.length();
+            if (vecLength <= maxLength)
+                return vector;
             else
-                return (*this) * (maxLength / sqrtXXX (vecLengthSquared));
+                return vector * (maxLength / vecLength);
         }
 
         // forces a 3d position onto the XZ (aka y=0) plane
 
-        Vec3 setYtoZero (void) const {return Vec3 (this->x, 0, this->z);}
+        static Vector3 setYtoZero (const Vector3& vector)
+        {
+            return Vector3 (vector.x, 0, vector.z);
+        }
 
         // rotate this vector about the global Y (up) axis by the given angle
 
-        Vec3 rotateAboutGlobalY (float angle) const 
+        static Vector3 rotateAboutGlobalY (const Vector3& vector, float angle)
         {
             const float s = sinXXX (angle);
             const float c = cosXXX (angle);
-            return Vec3 ((this->x * c) + (this->z * s),
-                         (this->y),
-                         (this->z * c) - (this->x * s));
+            return Vector3 ((vector.x * c) + (vector.z * s),
+                         (vector.y),
+                         (vector.z * c) - (vector.x * s));
         }
 
         // version for caching sin/cos computation
-        Vec3 rotateAboutGlobalY (float angle, float& sin, float& cos) const 
+        static Vector3 rotateAboutGlobalY (const Vector3& vector, float angle, float& sin, float& cos)
         {
             // is both are zero, they have not be initialized yet
             if (sin==0 && cos==0)
@@ -199,67 +120,48 @@
                 sin = sinXXX (angle);
                 cos = cosXXX (angle);
             }
-            return Vec3 ((this->x * cos) + (this->z * sin),
-                         (this->y),
-                         (this->z * cos) - (this->x * sin));
+            return Vector3 ((vector.x * cos) + (vector.z * sin),
+                         (vector.y),
+                         (vector.z * cos) - (vector.x * sin));
         }
 
         // if this position is outside sphere, push it back in by one diameter
 
-        Vec3 sphericalWrapAround (const Vec3& center, float radius)
+        static Vector3 sphericalWrapAround (const Vector3& vector, const Vector3& center, float radius)
         {
-            const Vec3 offset = *this - center;
+            const Vector3 offset = vector - center;
             const float r = offset.length();
             if (r > radius)
-                return *this + ((offset/r) * radius * -2);
+                return vector + ((offset/r) * radius * -2);
             else
-                return *this;
+                return vector;
         }
-
-        // names for frequently used vector constants
-        static const Vec3 zero;
-        static const Vec3 side;
-        static const Vec3 up;
-        static const Vec3 forward;
     };
 
 
     // ----------------------------------------------------------------------------
-    // scalar times vector product ("float * Vec3")
+    // scalar times vector product ("float * Vector3")
 
 
-    inline Vec3 operator* (float s, const Vec3& v) {return v*s;}
+    inline Vector3 operator* (float s, const Vector3& v) {return v*s;}
 
 
 	// return cross product a x b
-	inline Vec3 crossProduct(const Vec3& a, const Vec3& b)
+	inline Vector3 crossProduct(const Vector3& a, const Vector3& b)
 	{
-		Vec3 result((a.y * b.z) - (a.z * b.y),
+		Vector3 result((a.y * b.z) - (a.z * b.y),
 					(a.z * b.x) - (a.x * b.z),
 					(a.x * b.y) - (a.y * b.x));
 		return result;
 	}
 
-
     // ----------------------------------------------------------------------------
-    // default character stream output method
-
-#ifndef NOT_OPENSTEERDEMO  // only when building OpenSteerDemo
-
-    inline std::ostream& operator<< (std::ostream& o, const Vec3& v)
-    {
-        return o << "(" << v.x << "," << v.y << "," << v.z << ")";
-    }
-
-#endif // NOT_OPENSTEERDEMO
-
-    // ----------------------------------------------------------------------------
     // Returns a position randomly distributed inside a sphere of unit radius
     // centered at the origin.  Orientation will be random and length will range
     // between 0 and 1
 
 
-    Vec3 RandomVectorInUnitRadiusSphere (void);
+    Vector3 RandomVectorInUnitRadiusSphere (void);
 
 
     // ----------------------------------------------------------------------------
@@ -268,7 +170,7 @@
     // random and length will range between 0 and 1
 
 
-    Vec3 randomVectorOnUnitRadiusXZDisk (void);
+    Vector3 randomVectorOnUnitRadiusXZDisk (void);
 
 
     // ----------------------------------------------------------------------------
@@ -277,9 +179,9 @@
     // and length will be 1
 
 
-    inline Vec3 RandomUnitVector (void)
+    inline Vector3 RandomUnitVector (void)
     {
-        return RandomVectorInUnitRadiusSphere().normalize();
+        return RandomVectorInUnitRadiusSphere().normalisedCopy();
     }
 
 
@@ -289,9 +191,9 @@
     // random and length will be 1
 
 
-    inline Vec3 RandomUnitVectorOnXZPlane (void)
+    inline Vector3 RandomUnitVectorOnXZPlane (void)
     {
-        return RandomVectorInUnitRadiusSphere().setYtoZero().normalize();
+        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
     }
 
 
@@ -299,10 +201,10 @@
     // used by limitMaxDeviationAngle / limitMinDeviationAngle below
 
 
-    Vec3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                        const Vec3& source,
+    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
+                                        const Vector3& source,
                                         const float cosineOfConeAngle,
-                                        const Vec3& basis);
+                                        const Vector3& basis);
 
 
     // ----------------------------------------------------------------------------
@@ -312,9 +214,9 @@
     // defined by the basis and an angle.
 
 
-    inline Vec3 limitMaxDeviationAngle (const Vec3& source,
+    inline Vector3 limitMaxDeviationAngle (const Vector3& source,
                                         const float cosineOfConeAngle,
-                                        const Vec3& basis)
+                                        const Vector3& basis)
     {
         return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
                                               source,
@@ -330,9 +232,9 @@
     // defined by the basis and an angle.
 
 
-    inline Vec3 limitMinDeviationAngle (const Vec3& source,
+    inline Vector3 limitMinDeviationAngle (const Vector3& source,
                                         const float cosineOfConeAngle,
-                                        const Vec3& basis)
+                                        const Vector3& basis)
     {    
         return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
                                               source,
@@ -347,12 +249,12 @@
     // the line ("lineUnitTangent")
 
 
-    inline float distanceFromLine (const Vec3& point,
-                                   const Vec3& lineOrigin,
-                                   const Vec3& lineUnitTangent)
+    inline float distanceFromLine (const Vector3& point,
+                                   const Vector3& lineOrigin,
+                                   const Vector3& lineUnitTangent)
     {
-        const Vec3 offset = point - lineOrigin;
-        const Vec3 perp = offset.perpendicularComponent (lineUnitTangent);
+        const Vector3 offset = point - lineOrigin;
+        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
         return perp.length();
     }
 
@@ -362,7 +264,7 @@
     // arbitrarily selects one of the infinitude of perpendicular vectors)
 
 
-    Vec3 findPerpendicularIn3d (const Vec3& direction);
+    Vector3 findPerpendicularIn3d (const Vector3& direction);
 
 
     // ----------------------------------------------------------------------------
@@ -379,4 +281,4 @@
     
 
 // ----------------------------------------------------------------------------
-#endif // OPENSTEER_VEC3_H
+#endif // OPENSTEER_Vector3_H

Modified: dependencies/opensteer/include/OpenSteer/Vec3Utilities.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3Utilities.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Vec3Utilities.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -27,7 +27,7 @@
 //
 // ----------------------------------------------------------------------------
 //
-// Utilities to work with Vec3.
+// Utilities to work with Vector3.
 //
 // 05-12-05 bk:  Created based on code of PolylinePathway.
 //
@@ -37,7 +37,7 @@
 #define OPENSTEER_VEC3UTILITIES_H
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::size_t
@@ -54,22 +54,22 @@
      * Returns the nearest point on the segment @a segmentPoint0 to 
      * @a segmentPoint1 from @a point.
      */
-    OpenSteer::Vec3  nearestPointOnSegment( const Vec3& point,
-                                            const Vec3& segmentPoint0,
-                                            const Vec3& segmentPoint1 );
+    Vector3  nearestPointOnSegment( const Vector3& point,
+                                            const Vector3& segmentPoint0,
+                                            const Vector3& segmentPoint1 );
     
     /**
      * Computes minimum distance from @a point to the line segment defined by
      * @a segmentPoint0 and @a segmentPoint1.
      */
-    float pointToSegmentDistance( const Vec3& point,
-                                  const Vec3& segmentPoint0,
-                                  const Vec3& segmentPoint1);
+    float pointToSegmentDistance( const Vector3& point,
+                                  const Vector3& segmentPoint0,
+                                  const Vector3& segmentPoint1);
         
     /**
      * Retuns distance between @a a and @a b.
      */
-    inline float distance (const Vec3& a, const Vec3& b) {
+    inline float distance (const Vector3& a, const Vector3& b) {
         return (a-b).length();
     } 
     
@@ -85,8 +85,8 @@
      */
     inline
     bool
-    equalsRelative( Vec3 const& lhs, 
-                     Vec3 const& rhs, 
+    equalsRelative( Vector3 const& lhs, 
+                     Vector3 const& rhs, 
                      float const& tolerance = std::numeric_limits< float >::epsilon()  ) {
         return equalsRelative( lhs.x, rhs.x, tolerance ) && equalsRelative( lhs.y, rhs.y ) && equalsRelative( lhs.z, rhs.z );
     }

Modified: dependencies/opensteer/plugins/Boids.cpp
===================================================================
--- dependencies/opensteer/plugins/Boids.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Boids.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -151,12 +151,12 @@
 
 
         // basic flocking
-        Vec3 steerToFlock (void)
+        Vector3 steerToFlock (void)
         {
             // avoid obstacles if needed
             // XXX this should probably be moved elsewhere
-            const Vec3 avoidance = steerToAvoidObstacles (1.0f, obstacles);
-            if (avoidance != Vec3::zero) return avoidance;
+            const Vector3 avoidance = steerToAvoidObstacles (1.0f, obstacles);
+            if (avoidance != Vector3::ZERO) return avoidance;
 
             const float separationRadius =  5.0f;
             const float separationAngle  = -0.707f;
@@ -187,20 +187,20 @@
     #endif // NO_LQ_BIN_STATS
 
             // determine each of the three component behaviors of flocking
-            const Vec3 separation = steerForSeparation (separationRadius,
+            const Vector3 separation = steerForSeparation (separationRadius,
                                                         separationAngle,
                                                         neighbors);
-            const Vec3 alignment  = steerForAlignment  (alignmentRadius,
+            const Vector3 alignment  = steerForAlignment  (alignmentRadius,
                                                         alignmentAngle,
                                                         neighbors);
-            const Vec3 cohesion   = steerForCohesion   (cohesionRadius,
+            const Vector3 cohesion   = steerForCohesion   (cohesionRadius,
                                                         cohesionAngle,
                                                         neighbors);
 
             // apply weights to components (save in variables for annotation)
-            const Vec3 separationW = separation * separationWeight;
-            const Vec3 alignmentW = alignment * alignmentWeight;
-            const Vec3 cohesionW = cohesion * cohesionWeight;
+            const Vector3 separationW = separation * separationWeight;
+            const Vector3 alignmentW = alignment * alignmentWeight;
+            const Vector3 cohesionW = cohesion * cohesionWeight;
 
             // annotation
             // const float s = 0.1;
@@ -219,7 +219,7 @@
             if (position().length() > worldRadius)
             {
                 // wrap around (teleport)
-                setPosition (position().sphericalWrapAround (Vec3::zero,
+                setPosition (position().sphericalWrapAround (Vector3::ZERO,
                                                              worldRadius));
                 if (this == OpenSteerDemo::selectedVehicle)
                 {
@@ -233,7 +233,7 @@
 
     // ---------------------------------------------- xxxcwr111704_terrain_following
         // control orientation for this boid
-        void regenerateLocalSpace (const Vec3& newVelocity,
+        void regenerateLocalSpace (const Vector3& newVelocity,
                                    const float elapsedTime)
         {
             // 3d flight with banking
@@ -247,20 +247,20 @@
         // XXX experiment:
         // XXX   herd with terrain following
         // XXX   special case terrain: a sphere at the origin, radius 40
-        void regenerateLocalSpaceForTerrainFollowing  (const Vec3& newVelocity,
+        void regenerateLocalSpaceForTerrainFollowing  (const Vector3& newVelocity,
                                                        const float /* elapsedTime */)
         {
 
             // XXX this is special case code, these should be derived from arguments //
-            const Vec3 surfaceNormal = position().normalize();                       //
-            const Vec3 surfacePoint = surfaceNormal * 40.0f;                         //
+            const Vector3 surfaceNormal = position().normalisedCopy();                       //
+            const Vector3 surfacePoint = surfaceNormal * 40.0f;                         //
             // XXX this is special case code, these should be derived from arguments //
 
-            const Vec3 newUp = surfaceNormal;
-            const Vec3 newPos = surfacePoint;
-            const Vec3 newVel = newVelocity.perpendicularComponent(newUp);
+            const Vector3 newUp = surfaceNormal;
+            const Vector3 newPos = surfacePoint;
+            const Vector3 newVel = newVelocity.perpendicularComponent(newUp);
             const float newSpeed = newVel.length();
-            const Vec3 newFor = newVel / newSpeed;
+            const Vector3 newFor = newVel / newSpeed;
 
             setSpeed (newSpeed);
             setPosition (newPos);
@@ -298,12 +298,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vec3 boxSide = side() * radius();
-            const Vec3 boxFront = forward() * minDistanceToCollision;
-            const Vec3 FR = position() + boxFront - boxSide;
-            const Vec3 FL = position() + boxFront + boxSide;
-            const Vec3 BR = position()            - boxSide;
-            const Vec3 BL = position()            + boxSide;
+            const Vector3 boxSide = side() * radius();
+            const Vector3 boxFront = forward() * minDistanceToCollision;
+            const Vector3 FR = position() + boxFront - boxSide;
+            const Vector3 FL = position() + boxFront + boxSide;
+            const Vector3 BR = position()            - boxSide;
+            const Vector3 BL = position()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -356,7 +356,7 @@
             OpenSteerDemo::camera.fixedDistVOffset = 0;
             OpenSteerDemo::camera.lookdownDistance = 20;
             OpenSteerDemo::camera.aimLeadTime = 0.5;
-            OpenSteerDemo::camera.povOffset.set (0, 0.5, -2);
+            OpenSteerDemo::camera.povOffset = Vector3(0, 0.5, -2);
 
             // set up obstacles
             initObstacles ();
@@ -429,7 +429,7 @@
             }
             status << std::endl;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
 
             drawObstacles ();
@@ -471,11 +471,11 @@
             {
             case 0:
                 {
-                    const Vec3 center;
+                    const Vector3 center;
                     const float div = 10.0f;
-                    const Vec3 divisions (div, div, div);
+                    const Vector3 divisions (div, div, div);
                     const float diameter = Boid::worldRadius * 1.1f * 2;
-                    const Vec3 dimensions (diameter, diameter, diameter);
+                    const Vector3 dimensions (diameter, diameter, diameter);
                     typedef LQProximityDatabase<AbstractVehicle*> LQPDAV;
                     pd = new LQPDAV (center, dimensions, divisions);
                     break;
@@ -600,15 +600,15 @@
         }
 
         class SO : public SphereObstacle
-        {void draw (const bool filled, const Color& color, const Vec3& vp) const
+        {void draw (const bool filled, const Color& color, const Vector3& vp) const
             {drawSphereObstacle (*this, 10.0f, filled, color, vp);}};
 
         class RO : public RectangleObstacle
-        {void draw (const bool, const Color& color, const Vec3&) const
+        {void draw (const bool, const Color& color, const Vector3&) const
             {tempDrawRectangle (*this, color);}};
 
         class BO : public BoxObstacle
-        {void draw (const bool, const Color& color, const Vec3&) const
+        {void draw (const bool, const Color& color, const Vector3&) const
             {tempDrawBox (*this, color);}};
 
         RO bigRectangle;
@@ -637,16 +637,16 @@
             const float p = Boid::worldRadius * 0.5f;
             const float m = -p;
             const float z = 0.0f;
-            outsideSphere1.center.set (p, z, z);
-            outsideSphere2.center.set (m, z, z);
-            outsideSphere3.center.set (z, p, z);
-            outsideSphere4.center.set (z, m, z);
-            outsideSphere5.center.set (z, z, p);
-            outsideSphere6.center.set (z, z, m);
+            outsideSphere1.center = Vector3(p, z, z);
+            outsideSphere2.center = Vector3(m, z, z);
+            outsideSphere3.center = Vector3(z, p, z);
+            outsideSphere4.center = Vector3(z, m, z);
+            outsideSphere5.center = Vector3(z, z, p);
+            outsideSphere6.center = Vector3(z, z, m);
 
-            const Vec3 tiltF = Vec3 (1.0f, 1.0f, 0.0f).normalize ();
-            const Vec3 tiltS (0.0f, 0.0f, 1.0f);
-            const Vec3 tiltU = Vec3 (-1.0f, 1.0f, 0.0f).normalize ();
+            const Vector3 tiltF = Vector3 (1.0f, 1.0f, 0.0f).normalisedCopy();
+            const Vector3 tiltS (0.0f, 0.0f, 1.0f);
+            const Vector3 tiltU = Vector3 (-1.0f, 1.0f, 0.0f).normalisedCopy();
 
             bigRectangle.width = 50.0f;
             bigRectangle.height = 80.0f;
@@ -737,10 +737,10 @@
             float w = rect.width / 2;
             float h = rect.height / 2;
 
-            Vec3 v1 = rect.globalizePosition (Vec3 ( w,  h, 0));
-            Vec3 v2 = rect.globalizePosition (Vec3 (-w,  h, 0));
-            Vec3 v3 = rect.globalizePosition (Vec3 (-w, -h, 0));
-            Vec3 v4 = rect.globalizePosition (Vec3 ( w, -h, 0));
+            Vector3 v1 = rect.globalizePosition (Vector3 ( w,  h, 0));
+            Vector3 v2 = rect.globalizePosition (Vector3 (-w,  h, 0));
+            Vector3 v3 = rect.globalizePosition (Vector3 (-w, -h, 0));
+            Vector3 v4 = rect.globalizePosition (Vector3 ( w, -h, 0));
 
             drawLine (v1, v2, color);
             drawLine (v2, v3, color);
@@ -754,20 +754,20 @@
             const float w = box.width / 2;
             const float h = box.height / 2;
             const float d = box.depth / 2;
-            const Vec3 p = box.position ();
-            const Vec3 s = box.side ();
-            const Vec3 u = box.up ();
-            const Vec3 f = box.forward ();
+            const Vector3 p = box.position ();
+            const Vector3 s = box.side ();
+            const Vector3 u = box.up ();
+            const Vector3 f = box.forward ();
 
-            const Vec3 v1 = box.globalizePosition (Vec3 ( w,  h,  d));
-            const Vec3 v2 = box.globalizePosition (Vec3 (-w,  h,  d));
-            const Vec3 v3 = box.globalizePosition (Vec3 (-w, -h,  d));
-            const Vec3 v4 = box.globalizePosition (Vec3 ( w, -h,  d));
+            const Vector3 v1 = box.globalizePosition (Vector3 ( w,  h,  d));
+            const Vector3 v2 = box.globalizePosition (Vector3 (-w,  h,  d));
+            const Vector3 v3 = box.globalizePosition (Vector3 (-w, -h,  d));
+            const Vector3 v4 = box.globalizePosition (Vector3 ( w, -h,  d));
 
-            const Vec3 v5 = box.globalizePosition (Vec3 ( w,  h, -d));
-            const Vec3 v6 = box.globalizePosition (Vec3 (-w,  h, -d));
-            const Vec3 v7 = box.globalizePosition (Vec3 (-w, -h, -d));
-            const Vec3 v8 = box.globalizePosition (Vec3 ( w, -h, -d));
+            const Vector3 v5 = box.globalizePosition (Vector3 ( w,  h, -d));
+            const Vector3 v6 = box.globalizePosition (Vector3 (-w,  h, -d));
+            const Vector3 v7 = box.globalizePosition (Vector3 (-w, -h, -d));
+            const Vector3 v8 = box.globalizePosition (Vector3 ( w, -h, -d));
 
             drawLine (v1, v2, color);
             drawLine (v2, v3, color);

Modified: dependencies/opensteer/plugins/CaptureTheFlag.cpp
===================================================================
--- dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -106,7 +106,7 @@
         static void initializeObstacles (void);
         static void addOneObstacle (void);
         static void removeOneObstacle (void);
-        float minDistanceToObstacle (const Vec3 point);
+        float minDistanceToObstacle (const Vector3 point);
         static int obstacleCount;
         static const int maxObstacleCount;
         static SOG allObstacles;
@@ -129,15 +129,15 @@
         // is there a clear path to the goal?
         bool clearPathToGoal (void);
 
-        Vec3 steeringForSeeker (void);
+        Vector3 steeringForSeeker (void);
         void updateState (const float currentTime);
         void draw (void);
-        Vec3 steerToEvadeAllDefenders (void);
-        Vec3 XXXsteerToEvadeAllDefenders (void);
+        Vector3 steerToEvadeAllDefenders (void);
+        Vector3 XXXsteerToEvadeAllDefenders (void);
         void adjustObstacleAvoidanceLookAhead (const bool clearPath);
         void clearPathAnnotation (const float threshold,
                                   const float behindcThreshold,
-                                  const Vec3& goalDirection);
+                                  const Vector3& goalDirection);
 
         seekerState state;
         bool evading; // xxx store steer sub-state for anotation
@@ -167,7 +167,7 @@
 
     const int CtfBase::maxObstacleCount = 100;
 
-    const Vec3 gHomeBaseCenter (0, 0, 0);
+    const Vector3 gHomeBaseCenter (0, 0, 0);
     const float gHomeBaseRadius = 1.5;
 
     const float gMinStartRadius = 30;
@@ -228,7 +228,7 @@
     void CtfSeeker::reset (void)
     {
         CtfBase::reset ();
-        bodyColor.set (0.4f, 0.4f, 0.6f); // blueish
+        bodyColor = Color(Vector3(0.4f, 0.4f, 0.6f)); // blueish
         gSeeker = this;
         state = running;
         evading = false;
@@ -238,7 +238,7 @@
     void CtfEnemy::reset (void)
     {
         CtfBase::reset ();
-        bodyColor.set (0.6f, 0.4f, 0.4f); // redish
+        bodyColor = Color(Vector3(0.6f, 0.4f, 0.4f)); // redish
     }
 
 
@@ -261,7 +261,7 @@
         // randomize position on a ring between inner and outer radii
         // centered around the home base
         const float rRadius = frandom2 (gMinStartRadius, gMaxStartRadius);
-        const Vec3 randomOnRing = RandomUnitVectorOnXZPlane () * rRadius;
+        const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * rRadius;
         setPosition (gHomeBaseCenter + randomOnRing);
 
         // are we are too close to an obstacle?
@@ -285,7 +285,7 @@
     void CtfEnemy::update (const float currentTime, const float elapsedTime)
     {
         // determine upper bound for pursuit prediction time
-        const float seekerToGoalDist = Vec3::distance (gHomeBaseCenter,
+        const float seekerToGoalDist = Vector3::distance (gHomeBaseCenter,
                                                        gSeeker->position());
         const float adjustedDistance = seekerToGoalDist - radius()-gHomeBaseRadius;
         const float seekerToGoalTime = ((adjustedDistance < 0 ) ?
@@ -294,15 +294,15 @@
         const float maxPredictionTime = seekerToGoalTime * 0.9f;
 
         // determine steering (pursuit, obstacle avoidance, or braking)
-        Vec3 steer (0, 0, 0);
+        Vector3 steer (0, 0, 0);
         if (gSeeker->state == running)
         {
-            const Vec3 avoidance =
+            const Vector3 avoidance =
                 steerToAvoidObstacles (gAvoidancePredictTimeMin,
                                        (ObstacleGroup&) allObstacles);
 
             // saved for annotation
-            avoiding = (avoidance == Vec3::zero);
+            avoiding = (avoidance == Vector3::ZERO);
 
             if (avoiding)
                 steer = steerForPursuit (*gSeeker, maxPredictionTime);
@@ -321,7 +321,7 @@
 
 
         // detect and record interceptions ("tags") of seeker
-        const float seekerToMeDist = Vec3::distance (position(), 
+        const float seekerToMeDist = Vector3::distance (position(), 
                                                      gSeeker->position());
         const float sumOfRadii = radius() + gSeeker->radius();
         if (seekerToMeDist < sumOfRadii)
@@ -350,9 +350,9 @@
         const float sideThreshold = radius() * 8.0f;
         const float behindThreshold = radius() * 2.0f;
 
-        const Vec3 goalOffset = gHomeBaseCenter - position();
+        const Vector3 goalOffset = gHomeBaseCenter - position();
         const float goalDistance = goalOffset.length ();
-        const Vec3 goalDirection = goalOffset / goalDistance;
+        const Vector3 goalDirection = goalOffset / goalDistance;
 
         const bool goalIsAside = isAside (gHomeBaseCenter, 0.5);
 
@@ -364,14 +364,14 @@
         {
             // short name for this enemy
             const CtfEnemy& e = *ctfEnemies[i];
-            const float eDistance = Vec3::distance (position(), e.position());
+            const float eDistance = Vector3::distance (position(), e.position());
             const float timeEstimate = 0.3f * eDistance / e.speed(); //xxx
-            const Vec3 eFuture = e.predictFuturePosition (timeEstimate);
-            const Vec3 eOffset = eFuture - position();
-            const float alongCorridor = goalDirection.dot (eOffset);
+            const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
+            const Vector3 eOffset = eFuture - position();
+            const float alongCorridor = goalDirection.dotProduct(eOffset);
             const bool inCorridor = ((alongCorridor > -behindThreshold) && 
                                      (alongCorridor < goalDistance));
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
 
             // xxx temp move this up before the conditionals
             annotationXZCircle (e.radius(), eFuture, clearPathColor, 20); //xxx
@@ -379,7 +379,7 @@
             // consider as potential blocker if within the corridor
             if (inCorridor)
             {
-                const Vec3 perp = eOffset - (goalDirection * alongCorridor);
+                const Vector3 perp = eOffset - (goalDirection * alongCorridor);
                 const float acrossCorridor = perp.length();
                 if (acrossCorridor < sideThreshold)
                 {
@@ -425,14 +425,14 @@
 
     void CtfSeeker::clearPathAnnotation (const float sideThreshold,
                                          const float behindThreshold,
-                                         const Vec3& goalDirection)
+                                         const Vector3& goalDirection)
     {
-        const Vec3 behindSide = side() * sideThreshold;
-        const Vec3 behindBack = forward() * -behindThreshold;
-        const Vec3 pbb = position() + behindBack;
-        const Vec3 gun = localRotateForwardToSide (goalDirection);
-        const Vec3 gn = gun * sideThreshold;
-        const Vec3 hbc = gHomeBaseCenter;
+        const Vector3 behindSide = side() * sideThreshold;
+        const Vector3 behindBack = forward() * -behindThreshold;
+        const Vector3 pbb = position() + behindBack;
+        const Vector3 gun = localRotateForwardToSide (goalDirection);
+        const Vector3 gn = gun * sideThreshold;
+        const Vector3 hbc = gHomeBaseCenter;
         annotationLine (pbb + gn,         hbc + gn,         clearPathColor);
         annotationLine (pbb - gn,         hbc - gn,         clearPathColor);
         annotationLine (hbc - gn,         hbc + gn,         clearPathColor);
@@ -448,12 +448,12 @@
 
     void CtfBase::annotateAvoidObstacle (const float minDistanceToCollision)
     {
-        const Vec3 boxSide = side() * radius();
-        const Vec3 boxFront = forward() * minDistanceToCollision;
-        const Vec3 FR = position() + boxFront - boxSide;
-        const Vec3 FL = position() + boxFront + boxSide;
-        const Vec3 BR = position()            - boxSide;
-        const Vec3 BL = position()            + boxSide;
+        const Vector3 boxSide = side() * radius();
+        const Vector3 boxFront = forward() * minDistanceToCollision;
+        const Vector3 FR = position() + boxFront - boxSide;
+        const Vector3 FL = position() + boxFront + boxSide;
+        const Vector3 BR = position()            - boxSide;
+        const Vector3 BL = position()            + boxSide;
         const Color white (1,1,1);
         annotationLine (FR, FL, white);
         annotationLine (FL, BL, white);
@@ -465,19 +465,19 @@
     // ----------------------------------------------------------------------------
 
 
-    Vec3 CtfSeeker::steerToEvadeAllDefenders (void)
+    Vector3 CtfSeeker::steerToEvadeAllDefenders (void)
     {
-        Vec3 evade (0, 0, 0);
-        const float goalDistance = Vec3::distance (gHomeBaseCenter, position());
+        Vector3 evade (0, 0, 0);
+        const float goalDistance = Vector3::distance (gHomeBaseCenter, position());
 
         // sum up weighted evasion
         for (int i = 0; i < ctfEnemyCount; i++)
         {
             const CtfEnemy& e = *ctfEnemies[i];
-            const Vec3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.position() - position();
             const float eDistance = eOffset.length();
 
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
             const float behindThreshold = radius() * 2;
             const bool behind = eForwardDistance < behindThreshold;
             if ((!behind) || (eDistance < 5))
@@ -486,13 +486,13 @@
                 {
                     // const float timeEstimate = 0.5f * eDistance / e.speed;//xxx
                     const float timeEstimate = 0.15f * eDistance / e.speed();//xxx
-                    const Vec3 future =
+                    const Vector3 future =
                         e.predictFuturePosition (timeEstimate);
 
                     annotationXZCircle (e.radius(), future, evadeColor, 20); // xxx
 
-                    const Vec3 offset = future - position();
-                    const Vec3 lateral = offset.perpendicularComponent (forward());
+                    const Vector3 offset = future - position();
+                    const Vector3 lateral = offset.perpendicularComponent (forward());
                     const float d = lateral.length();
                     const float weight = -1000 / (d * d);
                     evade += (lateral / d) * weight;
@@ -503,34 +503,34 @@
     }
 
 
-    Vec3 CtfSeeker::XXXsteerToEvadeAllDefenders (void)
+    Vector3 CtfSeeker::XXXsteerToEvadeAllDefenders (void)
     {
         // sum up weighted evasion
-        Vec3 evade (0, 0, 0);
+        Vector3 evade (0, 0, 0);
         for (int i = 0; i < ctfEnemyCount; i++)
         {
             const CtfEnemy& e = *ctfEnemies[i];
-            const Vec3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.position() - position();
             const float eDistance = eOffset.length();
 
             // xxx maybe this should take into account e's heading? xxx
             const float timeEstimate = 0.5f * eDistance / e.speed(); //xxx
-            const Vec3 eFuture = e.predictFuturePosition (timeEstimate);
+            const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
 
             // annotation
             annotationXZCircle (e.radius(), eFuture, evadeColor, 20);
 
             // steering to flee from eFuture (enemy's future position)
-            const Vec3 flee = xxxsteerForFlee (eFuture);
+            const Vector3 flee = xxxsteerForFlee (eFuture);
 
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
             const float behindThreshold = radius() * -2;
 
             const float distanceWeight = 4 / eDistance;
             const float forwardWeight = ((eForwardDistance > behindThreshold) ?
                                          1.0f : 0.5f);
 
-            const Vec3 adjustedFlee = flee * distanceWeight * forwardWeight;
+            const Vector3 adjustedFlee = flee * distanceWeight * forwardWeight;
 
             evade += adjustedFlee;
         }
@@ -541,17 +541,17 @@
     // ----------------------------------------------------------------------------
 
 
-    Vec3 CtfSeeker::steeringForSeeker (void)
+    Vector3 CtfSeeker::steeringForSeeker (void)
     {
         // determine if obstacle avodiance is needed
         const bool clearPath = clearPathToGoal ();
         adjustObstacleAvoidanceLookAhead (clearPath);
-        const Vec3 obstacleAvoidance =
+        const Vector3 obstacleAvoidance =
             steerToAvoidObstacles (gAvoidancePredictTime,
                                    (ObstacleGroup&) allObstacles);
 
         // saved for annotation
-        avoiding = (obstacleAvoidance != Vec3::zero);
+        avoiding = (obstacleAvoidance != Vector3::ZERO);
 
         if (avoiding)
         {
@@ -561,13 +561,13 @@
         else
         {
             // otherwise seek home base and perhaps evade defenders
-            const Vec3 seek = xxxsteerForSeek (gHomeBaseCenter);
+            const Vector3 seek = xxxsteerForSeek (gHomeBaseCenter);
             if (clearPath)
             {
                 // we have a clear path (defender-free corridor), use pure seek
 
                 // xxx experiment 9-16-02
-                Vec3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
+                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
 
                 annotationLine (position(), position() + (s * 0.2f), seekColor);
                 return s;
@@ -577,8 +577,8 @@
                 if (0) // xxx testing new evade code xxx
                 {
                     // combine seek and (forward facing portion of) evasion
-                    const Vec3 evade = steerToEvadeAllDefenders ();
-                    const Vec3 steer = 
+                    const Vector3 evade = steerToEvadeAllDefenders ();
+                    const Vector3 steer = 
                         seek + limitMaxDeviationAngle (evade, 0.5f, forward());
 
                     // annotation: show evasion steering force
@@ -588,8 +588,8 @@
                 else
 
                 {
-                    const Vec3 evade = XXXsteerToEvadeAllDefenders ();
-                    const Vec3 steer = limitMaxDeviationAngle (seek + evade,
+                    const Vector3 evade = XXXsteerToEvadeAllDefenders ();
+                    const Vector3 steer = limitMaxDeviationAngle (seek + evade,
                                                                0.707f, forward());
 
                     annotationLine (position(),position()+seek, gRed);
@@ -614,7 +614,7 @@
         if (clearPath)
         {
             evading = false;
-            const float goalDistance = Vec3::distance (gHomeBaseCenter,position());
+            const float goalDistance = Vector3::distance (gHomeBaseCenter,position());
             const bool headingTowardGoal = isAhead (gHomeBaseCenter, 0.98f);
             const bool isNear = (goalDistance/speed()) < gAvoidancePredictTimeMax;
             const bool useMax = headingTowardGoal && !isNear;
@@ -637,7 +637,7 @@
         // if we reach the goal before being tagged, switch to atGoal state
         if (state == running)
         {
-            const float baseDistance = Vec3::distance (position(),gHomeBaseCenter);
+            const float baseDistance = Vector3::distance (position(),gHomeBaseCenter);
             if (baseDistance < (radius() + gHomeBaseRadius)) state = atGoal;
         }
 
@@ -684,7 +684,7 @@
         }
 
         // annote seeker with its state as text
-        const Vec3 textOrigin = position() + Vec3 (0, 0.25, 0);
+        const Vector3 textOrigin = position() + Vector3 (0, 0.25, 0);
         std::ostringstream annote;
         annote << seekerStateString << std::endl;
         annote << std::setprecision(2) << std::setiosflags(std::ios::fixed)
@@ -697,7 +697,7 @@
         status << obstacleCount << " obstacles [F1/F2]" << std::endl;
         status << resetCount << " restarts" << std::ends;
         const float h = drawGetWindowHeight ();
-        const Vec3 screenLocation (10, h-50, 0);
+        const Vector3 screenLocation (10, h-50, 0);
         draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
     }
 
@@ -712,7 +712,7 @@
         updateState (currentTime);
 
         // determine and apply steering/braking forces
-        Vec3 steer (0, 0, 0);
+        Vector3 steer (0, 0, 0);
         if (state == running)
         {
             steer = steeringForSeeker ();
@@ -744,7 +744,7 @@
 
     #define testOneObstacleOverlap(radius, center)               \
     {                                                            \
-        float d = Vec3::distance (c, center);                    \
+        float d = Vector3::distance (c, center);                    \
         float clearance = d - (r + (radius));                    \
         if (minClearance > clearance) minClearance = clearance;  \
     }
@@ -768,7 +768,7 @@
             // pick a random center and radius,
             // loop until no overlap with other obstacles and the home base
             float r;
-            Vec3 c;
+            Vector3 c;
             float minClearance;
             const float requiredClearance = gSeeker->radius() * 4; // 2 x diameter
             do
@@ -794,10 +794,10 @@
     }
 
 
-    float CtfBase::minDistanceToObstacle (const Vec3 point)
+    float CtfBase::minDistanceToObstacle (const Vector3 point)
     {
         float r = 0;
-        Vec3 c = point;
+        Vector3 c = point;
         float minClearance = FLT_MAX;
         for (SOI so = allObstacles.begin(); so != allObstacles.end(); so++)
         {
@@ -848,8 +848,8 @@
             // initialize camera
             OpenSteerDemo::init2dCamera (*ctfSeeker);
             OpenSteerDemo::camera.mode = Camera::cmFixedDistanceOffset;
-            OpenSteerDemo::camera.fixedTarget.set (15, 0, 0);
-            OpenSteerDemo::camera.fixedPosition.set (80, 60, 0);
+            OpenSteerDemo::camera.fixedTarget = Vector3(15, 0, 0);
+            OpenSteerDemo::camera.fixedPosition = Vector3(80, 60, 0);
 
             CtfBase::initializeObstacles ();
         }
@@ -878,12 +878,12 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw "ground plane" centered between base and selected vehicle
-            const Vec3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
-            const Vec3 goalDirection = goalOffset.normalize ();
-            const Vec3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
-            const float goalDot = cameraForward.dot (goalDirection);
+            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
+            const Vector3 goalDirection = goalOffset.normalisedCopy();
+            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
+            const float goalDot = cameraForward.dotProduct(goalDirection);
             const float blend = remapIntervalClip (goalDot, 1, 0, 0.5, 0);
-            const Vec3 gridCenter = interpolate (blend,
+            const Vector3 gridCenter = interpolate (blend,
                                                  selected.position(),
                                                  gHomeBaseCenter);
             OpenSteerDemo::gridUtility (gridCenter);
@@ -957,7 +957,7 @@
 
         void drawHomeBase (void)
         {
-            const Vec3 up (0, 0.01f, 0);
+            const Vector3 up (0, 0.01f, 0);
             const Color atColor (0.3f, 0.3f, 0.5f);
             const Color noColor = gGray50;
             const bool reached = ctfSeeker->state == CtfSeeker::atGoal;

Modified: dependencies/opensteer/plugins/LowSpeedTurn.cpp
===================================================================
--- dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -113,7 +113,7 @@
         }
 
         // constant steering force
-        Vec3 steering (void) {return Vec3 (1, 0, -1);}
+        Vector3 steering (void) {return Vector3 (1, 0, -1);}
 
         // for stepping the starting conditions for next vehicle
         static float startX;
@@ -131,8 +131,8 @@
 
     const int lstCount = 5;
     const float lstLookDownDistance = 18;
-    const Vec3 lstViewCenter (7, 0, -2);
-    const Vec3 lstPlusZ (0, 0, 1);
+    const Vector3 lstViewCenter (7, 0, -2);
+    const Vector3 lstPlusZ (0, 0, 1);
 
 
     class LowSpeedTurnPlugIn : public PlugIn
@@ -199,8 +199,8 @@
 
                 // display speed near agent's screen position
                 const Color textColor (0.8f, 0.8f, 1.0f);
-                const Vec3 textOffset (0, 0.25f, 0);
-                const Vec3 textPosition = agent.position() + textOffset;
+                const Vector3 textOffset (0, 0.25f, 0);
+                const Vector3 textPosition = agent.position() + textOffset;
                 std::ostringstream annote;
                 annote << std::setprecision (2)
                        << std::setiosflags (std::ios::fixed)

Modified: dependencies/opensteer/plugins/MapDrive.cpp
===================================================================
--- dependencies/opensteer/plugins/MapDrive.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/MapDrive.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -96,10 +96,10 @@
     public:
         PointToRadiusMapping(): radius( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const& ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&  ) {}
+        void setPointOnPathCenterLine( Vector3 const& ) {}
+        void setPointOnPathBoundary( Vector3 const&  ) {}
         void setRadius( float r ) { radius = r; }
-        void setTangent( OpenSteer::Vec3 const& ) {}
+        void setTangent( Vector3 const& ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
@@ -113,19 +113,19 @@
     
     class PointToTangentMapping : public OpenSteer::DontExtractPathDistance {
     public:
-        PointToTangentMapping() : tangent( OpenSteer::Vec3( 0.0f, 0.0f, 0.0f ) ) {}
+        PointToTangentMapping() : tangent( Vector3( 0.0f, 0.0f, 0.0f ) ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const& ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&  ) {}
+        void setPointOnPathCenterLine( Vector3 const& ) {}
+        void setPointOnPathBoundary( Vector3 const&  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const& t ) { tangent = t; }
+        void setTangent( Vector3 const& t ) { tangent = t; }
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
         void setDistanceOnPath( float  ) {}
         void setDistanceOnSegment( float ) {}
         
-        OpenSteer::Vec3 tangent;
+        Vector3 tangent;
     };
 
 
@@ -133,19 +133,19 @@
     
     class PointToPointOnCenterLineAndOutsideMapping : public OpenSteer::DontExtractPathDistance {
     public:
-        PointToPointOnCenterLineAndOutsideMapping() : pointOnPathCenterLine( OpenSteer::Vec3( 0.0f, 0.0f, 0.0f ) ), distancePointToPathBoundary( 0.0f ) {}
+        PointToPointOnCenterLineAndOutsideMapping() : pointOnPathCenterLine( Vector3( 0.0f, 0.0f, 0.0f ) ), distancePointToPathBoundary( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const& point) { pointOnPathCenterLine = point; }
-        void setPointOnPathBoundary( OpenSteer::Vec3 const& ) {}
+        void setPointOnPathCenterLine( Vector3 const& point) { pointOnPathCenterLine = point; }
+        void setPointOnPathBoundary( Vector3 const& ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const& ) {}
+        void setTangent( Vector3 const& ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float d ) { distancePointToPathBoundary = d; }
         void setDistancePointToPathCenterLine( float ) {}
         void setDistanceOnPath( float  ) {}
         void setDistanceOnSegment( float ) {}    
         
-        OpenSteer::Vec3 pointOnPathCenterLine;
+        Vector3 pointOnPathCenterLine;
         float distancePointToPathBoundary;
     };
 
@@ -156,10 +156,10 @@
     public:
         PointToOutsideMapping() : distancePointToPathBoundary( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const& ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&  ) {}
+        void setPointOnPathCenterLine( Vector3 const& ) {}
+        void setPointOnPathBoundary( Vector3 const&  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const& ) {}
+        void setTangent( Vector3 const& ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float d ) { distancePointToPathBoundary = d; }
         void setDistancePointToPathCenterLine( float ) {}
@@ -175,10 +175,10 @@
     public:
         PointToSegmentIndexMapping() : segmentIndex( 0 ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const& ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&  ) {}
+        void setPointOnPathCenterLine( Vector3 const& ) {}
+        void setPointOnPathBoundary( Vector3 const&  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const& ) {}
+        void setTangent( Vector3 const& ) {}
         void setSegmentIndex( OpenSteer::size_t i ) { segmentIndex = i; }
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
@@ -191,7 +191,7 @@
     /**
      * Maps @a point to @a pathway and extracts the radius at the mapping point.
      */
-    float mapPointToRadius( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point ) {
+    float mapPointToRadius( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point ) {
         PointToRadiusMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.radius;
@@ -201,7 +201,7 @@
      * Maps @a point to @a pathway and extracts the tangent at the mapping 
      * point.
      */
-    OpenSteer::Vec3 mapPointToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point ) {
+    Vector3 mapPointToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point ) {
         PointToTangentMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.tangent;
@@ -214,12 +214,12 @@
      */
     bool isInsidePathSegment( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway,  
                               OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex, 
-                              OpenSteer::Vec3 const& point ) {
+                              Vector3 const& point ) {
         assert( pathway.isValid() && "pathway isn't valid." );
         assert( segmentIndex < pathway.segmentCount() && "segmentIndex out of range." );
         
         float const segmentDistance = pathway.mapPointToSegmentDistance( segmentIndex, point );
-        OpenSteer::Vec3 const pointOnSegmentCenterLine = pathway.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
+        Vector3 const pointOnSegmentCenterLine = pathway.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
         float const segmentRadiusAtPoint = pathway.mapSegmentDistanceToRadius( segmentIndex, segmentDistance );
         
         float const distancePointToPointOnSegmentCenterLine = (point - pointOnSegmentCenterLine).length();
@@ -238,7 +238,7 @@
      * @param direction Follow the path in path direction (@c 1) or in reverse
      *                  direction ( @c -1 ).
      */
-    OpenSteer::Vec3 mapPointAndDirectionToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point, int direction ) {
+    Vector3 mapPointAndDirectionToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point, int direction ) {
         assert( ( ( 1 == direction ) || ( -1 == direction ) ) && "direction must be 1 or -1." );
         typedef OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type size_type;
         
@@ -279,7 +279,7 @@
      *
      * On point on the boundary isn't inside the pathway.
      */
-    bool isNearWaypoint( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point ) {
+    bool isNearWaypoint( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point ) {
         assert( pathway.isValid() && "pathway must be valid." );
         
         typedef OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type size_type;
@@ -287,8 +287,8 @@
         size_type pointIndex = 0;
         
         // Test first waypoint.
-        OpenSteer::Vec3 pointPathwayPointVector = point - pathway.point( pointIndex );
-        float pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+        Vector3 pointPathwayPointVector = point - pathway.point( pointIndex );
+        float pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
         if ( pointPathwayPointDistance < OpenSteer::square( pathway.segmentRadius( pointIndex ) ) ) {
             return true;
         }
@@ -297,7 +297,7 @@
         size_type const maxInnerPointIndex = pathway.pointCount() - 2;
         for ( pointIndex = 1; pointIndex <= maxInnerPointIndex; ++pointIndex ) {
             pointPathwayPointVector = point - pathway.point( pointIndex );
-            pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+            pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
             if ( ( pointPathwayPointDistance < OpenSteer::square( pathway.segmentRadius( pointIndex ) ) ) ||
                  ( pointPathwayPointDistance < OpenSteer::square( pathway.segmentRadius( pointIndex - 1) ) ) ) {
                 return true;
@@ -306,7 +306,7 @@
 
         // Test last waypoint.
         pointPathwayPointVector = point - pathway.point( pointIndex );
-        pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+        pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
         if ( pointPathwayPointDistance < OpenSteer::square( pathway.segmentRadius( pointIndex - 1 ) ) ) {
             return true;
         }
@@ -331,7 +331,7 @@
      * Maps @a point to @a pathway and returns the mapping point on the pathway 
      * boundary and how far outside @a point is from the mapping point.
      */
-    OpenSteer::Vec3 mapPointToPointOnCenterLineAndOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point, float& outside ) {
+    Vector3 mapPointToPointOnCenterLineAndOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point, float& outside ) {
         PointToPointOnCenterLineAndOutsideMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         outside = mapping.distancePointToPathBoundary;
@@ -343,7 +343,7 @@
      * Maps @a point to @a pathway and returns how far outside @a point is from 
      * the mapping point on the path boundary.
      */
-    float mapPointToOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point ) {
+    float mapPointToOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point ) {
         PointToOutsideMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping);
         return mapping.distancePointToPathBoundary;    
@@ -353,13 +353,13 @@
      * Returns @c true if @a point is inside @a pathway, @c false otherwise.
      * A point on the boundary isn't inside the pathway.
      */
-    bool isInsidePathway( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, OpenSteer::Vec3 const& point ) {
+    bool isInsidePathway( OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, Vector3 const& point ) {
         return 0.0f > mapPointToOutside( pathway, point );
     }
     
 
     OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type mapPointToSegmentIndex(  OpenSteer::PolylineSegmentedPathwaySegmentRadii const& pathway, 
-                                                                                        OpenSteer::Vec3 const& point ) {
+                                                                                        Vector3 const& point ) {
         PointToSegmentIndexMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.segmentIndex;
@@ -381,7 +381,7 @@
     public:
 
         // constructor
-        TerrainMap (const Vec3& c, float x, float z, int r)
+        TerrainMap (const Vector3& c, float x, float z, int r)
             : center(c),
               xSize(x),
               zSize(z),
@@ -418,10 +418,10 @@
 
 
         // get a value based on a position in 3d world space
-        bool getMapValue (const Vec3& point) const
+        bool getMapValue (const Vector3& point) const
         {
-            const Vec3 local = point - center;
-            const Vec3 localXZ = local.setYtoZero();
+            const Vector3 local = point - center;
+            const Vector3 localXZ = local.setYtoZero();
 
             const float hxs = xSize/2;
             const float hzs = zSize/2;
@@ -449,9 +449,9 @@
         {
             const float xs = xSize/(float)resolution;
             const float zs = zSize/(float)resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-xSize, 0, zs);
-            Vec3 g ((xSize - xs) / -2, 0, (zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-xSize, 0, zs);
+            Vector3 g ((xSize - xs) / -2, 0, (zSize - zs) / -2);
             g += center;
             for (int j = 0; j < resolution; j++)
             {
@@ -460,23 +460,23 @@
                     if (getMapBit (i, j))
                     {
                         // spikes
-                        // const Vec3 spikeTop (0, 5.0f, 0);
+                        // const Vector3 spikeTop (0, 5.0f, 0);
                         // drawLine (g, g+spikeTop, gWhite);
 
                         // squares
                         const float rockHeight = 0;
-                        const Vec3 v1 (+xs/2, rockHeight, +zs/2);
-                        const Vec3 v2 (+xs/2, rockHeight, -zs/2);
-                        const Vec3 v3 (-xs/2, rockHeight, -zs/2);
-                        const Vec3 v4 (-xs/2, rockHeight, +zs/2);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
+                        const Vector3 v1 (+xs/2, rockHeight, +zs/2);
+                        const Vector3 v2 (+xs/2, rockHeight, -zs/2);
+                        const Vector3 v3 (-xs/2, rockHeight, -zs/2);
+                        const Vector3 v4 (-xs/2, rockHeight, +zs/2);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
                         const Color orangeRockColor (0.5f, 0.2f, 0.0f);
                         drawQuadrangle (g+v1, g+v2, g+v3, g+v4, orangeRockColor);
 
                         // pyramids
-                        // const Vec3 top (0, xs/2, 0);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
-                        // const Vec3 orangeRockColor (0.5f, 0.2f, 0.0f);
+                        // const Vector3 top (0, xs/2, 0);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
+                        // const Vector3 orangeRockColor (0.5f, 0.2f, 0.0f);
                         // drawTriangle (g+v1, g+v2, g+top, redRockColor);
                         // drawTriangle (g+v2, g+v3, g+top, orangeRockColor);
                         // drawTriangle (g+v3, g+v4, g+top, redRockColor);
@@ -505,8 +505,8 @@
             {
                 for (float z = zMin; z < zMax; z += spacing)
                 {
-                    const Vec3 sample (x, 0, z);
-                    const Vec3 global = localSpace.globalizePosition (sample);
+                    const Vector3 sample (x, 0, z);
+                    const Vector3 global = localSpace.globalizePosition (sample);
                     if (getMapValue (global)) return true;
                 }
             }
@@ -516,11 +516,11 @@
         // Scans along a ray (directed line segment) on the XZ plane, sampling
         // the map for a "true" cell.  Returns the index of the first sample
         // that gets a "hit", or zero if no hits found.
-        int scanXZray (const Vec3& origin,
-                       const Vec3& sampleSpacing,
+        int scanXZray (const Vector3& origin,
+                       const Vector3& sampleSpacing,
                        const int sampleCount) const
         {
-            Vec3 samplePoint (origin);
+            Vector3 samplePoint (origin);
 
             for (int i = 1; i <= sampleCount; i++)
             {
@@ -534,10 +534,10 @@
 
         int cellwidth (void) const {return resolution;}  // xxx cwr
         int cellheight (void) const {return resolution;}  // xxx cwr
-        bool isPassable (const Vec3& point) const {return ! getMapValue (point);}
+        bool isPassable (const Vector3& point) const {return ! getMapValue (point);}
 
 
-        Vec3 center;
+        Vector3 center;
         float xSize;
         float zSize;
         int resolution;
@@ -580,7 +580,7 @@
         // array of points, an array of per-segment path radii, and a flag
         // indiating if the path is connected at the end.
         GCRoute (const int _pointCount,
-                 const Vec3 _points[],
+                 const Vector3 _points[],
                  const float _radii[],
                  const bool _cyclic)
         {
@@ -607,9 +607,9 @@
         // P and a measure of how far A is outside the Pathway's "tube".  Note
         // that a negative distance indicates A is inside the Pathway.
 
-        Vec3 mapPointToPath (const Vec3& point, Vec3& tangent, float& outside)
+        Vector3 mapPointToPath (const Vector3& point, Vector3& tangent, float& outside)
         {
-            Vec3 onPath;
+            Vector3 onPath;
             outside = FLT_MAX;
 
             // loop over all segments, find the one nearest to the given point
@@ -640,15 +640,15 @@
 
         // ignore that "tangent" output argument which is never used
         // XXX eventually move this to Pathway class
-        Vec3 mapPointToPath (const Vec3& point, float& outside)
+        Vector3 mapPointToPath (const Vector3& point, float& outside)
         {
-            Vec3 tangent;
+            Vector3 tangent;
             return mapPointToPath (point, tangent, outside);
         }
 
         // get the index number of the path segment nearest the given point
         // XXX consider moving this to path class
-        int indexOfNearestSegment (const Vec3& point)
+        int indexOfNearestSegment (const Vector3& point)
         {
             int index = 0;
             float minDistance = FLT_MAX;
@@ -672,11 +672,11 @@
         // used to measure the "angle" at a path vertex: how sharp is the turn?
         float dotSegmentUnitTangents (int segmentIndex0, int segmentIndex1)
         {
-            return normals[segmentIndex0].dot (normals[segmentIndex1]);
+            return normals[segmentIndex0].dotProduct(normals[segmentIndex1]);
         }
 
         // return path tangent at given point (its projection on path)
-        Vec3 tangentAt (const Vec3& point)
+        Vector3 tangentAt (const Vector3& point)
         {
             return normals [indexOfNearestSegment (point)];
         }
@@ -685,7 +685,7 @@
         // multiplied by the given pathfollowing direction (+1/-1 =
         // upstream/downstream).  Near path vertices (waypoints) use the
         // tangent of the "next segment" in the given direction
-        Vec3 tangentAt (const Vec3& point, const int pathFollowDirection)
+        Vector3 tangentAt (const Vector3& point, const int pathFollowDirection)
         {
             const int segmentIndex = indexOfNearestSegment (point);
             const int nextIndex = segmentIndex + pathFollowDirection;
@@ -697,7 +697,7 @@
 
         // is the given point "near" a waypoint of this path?  ("near" == closer
         // to the waypoint than the max of radii of two adjacent segments)
-        bool nearWaypoint (const Vec3& point)
+        bool nearWaypoint (const Vector3& point)
         {
             // loop over all waypoints
             for (int i = 1; i < pointCount; i++)
@@ -713,7 +713,7 @@
         // is the given point inside the path tube of the given segment
         // number?  (currently not used. this seemed like a useful utility,
         // but wasn't right for the problem I was trying to solve)
-        bool isInsidePathSegment (const Vec3& point, const int segmentIndex)
+        bool isInsidePathSegment (const Vector3& point, const int segmentIndex)
         {
             const int i = segmentIndex;
 
@@ -817,7 +817,7 @@
             adjustVehicleRadiusForSpeed ();
 
             // not previously avoiding
-            annotateAvoid = Vec3::zero;
+            annotateAvoid = Vector3::ZERO;
 
             // prevent long streaks due to teleportation 
             clearTrailHistory ();
@@ -826,7 +826,7 @@
             stuck = false;
 
             // QQQ need to clean up this hack
-            qqqLastNearestObstacle = Vec3::zero;
+            qqqLastNearestObstacle = Vector3::ZERO;
 
             // master look ahead (prediction) time
             baseLookAheadTime = 3;
@@ -836,15 +836,15 @@
                 lapsStarted++;
                 const float s = worldSize;
                 const float d = (float) pathFollowDirection;
-                setPosition (Vec3 (s * d * 0.6f, 0, s * -0.4f));
-                regenerateOrthonormalBasisUF (Vec3::side * d);
+                setPosition (Vector3 (s * d * 0.6f, 0, s * -0.4f));
+                regenerateOrthonormalBasisUF (Vector3::side * d);
             }
 
             // reset bookeeping to detect stuck cycles
             resetStuckCycleDetection ();
 
             // assume no previous steering
-            currentSteering = Vec3::zero;
+            currentSteering = Vector3::ZERO;
 
             // assume normal running state
             dtZero = false;
@@ -872,7 +872,7 @@
             annoteMaxRelSpeed = annoteMaxRelSpeedCurve = annoteMaxRelSpeedPath = 1;
 
             // determine combined steering
-            Vec3 steering;
+            Vector3 steering;
             const bool offPath = !bodyInsidePath ();
             if (stuck || offPath || detectImminentCollision ())
             {
@@ -887,16 +887,16 @@
 
                 // QQQ trying to prevent "creep" during emergency stops
                 resetSmoothedAcceleration ();
-                currentSteering = Vec3::zero;
+                currentSteering = Vector3::ZERO;
             }
             else
             {
                 // determine steering for obstacle avoidance (save for annotation)
-                const Vec3 avoid = annotateAvoid = 
+                const Vector3 avoid = annotateAvoid = 
                     steerToAvoidObstaclesOnMap (lookAheadTimeOA (),
                                                 *map,
                                                 hintForObstacleAvoidance ());
-                const bool needToAvoid = avoid != Vec3::zero;
+                const bool needToAvoid = avoid != Vector3::ZERO;
 
                 // any obstacles to avoid?
                 if (needToAvoid)
@@ -917,10 +917,10 @@
                     // wander for demo 1
                     if (demoSelect == 1)
                     {
-                        const Vec3 wander = steerForWander (elapsedTime);
-                        const Vec3 flat = wander.setYtoZero ();
-                        const Vec3 weighted = flat.truncateLength (maxForce()) * 6;
-                        const Vec3 a = position() + Vec3 (0, 0.2f, 0);
+                        const Vector3 wander = steerForWander (elapsedTime);
+                        const Vector3 flat = wander.setYtoZero ();
+                        const Vector3 weighted = flat.truncateLength (maxForce()) * 6;
+                        const Vector3 a = position() + Vector3 (0, 0.2f, 0);
                         annotationLine (a, a + (weighted * 0.3f), gWhite);
                         steering += weighted;
                     }
@@ -928,13 +928,13 @@
                     // follow the path in demo 2
                     if (demoSelect == 2)
                     {
-                        const Vec3 pf = steerToFollowPath (pathFollowDirection,
+                        const Vector3 pf = steerToFollowPath (pathFollowDirection,
                                                            lookAheadTimePF (),
                                                            *path);
-                        if (pf != Vec3::zero)
+                        if (pf != Vector3::ZERO)
                         {
                             // steer to remain on path
-                            if (pf.dot (forward()) < 0)
+                            if (pf.dotProduct(forward()) < 0)
                                 steering = pf;
                             else
                                 steering = pf + steering;
@@ -943,9 +943,9 @@
                         {
                             // path aligment: when neither obstacle avoidance nor
                             // path following is required, align with path segment
-                            const Vec3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
+                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
                             {
-                                const Vec3 b = (position () +
+                                const Vector3 b = (position () +
                                                 (up () * 0.2f) +
                                                 (forward () * halfLength * 1.4f));
                                 const float l = 2;
@@ -995,10 +995,10 @@
     //  //
     //  // reduce lateral steering at low speeds
     //  //
-    //  Vec3 reduceTurningAtLowSpeeds (const Vec3& rawSteering)
+    //  Vector3 reduceTurningAtLowSpeeds (const Vector3& rawSteering)
     //  {
-    //      const Vec3 thrust = rawSteering.parallelComponent (forward ());
-    //      const Vec3 lateral = rawSteering.perpendicularComponent (forward ());
+    //      const Vector3 thrust = rawSteering.parallelComponent (forward ());
+    //      const Vector3 lateral = rawSteering.perpendicularComponent (forward ());
     //      // const float adjust = relativeSpeed ();
     //      // const float adjust = square (relativeSpeed ());
     //      const float adjust = square (square (relativeSpeed ()));
@@ -1055,18 +1055,18 @@
         }
 
 
-        Vec3 hintForObstacleAvoidance (void)
+        Vector3 hintForObstacleAvoidance (void)
         {
             // used only when path following, return zero ("no hint") otherwise
-            if (demoSelect != 2) return Vec3::zero;
+            if (demoSelect != 2) return Vector3::ZERO;
 
             // are we heading roughly parallel to the current path segment?
-            const Vec3 p = position ();
-            const Vec3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path->tangentAt (p, pathFollowDirection);
-            if (pathHeading.dot (forward ()) < 0.8f)
+            const Vector3 p = position ();
+            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path->tangentAt (p, pathFollowDirection);
+            if (pathHeading.dotProduct(forward ()) < 0.8f)
             {
                 // if not, the "hint" is to turn to align with path heading
-                const Vec3 s = side () * halfWidth;
+                const Vector3 s = side () * halfWidth;
                 const float f = halfLength * 2;
                 annotationLine (p + s, p + s + (forward () * f), gBlack);
                 annotationLine (p - s, p - s + (forward () * f), gBlack);
@@ -1076,14 +1076,14 @@
             else
             {
                 // when there is a valid nearest obstacle position
-                const Vec3 obstacle = qqqLastNearestObstacle;
-                const Vec3 o = obstacle + (up () * 0.1f);
-                if (obstacle != Vec3::zero)
+                const Vector3 obstacle = qqqLastNearestObstacle;
+                const Vector3 o = obstacle + (up () * 0.1f);
+                if (obstacle != Vector3::ZERO)
                 {
                     // get offset, distance from obstacle to its image on path
                     float outside;
-                    const Vec3 onPath = mapPointToPointOnCenterLineAndOutside( *path, obstacle, outside );// path->mapPointToPath (obstacle, outside);
-                    const Vec3 offset = onPath - obstacle;
+                    const Vector3 onPath = mapPointToPointOnCenterLineAndOutside( *path, obstacle, outside );// path->mapPointToPath (obstacle, outside);
+                    const Vector3 offset = onPath - obstacle;
                     const float offsetDistance = offset.length();
 
                     // when the obstacle is inside the path tube
@@ -1104,7 +1104,7 @@
                             const bool usableHint = obstacleDistance>farThreshold;
                             if (usableHint)
                             {
-                                const Vec3 q = p + (offset.normalize() * 5);
+                                const Vector3 q = p + (offset.normalisedCopy() * 5);
                                 annotationLine (p, q, gMagenta);
                                 annotationCircleOrDisk (0.4f, up(), o, gWhite,
                                                         12, false, false);
@@ -1116,36 +1116,36 @@
                 }
             }
             // otherwise, no hint
-            return Vec3::zero;
+            return Vector3::ZERO;
         }
 
 
         // like steerToAvoidObstacles, but based on a BinaryTerrainMap indicating
         // the possitions of impassible regions
         //
-        Vec3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
+        Vector3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
                                          const TerrainMap& map)
         {
             return steerToAvoidObstaclesOnMap (minTimeToCollision,
                                                map,
-                                               Vec3::zero); // no steer hint
+                                               Vector3::ZERO); // no steer hint
         }
 
 
         // given a map of obstacles (currently a global, binary map) steer so as
         // to avoid collisions within the next minTimeToCollision seconds.
         //
-        Vec3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
+        Vector3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
                                          const TerrainMap& map,
-                                         const Vec3& steerHint)
+                                         const Vector3& steerHint)
         {
             const float spacing = map.minSpacing() / 2;
             const float maxSide = radius();
             const float maxForward = minTimeToCollision * speed();
             const int maxSamples = (int) (maxForward / spacing);
-            const Vec3 step = forward () * spacing;
-            const Vec3 fOffset = position ();
-            Vec3 sOffset;
+            const Vector3 step = forward () * spacing;
+            const Vector3 fOffset = position ();
+            Vector3 sOffset;
             float s = spacing / 2;
 
             const int infinity = 9999; // qqq
@@ -1153,11 +1153,11 @@
             int nearestR = infinity;
             int nearestWL = infinity;
             int nearestWR = infinity;
-            Vec3 nearestO;
+            Vector3 nearestO;
             wingDrawFlagL = false;
             wingDrawFlagR = false;
 
-            const bool hintGiven = steerHint != Vec3::zero;
+            const bool hintGiven = steerHint != Vector3::ZERO;
             if (hintGiven && !dtZero) hintGivenCount++;
             if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, up(),
                                                    position () + (up () * 0.2f),
@@ -1167,8 +1167,8 @@
             QQQoaJustScraping = true;
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1185,8 +1185,8 @@
                 if ((speed() * minTimeToCollision) > (circumference * fracLimit))
                 {
                     const float q = twoPi * fracLimit;
-                    const Vec3 fooz = position () - center;
-                    const Vec3 booz = fooz.rotateAboutGlobalY (sign * q);
+                    const Vector3 fooz = position () - center;
+                    const Vector3 booz = fooz.rotateAboutGlobalY (sign * q);
                     annotationLine (center, center + fooz, gRed);
                     annotationLine (center, center + booz, gRed);
                 }
@@ -1201,10 +1201,10 @@
             {
                 sOffset = side() * s;
                 s += spacing;
-                const Vec3 lOffset = fOffset + sOffset;
-                const Vec3 rOffset = fOffset - sOffset;
+                const Vector3 lOffset = fOffset + sOffset;
+                const Vector3 rOffset = fOffset - sOffset;
 
-                Vec3 lObsPos, rObsPos;
+                Vector3 lObsPos, rObsPos;
 
                 const int L = (curvedSteering ? 
                                (int) (scanObstacleMap (lOffset,
@@ -1265,7 +1265,7 @@
                 const int wingScans = 4;
                 // see duplicated code at: QQQ draw sensing "wings"
                 // QQQ should be a parameter of this method
-                const Vec3 wingWidth = side() * wingSlope () * maxForward;
+                const Vector3 wingWidth = side() * wingSlope () * maxForward;
 
                 const Color beforeColor (0.75f, 0.9f, 0.0f);  // for annotation
                 const Color afterColor  (0.9f,  0.5f, 0.0f);  // for annotation
@@ -1273,23 +1273,23 @@
                 for (int i=1; i<=wingScans; i++)
                 {
                     const float fraction = (float)i / (float)wingScans;
-                    const Vec3 endside = sOffset + (wingWidth * fraction);
-                    const Vec3 corridorFront = forward() * maxForward;
+                    const Vector3 endside = sOffset + (wingWidth * fraction);
+                    const Vector3 corridorFront = forward() * maxForward;
 
                     // "loop" from -1 to 1
                     for (int j = -1; j < 2; j+=2)
                     {
                         float k = (float)j; // prevent VC7.1 warning
-                        const Vec3 start = fOffset + (sOffset * k);
-                        const Vec3 end = fOffset + corridorFront + (endside * k);
-                        const Vec3 ray = end - start;
+                        const Vector3 start = fOffset + (sOffset * k);
+                        const Vector3 end = fOffset + corridorFront + (endside * k);
+                        const Vector3 ray = end - start;
                         const float rayLength = ray.length();
-                        const Vec3 step = ray * spacing / rayLength;
+                        const Vector3 step = ray * spacing / rayLength;
                         const int raySamples = (int) (rayLength / spacing);
                         const float endRadius =
                             wingSlope () * maxForward * fraction *
                             (signedRadius < 0 ? 1 : -1) * (j==1?1:-1);
-                        Vec3 ignore;
+                        Vector3 ignore;
                         const int scan = (curvedSteering ?
                                           (int) (scanObstacleMap (start,
                                                                   center,
@@ -1349,14 +1349,14 @@
             // no obstacles found on path, return zero steering
             if (obstacleFreeC)
             {
-                qqqLastNearestObstacle = Vec3::zero;
+                qqqLastNearestObstacle = Vector3::ZERO;
                 annotationNoteOAClauseName ("obstacleFreeC");
 
                 // qqq  this may be in the wrong place (what would be the right
                 // qqq  place?!) but I'm trying to say "even if the path is
                 // qqq  clear, don't go too fast when driving between obstacles
                 if (obstacleFreeWL || obstacleFreeWR || relativeSpeed () < 0.7f)
-                    return Vec3::zero;
+                    return Vector3::ZERO;
                 else
                     return -forward ();
             }
@@ -1368,7 +1368,7 @@
             {
                 annotationNoteOAClauseName ("nearest obstacle is way out there");
                 annotationHintWasTaken ();
-                if (steerHint.dot(side())>0) return side();else return -side();
+                if (steerHint.dotProduct(side())>0) return side();else return -side();
             }
 
             // QQQ experiment 3-9-04
@@ -1404,7 +1404,7 @@
                 if (same && hintGiven)
                 {
                     annotationHintWasTaken ();
-                    if (steerHint.dot(side())>0) return side();else return -side();
+                    if (steerHint.dotProduct(side())>0) return side();else return -side();
                 }
                 else
                 {
@@ -1420,7 +1420,7 @@
             {
                 annotationNoteOAClauseName ("equallyClear");
                 annotationHintWasTaken ();
-                if (steerHint.dot(side()) > 0) return side(); else return -side();
+                if (steerHint.dotProduct(side()) > 0) return side(); else return -side();
             }
 
             // turn towards the side whose "wing" region is less cluttered
@@ -1434,18 +1434,18 @@
         // QQQ reconsider calling sequence
         // called when steerToAvoidObstaclesOnMap decides steering is required
         // (default action is to do nothing, layered classes can overload it)
-        // virtual void annotateAvoidObstaclesOnMap (const Vec3& scanOrigin,
+        // virtual void annotateAvoidObstaclesOnMap (const Vector3& scanOrigin,
         //                                           int scanIndex,
-        //                                           const Vec3& scanStep)
+        //                                           const Vector3& scanStep)
         // {
         // }
-        void annotateAvoidObstaclesOnMap (const Vec3& scanOrigin,
+        void annotateAvoidObstaclesOnMap (const Vector3& scanOrigin,
                                           int scanIndex,
-                                          const Vec3& scanStep)
+                                          const Vector3& scanStep)
         {
             if (scanIndex > 0)
             {
-                const Vec3 hit = scanOrigin + (scanStep * (float) scanIndex);
+                const Vector3 hit = scanOrigin + (scanStep * (float) scanIndex);
                 annotationLine (scanOrigin, hit, Color (0.7f, 0.3f, 0.3f));
             }
         }
@@ -1480,9 +1480,9 @@
             if (!dtZero) hintTakenCount++;
 
             const float r = halfWidth * 0.9f;
-            const Vec3 ff = forward () * r;
-            const Vec3 ss = side () * r;
-            const Vec3 pp = position () + (up () * 0.2f);
+            const Vector3 ff = forward () * r;
+            const Vector3 ss = side () * r;
+            const Vector3 pp = position () + (up () * 0.2f);
             annotationLine (pp + ff + ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp + ff - ss, gWhite);
@@ -1505,29 +1505,29 @@
         //        return a "scan results object" with a flag for obstacle found,
         //        plus distant and position if so.
         //
-        float scanObstacleMap (const Vec3& start,
-                               const Vec3& center,
+        float scanObstacleMap (const Vector3& start,
+                               const Vector3& center,
                                const float arcAngle,
                                const int segments,
                                const float endRadiusChange,
                                const Color& beforeColor,
                                const Color& afterColor,
-                               Vec3& returnObstaclePosition)
+                               Vector3& returnObstaclePosition)
         {
             // "spoke" is initially the vector from center to start,
             // which is then rotated step by step around center
-            Vec3 spoke = start - center;
+            Vector3 spoke = start - center;
             // determine the angular step per segment
             const float step = arcAngle / segments;
             // store distance to, and position of first obstacle
             float obstacleDistance = 0;
-            returnObstaclePosition = Vec3::zero;
+            returnObstaclePosition = Vector3::ZERO;
             // for spiral "ramps" of changing radius
             const float startRadius = (endRadiusChange == 0) ? 0 : spoke.length(); 
 
             // traverse each segment along arc
             float sin=0, cos=0;
-            Vec3 oldPoint = start;
+            Vector3 oldPoint = start;
             bool obstacleFound = false;
             for (int i = 0; i < segments; i++)
             {
@@ -1547,7 +1547,7 @@
 
                 // construct new scan point: center point, offset by rotated
                 // spoke (possibly adjusting the radius if endRadiusChange!=0)
-                const Vec3 newPoint = center + (spoke * adjust);
+                const Vector3 newPoint = center + (spoke * adjust);
 
                 // once an obstacle if found "our work here is done" -- continue
                 // to loop only for the sake of annotation (make that optional?)
@@ -1559,7 +1559,7 @@
                 {
                     // no obstacle found on this scan so far,
                     // scan map along current segment (a chord of the arc)
-                    const Vec3 offset = newPoint - oldPoint;
+                    const Vector3 offset = newPoint - oldPoint;
                     const float d2 = offset.length() * 2;
 
                     // when obstacle found: set flag, save distance and position
@@ -1591,25 +1591,25 @@
             const float predictTime = curvedSteering ? .75f : 1.3f; // seconds
             const float maxForward =
                 speed () * combinedLookAheadTime (predictTime, minDistance);
-            const Vec3 step = forward () * spacing;
+            const Vector3 step = forward () * spacing;
             float s = curvedSteering ? (spacing / 4) : (spacing / 2);
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
             const float circumference = twoPi * arcRadius;
-            const Vec3 qqqLift (0, 0.2f, 0);
-            Vec3 ignore;
+            const Vector3 qqqLift (0, 0.2f, 0);
+            Vector3 ignore;
 
             // scan region ahead of vehicle
             while (s < maxSide)
             {
-                const Vec3 sOffset = side() * s;
-                const Vec3 lOffset = position () + sOffset;
-                const Vec3 rOffset = position () - sOffset;
+                const Vector3 sOffset = side() * s;
+                const Vector3 lOffset = position () + sOffset;
+                const Vector3 rOffset = position () - sOffset;
                 const float bevel = 0.3f;
                 const float fraction = s / maxSide;
                 const float scanDist = (halfLength +
@@ -1647,7 +1647,7 @@
                 // annotation
                 if (! curvedSteering)
                 {
-                    const Vec3 d (step * (float) samples);
+                    const Vector3 d (step * (float) samples);
                     annotationLine (lOffset, lOffset + d, gWhite);
                     annotationLine (rOffset, rOffset + d, gWhite);
                 }
@@ -1665,7 +1665,7 @@
         //
         // this should be const, but easier for now to ignore that
 
-        Vec3 predictFuturePosition (const float predictionTime) const
+        Vector3 predictFuturePosition (const float predictionTime) const
         {
             if (curvedSteering)
             {
@@ -1675,8 +1675,8 @@
                 // QQQ and now, worse, I rearranged it to try the "limit arc
                 // QQQ angle" trick
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-                const Vec3 localCenterOfCurvature = side () * signedRadius;
-                const Vec3 center = position () + localCenterOfCurvature;
+                const Vector3 localCenterOfCurvature = side () * signedRadius;
+                const Vector3 center = position () + localCenterOfCurvature;
                 const float sign = signedRadius < 0 ? 1.0f : -1.0f;
                 const float arcRadius = signedRadius * -sign;
                 const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1686,9 +1686,9 @@
                                                         circumference * 0.25f);
                 const float arcAngle = twoPi * arcLength / circumference;
 
-                const Vec3 spoke = position () - center;
-                const Vec3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
-                const Vec3 prediction = newSpoke + center;
+                const Vector3 spoke = position () - center;
+                const Vector3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
+                const Vector3 prediction = newSpoke + center;
 
                 // QQQ unify with annotatePathFollowing
                 const Color futurePositionColor (0.5f, 0.5f, 0.6f);
@@ -1732,7 +1732,7 @@
         //
         // and now its been modified again for curvature-based prediction
         //
-        Vec3 steerToFollowPath (const int direction,
+        Vector3 steerToFollowPath (const int direction,
                                 const float predictionTime,
                                 GCRoute& path)
         {
@@ -1743,7 +1743,7 @@
         }
 
 
-        Vec3 steerToFollowPathLinear (const int direction,
+        Vector3 steerToFollowPathLinear (const int direction,
                                       const float predictionTime,
                                       GCRoute& path)
         {
@@ -1751,26 +1751,26 @@
             const float pathDistanceOffset = direction * predictionTime * speed();
 
             // predict our future position
-            const Vec3 futurePosition = predictFuturePosition (predictionTime);
+            const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
             // measure distance along path of our current and predicted positions
             const float nowPathDistance =
                 path.mapPointToPathDistance (position ());
 
             // are we facing in the correction direction?
-            const Vec3 pathHeading = mapPointToTangent( path, position() ) * static_cast< float >( direction );// path.tangentAt(position()) * (float)direction;
-            const bool correctDirection = pathHeading.dot (forward ()) > 0;
+            const Vector3 pathHeading = mapPointToTangent( path, position() ) * static_cast< float >( direction );// path.tangentAt(position()) * (float)direction;
+            const bool correctDirection = pathHeading.dotProduct(forward ()) > 0;
 
             // find the point on the path nearest the predicted future position
             // XXX need to improve calling sequence, maybe change to return a
             // XXX special path-defined object which includes two Vec3s and a 
             // XXX bool (onPath,tangent (ignored), withinPath)
             float futureOutside;
-            const Vec3 onPath = mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
+            const Vector3 onPath = mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
 
             // determine if we are currently inside the path tube
             float nowOutside;
-            const Vec3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
+            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
 
             // no steering is required if our present and future positions are
             // inside the path tube and we are facing in the correct direction
@@ -1779,7 +1779,7 @@
             if (whollyInside && correctDirection)
             {
                 // all is well, return zero steering
-                return Vec3::zero;
+                return Vector3::ZERO;
             }
             else
             {
@@ -1789,7 +1789,7 @@
                 const float targetPathDistance = (nowPathDistance + 
                                                   (pathDistanceOffset *
                                                    (correctDirection ? 1 : 0.1f)));
-                Vec3 target = path.mapPathDistanceToPoint (targetPathDistance);
+                Vector3 target = path.mapPathDistanceToPoint (targetPathDistance);
 
 
                 // if we are on one segment and target is on the next segment and
@@ -1799,12 +1799,12 @@
                 const int it =  static_cast< int >( mapPointToSegmentIndex( path, target ) ); // path.indexOfNearestSegment (target);
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
-                Vec3 const ipTangent = path.mapSegmentDistanceToTangent( ip, 0.0f );
+                Vector3 const ipTangent = path.mapSegmentDistanceToTangent( ip, 0.0f );
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
-                Vec3 const itTangent = path.mapSegmentDistanceToTangent( it, 0.0f );
+                Vector3 const itTangent = path.mapSegmentDistanceToTangent( it, 0.0f );
                 if (((ip + direction) == it) &&
-                    ( /* path.dotSegmentUnitTangents (it, ip) */  itTangent.dot( ipTangent ) < -0.1f ) )
+                    ( /* path.dotSegmentUnitTangents (it, ip) */  itTangent.dotProduct( ipTangent ) < -0.1f ) )
                 {
                     const float newTargetPathDistance =
                         nowPathDistance + (pathDistanceOffset * 2);
@@ -1818,7 +1818,7 @@
                 if (nowOutside > 0) return steerForSeek (nowOnPath);
 
                 // steering to seek target on path
-                const Vec3 seek = steerForSeek (target).truncateLength(maxForce());
+                const Vector3 seek = steerForSeek (target).truncateLength(maxForce());
 
                 // return that seek steering -- except when we are heading off
                 // the path (currently on path and future position is off path)
@@ -1838,25 +1838,25 @@
         // QQQ this does not handle the case when we AND futurePosition
         // QQQ are outside, say when approach the path from far away
         //
-        Vec3 steerToFollowPathCurve (const int direction,
+        Vector3 steerToFollowPathCurve (const int direction,
                                      const float predictionTime,
                                      GCRoute& path)
         {
             // predict our future position (based on current curvature and speed)
-            const Vec3 futurePosition = predictFuturePosition (predictionTime);
+            const Vector3 futurePosition = predictFuturePosition (predictionTime);
             // find the point on the path nearest the predicted future position
             float futureOutside;
-            const Vec3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
-            const Vec3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
-            const Vec3 rawBraking = forward () * maxForce () * -1;
-            const Vec3 braking = ((futureOutside < 0) ? Vec3::zero : rawBraking);
+            const Vector3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
+            const Vector3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
+            const Vector3 rawBraking = forward () * maxForce () * -1;
+            const Vector3 braking = ((futureOutside < 0) ? Vector3::ZERO : rawBraking);
             //qqq experimental wrong-way-fixer
             float nowOutside;
-            Vec3 nowTangent;
-            const Vec3 p = position ();
-            const Vec3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
+            Vector3 nowTangent;
+            const Vector3 p = position ();
+            const Vector3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
             nowTangent *= (float)direction;
-            const float alignedness = nowTangent.dot (forward ());
+            const float alignedness = nowTangent.dotProduct(forward ());
 
             // facing the wrong way?
             if (alignedness < 0)
@@ -1866,8 +1866,8 @@
                 // if nearly anti-parallel
                 if (alignedness < -0.707f)
                 {
-                    const Vec3 towardCenter = nowOnPath - p;
-                    const Vec3 turn = (towardCenter.dot (side ()) > 0 ?
+                    const Vector3 towardCenter = nowOnPath - p;
+                    const Vector3 turn = (towardCenter.dotProduct(side ()) > 0 ?
                                        side () * maxForce () :
                                        side () * maxForce () * -1);
                     return (turn + rawBraking);
@@ -1883,7 +1883,7 @@
             if (futureOutside < -(radius () + 1.0f)) //QQQ
             {
                 // then no steering is required
-                return Vec3::zero;
+                return Vector3::ZERO;
             }
             else
             {
@@ -1904,9 +1904,9 @@
                 {
                     // otherwise steer away from the side of the path we
                     // are heading for
-                    const Vec3 pathSide = localRotateForwardToSide (pathHeading);
-                    const Vec3 towardFP = futurePosition - onPath;
-                    const float whichSide = (pathSide.dot(towardFP)<0)?1.0f :-1.0f;
+                    const Vector3 pathSide = localRotateForwardToSide (pathHeading);
+                    const Vector3 towardFP = futurePosition - onPath;
+                    const float whichSide = (pathSide.dotProduct(towardFP)<0)?1.0f :-1.0f;
                     return (side () * maxForce () * whichSide) + braking;
                 }
             }
@@ -1915,7 +1915,7 @@
 
         void perFrameAnnotation (void)
         {
-            const Vec3 p = position();
+            const Vector3 p = position();
 
             // draw the circular collision boundary
             annotationCircleOrDisk (radius(), up(), p, gBlack, 32, false, false);
@@ -1926,22 +1926,22 @@
                 const float corLength = speed() * lookAheadTimeOA ();
                 if (corLength > halfLength)
                 {
-                    const Vec3 corFront = forward() * corLength;
-                    const Vec3 corBack = Vec3::zero; // (was bbFront)
-                    const Vec3 corSide  = side() * radius();
-                    const Vec3 c1 = p + corSide + corBack;
-                    const Vec3 c2 = p + corSide + corFront;
-                    const Vec3 c3 = p - corSide + corFront;
-                    const Vec3 c4 = p - corSide + corBack;
-                    const Color color = ((annotateAvoid!=Vec3::zero)?gRed:gYellow);
+                    const Vector3 corFront = forward() * corLength;
+                    const Vector3 corBack = Vector3::ZERO; // (was bbFront)
+                    const Vector3 corSide  = side() * radius();
+                    const Vector3 c1 = p + corSide + corBack;
+                    const Vector3 c2 = p + corSide + corFront;
+                    const Vector3 c3 = p - corSide + corFront;
+                    const Vector3 c4 = p - corSide + corBack;
+                    const Color color = ((annotateAvoid!=Vector3::ZERO)?gRed:gYellow);
                     annotationLine (c1, c2, color);
                     annotationLine (c2, c3, color);
                     annotationLine (c3, c4, color);
 
                     // draw sensing "wings"
-                    const Vec3 wingWidth = side () * wingSlope () * corLength;
-                    const Vec3 wingTipL = c2 + wingWidth;
-                    const Vec3 wingTipR = c3 - wingWidth;
+                    const Vector3 wingWidth = side () * wingSlope () * corLength;
+                    const Vector3 wingTipL = c2 + wingWidth;
+                    const Vector3 wingTipR = c3 - wingWidth;
                     const Color wingColor (gOrange);
                     if (wingDrawFlagL) annotationLine (c2, wingTipL, wingColor);
                     if (wingDrawFlagL) annotationLine (c1, wingTipL, wingColor);
@@ -1951,8 +1951,8 @@
             }
 
             // annotate steering acceleration
-            const Vec3 above = position () + Vec3 (0, 0.2f, 0);
-            const Vec3 accel = smoothedAcceleration () * 5 / maxForce ();
+            const Vector3 above = position () + Vector3 (0, 0.2f, 0);
+            const Vector3 accel = smoothedAcceleration () * 5 / maxForce ();
             const Color aColor (0.4f, 0.4f, 0.8f);
             annotationLine (above, above + accel, aColor);
         }
@@ -1967,10 +1967,10 @@
             if (collisionDetected)   bodyColor = gRed;
 
             // draw vehicle's bounding box on gound plane (its "shadow")
-            const Vec3 p = position();
-            const Vec3 bbSide = side() * halfWidth;
-            const Vec3 bbFront = forward() * halfLength;
-            const Vec3 bbHeight (0, 0.1f, 0);
+            const Vector3 p = position();
+            const Vector3 bbSide = side() * halfWidth;
+            const Vector3 bbFront = forward() * halfLength;
+            const Vector3 bbHeight (0, 0.1f, 0);
             drawQuadrangle (p - bbFront + bbSide + bbHeight,
                             p + bbFront + bbSide + bbHeight,
                             p + bbFront - bbSide + bbHeight,
@@ -1984,9 +1984,9 @@
 
 
         // called when steerToFollowPath decides steering is required
-        void annotatePathFollowing (const Vec3& future,
-                                    const Vec3& onPath,
-                                    const Vec3& target,
+        void annotatePathFollowing (const Vector3& future,
+                                    const Vector3& onPath,
+                                    const Vector3& target,
                                     const float outside)
         {
             const Color toTargetColor (gGreen * 0.6f);
@@ -2006,9 +2006,9 @@
             // indicates the boundary of the tube.
 
             const float o = outside + radius () + (curvedSteering ? 1.0f : 0.0f);
-            const Vec3 boundaryOffset = ((onPath - future).normalize() * o);
+            const Vector3 boundaryOffset = ((onPath - future).normalisedCopy() * o);
 
-            const Vec3 onPathBoundary = future + boundaryOffset;
+            const Vector3 onPathBoundary = future + boundaryOffset;
             annotationLine (onPath, onPathBoundary, insidePathColor);
             annotationLine (onPathBoundary, future, outsidePathColor);
         }
@@ -2019,9 +2019,9 @@
     #ifdef OLDTERRAINMAP
             const float xs = map->xSize/(float)map->resolution;
             const float zs = map->zSize/(float)map->resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-map->xSize, 0, zs);
-            Vec3 g ((map->xSize - xs) / -2, 0, (map->zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-map->xSize, 0, zs);
+            Vector3 g ((map->xSize - xs) / -2, 0, (map->zSize - zs) / -2);
             g += map->center;
             for (int j = 0; j < map->resolution; j++)
             {
@@ -2030,23 +2030,23 @@
                     if (map->getMapBit (i, j))
                     {
                         // spikes
-                        // const Vec3 spikeTop (0, 5.0f, 0);
+                        // const Vector3 spikeTop (0, 5.0f, 0);
                         // drawLine (g, g+spikeTop, gWhite);
 
                         // squares
                         const float rockHeight = 0;
-                        const Vec3 v1 (+xs/2, rockHeight, +zs/2);
-                        const Vec3 v2 (+xs/2, rockHeight, -zs/2);
-                        const Vec3 v3 (-xs/2, rockHeight, -zs/2);
-                        const Vec3 v4 (-xs/2, rockHeight, +zs/2);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
+                        const Vector3 v1 (+xs/2, rockHeight, +zs/2);
+                        const Vector3 v2 (+xs/2, rockHeight, -zs/2);
+                        const Vector3 v3 (-xs/2, rockHeight, -zs/2);
+                        const Vector3 v4 (-xs/2, rockHeight, +zs/2);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
                         const Color orangeRockColor (0.5f, 0.2f, 0.0f);
                         drawQuadrangle (g+v1, g+v2, g+v3, g+v4, orangeRockColor);
 
                         // pyramids
-                        // const Vec3 top (0, xs/2, 0);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
-                        // const Vec3 orangeRockColor (0.5f, 0.2f, 0.0f);
+                        // const Vector3 top (0, xs/2, 0);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
+                        // const Vector3 orangeRockColor (0.5f, 0.2f, 0.0f);
                         // drawTriangle (g+v1, g+v2, g+top, redRockColor);
                         // drawTriangle (g+v2, g+v3, g+top, orangeRockColor);
                         // drawTriangle (g+v3, g+v4, g+top, redRockColor);
@@ -2065,7 +2065,7 @@
          * (QQQ this should probably be a method of Path (or a
          * closely-related utility function) in which case should pass
          * color in, certainly shouldn't be recomputing it each draw)
-         * @todo Add a <code>Vec3 const* points() const</code> member function to
+         * @todo Add a <code>Vector3 const* points() const</code> member function to
          *       SegmentedPath, etc. to allow for faster point access?
          */
         void drawPath (void)
@@ -2074,11 +2074,11 @@
             const Color sandColor (0.8f, 0.7f, 0.5f);
             const Color color = interpolate (0.1f, sandColor, pathColor);
 
-            const Vec3 down (0, -0.1f, 0);
+            const Vector3 down (0, -0.1f, 0);
             for ( OpenSteer::size_t i = 1; i < path->pointCount(); ++i )
             {
-                const Vec3 endPoint0 = path->point( i ) + down;
-                const Vec3 endPoint1 = path->point( i - 1 ) + down;
+                const Vector3 endPoint0 = path->point( i ) + down;
+                const Vector3 endPoint1 = path->point( i - 1 ) + down;
 
                 const float legWidth = path->segmentRadius( i - 1 );
 
@@ -2099,30 +2099,30 @@
             const float o = worldSize * 2;    // outside of the sand
 
             // construction vectors
-            const Vec3 p (0,   0, m);
-            const Vec3 q (0,   0, m-n);
-            const Vec3 r (-m,  0, 0);
-            const Vec3 s (2*n, 0, 0);
-            const Vec3 t (o,   0, 0);
-            const Vec3 u (-o,  0, 0);
-            const Vec3 v (n,   0, 0);
-            const Vec3 w (0, 0, 0);
+            const Vector3 p (0,   0, m);
+            const Vector3 q (0,   0, m-n);
+            const Vector3 r (-m,  0, 0);
+            const Vector3 s (2*n, 0, 0);
+            const Vector3 t (o,   0, 0);
+            const Vector3 u (-o,  0, 0);
+            const Vector3 v (n,   0, 0);
+            const Vector3 w (0, 0, 0);
 
 
             // path vertices
-            const Vec3 a (t-p);
-            const Vec3 b (s+v-p);
-            const Vec3 c (s-q);
-            const Vec3 d (s+q);
-            const Vec3 e (s-v+p);
-            const Vec3 f (p-w);
-            const Vec3 g (r-w);
-            const Vec3 h (-p-w);
-            const Vec3 i (u-p);
+            const Vector3 a (t-p);
+            const Vector3 b (s+v-p);
+            const Vector3 c (s-q);
+            const Vector3 d (s+q);
+            const Vector3 e (s-v+p);
+            const Vector3 f (p-w);
+            const Vector3 g (r-w);
+            const Vector3 h (-p-w);
+            const Vector3 i (u-p);
 
             // return Path object
             const int pathPointCount = 9;
-            const Vec3 pathPoints[pathPointCount] = {a, b, c, d, e, f, g, h, i};
+            const Vector3 pathPoints[pathPointCount] = {a, b, c, d, e, f, g, h, i};
             const float k = 10.0f;
             const float pathRadii[pathPointCount] = {k, k, k, k, k, k, k, k, k};
             return new GCRoute (pathPointCount, pathPoints, pathRadii, false);
@@ -2132,7 +2132,7 @@
         TerrainMap* makeMap (void)
         {
     #ifdef OLDTERRAINMAP
-            return new TerrainMap (Vec3::zero,
+            return new TerrainMap (Vector3::ZERO,
                                    worldSize,
                                    worldSize,
                                    (int)worldSize + 1);
@@ -2156,7 +2156,7 @@
                     lapsStarted++;
                     lapsFinished++;
 
-                    const Vec3 camOffsetBefore =
+                    const Vector3 camOffsetBefore =
                         OpenSteerDemo::camera.position() - position ();
 
                     // set position on other side of the map (set new X coordinate)
@@ -2214,7 +2214,7 @@
         // (say for example we were going around a circle with radius > 10)
         bool weAreGoingInCircles (void)
         {
-            const Vec3 offset = smoothedPosition () - position ();
+            const Vector3 offset = smoothedPosition () - position ();
             return offset.length () < 10;
         }
 
@@ -2251,8 +2251,8 @@
         {
             if (demoSelect == 2)
             {
-                const Vec3 bbSide = side () * halfWidth;
-                const Vec3 bbFront = forward () * halfLength;
+                const Vector3 bbSide = side () * halfWidth;
+                const Vector3 bbFront = forward () * halfLength;
                 return ( /* path->isInsidePath (position () - bbFront + bbSide) */ isInsidePathway( *path, position () - bbFront + bbSide ) &&
                          /* path->isInsidePath (position () + bbFront + bbSide) */ isInsidePathway( *path, position () + bbFront + bbSide ) &&
                          /* path->isInsidePath (position () + bbFront - bbSide) */ isInsidePathway( *path, position () + bbFront - bbSide ) &&
@@ -2262,15 +2262,15 @@
         }
 
 
-        Vec3 convertAbsoluteToIncrementalSteering (const Vec3& absolute,
+        Vector3 convertAbsoluteToIncrementalSteering (const Vector3& absolute,
                                                    const float elapsedTime)
         {
-            const Vec3 curved = convertLinearToCurvedSpaceGlobal (absolute);
+            const Vector3 curved = convertLinearToCurvedSpaceGlobal (absolute);
             blendIntoAccumulator (elapsedTime * 8.0f, curved, currentSteering);
             {
                 // annotation
-                const Vec3 u (0, 0.5, 0);
-                const Vec3 p = position ();
+                const Vector3 u (0, 0.5, 0);
+                const Vector3 p = position ();
                 annotationLine (p + u, p + u + absolute, gRed);
                 annotationLine (p + u, p + u + curved, gYellow);
                 annotationLine (p + u*2, p + u*2 + currentSteering, gGreen);
@@ -2287,16 +2287,16 @@
         // centered on the current center of curvature and passing through the
         // vehicle's position().
         //
-        Vec3 convertLinearToCurvedSpaceGlobal (const Vec3& linear)
+        Vector3 convertLinearToCurvedSpaceGlobal (const Vector3& linear)
         {
-            const Vec3 trimmedLinear = linear.truncateLength (maxForce ());
+            const Vector3 trimmedLinear = linear.truncateLength (maxForce ());
 
             // ---------- this block imported from steerToAvoidObstaclesOnMap
             const float signedRadius = 1 / (nonZeroCurvatureQQQ() /*QQQ*/ * 1);
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
-            const float arcLength = trimmedLinear.dot (forward ());
+            const float arcLength = trimmedLinear.dotProduct(forward ());
             //
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -2306,17 +2306,17 @@
 
             // ---------- this block imported from scanObstacleMap
             // vector from center of curvature to position of vehicle
-            const Vec3 initialSpoke = position () - center;
+            const Vector3 initialSpoke = position () - center;
             // rotate by signed arc angle
-            const Vec3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
+            const Vector3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
             // ---------- this block imported from scanObstacleMap
 
-            const Vec3 fromCenter = -localCenterOfCurvature.normalize ();
-            const float dRadius = trimmedLinear.dot (fromCenter);
+            const Vector3 fromCenter = -localCenterOfCurvature.normalisedCopy();
+            const float dRadius = trimmedLinear.dotProduct(fromCenter);
             const float radiusChangeFactor = (dRadius + arcRadius) / arcRadius;
-            const Vec3 resultLocation = center + (spoke * radiusChangeFactor);
+            const Vector3 resultLocation = center + (spoke * radiusChangeFactor);
             {
-                const Vec3 center = position () + localCenterOfCurvature;
+                const Vector3 center = position () + localCenterOfCurvature;
                 annotationXZArc (position (), center, speed () * sign * -3,
                                  20, gWhite);
             }
@@ -2330,7 +2330,7 @@
         float minimumTurningRadius () const {return 5.0f;}
 
 
-        Vec3 adjustSteeringForMinimumTurningRadius (const Vec3& steering)
+        Vector3 adjustSteeringForMinimumTurningRadius (const Vector3& steering)
         {
             const float maxCurvature = 1 / (minimumTurningRadius () * 1.1f);
 
@@ -2343,13 +2343,13 @@
                 // minimum turing radius
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
                 const float sign = signedRadius < 0 ? 1.0f : -1.0f;
-                const Vec3 thrust = steering.parallelComponent (forward ());
-                const Vec3 trimmed = thrust.truncateLength (maxForce ());
-                const Vec3 widenOut = side () * maxForce () * sign;
+                const Vector3 thrust = steering.parallelComponent (forward ());
+                const Vector3 trimmed = thrust.truncateLength (maxForce ());
+                const Vector3 widenOut = side () * maxForce () * sign;
                 {
                     // annotation
-                    const Vec3 localCenterOfCurvature = side () * signedRadius;
-                    const Vec3 center = position () + localCenterOfCurvature;
+                    const Vector3 localCenterOfCurvature = side () * signedRadius;
+                    const Vector3 center = position () + localCenterOfCurvature;
                     annotationCircleOrDisk (minimumTurningRadius (), up(),
                                             center, gBlue, 40, false, false);
                 }
@@ -2404,9 +2404,9 @@
                 else
                 {
                     // heading (unit tangent) of the path segment of interest
-                    const Vec3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
+                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
                     // measure how parallel we are to the path
-                    const float parallelness = pathHeading.dot (forward ());
+                    const float parallelness = pathHeading.dotProduct(forward ());
 
                     // determine relative speed for this heading
                     const float mw = 0.2f;
@@ -2425,24 +2425,24 @@
         // xxx library candidate
         // xxx assumes (but does not check or enforce) heading is unit length
         //
-        Vec3 steerTowardHeading (const Vec3& desiredGlobalHeading)
+        Vector3 steerTowardHeading (const Vector3& desiredGlobalHeading)
         {
-            const Vec3 headingError = desiredGlobalHeading - forward ();
-            return headingError.normalize () * maxForce ();
+            const Vector3 headingError = desiredGlobalHeading - forward ();
+            return headingError.normalisedCopy() * maxForce ();
         }
 
 
         // XXX this should eventually be in a library, make it a first
         // XXX class annotation queue, tie in with drawXZArc
-        void annotationXZArc (const Vec3& start,
-                              const Vec3& center,
+        void annotationXZArc (const Vector3& start,
+                              const Vector3& center,
                               const float arcLength,
                               const int segments,
                               const Color& color) const
         {
             // "spoke" is initially the vector from center to start,
             // it is then rotated around its tail
-            Vec3 spoke = start - center;
+            Vector3 spoke = start - center;
 
             // determine the angular step per segment
             const float radius = spoke.length ();
@@ -2455,7 +2455,7 @@
             float sin=0, cos=0;
             for (int i = 0; i < segments; i++)
             {
-                const Vec3 old = spoke + center;
+                const Vector3 old = spoke + center;
 
                 // rotate point to next step around circle
                 spoke = spoke.rotateAboutGlobalY (step, sin, cos);
@@ -2500,7 +2500,7 @@
         bool dtZero;
 
         // state saved for annotation
-        Vec3 annotateAvoid;
+        Vector3 annotateAvoid;
         bool wingDrawFlagL, wingDrawFlagR;
 
         // QQQ first pass at detecting "stuck" state
@@ -2509,7 +2509,7 @@
         int stuckCycleCount;
         int stuckOffPathCount;
 
-        Vec3 qqqLastNearestObstacle;
+        Vector3 qqqLastNearestObstacle;
 
         int lapsStarted;
         int lapsFinished;
@@ -2523,7 +2523,7 @@
 
         // for "curvature-based incremental steering" -- contains the current
         // steering into which new incremental steering is blended
-        Vec3 currentSteering;
+        Vector3 currentSteering;
 
         // use curved prediction and incremental steering:
         bool curvedSteering;
@@ -2595,9 +2595,9 @@
             // "look straight down at vehicle" camera mode parameters
             OpenSteerDemo::camera.lookdownDistance = 50;
             // "static" camera mode parameters
-            OpenSteerDemo::camera.fixedPosition.set (145, 145, 145);
-            OpenSteerDemo::camera.fixedTarget.set (40, 0, 40);
-            OpenSteerDemo::camera.fixedUp = Vec3::up;
+            OpenSteerDemo::camera.fixedPosition = Vector3(145, 145, 145);
+            OpenSteerDemo::camera.fixedTarget = Vector3(40, 0, 40);
+            OpenSteerDemo::camera.fixedUp = Vector3::UNIT_Y;
 
             // reset this plugin
             reset ();
@@ -2629,10 +2629,10 @@
             // draw "ground plane"  (make it 4x map size)
             const float s = MapDriver::worldSize * 2;
             const float u = -0.2f;
-            drawQuadrangle (Vec3 (+s, u, +s),
-                            Vec3 (+s, u, -s),
-                            Vec3 (-s, u, -s),
-                            Vec3 (-s, u, +s),
+            drawQuadrangle (Vector3 (+s, u, +s),
+                            Vector3 (+s, u, -s),
+                            Vector3 (-s, u, -s),
+                            Vector3 (-s, u, +s),
                             Color (0.8f, 0.7f, 0.5f)); // "sand"
 
             // draw map and path
@@ -2644,8 +2644,8 @@
 
             // QQQ mark origin to help spot artifacts
             const float tick = 2;
-            drawLine (Vec3 (tick, 0, 0), Vec3 (-tick, 0, 0), gGreen);
-            drawLine (Vec3 (0, 0, tick), Vec3 (0, 0, -tick), gGreen);
+            drawLine (Vector3 (tick, 0, 0), Vector3 (-tick, 0, 0), gGreen);
+            drawLine (Vector3 (0, 0, tick), Vector3 (0, 0, -tick), gGreen);
 
             // compute conversion factor miles-per-hour to meters-per-second
             const float metersPerMile = 1609.344f;
@@ -2718,7 +2718,7 @@
             qqqRange ("WL ", vehicle->savedNearestWL, status);
             status << std::ends;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             const Color color (0.15f, 0.15f, 0.5f);
             draw2dTextAt2dLocation (status, screenLocation, color, drawGetWindowWidth(), drawGetWindowHeight());
 
@@ -2731,21 +2731,21 @@
 
                 // limit tick mark
                 const float l = vehicle->annoteMaxRelSpeed;
-                draw2dLine (Vec3 (m+(f*l), v-3, 0), Vec3 (m+(f*l),v+3, 0), gBlack, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m+(f*l), v-3, 0), Vector3 (m+(f*l),v+3, 0), gBlack, drawGetWindowWidth(), drawGetWindowHeight());
                 // two "inverse speedometers" showing limits due to curvature and
                 // path alignment
                 if (l!=0)
                 {
                     const float c = vehicle->annoteMaxRelSpeedCurve;
                     const float p = vehicle->annoteMaxRelSpeedPath;
-                    draw2dLine (Vec3(m+(f*c), v+1, 0), Vec3(w-m, v+1, 0), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-                    draw2dLine (Vec3(m+(f*p), v-2, 0), Vec3(w-m, v-1, 0), gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+                    draw2dLine (Vector3(m+(f*c), v+1, 0), Vector3(w-m, v+1, 0), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+                    draw2dLine (Vector3(m+(f*p), v-2, 0), Vector3(w-m, v-1, 0), gGreen, drawGetWindowWidth(), drawGetWindowHeight());
                 }
                 // speedometer: horizontal line with length proportional to speed
-                draw2dLine (Vec3 (m, v, 0), Vec3 (m + (f * s), v, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m, v, 0), Vector3 (m + (f * s), v, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
                 // min and max tick marks
-                draw2dLine (Vec3 (m,       v, 0), Vec3 (m,      v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
-                draw2dLine (Vec3 (w-m,     v, 0), Vec3 (w-m,    v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m,       v, 0), Vector3 (m,      v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (w-m,     v, 0), Vector3 (w-m,    v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
             }
         }
 
@@ -2789,13 +2789,13 @@
                 {
                     const float m = MapDriver::worldSize * 0.4f; // main diamond size
                     const float n = MapDriver::worldSize / 8;    // notch size
-                    const Vec3 q (0,   0, m-n);
-                    const Vec3 s (2*n, 0, 0);
-                    const Vec3 c (s-q);
-                    const Vec3 d (s+q);
+                    const Vector3 q (0,   0, m-n);
+                    const Vector3 s (2*n, 0, 0);
+                    const Vector3 c (s-q);
+                    const Vector3 d (s+q);
                     const int pathPointCount = 2;
                     const float pathRadii[pathPointCount] = {10, 10};
-                    const Vec3 pathPoints[pathPointCount] = {c, d};
+                    const Vector3 pathPoints[pathPointCount] = {c, d};
                     GCRoute r (pathPointCount, pathPoints, pathRadii, false);
                     drawPathFencesOnMap (*vehicle->map, r);
                     break;
@@ -2984,9 +2984,9 @@
     #ifdef OLDTERRAINMAP
             const float xs = map.xSize / (float)map.resolution;
             const float zs = map.zSize / (float)map.resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-map.xSize, 0, zs);
-            Vec3 g ((map.xSize - xs) / -2, 0, (map.zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-map.xSize, 0, zs);
+            Vector3 g ((map.xSize - xs) / -2, 0, (map.zSize - zs) / -2);
             for (int j = 0; j < map.resolution; j++)
             {
                 for (int i = 0; i < map.resolution; i++)

Modified: dependencies/opensteer/plugins/MultiplePursuit.cpp
===================================================================
--- dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -91,14 +91,14 @@
         void reset (void)
         {
             MpBase::reset ();
-            bodyColor.set (0.4f, 0.6f, 0.4f); // greenish
+            bodyColor = Vector3(0.4f, 0.6f, 0.4f); // greenish
         }
 
         // one simulation step
         void update (const float currentTime, const float elapsedTime)
         {
-            const Vec3 wander2d = steerForWander (elapsedTime).setYtoZero ();
-            const Vec3 steer = forward() + (wander2d * 3);
+            const Vector3 wander2d = steerForWander (elapsedTime).setYtoZero ();
+            const Vector3 steer = forward() + (wander2d * 3);
             applySteeringForce (steer, elapsedTime);
 
             // for annotation
@@ -119,7 +119,7 @@
         void reset (void)
         {
             MpBase::reset ();
-            bodyColor.set (0.6f, 0.4f, 0.4f); // redish
+            bodyColor = Vector3(0.6f, 0.4f, 0.4f); // redish
             randomizeStartingPositionAndHeading ();
         }
 
@@ -127,7 +127,7 @@
         void update (const float currentTime, const float elapsedTime)
         {
             // when pursuer touches quarry ("wanderer"), reset its position
-            const float d = Vec3::distance (position(), wanderer->position());
+            const float d = Vector3::distance (position(), wanderer->position());
             const float r = radius() + wanderer->radius();
             if (d < r) reset ();
 
@@ -146,7 +146,7 @@
             const float inner = 20;
             const float outer = 30;
             const float radius = frandom2 (inner, outer);
-            const Vec3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
+            const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
             setPosition (wanderer->position() + randomOnRing);
 
             // randomize 2D heading

Modified: dependencies/opensteer/plugins/OneTurning.cpp
===================================================================
--- dependencies/opensteer/plugins/OneTurning.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/OneTurning.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -70,7 +70,7 @@
         // per frame simulation update
         void update (const float currentTime, const float elapsedTime)
         {
-            applySteeringForce (Vec3 (-2, 0, -3), elapsedTime);
+            applySteeringForce (Vector3 (-2, 0, -3), elapsedTime);
             annotationVelocityAcceleration ();
             recordTrailVertex (currentTime, position());
         }
@@ -110,7 +110,7 @@
             OpenSteerDemo::camera.setPosition (10,
                                                OpenSteerDemo::camera2dElevation,
                                                10);
-            OpenSteerDemo::camera.fixedPosition.set (40, 40, 40);
+            OpenSteerDemo::camera.fixedPosition = Vector3(40, 40, 40);
         }
 
         void update (const float currentTime, const float elapsedTime)
@@ -129,7 +129,7 @@
             annote << std::setprecision (2) << std::setiosflags (std::ios::fixed);
             annote << "      speed: " << gOneTurning->speed() << std::ends;
             draw2dTextAt3dLocation (annote, gOneTurning->position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-            draw2dTextAt3dLocation (*"start", Vec3::zero, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+            draw2dTextAt3dLocation (*"start", Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
 
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *gOneTurning);

Modified: dependencies/opensteer/plugins/Pedestrian.cpp
===================================================================
--- dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -68,8 +68,8 @@
     SphereObstacle gObstacle1;
     SphereObstacle gObstacle2;
     ObstacleGroup gObstacles;
-    Vec3 gEndpoint0;
-    Vec3 gEndpoint1;
+    Vector3 gEndpoint0;
+    Vector3 gEndpoint1;
     bool gUseDirectedPathFollowing = true;
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
     RectangleObstacle gObstacle3 (7,7);
@@ -130,7 +130,7 @@
             // (random point on path + random horizontal offset)
             const float d = path->length() * frandom01();
             const float r = path->radius();
-            const Vec3 randomOffset = randomVectorOnUnitRadiusXZDisk () * r;
+            const Vector3 randomOffset = randomVectorOnUnitRadiusXZDisk () * r;
             setPosition (path->mapPathDistanceToPoint (d) + randomOffset);
 
             // randomize 2D heading
@@ -159,12 +159,12 @@
                 const Color darkRed (0.7f, 0, 0);
                 float const pathRadius = path->radius();
                 
-                if (Vec3::distance (position(), gEndpoint0) < pathRadius )
+                if (Vector3::distance (position(), gEndpoint0) < pathRadius )
                 {
                     pathDirection = +1;
                     annotationXZCircle (pathRadius, gEndpoint0, darkRed, 20);
                 }
-                if (Vec3::distance (position(), gEndpoint1) < pathRadius )
+                if (Vector3::distance (position(), gEndpoint1) < pathRadius )
                 {
                     pathDirection = -1;
                     annotationXZCircle (pathRadius, gEndpoint1, darkRed, 20);
@@ -181,10 +181,10 @@
 
         // compute combined steering force: move forward, avoid obstacles
         // or neighbors if needed, otherwise follow the path and wander
-        Vec3 determineCombinedSteering (const float elapsedTime)
+        Vector3 determineCombinedSteering (const float elapsedTime)
         {
             // move forward
-            Vec3 steeringForce = forward();
+            Vector3 steeringForce = forward();
 
             // probability that a lower priority behavior will be given a
             // chance to "drive" even if a higher priority behavior might
@@ -192,7 +192,7 @@
             const float leakThrough = 0.1f;
 
             // determine if obstacle avoidance is required
-            Vec3 obstacleAvoidance;
+            Vector3 obstacleAvoidance;
             if (leakThrough < frandom01())
             {
                 const float oTime = 6; // minTimeToCollision = 6 seconds
@@ -206,14 +206,14 @@
             }
 
             // if obstacle avoidance is needed, do it
-            if (obstacleAvoidance != Vec3::zero)
+            if (obstacleAvoidance != Vector3::ZERO)
             {
                 steeringForce += obstacleAvoidance;
             }
             else
             {
                 // otherwise consider avoiding collisions with others
-                Vec3 collisionAvoidance;
+                Vector3 collisionAvoidance;
                 const float caLeadTime = 3;
 
                 // find all neighbors within maxRadius using proximity database
@@ -228,7 +228,7 @@
                         steerToAvoidNeighbors (caLeadTime, neighbors) * 10;
 
                 // if collision avoidance is needed, do it
-                if (collisionAvoidance != Vec3::zero)
+                if (collisionAvoidance != Vector3::ZERO)
                 {
                     steeringForce += collisionAvoidance;
                 }
@@ -240,7 +240,7 @@
 
                     // do (interactively) selected type of path following
                     const float pfLeadTime = 3;
-                    const Vec3 pathFollow =
+                    const Vector3 pathFollow =
                         (gUseDirectedPathFollowing ?
                          steerToFollowPath (pathDirection, pfLeadTime, *path) :
                          steerToStayOnPath (pfLeadTime, *path));
@@ -264,9 +264,9 @@
 
 
         // called when steerToFollowPath decides steering is required
-        void annotatePathFollowing (const Vec3& future,
-                                    const Vec3& onPath,
-                                    const Vec3& target,
+        void annotatePathFollowing (const Vector3& future,
+                                    const Vector3& onPath,
+                                    const Vector3& target,
                                     const float outside)
         {
             const Color yellow (1, 1, 0);
@@ -283,8 +283,8 @@
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
             // indicates the boundary of the tube.
-            const Vec3 boundaryOffset = (onPath - future).normalize() * outside;
-            const Vec3 onPathBoundary = future + boundaryOffset;
+            const Vector3 boundaryOffset = (onPath - future).normalisedCopy() * outside;
+            const Vector3 onPathBoundary = future + boundaryOffset;
             annotationLine (onPath, onPathBoundary, darkOrange);
             annotationLine (onPathBoundary, future, lightOrange);
         }
@@ -295,12 +295,12 @@
                                          const float /*additionalDistance*/)
         {
             // draw the word "Ouch!" above colliding vehicles
-            const float headOn = forward().dot(other.forward()) < 0;
+            const float headOn = forward().dotProduct(other.forward()) < 0;
             const Color green (0.4f, 0.8f, 0.1f);
             const Color red (1, 0.1f, 0);
             const Color color = headOn ? red : green;
             const char* string = headOn ? "OUCH!" : "pardon me";
-            const Vec3 location = position() + Vec3 (0, 0.5f, 0);
+            const Vector3 location = position() + Vector3 (0, 0.5f, 0);
             if (OpenSteer::annotationIsOn())
                 draw2dTextAt3dLocation (*string, location, color, drawGetWindowWidth(), drawGetWindowHeight());
         }
@@ -309,8 +309,8 @@
         // (parameter names commented out to prevent compiler warning from "-W")
         void annotateAvoidNeighbor (const AbstractVehicle& threat,
                                     const float /*steer*/,
-                                    const Vec3& ourFuture,
-                                    const Vec3& threatFuture)
+                                    const Vector3& ourFuture,
+                                    const Vector3& threatFuture)
         {
             const Color green (0.15f, 0.6f, 0.0f);
 
@@ -326,12 +326,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vec3 boxSide = side() * radius();
-            const Vec3 boxFront = forward() * minDistanceToCollision;
-            const Vec3 FR = position() + boxFront - boxSide;
-            const Vec3 FL = position() + boxFront + boxSide;
-            const Vec3 BR = position()            - boxSide;
-            const Vec3 BL = position()            + boxSide;
+            const Vector3 boxSide = side() * radius();
+            const Vector3 boxFront = forward() * minDistanceToCollision;
+            const Vector3 FR = position() + boxFront - boxSide;
+            const Vector3 FL = position() + boxFront + boxSide;
+            const Vector3 BR = position()            - boxSide;
+            const Vector3 BL = position()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -405,14 +405,14 @@
             const float gap = 1.2f * size;
             const float out = 2 * size;
             const float h = 0.5;
-            const Vec3 pathPoints[pathPointCount] =
-                {Vec3 (h+gap-out,     0,  h+top-out),  // 0 a
-                 Vec3 (h+gap,         0,  h+top),      // 1 b
-                 Vec3 (h+gap+(top/2), 0,  h+top/2),    // 2 c
-                 Vec3 (h+gap,         0,  h),          // 3 d
-                 Vec3 (h,             0,  h),          // 4 e
-                 Vec3 (h,             0,  h+top),      // 5 f
-                 Vec3 (h+gap,         0,  h+top/2)};   // 6 g
+            const Vector3 pathPoints[pathPointCount] =
+                {Vector3 (h+gap-out,     0,  h+top-out),  // 0 a
+                 Vector3 (h+gap,         0,  h+top),      // 1 b
+                 Vector3 (h+gap+(top/2), 0,  h+top/2),    // 2 c
+                 Vector3 (h+gap,         0,  h),          // 3 d
+                 Vector3 (h,             0,  h),          // 4 e
+                 Vector3 (h,             0,  h+top),      // 5 f
+                 Vector3 (h+gap,         0,  h+top/2)};   // 6 g
 
             gObstacle1.center = interpolate (0.2f, pathPoints[0], pathPoints[1]);
             gObstacle2.center = interpolate (0.5f, pathPoints[2], pathPoints[3]);
@@ -441,9 +441,9 @@
     //         gObstacle3.setPosition (20, 0, h);
 
             // tilted 45 degrees
-            gObstacle3.setForward (Vec3(1,1,0).normalize());
+            gObstacle3.setForward (Vector3(1,1,0).normalisedCopy());
             gObstacle3.setSide (0,0,1);
-            gObstacle3.setUp (Vec3(-1,1,0).normalize());
+            gObstacle3.setUp (Vector3(-1,1,0).normalisedCopy());
             gObstacle3.setPosition (20, 0, h);
 
     //         gObstacle3.setSeenFrom (Obstacle::outside);
@@ -492,8 +492,8 @@
             Pedestrian& firstPedestrian = **crowd.begin();
             OpenSteerDemo::init3dCamera (firstPedestrian);
             OpenSteerDemo::camera.mode = Camera::cmFixedDistanceOffset;
-            OpenSteerDemo::camera.fixedTarget.set (15, 0, 30);
-            OpenSteerDemo::camera.fixedPosition.set (15, 70, -70);
+            OpenSteerDemo::camera.fixedTarget = Vector3(15, 0, 30);
+            OpenSteerDemo::camera.fixedPosition = Vector3(15, 70, -70);
         }
 
         void update (const float currentTime, const float elapsedTime)
@@ -536,10 +536,10 @@
             if (OpenSteerDemo::selectedVehicle && OpenSteer::annotationIsOn())
             {
                 const Color color (0.8f, 0.8f, 1.0f);
-                const Vec3 textOffset (0, 0.25f, 0);
-                const Vec3 textPosition = selected.position() + textOffset;
-                const Vec3 camPosition = OpenSteerDemo::camera.position();
-                const float camDistance = Vec3::distance (selected.position(),
+                const Vector3 textOffset (0, 0.25f, 0);
+                const Vector3 textPosition = selected.position() + textOffset;
+                const Vector3 camPosition = OpenSteerDemo::camera.position();
+                const float camDistance = Vector3::distance (selected.position(),
                                                           camPosition);
                 const char* spacer = "      ";
                 std::ostringstream annote;
@@ -570,7 +570,7 @@
             if (gWanderSwitch) status << "yes"; else status << "no";
             status << std::endl;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
         }
 
@@ -586,19 +586,19 @@
                 {
                     AbstractVehicle* vehicle = *i;
                     const float nearDistance = 6;
-                    const Vec3& vp = vehicle->position();
-                    const Vec3& np = nearMouse.position();
-                    if ((Vec3::distance (vp, selected.position()) < nearDistance)
+                    const Vector3& vp = vehicle->position();
+                    const Vector3& np = nearMouse.position();
+                    if ((Vector3::distance (vp, selected.position()) < nearDistance)
                         ||
-                        (&nearMouse && (Vec3::distance (vp, np) < nearDistance)))
+                        (&nearMouse && (Vector3::distance (vp, np) < nearDistance)))
                     {
                         std::ostringstream sn;
                         sn << "#"
                            << ((Pedestrian*)vehicle)->serialNumber
                            << std::ends;
                         const Color textColor (0.8f, 1, 0.8f);
-                        const Vec3 textOffset (0, 0.25f, 0);
-                        const Vec3 textPos = vehicle->position() + textOffset;
+                        const Vector3 textOffset (0, 0.25f, 0);
+                        const Vector3 textPos = vehicle->position() + textOffset;
                         draw2dTextAt3dLocation (sn, textPos, textColor, drawGetWindowWidth(), drawGetWindowHeight());
                     }
                 }
@@ -621,14 +621,14 @@
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
             {
                 float w = gObstacle3.width * 0.5f;
-                Vec3 p = gObstacle3.position ();
-                Vec3 s = gObstacle3.side ();
+                Vector3 p = gObstacle3.position ();
+                Vector3 s = gObstacle3.side ();
                 drawLine (p + (s * w), p + (s * -w), gWhite);
 
-                Vec3 v1 = gObstacle3.globalizePosition (Vec3 (w, w, 0));
-                Vec3 v2 = gObstacle3.globalizePosition (Vec3 (-w, w, 0));
-                Vec3 v3 = gObstacle3.globalizePosition (Vec3 (-w, -w, 0));
-                Vec3 v4 = gObstacle3.globalizePosition (Vec3 (w, -w, 0));
+                Vector3 v1 = gObstacle3.globalizePosition (Vector3 (w, w, 0));
+                Vector3 v2 = gObstacle3.globalizePosition (Vector3 (-w, w, 0));
+                Vector3 v3 = gObstacle3.globalizePosition (Vector3 (-w, -w, 0));
+                Vector3 v4 = gObstacle3.globalizePosition (Vector3 (w, -w, 0));
 
                 drawLine (v1, v2, gWhite);
                 drawLine (v2, v3, gWhite);
@@ -726,11 +726,11 @@
             {
             case 0:
                 {
-                    const Vec3 center;
+                    const Vector3 center;
                     const float div = 20.0f;
-                    const Vec3 divisions (div, 1.0f, div);
+                    const Vector3 divisions (div, 1.0f, div);
                     const float diameter = 80.0f; //XXX need better way to get this
-                    const Vec3 dimensions (diameter, diameter, diameter);
+                    const Vector3 dimensions (diameter, diameter, diameter);
                     typedef LQProximityDatabase<AbstractVehicle*> LQPDAV;
                     pd = new LQPDAV (center, dimensions, divisions);
                     break;
@@ -756,7 +756,7 @@
         Pedestrian::groupType crowd;
         typedef Pedestrian::groupType::const_iterator iterator;
 
-        Vec3 gridCenter;
+        Vector3 gridCenter;
 
         // pointer to database used to accelerate proximity queries
         ProximityDatabase* pd;

Modified: dependencies/opensteer/plugins/Soccer.cpp
===================================================================
--- dependencies/opensteer/plugins/Soccer.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Soccer.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -52,16 +52,16 @@
     using namespace OpenSteer;
 
 
-    Vec3 playerPosition[9] = {
-        Vec3(4,0,0),
-        Vec3(7,0,-5),
-        Vec3(7,0,5),
-        Vec3(10,0,-3),
-        Vec3(10,0,3),
-        Vec3(15,0, -8),
-        Vec3(15,0,0),
-        Vec3(15,0,8),
-        Vec3(4,0,0)
+    Vector3 playerPosition[9] = {
+        Vector3(4,0,0),
+        Vector3(7,0,-5),
+        Vector3(7,0,5),
+        Vector3(10,0,-3),
+        Vector3(10,0,3),
+        Vector3(15,0, -8),
+        Vector3(15,0,0),
+        Vector3(15,0,8),
+        Vector3(4,0,0)
     };
 
     // ----------------------------------------------------------------------------
@@ -69,14 +69,14 @@
     // a box object for the field and the goals.
     class AABBox{
     public:
-        AABBox(Vec3 &min, Vec3& max): m_min(min), m_max(max){}
-        AABBox(Vec3 min, Vec3 max): m_min(min), m_max(max){}
-        bool	InsideX(const Vec3 p){if(p.x < m_min.x || p.x > m_max.x)	return false;return true;}
-        bool	InsideZ(const Vec3 p){if(p.z < m_min.z || p.z > m_max.z)	return false;return true;}
+        AABBox(Vector3 &min, Vector3& max): m_min(min), m_max(max){}
+        AABBox(Vector3 min, Vector3 max): m_min(min), m_max(max){}
+        bool	InsideX(const Vector3 p){if(p.x < m_min.x || p.x > m_max.x)	return false;return true;}
+        bool	InsideZ(const Vector3 p){if(p.z < m_min.z || p.z > m_max.z)	return false;return true;}
         void	draw(){
-            Vec3 b,c;
-            b = Vec3(m_min.x, 0, m_max.z);
-            c = Vec3(m_max.x, 0, m_min.z);
+            Vector3 b,c;
+            b = Vector3(m_min.x, 0, m_max.z);
+            c = Vector3(m_max.x, 0, m_min.z);
             Color color(1.0f,1.0f,0.0f);
             drawLineAlpha(m_min, b, color, 1.0f);
             drawLineAlpha(b, m_max, color, 1.0f);
@@ -84,8 +84,8 @@
             drawLineAlpha(c,m_min, color, 1.0f);
         }
     private:
-        Vec3 m_min;
-        Vec3 m_max;
+        Vector3 m_min;
+        Vector3 m_max;
     };
 
     // The ball object
@@ -114,20 +114,20 @@
             // are we now outside the field?
             if(!m_bbox->InsideX(position()))
             {
-                Vec3 d = velocity();
-                regenerateOrthonormalBasis(Vec3(-d.x, d.y, d.z));
+                Vector3 d = velocity();
+                regenerateOrthonormalBasis(Vector3(-d.x, d.y, d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
             if(!m_bbox->InsideZ(position()))
             {
-                Vec3 d = velocity();
-                regenerateOrthonormalBasis(Vec3(d.x, d.y, -d.z));
+                Vector3 d = velocity();
+                regenerateOrthonormalBasis(Vector3(d.x, d.y, -d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
         recordTrailVertex (currentTime, position());
         }
 
-        void kick(Vec3 dir, const float elapsedTime){
+        void kick(Vector3 dir, const float elapsedTime){
             OPENSTEER_UNUSED_PARAMETER(elapsedTime);
             
             setSpeed(dir.length());
@@ -166,7 +166,7 @@
                 if(b_ImTeamA)
                     setPosition(playerPosition[m_MyID]);
                 else
-                    setPosition(Vec3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
+                    setPosition(Vector3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
                 }
             m_home = position();
             clearTrailHistory ();    // prevent long streaks due to teleportation 
@@ -179,25 +179,25 @@
         {
             // if I hit the ball, kick it.
 
-            const float distToBall = Vec3::distance (position(), m_Ball->position());
+            const float distToBall = Vector3::distance (position(), m_Ball->position());
             const float sumOfRadii = radius() + m_Ball->radius();
             if (distToBall < sumOfRadii)
                 m_Ball->kick((m_Ball->position()-position())*50, elapsedTime);
 
 
             // otherwise consider avoiding collisions with others
-            Vec3 collisionAvoidance = steerToAvoidNeighbors(1, (AVGroup&)m_AllPlayers);
-            if(collisionAvoidance != Vec3::zero)
+            Vector3 collisionAvoidance = steerToAvoidNeighbors(1, (AVGroup&)m_AllPlayers);
+            if(collisionAvoidance != Vector3::ZERO)
                 applySteeringForce (collisionAvoidance, elapsedTime);
             else
                 {
-                float distHomeToBall = Vec3::distance (m_home, m_Ball->position());
+                float distHomeToBall = Vector3::distance (m_home, m_Ball->position());
                 if( distHomeToBall < 12.0f)
                     {
                     // go for ball if I'm on the 'right' side of the ball
                         if( b_ImTeamA ? position().x > m_Ball->position().x : position().x < m_Ball->position().x)
                         {
-                        Vec3 seekTarget = xxxsteerForSeek(m_Ball->position());
+                        Vector3 seekTarget = xxxsteerForSeek(m_Ball->position());
                         applySteeringForce (seekTarget, elapsedTime);
                         }
                     else
@@ -205,18 +205,18 @@
                         if( distHomeToBall < 12.0f)
                             {
                             float Z = m_Ball->position().z - position().z > 0 ? -1.0f : 1.0f;
-                            Vec3 behindBall = m_Ball->position() + (b_ImTeamA ? Vec3(2.0f,0.0f,Z) : Vec3(-2.0f,0.0f,Z));
-                            Vec3 behindBallForce = xxxsteerForSeek(behindBall);
+                            Vector3 behindBall = m_Ball->position() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
+                            Vector3 behindBallForce = xxxsteerForSeek(behindBall);
                             annotationLine (position(), behindBall , Color(0.0f,1.0f,0.0f));
-                            Vec3 evadeTarget = xxxsteerForFlee(m_Ball->position());
+                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball->position());
                             applySteeringForce (behindBallForce*10.0f + evadeTarget, elapsedTime);
                             }
                         }
                     }
                 else	// Go home
                     {
-                    Vec3 seekTarget = xxxsteerForSeek(m_home);
-                    Vec3 seekHome = xxxsteerForSeek(m_home);
+                    Vector3 seekTarget = xxxsteerForSeek(m_home);
+                    Vector3 seekHome = xxxsteerForSeek(m_home);
                     applySteeringForce (seekTarget+seekHome, elapsedTime);
                     }
 
@@ -235,7 +235,7 @@
         Ball*	m_Ball;
         bool	b_ImTeamA;
         int		m_MyID;
-        Vec3		m_home;
+        Vector3		m_home;
     };
 
 
@@ -258,11 +258,11 @@
         void open (void)
         {
             // Make a field
-            m_bbox = new AABBox(Vec3(-20,0,-10), Vec3(20,0,10));
+            m_bbox = new AABBox(Vector3(-20,0,-10), Vector3(20,0,10));
             // Red goal
-            m_TeamAGoal = new AABBox(Vec3(-21,0,-7), Vec3(-19,0,7));
+            m_TeamAGoal = new AABBox(Vector3(-21,0,-7), Vector3(-19,0,7));
             // Blue Goal
-            m_TeamBGoal = new AABBox(Vec3(19,0,-7), Vec3(21,0,7));
+            m_TeamBGoal = new AABBox(Vector3(19,0,-7), Vector3(21,0,7));
             // Make a ball
             m_Ball = new Ball(m_bbox);
             // Build team A
@@ -286,7 +286,7 @@
             // initialize camera
             OpenSteerDemo::init2dCamera (*m_Ball);
             OpenSteerDemo::camera.setPosition (10, OpenSteerDemo::camera2dElevation, 10);
-            OpenSteerDemo::camera.fixedPosition.set (40, 40, 40);
+            OpenSteerDemo::camera.fixedPosition = Vector3(40, 40, 40);
             OpenSteerDemo::camera.mode = Camera::cmFixed;
             m_redScore = 0;
             m_blueScore = 0;
@@ -328,12 +328,12 @@
             {
                 std::ostringstream annote;
                 annote << "Red: "<< m_redScore;
-                draw2dTextAt3dLocation (annote, Vec3(23,0,0), Color(1.0f,0.7f,0.7f), drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (annote, Vector3(23,0,0), Color(1.0f,0.7f,0.7f), drawGetWindowWidth(), drawGetWindowHeight());
             }
             {
                 std::ostringstream annote;
                 annote << "Blue: "<< m_blueScore;
-                draw2dTextAt3dLocation (annote, Vec3(-23,0,0), Color(0.7f,0.7f,1.0f), drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (annote, Vector3(-23,0,0), Color(0.7f,0.7f,1.0f), drawGetWindowWidth(), drawGetWindowHeight());
             }
 
             // textual annotation (following the test vehicle's screen position)
@@ -344,13 +344,13 @@
                 annote << std::setprecision (2) << std::setiosflags (std::ios::fixed);
                 annote << "      speed: " << TeamA[i]->speed() << "ID:" << i << std::ends;
                 draw2dTextAt3dLocation (annote, TeamA[i]->position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-                draw2dTextAt3dLocation (*"start", Vec3::zero, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (*"start", Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
             }
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *OpenSteerDemo::selectedVehicle);
 
             // draw "ground plane"
-            OpenSteerDemo::gridUtility (Vec3(0,0,0));
+            OpenSteerDemo::gridUtility (Vector3(0,0,0));
         }
 
         void close (void)

Modified: dependencies/opensteer/src/Camera.cpp
===================================================================
--- dependencies/opensteer/src/Camera.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Camera.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
     resetLocalSpace ();
 
     // "look at" point, center of view
-    target = Vec3::zero;
+    target = Vector3::ZERO;
 
     // vehicle being tracked
     vehicleToTrack = NULL;
@@ -90,15 +90,15 @@
     lookdownDistance = 30;
 
     // "static" camera mode parameters
-    fixedPosition.set (75, 75, 75);
-    fixedTarget = Vec3::zero;
-    fixedUp = Vec3::up;
+    fixedPosition = Vector3(75, 75, 75);
+    fixedTarget = Vector3::ZERO;
+    fixedUp = Vector3::UNIT_Y;
 
     // "fixed local offset" camera mode parameters
-    fixedLocalOffset.set (5, 5, -5);
+    fixedLocalOffset = Vector3(5, 5, -5);
 
     // "offset POV" camera mode parameters
-    povOffset.set (0, 1, -3);
+    povOffset = Vector3(0, 1, -3);
 }
 
 
@@ -120,9 +120,9 @@
     const bool noVehicle = vehicleToTrack == NULL;
     
     // new position/target/up, set in switch below, defaults to current
-    Vec3 newPosition = position();
-    Vec3 newTarget = target;
-    Vec3 newUp = up();
+    Vector3 newPosition = position();
+    Vector3 newTarget = target;
+    Vector3 newUp = up();
 
 
     // prediction time to compensate for lag caused by smoothing moves
@@ -142,7 +142,7 @@
 
     case cmFixedDistanceOffset:
         if (noVehicle) break;
-        newUp = Vec3::up; // xxx maybe this should be v.up ?
+        newUp = Vector3::UNIT_Y; // xxx maybe this should be v.up ?
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = constDistHelper (elapsedTime);
         break;
@@ -166,8 +166,8 @@
         {
             if (noVehicle) break;
             newUp = v.up();
-            const Vec3 futurePosition = v.predictFuturePosition (antiLagTime);
-            const Vec3 globalOffset = v.globalizeDirection (povOffset);
+            const Vector3 futurePosition = v.predictFuturePosition (antiLagTime);
+            const Vector3 globalOffset = v.globalizeDirection (povOffset);
             newPosition = futurePosition + globalOffset;
             // XXX hack to improve smoothing between modes (no effect on aim)
             const float L = 10;
@@ -195,17 +195,17 @@
 
 
 void 
-OpenSteer::Camera::smoothCameraMove (const Vec3& newPosition,
-                                     const Vec3& newTarget,
-                                     const Vec3& newUp,
+OpenSteer::Camera::smoothCameraMove (const Vector3& newPosition,
+                                     const Vector3& newTarget,
+                                     const Vector3& newUp,
                                      const float elapsedTime)
 {
     if (smoothNextMove)
     {
         const float smoothRate = elapsedTime * smoothMoveSpeed;
 
-        Vec3 tempPosition = position();
-        Vec3 tempUp = up();
+        Vector3 tempPosition = position();
+        Vector3 tempUp = up();
         blendIntoAccumulator (smoothRate, newPosition, tempPosition);
         blendIntoAccumulator (smoothRate, newTarget,   target);
         blendIntoAccumulator (smoothRate, newUp,       tempUp);
@@ -215,10 +215,10 @@
         // xxx not sure if these are needed, seems like a good idea
         // xxx (also if either up or oldUP are zero, use the other?)
         // xxx (even better: force up to be perp to target-position axis))
-        if (up() == Vec3::zero)
-            setUp (Vec3::up);
+        if (up() == Vector3::ZERO)
+            setUp (Vector3::UNIT_Y);
         else
-            setUp (up().normalize ());
+            setUp (up().normalisedCopy());
     }
     else
     {
@@ -238,7 +238,7 @@
 // parameter names commented out to prevent compiler warning from "-W"
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Camera::constDistHelper (const float /*elapsedTime*/)
 {
     // is the "global up"/"vertical" offset constraint enabled?  (it forces
@@ -247,10 +247,10 @@
     const bool constrainUp = (fixedDistVOffset != 0);
 
     // vector offset from target to current camera position
-    const Vec3 adjustedPosition (position().x,
+    const Vector3 adjustedPosition (position().x,
                                  (constrainUp) ? target.y : position().y,
                                  position().z);
-    const Vec3 offset = adjustedPosition - target;
+    const Vector3 offset = adjustedPosition - target;
 
     // current distance between them
     const float distance = offset.length();
@@ -263,15 +263,15 @@
     else
     {
         // unit vector along original offset
-        const Vec3 unitOffset = offset / distance;
+        const Vector3 unitOffset = offset / distance;
 
         // new offset of length XXX
         const float xxxDistance = sqrtXXX (square (fixedDistDistance) -
                                            square (fixedDistVOffset));
-        const Vec3 newOffset = unitOffset * xxxDistance;
+        const Vector3 newOffset = unitOffset * xxxDistance;
 
         // return new camera position: adjust distance to target
-        return target + newOffset + Vec3 (0, fixedDistVOffset, 0);
+        return target + newOffset + Vector3 (0, fixedDistVOffset, 0);
     }
 }
 
@@ -324,7 +324,7 @@
 
 
 void 
-OpenSteer::Camera::mouseAdjustOffset (const Vec3& adjustment)
+OpenSteer::Camera::mouseAdjustOffset (const Vector3& adjustment)
 {
     // vehicle being tracked (just a reference with a more concise name)
     const AbstractVehicle& v = *vehicleToTrack;
@@ -333,8 +333,8 @@
     {
     case cmFixed:
         {
-            const Vec3 offset = fixedPosition - fixedTarget;
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = fixedPosition - fixedTarget;
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             fixedPosition = fixedTarget + adjusted;
             break;
         }
@@ -343,15 +343,15 @@
             // XXX this is the oddball case, adjusting "position" instead
             // XXX of mode parameters, hence no smoothing during adjustment
             // XXX Plus the fixedDistVOffset feature complicates things
-            const Vec3 offset = position() - target;
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = position() - target;
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             // XXX --------------------------------------------------
 //             position = target + adjusted;
 //             fixedDistDistance = adjusted.length();
 //             fixedDistVOffset = position.y - target.y;
             // XXX --------------------------------------------------
 //             const float s = smoothMoveSpeed * (1.0f/40f);
-//             const Vec3 newPosition = target + adjusted;
+//             const Vector3 newPosition = target + adjusted;
 //             position = interpolate (s, position, newPosition);
 //             fixedDistDistance = interpolate (s, fixedDistDistance, adjusted.length());
 //             fixedDistVOffset = interpolate (s, fixedDistVOffset, position.y - target.y);
@@ -366,15 +366,15 @@
         }
     case cmStraightDown:
         {
-            const Vec3 offset (0, 0, lookdownDistance);
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset (0, 0, lookdownDistance);
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             lookdownDistance = adjusted.z;
             break;
         }
     case cmFixedLocalOffset:
         {
-            const Vec3 offset = v.globalizeDirection (fixedLocalOffset);
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = v.globalizeDirection (fixedLocalOffset);
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             fixedLocalOffset = v.localizeDirection (adjusted);
             break;
         }
@@ -383,8 +383,8 @@
             // XXX this might work better as a translation control, it is
             // XXX non-obvious using a polar adjustment when the view
             // XXX center is not at the camera aim target
-            const Vec3 offset = v.globalizeDirection (povOffset);
-            const Vec3 adjusted = mouseAdjustOrtho (adjustment, offset);
+            const Vector3 offset = v.globalizeDirection (povOffset);
+            const Vector3 adjusted = mouseAdjustOrtho (adjustment, offset);
             povOffset = v.localizeDirection (adjusted);
             break;
         }
@@ -397,13 +397,13 @@
 // ----------------------------------------------------------------------------
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Camera::mouseAdjust2 (const bool polar,
-                                 const Vec3& adjustment,
-                                 const Vec3& offsetToAdjust)
+                                 const Vector3& adjustment,
+                                 const Vector3& offsetToAdjust)
 {
     // value to be returned
-    Vec3 result = offsetToAdjust;
+    Vector3 result = offsetToAdjust;
 
     // using the camera's side/up axes (essentially: screen space) move the
     // offset vector sideways according to adjustment.x and vertically

Modified: dependencies/opensteer/src/Color.cpp
===================================================================
--- dependencies/opensteer/src/Color.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Color.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -29,7 +29,7 @@
 
 #include "OpenSteer/Color.h"
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include assert
@@ -57,7 +57,7 @@
 }
 
 
-OpenSteer::Color::Color( Vec3 const& vector )
+OpenSteer::Color::Color( Vector3 const& vector )
     : r_( vector.x ), g_( vector.y ), b_( vector.z ), a_ (1.0f)
 {
     
@@ -130,10 +130,10 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Color::convertToVec3() const
 {
-    return Vec3( r_, g_, b_ );
+    return Vector3( r_, g_, b_ );
 }
 
 

Modified: dependencies/opensteer/src/Draw.cpp
===================================================================
--- dependencies/opensteer/src/Draw.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Draw.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -88,9 +88,9 @@
 
 namespace {
     // ------------------------------------------------------------------------
-    // emit an OpenGL vertex based on a Vec3
+    // emit an OpenGL vertex based on a Vector3
     
-    inline void iglVertexVec3 (const OpenSteer::Vec3& v)
+    inline void iglVertexVec3 (const Vector3& v)
     {
         glVertex3f (v.x, v.y, v.z);
     }
@@ -129,8 +129,8 @@
     // ----------------------------------------------------------------------------
     // draw 3d "graphical annotation" lines, used for debugging
     
-    inline void iDrawLine (const OpenSteer::Vec3& startPoint,
-                           const OpenSteer::Vec3& endPoint,
+    inline void iDrawLine (const Vector3& startPoint,
+                           const Vector3& endPoint,
                            const OpenSteer::Color& color)
     {
         OpenSteer::warnIfInUpdatePhase ("iDrawLine");
@@ -142,11 +142,11 @@
     }
 
     // ----------------------------------------------------------------------------
-    // Draw a single OpenGL triangle given three Vec3 vertices.
+    // Draw a single OpenGL triangle given three Vector3 vertices.
     
-    inline void iDrawTriangle (const OpenSteer::Vec3& a,
-                               const OpenSteer::Vec3& b,
-                               const OpenSteer::Vec3& c,
+    inline void iDrawTriangle (const Vector3& a,
+                               const Vector3& b,
+                               const Vector3& c,
                                const OpenSteer::Color& color)
     {
         OpenSteer::warnIfInUpdatePhase ("iDrawTriangle");
@@ -162,12 +162,12 @@
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL quadrangle given four Vec3 vertices, and color.
+    // Draw a single OpenGL quadrangle given four Vector3 vertices, and color.
     
-    inline void iDrawQuadrangle (const OpenSteer::Vec3& a,
-                                 const OpenSteer::Vec3& b,
-                                 const OpenSteer::Vec3& c,
-                                 const OpenSteer::Vec3& d,
+    inline void iDrawQuadrangle (const Vector3& a,
+                                 const Vector3& b,
+                                 const Vector3& c,
+                                 const Vector3& d,
                                  const OpenSteer::Color& color)
     {
         OpenSteer::warnIfInUpdatePhase ("iDrawQuadrangle");
@@ -238,7 +238,7 @@
 
 
 void 
-OpenSteer::glVertexVec3 (const Vec3& v)
+OpenSteer::glVertexVec3 (const Vector3& v)
 {
     iglVertexVec3 (v);
 }
@@ -265,8 +265,8 @@
 
 
 void 
-OpenSteer::drawLine (const Vec3& startPoint,
-                     const Vec3& endPoint,
+OpenSteer::drawLine (const Vector3& startPoint,
+                     const Vector3& endPoint,
                      const Color& color)
 {
     iDrawLine (startPoint, endPoint, color);
@@ -282,8 +282,8 @@
 
 
 void 
-OpenSteer::drawLineAlpha (const Vec3& startPoint,
-                          const Vec3& endPoint,
+OpenSteer::drawLineAlpha (const Vector3& startPoint,
+                          const Vector3& endPoint,
                           const Color& color,
                           const float alpha)
 {
@@ -300,9 +300,9 @@
 
 
 void 
-OpenSteer::drawTriangle (const Vec3& a,
-                         const Vec3& b,
-                         const Vec3& c,
+OpenSteer::drawTriangle (const Vector3& a,
+                         const Vector3& b,
+                         const Vector3& c,
                          const Color& color)
 {
     iDrawTriangle (a, b, c, color);
@@ -314,10 +314,10 @@
     
     
 void 
-OpenSteer::drawQuadrangle (const Vec3& a,
-                           const Vec3& b,
-                           const Vec3& c,
-                           const Vec3& d,
+OpenSteer::drawQuadrangle (const Vector3& a,
+                           const Vector3& b,
+                           const Vector3& c,
+                           const Vector3& d,
                            const Color& color)
 {
     iDrawQuadrangle (a, b, c, d, color);
@@ -330,22 +330,22 @@
 
 
 void 
-OpenSteer::drawXZWideLine (const Vec3& startPoint,
-                           const Vec3& endPoint,
+OpenSteer::drawXZWideLine (const Vector3& startPoint,
+                           const Vector3& endPoint,
                            const Color& color,
                            float width)
 {
     warnIfInUpdatePhase ("drawXZWideLine");
 
-    const Vec3 offset = endPoint - startPoint;
-    const Vec3 along = offset.normalize();
-    const Vec3 perp = gGlobalSpace.localRotateForwardToSide (along);
-    const Vec3 radius = perp * width / 2;
+    const Vector3 offset = endPoint - startPoint;
+    const Vector3 along = offset.normalisedCopy();
+    const Vector3 perp = gGlobalSpace.localRotateForwardToSide (along);
+    const Vector3 radius = perp * width / 2;
 
-    const Vec3 a = startPoint + radius;
-    const Vec3 b = endPoint + radius;
-    const Vec3 c = endPoint - radius;
-    const Vec3 d = startPoint - radius;
+    const Vector3 a = startPoint + radius;
+    const Vector3 b = endPoint + radius;
+    const Vector3 c = endPoint - radius;
+    const Vector3 d = startPoint - radius;
 
     iDrawQuadrangle (a, b, c, d, color);
 }
@@ -364,8 +364,8 @@
 
 void 
 OpenSteer::drawCircleOrDisk (const float radius,
-                             const Vec3& axis,
-                             const Vec3& center,
+                             const Vector3& axis,
+                             const Vector3& center,
                              const Color& color,
                              const int segments,
                              const bool filled,
@@ -376,8 +376,8 @@
     {
         // define a local space with "axis" as the Y/up direction
         // (XXX should this be a method on  LocalSpace?)
-        const Vec3 unitAxis = axis.normalize ();
-        const Vec3 unitPerp = findPerpendicularIn3d (axis).normalize ();
+        const Vector3 unitAxis = axis.normalisedCopy();
+        const Vector3 unitPerp = findPerpendicularIn3d (axis).normalisedCopy();
         ls.setUp (unitAxis);
         ls.setForward (unitPerp);
         ls.setPosition (center);
@@ -388,7 +388,7 @@
     if (filled) beginDoubleSidedDrawing ();
 
     // point to be rotated about the (local) Y axis, angular step size
-    Vec3 pointOnCircle (radius, 0, 0);
+    Vector3 pointOnCircle (radius, 0, 0);
     const float step = (2 * OPENSTEER_M_PI) / segments;
 
     // set drawing color
@@ -409,7 +409,7 @@
         // of the local space), or in 2d (offset from the center)
         iglVertexVec3 (in3d ?
                            ls.globalizePosition (pointOnCircle) :
-                           (Vec3) (pointOnCircle + center));
+                           (Vector3) (pointOnCircle + center));
 
         // rotate point one more step around circle
         pointOnCircle = pointOnCircle.rotateAboutGlobalY (step, sin, cos);
@@ -426,8 +426,8 @@
 
 void 
 OpenSteer::draw3dCircleOrDisk (const float radius,
-                               const Vec3& center,
-                               const Vec3& axis,
+                               const Vector3& center,
+                               const Vector3& axis,
                                const Color& color,
                                const int segments,
                                const bool filled)
@@ -443,13 +443,13 @@
 
 void 
 OpenSteer::drawXZCircleOrDisk (const float radius,
-                               const Vec3& center,
+                               const Vector3& center,
                                const Color& color,
                                const int segments,
                                const bool filled)
 {
     // draw a circle-or-disk on the XZ plane
-    drawCircleOrDisk (radius, Vec3::zero, center, color, segments, filled, false);
+    drawCircleOrDisk (radius, Vector3::ZERO, center, color, segments, filled, false);
 }
 
 
@@ -464,8 +464,8 @@
 
 
 void 
-OpenSteer::drawXZArc (const Vec3& start,
-                      const Vec3& center,
+OpenSteer::drawXZArc (const Vector3& start,
+                      const Vector3& center,
                       const float arcLength,
                       const int segments,
                       const Color& color)
@@ -474,7 +474,7 @@
 
     // "spoke" is initially the vector from center to start,
     // it is then rotated around its tail
-    Vec3 spoke = start - center;
+    Vector3 spoke = start - center;
 
     // determine the angular step per segment
     const float radius = spoke.length ();
@@ -519,13 +519,13 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3& p = vehicle.position();
+    const Vector3& p = vehicle.position();
 
     // shape of triangular body
-    const Vec3 u = r * 0.05f * Vec3 (0, 1, 0); // slightly up
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 u = r * 0.05f * Vector3 (0, 1, 0); // slightly up
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // draw double-sided triangle (that is: no (back) face culling)
     beginDoubleSidedDrawing ();
@@ -554,20 +554,20 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3& p = vehicle.position();
+    const Vector3& p = vehicle.position();
 
     // body shape parameters
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 u = r * vehicle.up() * x * 0.5f;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 u = r * vehicle.up() * x * 0.5f;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // vertex positions
-    const Vec3 nose   = p + f;
-    const Vec3 side1  = p + b - s;
-    const Vec3 side2  = p + b + s;
-    const Vec3 top    = p + b + u;
-    const Vec3 bottom = p + b - u;
+    const Vector3 nose   = p + f;
+    const Vector3 side1  = p + b - s;
+    const Vector3 side2  = p + b + s;
+    const Vector3 top    = p + b + u;
+    const Vector3 bottom = p + b - u;
 
     // colors
     const float j = +0.05f;
@@ -601,20 +601,20 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3& p = vehicle.position();
+    const Vector3& p = vehicle.position();
 
     // body shape parameters
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 u = r * vehicle.up() * x * 0.5f;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 u = r * vehicle.up() * x * 0.5f;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // vertex positions
-    const Vec3 nose   = p + f;
-    const Vec3 side1  = p + b - s;
-    const Vec3 side2  = p + b + s;
-    const Vec3 top    = p + b + u;
-    const Vec3 bottom = p + b - u;
+    const Vector3 nose   = p + f;
+    const Vector3 side1  = p + b - s;
+    const Vector3 side2  = p + b + s;
+    const Vector3 top    = p + b + u;
+    const Vector3 bottom = p + b - u;
 
     // colors
     const float j = +0.05f;
@@ -651,7 +651,7 @@
 void 
 OpenSteer::drawXZCheckerboardGrid (const float size,
                                    const int subsquares,
-                                   const Vec3& center,
+                                   const Vector3& center,
                                    const Color& color1,
                                    const Color& color2)
 {
@@ -662,19 +662,19 @@
     {
         bool flag1 = false;
         float p = -half;
-        Vec3 corner;
+        Vector3 corner;
         for (int i = 0; i < subsquares; i++)
         {
             bool flag2 = flag1;
             float q = -half;
             for (int j = 0; j < subsquares; j++)
             {
-                corner.set (p, 0, q);
+                corner = Vector3(p, 0, q);
                 corner += center;
                 iDrawQuadrangle (corner,
-                                 corner + Vec3 (spacing, 0,       0),
-                                 corner + Vec3 (spacing, 0, spacing),
-                                 corner + Vec3 (0,       0, spacing),
+                                 corner + Vector3 (spacing, 0,       0),
+                                 corner + Vector3 (spacing, 0, spacing),
+                                 corner + Vector3 (0,       0, spacing),
                                  flag2 ? color1 : color2);
                 flag2 = !flag2;
                 q += spacing;
@@ -699,7 +699,7 @@
 void 
 OpenSteer::drawXZLineGrid (const float size,
                            const int subsquares,
-                           const Vec3& center,
+                           const Vector3& center,
                            const Color& color)
 {
     warnIfInUpdatePhase ("drawXZLineGrid");
@@ -715,10 +715,10 @@
     float q = -half;
     for (int i = 0; i < (subsquares + 1); i++)
     {
-        const Vec3 x1 (q, 0, +half); // along X parallel to Z
-        const Vec3 x2 (q, 0, -half);
-        const Vec3 z1 (+half, 0, q); // along Z parallel to X
-        const Vec3 z2 (-half, 0, q);
+        const Vector3 x1 (q, 0, +half); // along X parallel to Z
+        const Vector3 x2 (q, 0, -half);
+        const Vector3 z1 (+half, 0, q); // along Z parallel to X
+        const Vector3 z2 (-half, 0, q);
 
         iglVertexVec3 (x1 + center);
         iglVertexVec3 (x2 + center);
@@ -739,12 +739,12 @@
 
 void 
 OpenSteer::drawAxes  (const AbstractLocalSpace& ls,
-                      const Vec3& size,
+                      const Vector3& size,
                       const Color& color)
 {
-    const Vec3 x (size.x / 2, 0, 0);
-    const Vec3 y (0, size.y / 2, 0);
-    const Vec3 z (0, 0, size.z / 2);
+    const Vector3 x (size.x / 2, 0, 0);
+    const Vector3 y (0, size.y / 2, 0);
+    const Vector3 z (0, 0, size.z / 2);
  
     iDrawLine (ls.globalizePosition (x), ls.globalizePosition (x * -1), color);
     iDrawLine (ls.globalizePosition (y), ls.globalizePosition (y * -1), color);
@@ -763,30 +763,30 @@
 
 void 
 OpenSteer::drawBoxOutline  (const AbstractLocalSpace& localSpace,
-                            const Vec3& size,
+                            const Vector3& size,
                             const Color& color)
 {
-    const Vec3 s = size / 2.0f;  // half of main diagonal
+    const Vector3 s = size / 2.0f;  // half of main diagonal
 
-    const Vec3 a (+s.x, +s.y, +s.z);
-    const Vec3 b (+s.x, -s.y, +s.z);
-    const Vec3 c (-s.x, -s.y, +s.z);
-    const Vec3 d (-s.x, +s.y, +s.z);
+    const Vector3 a (+s.x, +s.y, +s.z);
+    const Vector3 b (+s.x, -s.y, +s.z);
+    const Vector3 c (-s.x, -s.y, +s.z);
+    const Vector3 d (-s.x, +s.y, +s.z);
 
-    const Vec3 e (+s.x, +s.y, -s.z);
-    const Vec3 f (+s.x, -s.y, -s.z);
-    const Vec3 g (-s.x, -s.y, -s.z);
-    const Vec3 h (-s.x, +s.y, -s.z);
+    const Vector3 e (+s.x, +s.y, -s.z);
+    const Vector3 f (+s.x, -s.y, -s.z);
+    const Vector3 g (-s.x, -s.y, -s.z);
+    const Vector3 h (-s.x, +s.y, -s.z);
 
-    const Vec3 A = localSpace.globalizePosition (a);
-    const Vec3 B = localSpace.globalizePosition (b);
-    const Vec3 C = localSpace.globalizePosition (c);
-    const Vec3 D = localSpace.globalizePosition (d);
+    const Vector3 A = localSpace.globalizePosition (a);
+    const Vector3 B = localSpace.globalizePosition (b);
+    const Vector3 C = localSpace.globalizePosition (c);
+    const Vector3 D = localSpace.globalizePosition (d);
 
-    const Vec3 E = localSpace.globalizePosition (e);
-    const Vec3 F = localSpace.globalizePosition (f);
-    const Vec3 G = localSpace.globalizePosition (g);
-    const Vec3 H = localSpace.globalizePosition (h);
+    const Vector3 E = localSpace.globalizePosition (e);
+    const Vector3 F = localSpace.globalizePosition (f);
+    const Vector3 G = localSpace.globalizePosition (g);
+    const Vector3 H = localSpace.globalizePosition (h);
 
     iDrawLine (A, B, color);
     iDrawLine (B, C, color);
@@ -810,13 +810,13 @@
 // ------------------------------------------------------------------------
 // this comes up often enough to warrant its own warning function
 
-    inline void drawCameraLookAtCheck (const OpenSteer::Vec3& cameraPosition,
-                                       const OpenSteer::Vec3& pointToLookAt,
-                                       const OpenSteer::Vec3& up)
+    inline void drawCameraLookAtCheck (const Vector3& cameraPosition,
+                                       const Vector3& pointToLookAt,
+                                       const Vector3& up)
     {
-        const OpenSteer::Vec3 view = pointToLookAt - cameraPosition;
-        const OpenSteer::Vec3 perp = view.perpendicularComponent (up);
-        if (perp == OpenSteer::Vec3::zero)
+        const Vector3 view = pointToLookAt - cameraPosition;
+        const Vector3 perp = view.perpendicularComponent (up);
+        if (perp == Vector3::ZERO)
             std::cerr << "OpenSteer - LookAt: degenerate camera";
     }
 
@@ -832,9 +832,9 @@
 
 
 void 
-OpenSteer::drawCameraLookAt (const Vec3& cameraPosition,
-                             const Vec3& pointToLookAt,
-                             const Vec3& up)
+OpenSteer::drawCameraLookAt (const Vector3& cameraPosition,
+                             const Vector3& pointToLookAt,
+                             const Vector3& up)
 {
     // check for valid "look at" parameters
     drawCameraLookAtCheck (cameraPosition, pointToLookAt, up);
@@ -849,8 +849,8 @@
 
 
 void 
-OpenSteer::draw2dLine (const Vec3& startPoint,
-                       const Vec3& endPoint,
+OpenSteer::draw2dLine (const Vector3& startPoint,
+                       const Vector3& endPoint,
                        const Color& color, 
                        float w, float h)
 {
@@ -872,16 +872,16 @@
     const int a = 10;
     const int b = 30;
 
-    draw2dLine (Vec3 (w+a, h,   0), Vec3 (w+b, h,   0), gWhite, w, h);
-    draw2dLine (Vec3 (w,   h+a, 0), Vec3 (w,   h+b, 0), gWhite, w, h);
-    draw2dLine (Vec3 (w-a, h,   0), Vec3 (w-b, h,   0), gWhite, w, h);
-    draw2dLine (Vec3 (w,   h-a, 0), Vec3 (w,   h-b, 0), gWhite, w, h);
+    draw2dLine (Vector3 (w+a, h,   0), Vector3 (w+b, h,   0), gWhite, w, h);
+    draw2dLine (Vector3 (w,   h+a, 0), Vector3 (w,   h+b, 0), gWhite, w, h);
+    draw2dLine (Vector3 (w-a, h,   0), Vector3 (w-b, h,   0), gWhite, w, h);
+    draw2dLine (Vector3 (w,   h-a, 0), Vector3 (w,   h-b, 0), gWhite, w, h);
 
     glLineWidth (3);
-    draw2dLine (Vec3 (w+a, h,   0), Vec3 (w+b, h,   0), gBlack, w, h);
-    draw2dLine (Vec3 (w,   h+a, 0), Vec3 (w,   h+b, 0), gBlack, w, h);
-    draw2dLine (Vec3 (w-a, h,   0), Vec3 (w-b, h,   0), gBlack, w, h);
-    draw2dLine (Vec3 (w,   h-a, 0), Vec3 (w,   h-b, 0), gBlack, w, h);
+    draw2dLine (Vector3 (w+a, h,   0), Vector3 (w+b, h,   0), gBlack, w, h);
+    draw2dLine (Vector3 (w,   h+a, 0), Vector3 (w,   h+b, 0), gBlack, w, h);
+    draw2dLine (Vector3 (w-a, h,   0), Vector3 (w-b, h,   0), gBlack, w, h);
+    draw2dLine (Vector3 (w,   h-a, 0), Vector3 (w,   h-b, 0), gBlack, w, h);
     glLineWidth (1);
 }
 
@@ -893,9 +893,9 @@
 
 //     // xxx --------------------------------------------------
 //     {
-//         const Vec3 p = gSelectedVehicle->position;
-//         const Vec3 f = gSelectedVehicle->forward;
-//         const Vec3 s = gSelectedVehicle->side * 0.25f;
+//         const Vector3 p = gSelectedVehicle->position;
+//         const Vector3 f = gSelectedVehicle->forward;
+//         const Vector3 s = gSelectedVehicle->side * 0.25f;
 //         for (float i = 0; i <= 5; i++)
 //         {
 //             drawLine (p + (f * +i) + s, p + (f * +i) - s, gGray60);
@@ -921,7 +921,7 @@
 // given point on the screen: the ray that would be traced for that pixel
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::directionFromCameraToScreenPosition (int x, int y, int h)
 {
     // Get window height, viewport, modelview and projection matrices
@@ -938,8 +938,8 @@
 
     // "direction" is the normalized difference between these far and near
     // unprojected points.  Its parallel to the "eye-mouse" selection line.
-    const Vec3 diffNearFar (un1x-un0x, un1y-un0y, un1z-un0z);
-    const Vec3 direction = diffNearFar.normalize ();
+    const Vector3 diffNearFar (un1x-un0x, un1y-un0y, un1z-un0z);
+    const Vector3 direction = diffNearFar.normalisedCopy();
     return direction;
 }
 
@@ -957,8 +957,8 @@
     {
     public:
 
-        static void addToBuffer (const OpenSteer::Vec3& s,
-                                 const OpenSteer::Vec3& e,
+        static void addToBuffer (const Vector3& s,
+                                 const Vector3& e,
                                  const OpenSteer::Color& c)
         {
             DeferredLine dl;
@@ -988,8 +988,8 @@
 
     private:
 
-        OpenSteer::Vec3 startPoint;
-        OpenSteer::Vec3 endPoint;
+        Vector3 startPoint;
+        Vector3 endPoint;
         OpenSteer::Color color;
 
         static DeferredLines lines;
@@ -1003,8 +1003,8 @@
 
 
 void 
-OpenSteer::deferredDrawLine (const Vec3& startPoint,
-                             const Vec3& endPoint,
+OpenSteer::deferredDrawLine (const Vector3& startPoint,
+                             const Vector3& endPoint,
                              const Color& color)
 {
     DeferredLine::addToBuffer (startPoint, endPoint, color);
@@ -1033,8 +1033,8 @@
     public:
 
         static void addToBuffer (const float radius,
-                                 const OpenSteer::Vec3& axis,
-                                 const OpenSteer::Vec3& center,
+                                 const Vector3& axis,
+                                 const Vector3& center,
                                  const OpenSteer::Color& color,
                                  const int segments,
                                  const bool filled,
@@ -1072,8 +1072,8 @@
     private:
 
         float radius;
-        OpenSteer::Vec3 axis;
-        OpenSteer::Vec3 center;
+        Vector3 axis;
+        Vector3 center;
         OpenSteer::Color color;
         int segments;
         bool filled;
@@ -1091,8 +1091,8 @@
 
 void 
 OpenSteer::deferredDrawCircleOrDisk (const float radius,
-                                     const Vec3& axis,
-                                     const Vec3& center,
+                                     const Vector3& axis,
+                                     const Vector3& center,
                                      const Color& color,
                                      const int segments,
                                      const bool filled,
@@ -1147,7 +1147,7 @@
 //         const int fontHeight = 15; // for GLUT_BITMAP_9_BY_15
 //         const int x = w - (fontWidth * s.pcount());
 //         const int y = h - (fontHeight + 5);
-//         const Vec3 screenLocation (x, y, 0);
+//         const Vector3 screenLocation (x, y, 0);
 //         draw2dTextAt2dLocation (s, screenLocation, gWhite);
 //     }
 
@@ -1155,8 +1155,8 @@
 
 // // void draw2dTextAt3dLocation (const char* s,
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1186,8 +1186,8 @@
 
 // // void draw2dTextAt2dLocation (char* s,
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // store OpenGL matrix mode
 //     int savedMatrixMode;
@@ -1269,8 +1269,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1299,8 +1299,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 // //     // store OpenGL matrix mode
 // //     int savedMatrixMode;
@@ -1385,8 +1385,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1423,8 +1423,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     begin2dDrawing ();
 
@@ -1442,8 +1442,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1483,8 +1483,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     const GLint originalMatrixMode = begin2dDrawing ();
 
@@ -1498,7 +1498,7 @@
 
 void 
 OpenSteer::draw2dTextAt3dLocation (const char& text,
-                                   const Vec3& location,
+                                   const Vector3& location,
                                    const Color& color, float w, float h)
 {
     // XXX NOTE: "it would be nice if" this had a 2d screenspace offset for
@@ -1547,7 +1547,7 @@
 
 void 
 OpenSteer::draw2dTextAt3dLocation (const std::ostringstream& text,
-                                   const Vec3& location,
+                                   const Vector3& location,
                                    const Color& color, float w, float h)
 {
     draw2dTextAt3dLocation (*text.str().c_str(), location, color, w, h);
@@ -1556,7 +1556,7 @@
 
 void 
 OpenSteer::draw2dTextAt2dLocation (const char& text,
-                                   const Vec3 location,
+                                   const Vector3 location,
                                    const Color& color, float w, float h)
 {
     const GLint originalMatrixMode = begin2dDrawing (w, h);
@@ -1571,7 +1571,7 @@
 
 void 
 OpenSteer::draw2dTextAt2dLocation (const std::ostringstream& text,
-                                   const Vec3 location,
+                                   const Vector3 location,
                                    const Color& color, float w, float h)
 {
     draw2dTextAt2dLocation (*text.str().c_str(), location, color, w, h);
@@ -1596,37 +1596,37 @@
     class DrawSphereHelper
     {
     public:
-        Vec3 center;
+        Vector3 center;
         float radius;
         float maxEdgeLength;
         bool filled;
         Color color;
         bool drawFrontFacing;
         bool drawBackFacing;
-        Vec3 viewpoint;
+        Vector3 viewpoint;
 
         // default constructor (at origin, radius=1, white, wireframe, nocull)
         DrawSphereHelper ()
-            : center (Vec3::zero),
+            : center (Vector3::ZERO),
               radius (1.0f),
               maxEdgeLength (1.0f),
               filled (false),
               color (gWhite),
               drawFrontFacing (true),
               drawBackFacing (true),
-              viewpoint (Vec3::zero)
+              viewpoint (Vector3::ZERO)
         {}
 
 
         // "kitchen sink" constructor (allows specifying everything)
-        DrawSphereHelper (const Vec3 _center,
+        DrawSphereHelper (const Vector3 _center,
                           const float _radius,
                           const float _maxEdgeLength,
                           const bool _filled,
                           const Color& _color,
                           const bool _drawFrontFacing,
                           const bool _drawBackFacing,
-                          const Vec3& _viewpoint)
+                          const Vector3& _viewpoint)
             : center (_center),
               radius (_radius),
               maxEdgeLength (_maxEdgeLength),
@@ -1652,18 +1652,18 @@
             const float b = (radius / ratio) / (2.0f * phi);
 
             // define the icosahedron's 12 vertices:
-            const Vec3 v1  = center + Vec3 ( 0,  b, -a);
-            const Vec3 v2  = center + Vec3 ( b,  a,  0);
-            const Vec3 v3  = center + Vec3 (-b,  a,  0);
-            const Vec3 v4  = center + Vec3 ( 0,  b,  a);
-            const Vec3 v5  = center + Vec3 ( 0, -b,  a);
-            const Vec3 v6  = center + Vec3 (-a,  0,  b);
-            const Vec3 v7  = center + Vec3 ( 0, -b, -a);
-            const Vec3 v8  = center + Vec3 ( a,  0, -b);
-            const Vec3 v9  = center + Vec3 ( a,  0,  b);
-            const Vec3 v10 = center + Vec3 (-a,  0, -b);
-            const Vec3 v11 = center + Vec3 ( b, -a,  0);
-            const Vec3 v12 = center + Vec3 (-b, -a,  0);
+            const Vector3 v1  = center + Vector3 ( 0,  b, -a);
+            const Vector3 v2  = center + Vector3 ( b,  a,  0);
+            const Vector3 v3  = center + Vector3 (-b,  a,  0);
+            const Vector3 v4  = center + Vector3 ( 0,  b,  a);
+            const Vector3 v5  = center + Vector3 ( 0, -b,  a);
+            const Vector3 v6  = center + Vector3 (-a,  0,  b);
+            const Vector3 v7  = center + Vector3 ( 0, -b, -a);
+            const Vector3 v8  = center + Vector3 ( a,  0, -b);
+            const Vector3 v9  = center + Vector3 ( a,  0,  b);
+            const Vector3 v10 = center + Vector3 (-a,  0, -b);
+            const Vector3 v11 = center + Vector3 ( b, -a,  0);
+            const Vector3 v12 = center + Vector3 (-b, -a,  0);
 
             // draw the icosahedron's 20 triangular faces:
             drawMeshedTriangleOnSphere (v1, v2, v3);
@@ -1690,10 +1690,10 @@
 
 
         // given two points, take midpoint and project onto this sphere
-        inline Vec3 midpointOnSphere (const Vec3& a, const Vec3& b) const
+        inline Vector3 midpointOnSphere (const Vector3& a, const Vector3& b) const
         {
-            const Vec3 midpoint = (a + b) * 0.5f;
-            const Vec3 unitRadial = (midpoint - center).normalize ();
+            const Vector3 midpoint = (a + b) * 0.5f;
+            const Vector3 unitRadial = (midpoint - center).normalisedCopy();
             return center + (unitRadial * radius);
         }
 
@@ -1701,9 +1701,9 @@
         // given three points on the surface of this sphere, if the triangle
         // is "small enough" draw it, otherwise subdivide it into four smaller
         // triangles and recursively draw each of them.
-        void drawMeshedTriangleOnSphere (const Vec3& a, 
-                                         const Vec3& b,
-                                         const Vec3& c) const
+        void drawMeshedTriangleOnSphere (const Vector3& a, 
+                                         const Vector3& b,
+                                         const Vector3& c) const
         {
             // if all edges are short enough
             if ((((a - b).length ()) < maxEdgeLength) &&
@@ -1716,9 +1716,9 @@
             else // otherwise subdivide and recurse
             {
                 // find edge midpoints
-                const Vec3 ab = midpointOnSphere (a, b);
-                const Vec3 bc = midpointOnSphere (b, c);
-                const Vec3 ca = midpointOnSphere (c, a);
+                const Vector3 ab = midpointOnSphere (a, b);
+                const Vector3 bc = midpointOnSphere (b, c);
+                const Vector3 ca = midpointOnSphere (c, a);
 
                 // recurse on four sub-triangles
                 drawMeshedTriangleOnSphere ( a, ab, ca);
@@ -1730,16 +1730,16 @@
 
 
         // draw one mesh element for drawMeshedTriangleOnSphere
-        void drawTriangleOnSphere (const Vec3& a, 
-                                   const Vec3& b,
-                                   const Vec3& c) const
+        void drawTriangleOnSphere (const Vector3& a, 
+                                   const Vector3& b,
+                                   const Vector3& c) const
         {
             // draw triangle, subject to the camera orientation criteria
             // (according to drawBackFacing and drawFrontFacing)
-            const Vec3 triCenter = (a + b + c) / 3.0f;
-            const Vec3 triNormal = triCenter - center; // not unit length
-            const Vec3 view = triCenter - viewpoint;
-            const float dot = view.dot (triNormal); // project normal on view
+            const Vector3 triCenter = (a + b + c) / 3.0f;
+            const Vector3 triNormal = triCenter - center; // not unit length
+            const Vector3 view = triCenter - viewpoint;
+            const float dot = view.dotProduct(triNormal); // project normal on view
             const bool seen = ((dot>0.0f) ? drawBackFacing : drawFrontFacing);
             if (seen)
             {
@@ -1756,7 +1756,7 @@
                     // draw triangle edges (use trick to avoid drawing each
                     // edge twice (for each adjacent triangle) unless we are
                     // culling and this tri is near the sphere's silhouette)
-                    const float unitDot = view.dot (triNormal.normalize ());
+                    const float unitDot = view.dotProduct(triNormal.normalisedCopy());
                     const float t = 0.05f; // near threshold
                     const bool nearSilhouette = (unitDot<t) || (unitDot>-t);
                     if (nearSilhouette && !(drawBackFacing&&drawFrontFacing))
@@ -1779,8 +1779,8 @@
         // Draws line from A to B but not from B to A: assumes each edge
         // will be drawn in both directions, picks just one direction for
         // drawing according to an arbitary but reproducable criterion.
-        void drawMeshedTriangleLine (const Vec3& a, 
-                                     const Vec3& b,
+        void drawMeshedTriangleLine (const Vector3& a, 
+                                     const Vector3& b,
                                      const Color& color) const
         {
             if (a.x != b.x)
@@ -1804,14 +1804,14 @@
 
 
     // draw a sphere (wireframe or opaque, with front/back/both culling)
-    void drawSphere (const Vec3 center,
+    void drawSphere (const Vector3 center,
                      const float radius,
                      const float maxEdgeLength,
                      const bool filled,
                      const Color& color,
                      const bool drawFrontFacing,
                      const bool drawBackFacing,
-                     const Vec3& viewpoint)
+                     const Vector3& viewpoint)
     {
         const DrawSphereHelper s (center, radius, maxEdgeLength, filled, color,
                                   drawFrontFacing, drawBackFacing, viewpoint);
@@ -1824,7 +1824,7 @@
                              const float maxEdgeLength,
                              const bool filled,
                              const Color& color,
-                             const Vec3& viewpoint)
+                             const Vector3& viewpoint)
     {
         bool front, back;
         switch (so.seenFrom ())

Modified: dependencies/opensteer/src/Obstacle.cpp
===================================================================
--- dependencies/opensteer/src/Obstacle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Obstacle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -44,7 +44,7 @@
 // compute steering for a vehicle to avoid this obstacle, if needed 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Obstacle::steerToAvoid (const AbstractVehicle& vehicle,
                                    const float minTimeToCollision) const
 {
@@ -62,7 +62,7 @@
 // static method to apply steerToAvoid to nearest obstacle in an ObstacleGroup
 
 
-OpenSteer::Vec3
+Vector3
 OpenSteer::Obstacle::
 steerToAvoidObstacles (const AbstractVehicle& vehicle,
                        const float minTimeToCollision,
@@ -120,7 +120,7 @@
 // determine steering once path intersections have been found
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Obstacle::PathIntersection::
 steerToAvoidIfNeeded (const AbstractVehicle& vehicle,
                       const float minTimeToCollision) const
@@ -132,12 +132,12 @@
         // compute avoidance steering force: take the component of
         // steerHint which is lateral (perpendicular to vehicle's
         // forward direction), set its length to vehicle's maxForce
-        Vec3 lateral = steerHint.perpendicularComponent (vehicle.forward ());
-        return lateral.normalize () * vehicle.maxForce ();
+        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.forward ());
+        return lateral.normalisedCopy() * vehicle.maxForce ();
     }
     else
     {
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
 }
 
@@ -161,7 +161,7 @@
     // simplifies some of the calculations.
 
     float b, c, d, p, q, s;
-    Vec3 lc;
+    Vector3 lc;
 
     // initialize pathIntersection object to "no intersection found"
     pi.intersect = false;
@@ -204,7 +204,7 @@
          ((p > 0) ? p : q));
     pi.surfacePoint =
         vehicle.position() + (vehicle.forward() * pi.distance);
-    pi.surfaceNormal = (pi.surfacePoint-center).normalize();
+    pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
     // hmm, note that this was actually determined already in pi.distance calc
     pi.vehicleOutside = lc.length () > radius;
     switch (seenFrom ())
@@ -237,13 +237,13 @@
     const float w = width; // dimensions
     const float h = height;
     const float d = depth;
-    const Vec3 s = side (); // local space
-    const Vec3 u = up ();
-    const Vec3 f = forward ();
-    const Vec3 p = position ();
-    const Vec3 hw = s * (0.5f * width); // offsets for face centers
-    const Vec3 hh = u * (0.5f * height);
-    const Vec3 hd = f * (0.5f * depth);
+    const Vector3 s = side (); // local space
+    const Vector3 u = up ();
+    const Vector3 f = forward ();
+    const Vector3 p = position ();
+    const Vector3 hw = s * (0.5f * width); // offsets for face centers
+    const Vector3 hh = u * (0.5f * height);
+    const Vector3 hd = f * (0.5f * depth);
     const seenFromState sf = seenFrom ();
 
     // the box's six rectangular faces
@@ -271,7 +271,7 @@
     if (pi.intersect)
     {
         pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - position ()).normalize () *
+        pi.steerHint = ((pi.surfacePoint - position ()).normalisedCopy() *
                         (pi.vehicleOutside ? 1.0f : -1.0f));
     }
 }
@@ -291,11 +291,11 @@
     // initialize pathIntersection object to "no intersection found"
     pi.intersect = false;
 
-    const Vec3 lp =  localizePosition (vehicle.position ());
-    const Vec3 ld = localizeDirection (vehicle.forward ());
+    const Vector3 lp =  localizePosition (vehicle.position ());
+    const Vector3 ld = localizeDirection (vehicle.forward ());
 
     // no obstacle intersection if path is parallel to XY (side/up) plane
-    if (ld.dot (Vec3::forward) == 0.0f) return;
+    if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
 
     // no obstacle intersection if vehicle is heading away from the XY plane
     if ((lp.z > 0.0f) && (ld.z > 0.0f)) return;
@@ -308,16 +308,16 @@
     // find intersection of path with rectangle's plane (XY plane)
     const float ix = lp.x - (ld.x * lp.z / ld.z);
     const float iy = lp.y - (ld.y * lp.z / ld.z);
-    const Vec3 planeIntersection (ix, iy, 0.0f);
+    const Vector3 planeIntersection (ix, iy, 0.0f);
 
     // no obstacle intersection if plane intersection is outside 2d shape
     if (!xyPointInsideShape (planeIntersection, vehicle.radius ())) return;
 
     // otherwise, the vehicle path DOES intersect this rectangle
-    const Vec3 localXYradial = planeIntersection.normalize ();
-    const Vec3 radial = globalizeDirection (localXYradial);
+    const Vector3 localXYradial = planeIntersection.normalisedCopy();
+    const Vector3 radial = globalizeDirection (localXYradial);
     const float sideSign = (lp.z > 0.0f) ? +1.0f : -1.0f;
-    const Vec3 opposingNormal = forward () * sideSign;
+    const Vector3 opposingNormal = forward () * sideSign;
     pi.intersect = true;
     pi.obstacle = this;
     pi.distance = (lp - planeIntersection).length ();
@@ -336,7 +336,7 @@
 bool 
 OpenSteer::
 RectangleObstacle::
-xyPointInsideShape (const Vec3& point, float radius) const
+xyPointInsideShape (const Vector3& point, float radius) const
 {
     const float w = radius + (width * 0.5f);
     const float h = radius + (height * 0.5f);

Modified: dependencies/opensteer/src/OldPathway.cpp
===================================================================
--- dependencies/opensteer/src/OldPathway.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/OldPathway.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -47,7 +47,7 @@
 
 
 OpenSteer::Old::PolylinePathway::PolylinePathway (const int _pointCount,
-                                                  const Vec3 _points[],
+                                                  const Vector3 _points[],
                                                   const float _radius,
                                                   const bool _cyclic)
 {
@@ -61,7 +61,7 @@
 
 void 
 OpenSteer::Old::PolylinePathway::initialize (const int _pointCount,
-                                             const Vec3 _points[],
+                                             const Vector3 _points[],
                                              const float _radius,
                                              const bool _cyclic)
 {
@@ -71,8 +71,8 @@
     pointCount = _pointCount;
     if (cyclic) pointCount++;
     lengths = new float    [pointCount];
-    points  = new Vec3 [pointCount];
-    normals = new Vec3 [pointCount];
+    points  = new Vector3 [pointCount];
+    normals = new Vector3 [pointCount];
 
     // loop over all points
     for (int i = 0; i < pointCount; i++)
@@ -117,7 +117,7 @@
 void 
 OpenSteer::Old::PolylinePathway::movePoints (const int _firstPoint,
                                              const int _numPoints,
-                                             const Vec3 _points[])
+                                             const Vector3 _points[])
 {
     // loop over all points
     for (int i = _firstPoint; i < _firstPoint + _numPoints; i++)
@@ -141,14 +141,14 @@
 // that a negative distance indicates A is inside the Pathway.
 
 
-OpenSteer::Vec3 
-OpenSteer::Old::PolylinePathway::mapPointToPath (const Vec3& point,
-                                                 Vec3& tangent,
+Vector3 
+OpenSteer::Old::PolylinePathway::mapPointToPath (const Vector3& point,
+                                                 Vector3& tangent,
                                                  float& outside)
 {
     float d;
     float minDistance = FLT_MAX;
-    Vec3 onPath;
+    Vector3 onPath;
 
     // loop over all segments, find the one nearest to the given point
     for (int i = 1; i < pointCount; i++)
@@ -165,7 +165,7 @@
     }
 
     // measure how far original point is outside the Pathway's "tube"
-    outside = Vec3::distance (onPath, point) - radius;
+    outside = onPath.distance(point) - radius;
 
     // return point on path
     return onPath;
@@ -177,7 +177,7 @@
 
 
 float 
-OpenSteer::Old::PolylinePathway::mapPointToPathDistance (const Vec3& point)
+OpenSteer::Old::PolylinePathway::mapPointToPathDistance (const Vector3& point)
 {
     float d;
     float minDistance = FLT_MAX;
@@ -206,7 +206,7 @@
 // given a distance along the path, convert it to a point on the path
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Old::PolylinePathway::mapPathDistanceToPoint (float pathDistance)
 {
     // clip or wrap given path distance according to cyclic flag
@@ -224,7 +224,7 @@
     // step through segments, subtracting off segment lengths until
     // locating the segment that contains the original pathDistance.
     // Interpolate along that segment to find 3d point value to return.
-    Vec3 result;
+    Vector3 result;
     for (int i = 1; i < pointCount; i++)
     {
         segmentLength = lengths[i];
@@ -251,15 +251,15 @@
 
 
 float 
-OpenSteer::Old::PolylinePathway::pointToSegmentDistance (const Vec3& point,
-                                                         const Vec3& ep0,
-                                                         const Vec3& ep1)
+OpenSteer::Old::PolylinePathway::pointToSegmentDistance (const Vector3& point,
+                                                         const Vector3& ep0,
+                                                         const Vector3& ep1)
 {
     // convert the test point to be "local" to ep0
     local = point - ep0;
 
     // find the projection of "local" onto "segmentNormal"
-    segmentProjection = segmentNormal.dot (local);
+    segmentProjection = segmentNormal.dotProduct(local);
 
     // handle boundary cases: when projection is not on segment, the
     // nearest point is one of the endpoints of the segment
@@ -267,19 +267,19 @@
     {
         chosen = ep0;
         segmentProjection = 0;
-        return Vec3::distance (point, ep0);
+        return point.distance(ep0);
     }
     if (segmentProjection > segmentLength)
     {
         chosen = ep1;
         segmentProjection = segmentLength;
-        return Vec3::distance (point, ep1);
+        return point.distance(ep1);
     }
 
     // otherwise nearest point is projection point on segment
     chosen = segmentNormal * segmentProjection;
     chosen +=  ep0;
-    return Vec3::distance (point, chosen);
+    return point.distance(chosen);
 }
 
 

Modified: dependencies/opensteer/src/OpenSteerDemo.cpp
===================================================================
--- dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -451,7 +451,7 @@
 OpenSteer::OpenSteerDemo::findVehicleNearestScreenPosition (int x, int y)
 {
     // find the direction from the camera position to the given pixel
-    const Vec3 direction = directionFromCameraToScreenPosition (x, y, glutGet (GLUT_WINDOW_HEIGHT));
+    const Vector3 direction = directionFromCameraToScreenPosition (x, y, glutGet (GLUT_WINDOW_HEIGHT));
 
     // iterate over all vehicles to find the one whose center is nearest the
     // "eye-mouse" selection line
@@ -541,7 +541,7 @@
     selectedVehicle = &selected;
     if (&selected)
     {
-        const Vec3 behind = selected.forward() * -distance;
+        const Vector3 behind = selected.forward() * -distance;
         camera.setPosition (selected.position() + behind);
         camera.target = selected.position();
     }
@@ -563,7 +563,7 @@
     position3dCamera (selected, distance, elevation);
 
     // then adjust for 3d:
-    Vec3 position3d = camera.position();
+    Vector3 position3d = camera.position();
     position3d.y += elevation;
     camera.setPosition (position3d);
 }
@@ -589,7 +589,7 @@
 
 const float OpenSteer::OpenSteerDemo::camera2dElevation = 8;
 const float OpenSteer::OpenSteerDemo::cameraTargetDistance = 13;
-const OpenSteer::Vec3 OpenSteer::OpenSteerDemo::cameraTargetOffset (0, OpenSteer::OpenSteerDemo::camera2dElevation, 
+const Vector3 OpenSteer::OpenSteerDemo::cameraTargetOffset (0, OpenSteer::OpenSteerDemo::camera2dElevation, 
                                                                     0);
 
 
@@ -598,12 +598,12 @@
 
 
 void 
-OpenSteer::OpenSteerDemo::gridUtility (const Vec3& gridTarget)
+OpenSteer::OpenSteerDemo::gridUtility (const Vector3& gridTarget)
 {
     // round off target to the nearest multiple of 2 (because the
     // checkboard grid with a pitch of 1 tiles with a period of 2)
     // then lower the grid a bit to put it under 2d annotation lines
-    const Vec3 gridCenter ((round (gridTarget.x * 0.5f) * 2),
+    const Vector3 gridCenter ((round (gridTarget.x * 0.5f) * 2),
                            (round (gridTarget.y * 0.5f) * 2) - .05f,
                            (round (gridTarget.z * 0.5f) * 2));
 
@@ -657,7 +657,7 @@
     if (&v)
     {
         const float diameter = v.radius() * 2;
-        const Vec3 size (diameter, diameter, diameter);
+        const Vector3 size (diameter, diameter, diameter);
         drawBoxOutline (v, size, color);
     }
 }
@@ -676,7 +676,7 @@
 {
     if (&v)
     {
-        const Vec3& cPosition = camera.position();
+        const Vector3& cPosition = camera.position();
         draw3dCircle  (v.radius() * radiusMultiplier,  // adjusted radius
                        v.position(),                   // center
                        v.position() - cPosition,       // view axis
@@ -988,7 +988,7 @@
             gMouseAdjustingCameraLastX = x;
             gMouseAdjustingCameraLastY = y;
 
-            OpenSteer::Vec3 cameraAdjustment;
+            Vector3 cameraAdjustment;
 
             // set XY values according to mouse motion on screen space
             if (gMouseAdjustingCameraAngle)
@@ -1041,7 +1041,7 @@
     drawDisplayPlugInName (void)
     {
         const float h = glutGet (GLUT_WINDOW_HEIGHT);
-        const OpenSteer::Vec3 screenLocation (10, h-20, 0);
+        const Vector3 screenLocation (10, h-20, 0);
         draw2dTextAt2dLocation (*OpenSteer::OpenSteerDemo::nameOfSelectedPlugIn (),
                                 screenLocation,
                                 OpenSteer::gWhite, OpenSteer::drawGetWindowWidth(), OpenSteer::drawGetWindowHeight());
@@ -1057,7 +1057,7 @@
     {
         std::ostringstream message;
         message << "Camera: " << OpenSteer::OpenSteerDemo::camera.modeName () << std::ends;
-        const OpenSteer::Vec3 screenLocation (10, 10, 0);
+        const Vector3 screenLocation (10, 10, 0);
         OpenSteer::draw2dTextAt2dLocation (message, screenLocation, OpenSteer::gWhite, OpenSteer::drawGetWindowWidth(), OpenSteer::drawGetWindowHeight());
     }
 
@@ -1124,7 +1124,7 @@
             // keep track of font metrics and start of next line
             const int lh = 16; // xxx line height
             const int cw = 9; // xxx character width
-            OpenSteer::Vec3 screenLocation (10, 10, 0);
+            Vector3 screenLocation (10, 10, 0);
 
             // target and recent average frame rates
             const int targetFPS = OpenSteer::OpenSteerDemo::clock.getFixedFrameRate ();
@@ -1155,7 +1155,7 @@
                     clockStr << "fixed frame rate (target: " << targetFPS;
                     clockStr << " actual: " << OpenSteer::round(smoothedFPS) << ", ";
 
-                    OpenSteer::Vec3 sp;
+                    Vector3 sp;
                     sp = screenLocation;
                     sp.x += cw * (int) clockStr.tellp ();
 

Modified: dependencies/opensteer/src/PolylineSegmentedPath.cpp
===================================================================
--- dependencies/opensteer/src/PolylineSegmentedPath.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/PolylineSegmentedPath.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,7 +38,7 @@
 
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include "OpenSteer/Vec3.h"
 
 // Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
@@ -58,7 +58,7 @@
 namespace {
     
     typedef OpenSteer::SegmentedPath::size_type size_type;
-    typedef std::vector< OpenSteer::Vec3 > Vec3Container;
+    typedef std::vector< Vector3 > Vec3Container;
     typedef std::vector< float > FloatContainer;
     
     /**
@@ -79,7 +79,7 @@
                 "segmentIndex out of range." );
         assert( segmentTangents.size() == segmentLengths.size() && "segmentTangents and segmentLengths must have the same size." );
         
-        OpenSteer::Vec3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
+        Vector3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
         float const length = tangent.length();
         assert( ! OpenSteer::isZero( length ) && 
                 "Segments must have lengths greater than 0." );
@@ -200,7 +200,7 @@
 
 
 OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( size_type numOfPoints,
-                                                         Vec3 const newPoints[],
+                                                         Vector3 const newPoints[],
                                                          bool closedCycle )
     : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
 {
@@ -247,7 +247,7 @@
 
 void 
 OpenSteer::PolylineSegmentedPath::setPath( size_type numOfPoints,
-                                           Vec3 const newPoints[],
+                                           Vector3 const newPoints[],
                                            bool closedCycle )
 {
     assert( 1 < numOfPoints && "Path must have at least two distinct points." );
@@ -289,7 +289,7 @@
 void 
 OpenSteer::PolylineSegmentedPath::movePoints( size_type startIndex,
                                               size_type numOfPoints,
-                                              Vec3 const newPoints[] )
+                                              Vector3 const newPoints[] )
 {
     assert( ( startIndex < ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) && 
             "startIndex must be inside index range." );
@@ -329,9 +329,9 @@
 
 
 
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vec3& point,
-                                                  Vec3& tangent,
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vector3& point,
+                                                  Vector3& tangent,
                                                   float& outside) const
 {
     PointToPathMapping mapping;
@@ -342,7 +342,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapPathDistanceToPoint (float pathDistance) const
 {
     PathDistanceToPointMapping mapping;
@@ -352,7 +352,7 @@
 
 
 float 
-OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vec3& point) const
+OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vector3& point) const
 {
     PointToPathDistanceMapping mapping;
     mapPointToPathAlike( *this, point, mapping );
@@ -382,7 +382,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::point( size_type pointIndex ) const
 {
     assert( pointIndex < pointCount() && "pointIndex out of range." );
@@ -407,7 +407,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::segmentStart( size_type segmentIndex ) const
 {
     assert( segmentIndex < segmentCount() && "segmentIndex out of range." );
@@ -416,7 +416,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::segmentEnd( size_type segmentIndex ) const
 {
     assert( segmentIndex < segmentCount() && "segmentIndex out of range." );
@@ -428,18 +428,18 @@
 
 float 
 OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                             Vec3 const& point ) const
+                                                             Vector3 const& point ) const
 {
     assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
     
-    Vec3 const segmentStartToPoint( point - points_[ segmentIndex ] );
-    float const distance = segmentStartToPoint.dot( segmentTangents_[ segmentIndex ] );
+    Vector3 const segmentStartToPoint( point - points_[ segmentIndex ] );
+    float const distance = segmentStartToPoint.dotProduct( segmentTangents_[ segmentIndex ] );
     
     return clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                              float segmentDistance ) const
 {
@@ -459,7 +459,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                                float ) const
 {
@@ -471,8 +471,8 @@
 void 
 OpenSteer::PolylineSegmentedPath::mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                                        float segmentDistance,
-                                                                       Vec3& pointOnPath,
-                                                                       Vec3& tangent ) const
+                                                                       Vector3& pointOnPath,
+                                                                       Vector3& tangent ) const
 {
     assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
     
@@ -494,17 +494,17 @@
 
 void 
 OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                               Vec3 const& point,
+                                                                               Vector3 const& point,
                                                                                float& distance,
-                                                                               Vec3& pointOnPath,
-                                                                               Vec3& tangent ) const
+                                                                               Vector3& pointOnPath,
+                                                                               Vector3& tangent ) const
 {
     assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
     
-    Vec3 const segmentStartPoint = points_[ segmentIndex ];
-    Vec3 const segmentStartToPoint( point - segmentStartPoint );
+    Vector3 const segmentStartPoint = points_[ segmentIndex ];
+    Vector3 const segmentStartToPoint( point - segmentStartPoint );
     tangent = segmentTangents_[ segmentIndex ];
-    distance = segmentStartToPoint.dot( tangent );
+    distance = segmentStartToPoint.dotProduct( tangent );
     distance =  clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
     pointOnPath = tangent * distance + segmentStartPoint;
 }

Modified: dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp
===================================================================
--- dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -62,7 +62,7 @@
 
 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                                                                       Vec3 const points[],
+                                                                                       Vector3 const points[],
                                                                                        float r,
                                                                                        bool closeCycle )
     : path_( numOfPoints, points, closeCycle ), radius_( r )
@@ -110,7 +110,7 @@
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::movePoints( size_type startIndex,
                                                              size_type numOfPoints,
-                                                             Vec3 const newPointValues[] )
+                                                             Vector3 const newPointValues[] )
 {
     path_.movePoints( startIndex, numOfPoints, newPointValues );
 }
@@ -120,7 +120,7 @@
 
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::setPathway( size_type numOfPoints,
-                                                             Vec3 const points[],
+                                                             Vector3 const points[],
                                                              float r,
                                                              bool closedCycle )
 {
@@ -155,9 +155,9 @@
 
 
 
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vec3& point,
-                                                                 Vec3& tangent,
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vector3& point,
+                                                                 Vector3& tangent,
                                                                  float& outside) const
 {
     PointToPathMapping mapping;
@@ -169,7 +169,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPathDistanceToPoint (float pathDistance) const
 {
     PathDistanceToPointMapping mapping;
@@ -180,7 +180,7 @@
 
 
 float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vec3& point) const
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vector3& point) const
 {
     PointToPathDistanceMapping mapping;
     mapPointToPathAlike( *this, point, mapping );
@@ -213,7 +213,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::point( size_type pointIndex ) const
 {
     return path_.point( pointIndex );
@@ -238,7 +238,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentStart( size_type segmentIndex ) const
 {
     return path_.segmentStart( segmentIndex );
@@ -246,7 +246,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentEnd( size_type segmentIndex ) const
 {
     return path_.segmentEnd( segmentIndex );
@@ -256,14 +256,14 @@
 
 float 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                                            Vec3 const& point ) const
+                                                                            Vector3 const& point ) const
 {
     return path_.mapPointToSegmentDistance( segmentIndex, point );
 }
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                                             float segmentDistance ) const
 {
@@ -283,7 +283,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                                               float segmentDistance ) const
 {
@@ -294,8 +294,8 @@
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                                                float distance,
-                                                                                               Vec3& pointOnPath,
-                                                                                               Vec3& tangent,
+                                                                                               Vector3& pointOnPath,
+                                                                                               Vector3& tangent,
                                                                                                float& radius ) const
 {
     path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
@@ -307,10 +307,10 @@
 
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                              Vec3 const& point,
+                                                                                              Vector3 const& point,
                                                                                               float& distance,
-                                                                                              Vec3& pointOnPath,
-                                                                                              Vec3& tangent,
+                                                                                              Vector3& pointOnPath,
+                                                                                              Vector3& tangent,
                                                                                               float& radius) const
 {
     path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );

Modified: dependencies/opensteer/src/SimpleVehicle.cpp
===================================================================
--- dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -78,7 +78,7 @@
 OpenSteer::SimpleVehicle::SimpleVehicle (void)
 {
     // set inital state
-    reset ();
+    reset();
 
     // maintain unique serial numbers
     serialNumber = serialNumberCounter++;
@@ -106,13 +106,13 @@
 // parameter names commented out to prevent compiler warning from "-W"
 
 
-OpenSteer::Vec3 
-OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vec3& force,
+Vector3 
+OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vector3& force,
                                                   const float /* deltaTime */)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed ();
+    const float maxAdjustedSpeed = 0.2f * maxSpeed();
 
-    if ((speed () > maxAdjustedSpeed) || (force == Vec3::zero))
+    if ((speed() > maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }
@@ -148,12 +148,12 @@
 void 
 OpenSteer::SimpleVehicle::applyBrakingForce (const float rate, const float deltaTime)
 {
-    const float rawBraking = speed () * rate;
-    const float clipBraking = ((rawBraking < maxForce ()) ?
+    const float rawBraking = speed() * rate;
+    const float clipBraking = ((rawBraking < maxForce()) ?
                                rawBraking :
-                               maxForce ());
+                               maxForce());
 
-    setSpeed (speed () - (clipBraking * deltaTime));
+    setSpeed (speed() - (clipBraking * deltaTime));
 }
 
 
@@ -163,18 +163,18 @@
 
 
 void 
-OpenSteer::SimpleVehicle::applySteeringForce (const Vec3& force,
+OpenSteer::SimpleVehicle::applySteeringForce (const Vector3& force,
                                               const float elapsedTime)
 {
 
-    const Vec3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
+    const Vector3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
 
     // enforce limit on magnitude of steering force
-    const Vec3 clippedForce = adjustedForce.truncateLength (maxForce ());
+    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, maxForce());
 
     // compute acceleration and velocity
-    Vec3 newAcceleration = (clippedForce / mass());
-    Vec3 newVelocity = velocity();
+    Vector3 newAcceleration = (clippedForce / mass());
+    Vector3 newVelocity = velocity();
 
     // damp out abrupt changes and oscillations in steering acceleration
     // (rate is proportional to time step, then clipped into useful range)
@@ -190,7 +190,7 @@
     newVelocity += _smoothedAcceleration * elapsedTime;
 
     // enforce speed limit
-    newVelocity = newVelocity.truncateLength (maxSpeed ());
+    newVelocity = Vec3Utils::truncateLength(newVelocity, maxSpeed());
 
     // update Speed
     setSpeed (newVelocity.length());
@@ -207,7 +207,7 @@
 
     // running average of recent positions
     blendIntoAccumulator (elapsedTime * 0.06f, // QQQ
-                          position (),
+                          position(),
                           _smoothedPosition);
 }
 
@@ -220,7 +220,7 @@
 
 
 void 
-OpenSteer::SimpleVehicle::regenerateLocalSpace (const Vec3& newVelocity,
+OpenSteer::SimpleVehicle::regenerateLocalSpace (const Vector3& newVelocity,
                                                 const float /* elapsedTime */)
 {
     // adjust orthonormal basis vectors to be aligned with new velocity
@@ -237,30 +237,30 @@
 
 
 void 
-OpenSteer::SimpleVehicle::regenerateLocalSpaceForBanking (const Vec3& newVelocity,
+OpenSteer::SimpleVehicle::regenerateLocalSpaceForBanking (const Vector3& newVelocity,
                                                           const float elapsedTime)
 {
     // the length of this global-upward-pointing vector controls the vehicle's
     // tendency to right itself as it is rolled over from turning acceleration
-    const Vec3 globalUp (0, 0.2f, 0);
+    const Vector3 globalUp (0, 0.2f, 0);
 
     // acceleration points toward the center of local path curvature, the
     // length determines how much the vehicle will roll while turning
-    const Vec3 accelUp = _smoothedAcceleration * 0.05f;
+    const Vector3 accelUp = _smoothedAcceleration * 0.05f;
 
     // combined banking, sum of UP due to turning and global UP
-    const Vec3 bankUp = accelUp + globalUp;
+    const Vector3 bankUp = accelUp + globalUp;
 
     // blend bankUp into vehicle's UP basis vector
     const float smoothRate = elapsedTime * 3;
-    Vec3 tempUp = up();
+    Vector3 tempUp = up();
     blendIntoAccumulator (smoothRate, bankUp, tempUp);
-    setUp (tempUp.normalize());
+    setUp (tempUp.normalisedCopy());
 
 //  annotationLine (position(), position() + (globalUp * 4), gWhite);  // XXX
 //  annotationLine (position(), position() + (bankUp   * 4), gOrange); // XXX
 //  annotationLine (position(), position() + (accelUp  * 4), gRed);    // XXX
-//  annotationLine (position(), position() + (up ()    * 1), gYellow); // XXX
+//  annotationLine (position(), position() + (up()    * 1), gYellow); // XXX
 
     // adjust orthonormal basis vectors to be aligned with new velocity
     if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
@@ -276,16 +276,16 @@
 {
     if (elapsedTime > 0)
     {
-        const Vec3 dP = _lastPosition - position ();
-        const Vec3 dF = (_lastForward - forward ()) / dP.length ();
-        const Vec3 lateral = dF.perpendicularComponent (forward ());
-        const float sign = (lateral.dot (side ()) < 0) ? 1.0f : -1.0f;
+        const Vector3 dP = _lastPosition - position();
+        const Vector3 dF = (_lastForward - forward()) / dP.length();
+        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, forward());
+        const float sign = (lateral.dotProduct(side()) < 0) ? 1.0f : -1.0f;
         _curvature = lateral.length() * sign;
         blendIntoAccumulator (elapsedTime * 4.0f,
                               _curvature,
                               _smoothedCurvature);
-        _lastForward = forward ();
-        _lastPosition = position ();
+        _lastForward = forward();
+        _lastPosition = position();
     }
 }
 
@@ -299,13 +299,13 @@
                                                           float maxLengthV)
 {
     const float desat = 0.4f;
-    const float aScale = maxLengthA / maxForce ();
-    const float vScale = maxLengthV / maxSpeed ();
-    const Vec3& p = position();
+    const float aScale = maxLengthA / maxForce();
+    const float vScale = maxLengthV / maxSpeed();
+    const Vector3& p = position();
     const Color aColor (desat, desat, 1); // bluish
     const Color vColor (    1, desat, 1); // pinkish
 
-    annotationLine (p, p + (velocity ()           * vScale), vColor);
+    annotationLine (p, p + (velocity()           * vScale), vColor);
     annotationLine (p, p + (_smoothedAcceleration * aScale), aColor);
 }
 
@@ -320,7 +320,7 @@
 // XXX move to a vehicle utility mixin?
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::SimpleVehicle::predictFuturePosition (const float predictionTime) const
 {
     return position() + (velocity() * predictionTime);

Modified: dependencies/opensteer/src/Vec3.cpp
===================================================================
--- dependencies/opensteer/src/Vec3.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Vec3.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -28,15 +28,15 @@
 // ----------------------------------------------------------------------------
 //
 //
-// Vec3: OpenSteer's generic type for 3d vectors
+// Vector3: OpenSteer's generic type for 3d vectors
 //
-// This file defines the class Vec3, which is used throughout OpenSteer to
+// This file defines the class Vector3, which is used throughout OpenSteer to
 // manipulate 3d geometric data.  It includes standard vector operations (like
 // vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
 // utility functions.
 //
 // When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vec3
+// important to use the 3d vector type of that application.  In that case Vector3
 // can be changed to inherit from the preexisting application' vector type and
 // to match the interface used by OpenSteer to the interface provided by the
 // preexisting 3d vector type.
@@ -52,37 +52,16 @@
 #include "OpenSteer/Vec3.h"
 
 
-// ----------------------------------------------------------------------------
-// names for frequently used vector constants
-
-
-const OpenSteer::Vec3 OpenSteer::Vec3::zero    (0, 0, 0);
-const OpenSteer::Vec3 OpenSteer::Vec3::up      (0, 1, 0);
-const OpenSteer::Vec3 OpenSteer::Vec3::forward (0, 0, 1);
-
-// XXX  This should be unified with LocalSpace::rightHanded, but I don't want
-// XXX  Vec3 to be based on LocalSpace which is based on Vec3.  Perhaps there
-// XXX  should be a tiny chirality.h header to define a const?  That could
-// XXX  then be included by both Vec3.h and LocalSpace.h
-
-const OpenSteer::Vec3 OpenSteer::Vec3::side    (-1, 0, 0);
-
-// ----------------------------------------------------------------------------
-// Returns a position randomly distributed inside a sphere of unit radius
-// centered at the origin.  Orientation will be random and length will range
-// between 0 and 1
-
-
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::RandomVectorInUnitRadiusSphere (void)
 {
-    Vec3 v;
+    Vector3 v;
 
     do
     {
-        v.set ((frandom01()*2) - 1,
-               (frandom01()*2) - 1,
-               (frandom01()*2) - 1);
+        v.x = (frandom01()*2) - 1;
+        v.y = (frandom01()*2) - 1;
+        v.z = (frandom01()*2) - 1;
     }
     while (v.length() >= 1);
 
@@ -96,16 +75,16 @@
 // random and length will range between 0 and 1
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::randomVectorOnUnitRadiusXZDisk (void)
 {
-    Vec3 v;
+    Vector3 v;
 
     do
     {
-        v.set ((frandom01()*2) - 1,
-               0,
-               (frandom01()*2) - 1);
+        v.x = (frandom01()*2) - 1;
+        v.y = 0;
+        v.z = (frandom01()*2) - 1;
     }
     while (v.length() >= 1);
 
@@ -121,19 +100,19 @@
 // cone.  Called by vecLimitMaxDeviationAngle and vecLimitMinDeviationAngle.
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                          const Vec3& source,
+                                          const Vector3& source,
                                           const float cosineOfConeAngle,
-                                          const Vec3& basis)
+                                          const Vector3& basis)
 {
     // immediately return zero length input vectors
     float sourceLength = source.length();
     if (sourceLength == 0) return source;
 
     // measure the angular diviation of "source" from "basis"
-    const Vec3 direction = source / sourceLength;
-    float cosineOfSourceAngle = direction.dot (basis);
+    const Vector3 direction = source / sourceLength;
+    float cosineOfSourceAngle = direction.dotProduct(basis);
 
     // Simply return "source" if it already meets the angle criteria.
     // (note: we hope this top "if" gets compiled out since the flag
@@ -150,18 +129,18 @@
     }
 
     // find the portion of "source" that is perpendicular to "basis"
-    const Vec3 perp = source.perpendicularComponent (basis);
+    const Vector3 perp = Vec3Utils::perpendicularComponent(source, basis);
 
     // normalize that perpendicular
-    const Vec3 unitPerp = perp.normalize ();
+    const Vector3 unitPerp = perp.normalisedCopy();
 
     // construct a new vector whose length equals the source vector,
     // and lies on the intersection of a plane (formed the source and
     // basis vectors) and a cone (whose axis is "basis" and whose
     // angle corresponds to cosineOfConeAngle)
     float perpDist = sqrtXXX (1 - (cosineOfConeAngle * cosineOfConeAngle));
-    const Vec3 c0 = basis * cosineOfConeAngle;
-    const Vec3 c1 = unitPerp * perpDist;
+    const Vector3 c0 = basis * cosineOfConeAngle;
+    const Vector3 c1 = unitPerp * perpDist;
     return (c0 + c1) * sourceLength;
 }
 
@@ -173,22 +152,22 @@
 // remain within 20% of input length).
 
 
-OpenSteer::Vec3 
-OpenSteer::findPerpendicularIn3d (const Vec3& direction)
+Vector3 
+OpenSteer::findPerpendicularIn3d (const Vector3& direction)
 {
     // to be filled in:
-    Vec3 quasiPerp;  // a direction which is "almost perpendicular"
-    Vec3 result;     // the computed perpendicular to be returned
+    Vector3 quasiPerp;  // a direction which is "almost perpendicular"
+    Vector3 result;     // the computed perpendicular to be returned
 
     // three mutually perpendicular basis vectors
-    const Vec3 i (1, 0, 0);
-    const Vec3 j (0, 1, 0);
-    const Vec3 k (0, 0, 1);
+    const Vector3 i (1, 0, 0);
+    const Vector3 j (0, 1, 0);
+    const Vector3 k (0, 0, 1);
 
     // measure the projection of "direction" onto each of the axes
-    const float id = i.dot (direction);
-    const float jd = j.dot (direction);
-    const float kd = k.dot (direction);
+    const float id = i.dotProduct(direction);
+    const float jd = j.dotProduct(direction);
+    const float kd = k.dotProduct(direction);
 
     // set quasiPerp to the basis which is least parallel to "direction"
     if ((id <= jd) && (id <= kd))
@@ -205,7 +184,7 @@
 
     // return the cross product (direction x quasiPerp)
     // which is guaranteed to be perpendicular to both of them
-    result.cross (direction, quasiPerp);
+    result = crossProduct(direction, quasiPerp);
     return result;
 }
 

Modified: dependencies/opensteer/src/Vec3Utilities.cpp
===================================================================
--- dependencies/opensteer/src/Vec3Utilities.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Vec3Utilities.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,10 +38,10 @@
 
 /**
  * @todo Is this useful?
-std::pair< Vec3, Vec3 >
-OpenSteer::convertPointAndSegmentToVectors( const Vec3& point,
-                                 const Vec3& segmentPoint0,
-                                 const Vec3& segmentPoint1 )
+std::pair< Vector3, Vector3 >
+OpenSteer::convertPointAndSegmentToVectors( const Vector3& point,
+                                 const Vector3& segmentPoint0,
+                                 const Vector3& segmentPoint1 )
 {
     
     
@@ -50,26 +50,26 @@
 }
 */
 
-OpenSteer::Vec3
-OpenSteer::nearestPointOnSegment( const Vec3& point,
-                                  const Vec3& segmentPoint0,
-                                  const Vec3& segmentPoint1 )
+Vector3
+OpenSteer::nearestPointOnSegment( const Vector3& point,
+                                  const Vector3& segmentPoint0,
+                                  const Vector3& segmentPoint1 )
 {
     // convert the test point to be "local" to ep0
-    Vec3 const local( point - segmentPoint0 );
+    Vector3 const local( point - segmentPoint0 );
     
     // find the projection of "local" onto "segmentNormal"
-    Vec3 const segment( segmentPoint1 - segmentPoint0 );
+    Vector3 const segment( segmentPoint1 - segmentPoint0 );
     float const segmentLength( segment.length() );
     
     assert( 0 != segmentLength && "Segment mustn't be of length zero." );
     
-    Vec3 const segmentNormalized( segment / segmentLength ); 
-    float segmentProjection = segmentNormalized.dot (local);
+    Vector3 const segmentNormalized( segment / segmentLength ); 
+    float segmentProjection = segmentNormalized.dotProduct(local);
     
     segmentProjection = clamp( segmentProjection, 0.0f, segmentLength );
     
-    Vec3 result( segmentNormalized * segmentProjection );
+    Vector3 result( segmentNormalized * segmentProjection );
     result +=  segmentPoint0;
     return result;    
     
@@ -78,9 +78,9 @@
 
 
 float 
-OpenSteer::pointToSegmentDistance ( const Vec3& point,
-                                    const Vec3& segmentPoint0,
-                                    const Vec3& segmentPoint1)
+OpenSteer::pointToSegmentDistance ( const Vector3& point,
+                                    const Vector3& segmentPoint0,
+                                    const Vector3& segmentPoint1)
 {
     return distance( point, nearestPointOnSegment( point, segmentPoint0, segmentPoint1 ) );
 }

Modified: modules/aitest/scripts/NpcTest.rb
===================================================================
--- modules/aitest/scripts/NpcTest.rb	2007-08-12 20:51:30 UTC (rev 3683)
+++ modules/aitest/scripts/NpcTest.rb	2007-08-12 21:30:22 UTC (rev 3684)
@@ -12,9 +12,9 @@
                                            min_base, max_base, "alpha_blue")
         base.placeIntoScene(center);
 
-        npc1proxy = $GOM.createGameObject("TestPerson");
-        npc1 = npc1proxy;
+        npc1 = $GOM.createGameObject("TestPerson");
         npc1.setPosition(rel_pos([0.0, height, 0.0]));
+		
 
         npc1.placeIntoScene();
     end

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * Copyright(C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
@@ -52,14 +52,14 @@
 	 *
 	 * Maybe this should be used as interface instead of AbstractVehicle
 	 */
-        class _RlAiExport SteeringVehicle : public SimpleVehicle_2,
+    class _RlAiExport SteeringVehicle : public SimpleVehicle_2,
                                             public DebugVisualisable
 	{
 	public:
 		/** Constructor.
 		 * @param parent Agent owning this vehicle
 		 */
-		SteeringVehicle(Agent* parent);
+		SteeringVehicle(Creature* creature);
 		/** explicit virtual destructor.
 		 */
 		virtual ~SteeringVehicle(void);
@@ -72,8 +72,8 @@
 
 		/**
 		 * Random walking behaviour
-		 * The steering value is purely tangential (has no Forward component) 
-		 * and uses the x-axis only at the moment (2D wandering)
+		 * The steering value is purely tangential(has no Forward component) 
+		 * and uses the x-axis only at the moment(2D wandering)
 		 * @param  elapsedTime The time step value allows wander rate to be consistent when frame times vary
 		 * @return a steering force for wandering behavior. 
 		 */
@@ -164,95 +164,95 @@
 		virtual void update(const float currentTime, const float elapsedTime);
 		/**
 		 * predict position of this vehicle at some time in the future
-		 * (assumes velocity remains constant)
+		 *(assumes velocity remains constant)
 		 */
-		OpenSteer::Vec3 predictFuturePosition (const float predictionTime) const;
+		Ogre::Vector3 predictFuturePosition(const float predictionTime) const;
 
 		void resetLocalSpace();
 
 		/** get mass
 		 * @returns mass of physical object
 		 */
-		float mass (void) const;
+		float mass() const;
 		/** does not set mass but is necessary for AbstractVehicle.
 		 * throws an exception on invocation.
 		 * @param m mass
 		 */
-		float setMass (float m);
+		float setMass(float m);
 
 		/** retrieve velocity of vehicle
 		 * @returns velocity of the vehicle
 		 */
-		OpenSteer::Vec3 velocity (void) const {return OpenSteer::Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
+		Ogre::Vector3 velocity() const {return mCurrentVelocity;}
 
 		/** retrieves speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 */
-		float speed (void) const;
+		float speed() const;
 		/** sets speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 * @param s new speed to set
 		 * @returns float new speed set.
 		 */
-		float setSpeed (float s);
+		float setSpeed(float s);
 
 		/** radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float radius (void) const;
+		float radius() const;
 		/** sets radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float setRadius (float m);
+		float setRadius(float m);
 
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float height (void) const;
+        float height() const;
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float setHeight (float h);
+        float setHeight(float h);
 
 		/** retrieves maximum force.
 		 * @returns float containing maximum force.
 		 */
-		float maxForce (void) const; 
+		float maxForce() const; 
 		/** sets maximum force.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum force set.
 		 */
-		float setMaxForce (float mf);
+		float setMaxForce(float mf);
 
 		/** retrieves maximum speed.
 		 * @returns float containing maximum speed
 		 */
-		float maxSpeed (void) const;
+		float maxSpeed() const;
 		/** retrieves maximum speed.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum speed
 		 */
-		float setMaxSpeed (float ms);
+		float setMaxSpeed(float ms);
 
 		/**
 		 * adjust the steering force passed to applySteeringForce.
          * allows a specific vehicle class to redefine this adjustment.
          * default is to disallow backward-facing steering at low speed.
 		 */
-		virtual OpenSteer::Vec3 adjustRawSteeringForce (const OpenSteer::Vec3& force);
+		virtual Ogre::Vector3 adjustRawSteeringForce(const Ogre::Vector3& force);
 
 		/** retrieve the controlled Actor
 		 * @returns Actor that is controlled by the SteeringVehicle
 		 */
-        const Actor* getActor(void) const;
+        const Actor* getActor() const;
 
         // derived from debugvisualisable
         virtual DebugVisualisableFlag getFlag() const;
@@ -290,9 +290,7 @@
 		//! the yaw angle in radians
 		//Ogre::Radian mYaw;
 
-		//! Agent using this vehicle
-		Agent* mParent;
-        //! Creature object steered by this vehicle (and controlled by Agent).
+        //! Creature object steered by this vehicle(and controlled by Agent).
         Creature* mCreature;
 
         CreatureController* mController;

Modified: rl/trunk/engine/ai/include/stdinc.h
===================================================================
--- rl/trunk/engine/ai/include/stdinc.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/include/stdinc.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -40,6 +40,7 @@
 #include <list>
 #include <map>
 #include <set>
+#include <stack>
 
 #include <iostream>
 #include <sstream>

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,13 +39,13 @@
 //  for easier access
 /*	BoxObstacle* o = new BoxObstacle(25,50,25);
 	o->setSeenFrom(AbstractObstacle::inside);
-	o->setPosition(Vec3(-40.0f,-10.0f, 0.0f));
+	o->setPosition(Vector3(-40.0f,-10.0f, 0.0f));
 	o->setForward(0,0,-1);
 	addObstacle(o);
 
 	o = new BoxObstacle(2,50,2);
 	o->setSeenFrom(AbstractObstacle::outside);
-	o->setPosition(Vec3(-31.5f,-10.0f, -3.5f));
+	o->setPosition(Vector3(-31.5f,-10.0f, -3.5f));
 	o->setForward(0,0,-1);
 	addObstacle(o); */
 
@@ -96,16 +96,13 @@
     // Dadurch ist ungefaehr der Umriss gesichert!
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
-    Vec3 _pos = vehicle.position();
-    Vec3 _futPos = vehicle.forward() * vehicle.speed() * 3 + _pos;
+    Vector3 pos = vehicle.position();
+    Vector3 futPos = vehicle.forward() * vehicle.speed() * 3 + pos;
 
 
-    if( _pos == _futPos )
+    if (pos == futPos)
         return;
 
-    Ogre::Vector3 pos (_pos.x, _pos.y, _pos.z);
-    Ogre::Vector3 futPos (_futPos.x, _futPos.y, _futPos.z);
-
     // zur Hilfe bei der Berechnung
     Ogre::Vector3 velocityNorm(futPos - pos);
     velocityNorm.normalise(); // normalisierte geschwindigkeit (Richtung!)
@@ -142,18 +139,18 @@
             // so wir ham ne normale und machen uns nen Y
             if( vehicle.radius() == 0 )
                 continue;
-            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
-            castPos = pos + Vector3(offset.x, offset.y, offset.z);
-            castFutPos = futPos + Vector3(offset.x, offset.y, offset.z);
+            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            castPos = pos + offset;
+            castFutPos = futPos + offset;
         }
         else if( raycastType == LEFT )
         {
             // wie bei right ...
             if( vehicle.radius() == 0 )
                 continue;
-            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
-            castPos = pos - Vector3(offset.x, offset.y, offset.z);
-            castFutPos = futPos - Vector3(offset.x, offset.y, offset.z);
+            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            castPos = pos - offset;
+            castFutPos = futPos - offset;
         }
         else
         {
@@ -215,8 +212,8 @@
         vehicle.position() + (vehicle.forward() * pi.distance);
 
         // Die normale muss zu uns zeigen! koennte aber auch in die entgegengesetzte Richtung sein!
-        pi.surfaceNormal = Vec3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
-/*        pi.surfaceNormal.normalize();
+        pi.surfaceNormal = Vector3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
+/*        pi.surfaceNormal.normalisedCopy();
         // jedenfalls gilt dafuer, dass der abstand zwischen surfacePoint+surfaceNormal und _pos minimal sein muss
         if( ((pi.surfacePoint + pi.surfaceNormal) - _pos).length() >
             ((pi.surfacePoint - pi.surfaceNormal) - _pos).length() )

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -32,24 +32,22 @@
 
 namespace rl {
 
-SteeringVehicle::SteeringVehicle(Agent* parent)
+SteeringVehicle::SteeringVehicle(Creature* creature)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       mSpeed(1.0f),
 	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-	  mParent(parent),
-	  mCreature(NULL),
+	  mCreature(creature),
       mController(NULL),
       mDebugSteer(Vector3::ZERO),
       mDebugWander(Vector3::ZERO),
       mDebugAvoidObstacles(Vector3::ZERO)
 {
-    mCreature = parent->getControlledCreature();
-
 	initialize();
-    mController = CreatureControllerManager::getSingleton().getCreatureController(mCreature);
+    mController = CreatureControllerManager::getSingleton().getCreatureController(
+        mCreature);
 }
 
 SteeringVehicle::~SteeringVehicle(void)
@@ -58,16 +56,16 @@
 
 void SteeringVehicle::resetLocalSpace()
 {
-	setForward(Vec3(mForwardVector.x, mForwardVector.y, mForwardVector.z));
+	setForward(mForwardVector);
 	setSide(localRotateForwardToSide(forward()));
-	setUp(OpenSteer::Vec3(0, 1, 0));
+    setUp(Vector3::UNIT_Y);
 	Vector3 pos = mCreature->getActor()->getPosition();
-	setPosition(Vec3(pos.x, pos.y, pos.z));
+	setPosition(pos);
 	Vector3 src = mCreature->getActor()->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
 
     // regenerate local space (by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF ( Vec3(src.x, src.y, src.z) );
+	regenerateOrthonormalBasisUF ( src );
 }
 
 void SteeringVehicle::initialize(void)
@@ -76,7 +74,7 @@
 	resetLocalSpace();
 	
     // reset SteerLibraryMixin state
-	SimpleVehicle_2::reset ();
+	SimpleVehicle_2::reset();
 
 	setMaxForce (1.0f);   // steering force is clipped to this magnitude
 	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
@@ -97,7 +95,7 @@
     Vector3 position;
 	Quaternion orientation;
 	body->getPositionOrientation(position, orientation);
-	setPosition(Vec3(position.x, position.y, position.z));
+	setPosition(position);
 
     //  Get the velocity vector
 	mCurrentVelocity = body->getVelocity();
@@ -105,14 +103,14 @@
 	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
 	//  update speed
 	setSpeed(mCurrentVelocity.length());
-	Vec3 newVelocity(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);
+	Vector3 newVelocity(mCurrentVelocity);
 
     //  regenerate local space (by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
     orientation = Quaternion(mController->getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
-    regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
+    regenerateOrthonormalBasisUF(newUnitForward);
 
     // end of inserting from playervehicle
 
@@ -170,26 +168,23 @@
 
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
-	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
+	Vector3 steering = mForwardVector;
 	
-    rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
+    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
 
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
     mDebugWander = steering;
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcSeek(const Vector3& target)
 {
-	Vec3 rVal = steerForSeek(Vec3(target.x, target.y, target.z)).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcFlee(const Vector3& target)
 {
-	Vec3 rVal = steerForFlee(Vec3(target.x, target.y, target.z)).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
 	return steering;
 }
 
@@ -203,7 +198,7 @@
     /// Just returning a direction vector on the xz-plane
     /// towards the other agent.
     Vector3 dir = agent->getControlledCreature()->getPosition() -
-        mParent->getControlledCreature()->getPosition();
+        mCreature->getPosition();
     dir.y = 0;
 	return dir;
 }
@@ -211,16 +206,15 @@
 Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
 {
     ObstacleGroup obstacles = getObstacles();
-	Vec3 rVal = steerToAvoidObstacles(minTimeToCollision, obstacles).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
     mDebugAvoidObstacles = steering;
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
 {
-	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
-	return Vector3(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors()));
+	return steering;
 }
 		
 Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
@@ -232,7 +226,7 @@
 {
     Vector3 target = agent->getControlledCreature()->getPosition();
 	//target.y = position.y;
-	return (SimpleVehicle_2::isAhead(Vec3(target.x, target.y, target.z), threshold));
+	return SimpleVehicle_2::isAhead(target, threshold);
 }
 
 bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
@@ -268,7 +262,7 @@
 
 Vector3 SteeringVehicle::getPosition()
 {
-	return Vector3(position().x, position().y, position().z);
+	return position();
 }
 
 float SteeringVehicle::mass (void) const 
@@ -350,17 +344,17 @@
 	return AiSubsystem::getSingleton().getWorld()->getSteeringObstacles();
 }
 
-Vec3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
+Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
 {
 	//return position() + (velocity() * predictionTime);
 	return velocity() * predictionTime;
 }
 
-Vec3 SteeringVehicle::adjustRawSteeringForce(const Vec3& force)
+Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3& force)
 {
     const float maxAdjustedSpeed = 0.2f * maxSpeed ();
 
-    if ((speed () > maxAdjustedSpeed) || (force == Vec3::zero))
+    if ((speed () > maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-12 21:30:22 UTC (rev 3684)
@@ -29,30 +29,18 @@
 	class SteeringVehicle
 	{
 	public:
-		SteeringVehicle(rl::Agent* agent);
-		
+        SteeringVehicle(rl::Creature* creature);
 		void addForce(const Ogre::Vector3& force);
-
 		Ogre::Vector3 calcWander(const float elapsedTime);
-
 		Ogre::Vector3 calcSeek(const Ogre::Vector3& target);
-
 		Ogre::Vector3 calcFlee(const Ogre::Vector3& target);
-		
 		Ogre::Vector3 calcPursuit(rl::Agent* agent);
-
 		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
-
 		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
-		
 		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
-		
 		float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2);
-		
 		Ogre::Vector3 getPosition();
-		
 		bool isAhead(rl::Agent* agent, const float threshold);
-		
 		bool needAvoidance(const float minTimeToCollision);
 	};
 	



From blakharaz at mail.berlios.de  Sun Aug 12 23:53:15 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 12 Aug 2007 23:53:15 +0200
Subject: [Dsa-hl-svn] r3685 - in rl/trunk/engine: ai ai/include ai/src
	rules/include rules/src
Message-ID: <200708122153.l7CLrFZJ006913@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-12 23:53:07 +0200 (Sun, 12 Aug 2007)
New Revision: 3685

Added:
   rl/trunk/engine/ai/include/AgentDialogState.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentState.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentSteeringState.cpp
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
Log:
* Let Agent inherit SteeringVehicle
* add AgentDialogState

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-12 21:53:07 UTC (rev 3685)
@@ -303,6 +303,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\AgentDialogState.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\AgentManager.cpp"
 				>
 			</File>
@@ -413,6 +417,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\AgentDialogState.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\AgentManager.h"
 				>
 			</File>

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/include/Agent.h	2007-08-12 21:53:07 UTC (rev 3685)
@@ -18,12 +18,13 @@
 
 #include "AgentManager.h"
 #include "AgentState.h"
+#include "SteeringMachine.h"
+#include "SteeringVehicle.h"
 
-#include <stack>
-
 namespace rl
 {
 	class Actor;
+    class AgentSteeringState;
 	class Creature;
 
 	/** Represents a single entity that has got AI.
@@ -32,7 +33,7 @@
 	 * Creatures (rl::Creature), steering (pathfinding, movement - OpenSteer)
 	 * and decission making (behaviours)
 	 */
-	class _RlAiExport Agent 
+    class _RlAiExport Agent : public SteeringVehicle
 	{
 	public:
 		/** Constructor by Creature object.
@@ -58,6 +59,9 @@
 		 * the vehicle are updated.
 		 */
 		void update(const float elapsedTime);
+
+        void updateVehicle(const float currentTime, const float elapsedTime);
+
 		/** Adds a steering behaviour to the internal steering machine.
 		 * @param behaviour SteeringBehaviour is initialized and registered to mBehaviour.
 		 */
@@ -74,8 +78,6 @@
 
 	protected:
         typedef std::deque<AgentState*> AgentStateStack;
-		//! stores the creature whose AI is simulated
-		Creature* mCreature;
         std::stack<AgentState*> mAgentStates;
 	};
 }

Added: rl/trunk/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentDialogState.h	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/include/AgentDialogState.h	2007-08-12 21:53:07 UTC (rev 3685)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RlAI_AgentDialogState_H__
+#define __RlAI_AgentDialogState_H__
+
+#include "AgentState.h"
+
+namespace rl
+{
+
+    class AgentDialogState :
+        public AgentState
+    {
+    public:
+        AgentDialogState(Agent* agent);
+        ~AgentDialogState();
+
+        virtual void update(const Ogre::Real elapsedTime);
+        void setPlayer(Agent* player);
+
+    private:
+        Agent* mPlayer;
+        bool mTalking;
+    };
+
+}
+
+#endif // __RlAI_AgentDialogState_H__

Modified: rl/trunk/engine/ai/include/AgentState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentState.h	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/include/AgentState.h	2007-08-12 21:53:07 UTC (rev 3685)
@@ -40,7 +40,7 @@
 		 * Decision making is done here.
          * @param elapsedTime time since last update call.
 		 */
-		virtual void update(const float elapsedTime) = 0;
+        virtual void update(const Ogre::Real elapsedTime) = 0;
 
         Agent* getAgent() const { return mAgent; }
 

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-12 21:53:07 UTC (rev 3685)
@@ -19,6 +19,7 @@
 
 #include "Actor.h"
 #include "AgentCombatState.h"
+#include "AgentDialogState.h"
 #include "AgentSteeringState.h"
 #include "Creature.h"
 #include "DialogCharacter.h"
@@ -33,7 +34,7 @@
 namespace rl {
 
 Agent::Agent(Creature* character)
-	: mCreature(character),
+	: SteeringVehicle(character),
       mAgentStates()
 {
 	initialize();
@@ -65,6 +66,11 @@
     }
 }
 
+//void Agent::updateVehicle(const float currentTime, const float elapsedTime)
+//{
+//    SteeringVehicle::update(currentTime, elapsedTime);
+//}
+
 Creature* Agent::getControlledCreature() const
 {
     return mCreature;
@@ -83,6 +89,7 @@
     }
     else if (stateType == AST_DIALOG)
     {
+        state = new AgentDialogState(this);
     }
     else
     {
@@ -94,7 +101,9 @@
 
 void Agent::popState()
 {
+    AgentState* cur = mAgentStates.top();
     mAgentStates.pop();
+    delete cur;
 }
 
 AgentState* Agent::getCurrentState() const
@@ -109,4 +118,9 @@
     }
 }
 
+void Agent::updateVehicle(const float currentTime, const float elapsedTime)
+{
+    SteeringVehicle::update(currentTime, elapsedTime);
 }
+
+}
\ No newline at end of file

Added: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-12 21:53:07 UTC (rev 3685)
@@ -0,0 +1,69 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h"
+#include "AgentDialogState.h"
+
+#include "Agent.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    AgentDialogState::AgentDialogState(Agent* agent)
+        : AgentState(agent),
+        mPlayer(NULL),
+        mTalking(false)
+    {
+    }
+
+    AgentDialogState::~AgentDialogState()
+    {
+    }
+
+    void AgentDialogState::setPlayer(Agent* player)
+    {
+        mPlayer = player;
+    }
+
+    void AgentDialogState::update(const Ogre::Real elapsedTime)
+    {
+        static CreatureController* ctrl = 
+                CreatureControllerManager::getSingleton().getCreatureController(
+                    mAgent->getControlledCreature());
+
+        if (!mAgent->isAhead(mPlayer, 0.95)) //getController().calcDistance(@mPlayer.getVehicle().getPosition(), getController().getPosition()) > 2.5)
+        {		
+            ctrl->setMovement(
+                CreatureController::MT_DREHEN, 
+                Vector3::ZERO, 
+                mPlayer->getControlledCreature()->getPosition());
+        }
+		else
+        {
+			if (!mTalking)
+            {
+                ctrl->setMovement(CreatureController::MT_NONE, Vector3::ZERO, Vector3::ZERO);
+				ctrl->setAnimation("reden");
+				mTalking = true;
+            }			
+        }
+    }
+} // namespace rl

Modified: rl/trunk/engine/ai/src/AgentSteeringState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-12 21:53:07 UTC (rev 3685)
@@ -23,31 +23,25 @@
 
 namespace rl {
 
+
     AgentSteeringState::AgentSteeringState(Agent* agent)
         : AgentState(agent),
-        mBehaviour(NULL),
-        mVehicle(NULL)
+        mBehaviour(NULL)
     {
-        mVehicle = new SteeringVehicle(agent);
-
+        mBehaviour = new SteeringMachine(NULL, mAgent);
         LOG_MESSAGE(Logger::AI, 
-            "created SteeringVehicle for Agent");
-
-        mBehaviour = new SteeringMachine(NULL, mVehicle);
-        LOG_MESSAGE(Logger::AI, 
             "created SteeringMachine for Agent");
     }
 
     AgentSteeringState::~AgentSteeringState(void)
     {
-        delete mVehicle;
         delete mBehaviour;
     }
 
     void AgentSteeringState::addSteeringBehaviour(SteeringBehaviour* behaviour)
     {
         behaviour->setParent(mBehaviour);
-        behaviour->setController(mVehicle);
+        behaviour->setController(mAgent);
         mBehaviour->addState(behaviour);
         LOG_MESSAGE(Logger::AI, 
             "added SteeringBehaviour for Agent");
@@ -64,12 +58,12 @@
     {
         mBehaviour->update(elapsedTime);
         //  currentTime not needed yet, only elapsedTime
-        mVehicle->update(0.0f, elapsedTime);
+        mAgent->updateVehicle(0.0f, elapsedTime);
     }
 
     SteeringVehicle* AgentSteeringState::getVehicle()
     {
-        return mVehicle;
+        return mAgent;
     }
 
 }

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-12 21:53:07 UTC (rev 3685)
@@ -108,6 +108,7 @@
 
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_AI;
+            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
 			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
             static const Ogre::String PROPERTY_CURRENT_LE;
             static const Ogre::String PROPERTY_CURRENT_AE;

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-12 21:30:22 UTC (rev 3684)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-12 21:53:07 UTC (rev 3685)
@@ -41,6 +41,7 @@
     const Ogre::String Creature::CLASS_NAME = "Creature";
 
     const Ogre::String Creature::PROPERTY_AI = "ai";
+    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = "behaviours";
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
     const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
     const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";



From blakharaz at mail.berlios.de  Sun Aug 12 23:58:33 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 12 Aug 2007 23:58:33 +0200
Subject: [Dsa-hl-svn] r3686 - in rl/trunk/engine/ui: include src
Message-ID: <200708122158.l7CLwX6e007208@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-12 23:58:23 +0200 (Sun, 12 Aug 2007)
New Revision: 3686

Modified:
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
Log:
Moved inventory drag container events to the drag container classes

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-12 21:58:23 UTC (rev 3686)
@@ -45,7 +45,8 @@
 		Inventory* mInventory;
         std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
 		CEGUI::Window* mWorldBackground;
-		DndContainerMap mDragContainers;
+		DndContainerMap mWorldDragContainers;
+		DndContainerMap mSlotDragContainers;
 		RaySelector* mMouseSelector;
 
 		void createSlotWindows(Inventory* inventory);
@@ -54,8 +55,6 @@
 		ItemDragContainer* createItemDragContainer(Item* item, bool showdescription, const CeGuiString& containerName = "");
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
-		bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
-		bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
 		bool handleKeys(const CEGUI::EventArgs& evt, bool down);
 		bool destroyDragContainer(ItemDragContainer* cont);

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2007-08-12 21:58:23 UTC (rev 3686)
@@ -32,7 +32,7 @@
 	public:
 		static const Ogre::String ICON_UNKNOWN_ITEM;
 		
-		~ItemDragContainer();
+		virtual ~ItemDragContainer();
 		
 		void setItemParent(Container* container);
 		void setItemParent(Inventory* inventory, const CeGuiString& slotname);
@@ -42,6 +42,9 @@
 		Item* getItem() const;
 		CEGUI::Window* getContentWindow() const;
 	
+		bool _handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
+		bool _handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
+
 	protected:
 		CEGUI::Window* mContentWindow;
 		

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-12 21:58:23 UTC (rev 3686)
@@ -25,6 +25,7 @@
 #include "Actor.h"
 #include "ActorManager.h"
 #include "CameraObject.h"
+#include "Container.h"
 #include "Creature.h"
 #include "Inventory.h"
 #include "Item.h"
@@ -32,7 +33,6 @@
 #include "ItemIconDragContainer.h"
 #include "Selector.h"
 #include "WindowFactory.h"
-#include "Container.h"
 
 using namespace CEGUI;
 using namespace Ogre;
@@ -148,11 +148,13 @@
 	{
 		CeGuiString dragContainerName =
 			mWindow->getName() +  "/item/"
-			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
+			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer"+
+			(showdescription?"_D":"_I");
 		ItemDragContainer* itemhandler = NULL;
 
-		DndContainerMap::iterator it = mDragContainers.find(dragContainerName);
-		if (it != mDragContainers.end())
+		DndContainerMap::iterator itW = mWorldDragContainers.find(dragContainerName);
+		DndContainerMap::iterator itS = mSlotDragContainers.find(dragContainerName);
+		if (itW != mWorldDragContainers.end() || itS != mSlotDragContainers.end())
 		{
 			//itemhandler = it->second;
 			return NULL; ///@todo just a test
@@ -167,21 +169,21 @@
 			if (slotName != "")
 			{
 				itemhandler->setItemParent(mInventory, slotName);
+				mSlotDragContainers[dragContainerName] = itemhandler;
 			}
+			else
+			{
+				mWorldDragContainers[dragContainerName] = itemhandler;
+			}
 
-			Window* itemWindow = itemhandler->getContentWindow();
+			//Window* itemWindow = itemhandler->getContentWindow();
 
-			itemWindow->subscribeEvent(
-				Window::EventMouseClick,
-				boost::bind(&InventoryWindow::handleItemMouseClick, this, _1, item));
+			//itemWindow->subscribeEvent(
+			//	Window::EventMouseLeaves,
+			//	boost::bind(&InventoryWindow::destroyDragContainer, this, itemhandler));
 
-			itemWindow->subscribeEvent(
-				Window::EventMouseDoubleClick,
-				boost::bind(&InventoryWindow::handleItemDoubleClick, this, _1, item));
-
+			itemhandler->setRiseOnClickEnabled(true);
 			itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-
-			mDragContainers[dragContainerName] = itemhandler;
 		}
 
 		return itemhandler;
@@ -203,25 +205,33 @@
 				if (dragcont->getItemParentContainer() != NULL)
 				{
 					dragcont->getItemParentContainer()->removeItem(item);
+					dragcont->getParent()->removeChildWindow(dragcont);
 					///@todo Swap with old content (if there is some)
 				}
 				else if (dragcont->getItemParentSlot() != "")
 				{
 					dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
+					dragcont->getParent()->removeChildWindow(dragcont);
 					///@todo Swap with old content (if there is some)
 				}
+
+				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
+
+				if (newCont)
+				{
+					destroyDragContainer(dragcont);
+				}
 				else
 				{
-					dragcont->removeEvent(Window::EventMouseLeaves);
-					mDragContainers.erase(dragcont->getName());
+					newCont = dragcont;
 				}
 
 				mInventory->hold(item, targetSlot);
-				dragcont->getParent()->removeChildWindow(dragcont);
-				mSlotWindows[targetSlot]->addChildWindow(dragcont);
-				dragcont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-				dragcont->setItemParent(mInventory, targetSlot);
 
+				mSlotWindows[targetSlot]->addChildWindow(newCont);
+				newCont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+				newCont->setItemParent(mInventory, targetSlot);
+
 				return true;
 			}
 			else
@@ -246,30 +256,12 @@
 				dragcont->getPixelRect().d_top / getRoot()->getPixelSize().d_height,
 				-1);
 
-			if (dragcont->getItemParentContainer() != NULL)
-			{
-				dragcont->getItemParentContainer()->removeItem(item);
-				dragcont->getParent()->removeChildWindow(dragcont);
-				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont->getContentWindow());
-				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
-			}
-			else if (dragcont->getItemParentSlot() != "")
-			{
-				dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
+			destroyDragContainer(dragcont);
 
-				dragcont->getParent()->removeChildWindow(dragcont);
-				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont->getContentWindow());
-				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
-			}
-			else
-			{
-				destroyDragContainer(dragcont);
-			}
-
 			Ogre::Vector3 targetPosWorldSpace =
 				mInventory->getOwner()->getPosition()
 				+ mInventory->getOwner()->getOrientation()
-				* targetPosWindow; ///@todo check why coordinates are negative
+				* targetPosWindow; 
 			item->placeIntoScene();
 			item->setPosition(targetPosWorldSpace);
 
@@ -328,10 +320,6 @@
 							UDim((aabb.top+aabb.bottom)/2.0, 0));
 					posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 					cont->setPosition(posCont);
-
-					cont->subscribeEvent(
-						Window::EventMouseLeaves,
-						boost::bind(&InventoryWindow::destroyDragContainer, this, cont));
 				}
 			}
 		}
@@ -341,34 +329,6 @@
 		return true;
 	}
 
-	bool InventoryWindow::handleItemMouseClick(const EventArgs& evt, Item* item)
-	{
-		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
-		if (mevt.button == RightButton)
-		{
-			WindowFactory::getSingleton().showActionChoice(item);
-			return true;
-		}
-		else
-		{
-			return false;
-		}
-	}
-
-	bool InventoryWindow::handleItemDoubleClick(const EventArgs& evt, Item* item)
-	{
-		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
-		if (mevt.button == LeftButton)
-		{
-			item->doDefaultAction(mInventory->getOwner(), NULL);
-			return true;
-		}
-		else
-		{
-			return false;
-		}
-	}
-
 	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &evt, bool down)
 	{
 		const KeyEventArgs& kevt = static_cast<const KeyEventArgs&>(evt);
@@ -403,18 +363,14 @@
 							UDim((aabb.top+aabb.bottom)/2.0, 0));
 						posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 						cont->setPosition(posCont);
-
-						cont->subscribeEvent(
-							Window::EventMouseLeaves,
-							boost::bind(&InventoryWindow::destroyDragContainer, this, cont));
 					}
 				}
 			}
 			else
 			{
-				while (!mDragContainers.empty())
+				while (!mWorldDragContainers.empty())
 				{
-					destroyDragContainer(mDragContainers.begin()->second);
+					destroyDragContainer(mWorldDragContainers.begin()->second);
 				}
 			}
 
@@ -426,11 +382,16 @@
 
 	bool InventoryWindow::destroyDragContainer(rl::ItemDragContainer* cont)
 	{
+		cont->hide();
 		cont->removeAllEvents();
-		mWorldBackground->removeChildWindow(cont);
-		mDragContainers.erase(cont->getName());
+		if (cont->getParent())
+		{
+			cont->getParent()->removeChildWindow(cont);
+		}
+		mWorldDragContainers.erase(cont->getName());
+		mSlotDragContainers.erase(cont->getName());
 		CEGUI::WindowManager::getSingleton().destroyWindow(cont->getContentWindow());
-
+		
 		return true;
 	}
 

Modified: rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-08-12 21:58:23 UTC (rev 3686)
@@ -17,6 +17,8 @@
 
 #include "ItemDescriptionDragContainer.h"
 
+#include <boost/bind.hpp>
+
 #include "AbstractWindow.h"
 #include "Item.h"
 
@@ -35,15 +37,23 @@
 		mContentWindow = AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
 
 		mContentWindow->getChild(
-			mContentWindow->getName()+"/Icon")
+			name+"ItemDescriptionDragContainer/Icon")
 			->setProperty("Image", icon);
 		mContentWindow->getChild(
-			mContentWindow->getName()+"/Name")
+			name+"ItemDescriptionDragContainer/Name")
 			->setText(item->getName());
 		mContentWindow->getChild(
-			mContentWindow->getName()+"/Description")
+			name+"ItemDescriptionDragContainer/Description")
 			->setText(item->getDescription());
 
+		mContentWindow->subscribeEvent(
+			Window::EventMouseClick,
+			boost::bind(&ItemDragContainer::_handleItemMouseClick, this, _1, item));
+
+		mContentWindow->subscribeEvent(
+			Window::EventMouseDoubleClick,
+			boost::bind(&ItemDragContainer::_handleItemDoubleClick, this, _1, item));
+
 		setSize(mContentWindow->getSize());
 		addChildWindow(mContentWindow);
 	}

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-12 21:58:23 UTC (rev 3686)
@@ -20,7 +20,9 @@
 #include <CEGUIWindowManager.h>
 
 #include "AbstractWindow.h"
+#include "Inventory.h"
 #include "Item.h"
+#include "WindowFactory.h"
 
 namespace rl {
 	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
@@ -86,4 +88,34 @@
 	{
 		return mContentWindow;
 	}
+
+	bool ItemDragContainer::_handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item)
+	{
+		const CEGUI::MouseEventArgs& mevt = static_cast<const CEGUI::MouseEventArgs&>(evt);
+		if (mevt.button == CEGUI::RightButton)
+		{
+			WindowFactory::getSingleton().showActionChoice(item);
+			return true;
+		}
+		else
+		{
+			return false;
+		}
+	}
+
+	bool ItemDragContainer::_handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item)
+	{
+		const CEGUI::MouseEventArgs& mevt = static_cast<const CEGUI::MouseEventArgs&>(evt);
+		if (mevt.button == CEGUI::LeftButton)
+		{
+			item->doDefaultAction(mInventory->getOwner(), NULL);
+			return true;
+		}
+		else
+		{
+			return false;
+		}
+	}
+
+
 }

Modified: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-08-12 21:53:07 UTC (rev 3685)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-08-12 21:58:23 UTC (rev 3686)
@@ -17,6 +17,8 @@
 
 #include "ItemIconDragContainer.h"
 
+#include <boost/bind.hpp>
+
 #include "AbstractWindow.h"
 #include "Item.h"
 
@@ -33,9 +35,23 @@
 
 		CeGuiString prefix = name;
 		mContentWindow = AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
-		mContentWindow->getChild(mContentWindow->getName()+"/Icon")
+
+		for (size_t idx = 0; idx < mContentWindow->getChildCount(); ++idx)
+		{
+			LOG_MESSAGE(Logger::UI, mContentWindow->getChildAtIdx(idx)->getName());
+		}
+
+		mContentWindow->getChild(name+"ItemIconDragContainer/Icon")
 			->setProperty("Image", icon);
 
+		mContentWindow->subscribeEvent(
+			Window::EventMouseClick,
+			boost::bind(&ItemDragContainer::_handleItemMouseClick, this, _1, item));
+
+		mContentWindow->subscribeEvent(
+			Window::EventMouseDoubleClick,
+			boost::bind(&ItemDragContainer::_handleItemDoubleClick, this, _1, item));
+
 		setSize(CEGUI::UVector2(
 			cegui_absdim(item->getSize().first*30),
 			cegui_absdim(item->getSize().second*30)));



From blakharaz at mail.berlios.de  Sun Aug 12 23:59:03 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 12 Aug 2007 23:59:03 +0200
Subject: [Dsa-hl-svn] r3687 - rl/trunk/engine/ui/src
Message-ID: <200708122159.l7CLx3EM007232@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-12 23:59:01 +0200 (Sun, 12 Aug 2007)
New Revision: 3687

Modified:
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Fix possible bad pointer

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-12 21:58:23 UTC (rev 3686)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-12 21:59:01 UTC (rev 3687)
@@ -82,7 +82,6 @@
         mShownObject(NULL),
         mObjectDescriptionWindow(NULL),
         mMainMenuWindow(NULL),
-        mCloseConfirmationWindow(NULL),
         mGameSettings(NULL),
         mCombatWindow(NULL)
     {
@@ -127,7 +126,6 @@
         delete mDebugWindow;
         delete mConsole;
         delete mMainMenuWindow;
-        delete mCloseConfirmationWindow;
         delete mGameSettings;
         delete mCombatWindow;
     }
@@ -293,12 +291,9 @@
 
     void WindowFactory::showExitConfirmation()
     {
-        if( mCloseConfirmationWindow != NULL )
-            delete mCloseConfirmationWindow;
-
-        mCloseConfirmationWindow = new CloseConfirmationWindow();
+        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
         LOG_MESSAGE2(Logger::UI, "Start", "UiSubsystem::requestExit");
-        mCloseConfirmationWindow->setVisible(true);
+        closeConfirmationWindow->setVisible(true);
     }
 
     void WindowFactory::writeToConsole(Ogre::String text)



From blakharaz at mail.berlios.de  Mon Aug 13 00:02:34 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 13 Aug 2007 00:02:34 +0200
Subject: [Dsa-hl-svn] r3688 - rl/trunk/engine/common/src
Message-ID: <200708122202.l7CM2YDV007554@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-13 00:02:31 +0200 (Mon, 13 Aug 2007)
New Revision: 3688

Modified:
   rl/trunk/engine/common/src/XmlHelper.cpp
Log:
Added a bit more information to failed assertions

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-12 21:59:01 UTC (rev 3687)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-12 22:02:31 UTC (rev 3688)
@@ -14,7 +14,7 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-#include "stdinc.h" //precompiled header
+#include "stdinc.h" //precompiled header
 
 #include <xercesc/dom/DOM.hpp>
 
@@ -40,8 +40,7 @@
 
 DOMElement* XmlHelper::getChildNamed(DOMElement* parent, const char* const name)
 {
-	if( parent == NULL )
-		Throw( NullPointerException, "parent darf nicht NULL sein" );
+    RlAssert(parent != NULL, "XmlHelper::getChildNamed: parent must not be NULL" );
 
 	AutoXMLCh nameXml = name;
 
@@ -62,19 +61,19 @@
 
 CeGuiString XmlHelper::getValueAsString(DOMElement* element)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getValueAsString: Element must not be NULL");
 	return transcodeToString( element->getFirstChild()->getNodeValue() );
 }
 
 utf8* XmlHelper::getValueAsUtf8(DOMElement* element)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getValueAsUtf8: Element must not be NULL");
 	return XmlHelper::transcodeToUtf8(element->getFirstChild()->getNodeValue());
 }
 
 bool XmlHelper::hasAttribute(DOMElement* element,const char* const name)
 {
-    RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::hasAttribute: Element must not be NULL");
     XMLCh* attrName = XMLString::transcode(name);
     bool rVal = element->hasAttribute(attrName);
     XMLString::release(&attrName);
@@ -83,7 +82,7 @@
 
 bool XmlHelper::hasNodeName(DOMNode* node, const char* const name)
 {
-    RlAssert(node != NULL, "node must not be NULL");
+    RlAssert(node != NULL, "XmlHelper::hasNodeName: node must not be NULL");
     XMLCh* nodeName = XMLString::transcode(name);
     int ival = XMLString::compareString(node->getNodeName(), nodeName);
     bool rVal = (0 == ival);
@@ -93,7 +92,7 @@
 
 int XmlHelper::getAttributeValueAsInteger(DOMElement* element,const char* const name)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsInteger: Element must not be NULL");
 	XMLCh* attrName = XMLString::transcode(name);
 	const XMLCh* attribute = element->getAttribute(attrName);
 	int rVal = XMLString::parseInt(attribute);
@@ -103,7 +102,7 @@
 
 Ogre::Real XmlHelper::getAttributeValueAsReal(DOMElement* element,const char* const name)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsReal: Element must not be NULL");
 	XMLCh* attrName = XMLString::transcode(name);
 	Ogre::Real rVal = Ogre::StringConverter::parseReal(
 		transcodeToString(element->getAttribute(attrName)).c_str() );
@@ -113,7 +112,7 @@
 
 CeGuiString XmlHelper::getAttributeValueAsString(DOMElement* element, const char* const name)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsString: Element must not be NULL");
 	XMLCh* attrName = XMLString::transcode(name);
 	CeGuiString rVal(transcodeToString(element->getAttribute(attrName)));
 	XMLString::release(&attrName);
@@ -134,7 +133,7 @@
 
 std::string XmlHelper::getAttributeValueAsStdString(DOMElement* element, const char* const name)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsStdString: Element must not be NULL");
 	XMLCh* attrName = XMLString::transcode(name);
 	std::string rVal(transcodeToStdString(element->getAttribute(attrName)));
 	XMLString::release(&attrName);
@@ -143,7 +142,7 @@
 
 bool XmlHelper::getAttributeValueAsBool(DOMElement* element,const char* const name)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsBool: Element must not be NULL");
 	if( XMLString::compareIString(getAttributeValueAsString(element, name).c_str(),"true") == 0  )
 		return true;
 	else
@@ -152,13 +151,13 @@
 
 int XmlHelper::getValueAsInteger(DOMElement* element)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getValueAsInteger: Element must not be NULL");
 	return XMLString::parseInt(element->getFirstChild()->getNodeValue());
 }
 
 Ogre::Vector3 XmlHelper::getValueAsVector3(DOMElement* element)
 {
-	RlAssert(element != NULL, "Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getValueAsVector3: Element must not be NULL");
 	RlAssert(
 		hasAttribute(element, "x") 
 		&& hasAttribute(element, "y") 



From timm at mail.berlios.de  Mon Aug 13 18:45:43 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 13 Aug 2007 18:45:43 +0200
Subject: [Dsa-hl-svn] r3689 - rl/trunk/engine/script/swig
Message-ID: <200708131645.l7DGjhs1023812@sheep.berlios.de>

Author: timm
Date: 2007-08-13 18:45:34 +0200 (Mon, 13 Aug 2007)
New Revision: 3689

Modified:
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
Log:
added TimeSource and TimeSourceManager to swig

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-12 22:02:31 UTC (rev 3688)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-13 16:45:34 UTC (rev 3689)
@@ -63,6 +63,7 @@
 #include "SoundFadeJob.h"
 #include "SoundFadeFunctor.h"
 #include "LinearSoundFadeFunctor.h"
+#include "TimeSource.h"
 
 #undef message
 #undef send

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-08-12 22:02:31 UTC (rev 3688)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-08-13 16:45:34 UTC (rev 3689)
@@ -939,4 +939,32 @@
 };
 
 
+typedef RL_LONGLONG rl::Time;
+
+class TimeSource : public rl::GameTask
+{
+public:
+    typedef enum
+    {
+        REALTIME_CONTINUOUS,
+        REALTIME_INTERRUPTABLE,
+        GAMETIME
+    }  TimeSourceType;
+    
+    virtual rl::TimeSource::TimeSourceType getType() const = 0;
+
+    virtual rl::Time getClock() const = 0;
+    virtual void setClock(const rl::Time& time) = 0;
+    virtual void setTimeFactor(Ogre::Real factor = 1.0) = 0;
+};
+
+class TimeSourceManager : public Ogre::Singleton<rl::TimeSourceManager>
+{
+public:
+    static rl::TimeSourceManager& getSingleton();
+    void registerTimeSource(rl::TimeSource* ts);
+    rl::TimeSource* getTimeSource(const rl::TimeSource::TimeSourceType& type) const;
+};
+
+
 }



From timm at mail.berlios.de  Mon Aug 13 18:46:10 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 13 Aug 2007 18:46:10 +0200
Subject: [Dsa-hl-svn] r3690 - modules/common/scripts
Message-ID: <200708131646.l7DGkAM5024738@sheep.berlios.de>

Author: timm
Date: 2007-08-13 18:46:07 +0200 (Mon, 13 Aug 2007)
New Revision: 3690

Modified:
   modules/common/scripts/questsound.rb
Log:
repaired questsound.rb

Modified: modules/common/scripts/questsound.rb
===================================================================
--- modules/common/scripts/questsound.rb	2007-08-13 16:45:34 UTC (rev 3689)
+++ modules/common/scripts/questsound.rb	2007-08-13 16:46:07 UTC (rev 3690)
@@ -27,7 +27,7 @@
 	end
     
 	def playSound()
-        now = $CORE.getClock()
+        now = TimeSourceManager.getSingleton().getTimeSource(TimeSource::GAMETIME).getClock()
         # only play sound, if we didn't play it in the last two seconds
         if (now - @lastPlayed) > 2000
             PlaySound2d("quest_aenderung_gekritzel_01.ogg")



From melven at mail.berlios.de  Mon Aug 13 19:24:03 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 13 Aug 2007 19:24:03 +0200
Subject: [Dsa-hl-svn] r3691 - rl/trunk/engine/rules/src
Message-ID: <200708131724.l7DHO3Y2019070@sheep.berlios.de>

Author: melven
Date: 2007-08-13 19:23:57 +0200 (Mon, 13 Aug 2007)
New Revision: 3691

Modified:
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
found bugs in some movements (no correct initialization of rotation-movement)

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-13 16:46:07 UTC (rev 3690)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-13 17:23:57 UTC (rev 3691)
@@ -423,7 +423,7 @@
         }
         virtual void activate()
         {
-            AbstractMovement::activate();
+            Gehen::activate();
             doTalentProbeIfNecessary();
         }
         virtual void doTalentProbeIfNecessary()
@@ -533,7 +533,7 @@
         }
         virtual void activate()
         {
-            AbstractMovement::activate();
+            Gehen::activate();
             doTalentProbeIfNecessary();
         }
         virtual void doTalentProbeIfNecessary()
@@ -690,7 +690,7 @@
         virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
         virtual void activate()
         {
-            AbstractMovement::activate();
+            Gehen::activate();
             mState = UPTODOWN;
             mMovingCreature->setAnimation("idle_zu_hocke",1,1,"Idle");
             mTimer = 0;



From melven at mail.berlios.de  Mon Aug 13 19:30:57 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 13 Aug 2007 19:30:57 +0200
Subject: [Dsa-hl-svn] r3692 - in rl/trunk/engine/ui: include src
Message-ID: <200708131730.l7DHUvph019544@sheep.berlios.de>

Author: melven
Date: 2007-08-13 19:30:50 +0200 (Mon, 13 Aug 2007)
New Revision: 3692

Modified:
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
-completed "VM_PNYX_MODE" (all movements supported, that are also supported by third-person-view
-fixed camera behaviour using stafe+forward

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-08-13 17:23:57 UTC (rev 3691)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-08-13 17:30:50 UTC (rev 3692)
@@ -107,6 +107,7 @@
         std::pair<Ogre::Real, Ogre::Real> mDistanceRange;
         Ogre::Degree mCamYaw; // f?r VM_FREE_CAMERA
         Ogre::Degree mCamVirtualYaw; // helps to simulate strafe+forward/backward movement
+        Ogre::Degree mNewCamVirtualYaw; // s.o.
         Ogre::Degree mPitch;
         Ogre::Degree mRoll;
         std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-13 17:23:57 UTC (rev 3691)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-13 17:30:50 UTC (rev 3692)
@@ -77,6 +77,7 @@
         mDistanceRange(0.60, 7.00),
         mCamYaw(0),
         mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
         mPitch(20),
         mRoll(0),
         mPitchRange(Degree(-75), Degree(85)),
@@ -326,22 +327,28 @@
                 if( mViewMode != VM_PNYX_MODE )
                 {
                     // virtual yaw
-                    Degree newVirtualYaw(0);
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
                     if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
                         ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
                     {
-                        newVirtualYaw = Degree(45);
+                        mNewCamVirtualYaw = Degree(45);
                     }
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
                         ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
                     {
-                        newVirtualYaw = Degree(-45);
+                        mNewCamVirtualYaw = Degree(-45);
                     }
-                    if( mCamVirtualYaw != newVirtualYaw )
+                    else
                     {
-                        rotation += mCamVirtualYaw - newVirtualYaw;
-                        mCamVirtualYaw = newVirtualYaw;
+                        mNewCamVirtualYaw =Degree(0);
                     }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
                 }
             }
 
@@ -464,16 +471,49 @@
                         break;
                     }
                     yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement & MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
                     mController->setMovement(
-                        CreatureController::MT_JOGGEN,
+                        type,
                         Vector3::NEGATIVE_UNIT_Z,
                         Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
                 }
                 else
                 {
                     // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement & MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
                     mController->setMovement(
-                        CreatureController::MT_STEHEN,
+                        type,
                         Vector3::ZERO,
                         Vector3::ZERO);
                 }
@@ -531,12 +571,12 @@
                 mCameraActor->getControlledObject());
             AxisAlignedBox aabb = ogreCam->getDefaultSize();
             // Radius berechnen
-            Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+            //Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
 
             cameraNode->lookAt(
                 charPos
-                + charOri * virtualCamOri *  mLookAtOffset
-                + charOri * virtualCamOri * (-Vector3::UNIT_Z*radius),
+                + charOri * virtualCamOri *  mLookAtOffset,
+                //+ charOri * virtualCamOri * (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
                 Node::TS_WORLD);
 
         }
@@ -855,7 +895,8 @@
         Vector3 targetCamPos;
 
         Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);   // is this ok, solves the problems, when strafe+move_forward...
         Quaternion virtualCamOri;
         virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
@@ -1206,6 +1247,8 @@
         Quaternion camOri;
         mCamBody->getPositionOrientation(camPos, camOri);
         mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
         if(mViewMode == VM_FIRST_PERSON)
             mCharacterActor->setVisible(false);
         else



From melven at mail.berlios.de  Mon Aug 13 22:16:46 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 13 Aug 2007 22:16:46 +0200
Subject: [Dsa-hl-svn] r3693 - in rl/trunk/engine/ui: include src
Message-ID: <200708132016.l7DKGkvv032125@sheep.berlios.de>

Author: melven
Date: 2007-08-13 22:16:36 +0200 (Mon, 13 Aug 2007)
New Revision: 3693

Modified:
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
CharacterSheetWindow and InventoryWindow can be closed without errors

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-08-13 17:30:50 UTC (rev 3692)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-08-13 20:16:36 UTC (rev 3693)
@@ -101,6 +101,7 @@
         void toggleCharacterStateWindow();
         void toggleInGameGlobalMenu();
         void toggleInventoryWindow();
+        void notifyInventoryWindowDestroyed();
 
         CombatWindow* getCombatWindow();
 

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-08-13 17:30:50 UTC (rev 3692)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-08-13 20:16:36 UTC (rev 3693)
@@ -51,7 +51,7 @@
 	mRasse = getWindow("CharacterSheet/CharacterSheet/Rasse");
 	mProfession = getWindow("CharacterSheet/CharacterSheet/Profession");
 
-	bindDestroyWindowToXButton();
+	bindHideWindowToXButton();
 
 	/*for (int i=0; i<EIGENSCHAFT_COUNT; i++)
 		mEigenschaft[i] =

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-13 17:30:50 UTC (rev 3692)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-13 20:16:36 UTC (rev 3693)
@@ -21,6 +21,7 @@
 #include <CEGUIImageset.h>
 #include <CEGUIImagesetManager.h>
 #include <CEGUIWindowManager.h>
+#include <elements/CEGUIFrameWindow.h>
 
 #include "Actor.h"
 #include "ActorManager.h"
@@ -49,6 +50,8 @@
 
         //mSquareSize = ...;
 		mWorldBackground = getWindow("InventoryWindow/Background");
+        getWindow("InventoryWindow")->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&InventoryWindow::destroyWindow, this));
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);
@@ -60,6 +63,7 @@
     {
 		mWorldBackground->removeAllEvents();
 		delete mMouseSelector;
+        WindowFactory::getSingleton().notifyInventoryWindowDestroyed();
     }
 
     void InventoryWindow::createSlotWindows(Inventory* inventory)

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-13 17:30:50 UTC (rev 3692)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-13 20:16:36 UTC (rev 3693)
@@ -210,7 +210,12 @@
         }
     }
 
+    void WindowFactory::notifyInventoryWindowDestroyed()
+    {
+        mInventoryWindow = NULL;
+    }
 
+
     void WindowFactory::showCharacterSheet()
     {
         if (mCharacterSheet->isVisible())



From melven at mail.berlios.de  Mon Aug 13 22:26:54 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 13 Aug 2007 22:26:54 +0200
Subject: [Dsa-hl-svn] r3694 - modules/common/gui/windows
Message-ID: <200708132026.l7DKQsNs032459@sheep.berlios.de>

Author: melven
Date: 2007-08-13 22:26:47 +0200 (Mon, 13 Aug 2007)
New Revision: 3694

Modified:
   modules/common/gui/windows/inventory_default.xml
Log:
we also need the worldbackground in inventory_default.xml

Modified: modules/common/gui/windows/inventory_default.xml
===================================================================
--- modules/common/gui/windows/inventory_default.xml	2007-08-13 20:16:36 UTC (rev 3693)
+++ modules/common/gui/windows/inventory_default.xml	2007-08-13 20:26:47 UTC (rev 3694)
@@ -1,101 +1,105 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
-		<Property Name="VerticalAlignment" Value="Centre" />
-		<Property Name="HorizontalAlignment" Value="Centre" />
-		<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
-		<Property Name="Text" Value="Inventar" />
+	<Window Type="DefaultWindow" Name="InventoryWindow/Background">
+		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}" />
+		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
 		
-		<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">
-			<Property Name="UnifiedPosition" Value="{{0,5},{0,5}}" />
-			<Property Name="UnifiedSize" Value="{{0,400},{0,540}}" />
+	    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
+			<Property Name="VerticalAlignment" Value="Centre" />
+			<Property Name="HorizontalAlignment" Value="Centre" />
+			<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
+			<Property Name="Text" Value="Inventar" />
 			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Head">
-				<Property Name="UnifiedPosition" Value="{{0.0,150},{0,40}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
+			<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">
+				<Property Name="UnifiedPosition" Value="{{0,5},{0,5}}" />
+				<Property Name="UnifiedSize" Value="{{0,400},{0,540}}" />
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Head">
+					<Property Name="UnifiedPosition" Value="{{0.0,150},{0,40}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Back">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,450}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Back">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,450}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Ring">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Ring">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Ring">
-				<Property Name="UnifiedPosition" Value="{{0,300},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Ring">
+					<Property Name="UnifiedPosition" Value="{{0,300},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>				
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Hand">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,80}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Hand">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,80}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Hand">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,80}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Armor">
+					<Property Name="UnifiedPosition" Value="{{0,135},{0,110}}" />
+					<Property Name="UnifiedSize" Value="{{0,90},{0,120}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Belt">
+					<Property Name="UnifiedPosition" Value="{{0,135},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,90},{0,30}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Trousers">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,90}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Boots">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,450}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Shinbone">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,380}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Necklace">
+					<Property Name="UnifiedPosition" Value="{{0,225},{0,70}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
+				
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletRight">
+					<Property Name="UnifiedPosition" Value="{{0,70},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
 			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Hand">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,80}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletLeft">
+					<Property Name="UnifiedPosition" Value="{{0,260},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Gloves">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,350}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Bracers">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
+				</Window>
+					
 			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Armor">
-				<Property Name="UnifiedPosition" Value="{{0,135},{0,110}}" />
-				<Property Name="UnifiedSize" Value="{{0,90},{0,120}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Belt">
-				<Property Name="UnifiedPosition" Value="{{0,135},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,90},{0,30}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Trousers">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,90}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Boots">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,450}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Shinbone">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,380}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Necklace">
-				<Property Name="UnifiedPosition" Value="{{0,225},{0,70}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-			
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletRight">
-				<Property Name="UnifiedPosition" Value="{{0,70},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-		
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletLeft">
-				<Property Name="UnifiedPosition" Value="{{0,260},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Gloves">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,350}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Bracers">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
-			</Window>
-
-				
 		</Window>
 	</Window>
 </GUILayout>



From pnyx at mail.berlios.de  Thu Aug 16 22:32:42 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 16 Aug 2007 22:32:42 +0200
Subject: [Dsa-hl-svn] r3695 - in modules/common: materials materials/model
	materials/programs materials/programs/Normalmapping models scripts
Message-ID: <200708162032.l7GKWgIo009849@sheep.berlios.de>

Author: pnyx
Date: 2007-08-16 22:18:12 +0200 (Thu, 16 Aug 2007)
New Revision: 3695

Added:
   modules/common/materials/model/lookup_skin.png
   modules/common/materials/model/men_eye_normal.png
   modules/common/materials/model/men_female_human_diffuse.png
   modules/common/materials/model/men_human_female_backpack_leather_01_normal.png
   modules/common/materials/model/men_human_female_hair_long_01_normal.png
   modules/common/materials/model/men_human_female_head_02_diffuse.png
   modules/common/materials/model/men_human_female_head_02_normal.png
   modules/common/materials/model/men_human_female_normalmap.png
   modules/common/materials/model/obj_Garetherplatte_diffuse.png
   modules/common/materials/model/obj_Garetherplatte_normal.png
   modules/common/materials/model/obj_Garetherplatte_spec.png
   modules/common/materials/model/obj_boots_01_normal.png
   modules/common/materials/model/obj_kroetenhaut_diffuse.png
   modules/common/materials/model/obj_kroetenhaut_normal.png
   modules/common/materials/model/obj_kroetenhaut_specular.png
   modules/common/materials/model/obj_pants_01_diffuse.png
   modules/common/materials/model/obj_pants_01_normal.png
   modules/common/materials/model/obj_shortsleeve02_normal.png
   modules/common/materials/model/obj_shortsleeve02_specular.png
   modules/common/materials/programs/Normalmapping/
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_PS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_PS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_mirrored_PS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV0_VS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV1_VS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV2_VS.hlsl
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_mirrored_PS.hlsl
   modules/common/materials/programs/Normalmapping/Eye_Normalmapping_PS.hlsl
   modules/common/materials/programs/Normalmapping/Eye_Normalmapping_VS.hlsl
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping_PS.hlsl
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping_mirrored_PS.hlsl
   modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program
Removed:
   modules/common/materials/model/men_human_female_hand.png
   modules/common/materials/model/obj_kroetenhaut.png
   modules/common/materials/model/obj_pants01.png
   modules/common/materials/model/obj_plattediffuse.png
   modules/common/materials/model/rl_mensch_female.png
Modified:
   modules/common/materials/men_human_female_armor_garethplatte.mesh.material
   modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
   modules/common/materials/men_human_female_backpack_leather_01.material
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/men_human_female_hand_nude.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/men_human_female_leg_pants01_long.mesh.material
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/model/men_human_female_hair_long_01_spec.png
   modules/common/materials/programs/NormalMap2Lights.hlsl
   modules/common/models/men_human_female.skeleton
   modules/common/models/men_human_female_armor_garethplatte.mesh
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_backpack_leather_01.mesh
   modules/common/models/men_human_female_backpack_leather_01_smalll.mesh
   modules/common/models/men_human_female_feet_boots_01.mesh
   modules/common/models/men_human_female_hair_long_01_normal.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_head_02.mesh
   modules/common/models/men_human_female_leg_pants_01_long.mesh
   modules/common/models/men_human_female_torso.mesh
   modules/common/scripts/moduleconfig.rb
Log:
* Added Normalmapping shaders (Spec, mirrored UV support, Skin, eyemovement etc.)
* Changed character materials to use these shaders
* Changed Meshes and Skeleton to support Lexi Exporter

Modified: modules/common/materials/men_human_female_armor_garethplatte.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,5 +1,7 @@
 
-material men_human_female_armor_garethplatte : Basic_Vertex_Shader
+material men_human_female_armor_garethplatte : Basic_Normalmapping_Spec
 {
-set_texture_alias diffuse obj_plattediffuse.png
+set_texture_alias DiffuseMap obj_Garetherplatte_diffuse.png
+set_texture_alias NormalMap obj_Garetherplatte_normal.png
+set_texture_alias SpecMap obj_Garetherplatte_spec.png
 }

Modified: modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,5 +1,7 @@
 
-material men_human_female_armor_kroetenhaut : Basic_Vertex_Shader
+material men_human_female_armor_kroetenhaut : Basic_Normalmapping_Spec_mirrored
 {
-set_texture_alias diffuse obj_kroetenhaut.png
+set_texture_alias DiffuseMap obj_kroetenhaut_diffuse.png
+set_texture_alias NormalMap obj_kroetenhaut_normal.png
+set_texture_alias SpecMap obj_kroetenhaut_specular.png
 }

Modified: modules/common/materials/men_human_female_backpack_leather_01.material
===================================================================
--- modules/common/materials/men_human_female_backpack_leather_01.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_backpack_leather_01.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,5 +1,6 @@
 
-material men_human_female_backpack_leather_01: Basic_Vertex_Shader
+material men_human_female_backpack_leather_01: Basic_Normalmapping
 {
-set_texture_alias diffuse men_human_female_backpack_leather_01_diffuse.png
+set_texture_alias DiffuseMap men_human_female_backpack_leather_01_diffuse.png
+set_texture_alias NormalMap men_human_female_backpack_leather_01_normal.png
 }

Modified: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,6 +1,7 @@
 
-material men_human_female_feet_boots_01 : Basic_Vertex_ShaderUV1
+material men_human_female_feet_boots_01 : Basic_Normalmapping_UV1_mirrored
 {
-set_texture_alias diffuse obj_boots01.png
-			//	tex_coord_set 1
+set_texture_alias DiffuseMap obj_boots01.png
+set_texture_alias NormalMap obj_boots_01_normal.png
+			//	tex_coord_set 1 obj_boots_01_normal.png
 }

Modified: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,6 +1,7 @@
 
-material men_human_female_hair_long_01_normal : Hair_Vertex_Shader
+material men_human_female_hair_long_01_normal : Basic_Normalmapping_Spec_Alpha
 {
-set_texture_alias diffuse men_human_female_hair_long_01.png
-set_texture_alias spec men_human_female_hair_long_01_spec.png
+set_texture_alias DiffuseMap men_human_female_hair_long_01.png
+set_texture_alias NormalMap men_human_female_hair_long_01_normal.png
+set_texture_alias SpecMap men_human_female_hair_long_01_spec.png
 }

Modified: modules/common/materials/men_human_female_hand_nude.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hand_nude.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_hand_nude.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,6 +1,8 @@
 
-material men_human_female_hand_nude : Skin_Vertex_Shader
+material men_human_female_hand_nude : Skin_Normalmapping
 {
-set_texture_alias diffuse rl_mensch_female.png
+set_texture_alias DiffuseMap men_female_human_diffuse.png
+set_texture_alias NormalMap men_human_female_normalmap.png
+set_texture_alias SpecMap men_female_human_diffuse.png
 
 }

Modified: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_head02.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,8 +1,16 @@
 
-material men_human_female_head_02 : Face_Vertex_Shader
+material men_human_female_head_02 : Face_Normalmapping_mirrored
 {
-set_texture_alias diffuse men_human_female_head02.png
-set_texture_alias eyeColor men_eye_blue.png
-set_texture_alias eyeShadow men_eyeshadow.png
+set_texture_alias DiffuseMap men_human_female_head_02_diffuse.png
+set_texture_alias NormalMap men_human_female_head_02_normal.png
+set_texture_alias SpecMap men_human_female_head_02_diffuse.png
 
+set_texture_alias EyeDiffuseMap men_eye_blue.png
+set_texture_alias EyeNormalMap men_eye_normal.png
+set_texture_alias EyeShadowMap men_eyeshadow.png
+
+
 }
+//set_texture_alias diffuse men_human_female_head02.png
+//set_texture_alias eyeColor men_eye_blue.png
+//set_texture_alias eyeShadow men_eyeshadow.png

Modified: modules/common/materials/men_human_female_leg_pants01_long.mesh.material
===================================================================
--- modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,6 +1,10 @@
 
-material men_human_female_legs_pants_01_long : Basic_Vertex_Shader
+material men_human_female_legs_pants_01_long : Basic_Normalmapping_Spec_mirrored
 {
-set_texture_alias diffuse obj_pants01.png
+set_texture_alias DiffuseMap obj_pants_01_diffuse.png
+set_texture_alias NormalMap obj_pants_01_normal.png
+set_texture_alias SpecMap obj_pants_01_diffuse.png
+}
+// set_texture_alias diffuse obj_pants01.png
 
-}
+

Modified: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/men_human_female_torso.mesh.material	2007-08-16 20:18:12 UTC (rev 3695)
@@ -1,5 +1,10 @@
-material men_human_female_torso : Torso_Vertex_Shader_Short
+material men_human_female_torso : Torso_Normalmapping_Short
 {
-	set_texture_alias skin rl_mensch_female.png
-	set_texture_alias cloth obj_shortsleeve02_diffuse.png
-}
+set_texture_alias DiffuseMapSkin men_female_human_diffuse.png
+set_texture_alias NormalMapSkin men_human_female_normalmap.png
+set_texture_alias SpecMapSkin men_female_human_diffuse.png
+
+set_texture_alias DiffuseMapCloth obj_shortsleeve02_diffuse.png
+set_texture_alias NormalMapCloth obj_shortsleeve02_normal.png
+set_texture_alias SpecMapCloth obj_shortsleeve02_specular.png
+}
\ No newline at end of file

Added: modules/common/materials/model/lookup_skin.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/lookup_skin.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_eye_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_eye_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_female_human_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_female_human_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_backpack_leather_01_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_backpack_leather_01_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_hair_long_01_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_hair_long_01_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/materials/model/men_human_female_hair_long_01_spec.png
===================================================================
(Binary files differ)

Deleted: modules/common/materials/model/men_human_female_hand.png
===================================================================
(Binary files differ)

Added: modules/common/materials/model/men_human_female_head_02_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_head_02_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_head_02_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_head_02_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_normalmap.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_normalmap.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_Garetherplatte_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_Garetherplatte_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_Garetherplatte_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_Garetherplatte_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_Garetherplatte_spec.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_Garetherplatte_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_boots_01_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_boots_01_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/materials/model/obj_kroetenhaut.png
===================================================================
(Binary files differ)

Copied: modules/common/materials/model/obj_kroetenhaut_diffuse.png (from rev 3694, modules/common/materials/model/obj_kroetenhaut.png)
===================================================================
(Binary files differ)

Added: modules/common/materials/model/obj_kroetenhaut_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_kroetenhaut_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_kroetenhaut_specular.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_kroetenhaut_specular.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/materials/model/obj_pants01.png
===================================================================
(Binary files differ)

Added: modules/common/materials/model/obj_pants_01_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_pants_01_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_pants_01_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_pants_01_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/materials/model/obj_plattediffuse.png
===================================================================
(Binary files differ)

Added: modules/common/materials/model/obj_shortsleeve02_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_shortsleeve02_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_shortsleeve02_specular.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_shortsleeve02_specular.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/materials/model/rl_mensch_female.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/programs/NormalMap2Lights.hlsl
===================================================================
--- modules/common/materials/programs/NormalMap2Lights.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/NormalMap2Lights.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -10,7 +10,7 @@
 
 VS_OUTPUT vs_main_1uv(float4 inPos     : POSITION,
                       float3 inNormal  : NORMAL,
-                      float3 inTangent : TEXCOORD1,
+                      float3 inTangent : TANGENT,
                       float2 inUV      : TEXCOORD0,
                       uniform float4 EyePosOS,
                       uniform float4 Light1PosOS,
@@ -43,7 +43,7 @@
 
 VS_OUTPUT vs_main_2uv(float4 inPos     : POSITION,
                       float3 inNormal  : NORMAL,
-                      float3 inTangent : TEXCOORD2,
+                      float3 inTangent : TANGENT,
                       float2 inUV      : TEXCOORD0,
                       uniform float4 EyePosOS,
                       uniform float4 Light1PosOS,
@@ -77,7 +77,7 @@
 
 VS_OUTPUT vs_main_3uv(float4 inPos     : POSITION,
                       float3 inNormal  : NORMAL,
-                      float3 inTangent : TEXCOORD3,
+                      float3 inTangent : TANGENT,
                       float2 inUV      : TEXCOORD0,
                       uniform float4 EyePosOS,
                       uniform float4 Light1PosOS,
@@ -125,7 +125,7 @@
                uniform float4  AmbientLight) : COLOR 
 {
     // Read normal from texture. *2-1 to convert it from signed to unsigned.
-    float4 Normal = tex2D(NormalMap, In.UV) * 2 - 1;
+    float3 Normal = tex2D(NormalMap, In.UV).xyz * 2 - 1;
     float4 TexColour = tex2D(DiffuseMap, In.UV);
 
     // Ambient component

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,163 @@
+vertex_program Basic_Normalmapping_UV0_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV0_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+vertex_program Basic_Normalmapping_UV1_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV1_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+vertex_program Basic_Normalmapping_UV2_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV2_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+fragment_program Basic_Normalmapping_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+
+fragment_program Basic_Normalmapping_mirrored_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+
+material Basic_Normalmapping
+{
+    technique hlsl
+    {
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecColor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Basic_Normalmapping_UV1_mirrored
+{
+    technique hlsl
+    {
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV1_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecColor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,66 @@
+float4 LightColor_0;
+float4 LightColor_1;
+float4 LightColor_2;
+float4 groundcolor;
+float4 skycolor;
+float4 SpecColor;
+float SpecExp;
+sampler DiffuseMap;
+sampler NormalMap;
+
+
+float4 ps_main(
+               float2 UV        : TEXCOORD0,
+               float4 LightDir_0  : TEXCOORD1,
+               float3 HalfVect_0  : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV).rgb *2 -1;
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   float specAttn;
+   float specAttn1;
+   float specAttn2;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn = LightColor_0 * pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      AngleAttn *= LightColor_0 * LightDir_0.w;
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn1  =LightColor_1 *  pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      AngleAttn1 *= LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn2  =LightColor_2 *  pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      AngleAttn2 *= LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = SpecColor * (specAttn + specAttn1 + specAttn2) * Diffuse;
+   
+   
+   return (tex2D(DiffuseMap,UV) * (ambient + Diffuse)) +specular;
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,222 @@
+fragment_program Basic_Normalmapping_Spec_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_Spec_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Basic_Normalmapping_Spec_mirrored_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_Spec_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+
+material Basic_Normalmapping_Spec
+{
+    technique hlsl
+    {
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Basic_Normalmapping_Spec_mirrored
+{
+    technique hlsl
+    {
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Basic_Normalmapping_Spec_Alpha
+{
+    technique hlsl
+    {
+        pass
+        {
+	        scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+      		
+      		
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,68 @@
+uniform float4 LightColor_0;
+uniform float4 LightColor_1;
+uniform float4 LightColor_2;
+uniform float4 groundcolor;
+uniform float4 skycolor;
+uniform float SpecExp;
+uniform sampler2D DiffuseMap;
+uniform sampler2D NormalMap;
+uniform sampler2D SpecMap;
+
+
+float4 ps_main(
+               float2 UV         : TEXCOORD0,
+               float4 LightDir_0 : TEXCOORD1,
+               float3 HalfVect_0 : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV).rgb *2 -1;
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   
+   
+   float specAttn;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   float4 Diffuse;
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn =LightColor_0 * pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      Diffuse = AngleAttn* LightColor_0 * LightDir_0.w;  
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn  += LightColor_1 * pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      Diffuse += AngleAttn1* LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn  +=LightColor_2 * pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      Diffuse += AngleAttn2* LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   //float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = tex2D(SpecMap, UV) * specAttn * (float(Diffuse.r + Diffuse.g + Diffuse.b)/3);
+   
+   float4 color = tex2D(DiffuseMap,UV);
+   
+   return float4((color.rgb * (ambient.rgb + Diffuse.rgb)) + specular.rgb ,color.a);
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_mirrored_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_mirrored_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec_mirrored_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,74 @@
+uniform float4 LightColor_0;
+uniform float4 LightColor_1;
+uniform float4 LightColor_2;
+uniform float4 groundcolor;
+uniform float4 skycolor;
+uniform float SpecExp;
+uniform sampler2D DiffuseMap;
+uniform sampler2D NormalMap;
+uniform sampler2D SpecMap;
+
+
+float4 ps_main(
+               float2 UV         : TEXCOORD0,
+               float4 LightDir_0 : TEXCOORD1,
+               float3 HalfVect_0 : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV).rgb *2 -1;
+   if (floor(UV.x)== 1)
+   {
+	  normal = float3(normal.x, -normal.y, normal.z);
+   }
+   
+   
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   
+   
+   float specAttn;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   float4 Diffuse;
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn =LightColor_0 * pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      Diffuse = AngleAttn* LightColor_0 * LightDir_0.w;  
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn  += LightColor_1 * pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      Diffuse += AngleAttn1* LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn  +=LightColor_2 * pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      Diffuse += AngleAttn2* LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   //float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = tex2D(SpecMap, UV) * specAttn * (float(Diffuse.r + Diffuse.g + Diffuse.b)/3);
+   
+   float4 color = tex2D(DiffuseMap,UV);
+   
+   return float4((color.rgb * (ambient.rgb + Diffuse.rgb)) + specular.rgb ,color.a);
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV0_VS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV0_VS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV0_VS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,98 @@
+float4x4 matViewProjection;
+float4 LightPosition_0;
+float4 LightPosition_1;
+float4 LightPosition_2;
+float4 vViewPosition;
+float4 LightAttn_0;
+float4 LightAttn_1;
+float4 LightAttn_2;
+
+struct VS_OUTPUT 
+{
+   float4 Position   : POSITION0;
+   float2 UV         : TEXCOORD0;
+   float4 LightDir_0 : TEXCOORD1;
+   float3 HalfVect_0 : TEXCOORD2;
+   float4 LightDir_1 : TEXCOORD3;
+   float3 HalfVect_1 : TEXCOORD4;
+   float4 LightDir_2 : TEXCOORD5;
+   float3 HalfVect_2 : TEXCOORD6;
+   float3 SkyDir     : TEXCOORD7;
+   
+};
+
+VS_OUTPUT vs_main(      float4 inPosition : POSITION0,
+                        float3 inNormal : NORMAL0,
+                        float3 inTangent : TANGENT0,
+                        float2 inUV:   TEXCOORD )
+{
+   VS_OUTPUT Output;
+
+   Output.Position = mul( matViewProjection, inPosition );
+   Output.UV = inUV;
+   
+   float3x3 TangentSpace;
+   
+   TangentSpace[0] = inTangent;   
+   TangentSpace[1] = cross(inTangent,inNormal);   
+   TangentSpace[2] = inNormal;
+   
+   float3 EyeVector = normalize(vViewPosition - inPosition);
+   
+   //################# Light 0  ################
+   float4 LightDir;
+   LightDir.xyz = LightPosition_0 - inPosition * LightPosition_0.w;
+   float Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_0.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_0.y +
+                            LightAttn_0.z * Dist +
+                            LightAttn_0.w * Dist * Dist));
+                            
+   
+   
+   Output.HalfVect_0 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_0 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 1  ################
+   LightDir;
+   LightDir.xyz = LightPosition_1 - inPosition * LightPosition_1.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_1.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_1.y +
+                            LightAttn_1.z * Dist +
+                            LightAttn_1.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_1 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_1 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 2  ################
+   LightDir;
+   LightDir.xyz = LightPosition_2 - inPosition * LightPosition_2.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_2.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_2.y +
+                            LightAttn_2.z * Dist +
+                            LightAttn_2.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_2 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_2 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   
+   // SkyLight
+   Output.SkyDir    = mul(TangentSpace, float3(0,-1,0));
+   
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV1_VS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV1_VS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV1_VS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,98 @@
+float4x4 matViewProjection;
+float4 LightPosition_0;
+float4 LightPosition_1;
+float4 LightPosition_2;
+float4 vViewPosition;
+float4 LightAttn_0;
+float4 LightAttn_1;
+float4 LightAttn_2;
+
+struct VS_OUTPUT 
+{
+   float4 Position   : POSITION0;
+   float2 UV         : TEXCOORD0;
+   float4 LightDir_0 : TEXCOORD1;
+   float3 HalfVect_0 : TEXCOORD2;
+   float4 LightDir_1 : TEXCOORD3;
+   float3 HalfVect_1 : TEXCOORD4;
+   float4 LightDir_2 : TEXCOORD5;
+   float3 HalfVect_2 : TEXCOORD6;
+   float3 SkyDir     : TEXCOORD7;
+   
+};
+
+VS_OUTPUT vs_main(      float4 inPosition : POSITION0,
+                        float3 inNormal : NORMAL0,
+                        float3 inTangent : TANGENT0,
+                        float2 inUV:   TEXCOORD1 )
+{
+   VS_OUTPUT Output;
+
+   Output.Position = mul( matViewProjection, inPosition );
+   Output.UV = inUV;
+   
+   float3x3 TangentSpace;
+   
+   TangentSpace[0] = inTangent;   
+   TangentSpace[1] = cross(inTangent,inNormal);   
+   TangentSpace[2] = inNormal;
+   
+   float3 EyeVector = normalize(vViewPosition - inPosition);
+   
+   //################# Light 0  ################
+   float4 LightDir;
+   LightDir.xyz = LightPosition_0 - inPosition * LightPosition_0.w;
+   float Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_0.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_0.y +
+                            LightAttn_0.z * Dist +
+                            LightAttn_0.w * Dist * Dist));
+                            
+   
+   
+   Output.HalfVect_0 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_0 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 1  ################
+   LightDir;
+   LightDir.xyz = LightPosition_1 - inPosition * LightPosition_1.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_1.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_1.y +
+                            LightAttn_1.z * Dist +
+                            LightAttn_1.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_1 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_1 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 2  ################
+   LightDir;
+   LightDir.xyz = LightPosition_2 - inPosition * LightPosition_2.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_2.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_2.y +
+                            LightAttn_2.z * Dist +
+                            LightAttn_2.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_2 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_2 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   
+   // SkyLight
+   Output.SkyDir    = mul(TangentSpace, float3(0,-1,0));
+   
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV2_VS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV2_VS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_UV2_VS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,98 @@
+float4x4 matViewProjection;
+float4 LightPosition_0;
+float4 LightPosition_1;
+float4 LightPosition_2;
+float4 vViewPosition;
+float4 LightAttn_0;
+float4 LightAttn_1;
+float4 LightAttn_2;
+
+struct VS_OUTPUT 
+{
+   float4 Position   : POSITION0;
+   float2 UV         : TEXCOORD0;
+   float4 LightDir_0 : TEXCOORD1;
+   float3 HalfVect_0 : TEXCOORD2;
+   float4 LightDir_1 : TEXCOORD3;
+   float3 HalfVect_1 : TEXCOORD4;
+   float4 LightDir_2 : TEXCOORD5;
+   float3 HalfVect_2 : TEXCOORD6;
+   float3 SkyDir     : TEXCOORD7;
+   
+};
+
+VS_OUTPUT vs_main(      float4 inPosition : POSITION0,
+                        float3 inNormal : NORMAL0,
+                        float3 inTangent : TANGENT0,
+                        float2 inUV:   TEXCOORD2 )
+{
+   VS_OUTPUT Output;
+
+   Output.Position = mul( matViewProjection, inPosition );
+   Output.UV = inUV;
+   
+   float3x3 TangentSpace;
+   
+   TangentSpace[0] = inTangent;   
+   TangentSpace[1] = cross(inTangent,inNormal);   
+   TangentSpace[2] = inNormal;
+   
+   float3 EyeVector = normalize(vViewPosition - inPosition);
+   
+   //################# Light 0  ################
+   float4 LightDir;
+   LightDir.xyz = LightPosition_0 - inPosition * LightPosition_0.w;
+   float Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_0.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_0.y +
+                            LightAttn_0.z * Dist +
+                            LightAttn_0.w * Dist * Dist));
+                            
+   
+   
+   Output.HalfVect_0 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_0 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 1  ################
+   LightDir;
+   LightDir.xyz = LightPosition_1 - inPosition * LightPosition_1.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_1.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_1.y +
+                            LightAttn_1.z * Dist +
+                            LightAttn_1.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_1 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_1 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 2  ################
+   LightDir;
+   LightDir.xyz = LightPosition_2 - inPosition * LightPosition_2.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_2.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_2.y +
+                            LightAttn_2.z * Dist +
+                            LightAttn_2.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_2 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_2 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   
+   // SkyLight
+   Output.SkyDir    = mul(TangentSpace, float3(0,-1,0));
+   
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_mirrored_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_mirrored_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_mirrored_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,72 @@
+float4 LightColor_0;
+float4 LightColor_1;
+float4 LightColor_2;
+float4 groundcolor;
+float4 skycolor;
+float4 SpecColor;
+float SpecExp;
+sampler DiffuseMap;
+sampler NormalMap;
+
+
+float4 ps_main(
+               float2 UV        : TEXCOORD0,
+               float4 LightDir_0  : TEXCOORD1,
+               float3 HalfVect_0  : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV).rgb *2 -1;
+   
+   if (floor(UV.x)== 1)
+   {
+	  normal = float3(normal.x, -normal.y, normal.z);
+   }
+   
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   float specAttn;
+   float specAttn1;
+   float specAttn2;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn = LightColor_0 * pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      AngleAttn *= LightColor_0 * LightDir_0.w;
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn1  =LightColor_1 *  pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      AngleAttn1 *= LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn2  =LightColor_2 *  pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      AngleAttn2 *= LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = SpecColor * (specAttn + specAttn1 + specAttn2) * Diffuse;
+   
+   
+   return (tex2D(DiffuseMap,UV) * (ambient + Diffuse)) +specular;
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Eye_Normalmapping_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Eye_Normalmapping_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Eye_Normalmapping_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,72 @@
+float4 LightColor_0;
+float4 LightColor_1;
+float4 LightColor_2;
+float4 groundcolor;
+float4 skycolor;
+float4 SpecColor;
+float SpecExp;
+sampler DiffuseMap;
+sampler NormalMap;
+sampler ShadowMap;
+
+
+float4 ps_main(
+               float4 UV        : TEXCOORD0,
+               float4 LightDir_0  : TEXCOORD1,
+               float3 HalfVect_0  : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV.xy).rgb *2 -1;
+   
+   if (UV.z > 1)
+   {
+	  normal = float3(-normal.x, -normal.y, normal.z);
+   }
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+   
+   float specAttn;
+   float specAttn1;
+   float specAttn2;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn = LightColor_0 * pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      AngleAttn *= LightColor_0 * LightDir_0.w;
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn1  =LightColor_1 *  pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      AngleAttn1 *= LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn2  =LightColor_2 *  pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      AngleAttn2 *= LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = SpecColor * (specAttn + specAttn1 + specAttn2) * Diffuse;
+   
+   
+   return ((tex2D(DiffuseMap,UV.xy) * (ambient + Diffuse)) *tex2D(ShadowMap,UV.zw)+specular);
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Eye_Normalmapping_VS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Eye_Normalmapping_VS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Eye_Normalmapping_VS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,109 @@
+float4x4 matViewProjection;
+float4 LightPosition_0;
+float4 LightPosition_1;
+float4 LightPosition_2;
+float4 vViewPosition;
+float4 LightAttn_0;
+float4 LightAttn_1;
+float4 LightAttn_2;
+float3 eyeDirection;
+
+struct VS_OUTPUT 
+{
+   float4 Position   : POSITION0;
+   float4 UV         : TEXCOORD0;
+   float4 LightDir_0 : TEXCOORD1;
+   float3 HalfVect_0 : TEXCOORD2;
+   float4 LightDir_1 : TEXCOORD3;
+   float3 HalfVect_1 : TEXCOORD4;
+   float4 LightDir_2 : TEXCOORD5;
+   float3 HalfVect_2 : TEXCOORD6;
+   float3 SkyDir     : TEXCOORD7;
+   
+};
+
+VS_OUTPUT vs_main(      float4 inPosition : POSITION0,
+                        float3 inNormal : NORMAL0,
+                        float3 inTangent : TANGENT0,
+                        float2 inUV:   TEXCOORD1 )
+{
+   VS_OUTPUT Output;
+
+   Output.Position = mul( matViewProjection, inPosition );
+   Output.UV.zw = inUV;
+   
+   float2 eyeDir; 
+   eyeDir.x = clamp(-eyeDirection.x/3,-0.3,0.3);
+   eyeDir.y = clamp(-eyeDirection.z/3,-0.3,0.3);
+     
+   Output.UV.x        = inUV.x + eyeDir.x;
+   Output.UV.y        = inUV.y + eyeDir.y;
+   
+   
+   
+   
+   float3x3 TangentSpace;
+   
+   TangentSpace[0] = inTangent;   
+   TangentSpace[1] = cross(inTangent,inNormal);   
+   TangentSpace[2] = inNormal;
+   
+   float3 EyeVector = normalize(vViewPosition - inPosition);
+   
+   //################# Light 0  ################
+   float4 LightDir;
+   LightDir.xyz = LightPosition_0 - inPosition * LightPosition_0.w;
+   float Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_0.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_0.y +
+                            LightAttn_0.z * Dist +
+                            LightAttn_0.w * Dist * Dist));
+                            
+   
+   
+   Output.HalfVect_0 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_0 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 1  ################
+   LightDir;
+   LightDir.xyz = LightPosition_1 - inPosition * LightPosition_1.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_1.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_1.y +
+                            LightAttn_1.z * Dist +
+                            LightAttn_1.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_1 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_1 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   //################# Light 2  ################
+   LightDir;
+   LightDir.xyz = LightPosition_2 - inPosition * LightPosition_2.w;
+   Dist = length(LightDir.xyz);
+   LightDir.xyz = LightDir.xyz /Dist;
+   
+   if (LightPosition_2.w != 0.0)
+   LightDir.w = saturate(1/(LightAttn_2.y +
+                            LightAttn_2.z * Dist +
+                            LightAttn_2.w * Dist * Dist));
+                            
+   
+   Output.HalfVect_2 = mul(TangentSpace, normalize(LightDir.xyz + EyeVector));
+   Output.LightDir_2 = float4(mul(TangentSpace,LightDir.xyz),LightDir.w);
+   
+   
+   // SkyLight
+   Output.SkyDir    = mul(TangentSpace, float3(0,-1,0));
+   
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,308 @@
+fragment_program Skin_Normalmapping_PS_HLSL hlsl
+{
+    source Skin_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Skin_Normalmapping_mirrored_PS_HLSL hlsl
+{
+    source Skin_Normalmapping_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Eye_Normalmapping_PS_HLSL hlsl
+{
+    source Eye_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+vertex_program Eye_Normalmapping_VS_HLSL hlsl
+{
+    source Eye_Normalmapping_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+material Skin_Normalmapping
+{
+    technique hlsl
+    {
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+
+
+material Face_Normalmapping_mirrored
+{
+    technique hlsl
+    {
+        pass
+        {
+            vertex_program_ref Eye_Normalmapping_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named eyeDirection float3 0.0 1 0.0
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Eye_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SpecColor float4 1.0 1.0 1.0 1.0
+                param_named SpecExp float 64.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias EyeDiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias EyeNormalMap
+            }
+            
+            texture_unit ShadowMap
+            {
+                texture_alias EyeShadowMap
+                texture men_eyeshadow.png
+            }
+        }
+        
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Skin_Normalmapping_mirrored
+{
+    technique hlsl
+    {
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Added: modules/common/materials/programs/Normalmapping/Skin_Normalmapping_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,72 @@
+uniform float4 LightColor_0;
+uniform float4 LightColor_1;
+uniform float4 LightColor_2;
+uniform float4 groundcolor;
+uniform float4 skycolor;
+uniform float4 SkinColor;
+uniform float SpecExp;
+uniform sampler2D DiffuseMap;
+uniform sampler2D NormalMap;
+uniform sampler2D SpecMap;
+uniform sampler1D LookupSkin;
+
+
+float4 ps_main(
+               float2 UV         : TEXCOORD0,
+               float4 LightDir_0 : TEXCOORD1,
+               float3 HalfVect_0 : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV).rgb *2 -1;
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   
+   
+   float specAttn;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   float4 Diffuse;
+   
+   if (AngleAttn.r > 0.0)
+   {
+      specAttn =LightColor_0 *  pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      AngleAttn = tex1D(LookupSkin, AngleAttn);
+      Diffuse = AngleAttn* LightColor_0 * LightDir_0.w;  
+   }
+   
+   if (AngleAttn1.r > 0.0)
+   {
+      specAttn  +=LightColor_1 *  pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      AngleAttn1 = tex1D(LookupSkin, AngleAttn1);
+      Diffuse += AngleAttn1* LightColor_1 * LightDir_1.w;
+   }
+  
+   if (AngleAttn2.r > 0.0)
+   {
+      specAttn  +=LightColor_2 *  pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      AngleAttn2 = tex1D(LookupSkin, AngleAttn2);
+      Diffuse += AngleAttn2* LightColor_2 * LightDir_2.w;
+   }
+  
+  
+   //float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = tex2D(SpecMap, UV) * specAttn * (float(Diffuse.r + Diffuse.g + Diffuse.b)/3);
+   
+   
+   return (SkinColor-0.5 +(tex2D(DiffuseMap,UV))  * (ambient + Diffuse)) +specular;
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Skin_Normalmapping_mirrored_PS.hlsl
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping_mirrored_PS.hlsl	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping_mirrored_PS.hlsl	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,72 @@
+uniform float4 LightColor_0;
+uniform float4 LightColor_1;
+uniform float4 LightColor_2;
+uniform float4 groundcolor;
+uniform float4 skycolor;
+uniform float4 SkinColor;
+uniform float SpecExp;
+uniform sampler2D DiffuseMap;
+uniform sampler2D NormalMap;
+uniform sampler2D SpecMap;
+uniform sampler1D LookupSkin;
+
+
+float4 ps_main(
+               float2 UV         : TEXCOORD0,
+               float4 LightDir_0 : TEXCOORD1,
+               float3 HalfVect_0 : TEXCOORD2,
+               float4 LightDir_1 : TEXCOORD3,
+               float3 HalfVect_1 : TEXCOORD4,
+               float4 LightDir_2 : TEXCOORD5,
+               float3 HalfVect_2 : TEXCOORD6,
+               float3 SkyDir     : TEXCOORD7
+               ) : COLOR0
+{ 
+
+   float3 normal = tex2D(NormalMap,UV.xy).rgb *2 -1;
+   if (UV.x > 1)
+   {
+	  normal = float3(normal.x, -normal.y, normal.z);
+   }
+   float4 ambient= lerp(skycolor , groundcolor, ((dot(normal, SkyDir) + 1.0)/2.0));
+
+   
+   
+   float specAttn;
+   float4 AngleAttn;
+   float4 AngleAttn1;
+   float4 AngleAttn2;
+   
+   AngleAttn= saturate(dot(normal,LightDir_0.xyz));
+   AngleAttn1= saturate(dot(normal,LightDir_1.xyz));
+   AngleAttn2= saturate(dot(normal,LightDir_2.xyz));
+   
+   float4 Diffuse;
+   
+
+      specAttn =LightColor_0 *  pow(clamp(dot(normal,normalize(HalfVect_0)),0,1),SpecExp)* LightDir_0.w;
+      AngleAttn = tex1D(LookupSkin, AngleAttn);
+      Diffuse = AngleAttn* LightColor_0 * LightDir_0.w;  
+   
+
+      specAttn  +=LightColor_1 *  pow(clamp(dot(normal,normalize(HalfVect_1)),0,1),SpecExp)* LightDir_1.w;
+      AngleAttn1 = tex1D(LookupSkin, AngleAttn1);
+      Diffuse += AngleAttn1* LightColor_1 * LightDir_1.w;
+
+  
+
+      specAttn  +=LightColor_2 *  pow(clamp(dot(normal,normalize(HalfVect_2)),0,1),SpecExp)* LightDir_2.w;
+      AngleAttn2 = tex1D(LookupSkin, AngleAttn2);
+      Diffuse += AngleAttn2* LightColor_2 * LightDir_2.w;
+
+  
+  
+   //float4 Diffuse = AngleAttn + AngleAttn1 + AngleAttn2;
+   float4 specular = tex2D(SpecMap, UV.xy) * specAttn * (float(Diffuse.r + Diffuse.g + Diffuse.b)/3);
+   float4 diffuseColor = (tex2D(DiffuseMap,UV.xy)) ;
+   
+   return float4(((SkinColor.rgb-0.5 + diffuseColor.rgb) * (ambient + Diffuse)) +specular.rgb , diffuseColor.a);
+}
+
+
+

Added: modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program	2007-08-16 20:18:12 UTC (rev 3695)
@@ -0,0 +1,250 @@
+material Torso_Normalmapping_Short
+{
+    technique hlsl
+    {
+        pass
+        {
+	        alpha_rejection greater 128
+	        
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit 
+            {
+                texture_alias DiffuseMapSkin
+            }
+
+            // Normal map
+            texture_unit 
+            {
+                texture_alias NormalMapSkin
+            }
+            
+            texture_unit 
+            {
+                texture_alias SpecMapSkin
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+        
+        
+        pass
+        {
+	        alpha_rejection greater 128
+	        
+            vertex_program_ref Basic_Normalmapping_UV1_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit 
+            {
+                texture_alias DiffuseMapCloth
+            }
+
+            // Normal map
+            texture_unit 
+            {
+                texture_alias NormalMapCloth
+            }
+            
+            texture_unit 
+            {
+                texture_alias SpecMapCloth
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Torso_Normalmapping_Long
+{
+    technique hlsl
+    {
+        pass
+        {
+	        alpha_rejection greater 128
+	        
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit 
+            {
+                texture_alias DiffuseMapSkin
+            }
+
+            // Normal map
+            texture_unit 
+            {
+                texture_alias NormalMapSkin
+            }
+            
+            texture_unit 
+            {
+                texture_alias SpecMapSkin
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+        
+        
+        pass
+        {
+	        alpha_rejection greater 128
+	        
+            vertex_program_ref Basic_Normalmapping_UV2_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit
+            {
+                texture_alias DiffuseMapCloth
+            }
+
+            // Normal map
+            texture_unit 
+            {
+                texture_alias NormalMapCloth
+            }
+            
+            texture_unit 
+            {
+                texture_alias SpecMapCloth
+            }
+        }
+    }
+
+    technique fixed_function
+    {
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_garethplatte.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_backpack_leather_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_backpack_leather_01_smalll.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_feet_boots_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_head_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_leg_pants_01_long.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)

Modified: modules/common/scripts/moduleconfig.rb
===================================================================
--- modules/common/scripts/moduleconfig.rb	2007-08-13 20:26:47 UTC (rev 3694)
+++ modules/common/scripts/moduleconfig.rb	2007-08-16 20:18:12 UTC (rev 3695)
@@ -10,7 +10,7 @@
     end
 
     def getTextureLocations()
-	return ["alpha", "env", "model", "programs", "templates", "tiled", "particle"]
+	return ["alpha", "env", "model", "programs", "programs/Normalmapping", "templates", "tiled", "particle"]
     end
 
     def getSoundLocations()



From pnyx at mail.berlios.de  Thu Aug 16 22:50:59 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 16 Aug 2007 22:50:59 +0200
Subject: [Dsa-hl-svn] r3696 - modules/common/models
Message-ID: <200708162050.l7GKoxf1010739@sheep.berlios.de>

Author: pnyx
Date: 2007-08-16 22:50:50 +0200 (Thu, 16 Aug 2007)
New Revision: 3696

Modified:
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
Log:
forgot to move mirrored UV part

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)



From tanis at mail.berlios.de  Fri Aug 17 00:09:23 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 17 Aug 2007 00:09:23 +0200
Subject: [Dsa-hl-svn] r3697 - dependencies/opensteer/win32
Message-ID: <200708162209.l7GM9NPn015941@sheep.berlios.de>

Author: tanis
Date: 2007-08-17 00:09:20 +0200 (Fri, 17 Aug 2007)
New Revision: 3697

Modified:
   dependencies/opensteer/win32/opensteer.vcproj
Log:
Add ogrenew include directory to includes, because Ogre::Vector3 is now used.

Modified: dependencies/opensteer/win32/opensteer.vcproj
===================================================================
--- dependencies/opensteer/win32/opensteer.vcproj	2007-08-16 20:50:50 UTC (rev 3696)
+++ dependencies/opensteer/win32/opensteer.vcproj	2007-08-16 22:09:20 UTC (rev 3697)
@@ -41,7 +41,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;$(ProjectDir)\..\include&quot;;&quot;$(ProjectDir)\..\include\Opensteer&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)\..\include&quot;;&quot;$(ProjectDir)\..\include\Opensteer&quot;;..\..\ogrenew\OgreMain\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_DLL;_MT"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -116,7 +116,7 @@
 				Optimization="2"
 				InlineFunctionExpansion="1"
 				OmitFramePointers="true"
-				AdditionalIncludeDirectories="&quot;$(ProjectDir)\..\include&quot;;&quot;$(ProjectDir)\..\include\Opensteer&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)\..\include&quot;;&quot;$(ProjectDir)\..\include\Opensteer&quot;;..\..\ogrenew\OgreMain\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_DLL;_MT"
 				StringPooling="true"
 				RuntimeLibrary="2"



From pnyx at mail.berlios.de  Fri Aug 17 17:45:56 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Fri, 17 Aug 2007 17:45:56 +0200
Subject: [Dsa-hl-svn] r3698 - in modules/common: materials
	materials/programs materials/programs/Normalmapping models
Message-ID: <200708171545.l7HFjuNb007098@sheep.berlios.de>

Author: pnyx
Date: 2007-08-17 17:45:44 +0200 (Fri, 17 Aug 2007)
New Revision: 3698

Added:
   modules/common/materials/men_human_female_cloth_short.mesh.material
   modules/common/materials/programs/Basic_Vertex_Shader.program
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.program
   modules/common/materials/programs/Face_Vertex_Shader.program
   modules/common/materials/programs/Skin_Vertex_Shader.program
   modules/common/models/men_human_female_cloth_long.mesh
   modules/common/models/men_human_female_cloth_short.mesh
   modules/common/models/men_human_female_cloth_short_02.mesh
Removed:
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
   modules/common/materials/programs/Face_Vertex_Shader.material
   modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program
   modules/common/materials/programs/Skin_Vertex_Shader.material
Modified:
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
Log:
*added lod techniques for normalmapping shaders
*added meshes and materials for new clothing


Added: modules/common/materials/men_human_female_cloth_short.mesh.material
===================================================================
--- modules/common/materials/men_human_female_cloth_short.mesh.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/men_human_female_cloth_short.mesh.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -0,0 +1,10 @@
+material men_human_female_cloth_short : Basic_Normalmapping_Spec
+{
+set_texture_alias DiffuseMap obj_shortsleeve02_diffuse.png
+set_texture_alias NormalMap obj_shortsleeve02_normal.png
+set_texture_alias SpecMap obj_shortsleeve02_specular.png
+
+//set_texture_alias DiffuseMap obj_shortsleeve02_diffuse.png
+//set_texture_alias NormalMapCloth obj_shortsleeve02_normal.png
+//set_texture_alias SpecMapCloth obj_shortsleeve02_specular.png
+}
\ No newline at end of file

Modified: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/men_human_female_torso.mesh.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,10 +1,10 @@
-material men_human_female_torso : Torso_Normalmapping_Short
+material men_human_female_torso : Skin_Normalmapping
 {
-set_texture_alias DiffuseMapSkin men_female_human_diffuse.png
-set_texture_alias NormalMapSkin men_human_female_normalmap.png
-set_texture_alias SpecMapSkin men_female_human_diffuse.png
+set_texture_alias DiffuseMap men_female_human_diffuse.png
+set_texture_alias NormalMap men_human_female_normalmap.png
+set_texture_alias SpecMap men_female_human_diffuse.png
 
-set_texture_alias DiffuseMapCloth obj_shortsleeve02_diffuse.png
-set_texture_alias NormalMapCloth obj_shortsleeve02_normal.png
-set_texture_alias SpecMapCloth obj_shortsleeve02_specular.png
+//set_texture_alias DiffuseMapCloth obj_shortsleeve02_diffuse.png
+//set_texture_alias NormalMapCloth obj_shortsleeve02_normal.png
+//set_texture_alias SpecMapCloth obj_shortsleeve02_specular.png
 }
\ No newline at end of file

Deleted: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,143 +0,0 @@
-//Effect: Textured
-
-//DirectX 9.0 HLSL Vertex Shader vs_2_0
-vertex_program Basic_Vertex_Shader hlsl
-{
-	source Basic_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
-//DirectX 9.0 HLSL Pixel Shader ps_2_0
-fragment_program Basic_Pixel_Shader hlsl
-{
-	source Basic_Pixel_Shader.source
-	target ps_2_0
-	entry_point ps_main
-}
-
-vertex_program Basic_Vertex_Shader_glsl glsl
-{
-	source Basic_Vertex_Shader_glsl.source
-}
-//DirectX 9.0 HLSL Pixel Shader ps_2_0
-fragment_program Basic_Pixel_Shader_glsl glsl
-{
-	source Basic_Pixel_Shader_glsl.source
-}
-
-vertex_program Basic_Vertex_Shader_SR hlsl
-{
-  source SimpleShadowReceiver.hlsl
-  entry_point vs_main
-  target vs_1_1
-}
-
-material Basic_Vertex_Shader
-{
-	receive_shadows off
-	technique glsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader_glsl
-			{
-				param_named baseMap int 0
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-	
-	technique hlsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-
-	technique
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture_alias diffuse
-            }
-        }
-    }
-}

Copied: modules/common/materials/programs/Basic_Vertex_Shader.program (from rev 3694, modules/common/materials/programs/Basic_Vertex_Shader.material)

Deleted: modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,120 +0,0 @@
-//Effect: Textured
-fragment_program Basic_Pixel_ShaderUV1 hlsl
-{
-	source Basic_Pixel_ShaderUV1.source
-	target ps_2_0
-	entry_point ps_main
-}
-fragment_program Basic_Pixel_ShaderUV1_glsl glsl
-{
-	source Basic_Pixel_ShaderUV1_glsl.source
-
-}
-
-
-material Basic_Vertex_ShaderUV1
-{
-	technique glsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_ShaderUV1_glsl
-			{
-				param_named baseMap int 0
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-	technique hlsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_ShaderUV1
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-	technique
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture_alias diffuse
-            }
-        }
-    }
-}

Copied: modules/common/materials/programs/Basic_Vertex_ShaderUV1.program (from rev 3694, modules/common/materials/programs/Basic_Vertex_ShaderUV1.material)

Deleted: modules/common/materials/programs/Face_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Face_Vertex_Shader.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,163 +0,0 @@
-vertex_program Face_Vertex_Shader hlsl
-{
-	source Face_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
-
-
-fragment_program Face_Pixel_Shader hlsl
-{
-	source Face_Pixel_Shader.source
-	target ps_2_0
-	entry_point ps_main
-}
-
-vertex_program Face_Vertex_Shader_glsl glsl
-{
-	source Face_Vertex_Shader_glsl.source
-}
-
-
-fragment_program Face_Pixel_Shader_glsl glsl
-{
-	source Face_Pixel_Shader_glsl.source
-}
-
-
-material Face_Vertex_Shader
-{
-	
-	technique glsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Face_Pixel_Shader_glsl
-			{
-				param_named baseMap int 0
-				param_named Texture1 int 1
-				param_named Texture2 int 2
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Face_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				param_named eyeDirection float3 0.0 0 0.0
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.25 0.25 0.25 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-			texture_unit
-			{
-				texture_alias eyeColor
-
-			}
-			texture_unit
-			{
-				texture_alias eyeShadow
-
-			}
-		}
-	}
-	
-
-	technique hlsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Face_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Face_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				param_named eyeDirection float3 0.0 0 0.0
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.25 0.25 0.25 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-			texture_unit
-			{
-				texture_alias eyeColor
-
-			}
-			texture_unit
-			{
-				texture_alias eyeShadow
-
-			}
-		}
-	}
-
-	technique fixed_function
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture_alias diffuse
-            }
-        }
-    }
-}

Copied: modules/common/materials/programs/Face_Vertex_Shader.program (from rev 3694, modules/common/materials/programs/Face_Vertex_Shader.material)

Modified: modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-17 15:45:44 UTC (rev 3698)
@@ -37,8 +37,11 @@
 
 material Basic_Normalmapping
 {
+	lod_distances 12 100
+	
     technique hlsl
     {
+	    lod_index 0
         pass
         {
             vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
@@ -80,9 +83,59 @@
             }
         }
     }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
     technique fixed_function
     {
+	    lod_index 2
         pass
         {
             ambient 0.6 0.6 0.6 1.0
@@ -101,8 +154,11 @@
 
 material Basic_Normalmapping_UV1_mirrored
 {
+	lod_distances 12 100
+	
     technique hlsl
     {
+	    lod_index 0
         pass
         {
             vertex_program_ref Basic_Normalmapping_UV1_VS_HLSL
@@ -144,9 +200,60 @@
             }
         }
     }
+    
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_ShaderUV1
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
     technique fixed_function
     {
+	    lod_index 2
         pass
         {
             ambient 0.6 0.6 0.6 1.0

Modified: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-17 15:45:44 UTC (rev 3698)
@@ -15,10 +15,14 @@
 
 material Basic_Normalmapping_Spec
 {
+	lod_distances 12 100
+	
     technique hlsl
     {
+	    lod_index 0
         pass
         {
+	        alpha_rejection greater 128
             vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
             {
                 param_named_auto matViewProjection worldviewproj_matrix
@@ -62,9 +66,58 @@
             }
         }
     }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
     technique fixed_function
     {
+	    lod_index 1
         pass
         {
             ambient 0.6 0.6 0.6 1.0
@@ -83,10 +136,14 @@
 
 material Basic_Normalmapping_Spec_mirrored
 {
+	lod_distances 12 100
+	
     technique hlsl
     {
+	    lod_index 0
         pass
         {
+	        alpha_rejection greater 128
             vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
             {
                 param_named_auto matViewProjection worldviewproj_matrix
@@ -131,8 +188,58 @@
         }
     }
 
+       
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
     technique fixed_function
     {
+	    lod_index 1
         pass
         {
             ambient 0.6 0.6 0.6 1.0
@@ -148,18 +255,22 @@
     }
 }
 
+ //scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+   //   		depth_write off
 
 material Basic_Normalmapping_Spec_Alpha
 {
+	lod_distances 12 100
+	
     technique hlsl
     {
+	    lod_index 0
         pass
         {
 	        scene_blend alpha_blend 
       		// Tiefenpuffer aus
       		depth_write off
-      		
-      		
             vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
             {
                 param_named_auto matViewProjection worldviewproj_matrix
@@ -203,9 +314,58 @@
             }
         }
     }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
     technique fixed_function
     {
+	    lod_index 1
         pass
         {
             ambient 0.6 0.6 0.6 1.0

Modified: modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-17 15:45:44 UTC (rev 3698)
@@ -28,10 +28,17 @@
 
 material Skin_Normalmapping
 {
+	lod_distances 12 100
+	
+	
     technique hlsl
     {
+	    lod_index 0
+	
+	    
         pass
         {
+	        depth_bias -18
 	        alpha_rejection greater 128
             vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
             {
@@ -84,11 +91,70 @@
             }
         }
     }
+    
+    
+    technique hlsl2
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			depth_bias -1
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+    
+    
+    
+    
+	
     technique fixed_function
     {
+	    lod_index 2
+	    
         pass
         {
+	        depth_bias -1
             ambient 0.6 0.6 0.6 1.0
             diffuse 0.7 0.7 0.7 1.0
             specular 0.3 0.3 0.3 1.0 16.0
@@ -107,8 +173,10 @@
 
 material Face_Normalmapping_mirrored
 {
+	lod_distances 10 100
     technique hlsl
     {
+	    lod_index 0
         pass
         {
             vertex_program_ref Eye_Normalmapping_VS_HLSL
@@ -212,9 +280,70 @@
             }
         }
     }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Face_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Face_Vertex_Shader
+			{
+				// param_named_auto
 
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				param_named eyeDirection float3 0.0 0 0.0
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+			texture_unit DiffuseMap
+            {
+                texture_alias EyeDiffuseMap
+            }            
+            texture_unit ShadowMap
+            {
+                texture_alias EyeShadowMap
+                texture men_eyeshadow.png
+            }
+		}
+	}
+    
+
     technique fixed_function
     {
+	    lod_index 2
         pass
         {
             ambient 0.6 0.6 0.6 1.0
@@ -233,8 +362,10 @@
 
 material Skin_Normalmapping_mirrored
 {
+	lod_distances 12 100
     technique hlsl
     {
+	    lod_index 0
         pass
         {
 	        alpha_rejection greater 128
@@ -290,10 +421,64 @@
         }
     }
 
+    technique hlsl2
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			depth_bias -1
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
     technique fixed_function
     {
+	    lod_index 2
+	    
         pass
         {
+	        depth_bias -1
             ambient 0.6 0.6 0.6 1.0
             diffuse 0.7 0.7 0.7 1.0
             specular 0.3 0.3 0.3 1.0 16.0

Deleted: modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Normalmapping/Torso_Normalmapping.program	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,250 +0,0 @@
-material Torso_Normalmapping_Short
-{
-    technique hlsl
-    {
-        pass
-        {
-	        alpha_rejection greater 128
-	        
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Skin_Normalmapping_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SkinColor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit 
-            {
-                texture_alias DiffuseMapSkin
-            }
-
-            // Normal map
-            texture_unit 
-            {
-                texture_alias NormalMapSkin
-            }
-            
-            texture_unit 
-            {
-                texture_alias SpecMapSkin
-            }
-            
-            texture_unit LookupSkin
-            {
-                texture_alias LookupSkin
-                texture lookup_skin.png 1d
-                tex_address_mode clamp
-            }
-        }
-        
-        
-        pass
-        {
-	        alpha_rejection greater 128
-	        
-            vertex_program_ref Basic_Normalmapping_UV1_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit 
-            {
-                texture_alias DiffuseMapCloth
-            }
-
-            // Normal map
-            texture_unit 
-            {
-                texture_alias NormalMapCloth
-            }
-            
-            texture_unit 
-            {
-                texture_alias SpecMapCloth
-            }
-        }
-    }
-
-    technique fixed_function
-    {
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
-
-material Torso_Normalmapping_Long
-{
-    technique hlsl
-    {
-        pass
-        {
-	        alpha_rejection greater 128
-	        
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Skin_Normalmapping_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SkinColor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit 
-            {
-                texture_alias DiffuseMapSkin
-            }
-
-            // Normal map
-            texture_unit 
-            {
-                texture_alias NormalMapSkin
-            }
-            
-            texture_unit 
-            {
-                texture_alias SpecMapSkin
-            }
-            
-            texture_unit LookupSkin
-            {
-                texture_alias LookupSkin
-                texture lookup_skin.png 1d
-                tex_address_mode clamp
-            }
-        }
-        
-        
-        pass
-        {
-	        alpha_rejection greater 128
-	        
-            vertex_program_ref Basic_Normalmapping_UV2_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit
-            {
-                texture_alias DiffuseMapCloth
-            }
-
-            // Normal map
-            texture_unit 
-            {
-                texture_alias NormalMapCloth
-            }
-            
-            texture_unit 
-            {
-                texture_alias SpecMapCloth
-            }
-        }
-    }
-
-    technique fixed_function
-    {
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
\ No newline at end of file

Deleted: modules/common/materials/programs/Skin_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-16 22:09:20 UTC (rev 3697)
+++ modules/common/materials/programs/Skin_Vertex_Shader.material	2007-08-17 15:45:44 UTC (rev 3698)
@@ -1,124 +0,0 @@
-vertex_program Skin_Vertex_Shader hlsl
-{
-	source Skin_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
-vertex_program Skin_Vertex_Shader_glsl glsl
-{
-	source Skin_Vertex_Shader_glsl.source
-}
-
-material Skin_Vertex_Shader
-{
-	receive_shadows off
-	
-	technique glsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader_glsl
-			{
-				param_named baseMap int 0
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Skin_Vertex_Shader_glsl
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.25 0.25 0.25 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-	technique hlsl
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Skin_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.25 0.25 0.25 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias diffuse
-
-			}
-		}
-	}
-
-	technique
-	{
-        pass
-        {
-            texture_unit
-            {
-                texture_alias diffuse
-            }
-        }
-    }
-}

Copied: modules/common/materials/programs/Skin_Vertex_Shader.program (from rev 3694, modules/common/materials/programs/Skin_Vertex_Shader.material)

Added: modules/common/models/men_human_female_cloth_long.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_cloth_long.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_cloth_short.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_cloth_short.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_cloth_short_02.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_cloth_short_02.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pnyx at mail.berlios.de  Fri Aug 17 20:32:22 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Fri, 17 Aug 2007 20:32:22 +0200
Subject: [Dsa-hl-svn] r3699 - modules/common/materials/model
Message-ID: <200708171832.l7HIWMfv004405@sheep.berlios.de>

Author: pnyx
Date: 2007-08-17 20:31:44 +0200 (Fri, 17 Aug 2007)
New Revision: 3699

Modified:
   modules/common/materials/model/obj_kroetenhaut_normal.png
   modules/common/materials/model/obj_pants_01_normal.png
Log:
*fixed seams occurring on smaller mipmaps

Modified: modules/common/materials/model/obj_kroetenhaut_normal.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/obj_pants_01_normal.png
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Tue Aug 21 10:42:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 10:42:46 +0200
Subject: [Dsa-hl-svn] r3700 - rl/trunk/engine/ai/src
Message-ID: <200708210842.l7L8gkQ3016642@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 10:42:31 +0200 (Tue, 21 Aug 2007)
New Revision: 3700

Modified:
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
Log:
Minor changes (mostly optical)

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-17 18:31:44 UTC (rev 3699)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-21 08:42:31 UTC (rev 3700)
@@ -66,11 +66,6 @@
     }
 }
 
-//void Agent::updateVehicle(const float currentTime, const float elapsedTime)
-//{
-//    SteeringVehicle::update(currentTime, elapsedTime);
-//}
-
 Creature* Agent::getControlledCreature() const
 {
     return mCreature;

Modified: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-17 18:31:44 UTC (rev 3699)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-21 08:42:31 UTC (rev 3700)
@@ -41,5 +41,6 @@
 
 	void AgentCombatState::update(const float elapsedTime)
     {
+        mAgent->updateVehicle(0, elapsedTime);
     }
 }

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-17 18:31:44 UTC (rev 3699)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-21 08:42:31 UTC (rev 3700)
@@ -65,7 +65,7 @@
 
     // regenerate local space (by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF ( src );
+	regenerateOrthonormalBasisUF ( src);
 }
 
 void SteeringVehicle::initialize(void)
@@ -117,7 +117,7 @@
 
 
     // only process if mMovingCreature not NULL
-    if( mController == NULL )
+    if (mController == NULL)
     {
         mCurrentForce = Vector3::ZERO;
         return;
@@ -129,14 +129,14 @@
      mDebugSteer = mCurrentForce;
 
     // @todo remove this
-    if( mCreature->getAu() <= 6 )
+    if (mCreature->getAu() <= 6)
         mCreature->modifyAu(20,true);
 
 
     AbstractMovement *mov_drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
     Real vel_drehen(0);
     Radian max_drehen = Degree(0);
-    if( mov_drehen->calculateBaseVelocity(vel_drehen) )
+    if (mov_drehen->calculateBaseVelocity(vel_drehen))
     {
         max_drehen = Degree(vel_drehen * 360 * elapsedTime);
     }
@@ -146,15 +146,15 @@
     Radian yaw(0);
     creatureDirection.y = result.y = 0;
     yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
-    if( yaw > Radian(0) && yaw > max_drehen )
+    if (yaw > Radian(0) && yaw > max_drehen)
         yaw = max_drehen;
-    if( yaw < Radian(0) && yaw < -max_drehen )
+    if (yaw < Radian(0) && yaw < -max_drehen)
         yaw = -max_drehen;
 
     Ogre::Vector3 direction(Ogre::Vector3::ZERO);
     Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
     CreatureController::MovementType movement = CreatureController::MT_STEHEN;
-    if( result != Ogre::Vector3::ZERO )
+    if (result != Ogre::Vector3::ZERO)
     {
         direction.z = -1;
         movement = CreatureController::MT_GEHEN;
@@ -190,16 +190,7 @@
 
 Vector3 SteeringVehicle::calcPursuit(Agent* agent)
 {
-    /// @todo Think up an OpenSteer compatible solution if this is none.
-    /// Not all Agents have a SteeringVehicle, so it is not possible to
-    /// to use steerForPursuit like this in all cases.
-	/// Vec3 rVal = steerForPursuit(*(agent->getVehicle())).setYtoZero();
-    /// So here is my naive solution without regarding
-    /// Just returning a direction vector on the xz-plane
-    /// towards the other agent.
-    Vector3 dir = agent->getControlledCreature()->getPosition() -
-        mCreature->getPosition();
-    dir.y = 0;
+    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
 	return dir;
 }
 
@@ -246,9 +237,9 @@
 	//AgentManager::VehicleList::const_iterator itr = list.begin();
 	//for(; itr != list.end(); ++itr)
 	//{
-	//	if( (*itr) != this )
+	//	if ((*itr) != this)
 	//	{
-	//		group.push_back( (*itr) );
+	//		group.push_back( (*itr));
 	//	}
 	//}
 	return group;



From blakharaz at mail.berlios.de  Tue Aug 21 10:43:49 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 10:43:49 +0200
Subject: [Dsa-hl-svn] r3701 - rl/trunk/engine/ai/src
Message-ID: <200708210843.l7L8hnTZ016703@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 10:43:46 +0200 (Tue, 21 Aug 2007)
New Revision: 3701

Modified:
   rl/trunk/engine/ai/src/AgentManager.cpp
Log:
Use existing Agent if there is one

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-21 08:42:31 UTC (rev 3700)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-21 08:43:46 UTC (rev 3701)
@@ -50,6 +50,12 @@
 
 Agent* AgentManager::createAgent(Creature* character)
 {
+    AgentMap::iterator it = mAgents.find(character);
+    if (it != mAgents.end())
+    {
+        return it->second;
+    }
+
     Agent* agent = new Agent(character);
 	addAgent(agent);
     return agent;



From blakharaz at mail.berlios.de  Tue Aug 21 10:46:29 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 10:46:29 +0200
Subject: [Dsa-hl-svn] r3702 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200708210846.l7L8kTYE016865@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 10:46:20 +0200 (Tue, 21 Aug 2007)
New Revision: 3702

Modified:
   rl/trunk/engine/ai/include/AgentDialogState.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Export AgentDialogState to Ruby

Modified: rl/trunk/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentDialogState.h	2007-08-21 08:43:46 UTC (rev 3701)
+++ rl/trunk/engine/ai/include/AgentDialogState.h	2007-08-21 08:46:20 UTC (rev 3702)
@@ -22,7 +22,7 @@
 namespace rl
 {
 
-    class AgentDialogState :
+    class _RlAiExport AgentDialogState :
         public AgentState
     {
     public:
@@ -30,10 +30,10 @@
         ~AgentDialogState();
 
         virtual void update(const Ogre::Real elapsedTime);
-        void setPlayer(Agent* player);
+        void setDialogPartner(Agent* partner);
 
     private:
-        Agent* mPlayer;
+        Agent* mPartner;
         bool mTalking;
     };
 

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-21 08:43:46 UTC (rev 3701)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-21 08:46:20 UTC (rev 3702)
@@ -29,7 +29,7 @@
 
     AgentDialogState::AgentDialogState(Agent* agent)
         : AgentState(agent),
-        mPlayer(NULL),
+        mPartner(NULL),
         mTalking(false)
     {
     }
@@ -38,9 +38,9 @@
     {
     }
 
-    void AgentDialogState::setPlayer(Agent* player)
+    void AgentDialogState::setDialogPartner(Agent* partner)
     {
-        mPlayer = player;
+        mPartner = partner;
     }
 
     void AgentDialogState::update(const Ogre::Real elapsedTime)
@@ -49,21 +49,30 @@
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent->getControlledCreature());
 
-        if (!mAgent->isAhead(mPlayer, 0.95)) //getController().calcDistance(@mPlayer.getVehicle().getPosition(), getController().getPosition()) > 2.5)
+        if (!mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5)
         {		
-            ctrl->setMovement(
-                CreatureController::MT_DREHEN, 
-                Vector3::ZERO, 
-                mPlayer->getControlledCreature()->getPosition());
+            mAgent->addForce(mAgent->calcPursuit(mPartner));
+            mAgent->updateVehicle(0, elapsedTime);
         }
+        //else if (!mAgent->isAhead(mPartner, 0.95)) 
+        //{		
+        //    mAgent->addForce(mAgent->calcPursuit(mPartner));
+        //    mAgent->updateVehicle(0, elapsedTime);
+        //}
+        ///@todo: Turn if near
 		else
         {
 			if (!mTalking)
             {
+                mAgent->reset();
                 ctrl->setMovement(CreatureController::MT_NONE, Vector3::ZERO, Vector3::ZERO);
-				ctrl->setAnimation("reden");
+		        //$IM.pushControlState(CST_DIALOG);
+
+                ctrl->setAnimation("reden");
 				mTalking = true;
             }			
         }
+
+
     }
 } // namespace rl

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-21 08:43:46 UTC (rev 3701)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-21 08:46:20 UTC (rev 3702)
@@ -23,6 +23,7 @@
 #include "AiSubsystem.h"
 #include "AgentManager.h"
 #include "Agent.h"
+#include "AgentDialogState.h"
 #include "AStar.h"
 #include "AStarHeuristic.h"
 #include "AStarCosts.h"

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-21 08:43:46 UTC (rev 3701)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-21 08:46:20 UTC (rev 3702)
@@ -22,9 +22,10 @@
 
 namespace rl 
 {
-	// Before first use of GameObject or subclasses!
+	// Before first use
 	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
 	%apply SWIGTYPE *DYNAMIC { rl::AStarCosts * };
+    %apply SWIGTYPE *DYNAMIC { rl::AgentState* };
 
 	class SteeringVehicle
 	{
@@ -64,6 +65,23 @@
 		rl::SteeringBehaviour* getParent();
 		rl::SteeringVehicle* getController();
 	};
+
+	%feature("director") AgentState;
+    class AgentState
+    {
+    private:
+        AgentState(rl::Agent* agent);
+    };
+
+    class AgentDialogState : public rl::AgentState
+    {
+    public:
+        void setDialogPartner(rl::Agent* partner);
+    private:
+        AgentDialogState(rl::Agent* agent);
+    };
+
+    typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
 	
 	class Agent
 	{
@@ -71,7 +89,10 @@
 		Agent(rl::Creature* character);
 		virtual ~Agent();
         rl::Creature* getControlledCreature() const;
+        rl::AgentState* getCurrentState() const;
+        void pushState(rl::AgentStateType type);
 	};
+
 	class AiSubsystem 
 	{
 	public:
@@ -301,3 +322,21 @@
 DYNAMIC_CAST(SWIGTYPE_p_rl__AStarCosts, AStarCosts_dynamic_cast);
 
 
+%{
+static swig_type_info *AgentState_dynamic_cast(void **ptr)
+{
+    rl::AgentState *pAgentState = static_cast<rl::AgentState*>(*ptr);
+
+    rl::AgentDialogState *pAgentDialogState=dynamic_cast<rl::AgentDialogState*>(pAgentState);
+    if (pAgentDialogState)
+    {
+        *ptr=pAgentDialogState;
+        return SWIGTYPE_p_rl__AgentDialogState;
+    }
+   
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AgentState, AgentState_dynamic_cast);
+
+



From blakharaz at mail.berlios.de  Tue Aug 21 12:13:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:13:36 +0200
Subject: [Dsa-hl-svn] r3703 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211013.l7LADaqq024932@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:13:29 +0200 (Tue, 21 Aug 2007)
New Revision: 3703

Added:
   rl/trunk/engine/ai/src/predicates/
Removed:
   rl/trunk/engine/dialog/src/predicates/
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/predicates (from rev 3702, rl/trunk/engine/dialog/src/predicates)



From blakharaz at mail.berlios.de  Tue Aug 21 12:13:44 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:13:44 +0200
Subject: [Dsa-hl-svn] r3704 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211013.l7LADiqC024980@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:13:38 +0200 (Tue, 21 Aug 2007)
New Revision: 3704

Added:
   rl/trunk/engine/ai/src/AimlNodeImplRl.cpp
Removed:
   rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/AimlNodeImplRl.cpp (from rev 3703, rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp)

Deleted: rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-08-21 10:13:29 UTC (rev 3703)
+++ rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-08-21 10:13:38 UTC (rev 3704)
@@ -1,103 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/util/XMLString.hpp>
-#include <xercesc/util/XMLChar.hpp>
-#include <xercesc/util/TransService.hpp>
-#include "AimlNodeImplRl.h"
-
-#include "XmlHelper.h"
-
-namespace rl {
-
-AimlNodeImplRl::AimlNodeImplRl(DOMNode* pNode)
-{
-	mNodeName  = XmlHelper::transcodeToString(pNode->getLocalName());
-	// #text or #comment have no local name, use NodeName for them
-	if(mNodeName.empty())
-	{
-		mNodeName  = XmlHelper::transcodeToString(pNode->getNodeName());
-	}
-	mNodeName.c_str();
-
-	// remove whitespaces from textnodes
-	if(mNodeName == "#text")
-	{
-		XMLCh* tmp = XMLString::replicate(pNode->getNodeValue());
-		XMLString::collapseWS(tmp);
-		mNodeValue = XmlHelper::transcodeToString(tmp);
-		XMLString::release(&tmp);
-	}
-	else
-	{
-		mNodeValue = XmlHelper::transcodeToString(pNode->getNodeValue());
-	}
-	mNodeValue.c_str();
-	// mpa attributes
-	DOMNamedNodeMap* attributes = pNode->getAttributes();
-	if(attributes != NULL)
-	{
-		for(unsigned int i = 0; i < attributes->getLength(); ++i)
-		{
-			CeGuiString attributeName  =
-				XmlHelper::transcodeToString(attributes->item(i)->getNodeName());
-			CeGuiString attributeValue =
-				XmlHelper::transcodeToString(attributes->item(i)->getNodeValue());
-			mAttributes.insert(Attributes::value_type(attributeName, attributeValue));
-		}
-	}
-	//debug
-	for(Attributes::iterator itr = mAttributes.begin(); itr != mAttributes.end() ;++itr)
-	{
-		itr->first.c_str();
-		itr->second.c_str();
-	}
-	// map children
-	DOMNode* child = pNode->getFirstChild();
-	for(; child !=NULL; child = child->getNextSibling())
-	{
-		// don't add pure whitespaces as AimlNode
-		XMLCh* cmp = XMLString::transcode("#text");
-		if(XMLString::equals(child->getNodeName(), cmp))
-		{
-			if(XMLChar1_0::isAllSpaces(child->getNodeValue(), XMLString::stringLen(child->getNodeValue())))
-			{
-				continue;
-			}
-		}
-		XMLString::release(&cmp);
-		mChildren.push_back(new AimlNodeImplRl(child));
-	}
-	if(!mChildren.empty())
-	{
-		std::vector<XmlNode<CeGuiString>*>::iterator itr = mChildren.begin();
-		std::vector<XmlNode<CeGuiString>*>::iterator itrnext;
-		for(; itr != mChildren.end()-1; ++itr)
-		{
-			itrnext= itr+1;
-			(*itr)->setNextSibling((*itrnext));
-		}
-		(*itr)->setNextSibling(NULL);
-	}
-}
-
-AimlNodeImplRl::~AimlNodeImplRl(void)
-{
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:14:02 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:14:02 +0200
Subject: [Dsa-hl-svn] r3705 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211014.l7LAE2eU024999@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:13:54 +0200 (Tue, 21 Aug 2007)
New Revision: 3705

Added:
   rl/trunk/engine/ai/src/AimlParserImplRl.cpp
Removed:
   rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/AimlParserImplRl.cpp (from rev 3704, rl/trunk/engine/dialog/src/AimlParserImplRl.cpp)

Deleted: rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-08-21 10:13:38 UTC (rev 3704)
+++ rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-08-21 10:13:54 UTC (rev 3705)
@@ -1,69 +0,0 @@
-
-#include "stdinc.h"
-
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/parsers/XercesDOMParser.hpp>
-#include <xercesc/sax/HandlerBase.hpp>
-#include "AimlParserImplRl.h"
-#include "XmlResourceManager.h"
-#include "XmlMapper/XmlDocument.h"
-#include "AimlNodeImplRl.h"
-#include "Logger.h"
-
-// needed for resources
-#include "CoreSubsystem.h"
-#include "ContentModule.h"
-
-using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
-
-namespace rl {
-
-
-AimlParserImplRl::~AimlParserImplRl(void)
-{
-}
-
-XmlDocument<CeGuiString>* AimlParserImplRl::parse(const CeGuiString& fileName)
-{
-	XercesDOMParser parser;// = new XercesDOMParser();
-
-	parser.setIncludeIgnorableWhitespace(false);
-	parser.setDoNamespaces(true);
-
-	XmlPtr res = getXmlResource(fileName);
-
-    bool result = res->parseBy(&parser);
-
-    if(result)
-    {
-        XERCES_CPP_NAMESPACE::DOMDocument* doc = parser.getDocument();
-	    XERCES_CPP_NAMESPACE::DOMElement* test = doc->getDocumentElement();
-	    XmlNode<CeGuiString>* rootNode = new AimlNodeImplRl(doc->getDocumentElement());
-	    return (new XmlDocument<CeGuiString>(rootNode));
-    }
-    std::string message = "File '"+ std::string(fileName.c_str()) +"' could not be parsed.";
-    message += "Possible reason: Wrong file format.";
-    LOG_ERROR(Logger::DIALOG, message );
-    return NULL;
-}
-
-ResourcePtr AimlParserImplRl::getXmlResource(const CeGuiString& fileName)
-{
-	ResourcePtr res = XmlResourceManager::getSingleton().getByName(fileName.c_str());
-
-    if (res.isNull())
-    {
-        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
-        if (ResourceGroupManager::getSingleton().resourceExists(
-			CoreSubsystem::getSingleton().getActiveAdventureModule()->getId(), fileName.c_str()))
-        {
-            group = CoreSubsystem::getSingleton().getActiveAdventureModule()->getId();
-        }
-		res = XmlResourceManager::getSingleton().create(fileName.c_str(), group);
-
-    }
-    return res;
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:14:14 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:14:14 +0200
Subject: [Dsa-hl-svn] r3706 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211014.l7LAEE1H025038@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:14:08 +0200 (Tue, 21 Aug 2007)
New Revision: 3706

Added:
   rl/trunk/engine/ai/src/ContextConditionProcessor.cpp
Removed:
   rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/ContextConditionProcessor.cpp (from rev 3705, rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp)

Deleted: rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-08-21 10:13:54 UTC (rev 3705)
+++ rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-08-21 10:14:08 UTC (rev 3706)
@@ -1,108 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "ContextConditionProcessor.h"
-#include "Creature.h"
-#include "Exception.h"
-#include "Logger.h"
-
-namespace rl {
-
-ContextConditionProcessor::ContextConditionProcessor(void)
-	: XmlNodeProcessor<Response, AimlBot, CeGuiString, false>("contextCondition")
-{
-	initialize();
-}
-
-ContextConditionProcessor::~ContextConditionProcessor(void)
-{
-}
-
-void ContextConditionProcessor::initialize()
-{
-	addAllowedSubProcessor("li");
-	addAttribute("mod");
-	addAttribute("type");
-	addAttribute("name");
-	addAttribute("value");
-}
-
-void ContextConditionProcessor::preprocessStep()
-{
-	mPredicateValue.clear();
-	mNodeValue.clear();
-	mCurrentReturnValue.clear();
-    RlAssert(mCurrentHelper != NULL, "No AimlBot found");
-	try
-	{
-		LOG_MESSAGE(Logger::DIALOG, "ContextCondition: getPredciates");
-        Predicates<CeGuiString>* predicates = NULL;
-		if(mAttributes["type"].find("probe") != CeGuiString::npos)
-		{
-			predicates = mCurrentHelper->getPredicates(mAttributes["type"]);
-            if( predicates == NULL )
-            {
-                CeGuiString message = "No predicate found with type: " + mAttributes["type"];
-                Throw( NullPointerException, message.c_str() );
-            }
-            predicates->setPredicate("mod", mAttributes["mod"]);
-		}
-		predicates = mCurrentHelper->getPredicates(mAttributes["type"]);
-        if( predicates == NULL )
-        {
-          CeGuiString message = "No predicate found with type: " + mAttributes["type"];
-          Throw( NullPointerException, message.c_str() );
-        }
-        mPredicateValue = predicates->getPredicate(mAttributes["name"]);
-
-		if(!mAttributes["value"].empty())
-		{
-			mNodeValue = mAttributes["value"];
-		}
-	}
-	catch(...)
-	{
-	}
-}
-
-void ContextConditionProcessor::processChildStep(XmlNode<CeGuiString>* pChild)
-{
-	mNodeValue.c_str();
-	mPredicateValue.c_str();
-	CeGuiString value = mNodeValue;
-	if(value.empty())
-	{
-		value = pChild->getAttribute("value");
-	}
-	value.c_str();
-	CeGuiString logMessage = "evaluated <li> with id " + pChild->getAttribute("id") + ". ";
-    logMessage += "Condition Value: " + value + " List(<li>) Value: " + mPredicateValue;
-    logMessage += "result: ";
-	CeGuiString result = "false";
-	if(mPredicateValue == value)
-	{
-		mCurrentReturnValue += pChild;
-		result = "true";
-	}
-	LOG_DEBUG(Logger::DIALOG, logMessage + result);
-}
-
-void ContextConditionProcessor::postprocessStep()
-{
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:14:21 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:14:21 +0200
Subject: [Dsa-hl-svn] r3707 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211014.l7LAEL9G025117@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:14:18 +0200 (Tue, 21 Aug 2007)
New Revision: 3707

Added:
   rl/trunk/engine/ai/src/ContextInterpreter.cpp
Removed:
   rl/trunk/engine/dialog/src/ContextInterpreter.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/ContextInterpreter.cpp (from rev 3706, rl/trunk/engine/dialog/src/ContextInterpreter.cpp)

Deleted: rl/trunk/engine/dialog/src/ContextInterpreter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-08-21 10:14:08 UTC (rev 3706)
+++ rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-08-21 10:14:18 UTC (rev 3707)
@@ -1,191 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "ContextInterpreter.h"
-#include "ContextConditionProcessor.h"
-#include "ScriptProcessor.h"
-#include "DialogResponse.h"
-#include "DialogOption.h"
-#include "AimlBot.h"
-
-using namespace std;
-
-namespace rl {
-
-CeGuiString ContextInterpreter::INTERPRETER_NAME = "contextInterpreter";
-CeGuiString ContextInterpreter::RL_TYPE = "rldialog:type";
-CeGuiString ContextInterpreter::RL_LI_ID = "rldialog:id";
-CeGuiString ContextInterpreter::RL_PATTERN_REF = "rldialog:patternRef";
-CeGuiString ContextInterpreter::RL_E_PROBE = "eigenschaftsprobe";
-CeGuiString ContextInterpreter::RL_E_MODIFIER = " (E) ";
-CeGuiString ContextInterpreter::RL_T_PROBE = "talentprobe";
-CeGuiString ContextInterpreter::RL_T_MODIFIER = " (T) ";
-CeGuiString ContextInterpreter::RL_RESPONSE = "response";
-CeGuiString ContextInterpreter::RL_OPTION = "option";
-CeGuiString ContextInterpreter::RL_SELECTION = "selection";
-CeGuiString ContextInterpreter::AIML_CONDITION = "condition";
-CeGuiString ContextInterpreter::AIML_TYPE = "type";
-CeGuiString ContextInterpreter::AIML_GOSSIP = "gossip";
-CeGuiString ContextInterpreter::AIML_LI = "li";
-
-ContextInterpreter::ContextInterpreter(void)
-	: AimlInterpreter<CeGuiString>(INTERPRETER_NAME), mBot(NULL)
-{
-	initialize();
-}
-
-ContextInterpreter::~ContextInterpreter(void)
-{
-}
-
-void ContextInterpreter::processResponse()
-{
-//  now we have one response with several <li>s. those <li>s should be processed
-	Response<CeGuiString>::GossipData gossip = mReturnValue.getGossip();
-	Response<CeGuiString>::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)->getNodeName() == AIML_LI)
-		{
-			CeGuiString id = (*itr)->getAttribute(RL_LI_ID);
-			id.c_str();
-			CeGuiString text = getProcessor(AIML_LI)->process(*itr, mBot).getResponse();
-			text.c_str();
-			mResponses.push_back(make_pair<CeGuiString, CeGuiString>(id, text));
-		}
-	}
-}
-
-void ContextInterpreter::processOption()
-{
-	Response<CeGuiString>::GossipData gossip = mReturnValue.getGossip();
-	Response<CeGuiString>::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)->getNodeName() == AIML_LI)
-		{
-			Response<CeGuiString> response = getProcessor(AIML_LI)->process(*itr, mBot);
-		//  check if this option is influenced by a condition check
-			XmlNode<CeGuiString>* pChild = (*itr)->getFirstChild();
-			for(; pChild != NULL; pChild = pChild->getNextSibling())
-			{
-				if(pChild->getNodeName() == AIML_CONDITION)
-				{
-					CeGuiString type = pChild->getAttribute(AIML_TYPE);
-					if(type == RL_E_PROBE)
-					{
-						response += RL_E_MODIFIER;
-					}
-					else if(type == RL_T_PROBE)
-					{
-						response += RL_T_MODIFIER;
-					}
-				}
-			}
-			DialogOption* option = new DialogOption(response, mBot);
-			option->setId((*itr)->getAttribute(RL_LI_ID));
-			option->setPattern((*itr)->getAttribute(RL_PATTERN_REF));
-			mOptions.push_back(option);
-		}
-		else
-		{
-			// exception or logging...
-		}
-	}
-}
-
-void ContextInterpreter::processSelection()
-{
-	Response<CeGuiString>::GossipData gossip = mReturnValue.getGossip();
-	Response<CeGuiString>::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)->getNodeName() == AIML_LI)
-		{
-			DialogOption* option = new DialogOption(getProcessor(AIML_LI)->process(*itr));
-			option->setId((*itr)->getAttribute(RL_LI_ID));
-			option->setPattern((*itr)->getAttribute(RL_PATTERN_REF));
-			mOptions.push_back(option);
-		}
-	}
-}
-
-DialogResponse* ContextInterpreter::interpret(const Response<CeGuiString>::GossipData& pData, AimlBot<CeGuiString>* pProcessHelper)
-{
-	mOptions.clear();
-	mResponses.clear();
-	mBot = pProcessHelper;
-	CeGuiString type;
-	Response<CeGuiString>::GossipData::const_iterator itr = pData.begin();
-	for(; itr != pData.end(); ++itr)
-	{
-		mCurrentType = (*itr)->getAttribute(RL_TYPE);
-		mCurrentType.c_str();
-		pProcessHelper->getPredicates("default")->setPredicate("contextType", mCurrentType);
-		process( (*itr), pProcessHelper);
-	}
-	pProcessHelper->getPredicates("default")->setPredicate("contextType", "");
-	return new DialogResponse(mResponses, mOptions, pProcessHelper);
-}
-
-Response<CeGuiString> ContextInterpreter
-			::process(XmlNode<CeGuiString>* pNode, AimlBot<CeGuiString>* pProcessHelper)
-{
-//  pNode == gossip
-	Response<CeGuiString> response;
-	XmlNode<CeGuiString>* child = pNode->getFirstChild();
-	for(; child != NULL; child = child->getNextSibling(), mReturnValue.clear())
-	{
-		if(child->getNodeName() == AIML_LI)
-		{
-		//	add the li-node to the responses gossip data
-			mReturnValue += child;
-		}
-		else if(child->getNodeName() == AIML_CONDITION)
-		{
-		//	add a list of valid li-nodes to the gossip data of the repsonse
-			LOG_MESSAGE(Logger::DIALOG, "process condition in context" + mCurrentType);
-			mReturnValue += getProcessor("contextCondition")
-					->process(child, pProcessHelper);
-		}
-	//	process the returnValue for the specific context
-		if(mCurrentType == RL_RESPONSE && pNode->getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, "process response");
-			processResponse();
-		}
-		else if(mCurrentType == RL_OPTION && pNode->getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, "process option");
-			processOption();
-		}
-		else if(mCurrentType == RL_SELECTION && pNode->getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, "process selection");
-			processSelection();
-		}
-	}
-	return response;
-}
-
-void ContextInterpreter::initialize()
-{
-	addProcessor(new ContextConditionProcessor());
-	addProcessor(new ScriptProcessor());
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:14:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:14:36 +0200
Subject: [Dsa-hl-svn] r3708 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211014.l7LAEag5025295@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:14:29 +0200 (Tue, 21 Aug 2007)
New Revision: 3708

Added:
   rl/trunk/engine/ai/src/DialogCharacter.cpp
Removed:
   rl/trunk/engine/dialog/src/DialogCharacter.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/DialogCharacter.cpp (from rev 3707, rl/trunk/engine/dialog/src/DialogCharacter.cpp)

Deleted: rl/trunk/engine/dialog/src/DialogCharacter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-08-21 10:14:18 UTC (rev 3707)
+++ rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-08-21 10:14:29 UTC (rev 3708)
@@ -1,145 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "DialogCharacter.h"
-#include "DialogSubsystem.h"
-#include "ContextInterpreter.h"
-#include "AimlBot.h"
-#include "Response.h"
-
-#include "Predicates.h"
-#include "EigenschaftsProbePredicates.h"
-#include "EigenschaftsWertPredicates.h"
-#include "QuestKnownPredicates.h"
-#include "QuestPartsPredicates.h"
-#include "QuestStatePredicates.h"
-#include "ScriptPredicates.h"
-#include "TalentProbePredicates.h"
-#include "TalentWertPredicates.h"
-#include "GrundWertPredicates.h"
-
-
-namespace rl
-{
-	DialogCharacter::DialogCharacter()
-		: mActive(false),
-		  mBot(NULL),
-		  mNonPlayerCharacter(NULL),
-		  mPlayerCharacter(NULL)
-	{
-	}
-
-	DialogCharacter::~DialogCharacter(void)
-	{
-		if(mBot)
-		{
-			delete mBot;
-		}
-	}
-
-	void DialogCharacter::initialize()
-	{
-	//  add additional predicates
-		if(mBot != NULL)
-		{
-			mBot->addPredicates(new EigenschaftsProbePredicates(mPlayerCharacter));
-			mBot->addPredicates(new EigenschaftsWertPredicates(mPlayerCharacter));
-			mBot->addPredicates(new QuestKnownPredicates());
-			mBot->addPredicates(new QuestPartsPredicates());
-			mBot->addPredicates(new QuestStatePredicates());
-			mBot->addPredicates(new ScriptPredicates(this));
-			mBot->addPredicates(new TalentProbePredicates(mPlayerCharacter));
-			mBot->addPredicates(new TalentWertPredicates(mPlayerCharacter));
-			mBot->addPredicates(new GrundWertPredicates(mPlayerCharacter));
-		}
-	}
-
-/*	void DialogCharacter::addDialogListener(DialogListener* listener)
-	{
-		mDialogListener.push_back(listener);
-	}
-
-	void DialogCharacter::removeDialogListener(DialogListener* listener)
-	{
-		mDialogListener.remove(listener);
-	}
-	void DialogCharacter::updateDialogListeners(DialogListener::DialogEvent e)
-	{
-		Listeners::iterator itr = mDialogListener.begin();
-		for(; itr != mDialogListener.end(); ++itr)
-		{
-			(*itr)->onDialogEvent(e);
-		}
-	}
-*/
-
-    bool DialogCharacter::hasExitRequest() const
-    {
-        return mBot->hasExitRequest();
-    }
-
-	const CeGuiString DialogCharacter::getName() const
-	{
-		return mBot->getName();
-	}
-
-	Predicates<CeGuiString>* DialogCharacter::getPredicates(const CeGuiString& pType)
-	{
-		return mBot->getPredicates(pType);
-	}
-
-	DialogResponse* DialogCharacter::createResponse(const CeGuiString& input)
-	{
-//		DialogListener::DialogEvent dialogEvent = DialogListener::DIALOG_RESPONSE;
-		if(!mActive)
-		{
-			mActive=true;
-//			dialogEvent = DialogListener::DIALOG_START;
-		}
-		input.c_str();
-		DialogResponse* dialogResponse = NULL;
-		LOG_MESSAGE(Logger::DIALOG, "Create AIML response");
-		Response<CeGuiString> response = mBot->respond(input);
-		if(response.hasGossip())
-		{
-			ContextInterpreter* interpreter = DialogSubsystem::getSingleton().getContextInterpreter();
-			if(interpreter!= NULL)
-			{
-				LOG_MESSAGE(Logger::DIALOG, "Create DialogResponse");
-				dialogResponse = interpreter->interpret(response.getGossip(), mBot);
-			}
-		}
-		// why check for response.empty()???
-		if(response.empty() || dialogResponse == NULL)
-		{
-			mActive = false;
-//			dialogEvent = DialogListener::DIALOG_END;
-		}
-//		updateDialogListeners(dialogEvent);
-		return dialogResponse;
-	}
-
-	void DialogCharacter::setVoiceFile(const CeGuiString& filename)
-	{
-		mBot->setVoice(filename);
-	}
-
-	const CeGuiString& DialogCharacter::getVoiceFile() const
-	{
-		return mBot->getVoice();
-	}
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:14:57 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:14:57 +0200
Subject: [Dsa-hl-svn] r3709 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211014.l7LAEvW5025306@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:14:51 +0200 (Tue, 21 Aug 2007)
New Revision: 3709

Added:
   rl/trunk/engine/ai/src/DialogOption.cpp
Removed:
   rl/trunk/engine/dialog/src/DialogOption.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/DialogOption.cpp (from rev 3708, rl/trunk/engine/dialog/src/DialogOption.cpp)

Deleted: rl/trunk/engine/dialog/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogOption.cpp	2007-08-21 10:14:29 UTC (rev 3708)
+++ rl/trunk/engine/dialog/src/DialogOption.cpp	2007-08-21 10:14:51 UTC (rev 3709)
@@ -1,64 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "DialogOption.h"
-#include "DialogResponse.h"
-#include "DialogSubsystem.h"
-#include "ContextInterpreter.h"
-#include "Response.h"
-
-namespace rl {
-
-DialogOption::DialogOption(const Response<CeGuiString>& pData, AimlBot<CeGuiString>* pBot)
-	: mBot(pBot), mData(new Response<CeGuiString>(pData))
-{
-}
-
-DialogOption::~DialogOption(void)
-{
-	if(mData)
-	{
-		delete mData;
-	}
-}
-
-const CeGuiString& DialogOption::getText() const
-{
-	return mData->getResponse();
-}
-
-void DialogOption::processSelection()
-{
-	DialogResponse* response = NULL;
-	ContextInterpreter* interpreter = DialogSubsystem::getSingleton().getContextInterpreter();
-	if(interpreter != NULL)
-	{
-		response = interpreter->interpret(mData->getGossip(), mBot);
-		LOG_MESSAGE(Logger::DIALOG, "Parsed selected option");
-		if(response != NULL && !response->getDialogOptions().empty())
-		{
-			DialogOption* option = (*response->getDialogOptions().begin());
-			mData->clear();
-			(*mData) += option->getText();
-			mId = option->getId();
-			mPatternId = option->getPattern();
-			delete response;
-		}
-	}
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:15:07 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:15:07 +0200
Subject: [Dsa-hl-svn] r3710 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211015.l7LAF7L3025348@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:15:02 +0200 (Tue, 21 Aug 2007)
New Revision: 3710

Added:
   rl/trunk/engine/ai/src/DialogResponse.cpp
Removed:
   rl/trunk/engine/dialog/src/DialogResponse.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/DialogResponse.cpp (from rev 3709, rl/trunk/engine/dialog/src/DialogResponse.cpp)

Deleted: rl/trunk/engine/dialog/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-08-21 10:14:51 UTC (rev 3709)
+++ rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-08-21 10:15:02 UTC (rev 3710)
@@ -1,63 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <xercesc/parsers/XercesDOMParser.hpp>
-#include <xercesc/framework/MemBufInputSource.hpp>
-#include <xercesc/dom/DOM.hpp>
-
-#include <CEGUIPropertyHelper.h>
-
-#include "XmlHelper.h"
-//#include "AimlProcessorManager.h"
-//#include "AimlProcessor.h"
-#include "DialogResponse.h"
-#include "DialogOption.h"
-
-
-namespace rl
-{
-	DialogResponse::DialogResponse( const CeGuiString& input,
-									const CeGuiString& response,
-									const Options& currentOptions,
-									const Options& selectableOptions,
-									NaturalLanguageProcessor* nlp)
-		:	mInput(input),
-			mResponse(response),
-			mCurrentOptions(currentOptions),
-			mSelectableOptions(selectableOptions),
-			mNlp(nlp)
-	{
-	}
-
-	DialogResponse::DialogResponse( const Responses &responses,
-									const DialogOptions &options,
-									AimlBot<CeGuiString>* bot)
-		: mResponses(responses),
-		  mOptions(options),
-		  mBot(bot)
-	{
-	}
-
-	DialogResponse::~DialogResponse(void)
-	{
-		DialogOptions::iterator itr = mOptions.begin();
-		for(; itr != mOptions.end(); ++itr)
-		{
-			delete (*itr);
-		}
-	}
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:15:24 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:15:24 +0200
Subject: [Dsa-hl-svn] r3711 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211015.l7LAFO91025365@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:15:15 +0200 (Tue, 21 Aug 2007)
New Revision: 3711

Added:
   rl/trunk/engine/ai/src/DialogScriptProcessor.cpp
Removed:
   rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/DialogScriptProcessor.cpp (from rev 3710, rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp)

Deleted: rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-08-21 10:15:02 UTC (rev 3710)
+++ rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-08-21 10:15:15 UTC (rev 3711)
@@ -1,57 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "DialogScriptProcessor.h"
-#include "CoreSubsystem.h"
-#include "RubyInterpreter.h"
-
-namespace rl {
-
-DialogScriptProcessor::DialogScriptProcessor()
-	: XmlNodeProcessor<AimlBot, AimlCore, CeGuiString>("script")
-{
-	initialize();
-}
-
-DialogScriptProcessor::~DialogScriptProcessor()
-{
-}
-
-void DialogScriptProcessor::initialize()
-{
-	addAttribute("src");
-	addAttribute("class");
-}
-
-void DialogScriptProcessor::preprocessStep()
-{
-	if( !(mAttributes["src"].empty() && mAttributes["class"].empty() ) )
-	{
-		CoreSubsystem::getSingleton().getRubyInterpreter()
-			->execute(("load \"" + mAttributes["src"] + "\"").c_str());
-	//  create the string for instanciating the class
-		std::stringstream newDialogScriptObject;
-				newDialogScriptObject << "DialogSubsystem.getSingleton()";
-				newDialogScriptObject << ".setCurrentDialogCharacter(";
-				newDialogScriptObject << mAttributes["class"].c_str() << ".new())";
-				// execute the ruby command
-				CoreSubsystem::getSingleton().getRubyInterpreter()
-					->execute(newDialogScriptObject.str());
-	}
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:15:39 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:15:39 +0200
Subject: [Dsa-hl-svn] r3712 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211015.l7LAFdpJ025381@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:15:33 +0200 (Tue, 21 Aug 2007)
New Revision: 3712

Added:
   rl/trunk/engine/ai/src/DialogSubsystem.cpp
Removed:
   rl/trunk/engine/dialog/src/DialogSubsystem.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/DialogSubsystem.cpp (from rev 3711, rl/trunk/engine/dialog/src/DialogSubsystem.cpp)

Deleted: rl/trunk/engine/dialog/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-08-21 10:15:15 UTC (rev 3711)
+++ rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-08-21 10:15:33 UTC (rev 3712)
@@ -1,150 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <xercesc/util/PlatformUtils.hpp>
-
-#include "XmlHelper.h"
-#include "XmlResourceManager.h"
-#include "Logger.h"
-#include "CoreSubsystem.h"
-#include "ContentModule.h"
-
-#include "DialogSubsystem.h"
-#include "AimlCore.h"
-#include "AimlParserImplRl.h"
-#include "DialogCharacter.h"
-#include "ScriptProcessor.h"
-#include "DialogScriptProcessor.h"
-#include "ContextInterpreter.h"
-
-using namespace Ogre;
-using namespace MadaBot;
-using namespace XERCES_CPP_NAMESPACE;
-
-template<> rl::DialogSubsystem* Singleton<rl::DialogSubsystem>::ms_Singleton = 0;
-
-namespace rl {
-
-DialogSubsystem::DialogSubsystem()
-	: mCore(new AimlCore()),
-	  mContextInterpreter(new ContextInterpreter()),
-	  mCurrentBot(NULL)
-{
-	LOG_MESSAGE(Logger::DIALOG, "Init Start");
-	initialize();
-	LOG_MESSAGE(Logger::DIALOG, "Init Ende");
-}
-
-DialogSubsystem::~DialogSubsystem()
-{
-	delete mCore;
-	delete mContextInterpreter;
-
-	for(BotMap::iterator iter = mBots.begin();
-		iter != mBots.end();
-		++iter)
-	{
-		delete iter->second;
-	}
-}
-
-void DialogSubsystem::initialize()
-{
-#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
-    setlocale(LC_ALL, "C");
-#endif
-
-	mCore->setParser(new AimlParserImplRl());
-	mCore->getBotInterpreter().addProcessor(new DialogScriptProcessor());
-	mCore->getAimlInterpreter().addProcessor(new ScriptProcessor());
-//  Initialize Xerces if this wasn't done already
-	try
-	{
-        XMLPlatformUtils::Initialize();
-		XmlHelper::initializeTranscoder();
-    }
-    catch (const XMLException& exc)
-	{
-		char* excmsg = XMLString::transcode(exc.getMessage());
-		std::string excs="Exception while initializing Xerces: ";
-		excs+=excmsg;
-		LOG_MESSAGE(Logger::DIALOG, excs);
-        XMLString::release(&excmsg);
-    }
-}
-
-DialogCharacter* DialogSubsystem::getBot(const CeGuiString& botName)
-{
-	BotMap::iterator itr = mBots.find(botName);
-	if(itr != mBots.end())
-	{
-		return itr->second;
-	}
-	return NULL;
-}
-
-
-DialogCharacter* DialogSubsystem::loadBot(const CeGuiString& botName, const CeGuiString& fileName)
-{
-	mCurrentBot = NULL;
-	AimlBot<CeGuiString>* bot = mCore->loadBot(botName.c_str(), fileName.c_str());
-//  while processing the bot definition, a DialogCharacter should have been created
-//  through a ruby script and stored in mCurrentBot
-    if (mCurrentBot == NULL)
-    {
-        mCurrentBot = new DialogCharacter();
-    }
-
-	if(bot != NULL)
-	{
-		mCurrentBot->setBot(bot);
-		mCurrentBot->initialize();
-	}
-	LOG_MESSAGE(Logger::DIALOG,"AimlBot " + botName + "loaded and initialized");
-	mBots.insert(BotMap::value_type(mCurrentBot->getName(), mCurrentBot));
-	return mCurrentBot;
-}
-
-ResourcePtr DialogSubsystem::getXmlResource(const Ogre::String& filename)
-{
-    ResourcePtr res = XmlResourceManager::getSingleton().getByName(filename);
-
-    if (res.isNull())
-    {
-        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
-        if (ResourceGroupManager::getSingleton().resourceExists(
-			CoreSubsystem::getSingleton().getActiveAdventureModule()->getId(), filename))
-        {
-            group = CoreSubsystem::getSingleton().getActiveAdventureModule()->getId();
-        }
-        res = XmlResourceManager::getSingleton().create(filename, group);
-
-    }
-    return res;
-}
-
-void DialogSubsystem::setCurrentDialogCharacter(DialogCharacter* bot)
-{
-	mCurrentBot = bot;
-}
-
-DialogCharacter* DialogSubsystem::getCurrentDialogCharacter() const
-{
-    return mCurrentBot;
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:16:06 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:16:06 +0200
Subject: [Dsa-hl-svn] r3713 - in rl/trunk/engine: ai/src dialog/src
Message-ID: <200708211016.l7LAG6fD025409@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:15:58 +0200 (Tue, 21 Aug 2007)
New Revision: 3713

Added:
   rl/trunk/engine/ai/src/ScriptProcessor.cpp
Removed:
   rl/trunk/engine/dialog/src/ScriptProcessor.cpp
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/src/ScriptProcessor.cpp (from rev 3712, rl/trunk/engine/dialog/src/ScriptProcessor.cpp)

Deleted: rl/trunk/engine/dialog/src/ScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-08-21 10:15:33 UTC (rev 3712)
+++ rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-08-21 10:15:58 UTC (rev 3713)
@@ -1,59 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "ScriptProcessor.h"
-#include "CoreSubsystem.h"
-#include "RubyInterpreter.h"
-#include "Exception.h"
-
-namespace rl {
-
-ScriptProcessor::ScriptProcessor(void)
-	: XmlNodeProcessor<Response, AimlBot, CeGuiString, false>("script")
-{
-	initialize();
-}
-
-ScriptProcessor::~ScriptProcessor(void)
-{
-}
-
-void ScriptProcessor::initialize()
-{
-	addAttribute("src");
-	mProcessChildren = false;
-}
-
-void ScriptProcessor::preprocessStep()
-{
-	if( !(mAttributes["src"].empty()))
-	{
-		CoreSubsystem::getSingleton().getRubyInterpreter()
-			->execute(("load \"" + mAttributes["src"] + "\"").c_str());
-		return;
-	}
-	if(mCurrentNode->getFirstChild() == NULL)
-	{
-		Throw(NullPointerException, "no text node found in script tag");
-	}
-	// execute the value of the text node
-	CoreSubsystem::getSingleton().getRubyInterpreter()
-		->execute(mCurrentNode->getFirstChild()->getNodeValue().c_str());
-
-}
-
-}



From blakharaz at mail.berlios.de  Tue Aug 21 12:18:19 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:18:19 +0200
Subject: [Dsa-hl-svn] r3714 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211018.l7LAIJEO025446@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:18:09 +0200 (Tue, 21 Aug 2007)
New Revision: 3714

Added:
   rl/trunk/engine/ai/include/predicates/
Removed:
   rl/trunk/engine/dialog/include/predicates/
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/predicates (from rev 3713, rl/trunk/engine/dialog/include/predicates)



From blakharaz at mail.berlios.de  Tue Aug 21 12:18:34 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:18:34 +0200
Subject: [Dsa-hl-svn] r3715 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211018.l7LAIYmp025457@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:18:29 +0200 (Tue, 21 Aug 2007)
New Revision: 3715

Added:
   rl/trunk/engine/ai/include/AimlNodeImplRl.h
Removed:
   rl/trunk/engine/dialog/include/AimlNodeImplRl.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/AimlNodeImplRl.h (from rev 3714, rl/trunk/engine/dialog/include/AimlNodeImplRl.h)

Deleted: rl/trunk/engine/dialog/include/AimlNodeImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-08-21 10:18:09 UTC (rev 3714)
+++ rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-08-21 10:18:29 UTC (rev 3715)
@@ -1,43 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_AimlNodeImplRl_H__
-#define __Rl_AimlNodeImplRl_H__
-
-#include "DialogPrerequisites.h"
-#include "AimlNode.h"
-
-using namespace MadaBot;
-namespace rl
-{
-	XERCES_CPP_NAMESPACE_USE
-	class XERCES_CPP_NAMESPACE::DOMNode;
-
-    /**
-     * Implementation of the XmlNode interface for AIML files in Rastullahs Lockenpracht
-     */
-	class AimlNodeImplRl :	public AimlNode<CeGuiString>
-	{
-	public:
-		AimlNodeImplRl(DOMNode* node);
-		virtual ~AimlNodeImplRl(void);
-	//	void setNodeValue(const XmlString& v){}
-
-		bool isElement(){ return false;}
-
-	private:
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:18:52 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:18:52 +0200
Subject: [Dsa-hl-svn] r3716 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211018.l7LAIqcr025472@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:18:44 +0200 (Tue, 21 Aug 2007)
New Revision: 3716

Added:
   rl/trunk/engine/ai/include/AimlParserImplRl.h
Removed:
   rl/trunk/engine/dialog/include/AimlParserImplRl.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/AimlParserImplRl.h (from rev 3715, rl/trunk/engine/dialog/include/AimlParserImplRl.h)

Deleted: rl/trunk/engine/dialog/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-08-21 10:18:29 UTC (rev 3715)
+++ rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-08-21 10:18:44 UTC (rev 3716)
@@ -1,42 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_AimlParserImplRl_H__
-#define __Rl_AimlParserImplRl_H__
-
-#include "DialogPrerequisites.h"
-#include "XmlMapper/XmlParser.h"
-
-#include <OgreResource.h>
-
-using namespace XmlMapper;
-
-namespace rl
-{
-    /**
-     * Implementation of the XmlParser interface for AIML files in Rastullahs Lockenpracht
-     */
-	class AimlParserImplRl : public XmlParser<CeGuiString>
-	{
-	public:
-		virtual ~AimlParserImplRl();
-		
-		virtual XmlDocument<CeGuiString>* parse(const CeGuiString& fileName);
-
-	private:
-		Ogre::ResourcePtr getXmlResource(const CeGuiString& fileName);
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:19:14 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:19:14 +0200
Subject: [Dsa-hl-svn] r3717 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211019.l7LAJEqQ025498@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:19:08 +0200 (Tue, 21 Aug 2007)
New Revision: 3717

Added:
   rl/trunk/engine/ai/include/ContextConditionProcessor.h
Removed:
   rl/trunk/engine/dialog/include/ContextConditionProcessor.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/ContextConditionProcessor.h (from rev 3716, rl/trunk/engine/dialog/include/ContextConditionProcessor.h)

Deleted: rl/trunk/engine/dialog/include/ContextConditionProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-08-21 10:18:44 UTC (rev 3716)
+++ rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-08-21 10:19:08 UTC (rev 3717)
@@ -1,60 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_ContextConditionProcessor_H__
-#define __Rl_ContextConditionProcessor_H__
-
-#include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
-#include "AimlBot.h"
-
-using namespace XmlMapper;
-using namespace MadaBot;
-
-namespace rl
-{
-    /**
-     * Special ConditionProcessor for processing conditions that are a ChildNode
-     * of a specific gossip context
-     */
-	class ContextConditionProcessor 
-		: public XmlNodeProcessor<Response, AimlBot, CeGuiString, false>
-	{
-	public:
-		ContextConditionProcessor(void); 
-		virtual ~ContextConditionProcessor(void);
-		
-        /**
-         * Get the needed Predicates of an AimlBot for preparing the processing of a 
-         * condition
-         */
-		virtual void preprocessStep();
-
-        /**
-         * Evaluates every ChildNode of the condition if it is a ListItem (<li>)
-         */
-		virtual void processChildStep(XmlNode<CeGuiString>* pChild);
-
-        /**
-         * Not used in this processor
-         */
-		virtual void postprocessStep();
-	protected:
-		virtual void initialize();
-		CeGuiString mPredicateValue;
-		CeGuiString mNodeValue;
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:19:25 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:19:25 +0200
Subject: [Dsa-hl-svn] r3718 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211019.l7LAJPdg025516@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:19:18 +0200 (Tue, 21 Aug 2007)
New Revision: 3718

Added:
   rl/trunk/engine/ai/include/ContextInterpreter.h
Removed:
   rl/trunk/engine/dialog/include/ContextInterpreter.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/ContextInterpreter.h (from rev 3717, rl/trunk/engine/dialog/include/ContextInterpreter.h)

Deleted: rl/trunk/engine/dialog/include/ContextInterpreter.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-08-21 10:19:08 UTC (rev 3717)
+++ rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-08-21 10:19:18 UTC (rev 3718)
@@ -1,71 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_AimlContextInterpreter_H__
-#define __Rl_AimlContextInterpreter_H__
-
-#include "AimlInterpreter.h"
-#include "DialogPrerequisites.h"
-#include "DialogResponse.h"
-using namespace MadaBot;
-
-namespace rl
-{
-	/**
-	 * Uses the AIML element "gossip" to interpret the childNodes in a 
-	 * specific context for dialog options/selections/responses
-	 * 
-	 */
-	class ContextInterpreter
-		: public AimlInterpreter<CeGuiString>
-	{
-	public:
-		ContextInterpreter(void);
-		virtual ~ContextInterpreter(void);
-
-		DialogResponse* interpret(const Response<CeGuiString>::GossipData& pData, AimlBot<CeGuiString>* pProcessHelper=NULL);
-		virtual Response<CeGuiString> process(XmlNode<CeGuiString>* pNode, AimlBot<CeGuiString>* pProcessHelper=NULL);
-		
-		void processResponse();
-		void processOption();
-		void processSelection();
-	protected:
-		virtual void initialize();
-		AimlBot<CeGuiString>* mBot;
-
-		CeGuiString mCurrentType;
-		DialogResponse::Responses mResponses;
-		DialogResponse::DialogOptions mOptions;
-
-		static CeGuiString INTERPRETER_NAME;
-		static CeGuiString RL_TYPE;
-		static CeGuiString RL_LI_ID;
-		static CeGuiString RL_PATTERN_REF;
-		static CeGuiString RL_E_PROBE;
-		static CeGuiString RL_E_MODIFIER;
-		static CeGuiString RL_T_PROBE;
-		static CeGuiString RL_T_MODIFIER;
-		static CeGuiString RL_RESPONSE;
-		static CeGuiString RL_OPTION;
-		static CeGuiString RL_SELECTION;
-		static CeGuiString AIML_CONDITION;
-		static CeGuiString AIML_TYPE;
-		static CeGuiString AIML_GOSSIP;
-		static CeGuiString AIML_LI;
-
-		
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:19:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:19:36 +0200
Subject: [Dsa-hl-svn] r3719 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211019.l7LAJa0r025537@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:19:29 +0200 (Tue, 21 Aug 2007)
New Revision: 3719

Added:
   rl/trunk/engine/ai/include/DialogCharacter.h
Removed:
   rl/trunk/engine/dialog/include/DialogCharacter.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogCharacter.h (from rev 3718, rl/trunk/engine/dialog/include/DialogCharacter.h)

Deleted: rl/trunk/engine/dialog/include/DialogCharacter.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogCharacter.h	2007-08-21 10:19:18 UTC (rev 3718)
+++ rl/trunk/engine/dialog/include/DialogCharacter.h	2007-08-21 10:19:29 UTC (rev 3719)
@@ -1,162 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_DialogCharacter_H__
-#define __Rl_DialogCharacter_H__
-
-#include "DialogPrerequisites.h"
-//#include "DialogListener.h"
-
-namespace MadaBot
-{
-	template <class S> class AimlBot;
-	template <class S> class Predicates;
-}
-using namespace MadaBot;
-
-namespace rl
-{
-	class Creature;
-	class DialogResponse;
-
-    /**
-     * Representation of a Character that is able to respond in a Dialog
-     * @todo Art der Erstellung ?ndern, das ist zu kompliziert.
-     */
-	class _RlDialogExport DialogCharacter 
-	{
-	public:
-		DialogCharacter();
-	//	DialogCharacter(const CeGuiString& name);
-		virtual ~DialogCharacter(void);
-
-		const CeGuiString getName() const;
-
-		Predicates<CeGuiString>* getPredicates(const CeGuiString& pType);
-
-		// deprecated
-		Creature* getDialogCharacter() const;
-		void setDialogCharacter(Creature* dialogCharacter);
-		Creature* getDialogPartner() const;
-		void setDialogPartner(Creature* dialogPartner);
-
-		void initialize();
-		/**
-		 * SHOULD NOT BE CALLED IN PUBLIC
-		 * set the dialogbot, this is done in DialogSubsystem/AimlCore
-		 */
-		void setBot(AimlBot<CeGuiString>* bot);
-        
-        bool hasExitRequest() const;
-/*		void addDialogListener(DialogListener* listener);
-		void removeDialogListener(DialogListener* listener);
-		void updateDialogListeners(DialogListener::DialogEvent e);
-*/
-		Creature* getNonPlayerCharacter() const;
-		void setNonPlayerCharacter(Creature* npc);
-
-		Creature* getPlayerCharacter() const;
-		void setPlayerCharacter(Creature* pc);
-
-		// not used in script, thereby it can return a reference
-		const CeGuiString& getVoiceFile() const;
-		void setVoiceFile(const CeGuiString& filename);
-
-		/**
-		 * calculation of special condition values
-		 * should have a second parameter "patternValue"
-		 */
-		virtual int calcOptionValue(const CeGuiString& optionName);
-		virtual int calcResponseValue(const CeGuiString& responseName);
-		virtual int calcSelectionValue(const CeGuiString& selectionName);
-
-		DialogResponse* createResponse(const CeGuiString& input);
-		bool isActive(){ return mActive; }
-		
-	private:
-		bool mActive;
-		AimlBot<CeGuiString>* mBot;
-
-		Creature* mNonPlayerCharacter;
-		Creature* mPlayerCharacter;
-
-//		typedef std::list<DialogListener*> Listeners;
-//		Listeners mDialogListener;
-
-	};
-
-	inline void DialogCharacter::setBot(AimlBot<CeGuiString>* bot)
-	{
-		mBot = bot;
-	}
-
-	inline Creature* DialogCharacter::getDialogCharacter() const
-	{
-		return mPlayerCharacter;
-	}
-	
-	inline void DialogCharacter::setDialogCharacter(Creature* dialogCharacter)
-	{
-		mPlayerCharacter = dialogCharacter;
-	}
-
-	inline Creature* DialogCharacter::getPlayerCharacter() const
-	{
-		return mPlayerCharacter;
-	}
-	
-	inline void DialogCharacter::setPlayerCharacter(Creature* pc)
-	{
-		mPlayerCharacter = pc;
-	}
-
-	inline Creature* DialogCharacter::getDialogPartner() const
-	{
-		return mNonPlayerCharacter;
-	}
-
-	inline void DialogCharacter::setDialogPartner(Creature* dialogPartner)
-	{
-		mNonPlayerCharacter = dialogPartner;
-	}
-
-	inline Creature* DialogCharacter::getNonPlayerCharacter() const
-	{
-		return mNonPlayerCharacter;
-	}
-
-	inline void DialogCharacter::setNonPlayerCharacter(Creature* npc)
-	{
-		mNonPlayerCharacter = npc;
-	}
-
-    /// @todo Magic Number.
-    inline int DialogCharacter::calcOptionValue(const CeGuiString& optionName)
-    {
-        return 4;
-    }
-
-	inline int DialogCharacter::calcResponseValue(const CeGuiString& responseName)
-    {
-        return 4;
-    }
-
-	inline int DialogCharacter::calcSelectionValue(const CeGuiString& selectionName)
-    {
-        return 4;
-    }
-}
-
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:19:47 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:19:47 +0200
Subject: [Dsa-hl-svn] r3720 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211019.l7LAJlpt025593@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:19:39 +0200 (Tue, 21 Aug 2007)
New Revision: 3720

Added:
   rl/trunk/engine/ai/include/DialogOption.h
Removed:
   rl/trunk/engine/dialog/include/DialogOption.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogOption.h (from rev 3719, rl/trunk/engine/dialog/include/DialogOption.h)

Deleted: rl/trunk/engine/dialog/include/DialogOption.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogOption.h	2007-08-21 10:19:29 UTC (rev 3719)
+++ rl/trunk/engine/dialog/include/DialogOption.h	2007-08-21 10:19:39 UTC (rev 3720)
@@ -1,75 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_DialogOption_H__
-#define __Rl_DialogOption_H__
-
-#include "DialogPrerequisites.h"
-
-namespace MadaBot
-{
-	template <class S> class AimlBot;
-	template <class S> class Response;
-}
-using namespace MadaBot;
-namespace rl
-{
-    /**
-     * The selectable options a player can choose from in a Dialog
-     */
-	class _RlDialogExport DialogOption
-	{
-	public:
-		DialogOption(const Response<CeGuiString>& pData, AimlBot<CeGuiString>* pBot = NULL);
-		~DialogOption(void);
-
-		/**
-		 * Process through the data of the selection and modify it by possible
-		 * conditions that occure 
-		 * TextData, SoundId and PatternId can be altered after the execution of this method
-		 */
-		void processSelection();
-
-		inline const CeGuiString& getId() const
-		{
-			return mId;
-		}
-
-		inline const CeGuiString& getPattern() const
-		{
-			return mPatternId;
-		}
-
-		const CeGuiString& getText() const;
-
-		inline void setId(const CeGuiString& id)
-		{
-			mId = id;
-		}
-
-		inline void setPattern(const CeGuiString& pattern)
-		{
-			mPatternId = pattern;
-		}
-		
-	private:
-		AimlBot<CeGuiString>* mBot;
-		Response<CeGuiString>* mData;
-		CeGuiString mId;
-		CeGuiString mPatternId;
-		
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:19:57 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:19:57 +0200
Subject: [Dsa-hl-svn] r3721 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211019.l7LAJvLe025637@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:19:51 +0200 (Tue, 21 Aug 2007)
New Revision: 3721

Added:
   rl/trunk/engine/ai/include/DialogPrerequisites.h
Removed:
   rl/trunk/engine/dialog/include/DialogPrerequisites.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogPrerequisites.h (from rev 3720, rl/trunk/engine/dialog/include/DialogPrerequisites.h)

Deleted: rl/trunk/engine/dialog/include/DialogPrerequisites.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-08-21 10:19:39 UTC (rev 3720)
+++ rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-08-21 10:19:51 UTC (rev 3721)
@@ -1,38 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __DialogPrerequisites_H__
-#define __DialogPrerequisites_H__
-
-// Common is only needed for the CeGuiString typedef
-#include "CommonPrerequisites.h"
-
-#include "RastullahPrerequisites.h"
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-// Export control
-#   if defined( RLDIALOG_EXPORTS )
-#       define _RlDialogExport __declspec( dllexport )
-#   else
-#       define _RlDialogExport __declspec( dllimport )
-#   endif
-#else // Linux / Mac OSX etc
-#   define _RlDialogExport
-#endif
-
-#pragma warning (disable : 4251)
-
-#endif
-



From blakharaz at mail.berlios.de  Tue Aug 21 12:20:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:20:09 +0200
Subject: [Dsa-hl-svn] r3722 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211020.l7LAK9ZI025667@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:20:05 +0200 (Tue, 21 Aug 2007)
New Revision: 3722

Added:
   rl/trunk/engine/ai/include/DialogResponse.h
Removed:
   rl/trunk/engine/dialog/include/DialogResponse.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogResponse.h (from rev 3721, rl/trunk/engine/dialog/include/DialogResponse.h)

Deleted: rl/trunk/engine/dialog/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogResponse.h	2007-08-21 10:19:51 UTC (rev 3721)
+++ rl/trunk/engine/dialog/include/DialogResponse.h	2007-08-21 10:20:05 UTC (rev 3722)
@@ -1,76 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_DialogResponse_H__
-#define __Rl_DialogResponse_H__
-
-#include "DialogPrerequisites.h"
-#include "CommonPrerequisites.h"
-
-namespace MadaBot
-{
-	template <class S> class AimlBot;
-}
-using namespace MadaBot;
-
-namespace rl
-{
-	class NaturalLanguageProcessor;
-	class DialogOption;
-
-    /**
-     * The reponse a DialogCharacter can give in a Dialog
-     */
-	class _RlDialogExport DialogResponse
-	{
-	public:
-		typedef std::map<int, CeGuiString> Options;
-		typedef std::list<std::pair<CeGuiString, CeGuiString> > Responses;
-		typedef std::vector<DialogOption*> DialogOptions;
-
-		DialogResponse( const CeGuiString& input, 
-						const CeGuiString& response,
-						const Options& currentOptions, 
-						const Options& selectableOptions,
-						NaturalLanguageProcessor* nlp);
-		DialogResponse( const Responses& responses, 
-						const DialogOptions& options,
-						AimlBot<CeGuiString>* bot);
-		virtual ~DialogResponse(void);
-
-		const Options& getOptions() { return mCurrentOptions; }
-		const CeGuiString& getResponse() { return mResponse;}
-		/**
-		 * @return all options with thier pattern-id
-		 */
-		const DialogOptions& getDialogOptions() { return mOptions;}
-		/**
-		 * @return all responses with their sound id
-		 */
-		const Responses& getResponses() { return mResponses; }
-	private:
-		CeGuiString mInput;
-		CeGuiString mResponse;
-		Options mCurrentOptions;
-		Options mSelectableOptions;
-		
-		Responses mResponses;
-		DialogOptions mOptions;
-		AimlBot<CeGuiString>* mBot;
-
-		NaturalLanguageProcessor* mNlp;
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:20:19 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:20:19 +0200
Subject: [Dsa-hl-svn] r3723 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211020.l7LAKJ95025683@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:20:14 +0200 (Tue, 21 Aug 2007)
New Revision: 3723

Added:
   rl/trunk/engine/ai/include/DialogScriptProcessor.h
Removed:
   rl/trunk/engine/dialog/include/DialogScriptProcessor.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogScriptProcessor.h (from rev 3722, rl/trunk/engine/dialog/include/DialogScriptProcessor.h)

Deleted: rl/trunk/engine/dialog/include/DialogScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-08-21 10:20:05 UTC (rev 3722)
+++ rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-08-21 10:20:14 UTC (rev 3723)
@@ -1,44 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_DialogScriptProcessor_H__
-#define __Rl_DialogScriptProcessor_H__
-
-#include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
-#include "AimlBot.h"
-
-using namespace XmlMapper;
-using namespace MadaBot;
-
-namespace rl
-{
-	/**
-	 * Loads ans processes a DialogCharacter script
-	 */
-	class DialogScriptProcessor
-			: public XmlNodeProcessor<AimlBot, AimlCore, CeGuiString>
-	{
-	public:
-		DialogScriptProcessor();
-		~DialogScriptProcessor();
-		void preprocessStep();
-		void processChildStep(XmlNode<CeGuiString>* pChild){}
-		void postprocessStep(){}
-	protected:
-		void initialize();
-	};
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:20:30 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:20:30 +0200
Subject: [Dsa-hl-svn] r3724 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211020.l7LAKUJK025694@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:20:23 +0200 (Tue, 21 Aug 2007)
New Revision: 3724

Added:
   rl/trunk/engine/ai/include/DialogSubsystem.h
Removed:
   rl/trunk/engine/dialog/include/DialogSubsystem.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/DialogSubsystem.h (from rev 3723, rl/trunk/engine/dialog/include/DialogSubsystem.h)

Deleted: rl/trunk/engine/dialog/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-08-21 10:20:14 UTC (rev 3723)
+++ rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-08-21 10:20:23 UTC (rev 3724)
@@ -1,94 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __DialogSubsystem_H__
-#define __DialogSubsystem_H__
-
-#include "DialogPrerequisites.h"
-
-#include <OgreResource.h>
-#include <OgreSingleton.h>
-
-//#include "CommonPrerequisites.h"
-
-namespace MadaBot
-{
-	template <class S> class AimlCore;
-}
-namespace rl
-{
-	class DialogCharacter;
-	class ContextInterpreter;
-
-	/// Initialises and manages everything for using dialogs in Rl
-	class _RlDialogExport DialogSubsystem : 
-	//	public AimlCoreComponent,
-		public Ogre::Singleton<DialogSubsystem>
-	{
-	public:
-		DialogSubsystem();
-		virtual ~DialogSubsystem();
-		
-		/**
-		 * Get the bot with the given name
-		 * @return the bot or NULL if the bot does not exist
-		 */
-		DialogCharacter* getBot(const CeGuiString& botName);
-
-		ContextInterpreter* getContextInterpreter();
-
-		/**
-		 * Load a DialogCharacter from a xml file
-		 * If no name is given, the first available bot in the xml file is loaded
-		 * @param fileName xml file with the bot definition
-		 * @param botName name of the bot to load
-		 * @return will return a DialogCharacter...
-		 */
-		DialogCharacter* loadBot(const CeGuiString& botName, const CeGuiString& fileName = "");
-	
-        /**
-         * Helper function, that retrieves an xml resource from its file name
-         * If resource not yet created, it gets first searched in the current
-         * adventure module group, then in the default group.
-         */
-        Ogre::ResourcePtr getXmlResource(const Ogre::String& filename);
-
-		/**
-		 * Set the DialogCharacter loaded from ruby
-		 */
-		void setCurrentDialogCharacter(DialogCharacter* bot);
-		DialogCharacter* getCurrentDialogCharacter() const;
-
-	private:
-		void initialize();
-		typedef std::map<CeGuiString, DialogCharacter*> BotMap;
-		typedef MadaBot::AimlCore<CeGuiString> AimlCore; 
-		BotMap mBots;
-		AimlCore* mCore;
-		ContextInterpreter* mContextInterpreter;
-		DialogCharacter* mCurrentBot;
-	};
-
-/*	inline DialogCharacter* DialogSubsystem::getCurrentBot()
-	{
-		return mCurrentBot;
-	}
-*/
-	inline ContextInterpreter* DialogSubsystem::getContextInterpreter()
-	{
-		return mContextInterpreter;
-	}
-}
-#endif



From blakharaz at mail.berlios.de  Tue Aug 21 12:20:44 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 21 Aug 2007 12:20:44 +0200
Subject: [Dsa-hl-svn] r3725 - in rl/trunk/engine: ai/include dialog/include
Message-ID: <200708211020.l7LAKiuw025721@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-21 12:20:38 +0200 (Tue, 21 Aug 2007)
New Revision: 3725

Added:
   rl/trunk/engine/ai/include/ScriptProcessor.h
Removed:
   rl/trunk/engine/dialog/include/ScriptProcessor.h
Log:
Merge dialog subsystem into AI
- CAUTION: this movement will break any builds so revert to 3702 until this is fixed

Copied: rl/trunk/engine/ai/include/ScriptProcessor.h (from rev 3724, rl/trunk/engine/dialog/include/ScriptProcessor.h)

Deleted: rl/trunk/engine/dialog/include/ScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-08-21 10:20:23 UTC (rev 3724)
+++ rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-08-21 10:20:38 UTC (rev 3725)
@@ -1,44 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __Rl_ScriptProcessor_H__
-#define __Rl_ScriptProcessor_H__
-
-#include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
-#include "AimlBot.h"
-
-using namespace XmlMapper;
-using namespace MadaBot;
-
-namespace rl
-{
-	/**
-	 * Processes a ruby script in AIML files
-	 */
-	class ScriptProcessor
-			: public XmlNodeProcessor<Response, AimlBot, CeGuiString, false>
-	{
-	public:
-		ScriptProcessor();
-		~ScriptProcessor();
-		void preprocessStep();
-		void processChildStep(XmlNode<CeGuiString>* pChild){}
-		void postprocessStep(){}
-	protected:
-		void initialize();
-	};
-}
-#endif



From timm at mail.berlios.de  Tue Aug 21 21:44:49 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 21 Aug 2007 21:44:49 +0200
Subject: [Dsa-hl-svn] r3726 - in rl/trunk/engine/common: include src
Message-ID: <200708211944.l7LJiniq001541@sheep.berlios.de>

Author: timm
Date: 2007-08-21 21:44:44 +0200 (Tue, 21 Aug 2007)
New Revision: 3726

Modified:
   rl/trunk/engine/common/include/XmlHelper.h
   rl/trunk/engine/common/src/XmlHelper.cpp
Log:
Added write support to XmlHelper

Modified: rl/trunk/engine/common/include/XmlHelper.h
===================================================================
--- rl/trunk/engine/common/include/XmlHelper.h	2007-08-21 10:20:38 UTC (rev 3725)
+++ rl/trunk/engine/common/include/XmlHelper.h	2007-08-21 19:44:44 UTC (rev 3726)
@@ -51,8 +51,21 @@
 class _RlCommonExport XmlHelper
 {
 public:
+    
+    /**
+	 * Erzeugt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
+	 * dieser ist wiederum ein Element-Knoten
+	 *
+     * @param doc Das DOM-Document
+	 * @param parent Knoten, dessen Kinder gesucht sind
+	 * @param name Name des gesuchten Kindknotens von parent
+	 *
+	 * @return Der Kindknoten
+	 */
+    static XERCES_CPP_NAMESPACE::DOMElement* appendChildElement(XERCES_CPP_NAMESPACE::DOMDocument* doc, 
+        XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
-	/**
+    /**
 	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
 	 * dieser ist wiederum ein Element-Knoten
 	 *
@@ -63,7 +76,16 @@
 	 */
 	static XERCES_CPP_NAMESPACE::DOMElement* getChildNamed(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name);
 	
-	/**
+    /**
+	 * Setzt den Text eines Elementknotens
+	 *
+	 * @param element Das DOM-Element
+     * @param string Der zu setzende String
+	 * @return Das DOM-Element
+	 */
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsString(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, const CeGuiString &value);
+    
+    /**
 	 * Ermittelt den Text eines Elementknotens
 	 *
 	 * @param element Das DOM-Element
@@ -71,7 +93,17 @@
 	 */
 	static CeGuiString getValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element);
 	
-	/**
+    /**
+	 * Setzt den Text eines Elementknotens, als UTF-8
+	 * vor Benutzung muss initializeTranscoder() aufgerufen werden
+	 *
+	 * @param element Das DOM-Element
+     * @param utf Der zu setzende UTF String
+	 * @return Das DOM-Element
+	 */
+	static XERCES_CPP_NAMESPACE::DOMElement* setValueAsUtf8(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, utf8* value);
+    
+    /**
 	 * Ermittelt den Text eines Elementknotens, als UTF-8
 	 * vor Benutzung muss initializeTranscoder() aufgerufen werden
 	 *
@@ -82,6 +114,17 @@
 	static utf8* getValueAsUtf8(XERCES_CPP_NAMESPACE::DOMElement* element);
 
 	/**
+	 * Setzt den Text eines Elementknotens und parst ihn, 
+	 * um eine Ganzzahl daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+     * @param value Der zu setzende Integer
+	 * @return Das DOM-Element
+	 */
+	static XERCES_CPP_NAMESPACE::DOMElement* setValueAsInteger(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, int value);
+
+    
+    /**
 	 * Ermittelt den Text eines Elementknotens und parst ihn, 
 	 * um eine Ganzzahl daraus zu machen
 	 *
@@ -90,7 +133,17 @@
 	 */
 	static int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element);
 
-	/**
+	
+    /**
+     * Convert a vector3 to an xml tag
+	 *
+	 * @param element The DOM element
+     * @param value The vector input
+	 * @return The DOM element
+	 */
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsVector3(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Vector3 value);
+
+    /**
 	 * Processes an element node of shape <any_node_name x="0" y="0" z="0"/>
 	 * into a three component Ogre vector
 	 *
@@ -99,7 +152,26 @@
 	 */
 	static Ogre::Vector3 getValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element);
 
-	/**
+    /**
+     * Convert a quaternion to an xml tag
+	 *
+	 * @param element The DOM element
+     * @param value The quaternion input
+	 * @return The DOM element
+	 */
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Quaternion value);
+
+    /**
+	 * Processes an element node of shape <any_node_name x="0" y="0" z="0" w="1"/>
+	 * into a three component Ogre vector
+	 *
+	 * @param element The DOM element
+	 * @return the quaternion
+	 */
+    static Ogre::Quaternion getValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element);
+
+	
+    /**
 	 * Ermittelt, ob ein DOMElement ein bestimmtes Attribut bestitzt
 	 *
 	 * @param element Das DOM-Element
@@ -109,6 +181,16 @@
 	static bool hasAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
     /**
+	 * Setzt den Wert von einem Attribut eines Elementes
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @param value Wert der gesetzt werden muss
+	 * @return <code>true</code>, wenn das Attribut an diesem Element existiert, sonst <code>false</code>
+	 */
+    static void setAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const char* const value);
+
+    /**
 	 * Checks whether a DOMNode has a certain name
 	 *
 	 * @param node the DOM node
@@ -117,6 +199,7 @@
 	 */
 	static bool hasNodeName(XERCES_CPP_NAMESPACE::DOMNode* node, const char* const name);
 
+    
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
 	 * um eine Ganzzahl daraus zu machen
@@ -125,9 +208,30 @@
 	 * @param name Name des Attributes
 	 * @return Zahlenwert des Attributes
 	 */
+	static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, int value);
+
+    /**
+	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
+	 * um eine Ganzzahl daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @param value das zu setzende Integer
+	 * @return Das DOM-Element
+	 */
 	static int getAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 	
 	/**
+	 * Setzt den Text eines DOMElement-Attributes
+	 * 
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+	 * @param value das zu setzende CeGuiString
+	 * @return Das DOM-Element
+	 */	
+	static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const CeGuiString &value);
+    
+    /**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem CeGuiString
 	 * 
 	 * @param element Das DOM-Element
@@ -136,9 +240,26 @@
 	 */	
 	static CeGuiString getAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
+    /**
+	 * Setzt den Text eines DOMElement-Attributes
+	 * 
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+	 * @param value der zu setzende std::string
+	 * @return Das DOM-Element
+	 */	
+    static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const std::string &value);
 
-	static std::string getAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 	/**
+	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem std::string
+	 * 
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+	 * @return Konvertierter Text als std::string
+	 */	
+    static std::string getAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
+	
+    /**
 	 * Ermittelt den Text eines SAX Element-Attributes und konvertiert ihn zu einem CeGuiString
 	 *
 	 * @param element Liste aller Attribute des aktuellen Elementes
@@ -147,6 +268,16 @@
 	 */
 	static CeGuiString getAttributeValueAsString(const XERCES_CPP_NAMESPACE::Attributes& attributes, const char* const name);
 
+    /**
+	 * Setzt den Text eines DOMElement-Attributes
+	 * 
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+	 * @param value der zu setzende boolean
+	 * @return Das DOM-Element
+	 */	
+	static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, bool value);
+
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und interpretier ihn als bool
 	 * 
@@ -156,6 +287,16 @@
 	 */	
 	static bool getAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
+    /**
+	 * Setzt den Text eines DOMElement-Attributes
+	 * 
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+	 * @param value der zu setzende Real Wert
+	 * @return Das DOM-Element
+	 */	
+    static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Real value);
+
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu Ogre::Real
 	 * 

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-21 10:20:38 UTC (rev 3725)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-21 19:44:44 UTC (rev 3726)
@@ -38,6 +38,15 @@
 	XmlHelper::sTranscoder = XMLPlatformUtils::fgTransService->makeNewTranscoderFor(XMLRecognizer::UTF_8, XmlHelper::sFailCode, 16*1024);
 }
 
+DOMElement* XmlHelper::appendChildElement(DOMDocument* doc, DOMElement* parent, const char* const name)
+{
+    RlAssert(parent != NULL, "XmlHelper::appendChildElement: parent must not be NULL" );
+
+    DOMElement* child = doc->createElement(XMLString::transcode(name));
+    parent->appendChild(child);
+    return child;
+}
+
 DOMElement* XmlHelper::getChildNamed(DOMElement* parent, const char* const name)
 {
     RlAssert(parent != NULL, "XmlHelper::getChildNamed: parent must not be NULL" );
@@ -59,12 +68,29 @@
 	return rval;
 }
 
+DOMElement* XmlHelper::setValueAsString(DOMDocument* doc, DOMElement *element, const CeGuiString &value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsString: Element must not be NULL");
+    DOMText* text = doc->createTextNode(XMLString::transcode(value.c_str()));
+    element->appendChild(text);
+    return element;
+}
+
 CeGuiString XmlHelper::getValueAsString(DOMElement* element)
 {
     RlAssert(element != NULL, "XmlHelper::getValueAsString: Element must not be NULL");
 	return transcodeToString( element->getFirstChild()->getNodeValue() );
 }
 
+DOMElement* XmlHelper::setValueAsUtf8(DOMDocument* doc, DOMElement* element, utf8* value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsUtf8: Element must not be NULL");
+    CeGuiString temp(value);
+    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
+    element->appendChild(text);
+    return element;
+}
+
 utf8* XmlHelper::getValueAsUtf8(DOMElement* element)
 {
     RlAssert(element != NULL, "XmlHelper::getValueAsUtf8: Element must not be NULL");
@@ -90,6 +116,24 @@
     return rVal;
 }
 
+void XmlHelper::setAttribute(DOMElement* element, const char* const name, const char* const value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttribute: Element must not be NULL");
+    XMLCh* attrName = XMLString::transcode(name);
+    element->setAttribute(attrName,XMLString::transcode(value));
+    XMLString::release(&attrName);
+}
+
+DOMElement* XmlHelper::setAttributeValueAsInteger(DOMElement *element, const char *const name, int value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsInteger: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    CeGuiString temp = Ogre::StringConverter::toString(value);
+    element->setAttribute(attrName,XMLString::transcode(temp.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
 int XmlHelper::getAttributeValueAsInteger(DOMElement* element,const char* const name)
 {
     RlAssert(element != NULL, "XmlHelper::getAttributeValueAsInteger: Element must not be NULL");
@@ -100,6 +144,16 @@
 	return rVal;
 }
 
+DOMElement* XmlHelper::setAttributeValueAsReal(DOMElement *element, const char *const name, Ogre::Real value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsReal: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    CeGuiString temp = Ogre::StringConverter::toString(value);
+    element->setAttribute(attrName,XMLString::transcode(temp.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
 Ogre::Real XmlHelper::getAttributeValueAsReal(DOMElement* element,const char* const name)
 {
     RlAssert(element != NULL, "XmlHelper::getAttributeValueAsReal: Element must not be NULL");
@@ -110,6 +164,15 @@
 	return rVal;
 }
 
+DOMElement* XmlHelper::setAttributeValueAsString(DOMElement *element, const char *const name, const CeGuiString &value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsString: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    element->setAttribute(attrName,XMLString::transcode(value.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
 CeGuiString XmlHelper::getAttributeValueAsString(DOMElement* element, const char* const name)
 {
     RlAssert(element != NULL, "XmlHelper::getAttributeValueAsString: Element must not be NULL");
@@ -131,6 +194,15 @@
 	return CeGuiString();
 }
 
+DOMElement* XmlHelper::setAttributeValueAsStdString(DOMElement *element, const char *const name, const std::string &value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsStdString: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    element->setAttribute(attrName,XMLString::transcode(value.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
 std::string XmlHelper::getAttributeValueAsStdString(DOMElement* element, const char* const name)
 {
     RlAssert(element != NULL, "XmlHelper::getAttributeValueAsStdString: Element must not be NULL");
@@ -140,6 +212,16 @@
 	return rVal;
 }
 
+DOMElement* XmlHelper::setAttributeValueAsBool(DOMElement *element, const char *const name, bool value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsBool: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    CeGuiString temp = Ogre::StringConverter::toString(value);
+    element->setAttribute(attrName,XMLString::transcode(temp.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
 bool XmlHelper::getAttributeValueAsBool(DOMElement* element,const char* const name)
 {
     RlAssert(element != NULL, "XmlHelper::getAttributeValueAsBool: Element must not be NULL");
@@ -149,12 +231,30 @@
 		return false;
 }
 
+DOMElement* XmlHelper::setValueAsInteger(DOMDocument* doc, DOMElement *element, int value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsInteger: Element must not be NULL");
+    CeGuiString temp = Ogre::StringConverter::toString(value);
+    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
+    element->appendChild(text);
+    return element;
+}
+
 int XmlHelper::getValueAsInteger(DOMElement* element)
 {
     RlAssert(element != NULL, "XmlHelper::getValueAsInteger: Element must not be NULL");
 	return XMLString::parseInt(element->getFirstChild()->getNodeValue());
 }
 
+DOMElement* XmlHelper::setValueAsVector3(DOMDocument* doc, DOMElement *element, Ogre::Vector3 value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsVector3: Element must not be NULL");
+    setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());
+    setAttribute(element, "y", Ogre::StringConverter::toString(value.y).c_str());
+    setAttribute(element, "z", Ogre::StringConverter::toString(value.z).c_str());
+    return element;
+}
+
 Ogre::Vector3 XmlHelper::getValueAsVector3(DOMElement* element)
 {
     RlAssert(element != NULL, "XmlHelper::getValueAsVector3: Element must not be NULL");
@@ -169,6 +269,32 @@
 		getAttributeValueAsReal(element, "z"));
 }
 
+DOMElement* XmlHelper::setValueAsQuaternion(DOMDocument* doc, DOMElement *element, Ogre::Quaternion value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsQuaternion: Element must not be NULL");
+    setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());
+    setAttribute(element, "y", Ogre::StringConverter::toString(value.y).c_str());
+    setAttribute(element, "z", Ogre::StringConverter::toString(value.z).c_str());
+    setAttribute(element, "w", Ogre::StringConverter::toString(value.w).c_str());
+    return element;
+}
+
+Ogre::Quaternion XmlHelper::getValueAsQuaternion(DOMElement* element)
+{
+    RlAssert(element != NULL, "XmlHelper::getValueAsQuaternion: Element must not be NULL");
+	RlAssert(
+		hasAttribute(element, "x") 
+		&& hasAttribute(element, "y") 
+		&& hasAttribute(element, "z")
+        && hasAttribute(element, "w"),
+		"Element must have attributes x, y z and w");
+    return Ogre::Quaternion(
+		getAttributeValueAsReal(element, "x"),
+		getAttributeValueAsReal(element, "y"),
+		getAttributeValueAsReal(element, "z"),
+        getAttributeValueAsReal(element, "w"));
+}
+
 utf8* XmlHelper::transcodeToUtf8(const XMLCh* const string16)
 {
 	unsigned int str16len = XMLString::stringLen(string16);



From blakharaz at mail.berlios.de  Wed Aug 22 00:06:24 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 22 Aug 2007 00:06:24 +0200
Subject: [Dsa-hl-svn] r3727 - modules/common/scripts
	modules/techdemo2/scripts modules/tutorial/scripts/maps
	rl/trunk rl/trunk/engine rl/trunk/engine/ai
	rl/trunk/engine/ai/include
	rl/trunk/engine/ai/include/predicates rl/trunk/engine/ai/src
	rl/trunk/engine/script rl/trunk/engine/script/swig
	rl/trunk/engine/startup/src rl/trunk/engine/ui
	rl/trunk/engine/ui/src
Message-ID: <200708212206.l7LM6OIY009253@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-22 00:05:49 +0200 (Wed, 22 Aug 2007)
New Revision: 3727

Removed:
   rl/trunk/engine/ai/include/DialogPrerequisites.h
   rl/trunk/engine/ai/include/DialogSubsystem.h
   rl/trunk/engine/dialog/
   rl/trunk/engine/script/swig/RlDialog.head.swig
   rl/trunk/engine/script/swig/RlDialog.swig
Modified:
   modules/common/scripts/globals.rb
   modules/common/scripts/npc.rb
   modules/techdemo2/scripts/forrest.rb
   modules/techdemo2/scripts/jarn.rb
   modules/tutorial/scripts/maps/nscs.rb
   rl/trunk/Rastullah2005.sln
   rl/trunk/configure.in
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/AimlNodeImplRl.h
   rl/trunk/engine/ai/include/AimlParserImplRl.h
   rl/trunk/engine/ai/include/ContextConditionProcessor.h
   rl/trunk/engine/ai/include/ContextInterpreter.h
   rl/trunk/engine/ai/include/DialogCharacter.h
   rl/trunk/engine/ai/include/DialogOption.h
   rl/trunk/engine/ai/include/DialogResponse.h
   rl/trunk/engine/ai/include/DialogScriptProcessor.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/include/ScriptProcessor.h
   rl/trunk/engine/ai/include/predicates/CreaturePredicates.h
   rl/trunk/engine/ai/include/predicates/QuestKnownPredicates.h
   rl/trunk/engine/ai/include/predicates/QuestPartsPredicates.h
   rl/trunk/engine/ai/include/predicates/QuestStatePredicates.h
   rl/trunk/engine/ai/include/predicates/ScriptPredicates.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/DialogCharacter.cpp
   rl/trunk/engine/ai/src/DialogOption.cpp
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/startup/src/RastullahMain.cpp
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/src/DialogControlState.cpp
Log:
Finished merging dialog subsystem into the AI subsystem

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-08-21 19:44:44 UTC (rev 3726)
+++ modules/common/scripts/globals.rb	2007-08-21 22:05:49 UTC (rev 3727)
@@ -11,7 +11,6 @@
 $PM = PhysicsManager.getSingleton();
 $UI = UiSubsystem.getSingleton();
 $DM = DsaManager.getSingleton();
-$DS = DialogSubsystem.getSingleton();
 $WF = WindowFactory.getSingleton();
 $AI = AgentManager.getSingleton();
 $WPGM = WayPointGraphManager.getSingleton();

Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2007-08-21 19:44:44 UTC (rev 3726)
+++ modules/common/scripts/npc.rb	2007-08-21 22:05:49 UTC (rev 3727)
@@ -6,14 +6,23 @@
   end
 
   def doAction(object, actor, target)
-    bot = $DS.getBot(object.getName())
+    bot = $AI.getBot(object.getName())
     if (bot.nil?)
-      bot = $DS.loadBot(object.getName(), object.getDialogfile())
+      bot = $AI.loadBot(object.getName(), object.getDialogfile())
     end
     if ( not bot.nil? )
+	  p "foo1"
       bot.setPlayerCharacter( actor );
+	  p "foo2"
       bot.setNonPlayerCharacter( object );
-      $IM.pushControlState(CST_DIALOG);
+	  p "foo3"
+	  p "foo4"
+	  agent = AgentManager::getSingleton().createAgent(object)
+	  agent.pushState(RlScript::AST_DIALOG);
+	  p "foo5"
+	  agent.getCurrentState().setDialogPartner(
+		AgentManager::getSingleton().createAgent(actor))
+	  p "foo6"
     end
   end
 end

Modified: modules/techdemo2/scripts/forrest.rb
===================================================================
--- modules/techdemo2/scripts/forrest.rb	2007-08-21 19:44:44 UTC (rev 3726)
+++ modules/techdemo2/scripts/forrest.rb	2007-08-21 22:05:49 UTC (rev 3727)
@@ -10,7 +10,7 @@
 #forrest.setActor($AM.createMeshActor("Forrest", "men_Gennisch.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 #forrest.getActor().placeIntoScene([-20.83, -6.70, 19.46]);
 #
-#bot=$DS.loadBot("Forrest", "forrest.xml");
+#bot=$AI.loadBot("Forrest", "forrest.xml");
 #bot.setNonPlayerCharacter(forrest);
 #forrest.addAction(TalkAction.new("Forrest", "forrest.xml"));
 #agent = $AI.createAgent(bot);

Modified: modules/techdemo2/scripts/jarn.rb
===================================================================
--- modules/techdemo2/scripts/jarn.rb	2007-08-21 19:44:44 UTC (rev 3726)
+++ modules/techdemo2/scripts/jarn.rb	2007-08-21 22:05:49 UTC (rev 3727)
@@ -11,7 +11,7 @@
 #jarn.setActor($AM.createMeshActor("Jarn", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 #jarn.getActor().placeIntoScene([ -36.16, -6.25, 18.12],[0.0, -23.40, 0.0]);
 
-#bot = $DS.loadBot("Jarn", "jarn.xml");
+#bot = $AI.loadBot("Jarn", "jarn.xml");
 #bot.setNonPlayerCharacter(jarn);
 #jarn.addAction(TalkAction.new("Jarn", "jarn.xml"));
 #agent = $AI.createAgent(bot);

Modified: modules/tutorial/scripts/maps/nscs.rb
===================================================================
--- modules/tutorial/scripts/maps/nscs.rb	2007-08-21 19:44:44 UTC (rev 3726)
+++ modules/tutorial/scripts/maps/nscs.rb	2007-08-21 22:05:49 UTC (rev 3727)
@@ -7,7 +7,7 @@
 nsc01.setActor($AM.createMeshActor("AIML01", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc01.getActor().placeIntoScene([ -1.46, 0.00, -3.57],[0.0, 180.0, 0.0]);
 
-bot01 = $DS.loadBot("AIML01", "nscs.xml");
+bot01 = $AI.loadBot("AIML01", "nscs.xml");
 bot01.setNonPlayerCharacter(nsc01);
 nsc01.addAction(TalkAction.new("AIML01", "nscs.xml"));
 agent01 = $AI.createAgent(bot01);
@@ -22,7 +22,7 @@
 nsc02.setActor($AM.createMeshActor("AIML02", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc02.getActor().placeIntoScene([ -0.46, 0.00, -3.57],[0.0, 180.0, 0.0]);
 
-bot02 = $DS.loadBot("AIML02", "nscs.xml");
+bot02 = $AI.loadBot("AIML02", "nscs.xml");
 bot02.setNonPlayerCharacter(nsc02);
 nsc02.addAction(TalkAction.new("AIML02", "nscs.xml"));
 agent02 = $AI.createAgent(bot02);
@@ -37,7 +37,7 @@
 nsc03.setActor($AM.createMeshActor("AIML03", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc03.getActor().placeIntoScene([ 0.7, 0.00, -3.57],[0.0, 180.0, 0.0]);
 
-bot03 = $DS.loadBot("AIML03", "nscs.xml");
+bot03 = $AI.loadBot("AIML03", "nscs.xml");
 bot03.setNonPlayerCharacter(nsc03);
 nsc03.addAction(TalkAction.new("AIML03", "nscs.xml"));
 agent03 = $AI.createAgent(bot03);
@@ -52,7 +52,7 @@
 nsc04.setActor($AM.createMeshActor("AIML04", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc04.getActor().placeIntoScene([ 1.82, 0.00, -3.57],[0.0, 180.0, 0.0]);
 
-bot04 = $DS.loadBot("AIML04", "nscs.xml");
+bot04 = $AI.loadBot("AIML04", "nscs.xml");
 bot04.setNonPlayerCharacter(nsc04);
 nsc04.addAction(TalkAction.new("AIML04", "nscs.xml"));
 agent04 = $AI.createAgent(bot04);
@@ -67,7 +67,7 @@
 nsc05.setActor($AM.createMeshActor("AIML05", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc05.getActor().placeIntoScene([ 2.88, -0.01, -0.58],[0.0, 90.0, 0.0]);
 
-bot05 = $DS.loadBot("AIML05", "nscs.xml");
+bot05 = $AI.loadBot("AIML05", "nscs.xml");
 bot05.setNonPlayerCharacter(nsc05);
 nsc05.addAction(TalkAction.new("AIML05", "nscs.xml"));
 agent05 = $AI.createAgent(bot05);
@@ -83,7 +83,7 @@
 nsc06.setActor($AM.createMeshActor("AIML06", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc06.getActor().placeIntoScene([ 2.88, -0.01, 1.0],[0.0, 90.0, 0.0]);
 
-bot06 = $DS.loadBot("AIML06", "nscs.xml");
+bot06 = $AI.loadBot("AIML06", "nscs.xml");
 bot06.setNonPlayerCharacter(nsc06);
 nsc06.addAction(TalkAction.new("AIML06", "nscs.xml"));
 agent06 = $AI.createAgent(bot06);
@@ -100,7 +100,7 @@
 nsc08.setActor($AM.createMeshActor("AIML08", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc08.getActor().placeIntoScene([ 2.88, -0.01, 2.36],[0.0, 90.0, 0.0]);
 
-bot08 = $DS.loadBot("AIML08", "nscs.xml");
+bot08 = $AI.loadBot("AIML08", "nscs.xml");
 bot08.setNonPlayerCharacter(nsc08);
 nsc08.addAction(TalkAction.new("AIML08", "nscs.xml"));
 agent08 = $AI.createAgent(bot08);
@@ -115,7 +115,7 @@
 nsc09.setActor($AM.createMeshActor("AIML09", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc09.getActor().placeIntoScene([ 1.97, -0.01, 3.78],[0.0, 0.0, 0.0]);
 
-bot09 = $DS.loadBot("AIML09", "nscs.xml");
+bot09 = $AI.loadBot("AIML09", "nscs.xml");
 bot09.setNonPlayerCharacter(nsc09);
 nsc09.addAction(TalkAction.new("AIML09", "nscs.xml"));
 agent09 = $AI.createAgent(bot09);
@@ -131,7 +131,7 @@
 nsc10.setActor($AM.createMeshActor("AIML10", "men_gennisch2.mesh", PhysicsManager::GT_ELLIPSOID, 75.0));
 nsc10.getActor().placeIntoScene([ 0.13, -0.01, 3.78],[0.0, 0.0, 0.0]);
 
-bot10 = $DS.loadBot("AIML10", "nscs.xml");
+bot10 = $AI.loadBot("AIML10", "nscs.xml");
 bot10.setNonPlayerCharacter(nsc10);
 nsc10.addAction(TalkAction.new("AIML10", "nscs.xml"));
 agent10 = $AI.createAgent(bot10);

Modified: rl/trunk/Rastullah2005.sln
===================================================================
--- rl/trunk/Rastullah2005.sln	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/Rastullah2005.sln	2007-08-21 22:05:49 UTC (rev 3727)
@@ -7,13 +7,6 @@
 		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlDialog", "engine\dialog\RlDialog2005.vcproj", "{6361481B-A6D5-4BC2-826C-C26A49C631A8}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-	EndProjectSection
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlRules", "engine\rules\RlRules2005.vcproj", "{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}"
 	ProjectSection(ProjectDependencies) = postProject
 		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
@@ -27,7 +20,6 @@
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
 		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlStartup", "engine\startup\RlStartup2005.vcproj", "{B78AEF70-E618-4E9D-BD67-E17995ECF714}"
@@ -38,20 +30,18 @@
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
 		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlUI", "engine\ui\RlUI2005.vcproj", "{53FE20F3-E726-44FE-BBEC-D29CAE210D25}"
 	ProjectSection(ProjectDependencies) = postProject
+		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
 		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlAI", "engine\ai\RlAI2005.vcproj", "{C3E78B89-587B-499A-BE7D-4FE8564F0CD7}"
 	ProjectSection(ProjectDependencies) = postProject
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
 		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
@@ -90,12 +80,6 @@
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2}.Release|Win32.Build.0 = Release|Win32
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2}.ReleaseWithSymbols|Win32.ActiveCfg = Release with Symbols|Win32
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2}.ReleaseWithSymbols|Win32.Build.0 = Release with Symbols|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.Debug|Win32.ActiveCfg = Debug|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.Debug|Win32.Build.0 = Debug|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.Release|Win32.ActiveCfg = Release|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.Release|Win32.Build.0 = Release|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.ReleaseWithSymbols|Win32.ActiveCfg = Release with Symbols|Win32
-		{6361481B-A6D5-4BC2-826C-C26A49C631A8}.ReleaseWithSymbols|Win32.Build.0 = Release with Symbols|Win32
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}.Debug|Win32.ActiveCfg = Debug|Win32
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}.Debug|Win32.Build.0 = Debug|Win32
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}.Release|Win32.ActiveCfg = Release|Win32

Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/configure.in	2007-08-21 22:05:49 UTC (rev 3727)
@@ -178,7 +178,6 @@
         engine/ai/Makefile engine/ai/src/Makefile engine/ai/include/Makefile\
         engine/common/Makefile engine/common/src/Makefile engine/common/include/Makefile \
         engine/core/Makefile engine/core/src/Makefile engine/core/include/Makefile \
-        engine/dialog/Makefile engine/dialog/src/Makefile engine/dialog/include/Makefile \
         engine/ui/Makefile engine/ui/src/Makefile engine/ui/include/Makefile \
         engine/rules/Makefile engine/rules/src/Makefile engine/rules/include/Makefile \
         engine/script/Makefile engine/script/swig/Makefile engine/script/src/Makefile engine/script/include/Makefile \

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-21 22:05:49 UTC (rev 3727)
@@ -41,7 +41,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -73,10 +73,10 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="false"
 				AdditionalOptions="/NODEFAULTLIB:MSVCRT&#x0D;&#x0A;"
-				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib RlDialog.lib Newton.lib"
+				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2D.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlAI.pdb"
@@ -141,7 +141,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"
@@ -161,10 +161,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib RlDialog.lib Newton.lib"
+				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -227,7 +227,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"
@@ -247,10 +247,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib RlDialog.lib Newton.lib"
+				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="..\common\lib\Release;..\core\lib\Release;..\rules\lib\Release;..\dialog\lib\Release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ogrenewt\lib\Release;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -315,6 +315,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\AimlNodeImplRl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\AimlParserImplRl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\AiSubsystem.cpp"
 				>
 			</File>
@@ -343,10 +351,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\ContextConditionProcessor.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\ContextInterpreter.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\CreatureWalkPathJob.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\src\DialogCharacter.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\DialogOption.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\DialogResponse.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\DialogScriptProcessor.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Landmark.cpp"
 				>
 			</File>
@@ -359,6 +391,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\ScriptProcessor.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\stdinc.cpp"
 				>
 				<FileConfiguration
@@ -402,6 +438,50 @@
 				RelativePath=".\src\WayPointNode.cpp"
 				>
 			</File>
+			<Filter
+				Name="predicates"
+				>
+				<File
+					RelativePath=".\src\predicates\CreaturePredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\EigenschaftsProbePredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\EigenschaftsWertPredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\GrundWertPredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\QuestKnownPredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\QuestPartsPredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\QuestStatePredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\ScriptPredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\TalentProbePredicates.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\predicates\TalentWertPredicates.cpp"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Headerdateien"
@@ -433,6 +513,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\AimlNodeImplRl.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AimlParserImplRl.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\AiPrerequisites.h"
 				>
 			</File>
@@ -465,10 +553,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\ContextConditionProcessor.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\ContextInterpreter.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\CreatureWalkPathJob.h"
 				>
 			</File>
 			<File
+				RelativePath=".\include\DialogCharacter.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\DialogOption.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\DialogResponse.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\DialogScriptProcessor.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\FuzzyState.h"
 				>
 			</File>
@@ -489,6 +601,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\ScriptProcessor.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\stdinc.h"
 				>
 			</File>
@@ -512,6 +628,50 @@
 				RelativePath=".\include\WayPointNode.h"
 				>
 			</File>
+			<Filter
+				Name="predicates"
+				>
+				<File
+					RelativePath=".\include\predicates\CreaturePredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\EigenschaftsProbePredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\EigenschaftsWertPredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\GrundWertPredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\QuestKnownPredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\QuestPartsPredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\QuestStatePredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\ScriptPredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\TalentProbePredicates.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\predicates\TalentWertPredicates.h"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Ressourcendateien"

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -23,11 +23,18 @@
 #include "MessagePump.h"
 #include "World.h"
 
+namespace MadaBot
+{
+	template <class S> class AimlCore;
+}
+
 namespace rl
 {
 	class Agent;
 	class AgentManager;
 	class AiWorld;
+	class ContextInterpreter;
+	class DialogCharacter;
 	class Landmark;
 	class LandmarkPath;
 	class WayPointGraphManager;
@@ -74,8 +81,45 @@
 
 		Landmark* getLandmark(const Ogre::String& name) const;
 
+		/**
+		 * Get the bot with the given name
+		 * @return the bot or NULL if the bot does not exist
+		 */
+		DialogCharacter* getBot(const CeGuiString& botName);
+
+		ContextInterpreter* getContextInterpreter();
+
+		/**
+		 * Load a DialogCharacter from a xml file
+		 * If no name is given, the first available bot in the xml file is loaded
+		 * @param fileName xml file with the bot definition
+		 * @param botName name of the bot to load
+		 * @return will return a DialogCharacter...
+		 */
+		DialogCharacter* loadBot(const CeGuiString& botName, const CeGuiString& fileName = "");
+	
+        /**
+         * Helper function, that retrieves an xml resource from its file name
+         * If resource not yet created, it gets first searched in the current
+         * adventure module group, then in the default group.
+         */
+        Ogre::ResourcePtr getXmlResource(const Ogre::String& filename);
+
+		/**
+		 * Set the DialogCharacter loaded from ruby
+		 */
+		void setCurrentDialogCharacter(DialogCharacter* bot);
+		DialogCharacter* getCurrentDialogCharacter() const;
+
 	private:
-		/** Initializes the AI subsystem.
+		typedef std::map<CeGuiString, DialogCharacter*> BotMap;
+		typedef MadaBot::AimlCore<CeGuiString> AimlCore; 
+		BotMap mBots;
+		AimlCore* mCore;
+		ContextInterpreter* mContextInterpreter;
+		DialogCharacter* mCurrentBot;
+
+        /** Initializes the AI subsystem.
 		 * Creates AiWorld and AgentManager, registers a scene listener,
 		 * adds the AgentManager to the GameLoop as a task.
 		 */
@@ -107,8 +151,13 @@
 	    MessagePump::ScopedConnection mSceneClearingConnection;
 	};
 
-	inline AiWorld* AiSubsystem::getWorld()
+	inline ContextInterpreter* AiSubsystem::getContextInterpreter()
 	{
+		return mContextInterpreter;
+	}
+
+    inline AiWorld* AiSubsystem::getWorld()
+	{
 		return mWorld;
 	}
 }

Modified: rl/trunk/engine/ai/include/AimlNodeImplRl.h
===================================================================
--- rl/trunk/engine/ai/include/AimlNodeImplRl.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/AimlNodeImplRl.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_AimlNodeImplRl_H__
 #define __Rl_AimlNodeImplRl_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "AimlNode.h"
 
 using namespace MadaBot;

Modified: rl/trunk/engine/ai/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/ai/include/AimlParserImplRl.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/AimlParserImplRl.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_AimlParserImplRl_H__
 #define __Rl_AimlParserImplRl_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "XmlMapper/XmlParser.h"
 
 #include <OgreResource.h>

Modified: rl/trunk/engine/ai/include/ContextConditionProcessor.h
===================================================================
--- rl/trunk/engine/ai/include/ContextConditionProcessor.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/ContextConditionProcessor.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -17,7 +17,7 @@
 #define __Rl_ContextConditionProcessor_H__
 
 #include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "AimlBot.h"
 
 using namespace XmlMapper;

Modified: rl/trunk/engine/ai/include/ContextInterpreter.h
===================================================================
--- rl/trunk/engine/ai/include/ContextInterpreter.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/ContextInterpreter.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -17,7 +17,7 @@
 #define __Rl_AimlContextInterpreter_H__
 
 #include "AimlInterpreter.h"
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "DialogResponse.h"
 using namespace MadaBot;
 

Modified: rl/trunk/engine/ai/include/DialogCharacter.h
===================================================================
--- rl/trunk/engine/ai/include/DialogCharacter.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogCharacter.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_DialogCharacter_H__
 #define __Rl_DialogCharacter_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 //#include "DialogListener.h"
 
 namespace MadaBot
@@ -35,7 +35,7 @@
      * Representation of a Character that is able to respond in a Dialog
      * @todo Art der Erstellung ?ndern, das ist zu kompliziert.
      */
-	class _RlDialogExport DialogCharacter 
+	class _RlAiExport DialogCharacter 
 	{
 	public:
 		DialogCharacter();

Modified: rl/trunk/engine/ai/include/DialogOption.h
===================================================================
--- rl/trunk/engine/ai/include/DialogOption.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogOption.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_DialogOption_H__
 #define __Rl_DialogOption_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 
 namespace MadaBot
 {
@@ -29,7 +29,7 @@
     /**
      * The selectable options a player can choose from in a Dialog
      */
-	class _RlDialogExport DialogOption
+	class _RlAiExport DialogOption
 	{
 	public:
 		DialogOption(const Response<CeGuiString>& pData, AimlBot<CeGuiString>* pBot = NULL);

Deleted: rl/trunk/engine/ai/include/DialogPrerequisites.h
===================================================================
--- rl/trunk/engine/ai/include/DialogPrerequisites.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogPrerequisites.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -1,38 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __DialogPrerequisites_H__
-#define __DialogPrerequisites_H__
-
-// Common is only needed for the CeGuiString typedef
-#include "CommonPrerequisites.h"
-
-#include "RastullahPrerequisites.h"
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-// Export control
-#   if defined( RLDIALOG_EXPORTS )
-#       define _RlDialogExport __declspec( dllexport )
-#   else
-#       define _RlDialogExport __declspec( dllimport )
-#   endif
-#else // Linux / Mac OSX etc
-#   define _RlDialogExport
-#endif
-
-#pragma warning (disable : 4251)
-
-#endif
-

Modified: rl/trunk/engine/ai/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/ai/include/DialogResponse.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogResponse.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_DialogResponse_H__
 #define __Rl_DialogResponse_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "CommonPrerequisites.h"
 
 namespace MadaBot
@@ -33,7 +33,7 @@
     /**
      * The reponse a DialogCharacter can give in a Dialog
      */
-	class _RlDialogExport DialogResponse
+	class _RlAiExport DialogResponse
 	{
 	public:
 		typedef std::map<int, CeGuiString> Options;

Modified: rl/trunk/engine/ai/include/DialogScriptProcessor.h
===================================================================
--- rl/trunk/engine/ai/include/DialogScriptProcessor.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogScriptProcessor.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -17,7 +17,7 @@
 #define __Rl_DialogScriptProcessor_H__
 
 #include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "AimlBot.h"
 
 using namespace XmlMapper;

Deleted: rl/trunk/engine/ai/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/DialogSubsystem.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/DialogSubsystem.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -1,94 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __DialogSubsystem_H__
-#define __DialogSubsystem_H__
-
-#include "DialogPrerequisites.h"
-
-#include <OgreResource.h>
-#include <OgreSingleton.h>
-
-//#include "CommonPrerequisites.h"
-
-namespace MadaBot
-{
-	template <class S> class AimlCore;
-}
-namespace rl
-{
-	class DialogCharacter;
-	class ContextInterpreter;
-
-	/// Initialises and manages everything for using dialogs in Rl
-	class _RlDialogExport DialogSubsystem : 
-	//	public AimlCoreComponent,
-		public Ogre::Singleton<DialogSubsystem>
-	{
-	public:
-		DialogSubsystem();
-		virtual ~DialogSubsystem();
-		
-		/**
-		 * Get the bot with the given name
-		 * @return the bot or NULL if the bot does not exist
-		 */
-		DialogCharacter* getBot(const CeGuiString& botName);
-
-		ContextInterpreter* getContextInterpreter();
-
-		/**
-		 * Load a DialogCharacter from a xml file
-		 * If no name is given, the first available bot in the xml file is loaded
-		 * @param fileName xml file with the bot definition
-		 * @param botName name of the bot to load
-		 * @return will return a DialogCharacter...
-		 */
-		DialogCharacter* loadBot(const CeGuiString& botName, const CeGuiString& fileName = "");
-	
-        /**
-         * Helper function, that retrieves an xml resource from its file name
-         * If resource not yet created, it gets first searched in the current
-         * adventure module group, then in the default group.
-         */
-        Ogre::ResourcePtr getXmlResource(const Ogre::String& filename);
-
-		/**
-		 * Set the DialogCharacter loaded from ruby
-		 */
-		void setCurrentDialogCharacter(DialogCharacter* bot);
-		DialogCharacter* getCurrentDialogCharacter() const;
-
-	private:
-		void initialize();
-		typedef std::map<CeGuiString, DialogCharacter*> BotMap;
-		typedef MadaBot::AimlCore<CeGuiString> AimlCore; 
-		BotMap mBots;
-		AimlCore* mCore;
-		ContextInterpreter* mContextInterpreter;
-		DialogCharacter* mCurrentBot;
-	};
-
-/*	inline DialogCharacter* DialogSubsystem::getCurrentBot()
-	{
-		return mCurrentBot;
-	}
-*/
-	inline ContextInterpreter* DialogSubsystem::getContextInterpreter()
-	{
-		return mContextInterpreter;
-	}
-}
-#endif

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-08-21 22:05:49 UTC (rev 3727)
@@ -22,4 +22,24 @@
 	SteeringVehicle.h \
 	WayPointNode.h \
 	WayPointGraph.h \
-	WayPointGraphManager.h
+	WayPointGraphManager.h \
+	AimlNodeImplRl.h \
+	AimlParserImplRl.h \
+	ContextConditionProcessor.h \
+	ContextInterpreter.h \
+	DialogCharacter.h \
+	DialogOption.h \
+	DialogPrerequisites.h \
+	DialogResponse.h \
+	DialogScriptProcessor.h \
+	DialogSubsystem.h \
+	ScriptProcessor.h \
+	predicates/CreaturePredicates.h \
+	predicates/EigenschaftsWertPredicates.h \
+	predicates/EigenschaftsProbePredicates.h \
+	predicates/QuestKnownPredicates.h \
+	predicates/QuestPartsPredicates.h \
+	predicates/QuestStatePredicates.h \
+	predicates/ScriptPredicates.h \
+	predicates/TalentProbePredicates.h \
+	predicates/TalentWertPredicates.h

Modified: rl/trunk/engine/ai/include/ScriptProcessor.h
===================================================================
--- rl/trunk/engine/ai/include/ScriptProcessor.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/ScriptProcessor.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -17,7 +17,7 @@
 #define __Rl_ScriptProcessor_H__
 
 #include "XmlMapper/XmlNodeProcessor.h"
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "AimlBot.h"
 
 using namespace XmlMapper;

Modified: rl/trunk/engine/ai/include/predicates/CreaturePredicates.h
===================================================================
--- rl/trunk/engine/ai/include/predicates/CreaturePredicates.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/predicates/CreaturePredicates.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_CreaturePredicates_H__
 #define __Rl_CreaturePredicates_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "Predicates.h"
 using namespace MadaBot;
 

Modified: rl/trunk/engine/ai/include/predicates/QuestKnownPredicates.h
===================================================================
--- rl/trunk/engine/ai/include/predicates/QuestKnownPredicates.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/predicates/QuestKnownPredicates.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_QuestKnownPredicates_H__
 #define __Rl_QuestKnownPredicates_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "Predicates.h"
 
 namespace rl

Modified: rl/trunk/engine/ai/include/predicates/QuestPartsPredicates.h
===================================================================
--- rl/trunk/engine/ai/include/predicates/QuestPartsPredicates.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/predicates/QuestPartsPredicates.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_QuestPartsPredicates_H__
 #define __Rl_QuestPartsPredicates_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "Predicates.h"
 
 namespace rl

Modified: rl/trunk/engine/ai/include/predicates/QuestStatePredicates.h
===================================================================
--- rl/trunk/engine/ai/include/predicates/QuestStatePredicates.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/predicates/QuestStatePredicates.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_QuestStatePredicates_H__
 #define __Rl_QuestStatePredicates_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "Predicates.h"
 
 namespace rl

Modified: rl/trunk/engine/ai/include/predicates/ScriptPredicates.h
===================================================================
--- rl/trunk/engine/ai/include/predicates/ScriptPredicates.h	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/include/predicates/ScriptPredicates.h	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #ifndef __Rl_ScriptPredicates_H__
 #define __Rl_ScriptPredicates_H__
 
-#include "DialogPrerequisites.h"
+#include "AiPrerequisites.h"
 #include "Predicates.h"
 
 using namespace MadaBot;

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -49,7 +49,7 @@
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent->getControlledCreature());
 
-        if (!mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5)
+        if (mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5)
         {		
             mAgent->addForce(mAgent->calcPursuit(mPartner));
             mAgent->updateVehicle(0, elapsedTime);
@@ -59,7 +59,7 @@
         //    mAgent->addForce(mAgent->calcPursuit(mPartner));
         //    mAgent->updateVehicle(0, elapsedTime);
         //}
-        ///@todo: Turn if near
+        ///@todo: Turn if near but not correctly oriented
 		else
         {
 			if (!mTalking)

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -28,7 +28,24 @@
 #include "WayPointGraphManager.h"
 #include "World.h"
 
+#include <xercesc/util/PlatformUtils.hpp>
+
+#include "XmlHelper.h"
+#include "XmlResourceManager.h"
+#include "ContentModule.h"
+
+#include "AimlCore.h"
+#include "AimlParserImplRl.h"
+#include "DialogCharacter.h"
+#include "ScriptProcessor.h"
+#include "DialogScriptProcessor.h"
+#include "ContextInterpreter.h"
+
 using namespace Ogre;
+using namespace MadaBot;
+using namespace XERCES_CPP_NAMESPACE;
+
+using namespace Ogre;
 using namespace OpenSteer;
 
 template<> rl::AiSubsystem* Singleton<rl::AiSubsystem>::ms_Singleton = 0;
@@ -38,7 +55,11 @@
 AiSubsystem::AiSubsystem(void)
     : mAgentManager(NULL),
 	  mWayPointGraphManager(NULL),
-      mWorld(NULL)
+      mWorld(NULL),
+      mCore(new AimlCore()),
+	  mContextInterpreter(new ContextInterpreter()),
+	  mCurrentBot(NULL)
+
 {
     LOG_MESSAGE(Logger::AI, "Init Start");
     initialize();
@@ -55,6 +76,17 @@
     delete mAgentManager;
 	delete mWayPointGraphManager;
     delete mWorld;
+
+  	delete mCore;
+	delete mContextInterpreter;
+
+	for(BotMap::iterator iter = mBots.begin();
+		iter != mBots.end();
+		++iter)
+	{
+		delete iter->second;
+	}
+
 }
 
 void AiSubsystem::initialize()
@@ -71,6 +103,28 @@
 		    boost::bind(&AiSubsystem::onBeforeClearScene, this));
 
     GameLoop::getSingleton().addTask(AgentManager::getSingletonPtr(), GameLoop::TG_LOGIC);
+
+#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
+    setlocale(LC_ALL, "C");
+#endif
+
+	mCore->setParser(new AimlParserImplRl());
+	mCore->getBotInterpreter().addProcessor(new DialogScriptProcessor());
+	mCore->getAimlInterpreter().addProcessor(new ScriptProcessor());
+//  Initialize Xerces if this wasn't done already
+	try
+	{
+        XMLPlatformUtils::Initialize();
+		XmlHelper::initializeTranscoder();
+    }
+    catch (const XMLException& exc)
+	{
+		char* excmsg = XMLString::transcode(exc.getMessage());
+		std::string excs="Exception while initializing Xerces: ";
+		excs+=excmsg;
+		LOG_MESSAGE(Logger::DIALOG, excs);
+        XMLString::release(&excmsg);
+    }
 }
 
 bool AiSubsystem::onBeforeClearScene()
@@ -151,5 +205,65 @@
 	mLandmarks.clear();
 }
 
+DialogCharacter* AiSubsystem::getBot(const CeGuiString& botName)
+{
+	BotMap::iterator itr = mBots.find(botName);
+	if(itr != mBots.end())
+	{
+		return itr->second;
+	}
+	return NULL;
+}
 
+
+DialogCharacter* AiSubsystem::loadBot(const CeGuiString& botName, const CeGuiString& fileName)
+{
+	mCurrentBot = NULL;
+	AimlBot<CeGuiString>* bot = mCore->loadBot(botName.c_str(), fileName.c_str());
+//  while processing the bot definition, a DialogCharacter should have been created
+//  through a ruby script and stored in mCurrentBot
+    if (mCurrentBot == NULL)
+    {
+        mCurrentBot = new DialogCharacter();
+    }
+
+	if(bot != NULL)
+	{
+		mCurrentBot->setBot(bot);
+		mCurrentBot->initialize();
+	}
+	LOG_MESSAGE(Logger::DIALOG,"AimlBot " + botName + "loaded and initialized");
+	mBots.insert(BotMap::value_type(mCurrentBot->getName(), mCurrentBot));
+	return mCurrentBot;
 }
+
+ResourcePtr AiSubsystem::getXmlResource(const Ogre::String& filename)
+{
+    ResourcePtr res = XmlResourceManager::getSingleton().getByName(filename);
+
+    if (res.isNull())
+    {
+        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
+        if (ResourceGroupManager::getSingleton().resourceExists(
+			CoreSubsystem::getSingleton().getActiveAdventureModule()->getId(), filename))
+        {
+            group = CoreSubsystem::getSingleton().getActiveAdventureModule()->getId();
+        }
+        res = XmlResourceManager::getSingleton().create(filename, group);
+
+    }
+    return res;
+}
+
+void AiSubsystem::setCurrentDialogCharacter(DialogCharacter* bot)
+{
+	mCurrentBot = bot;
+}
+
+DialogCharacter* AiSubsystem::getCurrentDialogCharacter() const
+{
+    return mCurrentBot;
+}
+
+
+}

Modified: rl/trunk/engine/ai/src/DialogCharacter.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogCharacter.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/src/DialogCharacter.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -16,7 +16,7 @@
 #include "stdinc.h" //precompiled header
 
 #include "DialogCharacter.h"
-#include "DialogSubsystem.h"
+#include "AiSubsystem.h"
 #include "ContextInterpreter.h"
 #include "AimlBot.h"
 #include "Response.h"
@@ -116,7 +116,7 @@
 		Response<CeGuiString> response = mBot->respond(input);
 		if(response.hasGossip())
 		{
-			ContextInterpreter* interpreter = DialogSubsystem::getSingleton().getContextInterpreter();
+			ContextInterpreter* interpreter = AiSubsystem::getSingleton().getContextInterpreter();
 			if(interpreter!= NULL)
 			{
 				LOG_MESSAGE(Logger::DIALOG, "Create DialogResponse");

Modified: rl/trunk/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogOption.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/src/DialogOption.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -17,7 +17,7 @@
 
 #include "DialogOption.h"
 #include "DialogResponse.h"
-#include "DialogSubsystem.h"
+#include "AiSubsystem.h"
 #include "ContextInterpreter.h"
 #include "Response.h"
 
@@ -44,7 +44,7 @@
 void DialogOption::processSelection()
 {
 	DialogResponse* response = NULL;
-	ContextInterpreter* interpreter = DialogSubsystem::getSingleton().getContextInterpreter();
+	ContextInterpreter* interpreter = AiSubsystem::getSingleton().getContextInterpreter();
 	if(interpreter != NULL)
 	{
 		response = interpreter->interpret(mData->getGossip(), mBot);

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-08-21 22:05:49 UTC (rev 3727)
@@ -1,5 +1,5 @@
 INCLUDES = $(OGRE_CFLAGS) $(STLPORT_CFLAGS) $(CEGUIOGRE_CFLAGS) -I../include -I ../../core/include \
-	-I ../../common/include -I ../../dialog/include -I ../../rules/include
+	-I ../../common/include -I ../../dialog/include -I ../../rules/include -I../include/predicates
 
 lib_LTLIBRARIES = libRlAi.la
 libRlAi_la_LDFLAGS = $(OGRE_LIBS) $(LIBS)
@@ -24,4 +24,24 @@
 	SteeringVehicle.cpp \
 	WayPointNode.cpp \
 	WayPointGraph.cpp \
-	WayPointGraphManager.cpp
+	WayPointGraphManager.cpp \
+	AimlNodeImplRl.cpp \
+	AimlParserImplRl.cpp \
+	ContextConditionProcessor.cpp \
+	ContextInterpreter.cpp \
+	DialogCharacter.cpp \
+	DialogOption.cpp \
+	DialogResponse.cpp \
+	DialogScriptProcessor.cpp \
+	DialogSubsystem.cpp \
+	ScriptProcessor.cpp \
+	predicates/CreaturePredicates.cpp \
+	predicates/EigenschaftsProbePredicates.cpp \
+	predicates/EigenschaftsWertPredicates.cpp \
+	predicates/GrundWertPredicates.cpp \
+	predicates/QuestKnownPredicates.cpp \
+	predicates/QuestPartsPredicates.cpp \
+	predicates/QuestStatePredicates.cpp \
+	predicates/ScriptPredicates.cpp \
+	predicates/TalentProbePredicates.cpp \
+	predicates/TalentWertPredicates.cpp	

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-08-21 22:05:49 UTC (rev 3727)
@@ -66,10 +66,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib RlDialog.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlScript.pdb"
@@ -152,10 +152,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib RlDialog.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -236,10 +236,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib RlDialog.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -572,10 +572,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\swig\RlDialog.head.swig"
-					>
-				</File>
-				<File
 					RelativePath=".\swig\RlRules.head.swig"
 					>
 				</File>
@@ -604,10 +600,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\swig\RlDialog.swig"
-					>
-				</File>
-				<File
 					RelativePath=".\swig\RlRules.swig"
 					>
 				</File>

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-08-21 22:05:49 UTC (rev 3727)
@@ -34,4 +34,5 @@
 #include "Landmark.h"
 #include "LandmarkPath.h"
 #include "CreatureWalkPathJob.h"
+#include "DialogCharacter.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-21 22:05:49 UTC (rev 3727)
@@ -93,10 +93,37 @@
         void pushState(rl::AgentStateType type);
 	};
 
+    %feature("director") DialogCharacter;
+	class DialogCharacter
+	{
+	public:
+		DialogCharacter();
+		virtual ~DialogCharacter();
+
+		const rl::CeGuiString getName() const;
+		rl::Creature* getDialogCharacter() const;
+		void setDialogCharacter(rl::Creature* dialogCharacter);
+		rl::Creature* getDialogPartner() const;
+		void setDialogPartner(rl::Creature* dialogPartner);
+		
+		rl::Creature* getNonPlayerCharacter()const;
+		void setNonPlayerCharacter(rl::Creature* npc);
+		
+		rl::Creature* getPlayerCharacter()const;
+		void setPlayerCharacter(rl::Creature* pc);
+		
+		virtual int calcOptionValue(const rl::CeGuiString& optionName)=0;	
+		virtual int calcResponseValue(const rl::CeGuiString& responseName)=0;
+		virtual int calcSelectionValue(const rl::CeGuiString& selectionName)=0;
+	};
+
 	class AiSubsystem 
 	{
 	public:
 		static AiSubsystem& getSingleton(void);
+		rl::DialogCharacter* getBot(const rl::CeGuiString& botName);
+		rl::DialogCharacter* loadBot(const rl::CeGuiString& fileName, const rl::CeGuiString& botName = "");
+		void setCurrentDialogCharacter(rl::DialogCharacter* bot);
 	};
 	
 	%feature("director") BehaviourFactory;

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-08-21 22:05:49 UTC (rev 3727)
@@ -958,7 +958,7 @@
     virtual void setTimeFactor(Ogre::Real factor = 1.0) = 0;
 };
 
-class TimeSourceManager : public Ogre::Singleton<rl::TimeSourceManager>
+class TimeSourceManager
 {
 public:
     static rl::TimeSourceManager& getSingleton();

Deleted: rl/trunk/engine/script/swig/RlDialog.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.head.swig	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlDialog.head.swig	2007-08-21 22:05:49 UTC (rev 3727)
@@ -1,23 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-%{
-//----------- Includes - Dialog -----------
-#include "FixRubyHeaders.h"
-#include "DialogPrerequisites.h"
-#include "DialogSubsystem.h"
-#include "DialogCharacter.h"
-%}
\ No newline at end of file

Deleted: rl/trunk/engine/script/swig/RlDialog.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.swig	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlDialog.swig	2007-08-21 22:05:49 UTC (rev 3727)
@@ -1,51 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-namespace rl 
-{
-	%feature("director") DialogCharacter;
-	class DialogCharacter
-	{
-	public:
-		DialogCharacter();
-		virtual ~DialogCharacter();
-
-		const rl::CeGuiString getName() const;
-		rl::Creature* getDialogCharacter() const;
-		void setDialogCharacter(rl::Creature* dialogCharacter);
-		rl::Creature* getDialogPartner() const;
-		void setDialogPartner(rl::Creature* dialogPartner);
-		
-		rl::Creature* getNonPlayerCharacter()const;
-		void setNonPlayerCharacter(rl::Creature* npc);
-		
-		rl::Creature* getPlayerCharacter()const;
-		void setPlayerCharacter(rl::Creature* pc);
-		
-		virtual int calcOptionValue(const rl::CeGuiString& optionName)=0;	
-		virtual int calcResponseValue(const rl::CeGuiString& responseName)=0;
-		virtual int calcSelectionValue(const rl::CeGuiString& selectionName)=0;
-	};
-
-	class DialogSubsystem 
-	{
-	public:
-		static DialogSubsystem& getSingleton(void);
-		rl::DialogCharacter* getBot(const rl::CeGuiString& botName);
-		rl::DialogCharacter* loadBot(const rl::CeGuiString& fileName, const rl::CeGuiString& botName = "");
-		void setCurrentDialogCharacter(rl::DialogCharacter* bot);
-	};
-}

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-08-21 22:05:49 UTC (rev 3727)
@@ -60,7 +60,6 @@
 %include "RlUi.head.swig"
 %include "RlCore.head.swig"
 %include "RlRules.head.swig"
-%include "RlDialog.head.swig"
 %include "RlAi.head.swig"
 %include "RlScript.head.swig"
 
@@ -174,7 +173,6 @@
 %include "RlCommon.swig"
 %include "RlCore.swig"
 %include "RlRules.swig"
-%include "RlDialog.swig"
 %include "RlUi.swig"
 %include "RlAi.swig"
 %include "RlScript.swig"

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -23,7 +23,6 @@
 #include "CoreSubsystem.h"
 #include "GameLoop.h"
 #include "RulesSubsystem.h"
-#include "DialogSubsystem.h"
 #include "AiSubsystem.h"
 #include "UiSubsystem.h"
 #include "ScriptSubsystem.h"
@@ -43,7 +42,6 @@
 {
     rl::CoreSubsystem* core = NULL;
     rl::RulesSubsystem* rules = NULL;
-    rl::DialogSubsystem* dialog = NULL;
     rl::AiSubsystem* ai = NULL;
     rl::UiSubsystem* ui =  NULL;
     rl::ScriptSubsystem* script =  NULL;
@@ -72,9 +70,6 @@
         rules = new rl::RulesSubsystem();
         LOG_MESSAGE_SHORT("RulesSubsystem gestartet");
 
-        dialog = new rl::DialogSubsystem();
-        LOG_MESSAGE_SHORT("DialogSubsystem gestartet");
-
         ai = new rl::AiSubsystem();
         LOG_MESSAGE_SHORT("AiSubsystem gestartet");
 
@@ -130,7 +125,6 @@
         delete script;
         delete ui;
         delete ai;
-        delete dialog;
         delete rules;
         delete core;
         delete logger;

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-08-21 22:05:49 UTC (rev 3727)
@@ -48,7 +48,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -162,7 +162,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -266,7 +266,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-21 19:44:44 UTC (rev 3726)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-21 22:05:49 UTC (rev 3727)
@@ -20,6 +20,7 @@
 #include "Exception.h"
 
 #include "Actor.h"
+#include "AiSubsystem.h"
 #include "CameraObject.h"
 #include "CommandMapper.h"
 #include "ConfigurationManager.h"
@@ -27,7 +28,6 @@
 #include "DialogCharacter.h"
 #include "DialogOption.h"
 #include "DialogResponse.h"
-#include "DialogSubsystem.h"
 #include "DialogWindow.h"
 #include "GameLoggerWindow.h"
 #include "InputManager.h"
@@ -121,7 +121,7 @@
 
 		mGameLogger = WindowFactory::getSingleton().getGameLogger();
 
-		DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
+		DialogCharacter* bot = AiSubsystem::getSingleton().getCurrentDialogCharacter();
 		initialize(bot);
     }
 



From blakharaz at mail.berlios.de  Wed Aug 22 00:20:40 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 22 Aug 2007 00:20:40 +0200
Subject: [Dsa-hl-svn] r3728 - in modules: common/scripts minidemo/scripts
	techdemo2/scripts techdemo2/scripts/maps tutorial/scripts/maps
Message-ID: <200708212220.l7LMKeu1010268@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-22 00:20:29 +0200 (Wed, 22 Aug 2007)
New Revision: 3728

Modified:
   modules/common/scripts/globals.rb
   modules/common/scripts/initialize_factories.rb
   modules/common/scripts/npc.rb
   modules/minidemo/scripts/enemy.rb
   modules/techdemo2/scripts/forrest.rb
   modules/techdemo2/scripts/jarn.rb
   modules/techdemo2/scripts/maps/techdemo2map1.rb
   modules/techdemo2/scripts/maps/techdemo2map2.rb
   modules/techdemo2/scripts/waldwoelfe_retten.rb
   modules/tutorial/scripts/maps/nscs.rb
   modules/tutorial/scripts/maps/tutorial.rb
Log:
Finished merging dialog subsystem into the AI subsystem (fixes in ruby scripts)

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/common/scripts/globals.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -12,7 +12,8 @@
 $UI = UiSubsystem.getSingleton();
 $DM = DsaManager.getSingleton();
 $WF = WindowFactory.getSingleton();
-$AI = AgentManager.getSingleton();
+$AI = AiSubsystem.getSingleton();
+$AGM = AiSubsystem.getSingleton();
 $WPGM = WayPointGraphManager.getSingleton();
 $DVM = DebugVisualsManager.getSingleton();
 $SCRIPT = ScriptSubsystem.getSingleton();

Modified: modules/common/scripts/initialize_factories.rb
===================================================================
--- modules/common/scripts/initialize_factories.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/common/scripts/initialize_factories.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -22,6 +22,6 @@
 
 factory = RubyClassFactory.new()
 $GOM.setGameObjectFactory(factory);
-$AI.setBehaviourFactory(factory);
+$AGM.setBehaviourFactory(factory);
 $SCRIPT.setTriggerFactory(factory)
 EffectFactoryManager.getSingleton().setEffectFactory(factory)

Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/common/scripts/npc.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -62,7 +62,7 @@
     #bot = $DS.loadBot("Sonja", "sonja.xml");
     #bot.setNonPlayerCharacter(sonja);
     #
-    #agent = $AI.createAgent(bot);
+    #agent = $AGM.createAgent(bot);
     #agent.addSteeringBehaviour(DefaultIdleBehaviour.new);
     #agent.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
     #agent.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));

Modified: modules/minidemo/scripts/enemy.rb
===================================================================
--- modules/minidemo/scripts/enemy.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/minidemo/scripts/enemy.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -15,7 +15,7 @@
 se = SimpleEnemy.new( "Wolf","Lebendiger Wolf","Toter Wolf","kiste.mesh","spinne_todesschrei_01.ogg");
 se.getActor().placeIntoScene([1.40, 2.80, 2.20]) 
 
-agent = $AI.createAgent(AgentManager::AGENT_STD_NPC, se )
+agent = $AGM.createAgent(AgentManager::AGENT_STD_NPC, se )
 agent.addSteeringBehaviour(DefaultWanderBehaviour.new);
 agent.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 

Modified: modules/techdemo2/scripts/forrest.rb
===================================================================
--- modules/techdemo2/scripts/forrest.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/techdemo2/scripts/forrest.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -13,7 +13,7 @@
 #bot=$AI.loadBot("Forrest", "forrest.xml");
 #bot.setNonPlayerCharacter(forrest);
 #forrest.addAction(TalkAction.new("Forrest", "forrest.xml"));
-#agent = $AI.createAgent(bot);
+#agent = $AGM.createAgent(bot);
 #agent.addSteeringBehaviour(DefaultWanderBehaviour.new);
 #agent.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 #agent.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));

Modified: modules/techdemo2/scripts/jarn.rb
===================================================================
--- modules/techdemo2/scripts/jarn.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/techdemo2/scripts/jarn.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -14,7 +14,7 @@
 #bot = $AI.loadBot("Jarn", "jarn.xml");
 #bot.setNonPlayerCharacter(jarn);
 #jarn.addAction(TalkAction.new("Jarn", "jarn.xml"));
-#agent = $AI.createAgent(bot);
+#agent = $AGM.createAgent(bot);
 #agent.addSteeringBehaviour(DefaultIdleBehaviour.new);
 ##agent.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 #agent.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));

Modified: modules/techdemo2/scripts/maps/techdemo2map1.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map1.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/techdemo2/scripts/maps/techdemo2map1.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -16,7 +16,7 @@
 $UI.setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
-#$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
+#$heroVehicle = $AGM.createAgent(AgentManager::AGENT_PLAYER, $hero);	
 #$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
 
 

Modified: modules/techdemo2/scripts/maps/techdemo2map2.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map2.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/techdemo2/scripts/maps/techdemo2map2.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -13,7 +13,7 @@
 $UI.setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
-#$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
+#$heroVehicle = $AGM.createAgent(AgentManager::AGENT_PLAYER, $hero);	
 #$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
 
 

Modified: modules/techdemo2/scripts/waldwoelfe_retten.rb
===================================================================
--- modules/techdemo2/scripts/waldwoelfe_retten.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/techdemo2/scripts/waldwoelfe_retten.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -42,7 +42,7 @@
     se = SimpleEnemy.new( "Wolf_"+wolfnum.to_s,"Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz.","Ein sehr toter Wolf","tie_wolf_01.mesh","wolf_sterben_001.ogg");
     se.getActor().placeIntoScene( pos ) 
 
-    agent = $AI.createAgent(AgentManager::AGENT_STD_NPC, se )
+    agent = $AGM.createAgent(AgentManager::AGENT_STD_NPC, se )
     agent.addSteeringBehaviour(DefaultWanderBehaviour.new);
     agent.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 

Modified: modules/tutorial/scripts/maps/nscs.rb
===================================================================
--- modules/tutorial/scripts/maps/nscs.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/tutorial/scripts/maps/nscs.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -10,7 +10,7 @@
 bot01 = $AI.loadBot("AIML01", "nscs.xml");
 bot01.setNonPlayerCharacter(nsc01);
 nsc01.addAction(TalkAction.new("AIML01", "nscs.xml"));
-agent01 = $AI.createAgent(bot01);
+agent01 = $AGM.createAgent(bot01);
 agent01.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent01.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent01.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -25,7 +25,7 @@
 bot02 = $AI.loadBot("AIML02", "nscs.xml");
 bot02.setNonPlayerCharacter(nsc02);
 nsc02.addAction(TalkAction.new("AIML02", "nscs.xml"));
-agent02 = $AI.createAgent(bot02);
+agent02 = $AGM.createAgent(bot02);
 agent02.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent02.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent02.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -40,7 +40,7 @@
 bot03 = $AI.loadBot("AIML03", "nscs.xml");
 bot03.setNonPlayerCharacter(nsc03);
 nsc03.addAction(TalkAction.new("AIML03", "nscs.xml"));
-agent03 = $AI.createAgent(bot03);
+agent03 = $AGM.createAgent(bot03);
 agent03.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent03.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent03.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -55,7 +55,7 @@
 bot04 = $AI.loadBot("AIML04", "nscs.xml");
 bot04.setNonPlayerCharacter(nsc04);
 nsc04.addAction(TalkAction.new("AIML04", "nscs.xml"));
-agent04 = $AI.createAgent(bot04);
+agent04 = $AGM.createAgent(bot04);
 agent04.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent04.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent04.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -70,7 +70,7 @@
 bot05 = $AI.loadBot("AIML05", "nscs.xml");
 bot05.setNonPlayerCharacter(nsc05);
 nsc05.addAction(TalkAction.new("AIML05", "nscs.xml"));
-agent05 = $AI.createAgent(bot05);
+agent05 = $AGM.createAgent(bot05);
 agent05.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent05.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent05.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -86,7 +86,7 @@
 bot06 = $AI.loadBot("AIML06", "nscs.xml");
 bot06.setNonPlayerCharacter(nsc06);
 nsc06.addAction(TalkAction.new("AIML06", "nscs.xml"));
-agent06 = $AI.createAgent(bot06);
+agent06 = $AGM.createAgent(bot06);
 agent06.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent06.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent06.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -103,7 +103,7 @@
 bot08 = $AI.loadBot("AIML08", "nscs.xml");
 bot08.setNonPlayerCharacter(nsc08);
 nsc08.addAction(TalkAction.new("AIML08", "nscs.xml"));
-agent08 = $AI.createAgent(bot08);
+agent08 = $AGM.createAgent(bot08);
 agent08.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent08.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent08.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -118,7 +118,7 @@
 bot09 = $AI.loadBot("AIML09", "nscs.xml");
 bot09.setNonPlayerCharacter(nsc09);
 nsc09.addAction(TalkAction.new("AIML09", "nscs.xml"));
-agent09 = $AI.createAgent(bot09);
+agent09 = $AGM.createAgent(bot09);
 agent09.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent09.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent09.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));
@@ -134,7 +134,7 @@
 bot10 = $AI.loadBot("AIML10", "nscs.xml");
 bot10.setNonPlayerCharacter(nsc10);
 nsc10.addAction(TalkAction.new("AIML10", "nscs.xml"));
-agent10 = $AI.createAgent(bot10);
+agent10 = $AGM.createAgent(bot10);
 agent10.addSteeringBehaviour(DefaultIdleBehaviour.new);
 #agent10.addSteeringBehaviour(AvoidObstaclesBehaviour.new);
 agent10.addSteeringBehaviour(DialogBehaviour.new($heroVehicle));

Modified: modules/tutorial/scripts/maps/tutorial.rb
===================================================================
--- modules/tutorial/scripts/maps/tutorial.rb	2007-08-21 22:05:49 UTC (rev 3727)
+++ modules/tutorial/scripts/maps/tutorial.rb	2007-08-21 22:20:29 UTC (rev 3728)
@@ -21,7 +21,7 @@
 $SCRIPT.log("Held vorbereitet.");
 $UI.setActiveCharacter($hero);
 $SCRIPT.log("Held als aktiver Charakter gesetzt.");
-$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
+$heroVehicle = $AGM.createAgent(AgentManager::AGENT_PLAYER, $hero);	
 $SCRIPT.log("SteeringVehicle f?r Held erstellen...");
 		
 



From blakharaz at mail.berlios.de  Wed Aug 22 00:30:30 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 22 Aug 2007 00:30:30 +0200
Subject: [Dsa-hl-svn] r3729 - rl/trunk/engine/ai/src
Message-ID: <200708212230.l7LMUUnR011390@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-22 00:30:27 +0200 (Wed, 22 Aug 2007)
New Revision: 3729

Removed:
   rl/trunk/engine/ai/src/DialogSubsystem.cpp
Log:
Die! Die! Die!

Deleted: rl/trunk/engine/ai/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogSubsystem.cpp	2007-08-21 22:20:29 UTC (rev 3728)
+++ rl/trunk/engine/ai/src/DialogSubsystem.cpp	2007-08-21 22:30:27 UTC (rev 3729)
@@ -1,150 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <xercesc/util/PlatformUtils.hpp>
-
-#include "XmlHelper.h"
-#include "XmlResourceManager.h"
-#include "Logger.h"
-#include "CoreSubsystem.h"
-#include "ContentModule.h"
-
-#include "DialogSubsystem.h"
-#include "AimlCore.h"
-#include "AimlParserImplRl.h"
-#include "DialogCharacter.h"
-#include "ScriptProcessor.h"
-#include "DialogScriptProcessor.h"
-#include "ContextInterpreter.h"
-
-using namespace Ogre;
-using namespace MadaBot;
-using namespace XERCES_CPP_NAMESPACE;
-
-template<> rl::DialogSubsystem* Singleton<rl::DialogSubsystem>::ms_Singleton = 0;
-
-namespace rl {
-
-DialogSubsystem::DialogSubsystem()
-	: mCore(new AimlCore()),
-	  mContextInterpreter(new ContextInterpreter()),
-	  mCurrentBot(NULL)
-{
-	LOG_MESSAGE(Logger::DIALOG, "Init Start");
-	initialize();
-	LOG_MESSAGE(Logger::DIALOG, "Init Ende");
-}
-
-DialogSubsystem::~DialogSubsystem()
-{
-	delete mCore;
-	delete mContextInterpreter;
-
-	for(BotMap::iterator iter = mBots.begin();
-		iter != mBots.end();
-		++iter)
-	{
-		delete iter->second;
-	}
-}
-
-void DialogSubsystem::initialize()
-{
-#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
-    setlocale(LC_ALL, "C");
-#endif
-
-	mCore->setParser(new AimlParserImplRl());
-	mCore->getBotInterpreter().addProcessor(new DialogScriptProcessor());
-	mCore->getAimlInterpreter().addProcessor(new ScriptProcessor());
-//  Initialize Xerces if this wasn't done already
-	try
-	{
-        XMLPlatformUtils::Initialize();
-		XmlHelper::initializeTranscoder();
-    }
-    catch (const XMLException& exc)
-	{
-		char* excmsg = XMLString::transcode(exc.getMessage());
-		std::string excs="Exception while initializing Xerces: ";
-		excs+=excmsg;
-		LOG_MESSAGE(Logger::DIALOG, excs);
-        XMLString::release(&excmsg);
-    }
-}
-
-DialogCharacter* DialogSubsystem::getBot(const CeGuiString& botName)
-{
-	BotMap::iterator itr = mBots.find(botName);
-	if(itr != mBots.end())
-	{
-		return itr->second;
-	}
-	return NULL;
-}
-
-
-DialogCharacter* DialogSubsystem::loadBot(const CeGuiString& botName, const CeGuiString& fileName)
-{
-	mCurrentBot = NULL;
-	AimlBot<CeGuiString>* bot = mCore->loadBot(botName.c_str(), fileName.c_str());
-//  while processing the bot definition, a DialogCharacter should have been created
-//  through a ruby script and stored in mCurrentBot
-    if (mCurrentBot == NULL)
-    {
-        mCurrentBot = new DialogCharacter();
-    }
-
-	if(bot != NULL)
-	{
-		mCurrentBot->setBot(bot);
-		mCurrentBot->initialize();
-	}
-	LOG_MESSAGE(Logger::DIALOG,"AimlBot " + botName + "loaded and initialized");
-	mBots.insert(BotMap::value_type(mCurrentBot->getName(), mCurrentBot));
-	return mCurrentBot;
-}
-
-ResourcePtr DialogSubsystem::getXmlResource(const Ogre::String& filename)
-{
-    ResourcePtr res = XmlResourceManager::getSingleton().getByName(filename);
-
-    if (res.isNull())
-    {
-        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
-        if (ResourceGroupManager::getSingleton().resourceExists(
-			CoreSubsystem::getSingleton().getActiveAdventureModule()->getId(), filename))
-        {
-            group = CoreSubsystem::getSingleton().getActiveAdventureModule()->getId();
-        }
-        res = XmlResourceManager::getSingleton().create(filename, group);
-
-    }
-    return res;
-}
-
-void DialogSubsystem::setCurrentDialogCharacter(DialogCharacter* bot)
-{
-	mCurrentBot = bot;
-}
-
-DialogCharacter* DialogSubsystem::getCurrentDialogCharacter() const
-{
-    return mCurrentBot;
-}
-
-}



From tanis at mail.berlios.de  Wed Aug 22 01:30:37 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 22 Aug 2007 01:30:37 +0200
Subject: [Dsa-hl-svn] r3730 - rl/trunk/engine/ai
Message-ID: <200708212330.l7LNUbrx031478@sheep.berlios.de>

Author: tanis
Date: 2007-08-22 01:30:34 +0200 (Wed, 22 Aug 2007)
New Revision: 3730

Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
Log:
Added needed XERCES dependency to AI subproject.

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-21 22:30:27 UTC (rev 3729)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-21 23:30:34 UTC (rev 3730)
@@ -41,7 +41,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -76,7 +76,7 @@
 				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2D.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlAI.pdb"
@@ -141,7 +141,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"
@@ -164,7 +164,7 @@
 				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -227,7 +227,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"
@@ -250,7 +250,7 @@
 				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"



From tanis at mail.berlios.de  Wed Aug 22 21:13:51 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 22 Aug 2007 21:13:51 +0200
Subject: [Dsa-hl-svn] r3731 - modules/common/scripts
Message-ID: <200708221913.l7MJDpwN017710@sheep.berlios.de>

Author: tanis
Date: 2007-08-22 21:13:27 +0200 (Wed, 22 Aug 2007)
New Revision: 3731

Modified:
   modules/common/scripts/globals.rb
Log:
Fixed copy/pasted error. Global actions work again.

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-08-21 23:30:34 UTC (rev 3730)
+++ modules/common/scripts/globals.rb	2007-08-22 19:13:27 UTC (rev 3731)
@@ -13,7 +13,7 @@
 $DM = DsaManager.getSingleton();
 $WF = WindowFactory.getSingleton();
 $AI = AiSubsystem.getSingleton();
-$AGM = AiSubsystem.getSingleton();
+$AGM = AgentManager.getSingleton();
 $WPGM = WayPointGraphManager.getSingleton();
 $DVM = DebugVisualsManager.getSingleton();
 $SCRIPT = ScriptSubsystem.getSingleton();



From melven at mail.berlios.de  Thu Aug 23 00:17:27 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 23 Aug 2007 00:17:27 +0200
Subject: [Dsa-hl-svn] r3732 - in rl/trunk/engine: core/src ui/src
Message-ID: <200708222217.l7MMHRae031976@sheep.berlios.de>

Author: melven
Date: 2007-08-23 00:17:17 +0200 (Thu, 23 Aug 2007)
New Revision: 3732

Modified:
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/ui/src/ControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Updated Camera Material (found old values from before CreatureController)

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2007-08-22 19:13:27 UTC (rev 3731)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2007-08-22 22:17:17 UTC (rev 3732)
@@ -291,8 +291,8 @@
                 .createPhysicalThing(GT_SPHERE, co,
                 100.0f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
-			pt->_getBody()->setMaterialGroupID(
-                PhysicsManager::getSingleton().getMaterialID("character"));
+            pt->_getBody()->setMaterialGroupID(
+                PhysicsManager::getSingleton().createMaterialID("camera"));
             actor = new Actor(uniquename, co, pt);
 
             mActors.insert(ActorPtrPair(uniquename,actor));

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2007-08-22 19:13:27 UTC (rev 3731)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2007-08-22 22:17:17 UTC (rev 3732)
@@ -87,18 +87,18 @@
 
 		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
 
-        PhysicsManager::getSingleton().createMaterialID("character");
+        PhysicsManager::getSingleton().createMaterialID("camera");
 
         PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
-            PhysicsManager::getSingleton().getMaterialID("default"))->setDefaultFriction(0,0);
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"))->setDefaultCollidable(0);
 
         PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
-            PhysicsManager::getSingleton().getMaterialID("level"))->setDefaultFriction(0,0);
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"))->setDefaultCollidable(0);
 
         PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
 	}
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-22 19:13:27 UTC (rev 3731)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-22 22:17:17 UTC (rev 3732)
@@ -206,7 +206,7 @@
 
         // control camera
         mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().createMaterialID("camera"));
+            PhysicsManager::getSingleton().getMaterialID("camera"));
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
 
         // We also handle cam<->level, cam<->default cam<->char collision from now on



From melven at mail.berlios.de  Thu Aug 23 00:22:59 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 23 Aug 2007 00:22:59 +0200
Subject: [Dsa-hl-svn] r3733 - in rl/trunk/engine: rules/include rules/src
	script/swig ui/include ui/src
Message-ID: <200708222222.l7MMMxpE032507@sheep.berlios.de>

Author: melven
Date: 2007-08-23 00:22:44 +0200 (Thu, 23 Aug 2007)
New Revision: 3733

Modified:
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/include/Slot.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/rules/src/Slot.cpp
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
-implemented GOS_READY in slots with another itemMask
-fixed bugs in InventoryWindow
-items automatically remove themselves from containers and slots, if assigned to another

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-08-22 22:22:44 UTC (rev 3733)
@@ -76,14 +76,16 @@
 
 
     // Das Inventar der Kreatur wird durch das Inventarobjekt verwaltet.
-    void addToInventory(Item* item, const CeGuiString& containerName);
+    //void addToInventory(Item* item, const CeGuiString& containerName);
     void hold(Item* item, const CeGuiString& slotName);
     bool canHold(Item* item, const CeGuiString& slotName) const;
+    bool canReady(Item* item, const CeGuiString& slotName) const;
 	void dropItem(const CeGuiString& slotName);
     void ready(Item* item);
+    //void removeFromInventory(Item* item);
 
     Item* getItem(const CeGuiString& slotName) const;
-    void addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type = SLOT_BONE);
+    void addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
     const SlotMap& getAllSlots() const;
 
 	Creature* getOwner() const;

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/include/Item.h	2007-08-22 22:22:44 UTC (rev 3733)
@@ -22,6 +22,8 @@
 namespace rl
 {
 	class _RlRulesExport Item;
+    class Slot;
+    class Container;
 
 	typedef std::vector<Item*> ContainerColumn;
 	typedef std::vector<ContainerColumn> ContainerLayout;
@@ -76,9 +78,25 @@
 		std::pair<int,int> getSize() const;
 		void setSize(int width, int height);
 
+
+        /**
+         * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
+         * @warning Falls ein Actor existiert, wird dieser gel?scht. Das bedeutet, dass diese Funktion
+         * aufgerufen werden muss, bevor gegebenenfalls ein neuer Actor erstellt wird!
+         * Der Owner und der ParentSlot wird ebenfalls resettet. Au?erdem wird das Item aus dem Slot entfernt!
+         * Bei den drei States ist die zu Grunde liegende Idee, dass man (in dieser Reihenfolge) mit dieser
+         * Funktion den neuen State setzt und dann dann den neuen State einrichtet (evt doCreateActor() aufruft).
+         * Dabei muss man sich nicht mehr darum k?mmern, welchen State das Item vorher hatte.
+         **/
         virtual void setState(GameObjectState state);
-        void hold();
+        //void hold();
 
+        void setParentSlot(Slot* slot);
+        Slot* getParentSlot() const;
+
+        void setParentContainer(Container* cont);
+        Container* getParentContainer() const;
+
         void setOwner(GameObject* go);
         GameObject* getOwner() const;
 
@@ -86,11 +104,14 @@
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
+        void doCreateActor();
     protected:
 		ItemType mItemType;
 		CeGuiString mImageName;
 		std::pair<int,int> mSize;
         GameObject* mOwner;
+        Slot* mParentSlot;
+        Container* mParentContainer;
 
 		void doHold();
 		void doLoose();

Modified: rl/trunk/engine/rules/include/Slot.h
===================================================================
--- rl/trunk/engine/rules/include/Slot.h	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/include/Slot.h	2007-08-22 22:22:44 UTC (rev 3733)
@@ -28,24 +28,34 @@
 public:
     virtual void setItem(Item* item) = 0;
     Item* getItem() const;
-    bool isAllowed(Item* item) const;
+    bool isAllowed(const Item* item) const;
+    bool isEmpty() const {return mItem == NULL;}
+    bool canReady(const Item* item) const;
+    CeGuiString getName() const {return mName;}
     virtual ~Slot();
 
 protected:
-    Slot(Creature* owner, const CeGuiString& name, int itemMask);
+    Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
 
+    // intended to be used in setItem-Function, provides standard behaviour, sets
+    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
+    bool standardSetItem(Item* item);
+
     Creature* mOwner;
     Item* mItem;
 
 private:
     CeGuiString mName;
-    int mItemMask;
+    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+    int mItemHeldMask;
+    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+    int mItemReadyMask;
 };
 
 class BoneSlot : public Slot
 {
 public:
-    BoneSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& bone);
+    BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
     virtual void setItem(Item* item);
 
 private:
@@ -55,7 +65,7 @@
 class SubmeshSlot : public Slot
 {
 public:
-    SubmeshSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh);
+    SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
     virtual void setItem(Item* item);
 
 private:
@@ -65,7 +75,7 @@
 class MaterialSlot : public Slot
 {
 public:
-    MaterialSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh);
+    MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
     virtual void setItem(Item* item);
 
 private:

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -113,6 +113,7 @@
 			mItemPositions[item] = pos;
 			mItems.insert(item);
 			item->setState(GOS_IN_POSSESSION);
+            item->setParentContainer(this);
 			return true;
 		}
 		else
@@ -128,7 +129,11 @@
         {
             mItems.erase(it);
             mItemPositions.erase(mItemPositions.find(item));
-            item->setState(GOS_LOADED);
+            
+            // this is the case, if the item is removed automatically
+            // don't change this without looking at Item::setState
+            if( item->getState() != GOS_LOADED )
+                item->setState(GOS_LOADED);
         }
         else
         {

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -46,6 +46,9 @@
 
         physicsManager->createMaterialPair(char_mat, def_mat)->setContactCallback(this);
         physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
+        
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0,0);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0,0);
     }
 
     CreatureControllerManager::~CreatureControllerManager()

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -176,7 +176,7 @@
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
-        slotIter->second->getItem()->setOwner(NULL);
+        //slotIter->second->getItem()->setOwner(NULL);
         slotIter->second->setItem(NULL);
 
 	}
@@ -190,7 +190,7 @@
         }
 
         slotIter->second->setItem(item);
-        item->setOwner(getOwner());
+        //item->setOwner(getOwner());
     }
 
 	bool Inventory::canHold(Item* item, const CeGuiString& slotName) const
@@ -204,6 +204,17 @@
 		return slotIter->second->isAllowed(item);
     }
 
+	bool Inventory::canReady(Item* item, const CeGuiString& slotName) const
+    {
+        std::map<CeGuiString, Slot*>::const_iterator slotIter = mSlots.find(slotName);
+        if (slotIter == mSlots.end())
+        {
+            Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
+        }
+
+		return true;//slotIter->second->canReady(item);
+    }
+
     Item* Inventory::getItem(const CeGuiString& slotName) const
     {
         std::map<CeGuiString, Slot*>::const_iterator slotIter = mSlots.find(slotName);
@@ -219,7 +230,7 @@
     {
     }
 
-    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type)
+    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type)
     {
         if (mSlots.find(name) != mSlots.end())
         {
@@ -229,13 +240,13 @@
 		switch (type)
         {
             case SLOT_BONE:
-			    mSlots[name] = new BoneSlot(mOwner, name, itemMask, meshpartname);
+			    mSlots[name] = new BoneSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
                 break;
             case SLOT_SUBMESH:
-			    mSlots[name] = new SubmeshSlot(mOwner, name, itemMask, meshpartname);
+			    mSlots[name] = new SubmeshSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
                 break;
             case SLOT_MATERIAL:
-			    mSlots[name] = new MaterialSlot(mOwner, name, itemMask, meshpartname);
+			    mSlots[name] = new MaterialSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
                 break;
 		}
     }

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -18,7 +18,9 @@
 #include "Item.h"
 
 #include "Actor.h"
+#include "Container.h"
 #include "Exception.h"
+#include "Slot.h"
 
 using namespace std;
 
@@ -35,7 +37,9 @@
 		mItemType(ITEMTYPE_OTHER),
 		mImageName(""),
 		mSize(pair<int,int>(1,1)),
-        mOwner(NULL)
+        mOwner(NULL),
+        mParentSlot(NULL),
+        mParentContainer(NULL)
     {
         mQueryFlags |= QUERYFLAG_ITEM;
     }
@@ -78,29 +82,79 @@
 	{
 		mSize = pair<int,int>(widthSize,heightSize);
 	}
-
+/*
 	void Item::hold()
 	{
 		setState(GOS_HELD);
 	}
-
+*/
     void Item::doHold()
     {
         setActor(createActor());
         mState = GOS_HELD;
     }
 
-	void Item::doLoose()
-	{
-		if (mActor != NULL)
-		{
-			mActor->detachFromParent();
-			///@todo is mState = GOS_IN_SCENE; after detaching?
-		}
-	}
+    void Item::doLoose()
+    {
+        if (mActor != NULL)
+        {
+            mActor->detachFromParent();
+            destroyActor();
+        }
+    }
 
+// --------------- Warning ------------
+// do not change this function without
+// having a look at the containers and slots
     void Item::setState(GameObjectState targetstate)
     {
+        // do reset if one of the new states
+        if (mState != GOS_HELD && mState != GOS_IN_POSSESSION && mState != GOS_READY &&
+            mState == targetstate)
+        {
+            return;
+        }
+
+        GameObjectState oldState = mState;
+
+
+        if( mState == GOS_HELD ||
+            mState == GOS_IN_POSSESSION ||
+            mState == GOS_READY )
+        {
+            mState = GOS_LOADED; // <- this is important to avoid endless recursion!
+            if( getParentSlot() )
+                getParentSlot()->setItem(NULL);
+            setParentSlot(NULL);
+            if( getParentContainer() )
+                getParentContainer()->removeItem(this);
+            setParentContainer(NULL);
+            doLoose();
+            setOwner(NULL);
+        }
+        else
+        {
+            GameObject::setState(GOS_LOADED);
+            oldState = GOS_LOADED;
+        }
+
+        if( targetstate == GOS_HELD || 
+            targetstate == GOS_IN_POSSESSION || 
+            targetstate == GOS_READY )
+        {
+            mState = targetstate;
+            onStateChange(oldState, mState);
+        }
+        else
+        {
+            onStateChange(oldState, mState);
+            GameObject::setState(targetstate);
+        }
+    }
+
+/*
+    void Item::setState(GameObjectState targetstate)
+    {
         if (mState == targetstate)
         {
             return;
@@ -111,6 +165,23 @@
 
         if (targetstate == GOS_IN_POSSESSION)
         {
+            if( mState == GOS_HELD ||
+                mState == GOS_IN_POSSESSION ||
+                mState == GOS_READY )
+            {
+                mState = GOS_LOADED;
+                doLoose();
+                setOwner(NULL);
+                onStateChange(oldState, mState);
+            }
+            else
+            {
+                GameObject::setState(GOS_LOADED);
+                oldState = GOS_LOADED;
+            }
+            mState = targetstate;
+            stateChanged = true;
+            /*
             if (mState == GOS_LOADED)
             {
                 stateChanged = true;
@@ -126,9 +197,12 @@
                 destroyActor();
                 stateChanged = true;
             }
+            */ /*
         }
         else if (targetstate == GOS_LOADED)
         {
+                doLoose();
+                setOwner(NULL);
             if (mState == GOS_IN_POSSESSION)
             {
 				mState = GOS_LOADED;
@@ -159,22 +233,41 @@
         }
         else if (targetstate == GOS_HELD)
         {
+            if( mState == GOS_HELD ||
+                mState == GOS_IN_POSSESSION ||
+                mState == GOS_READY )
+            {
+                mState = GOS_LOADED;
+                doLoose();
+                setOwner(NULL);
+                onStateChange(oldState, mState);
+            }
+            else
+            {
+                GameObject::setState(GOS_LOADED);
+                oldState = GOS_LOADED;
+            }
+            mState = targetstate;
+            stateChanged = true;*/
+            /*
             if (mState == GOS_LOADED)
             {
-                doHold();
+                //doHold();
                 stateChanged = true;
             }
             else if (mState == GOS_IN_SCENE)
             {
                 doRemoveFromScene();
-                doHold();
+                //doHold();
                 stateChanged = true;
             }
             else if (mState == GOS_IN_POSSESSION)
             {
-                doHold();
+                //doHold();
                 stateChanged = true;
             }
+            */
+/*
         }
         else if (targetstate == GOS_READY)
         {
@@ -190,7 +283,7 @@
             GameObject::setState(targetstate);
         }
     }
-
+*/
     void Item::setProperty(const Ogre::String &key, const rl::Property &value)
     {
         if (key == Item::PROPERTY_IMAGENAME)
@@ -250,4 +343,29 @@
     {
         return mOwner;
     }
+
+    void Item::setParentSlot(Slot* slot)
+    {
+        mParentSlot = slot;
+    }
+
+    Slot* Item::getParentSlot() const
+    {
+        return mParentSlot;
+    }
+
+    void Item::doCreateActor()
+    {
+        setActor(createActor());
+    }
+
+    void Item::setParentContainer(Container* cont)
+    {
+        mParentContainer = cont;
+    }
+
+    Container* Item::getParentContainer() const
+    {
+        return mParentContainer;
+    }
 }

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -26,8 +26,8 @@
 
 namespace rl {
 
-    Slot::Slot(Creature* owner, const CeGuiString& name, int itemMask)
-        : mOwner(owner), mName(name), mItemMask(itemMask), mItem(NULL)
+    Slot::Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask)
+        : mOwner(owner), mName(name), mItemReadyMask(itemReadyMask), mItemHeldMask(itemHeldMask), mItem(NULL)
     {
     }
 
@@ -40,105 +40,146 @@
         return mItem;
     }
 
-    bool Slot::isAllowed(Item *item) const
+    bool Slot::isAllowed(const Item *item) const
     {
+        if( item == NULL )
+            return false;
         int type = item->getItemType();
-        return (type & mItemMask) == type;
+        return (type & mItemReadyMask) == type || (type & mItemHeldMask) == type;
     }
 
+    bool Slot::canReady(const Item *item) const
 
-    BoneSlot::BoneSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& bone)
-        : Slot(owner, name, itemMask), mBone(bone)
+
     {
+        if( item == NULL )
+            return false;
+        int type = item->getItemType();
+        return (type & mItemReadyMask) == type;
     }
 
+    bool Slot::standardSetItem(Item* item)
 
+    {
+        if (item)
+        {
+            if( isAllowed(item) && isEmpty())
+            {
+                if( canReady(item) )
+                    item->setState(GOS_READY);
+                else
+                    item->setState(GOS_HELD);
+                item->setOwner(mOwner);
+                item->setParentSlot(this);
+                mItem = item;
+            }
+            else
+            {
+                LOG_MESSAGE(Logger::RULES,
+                    "Item '" + item->getName() + "' konnte nicht in den Slot '" + mName
+                    + "' gelegt werden: " + (isAllowed(item) ? "'falscher Typ' " : "")
+                    + (isEmpty() ? "'Slot schon belegt" : "") + "!");
+                return false;
+            }
+        }
+        else
+        {
+            // this is the case, if the item is removed automatically
+            // don't change this without looking at Item::setState
+            if( mItem->getState() != GOS_LOADED )
+                mItem->setState(GOS_LOADED);
+            mItem = NULL;
+
+        }
+
+        return true;
+    }
+
+
+    BoneSlot::BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone)
+        : Slot(owner, name, itemReadyMask, itemHeldMask), mBone(bone)
+    {
+    }
+
     void BoneSlot::setItem(Item* item)
     {
-		if (item == NULL)
-		{
-			mItem->setState(GOS_LOADED);
-			mItem = NULL;
-			return;
-		}
+        if( !standardSetItem(item) )
+            return;
 
-        if (isAllowed(item))
+        if(item)
         {
-			if (mItem != NULL)
-			{
-				/// @todo What to do with the item which was already in the slot (or should we throw an exception if the item is not NULL)
-			}
-
-            mItem = item;
             if (mOwner->getState() == GOS_IN_SCENE)
             {
-				mItem->setState(GOS_HELD);
+                mItem->doCreateActor();
                 mOwner->getActor()->attachToSlot(mItem->getActor(), mBone);
             }
         }
     }
 
 
-    SubmeshSlot::SubmeshSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh)
-        : Slot(owner, name, itemMask), mSubmesh(submesh)
+    SubmeshSlot::SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh)
+        : Slot(owner, name, itemReadyMask, itemHeldMask), mSubmesh(submesh)
     {
     }
 
-
     void SubmeshSlot::setItem(Item* item)
     {
-		///@todo: what to do if actor is null?, think about changing the inventory of an gameobject not in scene
-		if (mOwner->getActor())
-		{
-			MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
-				mOwner->getActor()->getControlledObject());
+        Item* oldItem = mItem;
+        if( !standardSetItem(item) )
+            return;
 
-			if (mmo)
-			{
-				if (item)
-				{
-					if (isAllowed(item))
-					{
-						item->setState(GOS_IN_POSSESSION);
-						mmo->replaceSubmesh(
-							mSubmesh,
-							item->getMeshfile().c_str());
-						mItem = item;
-					}
-				}
-				else
-				{
-					MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
-					if (it != mOwner->getMeshParts().end())
-					{
-						mmo->replaceSubmesh(
-							mSubmesh,
-							(*it).second);
-					}
-					else
-					{
-						mmo->removeSubmesh(mSubmesh);
-					}
-					mItem = NULL;
-				}
-			}
 
+	    if (mOwner->getActor())
+	    {
+		    MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
+			    mOwner->getActor()->getControlledObject());
+
+		    if (mmo)
+		    {
+                if (oldItem != mItem)
+			    {
+				    MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
+				    if (it != mOwner->getMeshParts().end())
+				    {
+					    mmo->replaceSubmesh(
+						    mSubmesh,
+						    (*it).second);
+				    }
+				    else
+				    {
+					    mmo->removeSubmesh(mSubmesh);
+				    }
+			    }
+
+			    if (item)
+			    {
+                    item->doCreateActor();
+				    mmo->replaceSubmesh(
+					    mSubmesh,
+					    item->getMeshfile().c_str());
+			    }
+		    }
+
             if (mOwner->getActor()
                 && mOwner->getActor()->getPhysicalThing())
             {
                 mOwner->getActor()->getPhysicalThing()->updatePhysicsProxy();
             }
-		}
+	    }
     }
 
-    MaterialSlot::MaterialSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh)
-      : Slot(owner, name, itemMask),
+    MaterialSlot::MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh)
+      : Slot(owner, name, itemReadyMask, itemHeldMask),
         mSubmesh(submesh)
     {
     }
 
     void MaterialSlot::setItem(Item* item)
     {
+        if( !standardSetItem(item) )
+            return;
+
+
         if (item)
         {
             try

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-08-22 22:22:44 UTC (rev 3733)
@@ -610,7 +610,7 @@
     private:
         Inventory(rl::Creature* owner);
     public:
-        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type = SLOT_BONE);
+        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
         rl::Item* getItem(const rl::CeGuiString& slotName) const;
         void hold(rl::Item* item, const rl::CeGuiString& slot);
         void dropItem(const rl::CeGuiString& slotName);

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-22 22:22:44 UTC (rev 3733)
@@ -53,6 +53,8 @@
         void initInventoryWindow(Inventory* inventory);
 
 		ItemDragContainer* createItemDragContainer(Item* item, bool showdescription, const CeGuiString& containerName = "");
+        //ItemDragContainer* getItemDragContainer(Item* item, bool description);
+        CeGuiString getDragContainerNameFromItem(const Item* item, bool description);
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-22 22:17:17 UTC (rev 3732)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-22 22:22:44 UTC (rev 3733)
@@ -146,14 +146,40 @@
 		mWorldBackground->subscribeEvent(Window::EventKeyUp,
 			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
     }
+/*
+    ItemDragContainer* InventoryWindow::getItemDragContainer(Item* item, bool description)
+    {
+		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
+		ItemDragContainer* itemhandler = NULL;
 
+		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
+        if( iter != mWorldDragContainers.end() )
+        {
+            return iter->second;
+        }
+		iter = mSlotDragContainers.find(dragContainerName);
+        if( iter != mSlotDragContainers.end() )
+        {
+            return iter->second;
+        }
+
+        return NULL;
+    }
+*/
+
+    CeGuiString InventoryWindow::getDragContainerNameFromItem(const Item* item, bool description)
+    {
+		CeGuiString dragContainerName =
+			mWindow->getName() +  "/item/"
+			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer"+
+			(description?"_D":"_I");
+        return dragContainerName;
+    }
+
 	ItemDragContainer* InventoryWindow::createItemDragContainer(
 		Item* item, bool showdescription, const CeGuiString& slotName)
 	{
-		CeGuiString dragContainerName =
-			mWindow->getName() +  "/item/"
-			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer"+
-			(showdescription?"_D":"_I");
+        CeGuiString dragContainerName = getDragContainerNameFromItem(item, showdescription);
 		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator itW = mWorldDragContainers.find(dragContainerName);
@@ -208,15 +234,13 @@
 			{
 				if (dragcont->getItemParentContainer() != NULL)
 				{
-					dragcont->getItemParentContainer()->removeItem(item);
+					//dragcont->getItemParentContainer()->removeItem(item);
 					dragcont->getParent()->removeChildWindow(dragcont);
-					///@todo Swap with old content (if there is some)
 				}
 				else if (dragcont->getItemParentSlot() != "")
 				{
-					dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
+					//dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
 					dragcont->getParent()->removeChildWindow(dragcont);
-					///@todo Swap with old content (if there is some)
 				}
 
 				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
@@ -230,9 +254,11 @@
 					newCont = dragcont;
 				}
 
+                CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
 				mInventory->hold(item, targetSlot);
 
-				mSlotWindows[targetSlot]->addChildWindow(newCont);
+				slotWindow->addChildWindow(newCont);
 				newCont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
 				newCont->setItemParent(mInventory, targetSlot);
 



From melven at mail.berlios.de  Thu Aug 23 00:24:48 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 23 Aug 2007 00:24:48 +0200
Subject: [Dsa-hl-svn] r3734 - in modules: common/scripts
	regressiontest/scripts
Message-ID: <200708222224.l7MMOm5R032640@sheep.berlios.de>

Author: melven
Date: 2007-08-23 00:24:36 +0200 (Thu, 23 Aug 2007)
New Revision: 3734

Modified:
   modules/common/scripts/hero.rb
   modules/common/scripts/mckhero.rb
   modules/regressiontest/scripts/InventoryTest.rb
   modules/regressiontest/scripts/MergeableMeshTest.rb
Log:
Updated scripts to new inventory::addslot function, which now uses another ItemMask argument (to ready items)

Modified: modules/common/scripts/hero.rb
===================================================================
--- modules/common/scripts/hero.rb	2007-08-22 22:22:44 UTC (rev 3733)
+++ modules/common/scripts/hero.rb	2007-08-22 22:24:36 UTC (rev 3734)
@@ -14,12 +14,12 @@
 
 		$SCRIPT.log("Inventar konfigurieren.");
 		inv = getInventory();
-		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
-		inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
-		inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Head", "kopf", Item::ITEMTYPE_HELMET);
-		inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
+		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
+		inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
+		inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
+		inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
+		inv.addSlot("Head", "kopf", Item::ITEMTYPE_HELMET, Item::ITEMTYPE_HELMET);
+		inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS, Item::ITEMTYPE_ALL_ITEMS);
 
 		#addSounds()
         $SCRIPT.log("done.");

Modified: modules/common/scripts/mckhero.rb
===================================================================
--- modules/common/scripts/mckhero.rb	2007-08-22 22:22:44 UTC (rev 3733)
+++ modules/common/scripts/mckhero.rb	2007-08-22 22:24:36 UTC (rev 3734)
@@ -31,15 +31,15 @@
 
 	$SCRIPT.log("Inventar konfigurieren.");
 	inv = getInventory();
-	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING);
-	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
+	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
+	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Back", "back", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
 	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
-    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
+    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
 	
 
 	#addSounds()

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2007-08-22 22:22:44 UTC (rev 3733)
+++ modules/regressiontest/scripts/InventoryTest.rb	2007-08-22 22:24:36 UTC (rev 3734)
@@ -24,15 +24,15 @@
     $SCRIPT.log("InventoryTest #4: Put an object attached to the hero into container.");
     sword_held_to_inventory = $GOM.createGameObject("shortsword");
     hero.getInventory().hold(sword_held_to_inventory, "Left Hand");
-    hero.getInventory().dropItem("Left Hand")
+    #hero.getInventory().dropItem("Left Hand")
     hero.getInventory().getItem("Back").addItem(sword_held_to_inventory);
 
     $SCRIPT.log("InventoryTest #5: Put an object from a container into the hero's hand.");
     sword_inventory_to_hold = $GOM.createGameObject("shortsword");
     hero.getInventory().getItem("Back").addItem(sword_inventory_to_hold)
-    hero.getInventory().getItem("Back").removeItem(sword_inventory_to_hold)
+    #hero.getInventory().getItem("Back").removeItem(sword_inventory_to_hold)
     hero.getInventory().hold(sword_inventory_to_hold, "Right Hand");
 
     p "InventoryTest Expectation: Hero should stand with a backpack on her back and a sword attached to the right hand, there should be no sword on the floor or in the left hand";
   end
-end
\ No newline at end of file
+end

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-08-22 22:22:44 UTC (rev 3733)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-08-22 22:24:36 UTC (rev 3734)
@@ -28,18 +28,18 @@
         test_obj2.setPosition(rel_pos([2, 0, 0]))
         test_obj2.placeIntoScene();
 #        test_obj2.getActor().getControlledObject().startAnimation("Walk")
-        test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-        test_obj2.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
-        test_obj2.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
+        test_obj2.getInventory().addSlot("Head", "head", 0, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj2.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj2.getInventory().addSlot("Armor", "armor", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
         test_obj2.getInventory().hold(test_item2, "Armor")
 
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj3.setPosition(rel_pos([3, 0, 0]))
         test_obj3.placeIntoScene();
-        test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-        test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
-        test_obj3.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
+        test_obj3.getInventory().addSlot("Head", "head", 0, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj3.getInventory().addSlot("Armor", "armor", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj3.getInventory().hold(test_item3, "Armor")
         test_obj3.getActor().getControlledObject().startAnimation("Walk")
@@ -47,9 +47,9 @@
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj4.setPosition(rel_pos([4, 0, 0]))
         test_obj4.placeIntoScene();
-        test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-        test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
-        test_obj4.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
+        test_obj4.getInventory().addSlot("Head", "head", 0, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj4.getInventory().addSlot("Armor", "armor", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item4 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj4.getInventory().hold(test_item4, "Armor")
         test_obj4.getInventory().dropItem("Armor")



From josch at mail.berlios.de  Thu Aug 23 21:53:51 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Thu, 23 Aug 2007 21:53:51 +0200
Subject: [Dsa-hl-svn] r3735 - in rl/trunk/engine/core: . include src
Message-ID: <200708231953.l7NJrp9q030188@sheep.berlios.de>

Author: josch
Date: 2007-08-23 21:53:33 +0200 (Thu, 23 Aug 2007)
New Revision: 3735

Added:
   rl/trunk/engine/core/include/PolynomicSoundFadeFunctor.h
   rl/trunk/engine/core/src/PolynomicSoundFadeFunctor.cpp
Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/src/Makefile.am
Log:
Added PolynomicSoundFadeFunctor. This fade functor takes an vector of interpolation points and then calculates the polynom parameters with the Newton method.

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-08-22 22:24:36 UTC (rev 3734)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-08-23 19:53:33 UTC (rev 3735)
@@ -817,6 +817,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\PolynomicSoundFadeFunctor.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\PrimitiveObject.cpp"
 				>
 			</File>

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-08-22 22:24:36 UTC (rev 3734)
+++ rl/trunk/engine/core/include/Makefile.am	2007-08-23 19:53:33 UTC (rev 3735)
@@ -50,6 +50,7 @@
 	PhysicsMaterialRaycast.h \
 	PlayAnimationJob.h \
 	PlaySoundJob.h \
+	PolynomicSoundFadeFunctor.h \
 	PrimitiveObject.h \
 	QuadTree.h \
 	RubyInterpreter.h \

Added: rl/trunk/engine/core/include/PolynomicSoundFadeFunctor.h
===================================================================
--- rl/trunk/engine/core/include/PolynomicSoundFadeFunctor.h	2007-08-22 22:24:36 UTC (rev 3734)
+++ rl/trunk/engine/core/include/PolynomicSoundFadeFunctor.h	2007-08-23 19:53:33 UTC (rev 3735)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_POLYNOMIC_SOUND_FADE_FUNCTOR_H__
+#define __RL_POLYNOMIC_SOUND_FADE_FUNCTOR_H__
+
+#include "CorePrerequisites.h"
+#include "SoundFadeFunctor.h"
+#include <vector>
+
+
+namespace rl {
+//    class SoundObject;
+	typedef std::vector< std::pair<Ogre::Real, Ogre::Real> > InterpolationPoints;
+	typedef std::vector<Ogre::Real> Parameters;
+
+    class _RlCoreExport PolynomicSoundFadeFunctor : public SoundFadeFunctor
+    {
+    public:
+        PolynomicSoundFadeFunctor(Ogre::Real duration, InterpolationPoints *points);
+		~PolynomicSoundFadeFunctor();
+
+        virtual Ogre::Real operator()(Ogre::Real time);
+
+    private:
+        // Interpolation points
+        InterpolationPoints *mPoints;
+		Parameters *mParameters;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-08-22 22:24:36 UTC (rev 3734)
+++ rl/trunk/engine/core/src/Makefile.am	2007-08-23 19:53:33 UTC (rev 3735)
@@ -49,6 +49,7 @@
 	PhysicsMaterialRaycast.cpp \
 	PlayAnimationJob.cpp \
 	PlaySoundJob.cpp \
+	PolynomicSoundFadeFunctor.cpp \
 	PrimitiveObject.cpp \
 	RubyInterpreter.cpp \
 	SceneQuery.cpp \

Added: rl/trunk/engine/core/src/PolynomicSoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/PolynomicSoundFadeFunctor.cpp	2007-08-22 22:24:36 UTC (rev 3734)
+++ rl/trunk/engine/core/src/PolynomicSoundFadeFunctor.cpp	2007-08-23 19:53:33 UTC (rev 3735)
@@ -0,0 +1,66 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "PolynomicSoundFadeFunctor.h"
+
+
+namespace rl
+{
+    PolynomicSoundFadeFunctor::PolynomicSoundFadeFunctor(Ogre::Real duration, InterpolationPoints *points) :
+        SoundFadeFunctor(duration),
+        mPoints(points),
+		mParameters(NULL)
+    {
+		mParameters = new Parameters(points->size());
+		int n = points->size() - 1;
+		for(int i = 0; i < n; i++)
+		{
+			(*mParameters)[i] = (*mPoints)[i].second;
+		}
+		for(int k = 1; k <= n; k++)
+		{
+			for(int i = n; i >= k; i--)
+			{
+				(*mParameters)[i] = 1.0f * ((*mParameters)[i] - (*mParameters)[i - 1]) / ((*mPoints)[i].first - (*mPoints)[i - k].first);
+			}
+		}
+    }
+
+	PolynomicSoundFadeFunctor::~PolynomicSoundFadeFunctor()
+	{
+		if (mPoints != NULL)
+		{
+			delete mPoints;
+		}
+		if (mParameters != NULL)
+		{
+			delete mParameters;
+		}
+	}
+
+    Ogre::Real PolynomicSoundFadeFunctor::operator()(Ogre::Real time)
+    {
+        int n = mPoints->size() - 1;
+		Ogre::Real p = (*mPoints)[n].first;
+		for(int k = n - 1; k >= 0; k--)
+		{
+			p *= (time - (*mPoints)[k].first) + (*mParameters)[k];
+		}
+		return p;
+    }
+
+}



From melven at mail.berlios.de  Fri Aug 24 14:47:03 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 24 Aug 2007 14:47:03 +0200
Subject: [Dsa-hl-svn] r3736 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200708241247.l7OCl3Tm010702@sheep.berlios.de>

Author: melven
Date: 2007-08-24 14:46:53 +0200 (Fri, 24 Aug 2007)
New Revision: 3736

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/src/Armor.cpp
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/rules/src/Slot.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
changed item::setitem and implemented RS in creature

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-24 12:46:53 UTC (rev 3736)
@@ -125,7 +125,7 @@
             static const Ogre::String PROPERTY_AP;
             static const Ogre::String PROPERTY_INVENTORY;
 
-			typedef std::string Wert;
+            typedef CeGuiString Wert;
 
     // some targets
 			static const std::string ALL_EIGENSCHAFTEN;
@@ -141,6 +141,7 @@
             static const Wert WERT_GS;
             static const Wert WERT_SOZIALSTATUS;
             static const Wert WERT_BE;
+            static const Wert WERT_RS;
             static const Wert WERT_INI;
             static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
             static const Wert WERT_REGENERATION;

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/include/Item.h	2007-08-24 12:46:53 UTC (rev 3736)
@@ -81,15 +81,13 @@
 
         /**
          * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
-         * @warning Falls ein Actor existiert, wird dieser gel?scht. Das bedeutet, dass diese Funktion
-         * aufgerufen werden muss, bevor gegebenenfalls ein neuer Actor erstellt wird!
-         * Der Owner und der ParentSlot wird ebenfalls resettet. Au?erdem wird das Item aus dem Slot entfernt!
-         * Bei den drei States ist die zu Grunde liegende Idee, dass man (in dieser Reihenfolge) mit dieser
-         * Funktion den neuen State setzt und dann dann den neuen State einrichtet (evt doCreateActor() aufruft).
-         * Dabei muss man sich nicht mehr darum k?mmern, welchen State das Item vorher hatte.
+         * @warning Bevor einer der drei States gesetzt wird, sollte zun?chst die Funktion removeOldState
+         * aufgerufen werden, dann m?ssen Owner und ParentSlot/ParentContainer gesetzt werden und
+         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
+         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k?nnen!
          **/
         virtual void setState(GameObjectState state);
-        //void hold();
+        virtual void removeOldState();
 
         void setParentSlot(Slot* slot);
         Slot* getParentSlot() const;

Modified: rl/trunk/engine/rules/src/Armor.cpp
===================================================================
--- rl/trunk/engine/rules/src/Armor.cpp	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/src/Armor.cpp	2007-08-24 12:46:53 UTC (rev 3736)
@@ -152,23 +152,29 @@
 
     void Armor::onStateChange(GameObjectState oldState, GameObjectState newState)
     {
+        int rs = 0;
         if (oldState != newState)
         {
-            if (newState == GOS_HELD)
+            if (newState == GOS_READY)
             {
                 if (getOwner())
                 {
                     mRsEffect = EffectFactoryManager::getSingleton().createEffect(
                         "Ruestung");
+                    if(mRsEffect == NULL)
+                        return;
                     mRsEffect->setProperty(Armor::PROPERTY_G_BE, Property(mGBE));
                     mRsEffect->setProperty(Armor::PROPERTY_G_RS, Property(mGRS));
                     getOwner()->addEffect(mRsEffect);
+                    rs = static_cast<Creature*>(getOwner())->getWert(Creature::WERT_RS);
                 }
             }
-            else if (oldState == GOS_HELD)
+            else if (oldState == GOS_READY)
             {
                 if (getOwner())
                 {
+                    if(mRsEffect == NULL)
+                        return;
                     getOwner()->removeEffect(mRsEffect);
                     delete mRsEffect;
                 }

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-24 12:46:53 UTC (rev 3736)
@@ -112,8 +112,15 @@
 		{
 			mItemPositions[item] = pos;
 			mItems.insert(item);
+
+            item->removeOldState();
+            item->setParentContainer(this);
+            if(mOwner)
+                item->setOwner(mOwner);
+            else
+                item->setOwner(this);
 			item->setState(GOS_IN_POSSESSION);
-            item->setParentContainer(this);
+
 			return true;
 		}
 		else

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-24 12:46:53 UTC (rev 3736)
@@ -71,6 +71,7 @@
     const Creature::Wert Creature::WERT_GS = "GS";
     const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
     const Creature::Wert Creature::WERT_BE = "BE";
+    const Creature::Wert Creature::WERT_RS = "RS";
     const Creature::Wert Creature::WERT_INI = "INI";
     const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
     const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
@@ -105,6 +106,7 @@
 		setWert(WERT_MOD_AU, 0);
 		setWert(WERT_MOD_MR, 0);
 		setWert(WERT_GS, 8);
+        setWert(WERT_RS, 0);
         setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
 		mEigenschaften[E_MUT] = 0;
 		mEigenschaften[E_KLUGHEIT] = 0;

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-08-24 12:46:53 UTC (rev 3736)
@@ -82,12 +82,7 @@
 	{
 		mSize = pair<int,int>(widthSize,heightSize);
 	}
-/*
-	void Item::hold()
-	{
-		setState(GOS_HELD);
-	}
-*/
+
     void Item::doHold()
     {
         setActor(createActor());
@@ -103,14 +98,17 @@
         }
     }
 
+    void Item::removeOldState()
+    {
+        setState(GOS_LOADED);
+    }
+
 // --------------- Warning ------------
 // do not change this function without
 // having a look at the containers and slots
     void Item::setState(GameObjectState targetstate)
     {
-        // do reset if one of the new states
-        if (mState != GOS_HELD && mState != GOS_IN_POSSESSION && mState != GOS_READY &&
-            mState == targetstate)
+        if (mState == targetstate)
         {
             return;
         }
@@ -118,172 +116,53 @@
         GameObjectState oldState = mState;
 
 
-        if( mState == GOS_HELD ||
-            mState == GOS_IN_POSSESSION ||
-            mState == GOS_READY )
+        if( targetstate != GOS_HELD &&
+            targetstate != GOS_IN_POSSESSION &&
+            targetstate != GOS_READY )
         {
-            mState = GOS_LOADED; // <- this is important to avoid endless recursion!
-            if( getParentSlot() )
-                getParentSlot()->setItem(NULL);
-            setParentSlot(NULL);
-            if( getParentContainer() )
-                getParentContainer()->removeItem(this);
-            setParentContainer(NULL);
-            doLoose();
-            setOwner(NULL);
-        }
-        else
-        {
-            GameObject::setState(GOS_LOADED);
-            oldState = GOS_LOADED;
-        }
-
-        if( targetstate == GOS_HELD || 
-            targetstate == GOS_IN_POSSESSION || 
-            targetstate == GOS_READY )
-        {
-            mState = targetstate;
-            onStateChange(oldState, mState);
-        }
-        else
-        {
-            onStateChange(oldState, mState);
-            GameObject::setState(targetstate);
-        }
-    }
-
-/*
-    void Item::setState(GameObjectState targetstate)
-    {
-        if (mState == targetstate)
-        {
-            return;
-        }
-
-        bool stateChanged = false;
-        GameObjectState oldState = mState;
-
-        if (targetstate == GOS_IN_POSSESSION)
-        {
             if( mState == GOS_HELD ||
                 mState == GOS_IN_POSSESSION ||
                 mState == GOS_READY )
             {
-                mState = GOS_LOADED;
-                doLoose();
-                setOwner(NULL);
+                mState = GOS_LOADED; // <- this is important to avoid endless recursion!
                 onStateChange(oldState, mState);
-            }
-            else
-            {
-                GameObject::setState(GOS_LOADED);
-                oldState = GOS_LOADED;
-            }
-            mState = targetstate;
-            stateChanged = true;
-            /*
-            if (mState == GOS_LOADED)
-            {
-                stateChanged = true;
-            }
-            else if (mState == GOS_IN_SCENE)
-            {
-                doRemoveFromScene();
-                stateChanged = true;
-            }
-            else if (mState == GOS_HELD)
-            {
+
+                if( getParentSlot() )
+                    getParentSlot()->setItem(NULL);
+                setParentSlot(NULL);
+                if( getParentContainer() )
+                    getParentContainer()->removeItem(this);
+                setParentContainer(NULL);
                 doLoose();
-                destroyActor();
-                stateChanged = true;
-            }
-            */ /*
-        }
-        else if (targetstate == GOS_LOADED)
-        {
-                doLoose();
                 setOwner(NULL);
-            if (mState == GOS_IN_POSSESSION)
-            {
-				mState = GOS_LOADED;
-                stateChanged = true;
             }
-            if (mState == GOS_HELD)
-            {
-                doLoose();
-                destroyActor();
-                mState = GOS_LOADED;
-				stateChanged = true;
-            }
+
+            GameObject::setState(targetstate);
         }
-        else if (targetstate == GOS_IN_SCENE)
+        else
         {
-            if (mState == GOS_IN_POSSESSION)
-            {
-                ///@todo remove from parent container?
-                doRemoveFromScene();
-                stateChanged = true;
-			}
-            if (mState == GOS_HELD)
-            {
-                doLoose();
-				doPlaceIntoScene();
-                stateChanged = true;
-            }
-        }
-        else if (targetstate == GOS_HELD)
-        {
             if( mState == GOS_HELD ||
                 mState == GOS_IN_POSSESSION ||
                 mState == GOS_READY )
             {
-                mState = GOS_LOADED;
-                doLoose();
-                setOwner(NULL);
-                onStateChange(oldState, mState);
+                LOG_WARNING(Logger::RULES, 
+                    "Item::removeOldState() or Item::setState(GOS_LOADED) should be called  \
+                    before setting one of the States GOS_HELD, GOS_IN_POSSESSION or GOS_READY!");
             }
             else
             {
-                GameObject::setState(GOS_LOADED);
-                oldState = GOS_LOADED;
+                if( mState != GOS_LOADED )
+                {
+                    GameObject::setState(GOS_LOADED);
+                    oldState = GOS_LOADED;
+                }
+
+                mState = targetstate;
+                onStateChange(oldState, mState);
             }
-            mState = targetstate;
-            stateChanged = true;*/
-            /*
-            if (mState == GOS_LOADED)
-            {
-                //doHold();
-                stateChanged = true;
-            }
-            else if (mState == GOS_IN_SCENE)
-            {
-                doRemoveFromScene();
-                //doHold();
-                stateChanged = true;
-            }
-            else if (mState == GOS_IN_POSSESSION)
-            {
-                //doHold();
-                stateChanged = true;
-            }
-            */
-/*
         }
-        else if (targetstate == GOS_READY)
-        {
-            ///@todo
-        }
-
-        if (stateChanged)
-        {
-            onStateChange(oldState, targetstate);
-        }
-        else
-        {
-            GameObject::setState(targetstate);
-        }
     }
-*/
+
     void Item::setProperty(const Ogre::String &key, const rl::Property &value)
     {
         if (key == Item::PROPERTY_IMAGENAME)

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-08-24 12:46:53 UTC (rev 3736)
@@ -65,12 +65,14 @@
         {
             if( isAllowed(item) && isEmpty())
             {
+                item->removeOldState();
+                item->setOwner(mOwner);
+                item->setParentSlot(this);
                 if( canReady(item) )
                     item->setState(GOS_READY);
                 else
                     item->setState(GOS_HELD);
-                item->setOwner(mOwner);
-                item->setParentSlot(this);
+
                 mItem = item;
             }
             else

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-08-23 19:53:33 UTC (rev 3735)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-08-24 12:46:53 UTC (rev 3736)
@@ -432,7 +432,17 @@
         void setItemType(rl::Item::ItemType itemType);
         rl::Item::ItemType getItemType() const;
         virtual void setState(rl::GameObjectState state);
+        virtual void removeOldState();
 
+        void setParentSlot(rl::Slot* slot);
+        rl::Slot* getParentSlot() const;
+
+        void setParentContainer(rl::Container* cont);
+        rl::Container* getParentContainer() const;
+
+        void setOwner(rl::GameObject* go);
+        rl::GameObject* getOwner() const;
+
         virtual const rl::Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const rl::Property& value);
         virtual rl::PropertySet* getAllProperties() const;
@@ -476,6 +486,10 @@
     class Armor : public Item
     {
     public:
+    
+        static const Ogre::String Armor::PROPERTY_G_BE = "g_be";
+        static const Ogre::String Armor::PROPERTY_G_RS = "g_rs";
+        
         Armor(unsigned int id);
         virtual ~Armor();
 
@@ -620,7 +634,7 @@
     class Creature : public GameObject {
     public:
     
-    typedef std::string Wert;
+    typedef CeGuiString Wert;
         enum Alignment
         {
             ALIGNMENT_ALLY,    ///< Creature fights with the player.
@@ -642,6 +656,7 @@
         static const Creature::Wert Creature::WERT_GS = "GS";
         static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
         static const Creature::Wert Creature::WERT_BE = "BE";
+        static const Creature::Wert Creature::WERT_RS = "RS";
         static const Creature::Wert Creature::WERT_INI = "INI";
         static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
         static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";



From melven at mail.berlios.de  Fri Aug 24 14:48:02 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 24 Aug 2007 14:48:02 +0200
Subject: [Dsa-hl-svn] r3737 - in modules/common/scripts: . effects
Message-ID: <200708241248.l7OCm28w010751@sheep.berlios.de>

Author: melven
Date: 2007-08-24 14:47:56 +0200 (Fri, 24 Aug 2007)
New Revision: 3737

Added:
   modules/common/scripts/effects/ruestung.rb
Modified:
   modules/common/scripts/initialize_factories.rb
Log:
added effect ruestung

Added: modules/common/scripts/effects/ruestung.rb
===================================================================
--- modules/common/scripts/effects/ruestung.rb	2007-08-24 12:46:53 UTC (rev 3736)
+++ modules/common/scripts/effects/ruestung.rb	2007-08-24 12:47:56 UTC (rev 3737)
@@ -0,0 +1,34 @@
+class Ruestung < Effect
+  def initialize(stufe)
+    super(stufe);
+    setName("Ruestung");
+    setDescription("Ruestungsschutz verringert den erlittenen Schaden.");
+  end
+
+  def setProperty(name, value)
+    if( name == Armor::PROPERTY_G_BE )
+      @_prop_g_be = value;
+    elsif( name == Armor::PROPERTY_G_RS )
+      @_prop_g_rs = value;
+    else
+      super(name, value)
+    end
+  end
+  
+  def getMod(target, type, tag)
+    if ((target == Creature::WERT_BE) &&
+        (type == MODTYPE_SUM))
+      print @_prop_g_be;
+      @_prop_g_be
+    elsif ((target == Creature::WERT_RS) &&
+        (type == MODTYPE_SUM))
+      print @_prop_g_be;
+      @_prop_g_rs
+    end
+    return 0;
+  end
+
+  def check()
+	  return PERMANENT;
+  end
+end

Modified: modules/common/scripts/initialize_factories.rb
===================================================================
--- modules/common/scripts/initialize_factories.rb	2007-08-24 12:46:53 UTC (rev 3736)
+++ modules/common/scripts/initialize_factories.rb	2007-08-24 12:47:56 UTC (rev 3737)
@@ -1,3 +1,4 @@
+load "effects/ruestung.rb"
 class RubyClassFactory < UnifiedFactory
   def initialize()
     super();
@@ -16,7 +17,7 @@
   end
 
   def createEffect(classname, stufe)
-    return Module.const_get(classname).new(id);
+    return Module.const_get(classname).new(stufe);
   end
 end
 



From melven at mail.berlios.de  Fri Aug 24 14:50:01 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 24 Aug 2007 14:50:01 +0200
Subject: [Dsa-hl-svn] r3738 - rl/trunk/engine/rules/src
Message-ID: <200708241250.l7OCo18Y010823@sheep.berlios.de>

Author: melven
Date: 2007-08-24 14:49:53 +0200 (Fri, 24 Aug 2007)
New Revision: 3738

Modified:
   rl/trunk/engine/rules/src/Armor.cpp
Log:
forgot to remove code for debugging

Modified: rl/trunk/engine/rules/src/Armor.cpp
===================================================================
--- rl/trunk/engine/rules/src/Armor.cpp	2007-08-24 12:47:56 UTC (rev 3737)
+++ rl/trunk/engine/rules/src/Armor.cpp	2007-08-24 12:49:53 UTC (rev 3738)
@@ -152,7 +152,6 @@
 
     void Armor::onStateChange(GameObjectState oldState, GameObjectState newState)
     {
-        int rs = 0;
         if (oldState != newState)
         {
             if (newState == GOS_READY)
@@ -166,7 +165,6 @@
                     mRsEffect->setProperty(Armor::PROPERTY_G_BE, Property(mGBE));
                     mRsEffect->setProperty(Armor::PROPERTY_G_RS, Property(mGRS));
                     getOwner()->addEffect(mRsEffect);
-                    rs = static_cast<Creature*>(getOwner())->getWert(Creature::WERT_RS);
                 }
             }
             else if (oldState == GOS_READY)



From pnyx at mail.berlios.de  Fri Aug 24 15:28:09 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Fri, 24 Aug 2007 15:28:09 +0200
Subject: [Dsa-hl-svn] r3739 - in modules: common/dsa common/gui/windows
	common/materials common/materials/model
	common/materials/programs/Normalmapping common/models
	common/scripts regressiontest/dsa regressiontest/materials
	regressiontest/scripts
Message-ID: <200708241328.l7ODS91W014259@sheep.berlios.de>

Author: pnyx
Date: 2007-08-24 15:25:42 +0200 (Fri, 24 Aug 2007)
New Revision: 3739

Added:
   modules/common/dsa/Clothing.gof
   modules/common/materials/men_human_female_legs_underpants.mesh.material
   modules/common/materials/model/men_human_female_legs_underpants_diffuse.png
   modules/common/materials/model/men_human_female_legs_underpants_normal.png
   modules/common/models/men_human_female_feet_nude.mesh
   modules/common/models/men_human_female_legs_underpants.mesh
Modified:
   modules/common/gui/windows/inventory_human.xml
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/materials/model/men_human_female_head_02_diffuse.png
   modules/common/materials/model/men_human_female_normalmap.png
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
   modules/common/models/men_human_female_feet_boots_01.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_torso.mesh
   modules/common/scripts/mckhero.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/materials/obj_Shortsleeve.material
   modules/regressiontest/materials/obj_Shortsleeve_2.material
   modules/regressiontest/scripts/InventoryTest.rb
Log:
* using items to dress characters up now. (You can find the clothing in the backpack now)
* added new slots to inventory (still using ITEMTYPE_ARMOR)
* Renamed Slot Cloak to Clothes for now
- no Default Torso Clothing yet

Added: modules/common/dsa/Clothing.gof
===================================================================
--- modules/common/dsa/Clothing.gof	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/dsa/Clothing.gof	2007-08-24 13:25:42 UTC (rev 3739)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+	<!--InventoryTest clothes-->
+    <gameobjectclass classid="men_human_female_leg_pants_01_long" baseclass="Armor">
+        <property name="name" type="STRING" data="Lederhose"/>
+        <property name="description" type="STRING" data="Eine lange Hose aus geschmeidigem Leder"/>
+        <property name="meshfile" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,3"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="itemtype" type="INT" data="32"/>
+    </gameobjectclass>
+    
+    <gameobjectclass classid="men_human_female_cloth_short" baseclass="Armor">
+        <property name="name" type="STRING" data="Ledergewand"/>
+        <property name="description" type="STRING" data="Blah, Ledergewand, dingsbums"/>
+        <property name="meshfile" type="STRING" data="men_human_female_cloth_short.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,3"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="itemtype" type="INT" data="32"/>
+    </gameobjectclass>
+    
+    <gameobjectclass classid="men_human_female_feet_boots_01" baseclass="Armor">
+        <property name="name" type="STRING" data="Lederstiefel"/>
+        <property name="description" type="STRING" data="Hohe Stiefel aus weichem Leder"/>
+        <property name="meshfile" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,2"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="itemtype" type="INT" data="32"/>
+    </gameobjectclass>
+	
+</GameObjectDefinitions>

Modified: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/gui/windows/inventory_human.xml	2007-08-24 13:25:42 UTC (rev 3739)
@@ -94,7 +94,7 @@
 					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
 				</Window>
 				
-				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Clothes">
 					<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
 					<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
 				</Window>

Modified: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-08-24 13:25:42 UTC (rev 3739)
@@ -1,5 +1,5 @@
 
-material men_human_female_feet_boots_01 : Basic_Normalmapping_UV1_mirrored
+material men_human_female_feet_boots_01 : Basic_Normalmapping_mirrored
 {
 set_texture_alias DiffuseMap obj_boots01.png
 set_texture_alias NormalMap obj_boots_01_normal.png

Added: modules/common/materials/men_human_female_legs_underpants.mesh.material
===================================================================
--- modules/common/materials/men_human_female_legs_underpants.mesh.material	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/materials/men_human_female_legs_underpants.mesh.material	2007-08-24 13:25:42 UTC (rev 3739)
@@ -0,0 +1,6 @@
+
+material men_human_female_legs_underpants : Basic_Normalmapping
+{
+set_texture_alias DiffuseMap men_human_female_legs_underpants_diffuse.png
+set_texture_alias NormalMap  men_human_female_legs_underpants_normal.png
+}

Modified: modules/common/materials/model/men_human_female_head_02_diffuse.png
===================================================================
(Binary files differ)

Added: modules/common/materials/model/men_human_female_legs_underpants_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_legs_underpants_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_legs_underpants_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_legs_underpants_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/materials/model/men_human_female_normalmap.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
@@ -152,7 +152,7 @@
 }
 
 
-material Basic_Normalmapping_UV1_mirrored
+material Basic_Normalmapping_mirrored
 {
 	lod_distances 12 100
 	
@@ -161,7 +161,7 @@
 	    lod_index 0
         pass
         {
-            vertex_program_ref Basic_Normalmapping_UV1_VS_HLSL
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
             {
                 param_named_auto matViewProjection worldviewproj_matrix
                 param_named_auto LightPosition_0 light_position_object_space 0
@@ -210,7 +210,7 @@
 		{
 			alpha_rejection greater 128
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_ShaderUV1
+			fragment_program_ref Basic_Pixel_Shader
 			{
 			}
 			//DirectX 9.0 HLSL Vertex Shader vs_2_0

Modified: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-24 13:25:42 UTC (rev 3739)
@@ -86,17 +86,17 @@
 				param_named_auto Light1_attenuation light_attenuation 0
 				param_named_auto Light1_color light_diffuse_colour 0
 				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
+				param_named Light1_spec_power float 0.5
 				
 				param_named_auto Light2_attenuation light_attenuation 1
 				param_named_auto Light2_color light_diffuse_colour 1
 				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
+				param_named Light2_spec_power float 0.5
 				
 				param_named_auto Light3_attenuation light_attenuation 2
 				param_named_auto Light3_color light_diffuse_colour 2
 				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
+				param_named Light3_spec_power float 0.5
 				
 				
 				param_named_auto matViewProjection worldviewproj_matrix
@@ -208,17 +208,17 @@
 				param_named_auto Light1_attenuation light_attenuation 0
 				param_named_auto Light1_color light_diffuse_colour 0
 				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
+				param_named Light1_spec_power float 0.5
 				
 				param_named_auto Light2_attenuation light_attenuation 1
 				param_named_auto Light2_color light_diffuse_colour 1
 				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
+				param_named Light2_spec_power float 0.5
 				
 				param_named_auto Light3_attenuation light_attenuation 2
 				param_named_auto Light3_color light_diffuse_colour 2
 				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
+				param_named Light3_spec_power float 0.5
 				
 				
 				param_named_auto matViewProjection worldviewproj_matrix
@@ -334,17 +334,17 @@
 				param_named_auto Light1_attenuation light_attenuation 0
 				param_named_auto Light1_color light_diffuse_colour 0
 				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
+				param_named Light1_spec_power float 0.5
 				
 				param_named_auto Light2_attenuation light_attenuation 1
 				param_named_auto Light2_color light_diffuse_colour 1
 				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
+				param_named Light2_spec_power float 0.5
 				
 				param_named_auto Light3_attenuation light_attenuation 2
 				param_named_auto Light3_color light_diffuse_colour 2
 				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
+				param_named Light3_spec_power float 0.5
 				
 				
 				param_named_auto matViewProjection worldviewproj_matrix

Modified: modules/common/models/men_human_female_feet_boots_01.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_feet_nude.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_feet_nude.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_legs_underpants.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_legs_underpants.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)

Modified: modules/common/scripts/mckhero.rb
===================================================================
--- modules/common/scripts/mckhero.rb	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/common/scripts/mckhero.rb	2007-08-24 13:25:42 UTC (rev 3739)
@@ -40,7 +40,9 @@
 	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
     inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
 	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
-	
+	inv.addSlot("Clothes", "clothes", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Boots", "boots", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Trousers", "trousers", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
 
 	#addSounds()
         $SCRIPT.log("done.");

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-24 13:25:42 UTC (rev 3739)
@@ -12,8 +12,8 @@
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
             <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
             <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
-            <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
-            <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
+            <property name="trousers" type="STRING" data="men_human_female_legs_underpants.mesh"/>
+            <property name="boots" type="STRING" data="men_human_female_feet_nude.mesh"/>
         </property>
     </gameobjectclass>
 

Modified: modules/regressiontest/materials/obj_Shortsleeve.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve.material	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/regressiontest/materials/obj_Shortsleeve.material	2007-08-24 13:25:42 UTC (rev 3739)
@@ -1,6 +1,6 @@
 
 material obj_Shortsleeve : Torso_Vertex_Shader_Short
 {
-	set_texture_alias skin rl_mensch_female.png
+	set_texture_alias skin men_female_human_diffuse.png
 	set_texture_alias cloth obj_shortsleeve02_diffuse.png
 }

Modified: modules/regressiontest/materials/obj_Shortsleeve_2.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-08-24 13:25:42 UTC (rev 3739)
@@ -1,6 +1,6 @@
 
 material obj_Shortsleeve_2 : Torso_Vertex_Shader_Short
 {
-	set_texture_alias skin rl_mensch_female.png
+	set_texture_alias skin men_female_human_diffuse.png
 	set_texture_alias cloth obj_shortsleeve_dummy.png
 }

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2007-08-24 12:49:53 UTC (rev 3738)
+++ modules/regressiontest/scripts/InventoryTest.rb	2007-08-24 13:25:42 UTC (rev 3739)
@@ -12,6 +12,13 @@
     p "InventoryTest #1: Put an object a creature's slot."
     hero.getInventory().hold(backpack, "Back");
     
+    itemToAdd = $GOM.createGameObject("men_human_female_leg_pants_01_long");
+    hero.getInventory().getItem("Back").addItem(itemToAdd);
+    itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
+    hero.getInventory().getItem("Back").addItem(itemToAdd);
+    itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
+    hero.getInventory().getItem("Back").addItem(itemToAdd);
+    
     $SCRIPT.log("InventoryTest #2: Put a loaded object into container.");
     sword_loaded_to_inventory = $GOM.createGameObject("shortsword");
     hero.getInventory().getItem("Back").addItem(sword_loaded_to_inventory);
@@ -32,6 +39,7 @@
     hero.getInventory().getItem("Back").addItem(sword_inventory_to_hold)
     #hero.getInventory().getItem("Back").removeItem(sword_inventory_to_hold)
     hero.getInventory().hold(sword_inventory_to_hold, "Right Hand");
+    
 
     p "InventoryTest Expectation: Hero should stand with a backpack on her back and a sword attached to the right hand, there should be no sword on the floor or in the left hand";
   end



From pnyx at mail.berlios.de  Sat Aug 25 10:45:55 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 25 Aug 2007 10:45:55 +0200
Subject: [Dsa-hl-svn] r3740 - modules/common/materials/programs/Normalmapping
Message-ID: <200708250845.l7P8jtTM024350@sheep.berlios.de>

Author: pnyx
Date: 2007-08-25 10:45:46 +0200 (Sat, 25 Aug 2007)
New Revision: 3740

Added:
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping.material
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.material
   modules/common/materials/programs/Normalmapping/Normalmapping.program
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping.material
Removed:
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
   modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
   modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
Log:
moved all program definitions of normalmapping shaders into one .program file

Copied: modules/common/materials/programs/Normalmapping/Basic_Normalmapping.material (from rev 3739, modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program)
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping.material	2007-08-25 08:45:46 UTC (rev 3740)
@@ -0,0 +1,233 @@
+material Basic_Normalmapping
+{
+	lod_distances 12 100
+	
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecColor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+        }
+    }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
+    technique fixed_function
+    {
+	    lod_index 2
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Basic_Normalmapping_mirrored
+{
+	lod_distances 12 100
+	
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecColor float4 0.2 0.2 0.2 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+        }
+    }
+    
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
+    technique fixed_function
+    {
+	    lod_index 2
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Deleted: modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping.program	2007-08-25 08:45:46 UTC (rev 3740)
@@ -1,270 +0,0 @@
-vertex_program Basic_Normalmapping_UV0_VS_HLSL hlsl
-{
-    source Basic_Normalmapping_UV0_VS.hlsl
-    entry_point vs_main
-    target vs_1_1
-}
-
-vertex_program Basic_Normalmapping_UV1_VS_HLSL hlsl
-{
-    source Basic_Normalmapping_UV1_VS.hlsl
-    entry_point vs_main
-    target vs_1_1
-}
-
-vertex_program Basic_Normalmapping_UV2_VS_HLSL hlsl
-{
-    source Basic_Normalmapping_UV2_VS.hlsl
-    entry_point vs_main
-    target vs_1_1
-}
-
-fragment_program Basic_Normalmapping_PS_HLSL hlsl
-{
-    source Basic_Normalmapping_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-
-fragment_program Basic_Normalmapping_mirrored_PS_HLSL hlsl
-{
-    source Basic_Normalmapping_mirrored_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-
-material Basic_Normalmapping
-{
-	lod_distances 12 100
-	
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named groundcolor float4 0.1 0.1 0.1 1.0
-                param_named skycolor float4 0.5 0.5 0.5 1.0
-                param_named SpecColor float4 0.2 0.2 0.2 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-        }
-    }
-    
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-    
-
-    technique fixed_function
-    {
-	    lod_index 2
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
-
-material Basic_Normalmapping_mirrored
-{
-	lod_distances 12 100
-	
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_mirrored_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named groundcolor float4 0.1 0.1 0.1 1.0
-                param_named skycolor float4 0.5 0.5 0.5 1.0
-                param_named SpecColor float4 0.2 0.2 0.2 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-        }
-    }
-    
-    
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-    
-
-    technique fixed_function
-    {
-	    lod_index 2
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
\ No newline at end of file

Copied: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.material (from rev 3739, modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program)
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.material	2007-08-25 08:45:46 UTC (rev 3740)
@@ -0,0 +1,367 @@
+material Basic_Normalmapping_Spec
+{
+	lod_distances 12 100
+	
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
+    technique fixed_function
+    {
+	    lod_index 1
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Basic_Normalmapping_Spec_mirrored
+{
+	lod_distances 12 100
+	
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+
+       
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
+    technique fixed_function
+    {
+	    lod_index 1
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+ //scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+   //   		depth_write off
+
+material Basic_Normalmapping_Spec_Alpha
+{
+	lod_distances 12 100
+	
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+	        scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named groundcolor float4 0.1 0.1 0.1 1.0
+                param_named skycolor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+        }
+    }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+
+    technique fixed_function
+    {
+	    lod_index 1
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Deleted: modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Basic_Normalmapping_Spec.program	2007-08-25 08:45:46 UTC (rev 3740)
@@ -1,382 +0,0 @@
-fragment_program Basic_Normalmapping_Spec_PS_HLSL hlsl
-{
-    source Basic_Normalmapping_Spec_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-fragment_program Basic_Normalmapping_Spec_mirrored_PS_HLSL hlsl
-{
-    source Basic_Normalmapping_Spec_mirrored_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-
-material Basic_Normalmapping_Spec
-{
-	lod_distances 12 100
-	
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-	        alpha_rejection greater 128
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named groundcolor float4 0.1 0.1 0.1 1.0
-                param_named skycolor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-        }
-    }
-    
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.5
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.5
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.5
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-
-    technique fixed_function
-    {
-	    lod_index 1
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
-
-material Basic_Normalmapping_Spec_mirrored
-{
-	lod_distances 12 100
-	
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-	        alpha_rejection greater 128
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_Spec_mirrored_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named groundcolor float4 0.1 0.1 0.1 1.0
-                param_named skycolor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-        }
-    }
-
-       
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.5
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.5
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.5
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-
-    technique fixed_function
-    {
-	    lod_index 1
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
- //scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-   //   		depth_write off
-
-material Basic_Normalmapping_Spec_Alpha
-{
-	lod_distances 12 100
-	
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-	        scene_blend alpha_blend 
-      		// Tiefenpuffer aus
-      		depth_write off
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Basic_Normalmapping_Spec_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named groundcolor float4 0.1 0.1 0.1 1.0
-                param_named skycolor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-        }
-    }
-    
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Basic_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.5
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.5
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.5
-				
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-
-    technique fixed_function
-    {
-	    lod_index 1
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
\ No newline at end of file

Added: modules/common/materials/programs/Normalmapping/Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Normalmapping.program	2007-08-25 08:45:46 UTC (rev 3740)
@@ -0,0 +1,77 @@
+vertex_program Basic_Normalmapping_UV0_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV0_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+vertex_program Basic_Normalmapping_UV1_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV1_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+vertex_program Basic_Normalmapping_UV2_VS_HLSL hlsl
+{
+    source Basic_Normalmapping_UV2_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
+
+fragment_program Basic_Normalmapping_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+
+fragment_program Basic_Normalmapping_mirrored_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Basic_Normalmapping_Spec_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_Spec_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Basic_Normalmapping_Spec_mirrored_PS_HLSL hlsl
+{
+    source Basic_Normalmapping_Spec_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Skin_Normalmapping_PS_HLSL hlsl
+{
+    source Skin_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Skin_Normalmapping_mirrored_PS_HLSL hlsl
+{
+    source Skin_Normalmapping_mirrored_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+fragment_program Eye_Normalmapping_PS_HLSL hlsl
+{
+    source Eye_Normalmapping_PS.hlsl
+    entry_point ps_main
+    target ps_2_0
+}
+
+vertex_program Eye_Normalmapping_VS_HLSL hlsl
+{
+    source Eye_Normalmapping_VS.hlsl
+    entry_point vs_main
+    target vs_1_1
+}
\ No newline at end of file

Copied: modules/common/materials/programs/Normalmapping/Skin_Normalmapping.material (from rev 3739, modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program)
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping.material	2007-08-25 08:45:46 UTC (rev 3740)
@@ -0,0 +1,465 @@
+material Skin_Normalmapping
+{
+	lod_distances 12 100
+	
+	
+    technique hlsl
+    {
+	    lod_index 0
+	
+	    
+        pass
+        {
+	        depth_bias -18
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+    
+    
+    technique hlsl2
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			depth_bias -1
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+    
+    
+    
+    
+	
+    technique fixed_function
+    {
+	    lod_index 2
+	    
+        pass
+        {
+	        depth_bias -1
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+
+
+material Face_Normalmapping_mirrored
+{
+	lod_distances 10 100
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+            vertex_program_ref Eye_Normalmapping_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named eyeDirection float3 0.0 1 0.0
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Eye_Normalmapping_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SpecColor float4 1.0 1.0 1.0 1.0
+                param_named SpecExp float 64.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias EyeDiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias EyeNormalMap
+            }
+            
+            texture_unit ShadowMap
+            {
+                texture_alias EyeShadowMap
+                texture men_eyeshadow.png
+            }
+        }
+        
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+    
+    technique hlsl1
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Face_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Face_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				param_named eyeDirection float3 0.0 0 0.0
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+			texture_unit DiffuseMap
+            {
+                texture_alias EyeDiffuseMap
+            }            
+            texture_unit ShadowMap
+            {
+                texture_alias EyeShadowMap
+                texture men_eyeshadow.png
+            }
+		}
+	}
+    
+
+    technique fixed_function
+    {
+	    lod_index 2
+        pass
+        {
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
+
+
+material Skin_Normalmapping_mirrored
+{
+	lod_distances 12 100
+    technique hlsl
+    {
+	    lod_index 0
+        pass
+        {
+	        alpha_rejection greater 128
+            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
+            {
+                param_named_auto matViewProjection worldviewproj_matrix
+                param_named_auto LightPosition_0 light_position_object_space 0
+                param_named_auto LightPosition_1 light_position_object_space 1
+                param_named_auto LightPosition_2 light_position_object_space 2
+                
+                param_named_auto LightAttn_0 light_attenuation 0
+                param_named_auto LightAttn_1 light_attenuation 1
+                param_named_auto LightAttn_2 light_attenuation 2
+                
+                param_named_auto vViewPosition	 camera_position_object_space
+            }
+
+            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
+            {
+                param_named_auto LightColor_0  light_diffuse_colour  0
+                param_named_auto LightColor_1  light_diffuse_colour  1
+                param_named_auto LightColor_2  light_diffuse_colour  2
+                
+                param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+                param_named SkinColor float4 0.5 0.5 0.5 1.0
+                param_named SpecExp float 16.0
+            }
+			
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+
+            // Normal map
+            texture_unit NormalMap
+            {
+                texture_alias NormalMap
+            }
+            
+            texture_unit SpecMap
+            {
+                texture_alias SpecMap
+            }
+            
+            texture_unit LookupSkin
+            {
+                texture_alias LookupSkin
+                texture lookup_skin.png 1d
+                tex_address_mode clamp
+            }
+        }
+    }
+
+    technique hlsl2
+	{
+		lod_index 1
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			depth_bias -1
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Skin_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.5
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.5
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.5
+				
+				param_named subsurfcolor float4 0.8 0 0 1
+				param_named skincolor float4 0.5 0.5 0.5 1
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				param_named skycolor float4 0.6 0.6 0.6 1.0
+				param_named groundcolor float4 0.2 0.2 0.2 1.0
+			}
+			
+			texture_unit
+			{
+				texture_alias DiffuseMap
+
+			}
+		}
+	}
+    
+
+    technique fixed_function
+    {
+	    lod_index 2
+	    
+        pass
+        {
+	        depth_bias -1
+            ambient 0.6 0.6 0.6 1.0
+            diffuse 0.7 0.7 0.7 1.0
+            specular 0.3 0.3 0.3 1.0 16.0
+
+            // Base diffuse texture map
+            texture_unit DiffuseMap
+            {
+                texture_alias DiffuseMap
+            }
+        } 
+    }
+}
\ No newline at end of file

Deleted: modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program
===================================================================
--- modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-24 13:25:42 UTC (rev 3739)
+++ modules/common/materials/programs/Normalmapping/Skin_Normalmapping.program	2007-08-25 08:45:46 UTC (rev 3740)
@@ -1,493 +0,0 @@
-fragment_program Skin_Normalmapping_PS_HLSL hlsl
-{
-    source Skin_Normalmapping_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-fragment_program Skin_Normalmapping_mirrored_PS_HLSL hlsl
-{
-    source Skin_Normalmapping_mirrored_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-fragment_program Eye_Normalmapping_PS_HLSL hlsl
-{
-    source Eye_Normalmapping_PS.hlsl
-    entry_point ps_main
-    target ps_2_0
-}
-
-vertex_program Eye_Normalmapping_VS_HLSL hlsl
-{
-    source Eye_Normalmapping_VS.hlsl
-    entry_point vs_main
-    target vs_1_1
-}
-
-material Skin_Normalmapping
-{
-	lod_distances 12 100
-	
-	
-    technique hlsl
-    {
-	    lod_index 0
-	
-	    
-        pass
-        {
-	        depth_bias -18
-	        alpha_rejection greater 128
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Skin_Normalmapping_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SkinColor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-            
-            texture_unit LookupSkin
-            {
-                texture_alias LookupSkin
-                texture lookup_skin.png 1d
-                tex_address_mode clamp
-            }
-        }
-    }
-    
-    
-    technique hlsl2
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			depth_bias -1
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Skin_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.5
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.5
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.5
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-    
-    
-    
-    
-    
-	
-    technique fixed_function
-    {
-	    lod_index 2
-	    
-        pass
-        {
-	        depth_bias -1
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
-
-
-
-material Face_Normalmapping_mirrored
-{
-	lod_distances 10 100
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-            vertex_program_ref Eye_Normalmapping_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named eyeDirection float3 0.0 1 0.0
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Eye_Normalmapping_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SpecColor float4 1.0 1.0 1.0 1.0
-                param_named SpecExp float 64.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias EyeDiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias EyeNormalMap
-            }
-            
-            texture_unit ShadowMap
-            {
-                texture_alias EyeShadowMap
-                texture men_eyeshadow.png
-            }
-        }
-        
-        pass
-        {
-	        alpha_rejection greater 128
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SkinColor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-            
-            texture_unit LookupSkin
-            {
-                texture_alias LookupSkin
-                texture lookup_skin.png 1d
-                tex_address_mode clamp
-            }
-        }
-    }
-    
-    technique hlsl1
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Face_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Face_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.3
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.3
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				param_named eyeDirection float3 0.0 0 0.0
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-			texture_unit DiffuseMap
-            {
-                texture_alias EyeDiffuseMap
-            }            
-            texture_unit ShadowMap
-            {
-                texture_alias EyeShadowMap
-                texture men_eyeshadow.png
-            }
-		}
-	}
-    
-
-    technique fixed_function
-    {
-	    lod_index 2
-        pass
-        {
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
-
-
-material Skin_Normalmapping_mirrored
-{
-	lod_distances 12 100
-    technique hlsl
-    {
-	    lod_index 0
-        pass
-        {
-	        alpha_rejection greater 128
-            vertex_program_ref Basic_Normalmapping_UV0_VS_HLSL
-            {
-                param_named_auto matViewProjection worldviewproj_matrix
-                param_named_auto LightPosition_0 light_position_object_space 0
-                param_named_auto LightPosition_1 light_position_object_space 1
-                param_named_auto LightPosition_2 light_position_object_space 2
-                
-                param_named_auto LightAttn_0 light_attenuation 0
-                param_named_auto LightAttn_1 light_attenuation 1
-                param_named_auto LightAttn_2 light_attenuation 2
-                
-                param_named_auto vViewPosition	 camera_position_object_space
-            }
-
-            fragment_program_ref Skin_Normalmapping_mirrored_PS_HLSL
-            {
-                param_named_auto LightColor_0  light_diffuse_colour  0
-                param_named_auto LightColor_1  light_diffuse_colour  1
-                param_named_auto LightColor_2  light_diffuse_colour  2
-                
-                param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-                param_named SkinColor float4 0.5 0.5 0.5 1.0
-                param_named SpecExp float 16.0
-            }
-			
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-
-            // Normal map
-            texture_unit NormalMap
-            {
-                texture_alias NormalMap
-            }
-            
-            texture_unit SpecMap
-            {
-                texture_alias SpecMap
-            }
-            
-            texture_unit LookupSkin
-            {
-                texture_alias LookupSkin
-                texture lookup_skin.png 1d
-                tex_address_mode clamp
-            }
-        }
-    }
-
-    technique hlsl2
-	{
-		lod_index 1
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			depth_bias -1
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Basic_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Skin_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.5
-				
-				param_named_auto Light2_attenuation light_attenuation 1
-				param_named_auto Light2_color light_diffuse_colour 1
-				param_named_auto Light2_position light_position_object_space 1
-				param_named Light2_spec_power float 0.5
-				
-				param_named_auto Light3_attenuation light_attenuation 2
-				param_named_auto Light3_color light_diffuse_colour 2
-				param_named_auto Light3_position light_position_object_space 2
-				param_named Light3_spec_power float 0.5
-				
-				param_named subsurfcolor float4 0.8 0 0 1
-				param_named skincolor float4 0.5 0.5 0.5 1
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				param_named skycolor float4 0.6 0.6 0.6 1.0
-				param_named groundcolor float4 0.2 0.2 0.2 1.0
-			}
-			
-			texture_unit
-			{
-				texture_alias DiffuseMap
-
-			}
-		}
-	}
-    
-
-    technique fixed_function
-    {
-	    lod_index 2
-	    
-        pass
-        {
-	        depth_bias -1
-            ambient 0.6 0.6 0.6 1.0
-            diffuse 0.7 0.7 0.7 1.0
-            specular 0.3 0.3 0.3 1.0 16.0
-
-            // Base diffuse texture map
-            texture_unit DiffuseMap
-            {
-                texture_alias DiffuseMap
-            }
-        } 
-    }
-}
\ No newline at end of file



From melven at mail.berlios.de  Sat Aug 25 10:47:14 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 10:47:14 +0200
Subject: [Dsa-hl-svn] r3741 - in rl/trunk/engine: rules/include script/swig
Message-ID: <200708250847.l7P8lEO1024378@sheep.berlios.de>

Author: melven
Date: 2007-08-25 10:47:07 +0200 (Sat, 25 Aug 2007)
New Revision: 3741

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/script/swig/RlRules.swig
Log:
rs works, problem with cegui::string, Ogre::String made no problems in swig

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-25 08:45:46 UTC (rev 3740)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-25 08:47:07 UTC (rev 3741)
@@ -125,7 +125,7 @@
             static const Ogre::String PROPERTY_AP;
             static const Ogre::String PROPERTY_INVENTORY;
 
-            typedef CeGuiString Wert;
+            typedef Ogre::String Wert;
 
     // some targets
 			static const std::string ALL_EIGENSCHAFTEN;

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-08-25 08:45:46 UTC (rev 3740)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-08-25 08:47:07 UTC (rev 3741)
@@ -634,7 +634,7 @@
     class Creature : public GameObject {
     public:
     
-    typedef CeGuiString Wert;
+    typedef Ogre::String Wert;
         enum Alignment
         {
             ALIGNMENT_ALLY,    ///< Creature fights with the player.



From melven at mail.berlios.de  Sat Aug 25 10:47:48 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 10:47:48 +0200
Subject: [Dsa-hl-svn] r3742 - modules/common/scripts/effects
Message-ID: <200708250847.l7P8lmLW024397@sheep.berlios.de>

Author: melven
Date: 2007-08-25 10:47:42 +0200 (Sat, 25 Aug 2007)
New Revision: 3742

Modified:
   modules/common/scripts/effects/ruestung.rb
Log:
fixed bug

Modified: modules/common/scripts/effects/ruestung.rb
===================================================================
--- modules/common/scripts/effects/ruestung.rb	2007-08-25 08:47:07 UTC (rev 3741)
+++ modules/common/scripts/effects/ruestung.rb	2007-08-25 08:47:42 UTC (rev 3742)
@@ -18,14 +18,13 @@
   def getMod(target, type, tag)
     if ((target == Creature::WERT_BE) &&
         (type == MODTYPE_SUM))
-      print @_prop_g_be;
       @_prop_g_be
     elsif ((target == Creature::WERT_RS) &&
         (type == MODTYPE_SUM))
-      print @_prop_g_be;
-      @_prop_g_rs
+      @_prop_g_rs;
+    else
+      0
     end
-    return 0;
   end
 
   def check()



From melven at mail.berlios.de  Sat Aug 25 12:58:18 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 12:58:18 +0200
Subject: [Dsa-hl-svn] r3743 - rl/trunk/engine/ui/src
Message-ID: <200708251058.l7PAwI9p002467@sheep.berlios.de>

Author: melven
Date: 2007-08-25 12:58:07 +0200 (Sat, 25 Aug 2007)
New Revision: 3743

Modified:
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
Log:
some bug fixes

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-25 08:47:42 UTC (rev 3742)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-25 10:58:07 UTC (rev 3743)
@@ -90,40 +90,19 @@
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
-			if (dragcont->getItemParentContainer() != NULL)
-			{
-				dragcont->getItemParentContainer()->removeItem(item);
-				mContainer->addItem(item);
+			if( mContainer->addItem(item) )
+            {
+			    dragcont->getParent()->removeChildWindow(dragcont);
+			    std::pair<unsigned int, unsigned int> pos = mContainer->getItemPosition(item);
+			    mContentWindow->addChildWindow(dragcont);
+			    dragcont->setPosition(
+				    UVector2(
+					    cegui_absdim(pos.first*30),
+					    cegui_absdim(pos.second*30)));
+			    dragcont->setItemParent(mContainer);
 
-				dragcont->getParent()->removeChildWindow(dragcont);
-				std::pair<unsigned int, unsigned int> pos = mContainer->getItemPosition(item);
-				mContentWindow->addChildWindow(dragcont);
-				dragcont->setPosition(
-					UVector2(
-						cegui_absdim(pos.first*30),
-						cegui_absdim(pos.second*30)));
-				dragcont->setItemParent(mContainer);
-
-				///@todo Swap with old content (if there is some)
-			}
-			else if (dragcont->getItemParentSlot() != "")
-			{
-				dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
-				mContainer->addItem(item);
-
-				dragcont->getParent()->removeChildWindow(dragcont);
-				std::pair<unsigned int, unsigned int> pos = mContainer->getItemPosition(item);
-				mContentWindow->addChildWindow(dragcont);
-				dragcont->setPosition(
-					UVector2(
-						cegui_absdim(pos.first*30),
-						cegui_absdim(pos.second*30)));
-				dragcont->setItemParent(mContainer);
-
-				///@todo Swap with old content (if there is some)
-			}
-
-			return true;
+			    return true;
+            }
 		}
 		return false;
 	}

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-25 08:47:42 UTC (rev 3742)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-25 10:58:07 UTC (rev 3743)
@@ -52,6 +52,7 @@
 		mWorldBackground = getWindow("InventoryWindow/Background");
         getWindow("InventoryWindow")->subscribeEvent(FrameWindow::EventCloseClicked,
 			boost::bind(&InventoryWindow::destroyWindow, this));
+        mWorldBackground->setZOrderingEnabled(false);
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-25 08:47:42 UTC (rev 3742)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-25 10:58:07 UTC (rev 3743)
@@ -20,6 +20,7 @@
 #include <CEGUIWindowManager.h>
 
 #include "AbstractWindow.h"
+#include "Creature.h"
 #include "Inventory.h"
 #include "Item.h"
 #include "WindowFactory.h"
@@ -32,7 +33,8 @@
 		mItem(item),
 		mParentContainer(NULL),
 		mParentSlot(""),
-		mContentWindow(NULL)
+		mContentWindow(NULL),
+        mInventory(NULL)
 	{
 	}
 
@@ -108,7 +110,7 @@
 		const CEGUI::MouseEventArgs& mevt = static_cast<const CEGUI::MouseEventArgs&>(evt);
 		if (mevt.button == CEGUI::LeftButton)
 		{
-			item->doDefaultAction(mInventory->getOwner(), NULL);
+            item->doDefaultAction(static_cast<Creature*>(item->getOwner()), NULL);
 			return true;
 		}
 		else



From melven at mail.berlios.de  Sat Aug 25 16:52:44 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 16:52:44 +0200
Subject: [Dsa-hl-svn] r3744 - in modules/common: dsa scripts
Message-ID: <200708251452.l7PEqi64029160@sheep.berlios.de>

Author: melven
Date: 2007-08-25 16:52:35 +0200 (Sat, 25 Aug 2007)
New Revision: 3744

Modified:
   modules/common/dsa/Clothing.gof
   modules/common/scripts/mckhero.rb
Log:
itemtypes set correctly (boots and trousers)

Modified: modules/common/dsa/Clothing.gof
===================================================================
--- modules/common/dsa/Clothing.gof	2007-08-25 10:58:07 UTC (rev 3743)
+++ modules/common/dsa/Clothing.gof	2007-08-25 14:52:35 UTC (rev 3744)
@@ -9,8 +9,8 @@
         <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
         <property name="mass" type="REAL" data="3.0"/>
         <property name="size" type="INTPAIR" data="2,3"/>
+        <property name="itemtype" type="INT" data="4096"/>
         <property name="geometrytype" type="STRING" data="box"/>
-        <property name="itemtype" type="INT" data="32"/>
     </gameobjectclass>
     
     <gameobjectclass classid="men_human_female_cloth_short" baseclass="Armor">
@@ -30,9 +30,9 @@
         <property name="meshfile" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
         <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
         <property name="mass" type="REAL" data="3.0"/>
-        <property name="size" type="INTPAIR" data="2,2"/>
+	<property name="size" type="INTPAIR" data="2,2"/>
+        <property name="itemtype" type="INT" data="16384"/>
         <property name="geometrytype" type="STRING" data="box"/>
-        <property name="itemtype" type="INT" data="32"/>
     </gameobjectclass>
 	
 </GameObjectDefinitions>

Modified: modules/common/scripts/mckhero.rb
===================================================================
--- modules/common/scripts/mckhero.rb	2007-08-25 10:58:07 UTC (rev 3743)
+++ modules/common/scripts/mckhero.rb	2007-08-25 14:52:35 UTC (rev 3744)
@@ -41,8 +41,8 @@
     inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
 	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
 	inv.addSlot("Clothes", "clothes", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Boots", "boots", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Trousers", "trousers", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Boots", "boots", Item::ITEMTYPE_BOOTS,  Item::ITEMTYPE_BOOTS, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Trousers", "trousers", Item::ITEMTYPE_TROUSERS,  Item::ITEMTYPE_TROUSERS, RlScript::SLOT_SUBMESH);
 
 	#addSounds()
         $SCRIPT.log("done.");



From melven at mail.berlios.de  Sat Aug 25 23:39:19 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 23:39:19 +0200
Subject: [Dsa-hl-svn] r3745 - in rl/trunk/engine: rules/include script/swig
	ui/include ui/src
Message-ID: <200708252139.l7PLdJHv004130@sheep.berlios.de>

Author: melven
Date: 2007-08-25 23:39:07 +0200 (Sat, 25 Aug 2007)
New Revision: 3745

Modified:
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
Log:
-slot tooltips
-item tooltips don't seem to work
-itemtype for clothing

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/rules/include/Item.h	2007-08-25 21:39:07 UTC (rev 3745)
@@ -49,7 +49,8 @@
 			ITEMTYPE_TROUSERS   = 1 << 12,
 			ITEMTYPE_SHINBONE   = 1 << 13,
 			ITEMTYPE_BOOTS      = 1 << 14,
-			ITEMTYPE_OTHER      = 1 << 15,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+			ITEMTYPE_OTHER      = 1 << 16,
             ITEMTYPE_ALL_ITEMS  = ~(0)
 		};
 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-08-25 21:39:07 UTC (rev 3745)
@@ -420,7 +420,8 @@
             ITEMTYPE_TROUSERS   = 1 << 12,
             ITEMTYPE_SHINBONE   = 1 << 13,
             ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_OTHER      = 1 << 15,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+            ITEMTYPE_OTHER      = 1 << 16,
             ITEMTYPE_ALL_ITEMS  = ~(0)
         };
     

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-25 21:39:07 UTC (rev 3745)
@@ -58,7 +58,7 @@
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
-		bool handleKeys(const CEGUI::EventArgs& evt, bool down);
+		//bool handleKeys(const CEGUI::EventArgs& evt, bool down);
 		bool destroyDragContainer(ItemDragContainer* cont);
 
 		Ogre::Rectangle getCeGuiRectFromWorldAABB(

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-25 21:39:07 UTC (rev 3745)
@@ -44,9 +44,14 @@
 			Window::EventDragDropItemDropped,
 			boost::bind(&ContainerContentWindow::handleItemDroppedOnContainer, this, _1));
 
-		mContentWindow->setSize(UVector2(
+        UVector2 size = UVector2(
 			cegui_absdim(container->getVolume().first*30),
-            cegui_absdim(container->getVolume().second*30)));
+            cegui_absdim(container->getVolume().second*30));
+		mContentWindow->setSize(size);
+        size.d_x += cegui_absdim(40);
+        size.d_y += cegui_absdim(50);
+        mContentWindow->getParent()->setMaxSize(size);
+        mContentWindow->getParent()->setMinSize(size);
 
 		initializeContent();
 
@@ -90,6 +95,9 @@
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
+            if( item->getParentContainer() == mContainer )
+                return false;
+
 			if( mContainer->addItem(item) )
             {
 			    dragcont->getParent()->removeChildWindow(dragcont);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-25 21:39:07 UTC (rev 3745)
@@ -83,6 +83,7 @@
                     curWndName.substr(
                         curWndName.find("InventoryWindow/Slots/") + 22);
                 slotsInWindowDefinition[slotname] = curWnd;
+                curWnd->setTooltipText(slotname);
             }
             else
             {
@@ -133,6 +134,7 @@
 				if (itemWindow != NULL)
 				{
 					slotWindow->addChildWindow(itemWindow);
+                    slotWindow->setTooltipText(item->getName());
 				}
             }
         }
@@ -142,10 +144,10 @@
 			boost::bind(&InventoryWindow::handleItemDroppedOnWorld, this, _1));
 		mWorldBackground->subscribeEvent(Window::EventMouseMove,
 			boost::bind(&InventoryWindow::handleMouseMovedInWorld, this, _1));
-		mWorldBackground->subscribeEvent(Window::EventKeyDown,
-			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
-		mWorldBackground->subscribeEvent(Window::EventKeyUp,
-			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
+		//mWorldBackground->subscribeEvent(Window::EventKeyDown,
+		//	boost::bind(&InventoryWindow::handleKeys, this, _1, true));
+		//mWorldBackground->subscribeEvent(Window::EventKeyUp,
+		//	boost::bind(&InventoryWindow::handleKeys, this, _1, false));
     }
 /*
     ItemDragContainer* InventoryWindow::getItemDragContainer(Item* item, bool description)
@@ -359,7 +361,7 @@
 
 		return true;
 	}
-
+/*
 	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &evt, bool down)
 	{
 		const KeyEventArgs& kevt = static_cast<const KeyEventArgs&>(evt);
@@ -410,7 +412,7 @@
 
 		return false;
 	}
-
+*/
 	bool InventoryWindow::destroyDragContainer(rl::ItemDragContainer* cont)
 	{
 		cont->hide();

Modified: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-08-25 14:52:35 UTC (rev 3744)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-08-25 21:39:07 UTC (rev 3745)
@@ -58,7 +58,6 @@
 		mContentWindow->setSize(CEGUI::UVector2(
 			cegui_absdim(item->getSize().first*30),
 			cegui_absdim(item->getSize().second*30)));
-		setTooltipText(item->getName());
 
 		addChildWindow(mContentWindow);
 	}



From melven at mail.berlios.de  Sat Aug 25 23:40:30 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 25 Aug 2007 23:40:30 +0200
Subject: [Dsa-hl-svn] r3746 - in modules: common/dsa common/scripts
	regressiontest/dsa
Message-ID: <200708252140.l7PLeUtb004314@sheep.berlios.de>

Author: melven
Date: 2007-08-25 23:40:21 +0200 (Sat, 25 Aug 2007)
New Revision: 3746

Modified:
   modules/common/dsa/Clothing.gof
   modules/common/scripts/mckhero.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/dsa/mapmeshparttest.gof
Log:
itemtype for clothes and backpack implemented

Modified: modules/common/dsa/Clothing.gof
===================================================================
--- modules/common/dsa/Clothing.gof	2007-08-25 21:39:07 UTC (rev 3745)
+++ modules/common/dsa/Clothing.gof	2007-08-25 21:40:21 UTC (rev 3746)
@@ -21,7 +21,7 @@
         <property name="mass" type="REAL" data="3.0"/>
         <property name="size" type="INTPAIR" data="2,3"/>
         <property name="geometrytype" type="STRING" data="box"/>
-        <property name="itemtype" type="INT" data="32"/>
+        <property name="itemtype" type="INT" data="32768"/>
     </gameobjectclass>
     
     <gameobjectclass classid="men_human_female_feet_boots_01" baseclass="Armor">

Modified: modules/common/scripts/mckhero.rb
===================================================================
--- modules/common/scripts/mckhero.rb	2007-08-25 21:39:07 UTC (rev 3745)
+++ modules/common/scripts/mckhero.rb	2007-08-25 21:40:21 UTC (rev 3746)
@@ -33,14 +33,14 @@
 	inv = getInventory();
 	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
 	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_WEAPON | Item::ITEMTYPE_SHIELD, Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_WEAPON | Item::ITEMTYPE_SHIELD, Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Back", "back", 0, Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Back", "back", 0, Item::ITEMTYPE_BACKPACK, RlScript::SLOT_SUBMESH);
 	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
-    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
-	inv.addSlot("Clothes", "clothes", Item::ITEMTYPE_ARMOR,  Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+        inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR | Item::ITEMTYPE_CLOTHES, Item::ITEMTYPE_ARMOR | Item::ITEMTYPE_CLOTHES, RlScript::SLOT_MATERIAL);
+	inv.addSlot("Clothes", "clothes", Item::ITEMTYPE_CLOTHES,  Item::ITEMTYPE_CLOTHES, RlScript::SLOT_SUBMESH);
 	inv.addSlot("Boots", "boots", Item::ITEMTYPE_BOOTS,  Item::ITEMTYPE_BOOTS, RlScript::SLOT_SUBMESH);
 	inv.addSlot("Trousers", "trousers", Item::ITEMTYPE_TROUSERS,  Item::ITEMTYPE_TROUSERS, RlScript::SLOT_SUBMESH);
 

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-25 21:39:07 UTC (rev 3745)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-25 21:40:21 UTC (rev 3746)
@@ -96,6 +96,7 @@
         <property name="capacity" type="REAL" data="20.0"/>
         <property name="volume" type="INTPAIR" data="8,6"/>
         <property name="size" type="INTPAIR" data="2,2"/>
+        <property name="itemtype" type="INT" data="256"/>	
 		<property name="mass" type="REAL" data="5.0"/>
 		<property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="actions" type="ARRAY">

Modified: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-08-25 21:39:07 UTC (rev 3745)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-08-25 21:40:21 UTC (rev 3746)
@@ -52,6 +52,7 @@
         <property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="g_be" type="INT" data="2"/>
         <property name="g_rs" type="INT" data="3"/>
+        <property name="size" type="INTPAIR" data="3,4"/>
 		<property name="itemtype" type="INT" data="32"/>
     </gameobjectclass>
 



From melven at mail.berlios.de  Sun Aug 26 12:12:13 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 12:12:13 +0200
Subject: [Dsa-hl-svn] r3747 - in rl/trunk/engine/ui: include src
Message-ID: <200708261012.l7QACDgW016165@sheep.berlios.de>

Author: melven
Date: 2007-08-26 12:12:02 +0200 (Sun, 26 Aug 2007)
New Revision: 3747

Modified:
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
improved behaviour of InventoryWindow and ContainerContentWindow

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-08-26 10:12:02 UTC (rev 3747)
@@ -105,7 +105,7 @@
 		const CeGuiString& getNamePrefix() const;
 		
 		void centerWindow();
-		bool destroyWindow();		
+		virtual bool destroyWindow();		
 		bool hideWindow();
 
 		void bindDestroyWindowToClick(CEGUI::Window* button);

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-26 10:12:02 UTC (rev 3747)
@@ -19,21 +19,28 @@
 
 #include "UiPrerequisites.h"
 #include "AbstractWindow.h"
+#include "InventoryWindow.h"
 
 namespace rl {
 
 	class Container;
 	class Item;
 	
+    /// this class is intended to be used with a inventorywindow
 	class _RlUiExport ContainerContentWindow :
 		public AbstractWindow
 	{
 	public:
-		ContainerContentWindow(Container* container);
+		ContainerContentWindow(Container* container, InventoryWindow* parent);
+        void doDestroyWindow();
 
+    protected:
+        bool destroyWindow();
+
 	private:
 		CEGUI::Window* mContentWindow;
 		Container* mContainer;
+        InventoryWindow* mInventoryWindow;
 
 		static int sItemCount;
 

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 10:12:02 UTC (rev 3747)
@@ -26,6 +26,8 @@
 namespace rl {
 
 	class CameraObject;
+    class Container;
+    class ContainerContentWindow;
     class Inventory;
 	class Item;
 	class ItemDragContainer;
@@ -39,6 +41,12 @@
 		InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory);
 		~InventoryWindow();
 
+        void showContainerContent(Container* container);
+        void notifyContainerContentWindowClosed(Container* container); // no error if not found!
+
+    protected:
+        bool destroyWindow();
+
     private:
 		typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
 
@@ -64,6 +72,8 @@
 		Ogre::Rectangle getCeGuiRectFromWorldAABB(
 			CameraObject* camera,
 			const Ogre::AxisAlignedBox& aabb) const;
+        typedef std::map<Container*, ContainerContentWindow*> ContainerMap;
+        ContainerMap mOpenContainerMap;
     };
 }
 

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-26 10:12:02 UTC (rev 3747)
@@ -25,6 +25,7 @@
 
 #include "Container.h"
 #include "Inventory.h"
+#include "InventoryWindow.h"
 #include "ItemIconDragContainer.h"
 #include "WindowFactory.h"
 
@@ -34,9 +35,10 @@
 
 	int ContainerContentWindow::sItemCount = 0;
 
-	ContainerContentWindow::ContainerContentWindow(Container* container)
+	ContainerContentWindow::ContainerContentWindow(Container* container, InventoryWindow* parent)
 		: AbstractWindow("containercontentwindow.xml", WIT_MOUSE_INPUT),
-		mContainer(container)
+		mContainer(container),
+        mInventoryWindow(parent)
 	{
 		mContentWindow = getWindow("ContainerContentWindow/Content");
 		mContentWindow->setUserData(container);
@@ -56,9 +58,21 @@
 		initializeContent();
 
 		bindDestroyWindowToXButton();
-		centerWindow();
 	}
 
+    bool ContainerContentWindow::destroyWindow()
+    {
+        if( mInventoryWindow )
+            mInventoryWindow->notifyContainerContentWindowClosed(mContainer);
+
+        return AbstractWindow::destroyWindow();
+    }
+
+    void ContainerContentWindow::doDestroyWindow()
+    {
+        destroyWindow();
+    }
+
 	void ContainerContentWindow::initializeContent()
 	{
 		ItemSet items = mContainer->getItems();

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 10:12:02 UTC (rev 3747)
@@ -27,6 +27,7 @@
 #include "ActorManager.h"
 #include "CameraObject.h"
 #include "Container.h"
+#include "ContainerContentWindow.h"
 #include "Creature.h"
 #include "Inventory.h"
 #include "Item.h"
@@ -52,7 +53,7 @@
 		mWorldBackground = getWindow("InventoryWindow/Background");
         getWindow("InventoryWindow")->subscribeEvent(FrameWindow::EventCloseClicked,
 			boost::bind(&InventoryWindow::destroyWindow, this));
-        mWorldBackground->setZOrderingEnabled(false);
+        //mWorldBackground->setZOrderingEnabled(false);
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);
@@ -451,4 +452,43 @@
         Ogre::Rectangle rval = {left,top, right, bottom};
         return rval;
     }
+
+    void InventoryWindow::showContainerContent(Container* container)
+    {
+        ContainerMap::iterator iter = mOpenContainerMap.find(container);
+        if( iter == mOpenContainerMap.end() )
+        {
+            ContainerContentWindow* wnd = new ContainerContentWindow(container, this);
+            mOpenContainerMap.insert(make_pair(container, wnd));
+            mWorldBackground->addChildWindow(wnd->getWindow());
+            wnd->setVisible(true);
+        }
+        else
+        {
+            iter->second->setVisible(true);
+            iter->second->getWindow()->moveToFront();
+        }
+    }
+
+    bool InventoryWindow::destroyWindow()
+    {
+        ContainerMap::iterator iter = mOpenContainerMap.begin();
+        for( ; iter != mOpenContainerMap.end(); iter++)
+        {
+            if( iter->second != NULL )
+                iter->second->doDestroyWindow();
+        }
+        mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
+
+        return AbstractWindow::destroyWindow();
+    }
+
+    void InventoryWindow::notifyContainerContentWindowClosed(Container* container)
+    {
+        ContainerMap::iterator iter = mOpenContainerMap.find(container);
+        if( iter != mOpenContainerMap.end() )
+        {
+            mOpenContainerMap.erase(iter);
+        }
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-25 21:40:21 UTC (rev 3746)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-08-26 10:12:02 UTC (rev 3747)
@@ -25,7 +25,6 @@
 #include "CloseConfirmationWindow.h"
 #include "CombatWindow.h"
 #include "Console.h"
-#include "ContainerContentWindow.h"
 #include "CoreSubsystem.h"
 #include "DebugWindow.h"
 #include "DialogCharacter.h"
@@ -137,7 +136,10 @@
 
     void WindowFactory::showContainerContent(Container* container)
     {
-        (new ContainerContentWindow(container))->setVisible(true);
+        if( !mInventoryWindow )
+            toggleInventoryWindow();
+
+        mInventoryWindow->showContainerContent(container);
     }
 
     void WindowFactory::showMessageWindow(const CeGuiString& message)



From melven at mail.berlios.de  Sun Aug 26 12:12:38 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 12:12:38 +0200
Subject: [Dsa-hl-svn] r3748 - modules/common/gui/windows
Message-ID: <200708261012.l7QACctp016186@sheep.berlios.de>

Author: melven
Date: 2007-08-26 12:12:32 +0200 (Sun, 26 Aug 2007)
New Revision: 3748

Modified:
   modules/common/gui/windows/inventory_human.xml
Log:
changed window-position

Modified: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-08-26 10:12:02 UTC (rev 3747)
+++ modules/common/gui/windows/inventory_human.xml	2007-08-26 10:12:32 UTC (rev 3748)
@@ -4,8 +4,8 @@
 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
 		
 	    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
-			<Property Name="VerticalAlignment" Value="Centre" />
-			<Property Name="HorizontalAlignment" Value="Centre" />
+			<Property Name="VerticalAlignment" Value="Bottom" />
+			<Property Name="HorizontalAlignment" Value="Left" />
 			<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
 			<Property Name="Text" Value="Inventar" />
 			



From melven at mail.berlios.de  Sun Aug 26 12:50:52 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 12:50:52 +0200
Subject: [Dsa-hl-svn] r3749 - in rl/trunk/engine/ui: include src
Message-ID: <200708261050.l7QAoqus018498@sheep.berlios.de>

Author: melven
Date: 2007-08-26 12:50:40 +0200 (Sun, 26 Aug 2007)
New Revision: 3749

Modified:
   rl/trunk/engine/ui/include/FreeflightControlState.h
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
-fixed the orientation of the cam when controlstates are paused
-fixed inventorywindow z-order-position

Modified: rl/trunk/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/trunk/engine/ui/include/FreeflightControlState.h	2007-08-26 10:12:32 UTC (rev 3748)
+++ rl/trunk/engine/ui/include/FreeflightControlState.h	2007-08-26 10:50:40 UTC (rev 3749)
@@ -67,7 +67,6 @@
 		Ogre::Real mSpeedIncrement;
 		Ogre::Real mRotationSpeed;
         Ogre::Vector3 mDesiredVelocity;
-        Ogre::Vector3 mCameraUpConstraint;
         Ogre::Radian mYaw;
         Ogre::Radian mPitch;
         bool mCollisionsEnabled;

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-26 10:12:32 UTC (rev 3748)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-26 10:50:40 UTC (rev 3749)
@@ -45,7 +45,6 @@
         mDesiredVelocity(Vector3::ZERO),
         mCollisionsEnabled(false),
         mPitchRange(Degree(-89), Degree(89)),
-        mCameraUpConstraint(Vector3::ZERO),
         mYaw(Degree(0)),
         mPitch(Degree(0))
 	{
@@ -59,9 +58,7 @@
 
     void FreeflightControlState::pause()
     {
-		mCameraActor->getPhysicalThing()->unfreeze();
-        if(mCameraUpConstraint != Vector3::ZERO)
-            mCameraActor->getPhysicalThing()->setUpConstraint(mCameraUpConstraint);
+		mCameraActor->getPhysicalThing()->freeze();
 		mCharacterActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
 
@@ -80,8 +77,7 @@
 
     void FreeflightControlState::resume()
     {
-        mCameraActor->getPhysicalThing()->freeze();
-        mCameraUpConstraint = mCameraActor->getPhysicalThing()->getUpConstraint();
+        mCameraActor->getPhysicalThing()->unfreeze();
 		mCharacterActor->getPhysicalThing()->freeze();
 
         resetCamera();
@@ -89,6 +85,7 @@
         // The actor should be controlled manually,
         // so let the PM prepare it accordingly
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
         // We also handle char<->level, char<->default collision from now on (camera=char!)
         PhysicsManager::getSingleton().getMaterialPair(
             PhysicsManager::getSingleton().getMaterialID("camera"),

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 10:12:32 UTC (rev 3748)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 10:50:40 UTC (rev 3749)
@@ -53,7 +53,8 @@
 		mWorldBackground = getWindow("InventoryWindow/Background");
         getWindow("InventoryWindow")->subscribeEvent(FrameWindow::EventCloseClicked,
 			boost::bind(&InventoryWindow::destroyWindow, this));
-        //mWorldBackground->setZOrderingEnabled(false);
+        mWorldBackground->moveToBack();
+        mWorldBackground->setZOrderingEnabled(false);
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-26 10:12:32 UTC (rev 3748)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-26 10:50:40 UTC (rev 3749)
@@ -161,8 +161,8 @@
         mController = NULL;
 
         // actors aren't controlled anymore
-        //mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
         // cam<->Level collision back to default
         PhysicsManager::getSingleton().resetMaterialPair(
             PhysicsManager::getSingleton().getMaterialID("camera"),
@@ -207,7 +207,9 @@
         // control camera
         mCameraActor->getPhysicalThing()->setMaterialID(
             PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
 
         // We also handle cam<->level, cam<->default cam<->char collision from now on
         PhysicsManager::getSingleton().createMaterialPair(
@@ -614,6 +616,7 @@
                 mCharacterActor->setVisible(true);
             }
         }
+        mCameraActor->setOrientation(cameraNode->getOrientation());
     }
 
     // -------------------------------------------------------------



From melven at mail.berlios.de  Sun Aug 26 13:20:35 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 13:20:35 +0200
Subject: [Dsa-hl-svn] r3750 - in rl/trunk/engine/ui: include src
Message-ID: <200708261120.l7QBKZHX031948@sheep.berlios.de>

Author: melven
Date: 2007-08-26 13:20:19 +0200 (Sun, 26 Aug 2007)
New Revision: 3750

Modified:
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
-fixed toggling inventorywindow

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2007-08-26 10:50:40 UTC (rev 3749)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-08-26 11:20:19 UTC (rev 3750)
@@ -105,7 +105,7 @@
 		const CeGuiString& getNamePrefix() const;
 		
 		void centerWindow();
-		virtual bool destroyWindow();		
+		bool destroyWindow();		
 		bool hideWindow();
 
 		void bindDestroyWindowToClick(CEGUI::Window* button);

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-26 10:50:40 UTC (rev 3749)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-26 11:20:19 UTC (rev 3750)
@@ -32,10 +32,8 @@
 	{
 	public:
 		ContainerContentWindow(Container* container, InventoryWindow* parent);
-        void doDestroyWindow();
 
-    protected:
-        bool destroyWindow();
+        void setVisible(bool visible, bool destroyAfterHide = false);
 
 	private:
 		CEGUI::Window* mContentWindow;

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 10:50:40 UTC (rev 3749)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 11:20:19 UTC (rev 3750)
@@ -44,8 +44,7 @@
         void showContainerContent(Container* container);
         void notifyContainerContentWindowClosed(Container* container); // no error if not found!
 
-    protected:
-        bool destroyWindow();
+        void setVisible(bool visible, bool destroyAfterHide = false);
 
     private:
 		typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-26 10:50:40 UTC (rev 3749)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-26 11:20:19 UTC (rev 3750)
@@ -60,19 +60,17 @@
 		bindDestroyWindowToXButton();
 	}
 
-    bool ContainerContentWindow::destroyWindow()
+    void ContainerContentWindow::setVisible(bool visible, bool destroyAfterHide)
     {
-        if( mInventoryWindow )
-            mInventoryWindow->notifyContainerContentWindowClosed(mContainer);
+        if( !visible && destroyAfterHide )
+        {
+            if( mInventoryWindow )
+                mInventoryWindow->notifyContainerContentWindowClosed(mContainer);
+        }
 
-        return AbstractWindow::destroyWindow();
+        AbstractWindow::setVisible(visible, destroyAfterHide);
     }
 
-    void ContainerContentWindow::doDestroyWindow()
-    {
-        destroyWindow();
-    }
-
 	void ContainerContentWindow::initializeContent()
 	{
 		ItemSet items = mContainer->getItems();

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 10:50:40 UTC (rev 3749)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 11:20:19 UTC (rev 3750)
@@ -471,17 +471,20 @@
         }
     }
 
-    bool InventoryWindow::destroyWindow()
+    void InventoryWindow::setVisible(bool visible, bool destroyAfterHide)
     {
-        ContainerMap::iterator iter = mOpenContainerMap.begin();
-        for( ; iter != mOpenContainerMap.end(); iter++)
+        if( !visible && destroyAfterHide )
         {
-            if( iter->second != NULL )
-                iter->second->doDestroyWindow();
+            ContainerMap::iterator iter = mOpenContainerMap.begin();
+            for( ; iter != mOpenContainerMap.end(); iter++)
+            {
+                if( iter->second != NULL )
+                    iter->second->setVisible(false, true);
+            }
+            mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
         }
-        mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
 
-        return AbstractWindow::destroyWindow();
+        AbstractWindow::setVisible(visible, destroyAfterHide);
     }
 
     void InventoryWindow::notifyContainerContentWindowClosed(Container* container)



From melven at mail.berlios.de  Sun Aug 26 15:12:20 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 15:12:20 +0200
Subject: [Dsa-hl-svn] r3751 - modules/common/gui/schemes
Message-ID: <200708261312.l7QDCK2C008628@sheep.berlios.de>

Author: melven
Date: 2007-08-26 15:12:15 +0200 (Sun, 26 Aug 2007)
New Revision: 3751

Modified:
   modules/common/gui/schemes/RastullahLook.looknfeel
Log:
added colors for Container-Windows

Modified: modules/common/gui/schemes/RastullahLook.looknfeel
===================================================================
--- modules/common/gui/schemes/RastullahLook.looknfeel	2007-08-26 11:20:19 UTC (rev 3750)
+++ modules/common/gui/schemes/RastullahLook.looknfeel	2007-08-26 13:12:15 UTC (rev 3751)
@@ -504,6 +504,10 @@
 	<!-- RastullahLook/Container -->
 	<WidgetLook name="RastullahLook/Container">
 		<PropertyDefinition	name="ContainerColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_Standard" initialValue="FFFFFFFF" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropPossible" initialValue="FFFFFF00" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropImpossible" initialValue="FFFF0000" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropReady" initialValue="FF00FF00" redrawOnWrite="true" />
 
         <Property name="UnifiedMinSize" value="{{0,30},{0,30}}" />
 		<Property name="Alpha" value="0.7" />



From melven at mail.berlios.de  Sun Aug 26 15:13:30 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 15:13:30 +0200
Subject: [Dsa-hl-svn] r3752 - in rl/trunk/engine: rules/src ui/include ui/src
Message-ID: <200708261313.l7QDDUlB008664@sheep.berlios.de>

Author: melven
Date: 2007-08-26 15:13:21 +0200 (Sun, 26 Aug 2007)
New Revision: 3752

Modified:
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
the slot can be become green red or yellow to indicate wether an item can be dropped or not

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-08-26 13:12:15 UTC (rev 3751)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-08-26 13:13:21 UTC (rev 3752)
@@ -212,7 +212,7 @@
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
 
-		return true;//slotIter->second->canReady(item);
+		return slotIter->second->canReady(item);
     }
 
     Item* Inventory::getItem(const CeGuiString& slotName) const

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 13:12:15 UTC (rev 3751)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 13:13:21 UTC (rev 3752)
@@ -63,6 +63,8 @@
         //ItemDragContainer* getItemDragContainer(Item* item, bool description);
         CeGuiString getDragContainerNameFromItem(const Item* item, bool description);
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
+        bool handleItemEntersSlot(const CEGUI::EventArgs& evt);
+        bool handleItemLeavesSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
 		//bool handleKeys(const CEGUI::EventArgs& evt, bool down);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 13:12:15 UTC (rev 3751)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 13:13:21 UTC (rev 3752)
@@ -128,6 +128,10 @@
 			slotWindow->setDragDropTarget(true);
 			slotWindow->subscribeEvent(Window::EventDragDropItemDropped,
 				boost::bind(&InventoryWindow::handleItemDroppedOnSlot, this, _1));
+            slotWindow->subscribeEvent(Window::EventDragDropItemEnters,
+                boost::bind(&InventoryWindow::handleItemEntersSlot, this, _1));
+            slotWindow->subscribeEvent(Window::EventDragDropItemLeaves,
+                boost::bind(&InventoryWindow::handleItemLeavesSlot, this, _1));
 
             if (item != NULL)
             {
@@ -267,17 +271,73 @@
 				newCont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
 				newCont->setItemParent(mInventory, targetSlot);
 
+                handleItemLeavesSlot(evt);
 				return true;
 			}
 			else
 			{
+                handleItemLeavesSlot(evt);
 				return false;
 			}
 		}
 
+        handleItemLeavesSlot(evt);
 		return false;
 	}
 
+    bool InventoryWindow::handleItemEntersSlot(const CEGUI::EventArgs& evt)
+    {
+		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
+
+		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
+		{
+			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+				evtArgs.dragDropItem);
+			Item* item = dragcont->getItem();
+			CeGuiString targetSlot = evtArgs.window->getUserString(SLOTNAME);
+            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
+
+            if( mInventory->canReady(item, targetSlot) )
+            {
+                slotWindow->setProperty("ContainerColour", 
+                    slotWindow->getProperty("ContainerColour_DropReady"));
+            }
+            else if( mInventory->canHold(item, targetSlot) )
+            {
+                slotWindow->setProperty("ContainerColour", 
+                    slotWindow->getProperty("ContainerColour_DropPossible"));
+            }
+            else
+            {
+                slotWindow->setProperty("ContainerColour", 
+                    slotWindow->getProperty("ContainerColour_DropImpossible"));
+            }
+
+
+            return true;
+        }
+        return false;
+    }
+
+    bool InventoryWindow::handleItemLeavesSlot(const CEGUI::EventArgs& evt)
+    {
+		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
+
+		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
+		{
+			CeGuiString targetSlot = evtArgs.window->getUserString(SLOTNAME);
+            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
+
+            slotWindow->setProperty("ContainerColour", 
+                slotWindow->getProperty("ContainerColour_Standard"));
+
+            return true;
+        }
+        return false;
+    }
+
 	bool InventoryWindow::handleItemDroppedOnWorld(const EventArgs& evt)
 	{
 		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);



From josch at mail.berlios.de  Sun Aug 26 15:27:13 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Sun, 26 Aug 2007 15:27:13 +0200
Subject: [Dsa-hl-svn] r3753 - rl/trunk/engine/script/swig
Message-ID: <200708261327.l7QDRDxV009457@sheep.berlios.de>

Author: josch
Date: 2007-08-26 15:27:07 +0200 (Sun, 26 Aug 2007)
New Revision: 3753

Modified:
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
Log:
PolynomicSoundFadeFunctor exported to Ruby

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-26 13:13:21 UTC (rev 3752)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-08-26 13:27:07 UTC (rev 3753)
@@ -63,6 +63,7 @@
 #include "SoundFadeJob.h"
 #include "SoundFadeFunctor.h"
 #include "LinearSoundFadeFunctor.h"
+#include "PolynomicSoundFadeFunctor.h"
 #include "TimeSource.h"
 
 #undef message

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-08-26 13:13:21 UTC (rev 3752)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-08-26 13:27:07 UTC (rev 3753)
@@ -938,7 +938,18 @@
     virtual Ogre::Real operator()(Ogre::Real time);
 };
 
+%rename(getVolume) rl::PolynomicSoundFadeFunctor::operator();
+typedef std::vector< std::pair<Ogre::Real, Ogre::Real> > InterpolationPoints;
+typedef std::vector<Ogre::Real> Parameters;
+class PolynomicSoundFadeFunctor : public rl::SoundFadeFunctor
+{
+public:
+    PolynomicSoundFadeFunctor(Ogre::Real duration, InterpolationPoints *points);
+	~PolynomicSoundFadeFunctor();
 
+    virtual Ogre::Real operator()(Ogre::Real time);
+};
+
 typedef RL_LONGLONG rl::Time;
 
 class TimeSource : public rl::GameTask



From pnyx at mail.berlios.de  Sun Aug 26 15:59:30 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sun, 26 Aug 2007 15:59:30 +0200
Subject: [Dsa-hl-svn] r3754 - modules/common/gui/schemes
Message-ID: <200708261359.l7QDxUPh012191@sheep.berlios.de>

Author: pnyx
Date: 2007-08-26 15:59:25 +0200 (Sun, 26 Aug 2007)
New Revision: 3754

Modified:
   modules/common/gui/schemes/RastullahLook.looknfeel
Log:
adjusted container colors

Modified: modules/common/gui/schemes/RastullahLook.looknfeel
===================================================================
--- modules/common/gui/schemes/RastullahLook.looknfeel	2007-08-26 13:27:07 UTC (rev 3753)
+++ modules/common/gui/schemes/RastullahLook.looknfeel	2007-08-26 13:59:25 UTC (rev 3754)
@@ -505,9 +505,9 @@
 	<WidgetLook name="RastullahLook/Container">
 		<PropertyDefinition	name="ContainerColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
 		<PropertyDefinition	name="ContainerColour_Standard" initialValue="FFFFFFFF" redrawOnWrite="true" />
-		<PropertyDefinition	name="ContainerColour_DropPossible" initialValue="FFFFFF00" redrawOnWrite="true" />
-		<PropertyDefinition	name="ContainerColour_DropImpossible" initialValue="FFFF0000" redrawOnWrite="true" />
-		<PropertyDefinition	name="ContainerColour_DropReady" initialValue="FF00FF00" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropPossible" initialValue="FF9FB9FF" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropImpossible" initialValue="FFFF4700" redrawOnWrite="true" />
+		<PropertyDefinition	name="ContainerColour_DropReady" initialValue="FFBCFF56" redrawOnWrite="true" />
 
         <Property name="UnifiedMinSize" value="{{0,30},{0,30}}" />
 		<Property name="Alpha" value="0.7" />



From melven at mail.berlios.de  Sun Aug 26 17:18:39 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 17:18:39 +0200
Subject: [Dsa-hl-svn] r3755 - modules/common/gui/windows
Message-ID: <200708261518.l7QFIdB7016960@sheep.berlios.de>

Author: melven
Date: 2007-08-26 17:18:23 +0200 (Sun, 26 Aug 2007)
New Revision: 3755

Modified:
   modules/common/gui/windows/containercontentwindow.xml
Log:
changed window look to rasullahlook/container

Modified: modules/common/gui/windows/containercontentwindow.xml
===================================================================
--- modules/common/gui/windows/containercontentwindow.xml	2007-08-26 13:59:25 UTC (rev 3754)
+++ modules/common/gui/windows/containercontentwindow.xml	2007-08-26 15:18:23 UTC (rev 3755)
@@ -4,9 +4,9 @@
 		<Property Name="UnifiedSize" Value="{{0,400},{0,300}}" />
 		<Property Name="WantsMultiClickEvents" Value="True"/>
 
-        <Window Type="DefaultWindow" Name="ContainerContentWindow/Content">
+        <Window Type="RastullahLook/Container" Name="ContainerContentWindow/Content">
 			<Property Name="UnifiedPosition" Value="{{0,20},{0,30}}" />
 			<Property Name="ItemTooltips" Value="True"/>
         </Window>
     </Window>
-</GUILayout>
\ No newline at end of file
+</GUILayout>



From melven at mail.berlios.de  Sun Aug 26 17:26:21 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 26 Aug 2007 17:26:21 +0200
Subject: [Dsa-hl-svn] r3756 - in rl/trunk/engine: rules/include rules/src
	ui/include ui/src
Message-ID: <200708261526.l7QFQLcn017304@sheep.berlios.de>

Author: melven
Date: 2007-08-26 17:26:08 +0200 (Sun, 26 Aug 2007)
New Revision: 3756

Modified:
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
the possible target slots are shown, if dragging an item

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/rules/include/Container.h	2007-08-26 15:26:08 UTC (rev 3756)
@@ -89,6 +89,8 @@
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
+        bool canHold(Item* item);
+
     private:
 		static const IntPair NO_SPACE_FOR_ITEM;
 

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-08-26 15:26:08 UTC (rev 3756)
@@ -78,8 +78,8 @@
     // Das Inventar der Kreatur wird durch das Inventarobjekt verwaltet.
     //void addToInventory(Item* item, const CeGuiString& containerName);
     void hold(Item* item, const CeGuiString& slotName);
-    bool canHold(Item* item, const CeGuiString& slotName) const;
-    bool canReady(Item* item, const CeGuiString& slotName) const;
+    bool canHold(const Item* item, const CeGuiString& slotName) const;
+    bool canReady(const Item* item, const CeGuiString& slotName) const;
 	void dropItem(const CeGuiString& slotName);
     void ready(Item* item);
     //void removeFromInventory(Item* item);

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-26 15:26:08 UTC (rev 3756)
@@ -363,4 +363,8 @@
         return ps;
     }
 
+    bool Container::canHold(Item* item)
+    {
+        return findPositionWithEnoughSpace(item->getSize()) != NO_SPACE_FOR_ITEM;
+    }
 }

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-08-26 15:26:08 UTC (rev 3756)
@@ -193,7 +193,7 @@
         //item->setOwner(getOwner());
     }
 
-	bool Inventory::canHold(Item* item, const CeGuiString& slotName) const
+	bool Inventory::canHold(const Item* item, const CeGuiString& slotName) const
     {
         std::map<CeGuiString, Slot*>::const_iterator slotIter = mSlots.find(slotName);
         if (slotIter == mSlots.end())
@@ -204,7 +204,7 @@
 		return slotIter->second->isAllowed(item);
     }
 
-	bool Inventory::canReady(Item* item, const CeGuiString& slotName) const
+	bool Inventory::canReady(const Item* item, const CeGuiString& slotName) const
     {
         std::map<CeGuiString, Slot*>::const_iterator slotIter = mSlots.find(slotName);
         if (slotIter == mSlots.end())

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-26 15:26:08 UTC (rev 3756)
@@ -43,6 +43,8 @@
 		static int sItemCount;
 
 		bool handleItemDroppedOnContainer(const CEGUI::EventArgs& evt);
+        bool handleItemEntersContainer(const CEGUI::EventArgs& evt);
+        bool handleItemLeavesContainer(const CEGUI::EventArgs& evt);
         bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
         bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
 		void initializeContent();

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-26 15:26:08 UTC (rev 3756)
@@ -46,11 +46,14 @@
 
         void setVisible(bool visible, bool destroyAfterHide = false);
 
+        bool showPossibleSlots(const Item* item);
+
     private:
 		typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
+        typedef std::map<CeGuiString, CEGUI::Window*> SlotWindowMap;
 
 		Inventory* mInventory;
-        std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
+        SlotWindowMap mSlotWindows;
 		CEGUI::Window* mWorldBackground;
 		DndContainerMap mWorldDragContainers;
 		DndContainerMap mSlotDragContainers;

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-26 15:26:08 UTC (rev 3756)
@@ -45,6 +45,12 @@
 		mContentWindow->subscribeEvent(
 			Window::EventDragDropItemDropped,
 			boost::bind(&ContainerContentWindow::handleItemDroppedOnContainer, this, _1));
+		mContentWindow->subscribeEvent(
+            Window::EventDragDropItemEnters,
+			boost::bind(&ContainerContentWindow::handleItemEntersContainer, this, _1));
+		mContentWindow->subscribeEvent(
+            Window::EventDragDropItemLeaves,
+			boost::bind(&ContainerContentWindow::handleItemLeavesContainer, this, _1));
 
         UVector2 size = UVector2(
 			cegui_absdim(container->getVolume().first*30),
@@ -60,6 +66,45 @@
 		bindDestroyWindowToXButton();
 	}
 
+    bool ContainerContentWindow::handleItemEntersContainer(const CEGUI::EventArgs& evt)
+    {
+		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
+
+		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
+		{
+			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+				evtArgs.dragDropItem);
+			Item* item = dragcont->getItem();
+
+            if( item->getParentContainer() == mContainer )
+                return true;
+
+            if( !mContainer->canHold(item) )
+            {
+                mContentWindow->setProperty("ContainerColour", 
+                    mContentWindow->getProperty("ContainerColour_DropImpossible"));
+            }
+
+
+            return true;
+        }
+        return false;
+    }
+
+    bool ContainerContentWindow::handleItemLeavesContainer(const CEGUI::EventArgs& evt)
+    {
+        const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
+
+		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
+		{
+            mContentWindow->setProperty("ContainerColour", 
+                mContentWindow->getProperty("ContainerColour_Standard"));
+
+            return true;
+        }
+        return false;
+    }
+
     void ContainerContentWindow::setVisible(bool visible, bool destroyAfterHide)
     {
         if( !visible && destroyAfterHide )
@@ -121,9 +166,11 @@
 					    cegui_absdim(pos.second*30)));
 			    dragcont->setItemParent(mContainer);
 
+                handleItemLeavesContainer(evt);
 			    return true;
             }
 		}
+        handleItemLeavesContainer(evt);
 		return false;
 	}
 
@@ -153,6 +200,13 @@
 			dragContainerName);
 		itemhandler->setItemParent(mContainer);
 		itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+        if( mInventoryWindow )
+        {
+            itemhandler->subscribeEvent(DragContainer::EventDragStarted,
+                boost::bind(&rl::InventoryWindow::showPossibleSlots, mInventoryWindow, item));
+            itemhandler->subscribeEvent(DragContainer::EventDragEnded,
+                boost::bind(&InventoryWindow::showPossibleSlots, mInventoryWindow, (Item*)NULL));
+        }
 
 		return itemhandler;
 	}

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 15:18:23 UTC (rev 3755)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-26 15:26:08 UTC (rev 3756)
@@ -223,6 +223,10 @@
 
 			itemhandler->setRiseOnClickEnabled(true);
 			itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+            itemhandler->subscribeEvent(DragContainer::EventDragStarted,
+                boost::bind(&rl::InventoryWindow::showPossibleSlots, this, item));
+            itemhandler->subscribeEvent(DragContainer::EventDragEnded,
+                boost::bind(&InventoryWindow::showPossibleSlots, this, (Item*)NULL));
 		}
 
 		return itemhandler;
@@ -271,12 +275,12 @@
 				newCont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
 				newCont->setItemParent(mInventory, targetSlot);
 
-                handleItemLeavesSlot(evt);
+                showPossibleSlots(NULL);
 				return true;
 			}
 			else
 			{
-                handleItemLeavesSlot(evt);
+                showPossibleSlots(NULL);
 				return false;
 			}
 		}
@@ -300,13 +304,13 @@
 
             if( mInventory->canReady(item, targetSlot) )
             {
-                slotWindow->setProperty("ContainerColour", 
-                    slotWindow->getProperty("ContainerColour_DropReady"));
+                //slotWindow->setProperty("ContainerColour", 
+                //    slotWindow->getProperty("ContainerColour_DropReady"));
             }
             else if( mInventory->canHold(item, targetSlot) )
             {
-                slotWindow->setProperty("ContainerColour", 
-                    slotWindow->getProperty("ContainerColour_DropPossible"));
+                //slotWindow->setProperty("ContainerColour", 
+                //    slotWindow->getProperty("ContainerColour_DropPossible"));
             }
             else
             {
@@ -326,13 +330,30 @@
 
 		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
 		{
+			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+				evtArgs.dragDropItem);
+			Item* item = dragcont->getItem();
 			CeGuiString targetSlot = evtArgs.window->getUserString(SLOTNAME);
             CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
 
 
-            slotWindow->setProperty("ContainerColour", 
-                slotWindow->getProperty("ContainerColour_Standard"));
+            if( mInventory->canReady(item, targetSlot) )
+            {
+                //slotWindow->setProperty("ContainerColour", 
+                //    slotWindow->getProperty("ContainerColour_Standard"));
+            }
+            else if( mInventory->canHold(item, targetSlot) )
+            {
+                //slotWindow->setProperty("ContainerColour", 
+                //    slotWindow->getProperty("ContainerColour_Standard"));
+            }
+            else
+            {
+                slotWindow->setProperty("ContainerColour", 
+                    slotWindow->getProperty("ContainerColour_Standard"));
+            }
 
+
             return true;
         }
         return false;
@@ -555,4 +576,31 @@
             mOpenContainerMap.erase(iter);
         }
     }
+
+    bool InventoryWindow::showPossibleSlots(const Item* item)
+    {
+        SlotWindowMap::iterator iter = mSlotWindows.begin();
+
+        for( ; iter != mSlotWindows.end(); iter++ )
+        {
+            if( item )
+            {
+                if( mInventory->canReady(item, iter->first) )
+                {
+                    iter->second->setProperty("ContainerColour", 
+                        iter->second->getProperty("ContainerColour_DropReady"));
+                    continue;
+                }
+                else if( mInventory->canHold(item, iter->first) )
+                {
+                    iter->second->setProperty("ContainerColour", 
+                        iter->second->getProperty("ContainerColour_DropPossible"));
+                    continue;
+                }
+            }
+            iter->second->setProperty("ContainerColour", 
+                iter->second->getProperty("ContainerColour_Standard"));
+        }
+        return true;
+    }
 }



From timm at mail.berlios.de  Sun Aug 26 22:06:31 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 26 Aug 2007 22:06:31 +0200
Subject: [Dsa-hl-svn] r3757 - in rl/trunk/engine/common: include src
Message-ID: <200708262006.l7QK6VBp014123@sheep.berlios.de>

Author: timm
Date: 2007-08-26 22:06:26 +0200 (Sun, 26 Aug 2007)
New Revision: 3757

Modified:
   rl/trunk/engine/common/include/XmlHelper.h
   rl/trunk/engine/common/src/XmlHelper.cpp
Log:
upgraded XmlHelper

Modified: rl/trunk/engine/common/include/XmlHelper.h
===================================================================
--- rl/trunk/engine/common/include/XmlHelper.h	2007-08-26 15:26:08 UTC (rev 3756)
+++ rl/trunk/engine/common/include/XmlHelper.h	2007-08-26 20:06:26 UTC (rev 3757)
@@ -25,6 +25,8 @@
 #include "CommonPrerequisites.h"
 #include "XmlErrorHandler.h"
 
+#include "Tripel.h"
+
 // Da sollten wir uns auf etwas einigen
 // So ist das laestig.
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
@@ -57,13 +59,13 @@
 	 * dieser ist wiederum ein Element-Knoten
 	 *
      * @param doc Das DOM-Document
-	 * @param parent Knoten, dessen Kinder gesucht sind
-	 * @param name Name des gesuchten Kindknotens von parent
+	 * @param parent Knoten, dessen Kind erzeugt wird
+	 * @param name Name des Kindknotens von parent
 	 *
 	 * @return Der Kindknoten
 	 */
     static XERCES_CPP_NAMESPACE::DOMElement* appendChildElement(XERCES_CPP_NAMESPACE::DOMDocument* doc, 
-        XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
+        XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name);
 
     /**
 	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
@@ -133,6 +135,13 @@
 	 */
 	static int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element);
 
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, IntPair value);
+
+    static IntPair getValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element);
+
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Tripel<int> value);
+
+    static Tripel<int> getValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element);
 	
     /**
      * Convert a vector3 to an xml tag
@@ -141,7 +150,7 @@
      * @param value The vector input
 	 * @return The DOM element
 	 */
-    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsVector3(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Vector3 value);
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Vector3 value);
 
     /**
 	 * Processes an element node of shape <any_node_name x="0" y="0" z="0"/>
@@ -159,7 +168,7 @@
      * @param value The quaternion input
 	 * @return The DOM element
 	 */
-    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Quaternion value);
+    static XERCES_CPP_NAMESPACE::DOMElement* setValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Quaternion value);
 
     /**
 	 * Processes an element node of shape <any_node_name x="0" y="0" z="0" w="1"/>
@@ -220,6 +229,14 @@
 	 * @return Das DOM-Element
 	 */
 	static int getAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
+
+    static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, IntPair value);
+
+    static IntPair getAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
+
+    static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Tripel<int> value);
+
+    static Tripel<int> getAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 	
 	/**
 	 * Setzt den Text eines DOMElement-Attributes

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-26 15:26:08 UTC (rev 3756)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-26 20:06:26 UTC (rev 3757)
@@ -23,6 +23,8 @@
 #include "Exception.h"
 #include "Logger.h"
 
+#include <CEGUIPropertyHelper.h>
+
 using namespace XERCES_CPP_NAMESPACE;
 
 
@@ -144,6 +146,70 @@
 	return rVal;
 }
 
+DOMElement* XmlHelper::setAttributeValueAsIntegerPair(DOMElement* element, const char* const name, IntPair value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsIntegerPair: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    CeGuiString temp = Ogre::StringConverter::toString(value.first) + "," + Ogre::StringConverter::toString(value.second);
+    element->setAttribute(attrName,XMLString::transcode(temp.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
+IntPair XmlHelper::getAttributeValueAsIntegerPair(DOMElement* element, const char* const name)
+{
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsIntegerPair: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+	const XMLCh* attribute = element->getAttribute(attrName);
+	
+    CeGuiString value = transcodeToString(attribute);
+    CeGuiString::size_type comma1 = value.find(",");
+
+	std::pair<int,int> intPairVal = std::make_pair(0, 0);
+    if (comma1 != CeGuiString::npos)
+    {
+		intPairVal = std::make_pair(
+			CEGUI::PropertyHelper::stringToInt(value.substr(0, comma1)),
+			CEGUI::PropertyHelper::stringToInt(value.substr(comma1 + 1)));
+    }
+    XMLString::release(&attrName);
+
+    return intPairVal;
+}
+
+DOMElement* XmlHelper::setAttributeValueAsIntegerTriple(DOMElement *element, const char *const name, Tripel<int> value)
+{
+    RlAssert(element != NULL, "XmlHelper::setAttributeValueAsIntegerTriple: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+    CeGuiString temp = Ogre::StringConverter::toString(value.first) + "," + Ogre::StringConverter::toString(value.second) + "" + Ogre::StringConverter::toString(value.third);
+    element->setAttribute(attrName,XMLString::transcode(temp.c_str()));
+    XMLString::release(&attrName);
+    return element;
+}
+
+Tripel<int> XmlHelper::getAttributeValueAsIntegerTriple(DOMElement* element, const char* const name)
+{
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsIntegerPair: Element must not be NULL");
+	XMLCh* attrName = XMLString::transcode(name);
+	const XMLCh* attribute = element->getAttribute(attrName);
+
+    CeGuiString value = transcodeToString(attribute);
+
+    CeGuiString::size_type comma1 = value.find(",");
+    CeGuiString::size_type comma2 = value.find(",", comma1 + 1);
+
+    Tripel<int> intTripel(0,0,0);
+    if (comma1 != CeGuiString::npos && comma2 != CeGuiString::npos)
+    {
+        intTripel.first = CEGUI::PropertyHelper::stringToFloat(value.substr(0, comma1));
+        intTripel.second = CEGUI::PropertyHelper::stringToFloat(value.substr(comma1 + 1, comma2 - comma1 - 1));
+        intTripel.third = CEGUI::PropertyHelper::stringToFloat(value.substr(comma2 + 1));
+    }
+    XMLString::release(&attrName);
+
+    return intTripel;
+}
+
 DOMElement* XmlHelper::setAttributeValueAsReal(DOMElement *element, const char *const name, Ogre::Real value)
 {
     RlAssert(element != NULL, "XmlHelper::setAttributeValueAsReal: Element must not be NULL");
@@ -246,8 +312,61 @@
 	return XMLString::parseInt(element->getFirstChild()->getNodeValue());
 }
 
-DOMElement* XmlHelper::setValueAsVector3(DOMDocument* doc, DOMElement *element, Ogre::Vector3 value)
+DOMElement* XmlHelper::setValueAsIntegerPair(DOMDocument *doc, DOMElement *element, IntPair value)
 {
+    RlAssert(element != NULL, "XmlHelper::setValueAsIntegerPair: Element must not be NULL");
+    String temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second);
+    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
+    element->appendChild(text);
+    return element;
+}
+
+IntPair XmlHelper::getValueAsIntegerPair(DOMElement* element)
+{
+    RlAssert(element != NULL, "XmlHelper::getValueAsIntegerPair: Element must not be NULL");
+    CeGuiString value = getValueAsString(element);
+    CeGuiString::size_type comma1 = value.find(",");
+
+	std::pair<int,int> intPairVal = std::make_pair(0, 0);
+    if (comma1 != CeGuiString::npos)
+    {
+		intPairVal = std::make_pair(
+			CEGUI::PropertyHelper::stringToInt(value.substr(0, comma1)),
+			CEGUI::PropertyHelper::stringToInt(value.substr(comma1 + 1)));
+    }
+    return intPairVal;
+}
+
+DOMElement* XmlHelper::setValueAsIntegerTriple(DOMDocument *doc, DOMElement *element, Tripel<int> value)
+{
+    RlAssert(element != NULL, "XmlHelper::setValueAsIntegerTriple: Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::setValueAsIntegerPair: Element must not be NULL");
+    String temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second) + ',' + CEGUI::PropertyHelper::intToString(value.third);
+    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
+    element->appendChild(text);
+    return element;
+}
+
+Tripel<int> XmlHelper::getValueAsIntegerTriple(DOMElement *element)
+{
+    RlAssert(element != NULL, "XmlHelper::getValueAsIntegerTriple: Element must not be NULL");
+    CeGuiString value = getValueAsString(element);
+
+    CeGuiString::size_type comma1 = value.find(",");
+    CeGuiString::size_type comma2 = value.find(",", comma1 + 1);
+
+    Tripel<int> intTripel(0,0,0);
+    if (comma1 != CeGuiString::npos && comma2 != CeGuiString::npos)
+    {
+        intTripel.first = CEGUI::PropertyHelper::stringToFloat(value.substr(0, comma1));
+        intTripel.second = CEGUI::PropertyHelper::stringToFloat(value.substr(comma1 + 1, comma2 - comma1 - 1));
+        intTripel.third = CEGUI::PropertyHelper::stringToFloat(value.substr(comma2 + 1));
+    }
+    return intTripel;
+}
+
+DOMElement* XmlHelper::setValueAsVector3( DOMElement *element, Ogre::Vector3 value)
+{
     RlAssert(element != NULL, "XmlHelper::setValueAsVector3: Element must not be NULL");
     setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());
     setAttribute(element, "y", Ogre::StringConverter::toString(value.y).c_str());
@@ -269,7 +388,7 @@
 		getAttributeValueAsReal(element, "z"));
 }
 
-DOMElement* XmlHelper::setValueAsQuaternion(DOMDocument* doc, DOMElement *element, Ogre::Quaternion value)
+DOMElement* XmlHelper::setValueAsQuaternion(DOMElement *element, Ogre::Quaternion value)
 {
     RlAssert(element != NULL, "XmlHelper::setValueAsQuaternion: Element must not be NULL");
     setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());



From timm at mail.berlios.de  Sun Aug 26 22:50:43 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 26 Aug 2007 22:50:43 +0200
Subject: [Dsa-hl-svn] r3758 - in rl/trunk/engine/common: include src
Message-ID: <200708262050.l7QKohcp016654@sheep.berlios.de>

Author: timm
Date: 2007-08-26 22:50:40 +0200 (Sun, 26 Aug 2007)
New Revision: 3758

Modified:
   rl/trunk/engine/common/include/XmlHelper.h
   rl/trunk/engine/common/src/XmlHelper.cpp
Log:
some fixes

Modified: rl/trunk/engine/common/include/XmlHelper.h
===================================================================
--- rl/trunk/engine/common/include/XmlHelper.h	2007-08-26 20:06:26 UTC (rev 3757)
+++ rl/trunk/engine/common/include/XmlHelper.h	2007-08-26 20:50:40 UTC (rev 3758)
@@ -116,8 +116,7 @@
 	static utf8* getValueAsUtf8(XERCES_CPP_NAMESPACE::DOMElement* element);
 
 	/**
-	 * Setzt den Text eines Elementknotens und parst ihn, 
-	 * um eine Ganzzahl daraus zu machen
+	 * Formt eine Ganzzahl in einen String um und setzt diesen als Wert
 	 *
 	 * @param element Das DOM-Element
      * @param value Der zu setzende Integer
@@ -135,12 +134,40 @@
 	 */
 	static int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element);
 
+    /**
+	 * Formt einen Ganzzahldubel in einen String um und setzt diesen als Wert
+	 *
+	 * @param element Das DOM-Element
+     * @param value Das zu setzende IntegerPair
+	 * @return Das DOM-Element
+	 */
     static XERCES_CPP_NAMESPACE::DOMElement* setValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, IntPair value);
 
+    /**
+	 * Ermittelt den Text eines Elementknotens und parst ihn, 
+	 * um einen Ganzzahldubel daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @return Zahl, die innerhalb der Element-Tags steht
+	 */
     static IntPair getValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element);
 
+    /**
+	 * Formt einen Ganzzahltripel in einen String um und setzt diesen als Wert
+	 *
+	 * @param element Das DOM-Element
+     * @param value Der zu setzende Tripel<int>
+	 * @return Das DOM-Element
+	 */
     static XERCES_CPP_NAMESPACE::DOMElement* setValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Tripel<int> value);
 
+    /**
+	 * Ermittelt den Text eines Elementknotens und parst ihn, 
+	 * um einen Ganzzahltripel daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @return Zahl, die innerhalb der Element-Tags steht
+	 */
     static Tripel<int> getValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element);
 	
     /**
@@ -210,12 +237,12 @@
 
     
     /**
-	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
-	 * um eine Ganzzahl daraus zu machen
+	 * Wandelt eine Ganzzahl in einen Text um und setzt diesen als Attribut 
 	 *
 	 * @param element Das DOM-Element
 	 * @param name Name des Attributes
-	 * @return Zahlenwert des Attributes
+     * @param value das zu setzende Integer
+	 * @return Das DOM-Element
 	 */
 	static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, int value);
 
@@ -225,17 +252,48 @@
 	 *
 	 * @param element Das DOM-Element
 	 * @param name Name des Attributes
-     * @param value das zu setzende Integer
-	 * @return Das DOM-Element
+     * @return Zahlenwert des Attributes
 	 */
 	static int getAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
+    /**
+	 * Wandelt eine Ganzzahldubel in einen Text um und setzt diesen als Attribut 
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @param value das zu setzende IntegerPair
+	 * @return Das DOM-Element
+	 */
     static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, IntPair value);
 
+    /**
+	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
+	 * um eine Ganzzahldubel daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @return Zahlendubel des Attributes
+	 */
     static IntPair getAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 
+    /**
+	 * Wandelt eine Ganzzahltripel in einen Text um und setzt diesen als Attribut 
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @param value das zu setzende Tripel<int>
+	 * @return Das DOM-Element
+	 */
     static XERCES_CPP_NAMESPACE::DOMElement* setAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Tripel<int> value);
 
+    /**
+	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
+	 * um eine Ganzzahltripel daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @param name Name des Attributes
+     * @return Zahlendubel des Attributes
+	 */
     static Tripel<int> getAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name);
 	
 	/**

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-26 20:06:26 UTC (rev 3757)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-08-26 20:50:40 UTC (rev 3758)
@@ -189,7 +189,7 @@
 
 Tripel<int> XmlHelper::getAttributeValueAsIntegerTriple(DOMElement* element, const char* const name)
 {
-    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsIntegerPair: Element must not be NULL");
+    RlAssert(element != NULL, "XmlHelper::getAttributeValueAsIntegerTriple: Element must not be NULL");
 	XMLCh* attrName = XMLString::transcode(name);
 	const XMLCh* attribute = element->getAttribute(attrName);
 



From melven at mail.berlios.de  Mon Aug 27 14:01:23 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 14:01:23 +0200
Subject: [Dsa-hl-svn] r3759 - in rl/trunk/engine/core: include src
Message-ID: <200708271201.l7RC1N2r011729@sheep.berlios.de>

Author: melven
Date: 2007-08-27 14:01:08 +0200 (Mon, 27 Aug 2007)
New Revision: 3759

Modified:
   rl/trunk/engine/core/include/JobScheduler.h
   rl/trunk/engine/core/src/JobScheduler.cpp
Log:
implement JobScheduler::remove correctly

Modified: rl/trunk/engine/core/include/JobScheduler.h
===================================================================
--- rl/trunk/engine/core/include/JobScheduler.h	2007-08-26 20:50:40 UTC (rev 3758)
+++ rl/trunk/engine/core/include/JobScheduler.h	2007-08-27 12:01:08 UTC (rev 3759)
@@ -100,6 +100,7 @@
             unsigned long end;            ///< when to discard the Job, if not then finished.
             Ogre::Real timeSinceLastCall; ///< frame time, since the last call of Job#execute.
             bool called;                  ///< false, if the Job has not been called yet.
+            bool markedToRemove;          ///< only true, if removeJob with the ticket of this job is called
         };
 
         /// Functor for finding a Job in a JobQueue by its ticket.
@@ -114,7 +115,7 @@
         typedef std::deque<JobEntry> JobQueue;
 
         JobQueue mJobQueue;
-        JobQueue mRemovedJobs;
+        //JobQueue mRemovedJobs; // should probably replaced by JobsToDelete
         unsigned short mTokenThreshold;
         unsigned long mTicketCounter;
     };

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2007-08-26 20:50:40 UTC (rev 3758)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2007-08-27 12:01:08 UTC (rev 3759)
@@ -28,7 +28,10 @@
 namespace rl
 {
     JobScheduler::JobScheduler()
-        : mJobQueue(), mRemovedJobs(), mTokenThreshold(JP_NORMAL), mTicketCounter(0)
+        : mJobQueue(), 
+        //mRemovedJobs(), 
+        mTokenThreshold(JP_NORMAL), 
+        mTicketCounter(0)
     {
     }
 
@@ -46,7 +49,7 @@
         unsigned long start = clock + delay*1000;
         unsigned long end = maxRuntime >= Math::POS_INFINITY ?
             0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
-        JobEntry entry = {job, listener, ticket, priority, priority, start, end, 0.0f, false};
+        JobEntry entry = {job, listener, ticket, priority, priority, start, end, 0.0f, false, false};
         mJobQueue.push_back(entry);
         return ticket;
     }
@@ -70,8 +73,21 @@
                 entry.job->getTimeSource());
             Time clock = ts->getClock();
 
-            if (entry.start <= clock && clock < entry.end)
+            if (entry.markedToRemove)
             {
+                // Notify listener, the job was removed
+                if (entry.listener != NULL)
+                {
+                    entry.listener->jobRemoved(entry.ticket);
+                }
+
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+            else if (entry.start <= clock && clock < entry.end)
+            {
                 // Is the token threshold reached?
                 if (entry.tokens >= mTokenThreshold)
                 {
@@ -135,6 +151,10 @@
                         entry.listener->jobDiscarded(entry.ticket);
                     }
                 }
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
             }
         }
 
@@ -148,8 +168,8 @@
             std::bind2nd(FindJobEntryByTicket(), ticket));
         if (it != mJobQueue.end())
         {
-            mRemovedJobs.push_back(*it);
-            if (it->listener != NULL) it->listener->jobRemoved(ticket);
+            //mRemovedJobs.push_back(*it);
+            (*it).markedToRemove = true;
         }
         else
         {



From melven at mail.berlios.de  Mon Aug 27 14:03:10 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 14:03:10 +0200
Subject: [Dsa-hl-svn] r3760 - rl/trunk/engine/rules/src
Message-ID: <200708271203.l7RC3Acq011822@sheep.berlios.de>

Author: melven
Date: 2007-08-27 14:03:03 +0200 (Mon, 27 Aug 2007)
New Revision: 3760

Modified:
   rl/trunk/engine/rules/src/Container.cpp
Log:
removed bugs from addItem with a given position

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-27 12:01:08 UTC (rev 3759)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-27 12:03:03 UTC (rev 3760)
@@ -110,10 +110,11 @@
 
 		if (pos != NO_SPACE_FOR_ITEM)
 		{
-			mItemPositions[item] = pos;
+            item->removeOldState();
+
+            mItemPositions[item] = pos;
 			mItems.insert(item);
 
-            item->removeOldState();
             item->setParentContainer(this);
             if(mOwner)
                 item->setOwner(mOwner);
@@ -178,11 +179,13 @@
 					+ Ogre::StringConverter::toString(y),
                     "Container::canPlaceAt()");
 
-                if (getItemAt(x, y) != item)
-                {
-                    // Siehe nach, ob ein anderes Item im Weg ist
-					return false;
-				}
+                Item* itemFound = getItemAt(x, y);
+                if( itemFound == NULL )
+                    continue;
+                if( itemFound == item )
+                    continue;
+
+				return false;
 			}
 		}
 



From melven at mail.berlios.de  Mon Aug 27 18:50:11 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 18:50:11 +0200
Subject: [Dsa-hl-svn] r3761 - rl/trunk/engine/ui/src
Message-ID: <200708271650.l7RGoBvK026622@sheep.berlios.de>

Author: melven
Date: 2007-08-27 18:50:03 +0200 (Mon, 27 Aug 2007)
New Revision: 3761

Modified:
   rl/trunk/engine/ui/src/Console.cpp
Log:
fixed bug using xbutton (hide and not destroy!)

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2007-08-27 12:03:03 UTC (rev 3760)
+++ rl/trunk/engine/ui/src/Console.cpp	2007-08-27 16:50:03 UTC (rev 3761)
@@ -48,7 +48,8 @@
 			boost::bind(&Console::handleKeyDown, this, _1));
 		mDisplay->moveToFront();
 
-		bindDestroyWindowToXButton();
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+            boost::bind(&Console::hideWindow, this));
 
 		mHistory.clear();
         setVisible(false);



From melven at mail.berlios.de  Mon Aug 27 19:05:39 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 19:05:39 +0200
Subject: [Dsa-hl-svn] r3762 - in rl/trunk/engine/ui: include src
Message-ID: <200708271705.l7RH5d2R007177@sheep.berlios.de>

Author: melven
Date: 2007-08-27 19:05:10 +0200 (Mon, 27 Aug 2007)
New Revision: 3762

Modified:
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/include/WindowFadeJob.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/ControlState.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
-ItemDragContainers are destroyed correctly (through WindowFadeJob)
-Pressing left control in the inventorywindow shows all possible world-ItemSet
-items can be placed at mouse position in containers (sorting possible)
-removed bugs in ControlStates (processing key.events)
-in the inventorywindow, world-items fade out and hide after some seconds
-changed windowmanager (bug?) to enable abstractwindows to process both key- and mouse-events
-WindowsFadeJob can handle different window types with different behaviour(AbstractWindow, CEGUI::Window, ItemDragContainer)

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-27 17:05:10 UTC (rev 3762)
@@ -20,6 +20,7 @@
 #include "UiPrerequisites.h"
 #include "AbstractWindow.h"
 #include "InventoryWindow.h"
+#include "ItemDragContainer.h"
 
 namespace rl {
 
@@ -28,17 +29,22 @@
 	
     /// this class is intended to be used with a inventorywindow
 	class _RlUiExport ContainerContentWindow :
-		public AbstractWindow
+		public AbstractWindow,
+        public ItemDragContainerDestroyListener
 	{
 	public:
 		ContainerContentWindow(Container* container, InventoryWindow* parent);
 
         void setVisible(bool visible, bool destroyAfterHide = false);
 
+        void notifyItemDragContainerDestroyed(ItemDragContainer* cont);
+
 	private:
 		CEGUI::Window* mContentWindow;
 		Container* mContainer;
         InventoryWindow* mInventoryWindow;
+        typedef std::map<Item*, ItemDragContainer*> ItemDragContainerMap;
+        ItemDragContainerMap mItemDragContainerMap;
 
 		static int sItemCount;
 
@@ -48,7 +54,8 @@
         bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
         bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
 		void initializeContent();
-		CEGUI::Window* createItemWindow(Item* item);
+		ItemDragContainer* createItemWindow(Item* item);
+        ItemDragContainer* getItemWindow(Item* item);
 	};
 }
 

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-08-27 17:05:10 UTC (rev 3762)
@@ -22,6 +22,7 @@
 #include <OgreRectangle.h>
 
 #include "AbstractWindow.h"
+#include "ItemDragContainer.h"
 
 namespace rl {
 
@@ -30,10 +31,10 @@
     class ContainerContentWindow;
     class Inventory;
 	class Item;
-	class ItemDragContainer;
 	class RaySelector;
 
-	class _RlUiExport InventoryWindow : public AbstractWindow
+	class _RlUiExport InventoryWindow : public AbstractWindow,
+        public ItemDragContainerDestroyListener
 	{
 	public:
 		static const Ogre::String SLOTNAME;
@@ -48,6 +49,8 @@
 
         bool showPossibleSlots(const Item* item);
 
+        void notifyItemDragContainerDestroyed(ItemDragContainer* cont);
+
     private:
 		typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
         typedef std::map<CeGuiString, CEGUI::Window*> SlotWindowMap;
@@ -58,20 +61,22 @@
 		DndContainerMap mWorldDragContainers;
 		DndContainerMap mSlotDragContainers;
 		RaySelector* mMouseSelector;
+        bool mShowAllWorldItems;
 
 		void createSlotWindows(Inventory* inventory);
         void initInventoryWindow(Inventory* inventory);
 
 		ItemDragContainer* createItemDragContainer(Item* item, bool showdescription, const CeGuiString& containerName = "");
-        //ItemDragContainer* getItemDragContainer(Item* item, bool description);
+        ItemDragContainer* getItemDragContainer(const Item* item, bool description);
         CeGuiString getDragContainerNameFromItem(const Item* item, bool description);
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
         bool handleItemEntersSlot(const CEGUI::EventArgs& evt);
         bool handleItemLeavesSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
+        bool handleItemDragEnded(const Item* item, bool description);
+        bool handleItemDragStarted(const Item* item, bool description);
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
-		//bool handleKeys(const CEGUI::EventArgs& evt, bool down);
-		bool destroyDragContainer(ItemDragContainer* cont);
+		bool handleKeys(const CEGUI::EventArgs& evt, bool down);
 
 		Ogre::Rectangle getCeGuiRectFromWorldAABB(
 			CameraObject* camera,

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2007-08-27 17:05:10 UTC (rev 3762)
@@ -26,6 +26,7 @@
 	class Inventory;
 	class Item;
 	class Slot;
+    class ItemDragContainerDestroyListener;
 
 	class ItemDragContainer : public CEGUI::DragContainer
 	{
@@ -45,6 +46,12 @@
 		bool _handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
 		bool _handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
 
+        bool fadeOutAndHide(Ogre::Real delay);
+        bool stopFadeOut();
+
+        void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+
+        void setDestroyListener(ItemDragContainerDestroyListener *listener) {mDestroyListener = listener;}
 	protected:
 		CEGUI::Window* mContentWindow;
 		
@@ -56,8 +63,17 @@
 		Container* mParentContainer;
 		CeGuiString mParentSlot;
 		Inventory* mInventory;
+        unsigned long mHideAndDestroyJobTicket;
+        bool mMarkedToHideAndDestroy;
+        ItemDragContainerDestroyListener *mDestroyListener;
 	};
 
+    class ItemDragContainerDestroyListener
+    {
+    public:
+        virtual void notifyItemDragContainerDestroyed(ItemDragContainer* cont) = 0;
+    };
+
 } // namespace rl
 
 #endif //__ItemDragContainer_H__

Modified: rl/trunk/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFadeJob.h	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/include/WindowFadeJob.h	2007-08-27 17:05:10 UTC (rev 3762)
@@ -22,9 +22,15 @@
 
 #include "Job.h"
 
+namespace CEGUI
+{
+    class Window;
+}
+
 namespace rl {
 
     class AbstractWindow;
+    class ItemDragContainer;
 
     class WindowFadeJob : public Job
     {
@@ -32,13 +38,19 @@
         typedef enum {FADE_IN, FADE_OUT, FADE_OUT_AND_DESTROY} Mode;
 
         WindowFadeJob(AbstractWindow* window, Mode mode,
-            Ogre::Real targetAlpha, Ogre::Real changeRate = 4.0f);
+            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
+        WindowFadeJob::WindowFadeJob(CEGUI::Window* window, Mode mode, 
+            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
+        WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, 
+            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
 
         virtual bool execute(Ogre::Real time);
         virtual void discard();
 
     protected:
-        AbstractWindow* mWindow;
+        AbstractWindow* mAbstractWindow;
+        CEGUI::Window* mCEGUIWindow;
+        ItemDragContainer* mItemDragContainer;
         Mode mMode;
         Ogre::Real mChangeRate;
         Ogre::Real mCurrentAlpha;

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -152,14 +152,28 @@
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
-            if( item->getParentContainer() == mContainer )
-                return false;
 
-			if( mContainer->addItem(item) )
+            int x = evtArgs.dragDropItem->getPixelRect().d_left;
+            int y = evtArgs.dragDropItem->getPixelRect().d_top;
+            x -= mContentWindow->getPixelRect().d_left;
+            y -= mContentWindow->getPixelRect().d_top;
+
+            // ?bergangspixel
+            x += 14;
+            y += 14;
+
+            x = x / 30;
+            y = y / 30;
+
+			if( mContainer->addItem(item,IntPair(x,y)) )
             {
-			    dragcont->getParent()->removeChildWindow(dragcont);
+                if( dragcont != getItemWindow(item) )
+                {
+                    dragcont->destroyWindow();
+                    dragcont = createItemWindow(item);
+                    mContentWindow->addChildWindow(dragcont);
+                }
 			    std::pair<unsigned int, unsigned int> pos = mContainer->getItemPosition(item);
-			    mContentWindow->addChildWindow(dragcont);
 			    dragcont->setPosition(
 				    UVector2(
 					    cegui_absdim(pos.first*30),
@@ -174,7 +188,7 @@
 		return false;
 	}
 
-	Window* ContainerContentWindow::createItemWindow(Item* item)
+	ItemDragContainer* ContainerContentWindow::createItemWindow(Item* item)
 	{
         CeGuiString icon = item->getImageName();
 
@@ -183,6 +197,8 @@
 			icon = ItemDragContainer::ICON_UNKNOWN_ITEM;
 		}
 
+        
+
    //     LOG_MESSAGE("IW", icon);
    //     Window* itemWindow =
 	  //      CEGUI::WindowManager::getSingletonPtr()->createWindow(
@@ -192,12 +208,22 @@
    //     itemWindow->setProperty("Image", icon);
    //     itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
    //     itemWindow->setSize(UVector2(cegui_reldim(1), cegui_reldim(1)));
+
+        ItemDragContainer* itemhandler = getItemWindow(item);
+        if( itemhandler )
+            return itemhandler;
+
+
+
+
 		CeGuiString dragContainerName =
 			mWindow->getName() +  "/item/"
 			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 
-		ItemDragContainer* itemhandler = new ItemIconDragContainer(item,
+		itemhandler = new ItemIconDragContainer(item,
 			dragContainerName);
+        itemhandler->setDestroyListener(this);
+        mItemDragContainerMap.insert(std::make_pair(item, itemhandler));
 		itemhandler->setItemParent(mContainer);
 		itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
         if( mInventoryWindow )
@@ -238,4 +264,28 @@
             return false;
         }
     }
+
+    ItemDragContainer* ContainerContentWindow::getItemWindow(Item* item)
+    {
+        ItemDragContainerMap::iterator iter = mItemDragContainerMap.find(item);
+        if( iter != mItemDragContainerMap.end() )
+            return iter->second;
+
+        return NULL;
+    }
+
+    void ContainerContentWindow::notifyItemDragContainerDestroyed(ItemDragContainer* cont)
+    {
+        ItemDragContainerMap::iterator iter = mItemDragContainerMap.begin();
+        for( ; iter != mItemDragContainerMap.end(); iter++ )
+        {
+            if( iter->second == cont )
+            {
+                mItemDragContainerMap.erase(iter);
+                return;
+            }
+        }
+
+        LOG_ERROR(Logger::UI, "Could not find ItemDragContainer in InventoryWindow::notifyItemDragContainerDestroyed!");
+    }
 }

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -174,7 +174,7 @@
         if (sendKeyToCeGui(evt))
         {
             CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyUp(evt.key);
+            cegui.injectKeyDown(evt.key);
             return true;
         }
         else
@@ -190,7 +190,7 @@
         if (sendKeyToCeGui(evt))
         {
             CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyDown(evt.key);
+            cegui.injectKeyUp(evt.key);
             cegui.injectChar(im->getKeyChar(evt.key, im->getModifierCode()));
             return true;
         }
@@ -238,7 +238,8 @@
             || evt.key == OIS::KC_LEFT || evt.key == OIS::KC_RIGHT
             || evt.key == OIS::KC_BACK || evt.key == OIS::KC_DELETE
             || evt.key == OIS::KC_UP   || evt.key == OIS::KC_DOWN
-            || evt.key == OIS::KC_RMENU)
+            || evt.key == OIS::KC_RMENU
+            || evt.key == OIS::KC_LCONTROL)
         {
             return true;
         }

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -219,6 +219,12 @@
 
     bool FreeflightControlState::keyPressed(const OIS::KeyEvent& evt)
 	{
+        if( ControlState::keyPressed(evt) )
+        {
+            mCurrentMovementState = MOVE_NONE;
+            return true;
+        }
+
         int movement = mCommandMapper->getMovement(evt.key);
 
 		if (movement != MOVE_NONE)
@@ -232,6 +238,12 @@
 
     bool FreeflightControlState::keyReleased(const OIS::KeyEvent& evt)
 	{
+        if( ControlState::keyPressed(evt) )
+        {
+            mCurrentMovementState = MOVE_NONE;
+            return true;
+        }
+
         int movement = mCommandMapper->getMovement(evt.key);
 
 		if (movement != MOVE_NONE)

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -45,7 +45,7 @@
 	const Ogre::String InventoryWindow::SLOTNAME = "slotname";
 
     InventoryWindow::InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory)
-        : AbstractWindow(inventoryWindow, AbstractWindow::WIT_MOUSE_INPUT)
+        : AbstractWindow(inventoryWindow, AbstractWindow::WIT_MOUSE_INPUT | AbstractWindow::WIT_KEYBOARD_INPUT), mShowAllWorldItems(false)
     {
         mInventory = inventory;
 
@@ -140,7 +140,6 @@
 				if (itemWindow != NULL)
 				{
 					slotWindow->addChildWindow(itemWindow);
-                    slotWindow->setTooltipText(item->getName());
 				}
             }
         }
@@ -150,13 +149,23 @@
 			boost::bind(&InventoryWindow::handleItemDroppedOnWorld, this, _1));
 		mWorldBackground->subscribeEvent(Window::EventMouseMove,
 			boost::bind(&InventoryWindow::handleMouseMovedInWorld, this, _1));
-		//mWorldBackground->subscribeEvent(Window::EventKeyDown,
-		//	boost::bind(&InventoryWindow::handleKeys, this, _1, true));
-		//mWorldBackground->subscribeEvent(Window::EventKeyUp,
-		//	boost::bind(&InventoryWindow::handleKeys, this, _1, false));
+
+        // be sure we get all key-events:
+        Window* invWnd = getWindow("InventoryWindow");
+        //invWnd->setDistributesCapturedInputs(false);
+		invWnd->subscribeEvent(Window::EventKeyDown,
+			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
+		invWnd->subscribeEvent(Window::EventKeyUp,
+			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
+        //mWorldBackground->setDistributesCapturedInputs(false);
+		mWorldBackground->subscribeEvent(Window::EventKeyDown,
+			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
+		mWorldBackground->subscribeEvent(Window::EventKeyUp,
+			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
+        //invWnd->activate();
     }
-/*
-    ItemDragContainer* InventoryWindow::getItemDragContainer(Item* item, bool description)
+
+    ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
     {
 		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
 		ItemDragContainer* itemhandler = NULL;
@@ -174,7 +183,6 @@
 
         return NULL;
     }
-*/
 
     CeGuiString InventoryWindow::getDragContainerNameFromItem(const Item* item, bool description)
     {
@@ -195,15 +203,17 @@
 		DndContainerMap::iterator itS = mSlotDragContainers.find(dragContainerName);
 		if (itW != mWorldDragContainers.end() || itS != mSlotDragContainers.end())
 		{
-			//itemhandler = it->second;
-			return NULL; ///@todo just a test
+			return NULL;
 		}
 		else
 		{
 			if (showdescription)
 				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
 			else
+            {
 				itemhandler = new ItemIconDragContainer(item, dragContainerName);
+                itemhandler->setTooltipText(item->getName());
+            }
 
 			if (slotName != "")
 			{
@@ -215,23 +225,49 @@
 				mWorldDragContainers[dragContainerName] = itemhandler;
 			}
 
-			//Window* itemWindow = itemhandler->getContentWindow();
+            itemhandler->setDestroyListener(this);
 
-			//itemWindow->subscribeEvent(
-			//	Window::EventMouseLeaves,
-			//	boost::bind(&InventoryWindow::destroyDragContainer, this, itemhandler));
-
-			itemhandler->setRiseOnClickEnabled(true);
+  			itemhandler->setRiseOnClickEnabled(true);
 			itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
             itemhandler->subscribeEvent(DragContainer::EventDragStarted,
-                boost::bind(&rl::InventoryWindow::showPossibleSlots, this, item));
+                boost::bind(&rl::InventoryWindow::handleItemDragStarted, this, item, showdescription));
             itemhandler->subscribeEvent(DragContainer::EventDragEnded,
-                boost::bind(&InventoryWindow::showPossibleSlots, this, (Item*)NULL));
+                boost::bind(&InventoryWindow::handleItemDragEnded, this, item, showdescription));
 		}
 
 		return itemhandler;
 	}
 
+    bool InventoryWindow::handleItemDragEnded(const Item* item, bool showdescription)
+    {
+        showPossibleSlots(NULL);
+
+        if( showdescription && !mShowAllWorldItems) // this is a world item
+        {
+            // fade out and destroy
+            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
+            if( cont )
+                cont->fadeOutAndHide(2.0f);
+        }
+
+        return true;
+    }
+
+    bool InventoryWindow::handleItemDragStarted(const Item* item, bool showdescription)
+    {
+        showPossibleSlots(item);
+
+        if( showdescription && !mShowAllWorldItems) // this is a world item
+        {
+            // stop fade out and destroy
+            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
+            if( cont )
+                cont->stopFadeOut();
+        }
+
+        return true;
+    }
+
 	bool InventoryWindow::handleItemDroppedOnSlot(const EventArgs& evt)
 	{
 		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
@@ -247,12 +283,10 @@
 			{
 				if (dragcont->getItemParentContainer() != NULL)
 				{
-					//dragcont->getItemParentContainer()->removeItem(item);
 					dragcont->getParent()->removeChildWindow(dragcont);
 				}
 				else if (dragcont->getItemParentSlot() != "")
 				{
-					//dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
 					dragcont->getParent()->removeChildWindow(dragcont);
 				}
 
@@ -260,7 +294,7 @@
 
 				if (newCont)
 				{
-					destroyDragContainer(dragcont);
+                    dragcont->destroyWindow();
 				}
 				else
 				{
@@ -372,8 +406,9 @@
 				dragcont->getPixelRect().d_top / getRoot()->getPixelSize().d_height,
 				-1);
 
-			destroyDragContainer(dragcont);
 
+            dragcont->destroyWindow();
+
 			Ogre::Vector3 targetPosWorldSpace =
 				mInventory->getOwner()->getPosition()
 				+ mInventory->getOwner()->getOrientation()
@@ -393,6 +428,9 @@
 
 	bool InventoryWindow::handleMouseMovedInWorld(const EventArgs& evt)
 	{
+        if( mShowAllWorldItems )
+            return true;
+
 		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
 
 		Actor* cameraActor = ActorManager::getSingleton().getActor("DefaultCamera");
@@ -422,13 +460,15 @@
 				LOG_MESSAGE(Logger::UI,
 					"Selected " + (*it)->getDescription());
 
-				ItemDragContainer* cont =
-					createItemDragContainer(static_cast<Item*>(*it), true);
+                ItemDragContainer* cont = getItemDragContainer(static_cast<Item*>(*it), true);
+
+                if( !cont )
+                {
+					cont = createItemDragContainer(static_cast<Item*>(*it), true);
+                    mWorldBackground->addChildWindow(cont);
+                }
 				if (cont)
 				{
-					mWorldBackground->addChildWindow(cont);
-					cont->setVisible(true);
-
 					Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
 							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
 					UVector2 posCont = UVector2(
@@ -436,58 +476,72 @@
 							UDim((aabb.top+aabb.bottom)/2.0, 0));
 					posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 					cont->setPosition(posCont);
+					cont->setVisible(true);
+
+                    cont->fadeOutAndHide(2.0f);
 				}
 			}
 		}
 
-		//camera->getPointOnScreen(
-
 		return true;
 	}
-/*
+
 	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &evt, bool down)
 	{
 		const KeyEventArgs& kevt = static_cast<const KeyEventArgs&>(evt);
-		if (kevt.scancode == CEGUI::Key::Tab)
+        if (kevt.scancode == CEGUI::Key::LeftControl)
 		{
 			if (down)
 			{
+                mShowAllWorldItems = true;
+
 				Actor* cameraActor = ActorManager::getSingleton().getActor("DefaultCamera");
 				CameraObject* camera = static_cast<CameraObject*>(cameraActor->getControlledObject());
 
 				HalfSphereSelector sel(QUERYFLAG_ITEM);
 				sel.setPosition(cameraActor->getWorldPosition());
 				sel.setOrientation(cameraActor->getWorldOrientation());
-				sel.setRadius(2.0);
+				sel.setRadius(10.0);
 
 				sel.updateSelection();
 				Selector::GameObjectVector v = sel.getAllSelectedObjects();
 				for (Selector::GameObjectVector::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
-					ItemDragContainer* cont =
-						createItemDragContainer(static_cast<Item*>(*it), true);
 
-					if (cont)
-					{
-						mWorldBackground->addChildWindow(cont);
+				    LOG_MESSAGE(Logger::UI,
+					    "Selected " + (*it)->getDescription());
 
-						Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
-							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
-						UVector2 posCont = UVector2(
-							UDim((aabb.left+aabb.right)/2.0, 0),
-							UDim((aabb.top+aabb.bottom)/2.0, 0));
-						posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
-						cont->setPosition(posCont);
-					}
+                    ItemDragContainer* cont = getItemDragContainer(static_cast<Item*>(*it), true);
+
+                    if( !cont )
+                    {
+					    cont = createItemDragContainer(static_cast<Item*>(*it), true);
+                        mWorldBackground->addChildWindow(cont);
+                    }
+				    if (cont)
+				    {
+					    Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
+							    (*it)->getActor()->_getSceneNode()->_getWorldAABB());
+					    UVector2 posCont = UVector2(
+							    UDim((aabb.left+aabb.right)/2.0, 0),
+							    UDim((aabb.top+aabb.bottom)/2.0, 0));
+					    posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
+					    cont->setPosition(posCont);
+					    cont->setVisible(true);
+                        cont->moveToFront();
+                        cont->stopFadeOut();
+				    }
 				}
 			}
 			else
 			{
-				while (!mWorldDragContainers.empty())
-				{
-					destroyDragContainer(mWorldDragContainers.begin()->second);
-				}
+                mShowAllWorldItems = false;
+                DndContainerMap::iterator iter = mWorldDragContainers.begin();
+                for( ; iter != mWorldDragContainers.end(); iter++ )
+                {
+                    iter->second->fadeOutAndHide(0.0f);
+                }
 			}
 
 			return true;
@@ -495,21 +549,6 @@
 
 		return false;
 	}
-*/
-	bool InventoryWindow::destroyDragContainer(rl::ItemDragContainer* cont)
-	{
-		cont->hide();
-		cont->removeAllEvents();
-		if (cont->getParent())
-		{
-			cont->getParent()->removeChildWindow(cont);
-		}
-		mWorldDragContainers.erase(cont->getName());
-		mSlotDragContainers.erase(cont->getName());
-		CEGUI::WindowManager::getSingleton().destroyWindow(cont->getContentWindow());
-		
-		return true;
-	}
 
 	Ogre::Rectangle InventoryWindow::getCeGuiRectFromWorldAABB(
 		CameraObject* camera,
@@ -603,4 +642,29 @@
         }
         return true;
     }
+
+    void InventoryWindow::notifyItemDragContainerDestroyed(ItemDragContainer* cont)
+    {
+        DndContainerMap::iterator iter = mWorldDragContainers.begin();
+        for( ; iter != mWorldDragContainers.end(); iter++)
+        {
+            if( iter->second == cont )
+            {
+                mWorldDragContainers.erase(iter);
+                return;
+            }
+        }
+
+        iter = mSlotDragContainers.begin();
+        for( ; iter != mSlotDragContainers.end(); iter++)
+        {
+            if( iter->second == cont )
+            {
+                mSlotDragContainers.erase(iter);
+                return;
+            }
+        }
+
+        LOG_ERROR(Logger::UI, "Could not find ItemDragContainer in InventoryWindow::notifyItemDragContainerDestroyed!");
+    }
 }

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -18,12 +18,15 @@
 #include "ItemDragContainer.h"
 
 #include <CEGUIWindowManager.h>
+#include <CEGUIEventSet.h>
 
 #include "AbstractWindow.h"
 #include "Creature.h"
 #include "Inventory.h"
 #include "Item.h"
+#include "JobScheduler.h"
 #include "WindowFactory.h"
+#include "WindowFadeJob.h"
 
 namespace rl {
 	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
@@ -34,18 +37,50 @@
 		mParentContainer(NULL),
 		mParentSlot(""),
 		mContentWindow(NULL),
-        mInventory(NULL)
+        mInventory(NULL),
+        mMarkedToHideAndDestroy(false),
+        mDestroyListener(NULL)
 	{
 	}
 
 	ItemDragContainer::~ItemDragContainer()
 	{
+        if(mDestroyListener)
+            mDestroyListener->notifyItemDragContainerDestroyed(this);
+        stopFadeOut();
+
+        hide();
+		if (getParent())
+		{
+			getParent()->removeChildWindow(this);
+		}
 		removeAllEvents();
 		mContentWindow->removeAllEvents();
 		removeChildWindow(mContentWindow);
 		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
+        CEGUI::WindowManager::getSingleton().destroyWindow(this);
 	}
 
+    void ItemDragContainer::destroyWindow()
+    {
+        if(mDestroyListener)
+            mDestroyListener->notifyItemDragContainerDestroyed(this);
+        mDestroyListener = NULL;
+        stopFadeOut();
+
+        hide();
+		if (getParent())
+		{
+			getParent()->removeChildWindow(this);
+		}
+
+        JobScheduler::getSingleton().addJob(
+            new WindowFadeJob(this,
+            WindowFadeJob::FADE_OUT_AND_DESTROY, 1.0f, 9999999999999.9f),
+            JobScheduler::JP_NORMAL,
+            0.0f);
+    }
+
 	void ItemDragContainer::setItemParent(Container* container)
 	{
 		mParentContainer = container;
@@ -119,5 +154,29 @@
 		}
 	}
 
+    bool ItemDragContainer::fadeOutAndHide(Ogre::Real delay)
+    {
+        stopFadeOut();
 
+        mHideAndDestroyJobTicket =
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    WindowFadeJob::FADE_OUT, 1.0f, 0.5f),
+                    JobScheduler::JP_NORMAL,
+                    delay);
+        mMarkedToHideAndDestroy = true;
+        return true;
+    }
+
+    bool ItemDragContainer::stopFadeOut()
+    {
+        if( mMarkedToHideAndDestroy )
+        {
+            JobScheduler::getSingleton().removeJob(mHideAndDestroyJobTicket);
+        }
+        mMarkedToHideAndDestroy = false;
+        setAlpha(1.0f);
+
+        return true;
+    }
 }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -1265,7 +1265,12 @@
     //------------------------------------------------------------------------
     bool MovementControlState::keyPressed(const OIS::KeyEvent& evt)
     {
-        if (ControlState::keyPressed(evt)) return true;
+        if( ControlState::keyPressed(evt) )
+        {
+            mCharacterState.mCurrentMovementState = MOVE_NONE |
+                (mCharacterState.mCurrentMovementState & MOVE_RUN_LOCK);
+            return true;
+        }
 
         int movement = mCommandMapper->getMovement(evt.key);
 
@@ -1286,9 +1291,11 @@
     bool MovementControlState::keyReleased(const OIS::KeyEvent& evt)
     {
         // CEGUI is handled by base class, so hand it down if necessary.
-        if (sendKeyToCeGui(evt))
+        if( ControlState::keyReleased(evt) )
         {
-            return ControlState::keyReleased(evt);
+            mCharacterState.mCurrentMovementState = MOVE_NONE |
+                (mCharacterState.mCurrentMovementState & MOVE_RUN_LOCK);
+            return true;
         }
 
         int movement = mCommandMapper->getMovement(evt.key);

Modified: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -20,6 +20,8 @@
 #include "AbstractWindow.h"
 #include "CeGuiHelper.h"
 #include "WindowManager.h"
+#include <CEGUIWindowManager.h>
+#include "ItemDragContainer.h"
 
 using namespace CEGUI;
 using namespace Ogre;
@@ -28,17 +30,49 @@
 {
     WindowFadeJob::WindowFadeJob(AbstractWindow* window, Mode mode, Real targetAlpha, Real changeRate)
         : Job(true, true),
-        mWindow(window),
+        mAbstractWindow(window),
+        mCEGUIWindow(window->getWindow()),
+        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
         mTargetAlpha(mode == FADE_IN ? targetAlpha : 0.0f)
     {
         // Ensure visibility. This is independant of whether we're fading in or out.
-        mWindow->getWindow()->setVisible(true);
-        mWindow->getWindow()->setAlpha(mCurrentAlpha);
+        mCEGUIWindow->setVisible(true);
+        mCEGUIWindow->setAlpha(mCurrentAlpha);
     }
 
+    WindowFadeJob::WindowFadeJob(CEGUI::Window* window, Mode mode, Real targetAlpha, Real changeRate)
+        : Job(true, true),
+        mAbstractWindow(NULL),
+        mCEGUIWindow(window),
+        mItemDragContainer(NULL),
+        mMode(mode),
+        mChangeRate(changeRate),
+        mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
+        mTargetAlpha(mode == FADE_IN ? targetAlpha : 0.0f)
+    {
+        // Ensure visibility. This is independant of whether we're fading in or out.
+        mCEGUIWindow->setVisible(true);
+        mCEGUIWindow->setAlpha(mCurrentAlpha);
+    }
+
+    WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, Real targetAlpha, Real changeRate)
+        : Job(true, true),
+        mAbstractWindow(NULL),
+        mCEGUIWindow(window),
+        mItemDragContainer(window),
+        mMode(mode),
+        mChangeRate(changeRate),
+        mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
+        mTargetAlpha(mode == FADE_IN ? targetAlpha : 0.0f)
+    {
+        // Ensure visibility. This is independant of whether we're fading in or out.
+        mCEGUIWindow->setVisible(true);
+        mCEGUIWindow->setAlpha(mCurrentAlpha);
+    }
+
     bool WindowFadeJob::execute(Real time)
     {
         mCurrentAlpha += time * mChangeRate * Math::Sign(mTargetAlpha - mCurrentAlpha);
@@ -50,18 +84,23 @@
             discard();
             return true;
         }
-        mWindow->getWindow()->setAlpha(mCurrentAlpha);
+        mCEGUIWindow->setAlpha(mCurrentAlpha);
 
         return false;
     }
 
     void WindowFadeJob::discard()
     {
-        mWindow->getWindow()->setAlpha(mTargetAlpha);
-        mWindow->getWindow()->setVisible(mMode == FADE_IN ? true : false);
+        mCEGUIWindow->setAlpha(mTargetAlpha);
+        mCEGUIWindow->setVisible(mMode == FADE_IN ? true : false);
         if (mMode == FADE_OUT_AND_DESTROY)
         {
-            WindowManager::getSingleton().destroyWindow(mWindow);
+            if( mAbstractWindow )
+                WindowManager::getSingleton().destroyWindow(mAbstractWindow);
+            else if(mItemDragContainer)
+                delete mItemDragContainer;
+            else
+                CEGUI::WindowManager::getSingleton().destroyWindow(mCEGUIWindow);
         }
     }
 }

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-08-27 16:50:03 UTC (rev 3761)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-08-27 17:05:10 UTC (rev 3762)
@@ -97,7 +97,7 @@
         {
             mNumActiveWindowsMouseInput += isVisible ? +1 : -1;
         }
-        else if (window->getWindowInputType() & AbstractWindow::WIT_KEYBOARD_INPUT)
+        if (window->getWindowInputType() & AbstractWindow::WIT_KEYBOARD_INPUT)
         {
             mNumActiveWindowsKeyboardInput += isVisible ? +1 : -1;
         }



From melven at mail.berlios.de  Mon Aug 27 20:48:24 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 20:48:24 +0200
Subject: [Dsa-hl-svn] r3763 - in rl/trunk/engine: rules/include rules/src
	ui/include ui/src
Message-ID: <200708271848.l7RImODG021620@sheep.berlios.de>

Author: melven
Date: 2007-08-27 20:47:56 +0200 (Mon, 27 Aug 2007)
New Revision: 3763

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/ui/include/CommandMapper.h
   rl/trunk/engine/ui/include/ControlState.h
   rl/trunk/engine/ui/src/CommandMapper.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
-fixed controlstates (some actions didn't work any more)
-InventoryWindow calls globalactions (i can close the window)
-added creature::canReachItem (tells the InventoryWindow if an item is
near enough to take it)

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-27 18:47:56 UTC (rev 3763)
@@ -684,6 +684,14 @@
              void setAlignment(Alignment);
             Alignment getAlignment() const;
 
+
+
+            /**
+             * Gibt an, ob die Creature mit den H?nden an den Gegenstand herankommt,
+             * ihn also ber?hren kann, mit ihm interagieren etc
+            **/
+            virtual bool canReachItem(const Item* item);
+
         protected:
            /**
              *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
@@ -709,6 +717,7 @@
 
 
 
+
         private:
 ///////////////////////////////////////////////////////////////////////////////
 // Typedefs

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-27 18:47:56 UTC (rev 3763)
@@ -24,6 +24,7 @@
 #include "EffectManager.h"
 #include "Exception.h"
 #include "Inventory.h"
+#include "Item.h"
 #include "Kampftechnik.h"
 #include "MeshObject.h"
 #include "StateSet.h"
@@ -1134,4 +1135,9 @@
 
         return ps;
     }
+
+    bool Creature::canReachItem(const Item* item)
+    {
+        return (item->getPosition() - getPosition()).length() <= 3.0f;
+    }
 }

Modified: rl/trunk/engine/ui/include/CommandMapper.h
===================================================================
--- rl/trunk/engine/ui/include/CommandMapper.h	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/include/CommandMapper.h	2007-08-27 18:47:56 UTC (rev 3763)
@@ -56,8 +56,8 @@
         const MovementState getMovement(int keycode) const;
 
         /// Get the action name assigned to the key.
-        const CeGuiString& getGlobalAction(int keyCodeOrMouseButton);
-        const CeGuiString& getControlStateAction(int keyCodeOrMouseButton, ControlStateType);
+        const CeGuiString& getGlobalAction(int keyCodeOrMouseButton) const;
+        const CeGuiString& getControlStateAction(int keyCodeOrMouseButton, ControlStateType) const;
 
     private:
 

Modified: rl/trunk/engine/ui/include/ControlState.h
===================================================================
--- rl/trunk/engine/ui/include/ControlState.h	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/include/ControlState.h	2007-08-27 18:47:56 UTC (rev 3763)
@@ -58,9 +58,12 @@
         virtual bool keyPressed(const OIS::KeyEvent& evt);
         virtual bool keyReleased(const OIS::KeyEvent& evt);
 
+        const CommandMapper* getCommandMapper() const {return mCommandMapper;}
+        ControlStateType getType() const { return mType;}
+
+        static bool startAction(const CeGuiString& actionName, Creature* character = NULL);
+
 	protected:
-		static bool startAction(const CeGuiString& actionName, Creature* character = NULL);
-
         /// Returns true, if there is at least one window open,
         /// that requires keyboard and/or mouse input. 
         bool isCeguiActive() const;

Modified: rl/trunk/engine/ui/src/CommandMapper.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapper.cpp	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/src/CommandMapper.cpp	2007-08-27 18:47:56 UTC (rev 3763)
@@ -45,7 +45,7 @@
     {
     }
 
-    const CeGuiString& CommandMapper::getGlobalAction(int keyCodeOrMouseButton)
+    const CeGuiString& CommandMapper::getGlobalAction(int keyCodeOrMouseButton) const
     {
         KeyAndMouseCommandMap::const_iterator command =
             mKeyGlobalActions.find(keyCodeOrMouseButton);
@@ -60,7 +60,7 @@
     }
 
     const CeGuiString& CommandMapper::getControlStateAction(int keyCodeOrMouseButton,
-        ControlStateType type)
+        ControlStateType type) const
     {
         const KeyAndMouseCommandMap& mapping = getControlStateMapping(type);
 

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-08-27 18:47:56 UTC (rev 3763)
@@ -219,10 +219,11 @@
 
     bool FreeflightControlState::keyPressed(const OIS::KeyEvent& evt)
 	{
-        if( ControlState::keyPressed(evt) )
+        // CEGUI is handled by base class, so hand it down if necessary.
+        if( sendKeyToCeGui(evt) )
         {
             mCurrentMovementState = MOVE_NONE;
-            return true;
+            return ControlState::keyPressed(evt);
         }
 
         int movement = mCommandMapper->getMovement(evt.key);
@@ -238,10 +239,11 @@
 
     bool FreeflightControlState::keyReleased(const OIS::KeyEvent& evt)
 	{
-        if( ControlState::keyPressed(evt) )
+        // CEGUI is handled by base class, so hand it down if necessary.
+        if( sendKeyToCeGui(evt) )
         {
             mCurrentMovementState = MOVE_NONE;
-            return true;
+            return ControlState::keyReleased(evt);
         }
 
         int movement = mCommandMapper->getMovement(evt.key);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 18:47:56 UTC (rev 3763)
@@ -29,6 +29,9 @@
 #include "Container.h"
 #include "ContainerContentWindow.h"
 #include "Creature.h"
+#include "ControlState.h"
+#include "CommandMapper.h"
+#include "InputManager.h"
 #include "Inventory.h"
 #include "Item.h"
 #include "ItemDescriptionDragContainer.h"
@@ -162,7 +165,7 @@
 			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
 		mWorldBackground->subscribeEvent(Window::EventKeyUp,
 			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
-        //invWnd->activate();
+        invWnd->activate();
     }
 
     ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
@@ -457,8 +460,8 @@
 			for (Selector::GameObjectVector::const_iterator it = objs.begin();
 				it != objs.end(); ++it)
 			{
-				LOG_MESSAGE(Logger::UI,
-					"Selected " + (*it)->getDescription());
+                if( !mInventory->getOwner()->canReachItem(static_cast<Item*>(*it)) )
+                    continue;
 
                 ItemDragContainer* cont = getItemDragContainer(static_cast<Item*>(*it), true);
 
@@ -508,10 +511,9 @@
 				for (Selector::GameObjectVector::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
+                    if( !mInventory->getOwner()->canReachItem(static_cast<Item*>(*it)) )
+                        continue;
 
-				    LOG_MESSAGE(Logger::UI,
-					    "Selected " + (*it)->getDescription());
-
                     ItemDragContainer* cont = getItemDragContainer(static_cast<Item*>(*it), true);
 
                     if( !cont )
@@ -546,6 +548,26 @@
 
 			return true;
 		}
+        else if(!down)
+        {
+            ///@todo das hier ueberpruefen!
+            CeGuiString action = 
+                InputManager::getSingleton().getCharacterController()
+                    ->getCommandMapper()->getControlStateAction(
+                    kevt.scancode,
+                    InputManager::getSingleton().getCharacterController()->getType()
+                    );
+            if( action == "" )
+            {
+                action = InputManager::getSingleton().getCharacterController()
+                            ->getCommandMapper()->getGlobalAction(kevt.scancode);
+            }
+            InputManager::getSingleton().getCharacterController()->startAction(
+                action,
+                mInventory->getOwner()
+                );
+            return true;
+        }
 
 		return false;
 	}

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-27 17:05:10 UTC (rev 3762)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-27 18:47:56 UTC (rev 3763)
@@ -1265,11 +1265,12 @@
     //------------------------------------------------------------------------
     bool MovementControlState::keyPressed(const OIS::KeyEvent& evt)
     {
-        if( ControlState::keyPressed(evt) )
+        // CEGUI is handled by base class, so hand it down if necessary.
+        if( sendKeyToCeGui(evt) )
         {
             mCharacterState.mCurrentMovementState = MOVE_NONE |
                 (mCharacterState.mCurrentMovementState & MOVE_RUN_LOCK);
-            return true;
+            return ControlState::keyPressed(evt);
         }
 
         int movement = mCommandMapper->getMovement(evt.key);
@@ -1291,11 +1292,11 @@
     bool MovementControlState::keyReleased(const OIS::KeyEvent& evt)
     {
         // CEGUI is handled by base class, so hand it down if necessary.
-        if( ControlState::keyReleased(evt) )
+        if( sendKeyToCeGui(evt) )
         {
             mCharacterState.mCurrentMovementState = MOVE_NONE |
                 (mCharacterState.mCurrentMovementState & MOVE_RUN_LOCK);
-            return true;
+            return ControlState::keyReleased(evt);
         }
 
         int movement = mCommandMapper->getMovement(evt.key);



From melven at mail.berlios.de  Mon Aug 27 21:47:51 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 27 Aug 2007 21:47:51 +0200
Subject: [Dsa-hl-svn] r3764 - in rl/trunk/engine/ui: include src
Message-ID: <200708271947.l7RJlpG3024750@sheep.berlios.de>

Author: melven
Date: 2007-08-27 21:47:38 +0200 (Mon, 27 Aug 2007)
New Revision: 3764

Modified:
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
removed error in inventorywindow::setvisible, which could cause an error in std::map, because of map change while iterating

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-27 18:47:56 UTC (rev 3763)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-08-27 19:47:38 UTC (rev 3764)
@@ -36,6 +36,7 @@
 		ContainerContentWindow(Container* container, InventoryWindow* parent);
 
         void setVisible(bool visible, bool destroyAfterHide = false);
+        void setVisible(bool visible, bool destroyAfterHide, bool dontNotifyInventory);
 
         void notifyItemDragContainerDestroyed(ItemDragContainer* cont);
 

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-27 18:47:56 UTC (rev 3763)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-08-27 19:47:38 UTC (rev 3764)
@@ -116,6 +116,16 @@
         AbstractWindow::setVisible(visible, destroyAfterHide);
     }
 
+    void ContainerContentWindow::setVisible(bool visible, bool destroyAfterHide, bool dontNotifyInventory)
+    {
+        if( !dontNotifyInventory )
+        {
+            setVisible(visible, destroyAfterHide);
+            return;
+        }
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+    }
+
 	void ContainerContentWindow::initializeContent()
 	{
 		ItemSet items = mContainer->getItems();

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 18:47:56 UTC (rev 3763)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-27 19:47:38 UTC (rev 3764)
@@ -54,10 +54,13 @@
 
         //mSquareSize = ...;
 		mWorldBackground = getWindow("InventoryWindow/Background");
-        getWindow("InventoryWindow")->subscribeEvent(FrameWindow::EventCloseClicked,
+        CEGUI::Window* invWnd = getWindow("InventoryWindow");
+        invWnd->subscribeEvent(FrameWindow::EventCloseClicked,
 			boost::bind(&InventoryWindow::destroyWindow, this));
         mWorldBackground->moveToBack();
         mWorldBackground->setZOrderingEnabled(false);
+        invWnd->setMaxSize(invWnd->getSize());
+        invWnd->setMinSize(invWnd->getSize());
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);
@@ -621,7 +624,9 @@
             for( ; iter != mOpenContainerMap.end(); iter++)
             {
                 if( iter->second != NULL )
-                    iter->second->setVisible(false, true);
+                {
+                    iter->second->setVisible(false, true, true); // if we call notifyInventoryWindow here, the iterator isn't valid any more!
+                }
             }
             mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
         }



From blakharaz at mail.berlios.de  Tue Aug 28 01:51:52 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 01:51:52 +0200
Subject: [Dsa-hl-svn] r3765 - in rl/trunk/engine/common: include src
Message-ID: <200708272351.l7RNpqKl021464@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 01:51:49 +0200 (Tue, 28 Aug 2007)
New Revision: 3765

Modified:
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/common/src/Property.cpp
Log:
Fix text of wrong type exception, add method to get type name


Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-08-27 19:47:38 UTC (rev 3764)
+++ rl/trunk/engine/common/include/Property.h	2007-08-27 23:51:49 UTC (rev 3765)
@@ -61,7 +61,9 @@
         { \
             Throw( \
                 rl::WrongFormatException, \
-                "Wrong property type for to##Name (type is "+ Ogre::String(mValue.type().name())+") " + (mValue.empty()?"EMPTY!":"not empty")); \
+                "Wrong property type for to" + Ogre::String(#Name) \
+                + "() (type is "+ Ogre::String(mValue.type().name())+") " \
+                + (mValue.empty()?"EMPTY!":"not empty")); \
         } \
     }\
     operator Type() const \
@@ -90,6 +92,8 @@
 		PropertyMethod(Array, const PropertyVector);
 		PropertyMethod(Map, const PropertyMap);
 
+        Ogre::String getTypeName() const;
+
     private:
         boost::any mValue;
     };

Modified: rl/trunk/engine/common/src/Property.cpp
===================================================================
--- rl/trunk/engine/common/src/Property.cpp	2007-08-27 19:47:38 UTC (rev 3764)
+++ rl/trunk/engine/common/src/Property.cpp	2007-08-27 23:51:49 UTC (rev 3765)
@@ -28,4 +28,9 @@
     Property::Property()
     {
     }
+
+    Ogre::String Property::getTypeName() const
+    {
+        return mValue.type().name();
+    }
 }



From blakharaz at mail.berlios.de  Tue Aug 28 01:53:08 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 01:53:08 +0200
Subject: [Dsa-hl-svn] r3766 - rl/trunk/engine/script/swig
Message-ID: <200708272353.l7RNr82m021481@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 01:53:07 +0200 (Tue, 28 Aug 2007)
New Revision: 3766

Modified:
   rl/trunk/engine/script/swig/TypeRlProperty.swig
Log:
Fix nasty bug in array properties (index was not used)


Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-08-27 23:51:49 UTC (rev 3765)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-08-27 23:53:07 UTC (rev 3766)
@@ -72,9 +72,9 @@
 			else // Array of Properties
 			{
 				std::vector<rl::Property> vec;
-				for (int idx = 0; idx < length; idx++)
+				for (int idx = 0; idx < length; ++idx)
 				{
-					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, 0)));
+					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, idx)));
 				}
 				rval.setValue(vec);
 			}
@@ -148,7 +148,7 @@
 		PropertyVector vec = input.toArray();
 		VALUE rval = rb_ary_new();
 		for (PropertyVector::const_iterator it = vec.begin();
-			it != vec.end(); it++)
+			it != vec.end(); ++it)
 		{
 			rb_ary_push(rval, rl::convertPropertyToValue(*it));
 		}



From blakharaz at mail.berlios.de  Tue Aug 28 01:55:47 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 01:55:47 +0200
Subject: [Dsa-hl-svn] r3767 - modules/common/dsa modules/common/scripts
	modules/regressiontest/dsa rl/trunk/engine/rules/include
	rl/trunk/engine/rules/src
Message-ID: <200708272355.l7RNtlLO021541@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 01:55:37 +0200 (Tue, 28 Aug 2007)
New Revision: 3767

Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/common/scripts/hero.rb
   modules/common/scripts/mckhero.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
Log:
Use GOF properties for inventory slots

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2007-08-27 23:53:07 UTC (rev 3766)
+++ modules/common/dsa/gameobjectdefinitions.gof	2007-08-27 23:55:37 UTC (rev 3767)
@@ -52,5 +52,110 @@
 		<property name="lit" type="BOOL" data="true"/>
 	</gameobjectclass>
 
+    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
+        <property name="geometrytype" type="STRING" data="ellipsoid" />
+        <property name="mass" type="REAL" data="75"/>
+        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="trousers" type="STRING" data="men_human_female_legs_underpants.mesh"/>
+            <property name="boots" type="STRING" data="men_human_female_feet_nude.mesh"/>
+        </property>
+		<property name="inventory" type="MAP">
+			<property name="slots" type="ARRAY">
+				<!-- Rings on left hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Left Ring"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 L Finger21"/>
+					<property name="holds" type="INT" data="4"/> <!-- Rings -->
+					<property name="readies" type="INT" data="4"/> <!-- Rings -->
+				</property>
+				<!-- Rings on right hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Right Ring"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 R Finger21"/>
+					<property name="holds" type="INT" data="4"/> <!-- Rings -->
+					<property name="readies" type="INT" data="4"/> <!-- Rings -->
+				</property>
+				<!-- Left hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Left Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 L SlotHand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+				<!-- Right hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Right Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 R SlotHand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+				<!-- Head -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Head"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="head"/>
+					<property name="readies" type="INT" data="2048"/> <!-- Helmets -->
+					<property name="holds" type="INT" data="2048"/> <!-- Helmets -->
+				</property>
+				<!-- Back -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Back"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="back"/>
+					<property name="readies" type="INT" data="256"/> <!-- Backpacks -->
+					<property name="holds" type="INT" data="256"/> <!-- Backpacks -->
+				</property>
+				<!-- Armor -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Armor"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="armor"/>
+					<property name="readies" type="INT" data="32"/> <!-- Armor -->
+					<property name="holds" type="INT" data="32"/> <!-- Armor -->
+				</property>
+				<!-- Torso -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Torso"/>
+					<property name="type" type="STRING" data="material"/>
+					<property name="submesh" type="STRING" data="men_human_female_torso"/>
+					<property name="readies" type="INT" data="32800"/> <!-- Armor | Clothes -->
+					<property name="holds" type="INT" data="32800"/> <!-- Armor | Clothes -->
+				</property>
+				<!-- Clothes -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Clothes"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="clothes"/>
+					<property name="readies" type="INT" data="32768"/> <!-- Clothes -->
+					<property name="holds" type="INT" data="32768"/> <!-- Clothes -->
+				</property>
+				<!-- Boots -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Boots"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="boots"/>
+					<property name="readies" type="INT" data="16384"/> <!-- Boots -->
+					<property name="holds" type="INT" data="16384"/> <!-- Boots -->
+				</property>
+				<!-- Trousers -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Trousers"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="trousers"/>
+					<property name="readies" type="INT" data="4096"/> <!-- Trousers -->
+					<property name="holds" type="INT" data="4096"/> <!-- Trousers -->
+				</property>				
+			</property>
+		</property>
+    </gameobjectclass>
 
 </GameObjectDefinitions>

Modified: modules/common/scripts/hero.rb
===================================================================
--- modules/common/scripts/hero.rb	2007-08-27 23:53:07 UTC (rev 3766)
+++ modules/common/scripts/hero.rb	2007-08-27 23:55:37 UTC (rev 3767)
@@ -12,15 +12,6 @@
         modifyAu(1000); # Au = voll
         #modifyLe(-20); # 10 LeP abziehen
 
-		$SCRIPT.log("Inventar konfigurieren.");
-		inv = getInventory();
-		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
-		inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
-		inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_WEAPON, Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Head", "kopf", Item::ITEMTYPE_HELMET, Item::ITEMTYPE_HELMET);
-		inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS, Item::ITEMTYPE_ALL_ITEMS);
-
 		#addSounds()
         $SCRIPT.log("done.");
     end

Modified: modules/common/scripts/mckhero.rb
===================================================================
--- modules/common/scripts/mckhero.rb	2007-08-27 23:53:07 UTC (rev 3766)
+++ modules/common/scripts/mckhero.rb	2007-08-27 23:55:37 UTC (rev 3767)
@@ -29,21 +29,6 @@
 
         $SCRIPT.log("Heldenaktor beschreiben...");
 
-	$SCRIPT.log("Inventar konfigurieren.");
-	inv = getInventory();
-	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
-	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING, Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_WEAPON | Item::ITEMTYPE_SHIELD, Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_WEAPON | Item::ITEMTYPE_SHIELD, Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Back", "back", 0, Item::ITEMTYPE_BACKPACK, RlScript::SLOT_SUBMESH);
-	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
-        inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR | Item::ITEMTYPE_CLOTHES, Item::ITEMTYPE_ARMOR | Item::ITEMTYPE_CLOTHES, RlScript::SLOT_MATERIAL);
-	inv.addSlot("Clothes", "clothes", Item::ITEMTYPE_CLOTHES,  Item::ITEMTYPE_CLOTHES, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Boots", "boots", Item::ITEMTYPE_BOOTS,  Item::ITEMTYPE_BOOTS, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Trousers", "trousers", Item::ITEMTYPE_TROUSERS,  Item::ITEMTYPE_TROUSERS, RlScript::SLOT_SUBMESH);
-
 	#addSounds()
         $SCRIPT.log("done.");
     end

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-27 23:53:07 UTC (rev 3766)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-27 23:55:37 UTC (rev 3767)
@@ -1,22 +1,6 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
-    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
-        <property name="geometrytype" type="STRING" data="ellipsoid" />
-        <property name="mass" type="REAL" data="75"/>
-        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
-        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
-        <property name="geometrytype" type="STRING" data="ellipsoid"/>
-        <property name="meshparts" type="MAP">
-            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
-            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
-            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
-            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
-            <property name="trousers" type="STRING" data="men_human_female_legs_underpants.mesh"/>
-            <property name="boots" type="STRING" data="men_human_female_feet_nude.mesh"/>
-        </property>
-    </gameobjectclass>
-
     <gameobjectclass classid="Holzscheit" baseclass="GameObject">
         <property name="name" type="STRING" data="Holzscheit"/>
         <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-08-27 23:53:07 UTC (rev 3766)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-08-27 23:55:37 UTC (rev 3767)
@@ -36,6 +36,7 @@
 public:
 
 	static const Ogre::String PROPERTY_CONTENT;
+	static const Ogre::String PROPERTY_SLOTS;
 	/** 
 	* @brief Eine Liste mit Zeigern auf Items
 	**/

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-27 23:53:07 UTC (rev 3766)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-27 23:55:37 UTC (rev 3767)
@@ -24,7 +24,6 @@
 #include "EffectManager.h"
 #include "Exception.h"
 #include "Inventory.h"
-#include "Item.h"
 #include "Kampftechnik.h"
 #include "MeshObject.h"
 #include "StateSet.h"
@@ -79,7 +78,6 @@
 
 
 
-
     Creature::Creature(unsigned int id)
         : GameObject(id),
 		mCurrentLe(0),
@@ -1027,7 +1025,7 @@
         }
         else if (key == Creature::PROPERTY_INVENTORY)
         {
-            mInventory->setProperty(Inventory::PROPERTY_CONTENT, value);
+            mInventory->setProperties(value.toMap());
         }
         else
         {

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-08-27 23:53:07 UTC (rev 3766)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-08-27 23:55:37 UTC (rev 3767)
@@ -33,6 +33,7 @@
 {
 
 	const Ogre::String Inventory::PROPERTY_CONTENT = "content";
+	const Ogre::String Inventory::PROPERTY_SLOTS = "slots";
 
     /**
        Just to remember all parts of the inventory
@@ -234,21 +235,23 @@
     {
         if (mSlots.find(name) != mSlots.end())
         {
-            Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+name.c_str()+"' already exists.");
+            LOG_ERROR(Logger::RULES, "Slot '" + name + "' already exists.");
         }
-
-		switch (type)
+        else
         {
-            case SLOT_BONE:
-			    mSlots[name] = new BoneSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
-                break;
-            case SLOT_SUBMESH:
-			    mSlots[name] = new SubmeshSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
-                break;
-            case SLOT_MATERIAL:
-			    mSlots[name] = new MaterialSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
-                break;
-		}
+		    switch (type)
+            {
+                case SLOT_BONE:
+			        mSlots[name] = new BoneSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
+                    break;
+                case SLOT_SUBMESH:
+			        mSlots[name] = new SubmeshSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
+                    break;
+                case SLOT_MATERIAL:
+			        mSlots[name] = new MaterialSlot(mOwner, name, itemReadyMask, itemHeldMask, meshpartname);
+                    break;
+		    }
+        }
     }
 
     const Inventory::SlotMap& Inventory::getAllSlots() const
@@ -281,7 +284,53 @@
 
 	void Inventory::setProperty(const Ogre::String& key, const Property& value)
 	{
-		if (key == Inventory::PROPERTY_CONTENT)
+        if (key == Inventory::PROPERTY_SLOTS)
+        {
+            PropertyVector slotVec = value.toArray();
+
+            for (PropertyVector::const_iterator it = slotVec.begin(); it != slotVec.end(); ++it)
+            {
+                PropertyMap slotProps = it->toMap();
+
+                CeGuiString name = slotProps["name"].toString();
+                int holdItems = Item::ITEMTYPE_ALL_ITEMS;
+                if (slotProps.find("holds") != slotProps.end())
+                {
+                    holdItems = slotProps["holds"].toInt();
+                }
+                int readyItems = Item::ITEMTYPE_ALL_ITEMS;
+                if (slotProps.find("readies") != slotProps.end())
+                {
+                    readyItems = slotProps["readies"].toInt();
+                }
+
+                CeGuiString type = slotProps.find("type")->second.toString();
+                if (type == "bone")
+                {
+                    CeGuiString bone = slotProps["bone"].toString();
+                    LOG_MESSAGE("Inventory", "Add bone slot "+ bone);
+                    addSlot(name, bone.c_str(), holdItems, readyItems, SLOT_BONE);
+                }
+                else if (type == "submesh")
+                {
+                    CeGuiString submesh = slotProps["submesh"].toString();
+                    LOG_MESSAGE("Inventory", "Add submesh slot "+ submesh);
+                    addSlot(name, submesh.c_str(), holdItems, readyItems, SLOT_SUBMESH);
+                }
+                else if (type == "material")
+                {
+                    CeGuiString submesh = slotProps["submesh"].toString();
+                    LOG_MESSAGE("Inventory", "Add material slot "+ submesh);
+                    addSlot(name, submesh.c_str(), holdItems, readyItems, SLOT_MATERIAL);
+                }
+                else
+                {
+                    LOG_ERROR(Logger::RULES, 
+                        "Unknown slot type '"+type+"' in inventory properties.");
+                }
+            }
+        }
+		else if (key == Inventory::PROPERTY_CONTENT)
 		{
 			PropertyMap bonesContent = value.toMap();
 			for (PropertyMap::const_iterator it = bonesContent.begin();
@@ -301,8 +350,8 @@
     PropertySet* Inventory::getAllProperties() const
 	{
 		PropertySet* ps = new PropertySet();
+		ps->setProperty(Inventory::PROPERTY_SLOTS, getProperty(Inventory::PROPERTY_SLOTS));
 		ps->setProperty(Inventory::PROPERTY_CONTENT, getProperty(Inventory::PROPERTY_CONTENT));
 		return ps;
 	}
-
 }



From blakharaz at mail.berlios.de  Tue Aug 28 23:21:41 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 23:21:41 +0200
Subject: [Dsa-hl-svn] r3768 - dependencies/opensteer/include/OpenSteer
	dependencies/opensteer/plugins dependencies/opensteer/src
	modules/common/scripts rl/trunk/engine/ai
	rl/trunk/engine/ai/include rl/trunk/engine/ai/src
	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
Message-ID: <200708282121.l7SLLfeH011546@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 23:21:18 +0200 (Tue, 28 Aug 2007)
New Revision: 3768

Added:
   rl/trunk/engine/ai/include/AiMessages.h
Modified:
   dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
   dependencies/opensteer/include/OpenSteer/Camera.h
   dependencies/opensteer/include/OpenSteer/LocalSpace.h
   dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
   dependencies/opensteer/include/OpenSteer/SteerLibrary.h
   dependencies/opensteer/plugins/Boids.cpp
   dependencies/opensteer/plugins/CaptureTheFlag.cpp
   dependencies/opensteer/plugins/LowSpeedTurn.cpp
   dependencies/opensteer/plugins/MapDrive.cpp
   dependencies/opensteer/plugins/MultiplePursuit.cpp
   dependencies/opensteer/plugins/OneTurning.cpp
   dependencies/opensteer/plugins/Pedestrian.cpp
   dependencies/opensteer/plugins/Soccer.cpp
   dependencies/opensteer/src/Camera.cpp
   dependencies/opensteer/src/Draw.cpp
   dependencies/opensteer/src/Obstacle.cpp
   dependencies/opensteer/src/OpenSteerDemo.cpp
   dependencies/opensteer/src/SimpleVehicle.cpp
   modules/common/scripts/npc.rb
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
- Adapt OpenSteer to naming conventions
- AgentDialogState moves npc to pc then initiates the dialog

Modified: dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -57,18 +57,18 @@
         virtual ~AbstractVehicle() { /* Nothing to do. */ }
         
         // mass (defaults to unity so acceleration=force)
-        virtual float mass (void) const = 0;
+        virtual float getMass (void) const = 0;
         virtual float setMass (float) = 0;
 
         // size of bounding sphere, for obstacle avoidance, etc.
-        virtual float radius (void) const = 0;
+        virtual float getRadius (void) const = 0;
         virtual float setRadius (float) = 0;
 
         // velocity of vehicle
-        virtual Vector3 velocity (void) const = 0;
+        virtual Vector3 getVelocity (void) const = 0;
 
         // speed of vehicle  (may be faster than taking magnitude of velocity)
-        virtual float speed (void) const = 0;
+        virtual float getSpeed (void) const = 0;
         virtual float setSpeed (float) = 0;
 
         // groups of (pointers to) abstract vehicles, and iterators over them
@@ -84,11 +84,11 @@
         // XXX of place on the abstract base class, but for now it is expedient
 
         // the maximum steering force this vehicle can apply
-        virtual float maxForce (void) const = 0;
+        virtual float getMaxForce (void) const = 0;
         virtual float setMaxForce (float) = 0;
 
         // the maximum speed this vehicle is allowed to move
-        virtual float maxSpeed (void) const = 0;
+        virtual float getMaxSpeed (void) const = 0;
         virtual float setMaxSpeed (float) = 0;
 
 		// dp - added to support heterogeneous flocks

Modified: dependencies/opensteer/include/OpenSteer/Camera.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -113,7 +113,7 @@
         // xxx differently (which is to say, correctly) during mouse adjustment.
         LocalSpace ls;
         const LocalSpace& xxxls (void)
-        {ls.regenerateOrthonormalBasis (target - position(), up()); return ls;}
+        {ls.regenerateOrthonormalBasis (target - getPosition(), getUp()); return ls;}
 
 
         // camera mode selection

Modified: dependencies/opensteer/include/OpenSteer/LocalSpace.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -80,17 +80,17 @@
         
 
         // accessors (get and set) for side, up, forward and position
-        virtual Vector3 side (void) const = 0;
+        virtual Vector3 getSide (void) const = 0;
         virtual Vector3 setSide (Vector3 s) = 0;
-        virtual Vector3 up (void) const = 0;
+        virtual Vector3 getUp (void) const = 0;
         virtual Vector3 setUp (Vector3 u) = 0;
-        virtual Vector3 forward (void) const = 0;
+        virtual Vector3 getForward (void) const = 0;
         virtual Vector3 setForward (Vector3 f) = 0;
-        virtual Vector3 position (void) const = 0;
+        virtual Vector3 getPosition (void) const = 0;
         virtual Vector3 setPosition (Vector3 p) = 0;
 
         // use right-(or left-)handed coordinate space
-        virtual bool rightHanded (void) const = 0;
+        virtual bool isRightHanded(void) const = 0;
 
         // reset transform to identity
         virtual void resetLocalSpace (void) = 0;
@@ -121,7 +121,7 @@
         virtual void regenerateOrthonormalBasis (const Vector3& newForward,
                                                  const Vector3& newUp) = 0;
 
-        // rotate 90 degrees in the direction implied by rightHanded()
+        // rotate 90 degrees in the direction implied by isRightHanded()
         virtual Vector3 localRotateForwardToSide (const Vector3& v) const = 0;
         virtual Vector3 globalRotateForwardToSide (const Vector3& globalForward) const=0;
     };
@@ -149,10 +149,10 @@
     public:
 
         // accessors (get and set) for side, up, forward and position
-        Vector3 side     (void) const {return _side;}
-        Vector3 up       (void) const {return _up;}
-        Vector3 forward  (void) const {return _forward;}
-        Vector3 position (void) const {return _position;}
+        Vector3 getSide     (void) const {return _side;}
+        Vector3 getUp       (void) const {return _up;}
+        Vector3 getForward  (void) const {return _forward;}
+        Vector3 getPosition (void) const {return _position;}
         Vector3 setSide     (Vector3 s) {return _side = s;}
         Vector3 setUp       (Vector3 u) {return _up = u;}
         Vector3 setForward  (Vector3 f) {return _forward = f;}
@@ -168,7 +168,7 @@
         // LocalSpace use a left- or right-handed coordinate system?  This can be
         // overloaded in derived types (e.g. vehicles) to change handedness.
 
-        bool rightHanded (void) const {return true;}
+        bool isRightHanded(void) const {return true;}
 
 
         // ------------------------------------------------------------------------
@@ -192,7 +192,7 @@
                          const Vector3& Position)
             : _side(), _up( Up ), _forward( Forward ), _position( Position )
         {
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndUp();
         }
 
         
@@ -275,7 +275,7 @@
         void setUnitSideFromForwardAndUp (void)
         {
             // derive new unit side basis vector from forward and up
-            if (rightHanded())
+            if (isRightHanded())
                 _side = _forward.crossProduct(_up);
             else
                 _side = _up.crossProduct(_forward);
@@ -293,12 +293,12 @@
             _forward = newUnitForward;
 
             // derive new side basis vector from NEW forward and OLD up
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndUp();
 
             // derive new Up basis vector from new Side and new Forward
             // (should have unit length since Side and Forward are
             // perpendicular and unit length)
-            if (rightHanded())
+            if (isRightHanded())
                 _up = _side.crossProduct(_forward);
             else
                 _up = _forward.crossProduct(_side);
@@ -330,7 +330,7 @@
 
         Vector3 localRotateForwardToSide (const Vector3& v) const
         {
-            return Vector3 (rightHanded () ? -v.z : +v.z,
+            return Vector3 (isRightHanded() ? -v.z : +v.z,
                          v.y,
                          v.x);
         }

Modified: dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -117,7 +117,7 @@
             setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
 
             // reset bookkeeping to do running averages of these quanities
-            resetSmoothedPosition ();
+            resetSmoothedPosition();
             resetSmoothedCurvature ();
             resetSmoothedAcceleration ();
         }
@@ -127,22 +127,22 @@
         float setMass (float m) {return _mass = m;}
 
         // get velocity of vehicle
-        Vector3 velocity (void) const {return forward() * _speed;}
+        Vector3 velocity (void) const {return getForward() * _speed;}
 
         // get/set speed of vehicle  (may be faster than taking mag of velocity)
-        float speed (void) const {return _speed;}
+        float getSpeed (void) const {return _speed;}
         float setSpeed (float s) {return _speed = s;}
 
         // size of bounding sphere, for obstacle avoidance, etc.
-        float radius (void) const {return _radius;}
+        float getRadius (void) const {return _radius;}
         float setRadius (float m) {return _radius = m;}
 
         // get/set maxForce
-        float maxForce (void) const {return _maxForce;}
+        float getMaxForce (void) const {return _maxForce;}
         float setMaxForce (float mf) {return _maxForce = mf;}
 
         // get/set maxSpeed
-        float maxSpeed (void) const {return _maxSpeed;}
+        float getMaxSpeed (void) const {return _maxSpeed;}
         float setMaxSpeed (float ms) {return _maxSpeed = ms;}
 
 
@@ -215,7 +215,7 @@
         {
             setUp (Vector3::UNIT_Y);
             setForward (RandomUnitVectorOnXZPlane ());
-            setSide (localRotateForwardToSide (forward()));
+            setSide (localRotateForwardToSide (getForward()));
         }
 
     private:

Modified: dependencies/opensteer/include/OpenSteer/SteerLibrary.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -64,15 +64,15 @@
     class SteerLibraryMixin : public Super
     {
     public:
-        using Super::velocity;
-        using Super::maxSpeed;
-        using Super::speed;
-        using Super::radius;
-        using Super::maxForce;
-        using Super::forward;
-        using Super::position;
-        using Super::side;
-        using Super::up;
+        using Super::getVelocity;
+        using Super::getMaxSpeed;
+        using Super::getSpeed;
+        using Super::getRadius;
+        using Super::getMaxForce;
+        using Super::getForward;
+        using Super::getPosition;
+        using Super::getSide;
+        using Super::getUp;
         using Super::predictFuturePosition;
         
     public:
@@ -257,19 +257,19 @@
 
         bool isAhead (const Vector3& target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position ()).normalisedCopy();
-            return forward().dotProduct(targetDirection) > cosThreshold;
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) > cosThreshold;
         };
         bool isAside (const Vector3& target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position ()).normalisedCopy();
-            const float dp = forward().dotProduct(targetDirection);
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            const float dp = getForward().dotProduct(targetDirection);
             return (dp < cosThreshold) && (dp > -cosThreshold);
         };
         bool isBehind (const Vector3& target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position()).normalisedCopy();
-            return forward().dotProduct(targetDirection) < cosThreshold;
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) < cosThreshold;
         };
 
 
@@ -326,7 +326,7 @@
     WanderUp   = scalarRandomWalk (WanderUp,   speed, -1, +1);
 
     // return a pure lateral steering vector: (+/-Side) + (+/-Up)
-    return (side() * WanderSide) + (up() * WanderUp);
+    return (getSide() * WanderSide) + (getUp() * WanderUp);
 }
 
 
@@ -339,8 +339,8 @@
 OpenSteer::SteerLibraryMixin<Super>::
 steerForSeek (const Vector3& target)
 {
-    const Vector3 desiredVelocity = target - position();
-    return desiredVelocity - velocity();
+    const Vector3 desiredVelocity = target - getPosition();
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -353,8 +353,8 @@
 OpenSteer::SteerLibraryMixin<Super>::
 steerForFlee (const Vector3& target)
 {
-    const Vector3 desiredVelocity = position() - target;
-    return desiredVelocity - velocity();
+    const Vector3 desiredVelocity = getPosition() - target;
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -368,9 +368,9 @@
 xxxsteerForFlee (const Vector3& target)
 {
 //  const Vector3 offset = position - target;
-    const Vector3 offset = position() - target;
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
-    return desiredVelocity - velocity();
+    const Vector3 offset = getPosition() - target;
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -380,9 +380,9 @@
 xxxsteerForSeek (const Vector3& target)
 {
 //  const Vector3 offset = target - position;
-    const Vector3 offset = target - position();
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
-    return desiredVelocity - velocity();
+    const Vector3 offset = target - getPosition();
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -430,14 +430,14 @@
                    Pathway& path)
 {
     // our goal will be offset from our path distance by this amount
-    const float pathDistanceOffset = direction * predictionTime * speed();
+    const float pathDistanceOffset = direction * predictionTime * getSpeed();
 
     // predict our future position
     const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // measure distance along path of our current and predicted positions
     const float nowPathDistance =
-        path.mapPointToPathDistance (position ());
+        path.mapPointToPathDistance (getPosition());
     const float futurePathDistance =
         path.mapPointToPathDistance (futurePosition);
 
@@ -511,7 +511,7 @@
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
     if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * speed());
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
 
     return avoidance;
 }
@@ -531,7 +531,7 @@
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
     if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * speed());
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
 
     return avoidance;
 }
@@ -576,7 +576,7 @@
         if (&other != this)
         {	
             // avoid when future positions are this close (or less)
-            const float collisionDangerThreshold = radius() * 2;
+            const float collisionDangerThreshold = getRadius() * 2;
 
             // predicted time until nearest approach of "this" and "other"
             const float time = predictNearestApproachTime (other);
@@ -605,15 +605,15 @@
     if (threat != NULL)
     {
         // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = forward().dotProduct(threat->forward());
+        float parallelness = getForward().dotProduct(threat->getForward());
         float angle = 0.707f;
 
         if (parallelness < -angle)
         {
             // anti-parallel "head on" paths:
             // steer away from future threat position
-            Vector3 offset = xxxThreatPositionAtNearestApproach - position();
-            float sideDot = offset.dotProduct(side());
+            Vector3 offset = xxxThreatPositionAtNearestApproach - getPosition();
+            float sideDot = offset.dotProduct(getSide());
             steer = (sideDot > 0) ? -1.0f : 1.0f;
         }
         else
@@ -621,17 +621,17 @@
             if (parallelness > angle)
             {
                 // parallel paths: steer away from threat
-                Vector3 offset = threat->position() - position();
-                float sideDot = offset.dotProduct(side());
+                Vector3 offset = threat->getPosition() - getPosition();
+                float sideDot = offset.dotProduct(getSide());
                 steer = (sideDot > 0) ? -1.0f : 1.0f;
             }
             else
             {
                 // perpendicular paths: steer behind threat
                 // (only the slower of the two does this)
-                if (threat->speed() <= speed())
+                if (threat->getSpeed() <= getSpeed())
                 {
-                    float sideDot = side().dotProduct(threat->velocity());
+                    float sideDot = getSide().dotProduct(threat->getVelocity());
                     steer = (sideDot > 0) ? -1.0f : 1.0f;
                 }
             }
@@ -643,7 +643,7 @@
                                xxxThreatPositionAtNearestApproach);
     }
 
-    return side() * steer;
+    return getSide() * steer;
 }
 
 
@@ -660,8 +660,8 @@
 {
     // imagine we are at the origin with no velocity,
     // compute the relative velocity of the other vehicle
-    const Vector3 myVelocity = velocity();
-    const Vector3 otherVelocity = otherVehicle.velocity();
+    const Vector3 myVelocity = getVelocity();
+    const Vector3 otherVelocity = otherVehicle.getVelocity();
     const Vector3 relVelocity = otherVelocity - myVelocity;
     const float relSpeed = relVelocity.length();
 
@@ -679,7 +679,7 @@
 
     // find distance from its path to origin (compute offset from
     // other to us, find length of projection onto path)
-    const Vector3 relPosition = position() - otherVehicle.position();
+    const Vector3 relPosition = getPosition() - otherVehicle.getPosition();
     const float projection = relTangent.dotProduct(relPosition);
 
     return projection / relSpeed;
@@ -697,11 +697,11 @@
 computeNearestApproachPositions (AbstractVehicle& otherVehicle,
                                  float time)
 {
-    const Vector3    myTravel =       forward () *       speed () * time;
-    const Vector3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
+    const Vector3    myTravel =       getForward() *       getSpeed() * time;
+    const Vector3 otherTravel = otherVehicle.getForward() * otherVehicle.getSpeed () * time;
 
-    const Vector3    myFinal =       position () +    myTravel;
-    const Vector3 otherFinal = otherVehicle.position () + otherTravel;
+    const Vector3    myFinal =       getPosition() +    myTravel;
+    const Vector3 otherFinal = otherVehicle.getPosition() + otherTravel;
 
     // xxx for annotation
     ourPositionAtNearestApproach = myFinal;
@@ -732,15 +732,15 @@
         AbstractVehicle& other = **i;
         if (&other != this)
         {
-            const float sumOfRadii = radius() + other.radius();
+            const float sumOfRadii = getRadius() + other.getRadius();
             const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vector3 offset = other.position() - position();
+            const Vector3 offset = other.getPosition() - getPosition();
             const float currentDistance = offset.length();
 
             if (currentDistance < minCenterToCenter)
             {
                 annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return Vec3Utils::perpendicularComponent(-offset, forward());
+                return Vec3Utils::perpendicularComponent(-offset, getForward());
             }
         }
     }
@@ -768,7 +768,7 @@
     }
     else
     {
-        const Vector3 offset = otherVehicle.position() - position();
+        const Vector3 offset = otherVehicle.getPosition() - getPosition();
         const float distanceSquared = offset.squaredLength();
 
         // definitely in neighborhood if inside minDistance sphere
@@ -787,7 +787,7 @@
             {
                 // otherwise, test angular offset from forward axis
                 const Vector3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = forward().dotProduct(unitOffset);
+                const float forwardness = getForward().dotProduct(unitOffset);
                 return forwardness > cosMaxAngle;
             }
         }
@@ -814,12 +814,12 @@
     AVIterator flockEndIter = flock.end();
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flockEndIter; ++otherVehicle )
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // add in steering contribution
             // (opposite of the offset direction, divided once by distance
             // to normalize, divided another time to get 1/d falloff)
-            const Vector3 offset = (**otherVehicle).position() - position();
+            const Vector3 offset = (**otherVehicle).getPosition() - getPosition();
             const float distanceSquared = offset.dotProduct(offset);
             steering += (offset / -distanceSquared);
 
@@ -862,10 +862,10 @@
     // for each of the other vehicles...
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // accumulate sum of neighbor's heading
-            steering += (**otherVehicle).forward();
+            steering += (**otherVehicle).getForward();
 
             // count neighbors
             neighbors++;
@@ -874,7 +874,7 @@
 
     // divide by neighbors, subtract off current heading to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - forward()).normalisedCopy();
+    if (neighbors > 0) steering = ((steering / (float)neighbors) - getForward()).normalisedCopy();
 
     return steering;
 }
@@ -899,10 +899,10 @@
     // for each of the other vehicles...
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // accumulate sum of neighbor's positions
-            steering += (**otherVehicle).position();
+            steering += (**otherVehicle).getPosition();
 
             // count neighbors
             neighbors++;
@@ -911,7 +911,7 @@
 
     // divide by neighbors, subtract off current position to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - position()).normalisedCopy();
+    if (neighbors > 0) steering = ((steering / (float)neighbors) - getPosition()).normalisedCopy();
 
     return steering;
 }
@@ -937,19 +937,19 @@
                  const float maxPredictionTime)
 {
     // offset from this to quarry, that distance, unit vector toward quarry
-    const Vector3 offset = quarry.position() - position();
+    const Vector3 offset = quarry.getPosition() - getPosition();
     const float distance = offset.length ();
     const Vector3 unitOffset = offset / distance;
 
     // how parallel are the paths of "this" and the quarry
     // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = forward().dotProduct(quarry.forward());
+    const float parallelness = getForward().dotProduct(quarry.getForward());
 
     // how "forward" is the direction to the quarry
     // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = forward().dotProduct(unitOffset);
+    const float forwardness = getForward().dotProduct(unitOffset);
 
-    const float directTravelTime = distance / speed ();
+    const float directTravelTime = distance / getSpeed();
     const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
     const int p = intervalComparison (parallelness, -0.707f, 0.707f);
 
@@ -1024,7 +1024,7 @@
     const Vector3 target = quarry.predictFuturePosition (etl);
 
     // annotation
-/*    annotationLine (position(),
+/*    annotationLine (getPosition(),
                     target,
                     gaudyPursuitAnnotation ? color : gGray40);
 */
@@ -1042,17 +1042,17 @@
                  const float maxPredictionTime)
 {
     // offset from this to menace, that distance, unit vector toward menace
-    const Vector3 offset = menace.position() - position();
+    const Vector3 offset = menace.getPosition() - getPosition();
     const float distance = offset.length ();
 
-    const float roughTime = distance / menace.speed();
+    const float roughTime = distance / menace.getSpeed();
     const float predictionTime = ((roughTime > maxPredictionTime) ?
                                   maxPredictionTime :
                                   roughTime);
 
-    const Vector3 target = menace.predictFuturePosition (predictionTime);
+    const Vector3 target = menace.predictFuturePosition(predictionTime);
 
-    return steerForFlee (target);
+    return steerForFlee(target);
 }
 
 
@@ -1066,9 +1066,9 @@
 OpenSteer::SteerLibraryMixin<Super>::
 steerForTargetSpeed (const float targetSpeed)
 {
-    const float mf = maxForce ();
-    const float speedError = targetSpeed - speed ();
-    return forward () * clip (speedError, -mf, +mf);
+    const float mf = getMaxForce();
+    const float speedError = targetSpeed - getSpeed();
+    return getForward() * clip (speedError, -mf, +mf);
 }
 
 

Modified: dependencies/opensteer/plugins/Boids.cpp
===================================================================
--- dependencies/opensteer/plugins/Boids.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Boids.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -113,7 +113,7 @@
             setMaxSpeed (9);
 
             // initial slow speed
-            setSpeed (maxSpeed() * 0.3f);
+            setSpeed (getMaxSpeed() * 0.3f);
 
             // randomize initial orientation
             regenerateOrthonormalBasisUF (RandomUnitVector ());
@@ -122,7 +122,7 @@
             setPosition (RandomVectorInUnitRadiusSphere () * 20);
 
             // notify proximity database that our position has changed
-            proximityToken->updateForNewPosition (position());
+            proximityToken->updateForNewPosition (getPosition());
         }
 
 
@@ -146,7 +146,7 @@
             sphericalWrapAround ();
 
             // notify proximity database that our position has changed
-            proximityToken->updateForNewPosition (position());
+            proximityToken->updateForNewPosition (getPosition());
         }
 
 
@@ -176,7 +176,7 @@
 
             // find all flockmates within maxRadius using proximity database
             neighbors.clear();
-            proximityToken->findNeighbors (position(), maxRadius, neighbors);
+            proximityToken->findNeighbors (getPosition(), maxRadius, neighbors);
 
     #ifndef NO_LQ_BIN_STATS
             // maintain stats on max/min/ave neighbors per boids
@@ -216,10 +216,10 @@
         void sphericalWrapAround (void)
         {
             // when outside the sphere
-            if (position().length() > worldRadius)
+            if (getPosition().length() > worldRadius)
             {
                 // wrap around (teleport)
-                setPosition (position().sphericalWrapAround (Vector3::ZERO,
+                setPosition (getPosition().sphericalWrapAround (Vector3::ZERO,
                                                              worldRadius));
                 if (this == OpenSteerDemo::selectedVehicle)
                 {
@@ -252,7 +252,7 @@
         {
 
             // XXX this is special case code, these should be derived from arguments //
-            const Vector3 surfaceNormal = position().normalisedCopy();                       //
+            const Vector3 surfaceNormal = getPosition().normalisedCopy();                       //
             const Vector3 surfacePoint = surfaceNormal * 40.0f;                         //
             // XXX this is special case code, these should be derived from arguments //
 
@@ -266,7 +266,7 @@
             setPosition (newPos);
             setUp (newUp);
             setForward (newFor);
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndgetUp();
         }
     // ---------------------------------------------- xxxcwr111704_terrain_following
 
@@ -298,12 +298,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vector3 boxSide = side() * radius();
-            const Vector3 boxFront = forward() * minDistanceToCollision;
-            const Vector3 FR = position() + boxFront - boxSide;
-            const Vector3 FL = position() + boxFront + boxSide;
-            const Vector3 BR = position()            - boxSide;
-            const Vector3 BL = position()            + boxSide;
+            const Vector3 boxSide = getSide() * radius();
+            const Vector3 boxFront = getForward() * minDistanceToCollision;
+            const Vector3 FR = getPosition() + boxFront - boxSide;
+            const Vector3 FL = getPosition() + boxFront + boxSide;
+            const Vector3 BR = getPosition()            - boxSide;
+            const Vector3 BL = getPosition()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -727,7 +727,7 @@
                             ((*o == &insideBigSphere) ?
                              Color (0.2f, 0.2f, 0.4f) :
                              Color (0.1f, 0.1f, 0.2f)),
-                            OpenSteerDemo::camera.position ());
+                            OpenSteerDemo::camera.getPosition());
             }
         }
 
@@ -754,10 +754,10 @@
             const float w = box.width / 2;
             const float h = box.height / 2;
             const float d = box.depth / 2;
-            const Vector3 p = box.position ();
-            const Vector3 s = box.side ();
-            const Vector3 u = box.up ();
-            const Vector3 f = box.forward ();
+            const Vector3 p = box.getPosition();
+            const Vector3 s = box.getSide();
+            const Vector3 u = box.getUp();
+            const Vector3 f = box.getForward();
 
             const Vector3 v1 = box.globalizePosition (Vector3 ( w,  h,  d));
             const Vector3 v2 = box.globalizePosition (Vector3 (-w,  h,  d));

Modified: dependencies/opensteer/plugins/CaptureTheFlag.cpp
===================================================================
--- dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -265,7 +265,7 @@
         setPosition (gHomeBaseCenter + randomOnRing);
 
         // are we are too close to an obstacle?
-        if (minDistanceToObstacle (position()) < radius()*5)
+        if (minDistanceToObstacle (getPosition()) < radius()*5)
         {
             // if so, retry the randomization (this recursive call may not return
             // if there is too little free space)
@@ -286,11 +286,11 @@
     {
         // determine upper bound for pursuit prediction time
         const float seekerToGoalDist = Vector3::distance (gHomeBaseCenter,
-                                                       gSeeker->position());
+                                                       gSeeker->getPosition());
         const float adjustedDistance = seekerToGoalDist - radius()-gHomeBaseRadius;
         const float seekerToGoalTime = ((adjustedDistance < 0 ) ?
                                         0 :
-                                        (adjustedDistance/gSeeker->speed()));
+                                        (adjustedDistance/gSeeker->getSpeed()));
         const float maxPredictionTime = seekerToGoalTime * 0.9f;
 
         // determine steering (pursuit, obstacle avoidance, or braking)
@@ -317,12 +317,12 @@
 
         // annotation
         annotationVelocityAcceleration ();
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
 
 
         // detect and record interceptions ("tags") of seeker
-        const float seekerToMeDist = Vector3::distance (position(), 
-                                                     gSeeker->position());
+        const float seekerToMeDist = Vector3::distance (getPosition(), 
+                                                     gSeeker->getPosition());
         const float sumOfRadii = radius() + gSeeker->radius();
         if (seekerToMeDist < sumOfRadii)
         {
@@ -333,7 +333,7 @@
             {
                 const Color color (0.8f, 0.5f, 0.5f);
                 annotationXZDisk (sumOfRadii,
-                            (position() + gSeeker->position()) / 2,
+                            (getPosition() + gSeeker->getPosition()) / 2,
                             color,
                             20);
             }
@@ -350,7 +350,7 @@
         const float sideThreshold = radius() * 8.0f;
         const float behindThreshold = radius() * 2.0f;
 
-        const Vector3 goalOffset = gHomeBaseCenter - position();
+        const Vector3 goalOffset = gHomeBaseCenter - getPosition();
         const float goalDistance = goalOffset.length ();
         const Vector3 goalDirection = goalOffset / goalDistance;
 
@@ -364,17 +364,17 @@
         {
             // short name for this enemy
             const CtfEnemy& e = *ctfEnemies[i];
-            const float eDistance = Vector3::distance (position(), e.position());
-            const float timeEstimate = 0.3f * eDistance / e.speed(); //xxx
+            const float eDistance = Vector3::distance (getPosition(), e.getPosition());
+            const float timeEstimate = 0.3f * eDistance / e.getSpeed(); //xxx
             const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
-            const Vector3 eOffset = eFuture - position();
+            const Vector3 eOffset = eFuture - getPosition();
             const float alongCorridor = goalDirection.dotProduct(eOffset);
             const bool inCorridor = ((alongCorridor > -behindThreshold) && 
                                      (alongCorridor < goalDistance));
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
 
             // xxx temp move this up before the conditionals
-            annotationXZCircle (e.radius(), eFuture, clearPathColor, 20); //xxx
+            annotationXZCircle (e.getRadius(), eFuture, clearPathColor, 20); //xxx
 
             // consider as potential blocker if within the corridor
             if (inCorridor)
@@ -384,7 +384,7 @@
                 if (acrossCorridor < sideThreshold)
                 {
                     // not a blocker if behind us and we are perp to corridor
-                    const float eFront = eForwardDistance + e.radius ();
+                    const float eFront = eForwardDistance + e.getRadius();
 
                     //annotationLine (position, forward*eFront, gGreen); // xxx
                     //annotationLine (e.position, forward*eFront, gGreen); // xxx
@@ -403,7 +403,7 @@
                     if (! safeToTurnTowardsGoal)
                     {
                         // this enemy blocks the path to the goal, so return false
-                        annotationLine (position(), e.position(), clearPathColor);
+                        annotationLine (getPosition(), e.getPosition(), clearPathColor);
                         // return false;
                         xxxReturn = false;
                     }
@@ -427,9 +427,9 @@
                                          const float behindThreshold,
                                          const Vector3& goalDirection)
     {
-        const Vector3 behindSide = side() * sideThreshold;
-        const Vector3 behindBack = forward() * -behindThreshold;
-        const Vector3 pbb = position() + behindBack;
+        const Vector3 behindSide = getSide() * sideThreshold;
+        const Vector3 behindBack = getForward() * -behindThreshold;
+        const Vector3 pbb = getPosition() + behindBack;
         const Vector3 gun = localRotateForwardToSide (goalDirection);
         const Vector3 gn = gun * sideThreshold;
         const Vector3 hbc = gHomeBaseCenter;
@@ -448,12 +448,12 @@
 
     void CtfBase::annotateAvoidObstacle (const float minDistanceToCollision)
     {
-        const Vector3 boxSide = side() * radius();
-        const Vector3 boxFront = forward() * minDistanceToCollision;
-        const Vector3 FR = position() + boxFront - boxSide;
-        const Vector3 FL = position() + boxFront + boxSide;
-        const Vector3 BR = position()            - boxSide;
-        const Vector3 BL = position()            + boxSide;
+        const Vector3 boxSide = getSide() * radius();
+        const Vector3 boxFront = getForward() * minDistanceToCollision;
+        const Vector3 FR = getPosition() + boxFront - boxSide;
+        const Vector3 FL = getPosition() + boxFront + boxSide;
+        const Vector3 BR = getPosition()            - boxSide;
+        const Vector3 BL = getPosition()            + boxSide;
         const Color white (1,1,1);
         annotationLine (FR, FL, white);
         annotationLine (FL, BL, white);
@@ -468,16 +468,16 @@
     Vector3 CtfSeeker::steerToEvadeAllDefenders (void)
     {
         Vector3 evade (0, 0, 0);
-        const float goalDistance = Vector3::distance (gHomeBaseCenter, position());
+        const float goalDistance = Vector3::distance (gHomeBaseCenter, getPosition());
 
         // sum up weighted evasion
         for (int i = 0; i < ctfEnemyCount; i++)
         {
             const CtfEnemy& e = *ctfEnemies[i];
-            const Vector3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.getPosition() - getPosition();
             const float eDistance = eOffset.length();
 
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
             const float behindThreshold = radius() * 2;
             const bool behind = eForwardDistance < behindThreshold;
             if ((!behind) || (eDistance < 5))
@@ -485,14 +485,14 @@
                 if (eDistance < (goalDistance * 1.2)) //xxx
                 {
                     // const float timeEstimate = 0.5f * eDistance / e.speed;//xxx
-                    const float timeEstimate = 0.15f * eDistance / e.speed();//xxx
+                    const float timeEstimate = 0.15f * eDistance / e.getSpeed();//xxx
                     const Vector3 future =
                         e.predictFuturePosition (timeEstimate);
 
-                    annotationXZCircle (e.radius(), future, evadeColor, 20); // xxx
+                    annotationXZCircle (e.getRadius(), future, evadeColor, 20); // xxx
 
-                    const Vector3 offset = future - position();
-                    const Vector3 lateral = offset.perpendicularComponent (forward());
+                    const Vector3 offset = future - getPosition();
+                    const Vector3 lateral = offset.perpendicularComponent (getForward());
                     const float d = lateral.length();
                     const float weight = -1000 / (d * d);
                     evade += (lateral / d) * weight;
@@ -510,20 +510,20 @@
         for (int i = 0; i < ctfEnemyCount; i++)
         {
             const CtfEnemy& e = *ctfEnemies[i];
-            const Vector3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.getPosition() - getPosition();
             const float eDistance = eOffset.length();
 
             // xxx maybe this should take into account e's heading? xxx
-            const float timeEstimate = 0.5f * eDistance / e.speed(); //xxx
+            const float timeEstimate = 0.5f * eDistance / e.getSpeed(); //xxx
             const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
 
             // annotation
-            annotationXZCircle (e.radius(), eFuture, evadeColor, 20);
+            annotationXZCircle (e.getRadius(), eFuture, evadeColor, 20);
 
             // steering to flee from eFuture (enemy's future position)
             const Vector3 flee = xxxsteerForFlee (eFuture);
 
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
             const float behindThreshold = radius() * -2;
 
             const float distanceWeight = 4 / eDistance;
@@ -567,9 +567,9 @@
                 // we have a clear path (defender-free corridor), use pure seek
 
                 // xxx experiment 9-16-02
-                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
+                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, getForward());
 
-                annotationLine (position(), position() + (s * 0.2f), seekColor);
+                annotationLine (getPosition(), getPosition() + (s * 0.2f), seekColor);
                 return s;
             }
             else
@@ -579,10 +579,10 @@
                     // combine seek and (forward facing portion of) evasion
                     const Vector3 evade = steerToEvadeAllDefenders ();
                     const Vector3 steer = 
-                        seek + limitMaxDeviationAngle (evade, 0.5f, forward());
+                        seek + limitMaxDeviationAngle (evade, 0.5f, getForward());
 
                     // annotation: show evasion steering force
-                    annotationLine (position(),position()+(steer*0.2f),evadeColor);
+                    annotationLine (getPosition(),getPosition()+(steer*0.2f),evadeColor);
                     return steer;
                 }
                 else
@@ -590,13 +590,13 @@
                 {
                     const Vector3 evade = XXXsteerToEvadeAllDefenders ();
                     const Vector3 steer = limitMaxDeviationAngle (seek + evade,
-                                                               0.707f, forward());
+                                                               0.707f, getForward());
 
-                    annotationLine (position(),position()+seek, gRed);
-                    annotationLine (position(),position()+evade, gGreen);
+                    annotationLine (getPosition(),getPosition()+seek, gRed);
+                    annotationLine (getPosition(),getPosition()+evade, gGreen);
 
                     // annotation: show evasion steering force
-                    annotationLine (position(),position()+(steer*0.2f),evadeColor);
+                    annotationLine (getPosition(),getPosition()+(steer*0.2f),evadeColor);
                     return steer;
                 }
             }
@@ -614,9 +614,9 @@
         if (clearPath)
         {
             evading = false;
-            const float goalDistance = Vector3::distance (gHomeBaseCenter,position());
+            const float goalDistance = Vector3::distance (gHomeBaseCenter,getPosition());
             const bool headingTowardGoal = isAhead (gHomeBaseCenter, 0.98f);
-            const bool isNear = (goalDistance/speed()) < gAvoidancePredictTimeMax;
+            const bool isNear = (goalDistance/getSpeed()) < gAvoidancePredictTimeMax;
             const bool useMax = headingTowardGoal && !isNear;
             gAvoidancePredictTime =
                 (useMax ? gAvoidancePredictTimeMax : gAvoidancePredictTimeMin);
@@ -637,7 +637,7 @@
         // if we reach the goal before being tagged, switch to atGoal state
         if (state == running)
         {
-            const float baseDistance = Vector3::distance (position(),gHomeBaseCenter);
+            const float baseDistance = Vector3::distance (getPosition(),gHomeBaseCenter);
             if (baseDistance < (radius() + gHomeBaseRadius)) state = atGoal;
         }
 
@@ -684,11 +684,11 @@
         }
 
         // annote seeker with its state as text
-        const Vector3 textOrigin = position() + Vector3 (0, 0.25, 0);
+        const Vector3 textOrigin = getPosition() + Vector3 (0, 0.25, 0);
         std::ostringstream annote;
         annote << seekerStateString << std::endl;
         annote << std::setprecision(2) << std::setiosflags(std::ios::fixed)
-               << speed() << std::ends;
+               << getSpeed() << std::ends;
         draw2dTextAt3dLocation (annote, textOrigin, gWhite, drawGetWindowWidth(), drawGetWindowHeight());
 
         // display status in the upper left corner of the window
@@ -725,7 +725,7 @@
 
         // annotation
         annotationVelocityAcceleration ();
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
     }
 
 
@@ -878,13 +878,13 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw "ground plane" centered between base and selected vehicle
-            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
+            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.getPosition();
             const Vector3 goalDirection = goalOffset.normalisedCopy();
-            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
+            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().getForward();
             const float goalDot = cameraForward.dotProduct(goalDirection);
             const float blend = remapIntervalClip (goalDot, 1, 0, 0.5, 0);
             const Vector3 gridCenter = interpolate (blend,
-                                                 selected.position(),
+                                                 selected.getPosition(),
                                                  gHomeBaseCenter);
             OpenSteerDemo::gridUtility (gridCenter);
 

Modified: dependencies/opensteer/plugins/LowSpeedTurn.cpp
===================================================================
--- dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -102,7 +102,7 @@
 
             // annotation
             annotationVelocityAcceleration ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // reset starting positions
@@ -188,7 +188,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw "ground plane"
-            OpenSteerDemo::gridUtility (selected.position());
+            OpenSteerDemo::gridUtility (selected.getPosition());
           
             // update, draw and annotate each agent
             for (iterator i = all.begin(); i != all.end(); i++)
@@ -200,11 +200,11 @@
                 // display speed near agent's screen position
                 const Color textColor (0.8f, 0.8f, 1.0f);
                 const Vector3 textOffset (0, 0.25f, 0);
-                const Vector3 textPosition = agent.position() + textOffset;
+                const Vector3 textPosition = agent.getPosition() + textOffset;
                 std::ostringstream annote;
                 annote << std::setprecision (2)
                        << std::setiosflags (std::ios::fixed)
-                       << agent.speed()
+                       << agent.getSpeed()
                        << std::ends;
                 draw2dTextAt3dLocation (annote, textPosition, textColor, drawGetWindowWidth(), drawGetWindowHeight());
             }

Modified: dependencies/opensteer/plugins/MapDrive.cpp
===================================================================
--- dependencies/opensteer/plugins/MapDrive.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/MapDrive.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -919,8 +919,8 @@
                     {
                         const Vector3 wander = steerForWander (elapsedTime);
                         const Vector3 flat = wander.setYtoZero ();
-                        const Vector3 weighted = flat.truncateLength (maxForce()) * 6;
-                        const Vector3 a = position() + Vector3 (0, 0.2f, 0);
+                        const Vector3 weighted = flat.truncateLength (getMaxForce()) * 6;
+                        const Vector3 a = getPosition() + Vector3 (0, 0.2f, 0);
                         annotationLine (a, a + (weighted * 0.3f), gWhite);
                         steering += weighted;
                     }
@@ -934,7 +934,7 @@
                         if (pf != Vector3::ZERO)
                         {
                             // steer to remain on path
-                            if (pf.dotProduct(forward()) < 0)
+                            if (pf.dotProduct(getForward()) < 0)
                                 steering = pf;
                             else
                                 steering = pf + steering;
@@ -943,17 +943,17 @@
                         {
                             // path aligment: when neither obstacle avoidance nor
                             // path following is required, align with path segment
-                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
+                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, getPosition(), pathFollowDirection ); // path->tangentAt (getPosition(), pathFollowDirection);
                             {
-                                const Vector3 b = (position () +
-                                                (up () * 0.2f) +
-                                                (forward () * halfLength * 1.4f));
+                                const Vector3 b = (getPosition() +
+                                                (getUp() * 0.2f) +
+                                                (getForward() * halfLength * 1.4f));
                                 const float l = 2;
-                                annotationLine (b, b + (forward ()  * l), gCyan);
+                                annotationLine (b, b + (getForward()  * l), gCyan);
                                 annotationLine (b, b + (pathHeading * l), gCyan);
                             }
                             steering += (steerTowardHeading(pathHeading) *
-                                         ( isNearWaypoint( *path, position() ) /* path->nearWaypoint (position () ) */ ?
+                                         ( isNearWaypoint( *path, getPosition() ) /* path->nearWaypoint (getPosition() ) */ ?
                                           0.5f : 0.1f));
                         }
                     }
@@ -981,13 +981,13 @@
                 const bool circles = weAreGoingInCircles ();
                 if (circles && !stuck) stuckCycleCount++;
                 if (circles) stuck = true;
-                annotationCircleOrDisk (0.5, up(), smoothedPosition (),
+                annotationCircleOrDisk (0.5, getUp(), smoothedgetPosition(),
                                         gWhite, 12, circles, false);
             }
 
             // annotation
             perFrameAnnotation ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
 
@@ -997,8 +997,8 @@
     //  //
     //  Vector3 reduceTurningAtLowSpeeds (const Vector3& rawSteering)
     //  {
-    //      const Vector3 thrust = rawSteering.parallelComponent (forward ());
-    //      const Vector3 lateral = rawSteering.perpendicularComponent (forward ());
+    //      const Vector3 thrust = rawSteering.parallelComponent (getForward());
+    //      const Vector3 lateral = rawSteering.perpendicularComponent (getForward());
     //      // const float adjust = relativeSpeed ();
     //      // const float adjust = square (relativeSpeed ());
     //      const float adjust = square (square (relativeSpeed ()));
@@ -1010,7 +1010,7 @@
         {
             const float minRadius = sqrtXXX(square(halfWidth)+square(halfLength));
             const float safetyMargin = (curvedSteering ?
-                                        interpolate (relativeSpeed(), 0.0f, 1.5f) :
+                                        interpolate (relativegetSpeed(), 0.0f, 1.5f) :
                                         0.0f);
             setRadius (minRadius + safetyMargin);
         }
@@ -1061,15 +1061,15 @@
             if (demoSelect != 2) return Vector3::ZERO;
 
             // are we heading roughly parallel to the current path segment?
-            const Vector3 p = position ();
+            const Vector3 p = getPosition();
             const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path->tangentAt (p, pathFollowDirection);
-            if (pathHeading.dotProduct(forward ()) < 0.8f)
+            if (pathHeading.dotProduct(getForward()) < 0.8f)
             {
                 // if not, the "hint" is to turn to align with path heading
-                const Vector3 s = side () * halfWidth;
+                const Vector3 s = getSide() * halfWidth;
                 const float f = halfLength * 2;
-                annotationLine (p + s, p + s + (forward () * f), gBlack);
-                annotationLine (p - s, p - s + (forward () * f), gBlack);
+                annotationLine (p + s, p + s + (getForward() * f), gBlack);
+                annotationLine (p - s, p - s + (getForward() * f), gBlack);
                 annotationLine (p, p + (pathHeading * 5), gMagenta);
                 return pathHeading;
             }
@@ -1077,7 +1077,7 @@
             {
                 // when there is a valid nearest obstacle position
                 const Vector3 obstacle = qqqLastNearestObstacle;
-                const Vector3 o = obstacle + (up () * 0.1f);
+                const Vector3 o = obstacle + (getUp() * 0.1f);
                 if (obstacle != Vector3::ZERO)
                 {
                     // get offset, distance from obstacle to its image on path
@@ -1106,13 +1106,13 @@
                             {
                                 const Vector3 q = p + (offset.normalisedCopy() * 5);
                                 annotationLine (p, q, gMagenta);
-                                annotationCircleOrDisk (0.4f, up(), o, gWhite,
+                                annotationCircleOrDisk (0.4f, getUp(), o, gWhite,
                                                         12, false, false);
                                 return offset;
                             }
                         }
                     }
-                    annotationCircleOrDisk (0.4f, up(), o, gBlack, 12,false,false);
+                    annotationCircleOrDisk (0.4f, getUp(), o, gBlack, 12,false,false);
                 }
             }
             // otherwise, no hint
@@ -1141,10 +1141,10 @@
         {
             const float spacing = map.minSpacing() / 2;
             const float maxSide = radius();
-            const float maxForward = minTimeToCollision * speed();
+            const float maxForward = minTimeToCollision * getSpeed();
             const int maxSamples = (int) (maxForward / spacing);
-            const Vector3 step = forward () * spacing;
-            const Vector3 fOffset = position ();
+            const Vector3 step = getForward() * spacing;
+            const Vector3 fOffset = getPosition();
             Vector3 sOffset;
             float s = spacing / 2;
 
@@ -1159,21 +1159,21 @@
 
             const bool hintGiven = steerHint != Vector3::ZERO;
             if (hintGiven && !dtZero) hintGivenCount++;
-            if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, up(),
-                                                   position () + (up () * 0.2f),
+            if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, getUp(),
+                                                   getPosition() + (getUp() * 0.2f),
                                                    gWhite, 12, false, false);
 
             // QQQ temporary global QQQoaJustScraping
             QQQoaJustScraping = true;
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
             const float circumference = twoPi * arcRadius;
-            const float rawLength = speed() * minTimeToCollision * sign;
+            const float rawLength = getSpeed() * minTimeToCollision * sign;
             const float fracLimit = 1.0f / 6.0f;
             const float distLimit = circumference * fracLimit;
             const float arcLength = arcLengthLimit (rawLength, distLimit);
@@ -1182,10 +1182,10 @@
             // XXX temp annotation to show limit on arc angle
             if (curvedSteering)
             {
-                if ((speed() * minTimeToCollision) > (circumference * fracLimit))
+                if ((getSpeed() * minTimeToCollision) > (circumference * fracLimit))
                 {
                     const float q = twoPi * fracLimit;
-                    const Vector3 fooz = position () - center;
+                    const Vector3 fooz = getPosition() - center;
                     const Vector3 booz = fooz.rotateAboutGlobalY (sign * q);
                     annotationLine (center, center + fooz, gRed);
                     annotationLine (center, center + booz, gRed);
@@ -1199,7 +1199,7 @@
             // keep track of nearest obstacle on left and right sides
             while (s < maxSide)
             {
-                sOffset = side() * s;
+                sOffset = getSide() * s;
                 s += spacing;
                 const Vector3 lOffset = fOffset + sOffset;
                 const Vector3 rOffset = fOffset - sOffset;
@@ -1265,7 +1265,7 @@
                 const int wingScans = 4;
                 // see duplicated code at: QQQ draw sensing "wings"
                 // QQQ should be a parameter of this method
-                const Vector3 wingWidth = side() * wingSlope () * maxForward;
+                const Vector3 wingWidth = getSide() * wingSlope () * maxForward;
 
                 const Color beforeColor (0.75f, 0.9f, 0.0f);  // for annotation
                 const Color afterColor  (0.9f,  0.5f, 0.0f);  // for annotation
@@ -1274,7 +1274,7 @@
                 {
                     const float fraction = (float)i / (float)wingScans;
                     const Vector3 endside = sOffset + (wingWidth * fraction);
-                    const Vector3 corridorFront = forward() * maxForward;
+                    const Vector3 corridorFront = getForward() * maxForward;
 
                     // "loop" from -1 to 1
                     for (int j = -1; j < 2; j+=2)
@@ -1358,7 +1358,7 @@
                 if (obstacleFreeWL || obstacleFreeWR || relativeSpeed () < 0.7f)
                     return Vector3::ZERO;
                 else
-                    return -forward ();
+                    return -getForward();
             }
 
             // if the nearest obstacle is way out there, take hint if any
@@ -1368,7 +1368,7 @@
             {
                 annotationNoteOAClauseName ("nearest obstacle is way out there");
                 annotationHintWasTaken ();
-                if (steerHint.dotProduct(side())>0) return side();else return -side();
+                if (steerHint.dotProduct(getSide())>0) return getSide();else return -getSide();
             }
 
             // QQQ experiment 3-9-04
@@ -1378,21 +1378,21 @@
             //
             // are we turning more sharply than the minimum turning radius?
             // (code from adjustSteeringForMinimumTurningRadius)
-            const float maxCurvature = 1 / (minimumTurningRadius () * 1.2f);
+            const float maxCurvature = 1 / (minimumTurninggetRadius() * 1.2f);
             if (absXXX (curvature ()) > maxCurvature)
             {
                 annotationNoteOAClauseName ("min turn radius");
-                annotationCircleOrDisk (minimumTurningRadius () * 1.2f, up(),
+                annotationCircleOrDisk (minimumTurninggetRadius() * 1.2f, getUp(),
                                         center, gBlue * 0.8f, 40, false, false);
-                return side () * sign;
+                return getSide() * sign;
             }
 
             // if either side is obstacle-free, turn in that direction
             if (obstacleFreeL || obstacleFreeR)
                 annotationNoteOAClauseName ("obstacle-free side");
 
-            if (obstacleFreeL) return side();
-            if (obstacleFreeR) return -side();
+            if (obstacleFreeL) return getSide();
+            if (obstacleFreeR) return -getSide();
 
             // if wings are clear, turn away from nearest obstacle straight ahead
             if (obstacleFreeW)
@@ -1404,12 +1404,12 @@
                 if (same && hintGiven)
                 {
                     annotationHintWasTaken ();
-                    if (steerHint.dotProduct(side())>0) return side();else return -side();
+                    if (steerHint.dotProduct(getSide())>0) return getSide();else return -getSide();
                 }
                 else
                 {
                     // otherwise steer toward the less cluttered side
-                    if (nearestL > nearestR) return side(); else return -side();
+                    if (nearestL > nearestR) return getSide(); else return -getSide();
                 }
             }
 
@@ -1420,13 +1420,13 @@
             {
                 annotationNoteOAClauseName ("equallyClear");
                 annotationHintWasTaken ();
-                if (steerHint.dotProduct(side()) > 0) return side(); else return -side();
+                if (steerHint.dotProduct(getSide()) > 0) return getSide(); else return -getSide();
             }
 
             // turn towards the side whose "wing" region is less cluttered
             // (the wing whose nearest obstacle is furthest away)
             annotationNoteOAClauseName ("wing less cluttered");
-            if (nearestWL > nearestWR) return side(); else return -side();
+            if (nearestWL > nearestWR) return getSide(); else return -getSide();
         }
 
 
@@ -1480,9 +1480,9 @@
             if (!dtZero) hintTakenCount++;
 
             const float r = halfWidth * 0.9f;
-            const Vector3 ff = forward () * r;
-            const Vector3 ss = side () * r;
-            const Vector3 pp = position () + (up () * 0.2f);
+            const Vector3 ff = getForward() * r;
+            const Vector3 ss = getSide() * r;
+            const Vector3 pp = getPosition() + (getUp() * 0.2f);
             annotationLine (pp + ff + ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp + ff - ss, gWhite);
@@ -1591,12 +1591,12 @@
             const float predictTime = curvedSteering ? .75f : 1.3f; // seconds
             const float maxForward =
                 speed () * combinedLookAheadTime (predictTime, minDistance);
-            const Vector3 step = forward () * spacing;
+            const Vector3 step = getForward() * spacing;
             float s = curvedSteering ? (spacing / 4) : (spacing / 2);
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1607,9 +1607,9 @@
             // scan region ahead of vehicle
             while (s < maxSide)
             {
-                const Vector3 sOffset = side() * s;
-                const Vector3 lOffset = position () + sOffset;
-                const Vector3 rOffset = position () - sOffset;
+                const Vector3 sOffset = getSide() * s;
+                const Vector3 lOffset = getPosition() + sOffset;
+                const Vector3 rOffset = getPosition() - sOffset;
                 const float bevel = 0.3f;
                 const float fraction = s / maxSide;
                 const float scanDist = (halfLength +
@@ -1675,30 +1675,30 @@
                 // QQQ and now, worse, I rearranged it to try the "limit arc
                 // QQQ angle" trick
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-                const Vector3 localCenterOfCurvature = side () * signedRadius;
-                const Vector3 center = position () + localCenterOfCurvature;
+                const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+                const Vector3 center = getPosition() + localCenterOfCurvature;
                 const float sign = signedRadius < 0 ? 1.0f : -1.0f;
                 const float arcRadius = signedRadius * -sign;
                 const float twoPi = 2 * OPENSTEER_M_PI;
                 const float circumference = twoPi * arcRadius;
-                const float rawLength = speed() * predictionTime * sign;
+                const float rawLength = getSpeed() * predictionTime * sign;
                 const float arcLength = arcLengthLimit (rawLength,
                                                         circumference * 0.25f);
                 const float arcAngle = twoPi * arcLength / circumference;
 
-                const Vector3 spoke = position () - center;
+                const Vector3 spoke = getPosition() - center;
                 const Vector3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
                 const Vector3 prediction = newSpoke + center;
 
                 // QQQ unify with annotatePathFollowing
                 const Color futurePositionColor (0.5f, 0.5f, 0.6f);
-                annotationXZArc (position (), center, arcLength, 20, 
+                annotationXZArc (getPosition(), center, arcLength, 20, 
                                  futurePositionColor);
                 return prediction;
             }
             else
             {
-                return position() + (velocity() * predictionTime);
+                return getPosition() + (velocity() * predictionTime);
             }
         }
 
@@ -1748,18 +1748,18 @@
                                       GCRoute& path)
         {
             // our goal will be offset from our path distance by this amount
-            const float pathDistanceOffset = direction * predictionTime * speed();
+            const float pathDistanceOffset = direction * predictionTime * getSpeed();
 
             // predict our future position
             const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
             // measure distance along path of our current and predicted positions
             const float nowPathDistance =
-                path.mapPointToPathDistance (position ());
+                path.mapPointToPathDistance (getPosition());
 
             // are we facing in the correction direction?
-            const Vector3 pathHeading = mapPointToTangent( path, position() ) * static_cast< float >( direction );// path.tangentAt(position()) * (float)direction;
-            const bool correctDirection = pathHeading.dotProduct(forward ()) > 0;
+            const Vector3 pathHeading = mapPointToTangent( path, getPosition() ) * static_cast< float >( direction );// path.tangentAt(getPosition()) * (float)direction;
+            const bool correctDirection = pathHeading.dotProduct(getForward()) > 0;
 
             // find the point on the path nearest the predicted future position
             // XXX need to improve calling sequence, maybe change to return a
@@ -1770,11 +1770,11 @@
 
             // determine if we are currently inside the path tube
             float nowOutside;
-            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
+            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, getPosition(), nowOutside );  // path.mapPointToPath (getPosition(), nowOutside);
 
             // no steering is required if our present and future positions are
             // inside the path tube and we are facing in the correct direction
-            const float m = -radius ();
+            const float m = -getRadius();
             const bool whollyInside = (futureOutside < m) && (nowOutside < m);
             if (whollyInside && correctDirection)
             {
@@ -1795,7 +1795,7 @@
                 // if we are on one segment and target is on the next segment and
                 // the dot of the tangents of the two segments is negative --
                 // increase the target offset to compensate the fold back
-                const int ip =  static_cast< int >( mapPointToSegmentIndex( path, position() ) ); // path.indexOfNearestSegment (position ());
+                const int ip =  static_cast< int >( mapPointToSegmentIndex( path, getPosition() ) ); // path.indexOfNearestSegment (getPosition());
                 const int it =  static_cast< int >( mapPointToSegmentIndex( path, target ) ); // path.indexOfNearestSegment (target);
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
@@ -1818,14 +1818,14 @@
                 if (nowOutside > 0) return steerForSeek (nowOnPath);
 
                 // steering to seek target on path
-                const Vector3 seek = steerForSeek (target).truncateLength(maxForce());
+                const Vector3 seek = steerForSeek (target).truncateLength(getMaxForce());
 
                 // return that seek steering -- except when we are heading off
                 // the path (currently on path and future position is off path)
                 // in which case we put on the brakes.
                 if ((nowOutside < 0) && (futureOutside > 0))
-                    return (seek.perpendicularComponent (forward ()) -
-                            (forward () * maxForce ()));
+                    return (seek.perpendicularComponent (getForward()) -
+                            (getForward() * maxForce ()));
                 else
                     return seek;
             }
@@ -1848,15 +1848,15 @@
             float futureOutside;
             const Vector3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
             const Vector3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
-            const Vector3 rawBraking = forward () * maxForce () * -1;
+            const Vector3 rawBraking = getForward() * maxForce () * -1;
             const Vector3 braking = ((futureOutside < 0) ? Vector3::ZERO : rawBraking);
             //qqq experimental wrong-way-fixer
             float nowOutside;
             Vector3 nowTangent;
-            const Vector3 p = position ();
+            const Vector3 p = getPosition();
             const Vector3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
             nowTangent *= (float)direction;
-            const float alignedness = nowTangent.dotProduct(forward ());
+            const float alignedness = nowTangent.dotProduct(getForward());
 
             // facing the wrong way?
             if (alignedness < 0)
@@ -1867,20 +1867,20 @@
                 if (alignedness < -0.707f)
                 {
                     const Vector3 towardCenter = nowOnPath - p;
-                    const Vector3 turn = (towardCenter.dotProduct(side ()) > 0 ?
-                                       side () * maxForce () :
-                                       side () * maxForce () * -1);
+                    const Vector3 turn = (towardCenter.dotProduct(getSide()) > 0 ?
+                                       getSide() * maxForce () :
+                                       getSide() * maxForce () * -1);
                     return (turn + rawBraking);
                 }
                 else
                 {
                     return (steerTowardHeading(pathHeading).
-                            perpendicularComponent(forward()) + braking);
+                            perpendicularComponent(getForward()) + braking);
                 }
             }
 
             // is the predicted future position(+radius+margin) inside the path?
-            if (futureOutside < -(radius () + 1.0f)) //QQQ
+            if (futureOutside < -(getRadius() + 1.0f)) //QQQ
             {
                 // then no steering is required
                 return Vector3::ZERO;
@@ -1890,13 +1890,13 @@
                 // otherwise determine corrective steering (including braking)
                 annotationLine (futurePosition, futurePosition+pathHeading, gRed);
                 annotatePathFollowing (futurePosition, onPath,
-                                       position(), futureOutside);
+                                       getPosition(), futureOutside);
 
                 // two cases, if entering a turn (a waypoint between path segments)
                 if ( /* path.nearWaypoint (onPath) */ isNearWaypoint( path, onPath )  && (futureOutside > 0))
                 {
                     // steer to align with next path segment
-                    annotationCircleOrDisk (0.5f, up(), futurePosition,
+                    annotationCircleOrDisk (0.5f, getUp(), futurePosition,
                                             gRed, 8, false, false);
                     return steerTowardHeading (pathHeading) + braking;
                 }
@@ -1907,7 +1907,7 @@
                     const Vector3 pathSide = localRotateForwardToSide (pathHeading);
                     const Vector3 towardFP = futurePosition - onPath;
                     const float whichSide = (pathSide.dotProduct(towardFP)<0)?1.0f :-1.0f;
-                    return (side () * maxForce () * whichSide) + braking;
+                    return (getSide() * maxForce () * whichSide) + braking;
                 }
             }
         }
@@ -1915,20 +1915,20 @@
 
         void perFrameAnnotation (void)
         {
-            const Vector3 p = position();
+            const Vector3 p = getPosition();
 
             // draw the circular collision boundary
-            annotationCircleOrDisk (radius(), up(), p, gBlack, 32, false, false);
+            annotationCircleOrDisk (radius(), getUp(), p, gBlack, 32, false, false);
 
             // draw forward sensing corridor and wings ( for non-curved case)
             if (!curvedSteering)
             {
-                const float corLength = speed() * lookAheadTimeOA ();
+                const float corLength = getSpeed() * lookAheadTimeOA ();
                 if (corLength > halfLength)
                 {
-                    const Vector3 corFront = forward() * corLength;
+                    const Vector3 corFront = getForward() * corLength;
                     const Vector3 corBack = Vector3::ZERO; // (was bbFront)
-                    const Vector3 corSide  = side() * radius();
+                    const Vector3 corSide  = getSide() * radius();
                     const Vector3 c1 = p + corSide + corBack;
                     const Vector3 c2 = p + corSide + corFront;
                     const Vector3 c3 = p - corSide + corFront;
@@ -1939,7 +1939,7 @@
                     annotationLine (c3, c4, color);
 
                     // draw sensing "wings"
-                    const Vector3 wingWidth = side () * wingSlope () * corLength;
+                    const Vector3 wingWidth = getSide() * wingSlope () * corLength;
                     const Vector3 wingTipL = c2 + wingWidth;
                     const Vector3 wingTipR = c3 - wingWidth;
                     const Color wingColor (gOrange);
@@ -1951,7 +1951,7 @@
             }
 
             // annotate steering acceleration
-            const Vector3 above = position () + Vector3 (0, 0.2f, 0);
+            const Vector3 above = getPosition() + Vector3 (0, 0.2f, 0);
             const Vector3 accel = smoothedAcceleration () * 5 / maxForce ();
             const Color aColor (0.4f, 0.4f, 0.8f);
             annotationLine (above, above + accel, aColor);
@@ -1967,9 +1967,9 @@
             if (collisionDetected)   bodyColor = gRed;
 
             // draw vehicle's bounding box on gound plane (its "shadow")
-            const Vector3 p = position();
-            const Vector3 bbSide = side() * halfWidth;
-            const Vector3 bbFront = forward() * halfLength;
+            const Vector3 p = getPosition();
+            const Vector3 bbSide = getSide() * halfWidth;
+            const Vector3 bbFront = getForward() * halfLength;
             const Vector3 bbHeight (0, 0.1f, 0);
             drawQuadrangle (p - bbFront + bbSide + bbHeight,
                             p + bbFront + bbSide + bbHeight,
@@ -1996,16 +1996,16 @@
 
             // draw line from our position to our predicted future position
             if (!curvedSteering)
-                annotationLine (position(), future, futurePositionColor);
+                annotationLine (getPosition(), future, futurePositionColor);
 
             // draw line from our position to our steering target on the path
-            annotationLine (position(), target, toTargetColor);
+            annotationLine (getPosition(), target, toTargetColor);
 
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
             // indicates the boundary of the tube.
 
-            const float o = outside + radius () + (curvedSteering ? 1.0f : 0.0f);
+            const float o = outside + getRadius() + (curvedSteering ? 1.0f : 0.0f);
             const Vector3 boundaryOffset = ((onPath - future).normalisedCopy() * o);
 
             const Vector3 onPathBoundary = future + boundaryOffset;
@@ -2147,8 +2147,8 @@
             if (demoSelect == 2)
             {
                 // for path following, do wrap-around (teleport) and make new map
-                const float px = position ().x;
-                const float fx = forward ().x;
+                const float px = getPosition().x;
+                const float fx = getForward().x;
                 const float ws = worldSize * 0.51f; // slightly past edge
                 if (((fx > 0) && (px > ws)) || ((fx < 0) && (px < -ws)))
                 {
@@ -2157,21 +2157,21 @@
                     lapsFinished++;
 
                     const Vector3 camOffsetBefore =
-                        OpenSteerDemo::camera.position() - position ();
+                        OpenSteerDemo::camera.getPosition() - getPosition();
 
                     // set position on other side of the map (set new X coordinate)
                     setPosition ((((px < 0) ? 1 : -1) *
                                   ((worldSize * 0.5f) +
-                                   (speed() * lookAheadTimePF ()))),
-                                 position ().y,
-                                 position ().z);
+                                   (getSpeed() * lookAheadTimePF ()))),
+                                 getPosition().y,
+                                 getPosition().z);
 
                     // reset bookeeping to detect stuck cycles
                     resetStuckCycleDetection ();
 
                     // new camera position and aimpoint to compensate for teleport
-                    OpenSteerDemo::camera.target = position ();
-                    OpenSteerDemo::camera.setPosition (position () + camOffsetBefore);
+                    OpenSteerDemo::camera.target = getPosition();
+                    OpenSteerDemo::camera.setPosition (getPosition() + camOffsetBefore);
 
                     // make camera jump immediately to new position
                     OpenSteerDemo::camera.doNotSmoothNextMove ();
@@ -2186,7 +2186,7 @@
             {
                 // for the non-path-following demos:
                 // reset simulation if the vehicle drives through the fence
-                if (position().length() > worldDiag) reset();
+                if (getPosition().length() > worldDiag) reset();
             }
             return false;
         }
@@ -2206,7 +2206,7 @@
 
         void resetStuckCycleDetection (void)
         {
-            resetSmoothedPosition (position () + (forward () * -80)); // qqq
+            resetSmoothedPosition (getPosition() + (getForward() * -80)); // qqq
         }
 
 
@@ -2214,7 +2214,7 @@
         // (say for example we were going around a circle with radius > 10)
         bool weAreGoingInCircles (void)
         {
-            const Vector3 offset = smoothedPosition () - position ();
+            const Vector3 offset = smoothedgetPosition() - getPosition();
             return offset.length () < 10;
         }
 
@@ -2223,7 +2223,7 @@
         {
             const float minTime = (baseLookAheadTime *
                                    (curvedSteering ?
-                                    interpolate (relativeSpeed(), 0.4f, 0.7f) :
+                                    interpolate (relativegetSpeed(), 0.4f, 0.7f) :
                                     0.66f));
             return combinedLookAheadTime (minTime, 3);
         }
@@ -2251,12 +2251,12 @@
         {
             if (demoSelect == 2)
             {
-                const Vector3 bbSide = side () * halfWidth;
-                const Vector3 bbFront = forward () * halfLength;
-                return ( /* path->isInsidePath (position () - bbFront + bbSide) */ isInsidePathway( *path, position () - bbFront + bbSide ) &&
-                         /* path->isInsidePath (position () + bbFront + bbSide) */ isInsidePathway( *path, position () + bbFront + bbSide ) &&
-                         /* path->isInsidePath (position () + bbFront - bbSide) */ isInsidePathway( *path, position () + bbFront - bbSide ) &&
-                         /* path->isInsidePath (position () - bbFront - bbSide) */ isInsidePathway( *path, position () - bbFront - bbSide ) );
+                const Vector3 bbSide = getSide() * halfWidth;
+                const Vector3 bbFront = getForward() * halfLength;
+                return ( /* path->isInsidePath (getPosition() - bbFront + bbSide) */ isInsidePathway( *path, getPosition() - bbFront + bbSide ) &&
+                         /* path->isInsidePath (getPosition() + bbFront + bbSide) */ isInsidePathway( *path, getPosition() + bbFront + bbSide ) &&
+                         /* path->isInsidePath (getPosition() + bbFront - bbSide) */ isInsidePathway( *path, getPosition() + bbFront - bbSide ) &&
+                         /* path->isInsidePath (getPosition() - bbFront - bbSide) */ isInsidePathway( *path, getPosition() - bbFront - bbSide ) );
             }
             return true;
         }
@@ -2270,7 +2270,7 @@
             {
                 // annotation
                 const Vector3 u (0, 0.5, 0);
-                const Vector3 p = position ();
+                const Vector3 p = getPosition();
                 annotationLine (p + u, p + u + absolute, gRed);
                 annotationLine (p + u, p + u + curved, gYellow);
                 annotationLine (p + u*2, p + u*2 + currentSteering, gGreen);
@@ -2283,9 +2283,9 @@
         //
         // Given a location in this vehicle's linear local space, convert it into
         // the curved space defined by the vehicle's current path curvature.  For
-        // example, forward() gets mapped on a point 1 unit along the circle
+        // example, getForward() gets mapped on a point 1 unit along the circle
         // centered on the current center of curvature and passing through the
-        // vehicle's position().
+        // vehicle's getPosition().
         //
         Vector3 convertLinearToCurvedSpaceGlobal (const Vector3& linear)
         {
@@ -2293,10 +2293,10 @@
 
             // ---------- this block imported from steerToAvoidObstaclesOnMap
             const float signedRadius = 1 / (nonZeroCurvatureQQQ() /*QQQ*/ * 1);
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius < 0 ? 1.0f : -1.0f;
-            const float arcLength = trimmedLinear.dotProduct(forward ());
+            const float arcLength = trimmedLinear.dotProduct(getForward());
             //
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -2306,7 +2306,7 @@
 
             // ---------- this block imported from scanObstacleMap
             // vector from center of curvature to position of vehicle
-            const Vector3 initialSpoke = position () - center;
+            const Vector3 initialSpoke = getPosition() - center;
             // rotate by signed arc angle
             const Vector3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
             // ---------- this block imported from scanObstacleMap
@@ -2316,23 +2316,23 @@
             const float radiusChangeFactor = (dRadius + arcRadius) / arcRadius;
             const Vector3 resultLocation = center + (spoke * radiusChangeFactor);
             {
-                const Vector3 center = position () + localCenterOfCurvature;
-                annotationXZArc (position (), center, speed () * sign * -3,
+                const Vector3 center = getPosition() + localCenterOfCurvature;
+                annotationXZArc (getPosition(), center, speed () * sign * -3,
                                  20, gWhite);
             }
             // return the vector from vehicle position to the coimputed location
             // of the curved image of the original linear offset
-            return resultLocation - position ();
+            return resultLocation - getPosition();
         }
 
 
         // approximate value for the Polaris Ranger 6x6: 16 feet, 5 meters
-        float minimumTurningRadius () const {return 5.0f;}
+        float minimumTurninggetRadius() const {return 5.0f;}
 
 
         Vector3 adjustSteeringForMinimumTurningRadius (const Vector3& steering)
         {
-            const float maxCurvature = 1 / (minimumTurningRadius () * 1.1f);
+            const float maxCurvature = 1 / (minimumTurninggetRadius() * 1.1f);
 
             // are we turning more sharply than the minimum turning radius?
             if (absXXX (curvature ()) > maxCurvature)
@@ -2343,14 +2343,14 @@
                 // minimum turing radius
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
                 const float sign = signedRadius < 0 ? 1.0f : -1.0f;
-                const Vector3 thrust = steering.parallelComponent (forward ());
+                const Vector3 thrust = steering.parallelComponent (getForward());
                 const Vector3 trimmed = thrust.truncateLength (maxForce ());
-                const Vector3 widenOut = side () * maxForce () * sign;
+                const Vector3 widenOut = getSide() * maxForce () * sign;
                 {
                     // annotation
-                    const Vector3 localCenterOfCurvature = side () * signedRadius;
-                    const Vector3 center = position () + localCenterOfCurvature;
-                    annotationCircleOrDisk (minimumTurningRadius (), up(),
+                    const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+                    const Vector3 center = getPosition() + localCenterOfCurvature;
+                    annotationCircleOrDisk (minimumTurninggetRadius(), getUp(),
                                             center, gBlue, 40, false, false);
                 }
                 return trimmed + widenOut;
@@ -2390,7 +2390,7 @@
             {
                 // compute an ad hoc "relative curvature"
                 const float absC = absXXX (curvature ());
-                const float maxC = 1 / minimumTurningRadius ();
+                const float maxC = 1 / minimumTurninggetRadius();
                 const float relativeCurvature = sqrtXXX (clip (absC/maxC, 0, 1));
 
                 // map from full throttle when straight to 10% at max curvature
@@ -2404,9 +2404,9 @@
                 else
                 {
                     // heading (unit tangent) of the path segment of interest
-                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path->tangentAt (position (), pathFollowDirection);
+                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, getPosition(), pathFollowDirection ); // path->tangentAt (getPosition(), pathFollowDirection);
                     // measure how parallel we are to the path
-                    const float parallelness = pathHeading.dotProduct(forward ());
+                    const float parallelness = pathHeading.dotProduct(getForward());
 
                     // determine relative speed for this heading
                     const float mw = 0.2f;
@@ -2427,7 +2427,7 @@
         //
         Vector3 steerTowardHeading (const Vector3& desiredGlobalHeading)
         {
-            const Vector3 headingError = desiredGlobalHeading - forward ();
+            const Vector3 headingError = desiredGlobalHeading - getForward();
             return headingError.normalisedCopy() * maxForce ();
         }
 

Modified: dependencies/opensteer/plugins/MultiplePursuit.cpp
===================================================================
--- dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -98,11 +98,11 @@
         void update (const float currentTime, const float elapsedTime)
         {
             const Vector3 wander2d = steerForWander (elapsedTime).setYtoZero ();
-            const Vector3 steer = forward() + (wander2d * 3);
+            const Vector3 steer = getForward() + (wander2d * 3);
             applySteeringForce (steer, elapsedTime);
 
             // for annotation
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
     };
@@ -127,7 +127,7 @@
         void update (const float currentTime, const float elapsedTime)
         {
             // when pursuer touches quarry ("wanderer"), reset its position
-            const float d = Vector3::distance (position(), wanderer->position());
+            const float d = Vector3::distance (getPosition(), wanderer->getPosition());
             const float r = radius() + wanderer->radius();
             if (d < r) reset ();
 
@@ -135,7 +135,7 @@
             applySteeringForce (steerForPursuit (*wanderer, maxTime), elapsedTime);
 
             // for annotation
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // reset position
@@ -147,7 +147,7 @@
             const float outer = 30;
             const float radius = frandom2 (inner, outer);
             const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
-            setPosition (wanderer->position() + randomOnRing);
+            setPosition (wanderer->getPosition() + randomOnRing);
 
             // randomize 2D heading
             randomizeHeadingOnXZPlane ();
@@ -215,7 +215,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw "ground plane"
-            OpenSteerDemo::gridUtility (selected.position());
+            OpenSteerDemo::gridUtility (selected.getPosition());
 
             // draw each vehicles
             for (iterator i = allMP.begin(); i != pEnd; i++) (**i).draw ();

Modified: dependencies/opensteer/plugins/OneTurning.cpp
===================================================================
--- dependencies/opensteer/plugins/OneTurning.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/OneTurning.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -72,7 +72,7 @@
         {
             applySteeringForce (Vector3 (-2, 0, -3), elapsedTime);
             annotationVelocityAcceleration ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // draw this character/vehicle into the scene
@@ -127,15 +127,15 @@
             // textual annotation (following the test vehicle's screen position)
             std::ostringstream annote;
             annote << std::setprecision (2) << std::setiosflags (std::ios::fixed);
-            annote << "      speed: " << gOneTurning->speed() << std::ends;
-            draw2dTextAt3dLocation (annote, gOneTurning->position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+            annote << "      speed: " << gOneTurning->getSpeed() << std::ends;
+            draw2dTextAt3dLocation (annote, gOneTurning->getPosition(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
             draw2dTextAt3dLocation (*"start", Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
 
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *gOneTurning);
 
             // draw "ground plane"
-            OpenSteerDemo::gridUtility (gOneTurning->position());
+            OpenSteerDemo::gridUtility (gOneTurning->getPosition());
         }
 
         void close (void)

Modified: dependencies/opensteer/plugins/Pedestrian.cpp
===================================================================
--- dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -143,7 +143,7 @@
             setTrailParameters (3, 60);
 
             // notify proximity database that our position has changed
-            proximityToken->updateForNewPosition (position());
+            proximityToken->updateForNewPosition (getPosition());
         }
 
         // per frame simulation update
@@ -159,12 +159,12 @@
                 const Color darkRed (0.7f, 0, 0);
                 float const pathRadius = path->radius();
                 
-                if (Vector3::distance (position(), gEndpoint0) < pathRadius )
+                if (Vector3::distance (getPosition(), gEndpoint0) < pathRadius )
                 {
                     pathDirection = +1;
                     annotationXZCircle (pathRadius, gEndpoint0, darkRed, 20);
                 }
-                if (Vector3::distance (position(), gEndpoint1) < pathRadius )
+                if (Vector3::distance (getPosition(), gEndpoint1) < pathRadius )
                 {
                     pathDirection = -1;
                     annotationXZCircle (pathRadius, gEndpoint1, darkRed, 20);
@@ -173,10 +173,10 @@
 
             // annotation
             annotationVelocityAcceleration (5, 0);
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
 
             // notify proximity database that our position has changed
-            proximityToken->updateForNewPosition (position());
+            proximityToken->updateForNewPosition (getPosition());
         }
 
         // compute combined steering force: move forward, avoid obstacles
@@ -184,7 +184,7 @@
         Vector3 determineCombinedSteering (const float elapsedTime)
         {
             // move forward
-            Vector3 steeringForce = forward();
+            Vector3 steeringForce = getForward();
 
             // probability that a lower priority behavior will be given a
             // chance to "drive" even if a higher priority behavior might
@@ -219,9 +219,9 @@
                 // find all neighbors within maxRadius using proximity database
                 // (radius is largest distance between vehicles traveling head-on
                 // where a collision is possible within caLeadTime seconds.)
-                const float maxRadius = caLeadTime * maxSpeed() * 2;
+                const float maxRadius = caLeadTime * getMaxSpeed() * 2;
                 neighbors.clear();
-                proximityToken->findNeighbors (position(), maxRadius, neighbors);
+                proximityToken->findNeighbors (getPosition(), maxRadius, neighbors);
 
                 if (leakThrough < frandom01())
                     collisionAvoidance =
@@ -275,10 +275,10 @@
             const Color yellowOrange (1.0f, 0.75f, 0.0f);
 
             // draw line from our position to our predicted future position
-            annotationLine (position(), future, yellow);
+            annotationLine (getPosition(), future, yellow);
 
             // draw line from our position to our steering target on the path
-            annotationLine (position(), target, yellowOrange);
+            annotationLine (getPosition(), target, yellowOrange);
 
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
@@ -295,12 +295,12 @@
                                          const float /*additionalDistance*/)
         {
             // draw the word "Ouch!" above colliding vehicles
-            const float headOn = forward().dotProduct(other.forward()) < 0;
+            const float headOn = getForward().dotProduct(other.getForward()) < 0;
             const Color green (0.4f, 0.8f, 0.1f);
             const Color red (1, 0.1f, 0);
             const Color color = headOn ? red : green;
             const char* string = headOn ? "OUCH!" : "pardon me";
-            const Vector3 location = position() + Vector3 (0, 0.5f, 0);
+            const Vector3 location = getPosition() + Vector3 (0, 0.5f, 0);
             if (OpenSteer::annotationIsOn())
                 draw2dTextAt3dLocation (*string, location, color, drawGetWindowWidth(), drawGetWindowHeight());
         }
@@ -314,8 +314,8 @@
         {
             const Color green (0.15f, 0.6f, 0.0f);
 
-            annotationLine (position(), ourFuture, green);
-            annotationLine (threat.position(), threatFuture, green);
+            annotationLine (getPosition(), ourFuture, green);
+            annotationLine (threat.getPosition(), threatFuture, green);
             annotationLine (ourFuture, threatFuture, gRed);
             annotationXZCircle (radius(), ourFuture,    green, 12);
             annotationXZCircle (radius(), threatFuture, green, 12);
@@ -326,12 +326,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vector3 boxSide = side() * radius();
-            const Vector3 boxFront = forward() * minDistanceToCollision;
-            const Vector3 FR = position() + boxFront - boxSide;
-            const Vector3 FL = position() + boxFront + boxSide;
-            const Vector3 BR = position()            - boxSide;
-            const Vector3 BL = position()            + boxSide;
+            const Vector3 boxSide = getSide() * radius();
+            const Vector3 boxFront = getForward() * minDistanceToCollision;
+            const Vector3 FR = getPosition() + boxFront - boxSide;
+            const Vector3 FL = getPosition() + boxFront + boxSide;
+            const Vector3 BR = getPosition()            - boxSide;
+            const Vector3 BL = getPosition()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -517,7 +517,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw "ground plane"
-            if (OpenSteerDemo::selectedVehicle) gridCenter = selected.position();
+            if (OpenSteerDemo::selectedVehicle) gridCenter = selected.getPosition();
             OpenSteerDemo::gridUtility (gridCenter);
 
             // draw and annotate each Pedestrian
@@ -537,15 +537,15 @@
             {
                 const Color color (0.8f, 0.8f, 1.0f);
                 const Vector3 textOffset (0, 0.25f, 0);
-                const Vector3 textPosition = selected.position() + textOffset;
-                const Vector3 camPosition = OpenSteerDemo::camera.position();
-                const float camDistance = Vector3::distance (selected.position(),
+                const Vector3 textPosition = selected.getPosition() + textOffset;
+                const Vector3 camPosition = OpenSteerDemo::camera.getPosition();
+                const float camDistance = Vector3::distance (selected.getPosition(),
                                                           camPosition);
                 const char* spacer = "      ";
                 std::ostringstream annote;
                 annote << std::setprecision (2);
                 annote << std::setiosflags (std::ios::fixed);
-                annote << spacer << "1: speed: " << selected.speed() << std::endl;
+                annote << spacer << "1: speed: " << selected.getSpeed() << std::endl;
                 annote << std::setprecision (1);
                 annote << spacer << "2: cam dist: " << camDistance << std::endl;
                 annote << spacer << "3: no third thing" << std::ends;
@@ -586,9 +586,9 @@
                 {
                     AbstractVehicle* vehicle = *i;
                     const float nearDistance = 6;
-                    const Vector3& vp = vehicle->position();
-                    const Vector3& np = nearMouse.position();
-                    if ((Vector3::distance (vp, selected.position()) < nearDistance)
+                    const Vector3& vp = vehicle->getPosition();
+                    const Vector3& np = nearMouse.getPosition();
+                    if ((Vector3::distance (vp, selected.getPosition()) < nearDistance)
                         ||
                         (&nearMouse && (Vector3::distance (vp, np) < nearDistance)))
                     {
@@ -598,7 +598,7 @@
                            << std::ends;
                         const Color textColor (0.8f, 1, 0.8f);
                         const Vector3 textOffset (0, 0.25f, 0);
-                        const Vector3 textPos = vehicle->position() + textOffset;
+                        const Vector3 textPos = vehicle->getPosition() + textOffset;
                         draw2dTextAt3dLocation (sn, textPos, textColor, drawGetWindowWidth(), drawGetWindowHeight());
                     }
                 }
@@ -621,8 +621,8 @@
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
             {
                 float w = gObstacle3.width * 0.5f;
-                Vector3 p = gObstacle3.position ();
-                Vector3 s = gObstacle3.side ();
+                Vector3 p = gObstacle3.getPosition();
+                Vector3 s = gObstacle3.getSide();
                 drawLine (p + (s * w), p + (s * -w), gWhite);
 
                 Vector3 v1 = gObstacle3.globalizePosition (Vector3 (w, w, 0));

Modified: dependencies/opensteer/plugins/Soccer.cpp
===================================================================
--- dependencies/opensteer/plugins/Soccer.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Soccer.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -112,19 +112,19 @@
             applyBrakingForce(1.5f, elapsedTime);
             applySteeringForce(velocity(), elapsedTime);
             // are we now outside the field?
-            if(!m_bbox->InsideX(position()))
+            if(!m_bbox->InsideX(getPosition()))
             {
                 Vector3 d = velocity();
                 regenerateOrthonormalBasis(Vector3(-d.x, d.y, d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
-            if(!m_bbox->InsideZ(position()))
+            if(!m_bbox->InsideZ(getPosition()))
             {
                 Vector3 d = velocity();
                 regenerateOrthonormalBasis(Vector3(d.x, d.y, -d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
         }
 
         void kick(Vector3 dir, const float elapsedTime){
@@ -168,7 +168,7 @@
                 else
                     setPosition(Vector3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
                 }
-            m_home = position();
+            m_home = getPosition();
             clearTrailHistory ();    // prevent long streaks due to teleportation 
             setTrailParameters (10, 60);
         }
@@ -179,10 +179,10 @@
         {
             // if I hit the ball, kick it.
 
-            const float distToBall = Vector3::distance (position(), m_Ball->position());
+            const float distToBall = Vector3::distance (getPosition(), m_Ball->getPosition());
             const float sumOfRadii = radius() + m_Ball->radius();
             if (distToBall < sumOfRadii)
-                m_Ball->kick((m_Ball->position()-position())*50, elapsedTime);
+                m_Ball->kick((m_Ball->getPosition()-getPosition())*50, elapsedTime);
 
 
             // otherwise consider avoiding collisions with others
@@ -191,24 +191,24 @@
                 applySteeringForce (collisionAvoidance, elapsedTime);
             else
                 {
-                float distHomeToBall = Vector3::distance (m_home, m_Ball->position());
+                float distHomeToBall = Vector3::distance (m_home, m_Ball->getPosition());
                 if( distHomeToBall < 12.0f)
                     {
                     // go for ball if I'm on the 'right' side of the ball
-                        if( b_ImTeamA ? position().x > m_Ball->position().x : position().x < m_Ball->position().x)
+                        if( b_ImTeamA ? getPosition().x > m_Ball->getPosition().x : getPosition().x < m_Ball->getPosition().x)
                         {
-                        Vector3 seekTarget = xxxsteerForSeek(m_Ball->position());
+                        Vector3 seekTarget = xxxsteerForSeek(m_Ball->getPosition());
                         applySteeringForce (seekTarget, elapsedTime);
                         }
                     else
                         {
                         if( distHomeToBall < 12.0f)
                             {
-                            float Z = m_Ball->position().z - position().z > 0 ? -1.0f : 1.0f;
-                            Vector3 behindBall = m_Ball->position() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
+                            float Z = m_Ball->getPosition().z - getPosition().z > 0 ? -1.0f : 1.0f;
+                            Vector3 behindBall = m_Ball->getPosition() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
                             Vector3 behindBallForce = xxxsteerForSeek(behindBall);
-                            annotationLine (position(), behindBall , Color(0.0f,1.0f,0.0f));
-                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball->position());
+                            annotationLine (getPosition(), behindBall , Color(0.0f,1.0f,0.0f));
+                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball->getPosition());
                             applySteeringForce (behindBallForce*10.0f + evadeTarget, elapsedTime);
                             }
                         }
@@ -301,12 +301,12 @@
                 TeamB[i]->update (currentTime, elapsedTime);
             m_Ball->update(currentTime, elapsedTime);
 
-            if(m_TeamAGoal->InsideX(m_Ball->position()) && m_TeamAGoal->InsideZ(m_Ball->position()))
+            if(m_TeamAGoal->InsideX(m_Ball->getPosition()) && m_TeamAGoal->InsideZ(m_Ball->getPosition()))
             {
                 m_Ball->reset();	// Ball in blue teams goal, red scores
                 m_redScore++;
             }
-            if(m_TeamBGoal->InsideX(m_Ball->position()) && m_TeamBGoal->InsideZ(m_Ball->position()))
+            if(m_TeamBGoal->InsideX(m_Ball->getPosition()) && m_TeamBGoal->InsideZ(m_Ball->getPosition()))
             {
                 m_Ball->reset();	// Ball in red teams goal, blue scores
                     m_blueScore++;
@@ -342,8 +342,8 @@
             {
                 std::ostringstream annote;
                 annote << std::setprecision (2) << std::setiosflags (std::ios::fixed);
-                annote << "      speed: " << TeamA[i]->speed() << "ID:" << i << std::ends;
-                draw2dTextAt3dLocation (annote, TeamA[i]->position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+                annote << "      speed: " << TeamA[i]->getSpeed() << "ID:" << i << std::ends;
+                draw2dTextAt3dLocation (annote, TeamA[i]->getPosition(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
                 draw2dTextAt3dLocation (*"start", Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
             }
             // update camera, tracking test vehicle

Modified: dependencies/opensteer/src/Camera.cpp
===================================================================
--- dependencies/opensteer/src/Camera.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Camera.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -120,9 +120,9 @@
     const bool noVehicle = vehicleToTrack == NULL;
     
     // new position/target/up, set in switch below, defaults to current
-    Vector3 newPosition = position();
+    Vector3 newPosition = getPosition();
     Vector3 newTarget = target;
-    Vector3 newUp = up();
+    Vector3 newUp = getUp();
 
 
     // prediction time to compensate for lag caused by smoothing moves
@@ -149,7 +149,7 @@
 
     case cmStraightDown:
         if (noVehicle) break;
-        newUp = v.forward();
+        newUp = v.getForward();
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = newTarget;
         newPosition.y += lookdownDistance;
@@ -157,7 +157,7 @@
 
     case cmFixedLocalOffset:
         if (noVehicle) break;
-        newUp = v.up();
+        newUp = v.getUp();
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = v.globalizePosition (fixedLocalOffset);
         break;
@@ -165,13 +165,13 @@
     case cmOffsetPOV:
         {
             if (noVehicle) break;
-            newUp = v.up();
+            newUp = v.getUp();
             const Vector3 futurePosition = v.predictFuturePosition (antiLagTime);
             const Vector3 globalOffset = v.globalizeDirection (povOffset);
             newPosition = futurePosition + globalOffset;
             // XXX hack to improve smoothing between modes (no effect on aim)
             const float L = 10;
-            newTarget = newPosition + (v.forward() * L);
+            newTarget = newPosition + (v.getForward() * L);
             break;
         }
     default:
@@ -182,7 +182,7 @@
     smoothCameraMove (newPosition, newTarget, newUp, elapsedTime);
 
     // set camera in draw module
-    drawCameraLookAt (position(), target, up());
+    drawCameraLookAt (getPosition(), target, getUp());
 }
 
 
@@ -204,8 +204,8 @@
     {
         const float smoothRate = elapsedTime * smoothMoveSpeed;
 
-        Vector3 tempPosition = position();
-        Vector3 tempUp = up();
+        Vector3 tempPosition = getPosition();
+        Vector3 tempUp = getUp();
         blendIntoAccumulator (smoothRate, newPosition, tempPosition);
         blendIntoAccumulator (smoothRate, newTarget,   target);
         blendIntoAccumulator (smoothRate, newUp,       tempUp);
@@ -215,10 +215,10 @@
         // xxx not sure if these are needed, seems like a good idea
         // xxx (also if either up or oldUP are zero, use the other?)
         // xxx (even better: force up to be perp to target-position axis))
-        if (up() == Vector3::ZERO)
+        if (getUp() == Vector3::ZERO)
             setUp (Vector3::UNIT_Y);
         else
-            setUp (up().normalisedCopy());
+            setUp (getUp().normalisedCopy());
     }
     else
     {
@@ -247,9 +247,9 @@
     const bool constrainUp = (fixedDistVOffset != 0);
 
     // vector offset from target to current camera position
-    const Vector3 adjustedPosition (position().x,
-                                 (constrainUp) ? target.y : position().y,
-                                 position().z);
+    const Vector3 adjustedPosition (getPosition().x,
+                                 (constrainUp) ? target.y : getPosition().y,
+                                 getPosition().z);
     const Vector3 offset = adjustedPosition - target;
 
     // current distance between them
@@ -258,7 +258,7 @@
     // move camera only when geometry is well-defined (avoid degenerate case)
     if (distance == 0)
     {
-        return position();
+        return getPosition();
     }
     else
     {
@@ -343,7 +343,7 @@
             // XXX this is the oddball case, adjusting "position" instead
             // XXX of mode parameters, hence no smoothing during adjustment
             // XXX Plus the fixedDistVOffset feature complicates things
-            const Vector3 offset = position() - target;
+            const Vector3 offset = getPosition() - target;
             const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             // XXX --------------------------------------------------
 //             position = target + adjusted;
@@ -360,7 +360,7 @@
             setPosition (target + adjusted);
             fixedDistDistance = adjusted.length();
 //          fixedDistVOffset = position.y - target.y;
-            fixedDistVOffset = position().y - target.y;
+            fixedDistVOffset = getPosition().y - target.y;
             // XXX --------------------------------------------------
             break;
         }
@@ -412,8 +412,8 @@
     // sphere.
     const float oldLength = result.length ();
     const float rate = polar ? oldLength : 1;
-    result += xxxls().side() * (adjustment.x * rate);
-    result += xxxls().up()   * (adjustment.y * rate);
+    result += xxxls().getSide() * (adjustment.x * rate);
+    result += xxxls().getUp()   * (adjustment.y * rate);
     if (polar)
     {
         const float newLength = result.length ();
@@ -424,7 +424,7 @@
     if (polar)
         result *= (1 + adjustment.z);
     else
-        result += xxxls().forward() * adjustment.z;
+        result += xxxls().getForward() * adjustment.z;
 
     return result;
 }

Modified: dependencies/opensteer/src/Draw.cpp
===================================================================
--- dependencies/opensteer/src/Draw.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Draw.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -381,7 +381,7 @@
         ls.setUp (unitAxis);
         ls.setForward (unitPerp);
         ls.setPosition (center);
-        ls.setUnitSideFromForwardAndUp ();
+        ls.setUnitSideFromForwardAndgetUp();
     }
         
     // make disks visible (not culled) from both sides 
@@ -398,7 +398,7 @@
     glBegin (filled ? GL_TRIANGLE_FAN : GL_LINE_LOOP);
 
     // for the filled case, first emit the center point
-    if (filled) iglVertexVec3 (in3d ? ls.position() : center);
+    if (filled) iglVertexVec3 (in3d ? ls.getPosition() : center);
 
     // rotate p around the circle in "segments" steps
     float sin=0, cos=0;
@@ -518,14 +518,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3& p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3& p = vehicle.getPosition();
 
     // shape of triangular body
     const Vector3 u = r * 0.05f * Vector3 (0, 1, 0); // slightly up
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // draw double-sided triangle (that is: no (back) face culling)
     beginDoubleSidedDrawing ();
@@ -553,14 +553,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3& p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3& p = vehicle.getPosition();
 
     // body shape parameters
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 u = r * vehicle.up() * x * 0.5f;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 u = r * vehicle.getUp() * x * 0.5f;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // vertex positions
     const Vector3 nose   = p + f;
@@ -600,14 +600,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3& p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3& p = vehicle.getPosition();
 
     // body shape parameters
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 u = r * vehicle.up() * x * 0.5f;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 u = r * vehicle.getUp() * x * 0.5f;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // vertex positions
     const Vector3 nose   = p + f;

Modified: dependencies/opensteer/src/Obstacle.cpp
===================================================================
--- dependencies/opensteer/src/Obstacle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Obstacle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -126,14 +126,14 @@
                       const float minTimeToCollision) const
 {
     // if nearby intersection found, steer away from it, otherwise no steering
-    const float minDistanceToCollision = minTimeToCollision * vehicle.speed();
+    const float minDistanceToCollision = minTimeToCollision * vehicle.getSpeed();
     if (intersect && (distance < minDistanceToCollision))
     {
         // compute avoidance steering force: take the component of
         // steerHint which is lateral (perpendicular to vehicle's
         // forward direction), set its length to vehicle's maxForce
-        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.forward ());
-        return lateral.normalisedCopy() * vehicle.maxForce ();
+        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.getForward());
+        return lateral.normalisedCopy() * vehicle.getMaxForce();
     }
     else
     {
@@ -170,7 +170,7 @@
     lc = vehicle.localizePosition (center);
 
     // compute line-sphere intersection parameters
-    const float r = radius + vehicle.radius();
+    const float r = radius + vehicle.getRadius();
     b = -2 * lc.z;
     c = square (lc.x) + square (lc.y) + square (lc.z) - square (r);
     d = (b * b) - (4 * c);
@@ -203,7 +203,7 @@
          // hollow obstacle (or "both"), pick point that is in front
          ((p > 0) ? p : q));
     pi.surfacePoint =
-        vehicle.position() + (vehicle.forward() * pi.distance);
+        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
     pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
     // hmm, note that this was actually determined already in pi.distance calc
     pi.vehicleOutside = lc.length () > radius;
@@ -237,10 +237,10 @@
     const float w = width; // dimensions
     const float h = height;
     const float d = depth;
-    const Vector3 s = side (); // local space
-    const Vector3 u = up ();
-    const Vector3 f = forward ();
-    const Vector3 p = position ();
+    const Vector3 s = getSide(); // local space
+    const Vector3 u = getUp();
+    const Vector3 f = getForward();
+    const Vector3 p = getPosition();
     const Vector3 hw = s * (0.5f * width); // offsets for face centers
     const Vector3 hh = u * (0.5f * height);
     const Vector3 hd = f * (0.5f * depth);
@@ -271,7 +271,7 @@
     if (pi.intersect)
     {
         pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - position ()).normalisedCopy() *
+        pi.steerHint = ((pi.surfacePoint - getPosition()).normalisedCopy() *
                         (pi.vehicleOutside ? 1.0f : -1.0f));
     }
 }
@@ -291,8 +291,8 @@
     // initialize pathIntersection object to "no intersection found"
     pi.intersect = false;
 
-    const Vector3 lp =  localizePosition (vehicle.position ());
-    const Vector3 ld = localizeDirection (vehicle.forward ());
+    const Vector3 lp =  localizePosition (vehicle.getPosition());
+    const Vector3 ld = localizeDirection (vehicle.getForward());
 
     // no obstacle intersection if path is parallel to XY (side/up) plane
     if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
@@ -311,13 +311,13 @@
     const Vector3 planeIntersection (ix, iy, 0.0f);
 
     // no obstacle intersection if plane intersection is outside 2d shape
-    if (!xyPointInsideShape (planeIntersection, vehicle.radius ())) return;
+    if (!xyPointInsideShape (planeIntersection, vehicle.getRadius())) return;
 
     // otherwise, the vehicle path DOES intersect this rectangle
     const Vector3 localXYradial = planeIntersection.normalisedCopy();
     const Vector3 radial = globalizeDirection (localXYradial);
     const float sideSign = (lp.z > 0.0f) ? +1.0f : -1.0f;
-    const Vector3 opposingNormal = forward () * sideSign;
+    const Vector3 opposingNormal = getForward() * sideSign;
     pi.intersect = true;
     pi.obstacle = this;
     pi.distance = (lp - planeIntersection).length ();

Modified: dependencies/opensteer/src/OpenSteerDemo.cpp
===================================================================
--- dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -461,8 +461,8 @@
     for (AVIterator i = vehicles.begin(); i != vehicles.end(); i++)
     {
         // distance from this vehicle's center to the selection line:
-        const float d = distanceFromLine ((**i).position(),
-                                          camera.position(),
+        const float d = distanceFromLine ((**i).getPosition(),
+                                          camera.getPosition(),
                                           direction);
 
         // if this vehicle-to-line distance is the smallest so far,
@@ -541,9 +541,9 @@
     selectedVehicle = &selected;
     if (&selected)
     {
-        const Vector3 behind = selected.forward() * -distance;
-        camera.setPosition (selected.position() + behind);
-        camera.target = selected.position();
+        const Vector3 behind = selected.getForward() * -distance;
+        camera.setPosition (selected.getPosition() + behind);
+        camera.target = selected.getPosition();
     }
 }
 
@@ -563,7 +563,7 @@
     position3dCamera (selected, distance, elevation);
 
     // then adjust for 3d:
-    Vector3 position3d = camera.position();
+    Vector3 position3d = camera.getPosition();
     position3d.y += elevation;
     camera.setPosition (position3d);
 }
@@ -627,7 +627,7 @@
 OpenSteer::OpenSteerDemo::highlightVehicleUtility (const AbstractVehicle& vehicle)
 {
     if (&vehicle != NULL)
-        drawXZDisk (vehicle.radius(), vehicle.position(), gGray60, 20);
+        drawXZDisk (vehicle.getRadius(), vehicle.getPosition(), gGray60, 20);
 }
 
 
@@ -638,8 +638,8 @@
 void 
 OpenSteer::OpenSteerDemo::circleHighlightVehicleUtility (const AbstractVehicle& vehicle)
 {
-    if (&vehicle != NULL) drawXZCircle (vehicle.radius () * 1.1f,
-                                        vehicle.position(),
+    if (&vehicle != NULL) drawXZCircle (vehicle.getRadius() * 1.1f,
+                                        vehicle.getPosition(),
                                         gGray60,
                                         20);
 }
@@ -656,7 +656,7 @@
 {
     if (&v)
     {
-        const float diameter = v.radius() * 2;
+        const float diameter = v.getRadius() * 2;
         const Vector3 size (diameter, diameter, diameter);
         drawBoxOutline (v, size, color);
     }
@@ -676,10 +676,10 @@
 {
     if (&v)
     {
-        const Vector3& cPosition = camera.position();
-        draw3dCircle  (v.radius() * radiusMultiplier,  // adjusted radius
-                       v.position(),                   // center
-                       v.position() - cPosition,       // view axis
+        const Vector3& cPosition = camera.getPosition();
+        draw3dCircle  (v.getRadius() * radiusMultiplier,  // adjusted radius
+                       v.getPosition(),                   // center
+                       v.getPosition() - cPosition,       // view axis
                        color,                          // drawing color
                        20);                            // circle segments
     }

Modified: dependencies/opensteer/src/SimpleVehicle.cpp
===================================================================
--- dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -110,22 +110,22 @@
 OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vector3& force,
                                                   const float /* deltaTime */)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed();
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
 
-    if ((speed() > maxAdjustedSpeed) || (force == Vector3::ZERO))
+    if ((getSpeed() > maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }
     else
     {
-        const float range = speed() / maxAdjustedSpeed;
+        const float range = getSpeed() / maxAdjustedSpeed;
         // const float cosine = interpolate (pow (range, 6), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 10), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 100), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 50), 1.0f, -1.0f);
         const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle (force, cosine, forward());
+        return limitMaxDeviationAngle (force, cosine, getForward());
     }
 }
 
@@ -148,12 +148,12 @@
 void 
 OpenSteer::SimpleVehicle::applyBrakingForce (const float rate, const float deltaTime)
 {
-    const float rawBraking = speed() * rate;
-    const float clipBraking = ((rawBraking < maxForce()) ?
+    const float rawBraking = getSpeed() * rate;
+    const float clipBraking = ((rawBraking < getMaxForce()) ?
                                rawBraking :
-                               maxForce());
+                               getMaxForce());
 
-    setSpeed (speed() - (clipBraking * deltaTime));
+    setSpeed (getSpeed() - (clipBraking * deltaTime));
 }
 
 
@@ -170,7 +170,7 @@
     const Vector3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
 
     // enforce limit on magnitude of steering force
-    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, maxForce());
+    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, getMaxForce());
 
     // compute acceleration and velocity
     Vector3 newAcceleration = (clippedForce / mass());
@@ -190,13 +190,13 @@
     newVelocity += _smoothedAcceleration * elapsedTime;
 
     // enforce speed limit
-    newVelocity = Vec3Utils::truncateLength(newVelocity, maxSpeed());
+    newVelocity = Vec3Utils::truncateLength(newVelocity, getMaxSpeed());
 
     // update Speed
     setSpeed (newVelocity.length());
 
     // Euler integrate (per frame) velocity into position
-    setPosition (position() + (newVelocity * elapsedTime));
+    setPosition (getPosition() + (newVelocity * elapsedTime));
 
     // regenerate local space (by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
@@ -207,7 +207,7 @@
 
     // running average of recent positions
     blendIntoAccumulator (elapsedTime * 0.06f, // QQQ
-                          position(),
+                          getPosition(),
                           _smoothedPosition);
 }
 
@@ -224,7 +224,7 @@
                                                 const float /* elapsedTime */)
 {
     // adjust orthonormal basis vectors to be aligned with new velocity
-    if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
+    if (getSpeed() > 0) regenerateOrthonormalBasisUF (newVelocity / getSpeed());
 }
 
 
@@ -253,17 +253,17 @@
 
     // blend bankUp into vehicle's UP basis vector
     const float smoothRate = elapsedTime * 3;
-    Vector3 tempUp = up();
+    Vector3 tempUp = getUp();
     blendIntoAccumulator (smoothRate, bankUp, tempUp);
     setUp (tempUp.normalisedCopy());
 
-//  annotationLine (position(), position() + (globalUp * 4), gWhite);  // XXX
-//  annotationLine (position(), position() + (bankUp   * 4), gOrange); // XXX
-//  annotationLine (position(), position() + (accelUp  * 4), gRed);    // XXX
-//  annotationLine (position(), position() + (up()    * 1), gYellow); // XXX
+//  annotationLine (getPosition(), getPosition() + (globalUp * 4), gWhite);  // XXX
+//  annotationLine (getPosition(), getPosition() + (bankUp   * 4), gOrange); // XXX
+//  annotationLine (getPosition(), getPosition() + (accelUp  * 4), gRed);    // XXX
+//  annotationLine (getPosition(), getPosition() + (getUp()    * 1), gYellow); // XXX
 
     // adjust orthonormal basis vectors to be aligned with new velocity
-    if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
+    if (getSpeed() > 0) regenerateOrthonormalBasisUF (newVelocity / getSpeed());
 }
 
 
@@ -276,16 +276,16 @@
 {
     if (elapsedTime > 0)
     {
-        const Vector3 dP = _lastPosition - position();
-        const Vector3 dF = (_lastForward - forward()) / dP.length();
-        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, forward());
-        const float sign = (lateral.dotProduct(side()) < 0) ? 1.0f : -1.0f;
+        const Vector3 dP = _lastPosition - getPosition();
+        const Vector3 dF = (_lastForward - getForward()) / dP.length();
+        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, getForward());
+        const float sign = (lateral.dotProduct(getSide()) < 0) ? 1.0f : -1.0f;
         _curvature = lateral.length() * sign;
         blendIntoAccumulator (elapsedTime * 4.0f,
                               _curvature,
                               _smoothedCurvature);
-        _lastForward = forward();
-        _lastPosition = position();
+        _lastForward = getForward();
+        _lastPosition = getPosition();
     }
 }
 
@@ -299,9 +299,9 @@
                                                           float maxLengthV)
 {
     const float desat = 0.4f;
-    const float aScale = maxLengthA / maxForce();
-    const float vScale = maxLengthV / maxSpeed();
-    const Vector3& p = position();
+    const float aScale = maxLengthA / getMaxForce();
+    const float vScale = maxLengthV / getMaxSpeed();
+    const Vector3& p = getPosition();
     const Color aColor (desat, desat, 1); // bluish
     const Color vColor (    1, desat, 1); // pinkish
 
@@ -323,7 +323,7 @@
 Vector3 
 OpenSteer::SimpleVehicle::predictFuturePosition (const float predictionTime) const
 {
-    return position() + (velocity() * predictionTime);
+    return getPosition() + (velocity() * predictionTime);
 }
 
 

Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2007-08-27 23:55:37 UTC (rev 3767)
+++ modules/common/scripts/npc.rb	2007-08-28 21:21:18 UTC (rev 3768)
@@ -11,18 +11,12 @@
       bot = $AI.loadBot(object.getName(), object.getDialogfile())
     end
     if ( not bot.nil? )
-	  p "foo1"
       bot.setPlayerCharacter( actor );
-	  p "foo2"
       bot.setNonPlayerCharacter( object );
-	  p "foo3"
-	  p "foo4"
 	  agent = AgentManager::getSingleton().createAgent(object)
 	  agent.pushState(RlScript::AST_DIALOG);
-	  p "foo5"
 	  agent.getCurrentState().setDialogPartner(
 		AgentManager::getSingleton().createAgent(actor))
-	  p "foo6"
     end
   end
 end

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-28 21:21:18 UTC (rev 3768)
@@ -250,7 +250,7 @@
 				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="..\common\lib\Release;..\core\lib\Release;..\rules\lib\Release;..\dialog\lib\Release;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib\Release;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\aiml\MadaBot\lib\Release"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -513,6 +513,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\AiMessages.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\AimlNodeImplRl.h"
 				>
 			</File>

Added: rl/trunk/engine/ai/include/AiMessages.h
===================================================================
--- rl/trunk/engine/ai/include/AiMessages.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/include/AiMessages.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_AiMessages_H__
+#define __Rl_AiMessages_H__
+
+#include "AiPrerequisites.h"
+#include "MessageType.h"
+
+namespace rl
+{
+    class DialogCharacter;
+
+    enum AiMessageTypeIds
+    {
+        // Controllers //
+        // Mask
+        RLMSG_CONTROLLERS_EVENTS            = 0x02000100,
+        // Events
+        RLMSG_CONTROLLERS_DIALOG_STARTED    = 0x02000101,
+        RLMSG_CONTROLLERS_DIALOG_ENDED      = 0x02000102,
+    };
+
+    /// Message sent when a dialog with the player will be started
+    typedef MessageType<RLMSG_CONTROLLERS_DIALOG_STARTED/*, DialogCharacter* */> 
+        MessageType_DialogStarted;
+}
+
+#endif

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -173,7 +173,7 @@
 		/** get mass
 		 * @returns mass of physical object
 		 */
-		float mass() const;
+		float getMass() const;
 		/** does not set mass but is necessary for AbstractVehicle.
 		 * throws an exception on invocation.
 		 * @param m mass
@@ -183,12 +183,12 @@
 		/** retrieve velocity of vehicle
 		 * @returns velocity of the vehicle
 		 */
-		Ogre::Vector3 velocity() const {return mCurrentVelocity;}
+		Ogre::Vector3 getVelocity() const {return mCurrentVelocity;}
 
 		/** retrieves speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 */
-		float speed() const;
+		float getSpeed() const;
 		/** sets speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 * @param s new speed to set
@@ -201,7 +201,7 @@
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float radius() const;
+		float getRadius() const;
 		/** sets radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
@@ -214,7 +214,7 @@
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float height() const;
+        float getHeight() const;
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
@@ -225,7 +225,7 @@
 		/** retrieves maximum force.
 		 * @returns float containing maximum force.
 		 */
-		float maxForce() const; 
+		float getMaxForce() const; 
 		/** sets maximum force.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum force set.
@@ -235,7 +235,7 @@
 		/** retrieves maximum speed.
 		 * @returns float containing maximum speed
 		 */
-		float maxSpeed() const;
+		float getMaxSpeed() const;
 		/** retrieves maximum speed.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum speed

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -18,9 +18,11 @@
 #include "AgentDialogState.h"
 
 #include "Agent.h"
+#include "AiMessages.h"
 #include "Creature.h"
 #include "CreatureController.h"
 #include "CreatureControllerManager.h"
+#include "MessagePump.h"
 
 using namespace Ogre;
 
@@ -49,30 +51,28 @@
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent->getControlledCreature());
 
-        if (mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5)
+        if (mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5
+            || !mAgent->isAhead(mPartner, 0.95))
         {		
-            mAgent->addForce(mAgent->calcPursuit(mPartner));
+            mAgent->addForce(mAgent->calcSeek(mPartner->getPosition()));
             mAgent->updateVehicle(0, elapsedTime);
         }
-        //else if (!mAgent->isAhead(mPartner, 0.95)) 
-        //{		
-        //    mAgent->addForce(mAgent->calcPursuit(mPartner));
-        //    mAgent->updateVehicle(0, elapsedTime);
-        //}
-        ///@todo: Turn if near but not correctly oriented
 		else
         {
 			if (!mTalking)
             {
                 mAgent->reset();
-                ctrl->setMovement(CreatureController::MT_NONE, Vector3::ZERO, Vector3::ZERO);
-		        //$IM.pushControlState(CST_DIALOG);
+                ctrl->setMovement(
+                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 
                 ctrl->setAnimation("reden");
 				mTalking = true;
+
+                MessagePump::getSingleton().sendMessage<MessageType_DialogStarted>();
+                
+                mAgent->popState();
             }			
         }
 
-
     }
 } // namespace rl

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -96,8 +96,8 @@
     // Dadurch ist ungefaehr der Umriss gesichert!
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
-    Vector3 pos = vehicle.position();
-    Vector3 futPos = vehicle.forward() * vehicle.speed() * 3 + pos;
+    Vector3 pos = vehicle.getPosition();
+    Vector3 futPos = vehicle.getForward() * vehicle.getSpeed() * 3 + pos;
 
 
     if (pos == futPos)
@@ -114,8 +114,8 @@
 
     if( steerVec != NULL )
     {
-        pos = pos + Ogre::Vector3::UNIT_Y*steerVec->height()/2.0;
-        futPos = futPos + Ogre::Vector3::UNIT_Y*steerVec->height()/2.0;
+        pos = pos + Ogre::Vector3::UNIT_Y*steerVec->getHeight()/2.0;
+        futPos = futPos + Ogre::Vector3::UNIT_Y*steerVec->getHeight()/2.0;
     }
 
 
@@ -137,18 +137,18 @@
         else if( raycastType == RIGHT )
         {
             // so wir ham ne normale und machen uns nen Y
-            if( vehicle.radius() == 0 )
+            if( vehicle.getRadius() == 0 )
                 continue;
-            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            Vector3 offset = vehicle.getSide().normalisedCopy() * (vehicle.getRadius() - 0.1);
             castPos = pos + offset;
             castFutPos = futPos + offset;
         }
         else if( raycastType == LEFT )
         {
             // wie bei right ...
-            if( vehicle.radius() == 0 )
+            if( vehicle.getRadius() == 0 )
                 continue;
-            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            Vector3 offset = vehicle.getSide().normalisedCopy() * (vehicle.getRadius() - 0.1);
             castPos = pos - offset;
             castFutPos = futPos - offset;
         }
@@ -156,7 +156,7 @@
         {
             if( steerVec == NULL ) // hier abbrechen
                 break;
-            float height = steerVec->height();
+            float height = steerVec->getHeight();
             if( height == 0 )
                 break;
             if( raycastType == TOP )
@@ -209,7 +209,7 @@
         pi.obstacle = this;
         pi.distance = infoNearest.mDistance * (futPos - pos).length();
         pi.surfacePoint =
-        vehicle.position() + (vehicle.forward() * pi.distance);
+        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
 
         // Die normale muss zu uns zeigen! koennte aber auch in die entgegengesetzte Richtung sein!
         pi.surfaceNormal = Vector3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * Copyright(C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
@@ -22,6 +22,7 @@
 #include "Agent.h"
 #include "Actor.h"
 #include "Creature.h"
+#include "CreatureController.h"
 #include "CreatureControllerManager.h"
 #include "MeshObject.h"
 #include "CreatureController.h"
@@ -50,25 +51,25 @@
         mCreature);
 }
 
-SteeringVehicle::~SteeringVehicle(void)
+SteeringVehicle::~SteeringVehicle()
 {
 }
 
 void SteeringVehicle::resetLocalSpace()
 {
 	setForward(mForwardVector);
-	setSide(localRotateForwardToSide(forward()));
+	setSide(localRotateForwardToSide(getForward()));
     setUp(Vector3::UNIT_Y);
-	Vector3 pos = mCreature->getActor()->getPosition();
+	Vector3 pos = mCreature->getPosition();
 	setPosition(pos);
-	Vector3 src = mCreature->getActor()->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+	Vector3 src = mCreature->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
 
-    // regenerate local space (by default: align vehicle's forward axis with
+    // regenerate local space(by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF ( src);
+	regenerateOrthonormalBasisUF(src);
 }
 
-void SteeringVehicle::initialize(void)
+void SteeringVehicle::initialize()
 {
     // reset LocalSpace state
 	resetLocalSpace();
@@ -76,8 +77,8 @@
     // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset();
 
-	setMaxForce (1.0f);   // steering force is clipped to this magnitude
-	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
+	setMaxForce(1.0f);   // steering force is clipped to this magnitude
+	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
 }
 
 void SteeringVehicle::addForce(const Ogre::Vector3& force)
@@ -92,23 +93,20 @@
 
 	OgreNewt::Body* body = mCreature->getActor()->getPhysicalThing()->_getBody();
 
-    Vector3 position;
-	Quaternion orientation;
-	body->getPositionOrientation(position, orientation);
-	setPosition(position);
+	setPosition(mCreature->getPosition());
 
     //  Get the velocity vector
 	mCurrentVelocity = body->getVelocity();
 	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
+	//  newVelocity = newVelocity.truncateLength(maxSpeed());
 	//  update speed
 	setSpeed(mCurrentVelocity.length());
 	Vector3 newVelocity(mCurrentVelocity);
 
-    //  regenerate local space (by default: align vehicle's forward axis with
+    //  regenerate local space(by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
-    orientation = Quaternion(mController->getYaw(), Ogre::Vector3::UNIT_Y);
+    Quaternion orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
     regenerateOrthonormalBasisUF(newUnitForward);
 
@@ -162,6 +160,10 @@
 
 
     mController->setMovement(movement, direction, rotation);
+    LOG_MESSAGE("mController->setMovement",
+        Ogre::StringConverter::toString(movement) + ", "
+        + Ogre::StringConverter::toString(direction) + ", "
+        + Ogre::StringConverter::toString(rotation));
 
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
@@ -223,7 +225,7 @@
 bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
 {
 	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
-	if(rVal == Vector3::ZERO)
+	if (rVal == Vector3::ZERO)
 	{
 		return false;
 	}
@@ -239,7 +241,7 @@
 	//{
 	//	if ((*itr) != this)
 	//	{
-	//		group.push_back( (*itr));
+	//		group.push_back((*itr));
 	//	}
 	//}
 	return group;
@@ -253,81 +255,81 @@
 
 Vector3 SteeringVehicle::getPosition()
 {
-	return position();
+	return mCreature->getPosition();
 }
 
-float SteeringVehicle::mass (void) const 
+float SteeringVehicle::getMass() const 
 {
-    return mCreature->getActor()->getPhysicalThing()->getMass();
+    return mCreature->getMass();
 }
 
-float SteeringVehicle::setMass (float m) 
+float SteeringVehicle::setMass(float m) 
 {
 	// don't set mass here TODO: throw exception
 
 	return 1;
 } 
 
-float SteeringVehicle::speed (void) const 
+float SteeringVehicle::getSpeed() const 
 {
 	return mSpeed;
 }
 
-float SteeringVehicle::setSpeed (float s) 
+float SteeringVehicle::setSpeed(float s) 
 {
-	return mSpeed = s;
+	return 1;
 }
 
-float SteeringVehicle::radius (void) const 
+float SteeringVehicle::getRadius() const 
 {
 	// this is only the radius in x axis, but i think, this is the value that should be used here
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
-    return (aab.getMaximum().x - aab.getMinimum().x)/2;
+    return(aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
-float SteeringVehicle::setRadius (float m) 
+float SteeringVehicle::setRadius(float m) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-float SteeringVehicle::height (void) const 
+float SteeringVehicle::getHeight() const 
 {
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
     return aab.getMaximum().y - aab.getMinimum().y;
 }
 
-float SteeringVehicle::setHeight (float h) 
+float SteeringVehicle::setHeight(float h) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-const Actor* SteeringVehicle::getActor(void) const  
+const Actor* SteeringVehicle::getActor() const  
 { 
 	return mCreature->getActor(); 
 }
 
-float SteeringVehicle::maxForce (void) const 
+float SteeringVehicle::getMaxForce() const 
 {
 	return 10000.0f;
 } 
 
-float SteeringVehicle::setMaxForce (float mf) 
+float SteeringVehicle::setMaxForce(float mf) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxForce = mf;
 }
 
-float SteeringVehicle::maxSpeed (void) const 
+float SteeringVehicle::getMaxSpeed() const 
 {
-	return 100000; 
+	return mController->getMaximumSpeed();
 }
 
-float SteeringVehicle::setMaxSpeed (float ms) 
+float SteeringVehicle::setMaxSpeed(float ms) 
 {
 	 // TODO: should not be set here, throw excpetion or so
-	return _maxSpeed = ms;
+	return 1;
 }
 
 const ObstacleGroup& SteeringVehicle::getObstacles() const
@@ -337,28 +339,28 @@
 
 Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
 {
-	//return position() + (velocity() * predictionTime);
-	return velocity() * predictionTime;
+	//return position() +(velocity() * predictionTime);
+	return getVelocity() * predictionTime;
 }
 
 Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3& force)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed ();
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
 
-    if ((speed () > maxAdjustedSpeed) || (force == Vector3::ZERO))
+    if ((getSpeed() > maxAdjustedSpeed) ||(force == Vector3::ZERO))
     {
         return force;
     }
     else
     {
-        const float range = speed() / maxAdjustedSpeed;
-        // const float cosine = interpolate (pow (range, 6), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 10), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 100), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 50), 1.0f, -1.0f);
-        const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle (force, cosine, forward());
+        const float range = getSpeed() / maxAdjustedSpeed;
+        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
+        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        return limitMaxDeviationAngle(force, cosine, getForward());
     }
 }
 
@@ -378,17 +380,17 @@
     LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
     lineSet->clear();
     
-    if(mDebugSteer != Vector3::ZERO)
+    if (mDebugSteer != Vector3::ZERO)
     {
         lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
         mDebugSteer = Vector3::ZERO;
     }
-    if(mDebugWander != Vector3::ZERO)
+    if (mDebugWander != Vector3::ZERO)
     {
         lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
         mDebugWander = Vector3::ZERO;
     }
-    if(mDebugAvoidObstacles != Vector3::ZERO)
+    if (mDebugAvoidObstacles != Vector3::ZERO)
     {
         lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
         mDebugAvoidObstacles = Vector3::ZERO;
@@ -399,4 +401,5 @@
 {
     mPrimitive = new LineSetPrimitive();
 }
-}
+
+} // namespace rl

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -131,6 +131,7 @@
 
         // some methods used by movements
         int getCurrentGS() const;
+        Ogre::Real getMaximumSpeed() const;
         Ogre::Vector3 getVelocity() const; // in local axes
         Ogre::Vector3 getOmega() const;
         MeshAnimation *setAnimation(const Ogre::String &name, 

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -1218,6 +1218,11 @@
         return max(act_gs,1);
     }
 
+    Ogre::Real CreatureController::getMaximumSpeed() const
+    {
+        return getCurrentGS() * 1.2; // GS = m/KR
+    }
+
     MeshAnimation *CreatureController::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName, Real weight)
     {
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());



From blakharaz at mail.berlios.de  Tue Aug 28 23:22:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 23:22:46 +0200
Subject: [Dsa-hl-svn] r3769 - in rl/trunk/engine: core script
Message-ID: <200708282122.l7SLMkKS011580@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 23:22:37 +0200 (Tue, 28 Aug 2007)
New Revision: 3769

Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/script/RlScript2005.vcproj
Log:
Fix ReleaseWithSymbols

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-08-28 21:21:18 UTC (rev 3768)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-08-28 21:22:37 UTC (rev 3769)
@@ -309,7 +309,7 @@
 				OutputFile="$(OutDir)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib"
+				AdditionalLibraryDirectories="..\common\lib\Release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib\release;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(TargetDir)$(TargetName).pdb"

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-08-28 21:21:18 UTC (rev 3768)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-08-28 21:22:37 UTC (rev 3769)
@@ -239,7 +239,7 @@
 				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="..\rules\lib\Release;..\core\lib\Release;..\ui\lib\Release;..\ai\lib\release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib\release;..\..\dependencies\NewtonSDK\sdk\dll"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"



From blakharaz at mail.berlios.de  Tue Aug 28 23:26:04 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 28 Aug 2007 23:26:04 +0200
Subject: [Dsa-hl-svn] r3770 - in rl/trunk/engine/ui: include src
Message-ID: <200708282126.l7SLQ4sM011937@sheep.berlios.de>

Author: blakharaz
Date: 2007-08-28 23:25:58 +0200 (Tue, 28 Aug 2007)
New Revision: 3770

Modified:
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
Log:
- InputManager initiates the dialog state on "start dialog" message
- renamed getCharacterController to getControlState

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-08-28 21:22:37 UTC (rev 3769)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-08-28 21:25:58 UTC (rev 3770)
@@ -78,7 +78,7 @@
         /// Remove all control states.
         void clearControlStates();
 
-        ControlState* getCharacterController() const;
+        ControlState* getControlState() const;
 
         int getModifierCode() const;
         const CEGUI::utf8& getKeyChar(int keycode, int modifiers) const;
@@ -88,6 +88,7 @@
         enum Modifiers {ALT_MASK = 1, CTRL_MASK = 2, SHIFT_MASK = 4, SUPER_MASK = 8};
 
         void initializeOis(Ogre::RenderWindow* wnd);
+        bool startDialog(/* CeGuiString dialog */);
 
         Ogre::Vector3 mSavedMouseState;
 

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-28 21:22:37 UTC (rev 3769)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-08-28 21:25:58 UTC (rev 3770)
@@ -93,7 +93,7 @@
             {
                 mesh->stopAllAnimations();
                 if (mesh->hasAnimation("idle"))
-                {
+                { 
                     mTalkAnimation = mesh->startAnimation("idle");
                 }
             }

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-08-28 21:22:37 UTC (rev 3769)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-08-28 21:25:58 UTC (rev 3770)
@@ -30,11 +30,12 @@
 #include "XmlResource.h"
 #include "XmlResourceManager.h"
 
+#include "AbstractWindow.h"
 #include "Action.h"
 #include "ActionManager.h"
 #include "Actor.h"
 #include "ActorManager.h"
-#include "AbstractWindow.h"
+#include "AiMessages.h"
 #include "ControlState.h"
 #include "CombatControlState.h"
 #include "CommandMapper.h"
@@ -130,6 +131,9 @@
         mMouse->getMouseState().width = width;
         mMouse->getMouseState().height = height;
 
+        MessagePump::getSingleton().addMessageHandler<MessageType_DialogStarted>(
+            boost::bind(&InputManager::startDialog, this/*, _1*/));
+
         LOG_DEBUG(Logger::UI, "Done initializing input manager.");
     }
 
@@ -469,7 +473,7 @@
         }
     }
 
-    ControlState* InputManager::getCharacterController() const
+    ControlState* InputManager::getControlState() const
     {
         if (!mControlStates.empty())
         {
@@ -480,4 +484,10 @@
             return NULL;
         }
     }
+
+    bool InputManager::startDialog(/* CeGuiString dialog */) 
+    {
+        pushControlState(CST_DIALOG);
+        return true;
+    }
 }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-28 21:22:37 UTC (rev 3769)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-28 21:25:58 UTC (rev 3770)
@@ -555,17 +555,17 @@
         {
             ///@todo das hier ueberpruefen!
             CeGuiString action = 
-                InputManager::getSingleton().getCharacterController()
+                InputManager::getSingleton().getControlState()
                     ->getCommandMapper()->getControlStateAction(
                     kevt.scancode,
-                    InputManager::getSingleton().getCharacterController()->getType()
+                    InputManager::getSingleton().getControlState()->getType()
                     );
             if( action == "" )
             {
-                action = InputManager::getSingleton().getCharacterController()
+                action = InputManager::getSingleton().getControlState()
                             ->getCommandMapper()->getGlobalAction(kevt.scancode);
             }
-            InputManager::getSingleton().getCharacterController()->startAction(
+            InputManager::getSingleton().getControlState()->startAction(
                 action,
                 mInventory->getOwner()
                 );

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-08-28 21:22:37 UTC (rev 3769)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-08-28 21:25:58 UTC (rev 3770)
@@ -18,41 +18,30 @@
 #include "UiSubsystem.h"
 
 #include <CEGUISystem.h>
+#include <CEGUIWindow.h>
 #include <CEGUIWindowManager.h>
 #include <OgreCEGUIRenderer.h>
 #include <OgreCEGUIResourceProvider.h>
 
-#include "Action.h"
-#include "ActionManager.h"
 #include "Actor.h"
-#include "ActorManager.h"
+#include "AiMessages.h"
+#include "CeGuiHelper.h"
 #include "ConfigurationManager.h"
 #include "CoreMessages.h"
 #include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CombatControlState.h"
-#include "CutsceneControlState.h"
-#include "DialogControlState.h"
-#include "DsaManager.h"
+#include "ControlState.h"
 #include "Exception.h"
-#include "FreeflightControlState.h"
-#include "GameObject.h"
-#include "GameLoggerWindow.h"
 #include "GameLoop.h"
 #include "InputManager.h"
-#include "ListenerMovable.h"
 #include "Logger.h"
-#include "MovementControlState.h"
 #include "Person.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"
 #include "WindowFactory.h"
 #include "WindowManager.h"
-#include "World.h"
-#include "CeGuiHelper.h"
 
-template<> rl::UiSubsystem* Singleton<rl::UiSubsystem>::ms_Singleton = 0;
 using namespace Ogre;
+template<> rl::UiSubsystem* Singleton<rl::UiSubsystem>::ms_Singleton = 0;
 
 namespace rl {
     const char* UiSubsystem::CEGUI_ROOT = "RootWindow";



From melven at mail.berlios.de  Wed Aug 29 12:47:35 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 29 Aug 2007 12:47:35 +0200
Subject: [Dsa-hl-svn] r3772 - modules/common/scripts
Message-ID: <200708291047.l7TAlZWx014326@sheep.berlios.de>

Author: melven
Date: 2007-08-29 12:47:29 +0200 (Wed, 29 Aug 2007)
New Revision: 3772

Modified:
   modules/common/scripts/global-actions.rb
Log:
-key to show worlditems in the InventoryWindow is now defined in rastullah.conf

Modified: modules/common/scripts/global-actions.rb
===================================================================
--- modules/common/scripts/global-actions.rb	2007-08-29 10:47:06 UTC (rev 3771)
+++ modules/common/scripts/global-actions.rb	2007-08-29 10:47:29 UTC (rev 3772)
@@ -254,7 +254,15 @@
   end
 end
 
+class InventoryShowWorldObjects < Action
+  def initialize
+   super("inventoryshowworldobjects", "Zeige alle greifbaren Objekte")
+  end
 
+  def doAction(object, actor, target)
+  end
+end
+
 act = ShowObjectDescriptionWindow.new()
 ActionManager.getSingleton().registerAction(act)
 
@@ -263,3 +271,6 @@
 
 act3 = ShowContainerContentAction.new()
 ActionManager.getSingleton().registerAction(act3)
+
+act4 = InventoryShowWorldObjects.new()
+ActionManager.getSingleton().registerAction(act4)



From melven at mail.berlios.de  Wed Aug 29 12:47:32 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 29 Aug 2007 12:47:32 +0200
Subject: [Dsa-hl-svn] r3771 - in rl/trunk/engine: core/src rules/src ui/src
Message-ID: <200708291047.l7TAlWsB014299@sheep.berlios.de>

Author: melven
Date: 2007-08-29 12:47:06 +0200 (Wed, 29 Aug 2007)
New Revision: 3771

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
-corrected arguments to addslot in setproperty (readyitem and holditem exchanged)
-key to show worlditems in the InventoryWindow is now defined in rastullah.conf

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-08-28 21:25:58 UTC (rev 3770)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-08-29 10:47:06 UTC (rev 3771)
@@ -112,6 +112,7 @@
         addSetting("Action keys", "toggleingameglobalmenu", "F10");
         addSetting("Action keys", "shownextdebugwindowpage", "Ctrl+M");
         addSetting("Action keys", "showobjectactions", "U");
+        addSetting("Action keys", "inventoryshowworldobjects", "Strg links");
 
         addSetting("FreeflightController keys", "back_to_character_movement", "M");
         addSetting("FreeflightController keys", "toggle_camera_collision", "F");

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-08-28 21:25:58 UTC (rev 3770)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-08-29 10:47:06 UTC (rev 3771)
@@ -309,19 +309,19 @@
                 {
                     CeGuiString bone = slotProps["bone"].toString();
                     LOG_MESSAGE("Inventory", "Add bone slot "+ bone);
-                    addSlot(name, bone.c_str(), holdItems, readyItems, SLOT_BONE);
+                    addSlot(name, bone.c_str(), readyItems, holdItems, SLOT_BONE);
                 }
                 else if (type == "submesh")
                 {
                     CeGuiString submesh = slotProps["submesh"].toString();
                     LOG_MESSAGE("Inventory", "Add submesh slot "+ submesh);
-                    addSlot(name, submesh.c_str(), holdItems, readyItems, SLOT_SUBMESH);
+                    addSlot(name, submesh.c_str(), readyItems, holdItems, SLOT_SUBMESH);
                 }
                 else if (type == "material")
                 {
                     CeGuiString submesh = slotProps["submesh"].toString();
                     LOG_MESSAGE("Inventory", "Add material slot "+ submesh);
-                    addSlot(name, submesh.c_str(), holdItems, readyItems, SLOT_MATERIAL);
+                    addSlot(name, submesh.c_str(), readyItems, holdItems, SLOT_MATERIAL);
                 }
                 else
                 {

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-28 21:25:58 UTC (rev 3770)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-08-29 10:47:06 UTC (rev 3771)
@@ -495,7 +495,20 @@
 	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &evt, bool down)
 	{
 		const KeyEventArgs& kevt = static_cast<const KeyEventArgs&>(evt);
-        if (kevt.scancode == CEGUI::Key::LeftControl)
+
+        ///@todo das hier ueberpruefen!
+        CeGuiString action = 
+            InputManager::getSingleton().getControlState()
+                ->getCommandMapper()->getControlStateAction(
+                kevt.scancode,
+                InputManager::getSingleton().getControlState()->getType()
+                );
+        if( action == "" )
+        {
+            action = InputManager::getSingleton().getControlState()
+                        ->getCommandMapper()->getGlobalAction(kevt.scancode);
+        }
+        if( action == "inventoryshowworldobjects" )
 		{
 			if (down)
 			{
@@ -553,18 +566,6 @@
 		}
         else if(!down)
         {
-            ///@todo das hier ueberpruefen!
-            CeGuiString action = 
-                InputManager::getSingleton().getControlState()
-                    ->getCommandMapper()->getControlStateAction(
-                    kevt.scancode,
-                    InputManager::getSingleton().getControlState()->getType()
-                    );
-            if( action == "" )
-            {
-                action = InputManager::getSingleton().getControlState()
-                            ->getCommandMapper()->getGlobalAction(kevt.scancode);
-            }
             InputManager::getSingleton().getControlState()->startAction(
                 action,
                 mInventory->getOwner()



From melven at mail.berlios.de  Wed Aug 29 19:44:41 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 29 Aug 2007 19:44:41 +0200
Subject: [Dsa-hl-svn] r3773 - in rl/trunk/engine/rules: include src
Message-ID: <200708291744.l7THifSY004849@sheep.berlios.de>

Author: melven
Date: 2007-08-29 19:44:31 +0200 (Wed, 29 Aug 2007)
New Revision: 3773

Modified:
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/src/Container.cpp
Log:
prevent recursive containers (backpack cannot be placed in itself any more)

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-08-29 10:47:29 UTC (rev 3772)
+++ rl/trunk/engine/rules/include/Container.h	2007-08-29 17:44:31 UTC (rev 3773)
@@ -70,8 +70,7 @@
 		 * @param item the item
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
-        bool addItem(Item* item);
-		bool addItem(Item* item, IntPair position);
+        bool addItem(Item* item, IntPair position = IntPair(0,0));
         void removeItem(Item* item);
 
         ItemSet getItems() const;
@@ -110,6 +109,12 @@
 			int xStart, 
 			int yStart, 
 			IntPair space) const;
+
+        /*
+         * recursive function
+         * @return true, if the item is this container or any of his parents
+        */
+        bool findContainerRecursion(Item* item);
     };
 }
 

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-29 10:47:29 UTC (rev 3772)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-29 17:44:31 UTC (rev 3773)
@@ -89,9 +89,29 @@
         return mItems;
     }
 
-    bool Container::addItem(Item* item)
+    bool Container::findContainerRecursion(Item* item)
     {
-        return addItem(item, findPositionWithEnoughSpace(item->getSize()));
+        if( item == this )
+            return true;
+
+        while( this->getParentContainer() )
+            if( item == this->getParentContainer() )
+                return true;
+        
+        Container* itemAsContainer = dynamic_cast<Container*>(item);
+        if( !itemAsContainer )
+        {
+            Throw(NullPointerException, "Could not cast item to Container!");
+        }
+
+        ItemSet::iterator iter = itemAsContainer->mItems.begin(); // c++ allows nasty accesses like this ;-)
+        for( ; iter != itemAsContainer->mItems.end(); iter++)
+        {
+            if( (*iter)->isContainer() )
+                if( findContainerRecursion(*iter) )
+                    return true;
+        }
+        return false;
     }
 
     bool Container::addItem(Item* item, IntPair position)
@@ -101,7 +121,14 @@
             Throw(NullPointerException, "Item ist null.");
         }
 
+        // find recursions, we cannot place the container in the same container etc
+        if( item->isContainer() )
+        {
+            if( findContainerRecursion(item) )
+                return false;
+        }
 
+
         IntPair pos = position;
 		if (!canPlaceAt(item, pos.first, pos.second))
 		{



From melven at mail.berlios.de  Wed Aug 29 19:50:06 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 29 Aug 2007 19:50:06 +0200
Subject: [Dsa-hl-svn] r3774 - rl/trunk/engine/rules/src
Message-ID: <200708291750.l7THo6qX005308@sheep.berlios.de>

Author: melven
Date: 2007-08-29 19:49:46 +0200 (Wed, 29 Aug 2007)
New Revision: 3774

Modified:
   rl/trunk/engine/rules/src/Container.cpp
Log:
fixed infinite loop (from the last commit)

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-08-29 17:44:31 UTC (rev 3773)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-08-29 17:49:46 UTC (rev 3774)
@@ -94,9 +94,13 @@
         if( item == this )
             return true;
 
-        while( this->getParentContainer() )
-            if( item == this->getParentContainer() )
+        Item* parent = this->getParentContainer();
+        while( parent )
+        {
+            if( item == parent )
                 return true;
+            parent = parent->getParentContainer();
+        }
         
         Container* itemAsContainer = dynamic_cast<Container*>(item);
         if( !itemAsContainer )



From melven at mail.berlios.de  Thu Aug 30 21:32:36 2007
From: melven at mail.berlios.de (melven at BerliOS)
Date: Thu, 30 Aug 2007 21:32:36 +0200
Subject: [Dsa-hl-svn] r3775 - in dependencies/OgreNewt: include/OgreNewt src
Message-ID: <200708301932.l7UJWaBo017867@sheep.berlios.de>

Author: melven
Date: 2007-08-30 21:32:34 +0200 (Thu, 30 Aug 2007)
New Revision: 3775

Modified:
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
Log:
added the possibility to set the colors of the collision-debuglines per material

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h	2007-08-29 17:49:46 UTC (rev 3774)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h	2007-08-30 19:32:34 UTC (rev 3775)
@@ -56,6 +56,12 @@
 
 		//! remove lines drawn.
 		void hideLines();
+
+        //! set default color
+        void setDefaultColor(Ogre::ColourValue col);
+
+        //! set Material color
+        void setMaterialColor(const MaterialID* mat, Ogre::ColourValue col);
 	
 	protected:
 		Debugger();
@@ -63,6 +69,9 @@
 	private:
 		Ogre::SceneNode*		m_debugnode;
 		Ogre::ManualObject*		m_debuglines;
+        typedef std::map<int, Ogre::ColourValue> MaterialIdColorMap;
+        MaterialIdColorMap      m_materialcolors;
+        Ogre::ColourValue       m_defaultcolor;
 
 		static void _CDECL newtonPerBody( const NewtonBody* body );
 		static void _CDECL newtonPerPoly( const NewtonBody* body, int vertexCount, const float* faceVertec, int id );

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2007-08-29 17:49:46 UTC (rev 3774)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2007-08-30 19:32:34 UTC (rev 3775)
@@ -10,6 +10,7 @@
 {
 	m_debuglines = NULL;
 	m_debugnode = NULL;
+    m_defaultcolor = Ogre::ColourValue::White;
 }
 
 Debugger::~Debugger()
@@ -43,7 +44,16 @@
 	}
 }
 
+void Debugger::setMaterialColor(const MaterialID* mat, Ogre::ColourValue col)
+{
+    m_materialcolors[mat->getID()] = col;
+}
 
+void Debugger::setDefaultColor(Ogre::ColourValue col)
+{
+    m_defaultcolor = col;
+}
+
 void Debugger::showLines( OgreNewt::World* world )
 {
 	m_debugnode->detachAllObjects();
@@ -68,6 +78,15 @@
 
 void _CDECL Debugger::newtonPerBody( const NewtonBody* body )
 {
+    Debugger& debugger (Debugger::getSingleton());
+    MaterialIdColorMap::iterator it = 
+        debugger.m_materialcolors.find( NewtonBodyGetMaterialGroupID(body) );
+
+    if( it != debugger.m_materialcolors.end() )
+        debugger.m_debuglines->colour(it->second);
+    else
+        debugger.m_debuglines->colour(debugger.m_defaultcolor);
+         
 	NewtonBodyForEachPolygonDo( body, newtonPerPoly );
 }
 



From melven at mail.berlios.de  Thu Aug 30 22:09:19 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 30 Aug 2007 22:09:19 +0200
Subject: [Dsa-hl-svn] r3776 - in rl/trunk/engine: core/include core/src
	rules/src script/swig ui/src
Message-ID: <200708302009.l7UK9Jop021248@sheep.berlios.de>

Author: melven
Date: 2007-08-30 22:09:06 +0200 (Thu, 30 Aug 2007)
New Revision: 3776

Modified:
   rl/trunk/engine/core/include/GameAreaTypes.h
   rl/trunk/engine/core/include/GameEventManager.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/ui/src/ControlState.cpp
Log:
(ogrenewt update needed!)
-added GameMeshAreaType (works with newton bodies)
-added colors for different materialIds (areas are green, creatures owned by the creaturecontroller red, camera is black, level is blue, standard is white) use 'l' to enjoy the colors :-P
-areas are not found by material-raycasts (i don't think anybody wants to raycast an area)

Modified: rl/trunk/engine/core/include/GameAreaTypes.h
===================================================================
--- rl/trunk/engine/core/include/GameAreaTypes.h	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/include/GameAreaTypes.h	2007-08-30 20:09:06 UTC (rev 3776)
@@ -17,15 +17,13 @@
 #ifndef __GameAreaTypes_H__
 #define __GameAreaTypes_H__
 
+#include "Actor.h"
 #include "CorePrerequisites.h"
+#include "CoreDefines.h"
 
-#include <OgreNewt_ContactCallback.h>
 
-#include "Actor.h"
-
 namespace rl {
 
-	class MeshObject;
 	class PhysicalThing;
 
 /** GameAreaType
@@ -57,11 +55,18 @@
     /// Setzt die genaue Position der Anfrage, wird in Unterklassen implementiert
     virtual void setQueryPosition( const Ogre::Vector3& vec ) = 0;
     /// Gibt die Position der Anfrage zur?ck, wird in Unterklassen implementiert
-    virtual const Ogre::Vector3& getQueryPosition() const = 0;
+    virtual Ogre::Vector3 getQueryPosition() const = 0;
+    /// Setzt die genaue Orientierung der Anfrage, wird in Unterklassen implementiert
+    virtual void setQueryOrientation( const Ogre::Quaternion& ori ) = 0;
+    /// Gibt die Orientierung der Anfrage zur?ck, wird in Unterklassen implementiert
+    virtual Ogre::Quaternion getQueryOrientation() const = 0;
+
     /// Blendet ein Debug-Objekt ein, um das Areal zu verdeutlichen
     //virtual setShowDebug() = 0;
     /// Gibt zur?ck ob ein Debug-Objekt eingeblendet ist
     //virtual bool getShowDebug() const = 0;
+
+    virtual OgreNewt::Body* getBody() { return NULL;}
 };
 
 /** GameSphereAreaType
@@ -91,36 +96,69 @@
      /// Setzt die genaue Position der Anfrage
     virtual void setQueryPosition( const Ogre::Vector3& vec );
     /// Gibt die Position der Anfrage zur?ck
-    virtual const Ogre::Vector3& getQueryPosition() const;    
+    virtual Ogre::Vector3 getQueryPosition() const;
+    /// Setzt die genaue Orientierung der Anfrage, wird in Unterklassen implementiert
+    virtual void setQueryOrientation( const Ogre::Quaternion& ori ) {}
+    /// Gibt die Orientierung der Anfrage zur?ck, wird in Unterklassen implementiert
+    virtual Ogre::Quaternion getQueryOrientation() const {return Ogre::Quaternion::IDENTITY;}
 private:
     /// Die Kugel-Anfrage
     Ogre::SphereSceneQuery* mSphereQuery;
 };
 
-//class _RlCoreExport GameMeshAreaType : public GameAreaType
-//{
-//public:
-//	GameMeshAreaType(MeshObject* mo, PhysicalThing* testObj); ///@todo allow character change
-//	virtual ~GameMeshAreaType();
-//
-//	virtual ActorMap performQuery();
-//
-//	/// Setzt die genaue Position der Anfrage
-//    virtual void setQueryPosition( const Ogre::Vector3& vec );
-//    /// Gibt die Position der Anfrage zur?ck
-//    virtual const Ogre::Vector3& getQueryPosition() const;   
-//
-//	/// Gibt die Anfrage-Maske zur?ck, wird in Unterklassen implementiert
-//	virtual unsigned long getQueryMask() const { return 0xFFFFFFFF; }
-//    /// Setzt die Anfrage-Maske, wird in Unterklassen implementiert
-//	virtual void setQueryMask( unsigned long mask = 0xFFFFFFFF ) {}
-//
-//private:
-//	OgreNewt::CollisionPtr mCollision;
-//	PhysicalThing* mTestObj;
-//	Ogre::Vector3 mPosition;
-//};
 
+/// ein Problem k?nnte die zeitliche Verschiebung um eine Framedauer sein, wenn position und orientation
+/// neu gesetzt werden, muss erst newton wieder upgedated werden!
+class _RlCoreExport GameNewtonBodyAreaType : 
+    public GameAreaType
+{
+public:
+    /// Konstruktor
+    GameNewtonBodyAreaType();
+
+    /// Destruktor
+    virtual ~GameNewtonBodyAreaType();
+
+    /// Implementierung der Anfrage ?ber einen SphereSceneQuery
+    virtual ActorMap performQuery(  );
+
+    /// Gibt die Anfrage-Maske zur?ck
+    virtual unsigned long getQueryMask() const;
+    /// Setzt die Anfrage-Maske
+    virtual void setQueryMask( unsigned long mask = 0xFFFFFFFF );
+
+     /// Setzt die genaue Position der Anfrage
+    virtual void setQueryPosition( const Ogre::Vector3& vec );
+    /// Gibt die Position der Anfrage zur?ck
+    virtual Ogre::Vector3 getQueryPosition() const;
+    /// Setzt die genaue Orientierung der Anfrage, wird in Unterklassen implementiert
+    virtual void setQueryOrientation( const Ogre::Quaternion& ori );
+    /// Gibt die Orientierung der Anfrage zur?ck, wird in Unterklassen implementiert
+    virtual Ogre::Quaternion getQueryOrientation() const;
+
+    virtual void foundCollision(Actor* actor);
+
+    virtual void resetFoundCollisions();
+
+    virtual OgreNewt::Body* getBody() { return mBody;}
+protected:
+    OgreNewt::Body* mBody;
+    ActorMap mFoundActors;
+    unsigned long mQueryMask;
+};
+
+
+class _RlCoreExport GameMeshAreaType :
+    public GameNewtonBodyAreaType
+{
+public:
+    GameMeshAreaType(
+            Ogre::Entity* entity,
+            const GeometryType& geomType = GT_NONE,
+			Ogre::Vector3* offset = NULL,
+			Ogre::Quaternion* orientation = NULL);
+};
+
 }
 
 #endif

Modified: rl/trunk/engine/core/include/GameEventManager.h
===================================================================
--- rl/trunk/engine/core/include/GameEventManager.h	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/include/GameEventManager.h	2007-08-30 20:09:06 UTC (rev 3776)
@@ -25,10 +25,13 @@
 #include "GameAreaEventSource.h"
 #include "GameAreaListener.h"
 #include "CorePrerequisites.h"
+#include "PhysicsGenericContactCallback.h"
 
+
 namespace rl {
 
 class PhysicalThing;
+class GameNewtonBodyAreaType;
 
 typedef std::set<GameAreaEventSource*> GameAreaEventSourceList;
 
@@ -38,7 +41,8 @@
  */
 class _RlCoreExport GameEventManager
   : public GameTask,
-    public Ogre::Singleton<GameEventManager>
+    public Ogre::Singleton<GameEventManager>,
+    public PhysicsGenericContactCallback
 {
 public:
     /** Default Constructor */
@@ -62,7 +66,7 @@
     void addSphereAreaListener( Actor* actor, Ogre::Real radius,
         GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
 
-	void addMeshAreaListener( Actor* meshactor, GameAreaListener* list, PhysicalThing* testObj );
+	void addMeshAreaListener( Actor* meshactor, GeometryType geom, GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
 
     /** Entfernt an allen Areas diesen Listener
     *
@@ -82,9 +86,19 @@
 
 	void removeQueuedDeletionSources();
 
+
+    /// newton collision callback function
+    int userProcess();
+
+    /// notify about newton world update
+    void notifyNewtonWorldUpdate();
 private:
     GameAreaEventSourceList mAreaEventSources;
 	GameAreaEventSourceList mQueuedDeletionSources;
+    typedef std::map<OgreNewt::Body*, GameNewtonBodyAreaType*> NewtonBodyGameAreaMap;
+    NewtonBodyGameAreaMap mBodyGameAreaMap;
+
+    Actor* bodyToActor(OgreNewt::Body* body);
 };
 
 }

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-08-30 20:09:06 UTC (rev 3776)
@@ -270,6 +270,9 @@
          */
         static Ogre::String convertGeometryTypeToString(const GeometryType& geomType);
 
+        /// returns newton debugger
+        OgreNewt::Debugger* getNewtonDebugger() {return mNewtonDebugger;}
+
     private:
 
         /** structure containing further information about the collision primitive.

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -19,7 +19,9 @@
 
 #include "World.h"
 #include "CoreSubsystem.h"
+#include "PhysicsManager.h"
 
+
 using namespace Ogre;
 
 namespace rl {
@@ -93,10 +95,104 @@
             mSphereQuery->setSphere( Sphere(vec,mSphereQuery->getSphere().getRadius()) );
     }
 
-    const Ogre::Vector3& GameSphereAreaType::getQueryPosition() const
+    Ogre::Vector3 GameSphereAreaType::getQueryPosition() const
     {
         return mSphereQuery->getSphere().getCenter( );
     }
 
+
+
+
+    GameNewtonBodyAreaType::GameNewtonBodyAreaType() :
+        mBody(NULL)
+    {
+    }
+
+
+    GameNewtonBodyAreaType::~GameNewtonBodyAreaType()
+    {
+        if(mBody != NULL)
+            delete mBody;
+        mBody = NULL;
+    }
+
+    unsigned long GameNewtonBodyAreaType::getQueryMask() const
+    {
+        return mQueryMask;
+    }
+
+    void GameNewtonBodyAreaType::setQueryMask(unsigned long mask)
+    {
+        mQueryMask = mask;
+    }
+
+    Quaternion GameNewtonBodyAreaType::getQueryOrientation() const
+    {
+        Vector3 pos;
+        Quaternion orient;
+        mBody->getPositionOrientation(pos, orient);
+        return orient;
+    }
+
+    Vector3 GameNewtonBodyAreaType::getQueryPosition() const
+    {
+        Vector3 pos;
+        Quaternion orient;
+        mBody->getPositionOrientation(pos, orient);
+        return pos;
+    }
+
+    void GameNewtonBodyAreaType::setQueryPosition(const Vector3 &pos)
+    {
+        Quaternion orient;
+        Vector3 old_pos;
+        mBody->getPositionOrientation(old_pos, orient);
+        mBody->setPositionOrientation(pos, orient);
+    }
+
+    void GameNewtonBodyAreaType::setQueryOrientation(const Quaternion &orient)
+    {
+        Quaternion old_orient;
+        Vector3 pos;
+        mBody->getPositionOrientation(pos, old_orient);
+        mBody->setPositionOrientation(pos, orient);
+    }
+
+    void GameNewtonBodyAreaType::foundCollision(Actor* actor)
+    {
+        if( actor )
+        {
+            if( actor->getQueryFlags() & mQueryMask )
+                mFoundActors[actor->getName()] = actor;
+        }
+    }
+
+    void GameNewtonBodyAreaType::resetFoundCollisions()
+    {
+        mFoundActors.clear();
+    }
+
+    ActorMap GameNewtonBodyAreaType::performQuery()
+    {
+        return mFoundActors;
+    }
+
+    GameMeshAreaType::GameMeshAreaType(
+            Ogre::Entity* entity,
+            const GeometryType& geomType,
+			Ogre::Vector3* offset,
+			Ogre::Quaternion* orientation)
+    {
+        OgreNewt::CollisionPtr col =
+            PhysicsManager::getSingleton().createCollision(entity,
+            geomType, "", offset, orientation);
+        mBody = new OgreNewt::Body(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            col);
+        mBody->setMaterialGroupID(
+            PhysicsManager::getSingleton().getMaterialID("gamearea"));
+        mBody->setUserData(NULL);
+    }
+
 }
 

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -19,6 +19,8 @@
 #include "GameAreaTypes.h"
 #include "ScriptWrapper.h"
 #include "CoreSubsystem.h"
+#include "MeshObject.h"
+#include "PhysicsManager.h"
 
 
 template<> rl::GameEventManager* Ogre::Singleton<rl::GameEventManager>::ms_Singleton = 0;
@@ -29,11 +31,41 @@
         mAreaEventSources(),
 		mQueuedDeletionSources()
     {
+        // set newton collision callback
+        PhysicsManager* physicsManager = PhysicsManager::getSingletonPtr();
 
+        const OgreNewt::MaterialID *area_mat = physicsManager->createMaterialID("gamearea");
+        const OgreNewt::MaterialID *char_mat = physicsManager->createMaterialID("character");
+        const OgreNewt::MaterialID *def_mat = physicsManager->createMaterialID("default");
+        const OgreNewt::MaterialID *cam_mat = physicsManager->createMaterialID("camera");
+        const OgreNewt::MaterialID *lev_mat = physicsManager->createMaterialID("level");
+
+        physicsManager->createMaterialPair(area_mat, char_mat)->setContactCallback(this);
+        physicsManager->createMaterialPair(area_mat, def_mat)->setContactCallback(this);
+        physicsManager->createMaterialPair(area_mat, cam_mat)->setDefaultCollidable(0);// ->setContactCallback(this);
+        physicsManager->createMaterialPair(area_mat, lev_mat)->setDefaultCollidable(0);// ->setContactCallback(this);
+
+        // set collision-debug color
+        physicsManager->getNewtonDebugger()->setMaterialColor(area_mat, Ogre::ColourValue::Green);
     }
 
     GameEventManager::~GameEventManager( )
     {
+        // remove collision callbacks
+        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
+
+        const OgreNewt::MaterialID *area_mat = physicsManager->createMaterialID("gamearea");
+        const OgreNewt::MaterialID *char_mat = physicsManager->createMaterialID("character");
+        const OgreNewt::MaterialID *def_mat = physicsManager->createMaterialID("default");
+        const OgreNewt::MaterialID *cam_mat = physicsManager->createMaterialID("camera");
+        const OgreNewt::MaterialID *lev_mat = physicsManager->createMaterialID("level");
+
+        physicsManager->resetMaterialPair(area_mat, char_mat);
+        physicsManager->resetMaterialPair(area_mat, def_mat);
+        physicsManager->resetMaterialPair(area_mat, cam_mat);
+        physicsManager->resetMaterialPair(area_mat, lev_mat);
+
+
         GameAreaEventSourceList::iterator it;
         for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();++it)
         {
@@ -44,6 +76,7 @@
         }
         mAreaEventSources.clear();
 		mQueuedDeletionSources.clear();
+        mBodyGameAreaMap.clear();
     }
 
 	/// @todo  Doppelte Aktoren nachnutzen??
@@ -61,6 +94,28 @@
         gam->addAreaListener( list );
     }
 
+    void GameEventManager::addMeshAreaListener( Actor* actor, GeometryType geom, GameAreaListener* list, unsigned long queryMask )
+    {
+        // neues areal ereugen
+        MeshObject* meshObj = static_cast<MeshObject*>(actor->getControlledObject());
+
+        GameNewtonBodyAreaType* at = new GameMeshAreaType(
+            meshObj->getEntity(), geom);
+
+        at->setQueryMask(queryMask);
+
+        // Event-Quelle erzeugen
+        GameAreaEventSource* gam = new GameAreaEventSource( at, actor );
+        // In die Menge einf?gen
+        mAreaEventSources.insert( gam );
+		ScriptWrapper::getSingleton().owned( gam );
+        // Und Listener anh?ngen
+        gam->addAreaListener( list );
+
+        // add to newton collision list
+        mBodyGameAreaMap.insert(std::make_pair(at->getBody(), at));
+    }
+
     void GameEventManager::removeAreaListener( GameAreaListener* list )
     {
         GameAreaEventSourceList::iterator it;
@@ -110,6 +165,15 @@
 			ScriptWrapper::getSingleton().deleted( gam );
 			mQueuedDeletionSources.erase(mQueuedDeletionSources.begin());
 
+            // gegebenenfalls bodymap-eintrag l?schen
+            if( gam->getGameAreaType()->getBody() )
+            {
+                NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(gam->getGameAreaType()->getBody());
+                if( it != mBodyGameAreaMap.end() )
+                    mBodyGameAreaMap.erase(it);
+            }
+
+			ScriptWrapper::getSingleton().deleted( gam );
 			// Die Area-Art l?schen
 			delete gam->getGameAreaType();
 			// Das Objekt l?schen
@@ -136,4 +200,36 @@
 
         return NAME;
     }
+
+    int GameEventManager::userProcess()
+    {
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
+        if( it != mBodyGameAreaMap.end() )
+        {
+            it->second->foundCollision(bodyToActor(m_body1));
+            return false;
+        }
+
+        it = mBodyGameAreaMap.find(m_body1);
+        if( it != mBodyGameAreaMap.end() )
+        {
+            it->second->foundCollision(bodyToActor(m_body0));
+            return 0;
+        }
+
+        LOG_WARNING(Logger::CORE, "Der Kollisionsk?rper konne keiner GameArea zugeordnet werden!");
+        return 0;
+    }
+
+    void GameEventManager::notifyNewtonWorldUpdate()
+    {
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.begin();
+        for( ; it != mBodyGameAreaMap.end(); it++ )
+            it->second->resetFoundCollisions();
+    }
+
+    Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
+    {
+        return static_cast<Actor*>(body->getUserData());
+    }
 }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -21,6 +21,7 @@
 #include "ActorManager.h"
 #include "CoreSubsystem.h"
 #include "Exception.h"
+#include "GameEventManager.h"
 #include "PhysicsController.h"
 #include "PhysicsGenericContactCallback.h"
 #include "PhysicalObject.h"
@@ -69,7 +70,7 @@
 
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
-        mNewtonDebugger(),
+        mNewtonDebugger(&OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
         mDebugMode(false),
         mGravity(0, -9.81, 0),
@@ -97,6 +98,8 @@
         // setup level material
         createMaterialID("level");
 
+        mNewtonDebugger->setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
+
         // below here starts 'old' stale fix code that should be removed
 
         // setup level quadtree extents
@@ -141,6 +144,10 @@
         mElapsed += elapsedTime;
         while( mElapsed >= mMaxTimestep)
         {
+            // perhaps we should add a newtonupdate listener, but i don't
+            // know if it's really neccessary
+            GameEventManager::getSingleton().notifyNewtonWorldUpdate();
+
             mWorld->update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
 #ifdef _DEBUG
@@ -156,6 +163,10 @@
         }
         if( mElapsed > mMinTimestep)
         {
+            // perhaps we should add a newtonupdate listener, but i don't
+            // know if it's really neccessary
+            GameEventManager::getSingleton().notifyNewtonWorldUpdate();
+
             mWorld->update(mElapsed);
             mElapsed = 0;
 #ifdef _DEBUG

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -16,6 +16,7 @@
 #include "stdinc.h" //precompiled header
 
 #include "PhysicsMaterialRaycast.h"
+#include "PhysicsManager.h"
 
 using namespace Ogre;
 using namespace OgreNewt;
@@ -70,6 +71,9 @@
             mGetNearest = true;
             LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
         }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+        }
         else
         {
             if( mMaterial == NULL && mMaterialVector == NULL)

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -49,6 +49,8 @@
         
         physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0,0);
         physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0,0);
+
+        physicsManager->getNewtonDebugger()->setMaterialColor(char_mat, Ogre::ColourValue::Red);
     }
 
     CreatureControllerManager::~CreatureControllerManager()

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-08-30 20:09:06 UTC (rev 3776)
@@ -242,7 +242,8 @@
 public:
     void addSphereAreaListener( rl::Actor* actor, Ogre::Real radius, 
 		rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
-	//void addMeshAreaListener( rl::Actor* meshactor, rl::GameAreaListener* list, rl::PhysicalThing* testObj );
+	void addMeshAreaListener( rl::Actor* meshactor, rl::GeometryType geom, 
+	    rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
 	
     void removeAreaListener( rl::GameAreaListener* list );
     void removeAllAreas( rl::Actor* actor );

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2007-08-30 19:32:34 UTC (rev 3775)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2007-08-30 20:09:06 UTC (rev 3776)
@@ -100,6 +100,10 @@
         PhysicsManager::getSingleton().createMaterialPair(
             PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
+
+        PhysicsManager::getSingleton().getNewtonDebugger()->setMaterialColor(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            Ogre::ColourValue::Black);
 	}
 
     ControlState::~ControlState()



From melven at mail.berlios.de  Thu Aug 30 22:09:40 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 30 Aug 2007 22:09:40 +0200
Subject: [Dsa-hl-svn] r3777 - modules/common/gui/windows
Message-ID: <200708302009.l7UK9eFg021296@sheep.berlios.de>

Author: melven
Date: 2007-08-30 22:09:32 +0200 (Thu, 30 Aug 2007)
New Revision: 3777

Modified:
   modules/common/gui/windows/inventory_default.xml
   modules/common/gui/windows/inventory_human.xml
Log:
changed size of inventorywindow

Modified: modules/common/gui/windows/inventory_default.xml
===================================================================
--- modules/common/gui/windows/inventory_default.xml	2007-08-30 20:09:06 UTC (rev 3776)
+++ modules/common/gui/windows/inventory_default.xml	2007-08-30 20:09:32 UTC (rev 3777)
@@ -6,7 +6,7 @@
 	    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
 			<Property Name="VerticalAlignment" Value="Centre" />
 			<Property Name="HorizontalAlignment" Value="Centre" />
-			<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
+			<Property Name="UnifiedSize" Value="{{0,380},{0,560}}" />
 			<Property Name="Text" Value="Inventar" />
 			
 			<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">

Modified: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-08-30 20:09:06 UTC (rev 3776)
+++ modules/common/gui/windows/inventory_human.xml	2007-08-30 20:09:32 UTC (rev 3777)
@@ -6,7 +6,7 @@
 	    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
 			<Property Name="VerticalAlignment" Value="Bottom" />
 			<Property Name="HorizontalAlignment" Value="Left" />
-			<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
+			<Property Name="UnifiedSize" Value="{{0,380},{0,560}}" />
 			<Property Name="Text" Value="Inventar" />
 			
 			<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">



From melven at mail.berlios.de  Thu Aug 30 22:10:36 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 30 Aug 2007 22:10:36 +0200
Subject: [Dsa-hl-svn] r3778 - in modules/regressiontest: dsa scripts
	scripts/maps
Message-ID: <200708302010.l7UKAabA021358@sheep.berlios.de>

Author: melven
Date: 2007-08-30 22:10:27 +0200 (Thu, 30 Aug 2007)
New Revision: 3778

Added:
   modules/regressiontest/scripts/MeshAreaTest.rb
Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
added test for meshareas in regressiontest

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-30 20:09:32 UTC (rev 3777)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-08-30 20:10:27 UTC (rev 3778)
@@ -142,5 +142,11 @@
         <property name="geometrytype" type="STRING" data="box"/>
         <property name="material" type="STRING" data="obj_Shortsleeve_2"/>
     </gameobjectclass>
+
+    <gameobjectclass classid="MeshAreaTestHouse" baseclass="GameObject">
+        <property name="name" type="STRING" data="MeshAreaTestHouse"/>
+	<property name="meshfile" type="STRING" data="arc_Wirtshaus_02.mesh"/>
+	<property name="geometrytype" type="STRING" data="none"/>
+    </gameobjectclass>
 	
 </GameObjectDefinitions>

Added: modules/regressiontest/scripts/MeshAreaTest.rb
===================================================================
--- modules/regressiontest/scripts/MeshAreaTest.rb	2007-08-30 20:09:32 UTC (rev 3777)
+++ modules/regressiontest/scripts/MeshAreaTest.rb	2007-08-30 20:10:27 UTC (rev 3778)
@@ -0,0 +1,26 @@
+require 'testcase.rb'
+
+class MeshAreaListener < GameAreaListener
+    def initialize()
+        super()
+    end
+
+    def areaEntered( anEvent )
+        print "Area Entered"
+    end
+    
+    def areaLeft( anEvent )
+        print "Area Left"
+    end
+end
+
+class MeshAreaTest < TestCase
+  def execute()
+    testObj = $GOM.createGameObject("MeshAreaTestHouse")
+    testObj.setPosition(@center)
+    testObj.placeIntoScene()
+
+    listener = MeshAreaListener.new()
+    $GameEveMgr.addMeshAreaListener(testObj.getActor(), GT_CONVEXHULL, listener)
+  end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-08-30 20:09:32 UTC (rev 3777)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-08-30 20:10:27 UTC (rev 3778)
@@ -37,6 +37,7 @@
 require 'MergeableMeshTest.rb'
 require 'WalkJobTest.rb'
 require 'SelectorTest.rb'
+require 'MeshAreaTest.rb'
 
 
  MaterialSlotTest.new([-15, 0, -5]).run()
@@ -54,6 +55,7 @@
        EffectTest.new([  5, 0, 5]).run()
 MergeableMeshTest.new([ 10, 0, 0]).run()
         SoundTest.new([ 10, 0, 10]).run()
+     MeshAreaTest.new([-50, 0,-55]).run()
 
 $SCRIPT.log("tests initialisiert.");
 



From chrber at mail.berlios.de  Fri Aug 31 22:39:55 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Fri, 31 Aug 2007 22:39:55 +0200
Subject: [Dsa-hl-svn] r3779 - in dependencies/opensteer: . include/OpenSteer
	src
Message-ID: <200708312039.l7VKdteW020555@sheep.berlios.de>

Author: chrber
Date: 2007-08-31 22:39:52 +0200 (Fri, 31 Aug 2007)
New Revision: 3779

Modified:
   dependencies/opensteer/configure.in
   dependencies/opensteer/include/OpenSteer/Annotation.h
   dependencies/opensteer/src/Makefile.am
Log:
Added check for Ogre
Corrected function declarations and added a missing function declaration to make gcc happy


Modified: dependencies/opensteer/configure.in
===================================================================
--- dependencies/opensteer/configure.in	2007-08-30 20:10:27 UTC (rev 3778)
+++ dependencies/opensteer/configure.in	2007-08-31 20:39:52 UTC (rev 3779)
@@ -44,6 +44,8 @@
 # Pthreads
 CXXFLAGS="$CXXFLAGS -pthread"
 
+# Ogre
+PKG_CHECK_MODULES([OGRE], [OGRE >= 1.4.0])
 
 dnl Create the makefiles
 AC_CONFIG_FILES([Makefile \

Modified: dependencies/opensteer/include/OpenSteer/Annotation.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-30 20:10:27 UTC (rev 3778)
+++ dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-31 20:39:52 UTC (rev 3779)
@@ -59,6 +59,12 @@
     extern bool enableAnnotation;
     extern bool drawPhaseActive;
 
+    // Declaration has to be here for GCC (tested with 4.1.1)
+    void drawLineAlpha (const Vector3& startPoint,
+                        const Vector3& endPoint,
+                        const Color& color,
+                        const float alpha);
+
     // graphical annotation: master on/off switch
     inline bool annotationIsOn (void) {return enableAnnotation;}
     inline void setAnnotationOn (void) {enableAnnotation = true;}
@@ -400,7 +406,7 @@
 }
 #else
 template<class Super> void OpenSteer::AnnotationMixin<Super>::annotationLine
- (const Vector3&, const Vector3&, const Vector3&) const {}
+ (const Vector3&, const Vector3&, const Color&) const {}
 #endif // NOT_OPENSTEERDEMO
 
 
@@ -440,7 +446,7 @@
 #else
 template<class Super>
 void OpenSteer::AnnotationMixin<Super>::annotationCircleOrDisk
-(const float, const Vector3&, const Vector3&, const Vector3&, const int,
+(const float, const Vector3&, const Vector3&, const Color&, const int,
  const bool, const bool) const {}
 #endif // NOT_OPENSTEERDEMO
 

Modified: dependencies/opensteer/src/Makefile.am
===================================================================
--- dependencies/opensteer/src/Makefile.am	2007-08-30 20:10:27 UTC (rev 3778)
+++ dependencies/opensteer/src/Makefile.am	2007-08-31 20:39:52 UTC (rev 3779)
@@ -1,9 +1,10 @@
-INCLUDES =  -I. -I../include
+INCLUDES =  -I. -I../include $(OGRE_CFLAGS)
 
 lib_LTLIBRARIES = libOpenSteer.la
 libOpenSteer_la_LDFLAGS =  $(LIBS)
 libOpenSteer_la_SOURCES = \
 	lq.c \
+	Camera.cpp \
 	Clock.cpp \
 	Color.cpp \
 	Obstacle.cpp \
@@ -12,11 +13,9 @@
 	Pathway.cpp \
 	PlugIn.cpp \
 	PolylineSegmentedPath.cpp \
-	PolylineSegmentedPathwaySegmentRadii.cpp \
 	PolylineSegmentedPathwaySingleRadius.cpp \
 	SegmentedPath.cpp \
 	SegmentedPathway.cpp \
+	SimpleVehicle.cpp \
 	Vec3.cpp \
 	Vec3Utilities.cpp 
-
-	
\ No newline at end of file



