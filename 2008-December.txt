From blakharaz at mail.berlios.de  Mon Dec  1 00:53:20 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 00:53:20 +0100
Subject: [Dsa-hl-svn] r4617 - in rl/trunk/engine/ui: include src
Message-ID: <200811302353.mAUNrKJP007129@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 00:53:17 +0100 (Mon, 01 Dec 2008)
New Revision: 4617

Modified:
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/GameSettings.h
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
Log:
More video settings in the settings dialog (not changeable for now)

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2008-11-30 22:46:52 UTC (rev 4616)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2008-11-30 23:53:17 UTC (rev 4617)
@@ -22,6 +22,7 @@
 
 #include <CEGUIWindow.h>
 #include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIRadioButton.h>
 #include <elements/CEGUIEditbox.h>
 #include <elements/CEGUIListbox.h>
 #include <elements/CEGUIMultiColumnList.h>
@@ -77,6 +78,7 @@
 		CEGUI::MenuBase* getMenu(const char* name);
 		CEGUI::MenuItem* getMenuItem(const char* name);
 		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::RadioButton* getRadioButton(const char* name);
 		CEGUI::Combobox* getCombobox(const char* name);
 		CEGUI::ComboDropList* getComboDropList(const char* name);
         CEGUI::ScrollablePane* getScrollablePane(const char* name);

Modified: rl/trunk/engine/ui/include/GameSettings.h
===================================================================
--- rl/trunk/engine/ui/include/GameSettings.h	2008-11-30 22:46:52 UTC (rev 4616)
+++ rl/trunk/engine/ui/include/GameSettings.h	2008-11-30 23:53:17 UTC (rev 4617)
@@ -84,7 +84,12 @@
 		bool onRenderSystemChanged();
         
         void update();
-
+        
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Checkbox* checkbox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Combobox* combobox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, std::vector<CEGUI::RadioButton*> radioGroup);
+        void createElements(CEGUI::Combobox* combobox, size_t count);
+        
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
@@ -93,6 +98,9 @@
         CEGUI::Combobox* mVideoRenderer;
         CEGUI::Combobox* mVideoResolution;
         CEGUI::Checkbox* mVideoFullscreen;
+        CEGUI::RadioButton* mVideoColorDepth32, *mVideoColorDepth16;
+        CEGUI::RadioButton* mVideoFsaa0, *mVideoFsaa2, *mVideoFsaa4, *mVideoFsaa8;
+        CEGUI::RadioButton* mVideoRttModeFBO, *mVideoRttModePBuffer, *mVideoRttModeCopy;
 	};
 }
 

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2008-11-30 23:53:17 UTC (rev 4617)
@@ -232,7 +232,12 @@
 	{
 		return static_cast<PushButton*>(getWindow(name, "PushButton"));
 	}
-
+    
+	RadioButton* AbstractWindow::getRadioButton(const char* name)
+	{
+		return static_cast<RadioButton*>(getWindow(name, "RadioButton"));
+	}
+    
 	Combobox* AbstractWindow::getCombobox(const char* name)
 	{
 		return static_cast<Combobox*>(getWindow(name, "Combobox"));

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2008-11-30 22:46:52 UTC (rev 4616)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2008-11-30 23:53:17 UTC (rev 4617)
@@ -18,14 +18,22 @@
 #include "GameSettings.h"
 
 #include <boost/bind.hpp>
+#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#include <CEGUI/elements/CEGUIFrameWindow.h>
+#include <CEGUI/elements/CEGUIListboxTextItem.h>
+#else
 #include <elements/CEGUIFrameWindow.h>
 #include <elements/CEGUIListboxTextItem.h>
+#endif
+
 #include <iostream>
 
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
 using namespace Ogre;
+using namespace CEGUI;
+using namespace std;
 
 namespace rl
 {
@@ -51,6 +59,37 @@
         mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
         mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
         mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
+        
+        mVideoColorDepth32 = getRadioButton("GameOptionsWindow/Video/ColorDepth/32");
+        mVideoColorDepth32->setUserData(new Ogre::String("32"));
+        mVideoColorDepth32->setGroupID(1);
+        mVideoColorDepth16 = getRadioButton("GameOptionsWindow/Video/ColorDepth/16");
+        mVideoColorDepth16->setUserData(new Ogre::String("16"));
+        mVideoColorDepth16->setGroupID(1);
+        
+        mVideoFsaa0 = getRadioButton("GameOptionsWindow/Video/FSAA/Off");
+        mVideoFsaa0->setUserData(new Ogre::String("0"));
+        mVideoFsaa0->setGroupID(2);
+        mVideoFsaa2 = getRadioButton("GameOptionsWindow/Video/FSAA/2x");
+        mVideoFsaa2->setUserData(new Ogre::String("2"));
+        mVideoFsaa2->setGroupID(2);
+        mVideoFsaa4 = getRadioButton("GameOptionsWindow/Video/FSAA/4x");
+        mVideoFsaa4->setUserData(new Ogre::String("4"));
+        mVideoFsaa4->setGroupID(2);
+        mVideoFsaa8 = getRadioButton("GameOptionsWindow/Video/FSAA/8x");
+        mVideoFsaa8->setUserData(new Ogre::String("8"));
+        mVideoFsaa8->setGroupID(2);
+        
+        mVideoRttModeFBO = getRadioButton("GameOptionsWindow/Video/RTT/FBO");
+        mVideoRttModeFBO->setUserData(new Ogre::String("FBO"));
+        mVideoRttModeFBO->setGroupID(3);
+        mVideoRttModePBuffer = getRadioButton("GameOptionsWindow/Video/RTT/PBuffer");
+        mVideoRttModePBuffer->setUserData(new Ogre::String("PBuffer"));
+        mVideoRttModePBuffer->setGroupID(3);
+        mVideoRttModeCopy = getRadioButton("GameOptionsWindow/Video/RTT/Copy");
+        mVideoRttModeCopy->setUserData(new Ogre::String("Copy"));
+        mVideoRttModeCopy->setGroupID(3);
+        
         centerWindow();
         setVisible(false);
         update();
@@ -137,50 +176,124 @@
     void GameSettings::update()
     {
         Root* root = Ogre::Root::getSingletonPtr();
+        
+        RenderSystemList* renderers = root->getAvailableRenderers();
         RenderSystem* renderer = root->getRenderSystem();
         
+        createElements(mVideoRenderer, renderers->size());
+
+        for (int i = 0; i < renderers->size(); ++i)
+        {
+            RenderSystem* cur = renderers->operator[](i);
+            ListboxItem* item = mVideoRenderer->getListboxItemFromIndex(i);
+            item->setText(cur->getName());
+            if (cur == renderer)
+            {
+                mVideoRenderer->setItemSelectState(item, true);
+            }
+        }
+        
         ConfigOptionMap config = renderer->getConfigOptions();
         
-		ConfigOptionMap::iterator cfi;
-		
-		cfi = config.find( "Full Screen" );
-		if( cfi != config.end() )
-		{
-			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
-		}
+        setOption(config, "Full Screen", mVideoFullscreen);
+        vector<RadioButton*> videoColorDepth;
+        videoColorDepth.push_back(mVideoColorDepth32);
+        videoColorDepth.push_back(mVideoColorDepth16);
         
-/*		cfi = config.find( "FSAA" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "0" )
-			{
-				SetControlValue( iFSAARef, 1 );
-			}
-			else if( cfi->second.currentValue == "2" )
-			{
-				SetControlValue( iFSAARef, 2 );
-			}
-			else if( cfi->second.currentValue == "4" )
-			{
-				SetControlValue( iFSAARef, 3 );
-			}
-			else if( cfi->second.currentValue == "6" )
-			{
-				SetControlValue( iFSAARef, 4 );
-			}
-		}
+        setOption(config, "Colour Depth", videoColorDepth);
+        vector<RadioButton*> videoAntiAliasing;
+        videoAntiAliasing.push_back(mVideoFsaa0);
+        videoAntiAliasing.push_back(mVideoFsaa2);
+        videoAntiAliasing.push_back(mVideoFsaa4);
+        videoAntiAliasing.push_back(mVideoFsaa8);
+        setOption(config, "FSAA", videoAntiAliasing);
         
-		cfi = config.find( "Colour Depth" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "32" )
-			{
-				SetControlValue( iColorDepthRef, 1 );
-			}
-			else
-			{
-				SetControlValue( iColorDepthRef, 2 );
-			}
-		}*/
+        vector<RadioButton*> videoRttMode;
+        videoRttMode.push_back(mVideoRttModeFBO);
+        videoRttMode.push_back(mVideoRttModePBuffer);
+        videoRttMode.push_back(mVideoRttModeCopy);
+        setOption(config, "RTT Preferred Mode", videoRttMode);
+        
+        setOption(config, "Video Mode", mVideoResolution);
     }
+    
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Checkbox* checkbox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            checkbox->setSelected(cfi->second.currentValue == "Yes");            
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Combobox* combobox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            int delta = curOption.possibleValues.size() - combobox->getItemCount();
+            if (delta > 0)
+            {
+                for (int i = 0; i < delta; ++i)
+                {
+                    combobox->addItem(new ListboxTextItem(""));
+                }
+            }
+            else if (delta < 0)
+            {
+                for (int i = 0; i < -delta; ++i)
+                {
+                    ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                    combobox->removeItem(item);
+                    delete item;
+                }
+            }
+            
+            for (int i = 0; i < combobox->getItemCount(); ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(i);
+                item->setText(curOption.possibleValues[i]);
+            }
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, std::vector<RadioButton*> radioGroup)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            for (std::vector<RadioButton*>::const_iterator it = radioGroup.begin(); it != radioGroup.end(); ++it)
+            {
+                Ogre::String* value = static_cast<Ogre::String*>((*it)->getUserData());
+                if (value && (*value == curOption.currentValue))
+                {
+                    (*it)->setSelected(true);
+                    break;
+                }
+            }
+        }
+    }
+    
+    void GameSettings::createElements(CEGUI::Combobox* combobox, size_t count)
+    {
+        int delta = count - combobox->getItemCount();
+        if (delta > 0)
+        {
+            for (int i = 0; i < delta; ++i)
+            {
+                combobox->addItem(new ListboxTextItem(""));
+            }
+        }
+        else if (delta < 0)
+        {
+            for (int i = 0; i < -delta; ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                combobox->removeItem(item);
+                delete item;
+            }
+        }
+    }    
 }



From blakharaz at mail.berlios.de  Mon Dec  1 00:53:30 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 00:53:30 +0100
Subject: [Dsa-hl-svn] r4618 - in modules/common/gui: imagesets windows
Message-ID: <200811302353.mAUNrU8e007387@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 00:53:28 +0100 (Mon, 01 Dec 2008)
New Revision: 4618

Modified:
   modules/common/gui/imagesets/RastullahLook.imageset
   modules/common/gui/windows/gamesettings.xml
Log:
More video settings in the settings dialog (not changeable for now)

Modified: modules/common/gui/imagesets/RastullahLook.imageset
===================================================================
--- modules/common/gui/imagesets/RastullahLook.imageset	2008-11-30 23:53:17 UTC (rev 4617)
+++ modules/common/gui/imagesets/RastullahLook.imageset	2008-11-30 23:53:28 UTC (rev 4618)
@@ -320,11 +320,11 @@
 
     <Image Name="CheckboxNormal" XPos="110" YPos="2" Width="12" Height="12" />
     <Image Name="CheckboxHover" XPos="110" YPos="30" Width="12" Height="12" />
-    <Image Name="CheckboxMark" XPos="110" YPos="16" Width="12" Height="12" />
+    <Image Name="CheckboxMark" XPos="126" YPos="320" Width="12" Height="12" />
     
     <Image Name="RadioButtonNormal" XPos="124" YPos="2" Width="12" Height="12" />
     <Image Name="RadioButtonHover" XPos="124" YPos="30" Width="12" Height="12" />
-    <Image Name="RadioButtonMark" XPos="124" YPos="16" Width="12" Height="12" />
+    <Image Name="RadioButtonMark" XPos="126" YPos="320" Width="12" Height="12" />
     
 
 

Modified: modules/common/gui/windows/gamesettings.xml
===================================================================
--- modules/common/gui/windows/gamesettings.xml	2008-11-30 23:53:17 UTC (rev 4617)
+++ modules/common/gui/windows/gamesettings.xml	2008-11-30 23:53:28 UTC (rev 4618)
@@ -20,38 +20,108 @@
             <Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
             <Property Name="Text" Value="Video"/>
 
-            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/LabelRenderer">
+            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/RendererLabel">
                <Property Name="UnifiedPosition" Value="{{0.05,0},{0.05,0}}"/>
                <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
-               <Property Name="Text" Value="Rendersystem"/>
+               <Property Name="Text" Value="Renderer"/>
             </Window>
 
-            <Window Type="RastullahLook/Combobox" Name="GameOptionsWindow/Video/TableRenderer">
+            <Window Type="RastullahLook/Combobox" Name="GameOptionsWindow/Video/Renderer">
                <Property Name="UnifiedPosition" Value="{{0.25,0},{0.05,0}}"/>
-               <Property Name="UnifiedSize" Value="{{0.7,0},{0,50}}"/>
+               <Property Name="UnifiedSize" Value="{{0.7,0},{0,200}}"/>
+               <Property Name="ReadOnly" Value="True"/>
             </Window>
 
-            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/LabelResolution">
+            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/ResolutionLabel">
                <Property Name="UnifiedPosition" Value="{{0.05,0},{0.15,0}}"/>
                <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
                <Property Name="Text" Value="Resolution"/>
             </Window>
 
-            <Window Type="RastullahLook/Combobox" Name="GameOptionsWindow/Video/TableResolution">
+            <Window Type="RastullahLook/Combobox" Name="GameOptionsWindow/Video/Resolution">
                <Property Name="UnifiedPosition" Value="{{0.25,0},{0.15,0}}"/>
-               <Property Name="UnifiedSize" Value="{{0.7,0},{0,50}}"/>
+               <Property Name="UnifiedSize" Value="{{0.7,0},{0,200}}"/>
+               <Property Name="ReadOnly" Value="True"/>
             </Window>
 
-            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/LabelFullscreen">
-               <Property Name="UnifiedPosition" Value="{{0.05,0},{0.25,0}}"/>
+            <Window Type="RastullahLook/Checkbox" Name="GameOptionsWindow/Video/Fullscreen">
+               <Property Name="UnifiedPosition" Value="{{0.25,0},{0.25,0}}"/>
                <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
                <Property Name="Text" Value="Fullscreen"/>
             </Window>
 
-            <Window Type="RastullahLook/Checkbox" Name="GameOptionsWindow/Video/Fullscreen">
-               <Property Name="UnifiedPosition" Value="{{0.25,0},{0.25,0}}"/>
-               <Property Name="UnifiedSize" Value="{{0,20},{0,20}}"/>
+            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/FSAA">
+               <Property Name="UnifiedPosition" Value="{{0.05,0},{0.35,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="FSAA"/>
             </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/FSAA/Off">
+               <Property Name="UnifiedPosition" Value="{{0.25,0},{0.35,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="Off"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/FSAA/2x">
+               <Property Name="UnifiedPosition" Value="{{0.25,50},{0.35,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="2x"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/FSAA/4x">
+               <Property Name="UnifiedPosition" Value="{{0.25,100},{0.35,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="4x"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/FSAA/8x">
+               <Property Name="UnifiedPosition" Value="{{0.25,150},{0.35,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="8x"/>
+            </Window>
+
+            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/RTT">
+               <Property Name="UnifiedPosition" Value="{{0.05,0},{0.45,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="RTT Mode"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/RTT/FBO">
+               <Property Name="UnifiedPosition" Value="{{0.25,0},{0.45,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="FBO"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/RTT/PBuffer">
+               <Property Name="UnifiedPosition" Value="{{0.25,60},{0.45,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="PBuffer"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/RTT/Copy">
+               <Property Name="UnifiedPosition" Value="{{0.25,120},{0.45,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="Copy"/>
+            </Window>
+            
+            <Window Type="RastullahLook/StaticText" Name="GameOptionsWindow/Video/ColorDepth">
+               <Property Name="UnifiedPosition" Value="{{0.05,0},{0.55,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="Color Depth"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/ColorDepth/32">
+               <Property Name="UnifiedPosition" Value="{{0.25,0},{0.55,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="32 bit (16.7m)"/>
+            </Window>
+
+            <Window Type="RastullahLook/RadioButton" Name="GameOptionsWindow/Video/ColorDepth/16">
+               <Property Name="UnifiedPosition" Value="{{0.25,150},{0.55,0}}"/>
+               <Property Name="UnifiedSize" Value="{{0.9,0},{0,20}}"/>
+               <Property Name="Text" Value="16 bit (65,536)"/>
+            </Window>
+
          </Window>
 
          <Window Type="DefaultGUISheet" Name="GameOptionsWindow/Sound">



From blakharaz at mail.berlios.de  Mon Dec  1 21:06:53 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 21:06:53 +0100
Subject: [Dsa-hl-svn] r4619 - rl/trunk/engine/rules/src
Message-ID: <200812012006.mB1K6rsn004018@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 21:06:52 +0100 (Mon, 01 Dec 2008)
New Revision: 4619

Modified:
   rl/trunk/engine/rules/src/GoToJob.cpp
Log:
Fix go to position (fixes fleeing in combat)

Modified: rl/trunk/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/GoToJob.cpp	2008-11-30 23:53:28 UTC (rev 4618)
+++ rl/trunk/engine/rules/src/GoToJob.cpp	2008-12-01 20:06:52 UTC (rev 4619)
@@ -62,15 +62,22 @@
 			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
+        
+        Ogre::Real distance;
+        
 		// update target position
 		if (mTarget)
 		{
 			mTargetPos = mTarget->getPosition();
-		}
-
+            distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
+                                                     mActor->getCreature()->getWorldBoundingBox());
+        }
+        else 
+        {
+            distance = MathUtil::distance(mTargetPos, mActor->getCreature()->getWorldBoundingBox());
+        }
+        
 		// Are we there now?
-		Ogre::Real distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
-			mActor->getCreature()->getWorldBoundingBox());
 		if (distance < mMaxDistance)
 		{
 			// Stay put where ever we are.



From blakharaz at mail.berlios.de  Mon Dec  1 21:08:08 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 21:08:08 +0100
Subject: [Dsa-hl-svn] r4620 - in rl/trunk/engine/common: include src
Message-ID: <200812012008.mB1K88q8004119@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 21:08:06 +0100 (Mon, 01 Dec 2008)
New Revision: 4620

Modified:
   rl/trunk/engine/common/include/MathUtil.h
   rl/trunk/engine/common/src/MathUtil.cpp
Log:
Fix go to position (fixes fleeing in combat)

Modified: rl/trunk/engine/common/include/MathUtil.h
===================================================================
--- rl/trunk/engine/common/include/MathUtil.h	2008-12-01 20:06:52 UTC (rev 4619)
+++ rl/trunk/engine/common/include/MathUtil.h	2008-12-01 20:08:06 UTC (rev 4620)
@@ -1,39 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __MathUtil_H__
-#define __MathUtil_H__
-
-#include "CommonPrerequisites.h"
-
-namespace rl {
-
-class _RlCommonExport MathUtil
-{
-    public:
-        static const Ogre::Real EPSILON;
-
-        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
-            Ogre::Radian azimuth, Ogre::Radian altitude);
-
-        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-            Ogre::Radian& azimuth, Ogre::Radian& altitude);
-        static Ogre::Real normaliseAngle(Ogre::Real angle);
-
-		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
-};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __MathUtil_H__
+#define __MathUtil_H__
+
+#include "CommonPrerequisites.h"
+
+namespace rl 
+{
+    
+    class _RlCommonExport MathUtil
+    {
+    public:
+        static const Ogre::Real EPSILON;
+        
+        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
+                                                  Ogre::Radian azimuth, Ogre::Radian altitude);
+        
+        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+                                         Ogre::Radian& azimuth, Ogre::Radian& altitude);
+        static Ogre::Real normaliseAngle(Ogre::Real angle);
+        
+		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
+        static Ogre::Real distance(const Ogre::Vector3& v, const Ogre::AxisAlignedBox& b);
+        static Ogre::Real distance(const Ogre::AxisAlignedBox& b, const Ogre::Vector3& v);
+    };
+    
+}
+#endif

Modified: rl/trunk/engine/common/src/MathUtil.cpp
===================================================================
--- rl/trunk/engine/common/src/MathUtil.cpp	2008-12-01 20:06:52 UTC (rev 4619)
+++ rl/trunk/engine/common/src/MathUtil.cpp	2008-12-01 20:08:06 UTC (rev 4620)
@@ -1,78 +1,104 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h" //precompiled header
-
-#include "MathUtil.h"
-
-
-using namespace Ogre;
-
-namespace rl
-{
-    const Ogre::Real MathUtil::EPSILON = 0.00001f;
-
-    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
-        Ogre::Radian azimuth, Ogre::Radian altitude)
-    {
-        Vector3 rval;
-        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
-        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        return rval;
-    }
-
-    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-        Ogre::Radian& azimuth, Ogre::Radian& altitude)
-    {
-        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
-        azimuth = Math::ATan2(cartesian.x, cartesian.z);
-        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
-    }
-
-    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
-	{
-        Ogre::Real ang = angle;
-
-		while (ang < 0) ang += 360;
-		while (ang > 360) ang -= 360;
-
-		return ang;
-	}	
-
-	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
-	{
-		if (b1.intersects(b2))
-		{
-			return 0.0f;
-		}
-		else
-		{
-			Vector3 dv;
-
-			const Vector3& min1 = b1.getMinimum();
-			const Vector3& min2 = b2.getMinimum();
-			const Vector3& max1 = b1.getMaximum();
-			const Vector3& max2 = b2.getMaximum();
-
-			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
-			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
-			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
-
-			return dv.length();
-		}
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h" //precompiled header
+
+#include "MathUtil.h"
+
+
+using namespace Ogre;
+
+namespace rl
+{
+    const Ogre::Real MathUtil::EPSILON = 0.00001f;
+
+    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
+        Ogre::Radian azimuth, Ogre::Radian altitude)
+    {
+        Vector3 rval;
+        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
+        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        return rval;
+    }
+
+    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+        Ogre::Radian& azimuth, Ogre::Radian& altitude)
+    {
+        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
+        azimuth = Math::ATan2(cartesian.x, cartesian.z);
+        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
+    }
+
+    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
+	{
+        Ogre::Real ang = angle;
+
+		while (ang < 0) ang += 360;
+		while (ang > 360) ang -= 360;
+
+		return ang;
+	}	
+
+	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
+	{
+		if (b1.intersects(b2))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+
+			const Vector3& min1 = b1.getMinimum();
+			const Vector3& min2 = b2.getMinimum();
+			const Vector3& max1 = b1.getMaximum();
+			const Vector3& max2 = b2.getMaximum();
+
+			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
+			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
+			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
+
+			return dv.length();
+		}
+	}
+    
+	Real MathUtil::distance(const Vector3& v, const AxisAlignedBox& b)
+    {
+        return MathUtil::distance(b, v);
+    }
+    
+	Real MathUtil::distance(const AxisAlignedBox& b, const Vector3& v)
+	{
+		if (b.contains(v))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+            
+			const Vector3& min1 = b.getMinimum();
+			const Vector3& max1 = b.getMaximum();
+            
+			dv.x = min1.x > v.x ? min1.x - v.x : v.x > max1.x ? v.x - max1.x : 0.0f;
+			dv.y = min1.y > v.y ? min1.y - v.y : v.y > max1.y ? v.y - max1.y : 0.0f;
+			dv.z = min1.z > v.z ? min1.z - v.z : v.z > max1.z ? v.z - max1.z : 0.0f;
+            
+			return dv.length();
+		}
+	}
+}



From timm at mail.berlios.de  Mon Dec  1 21:13:51 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 1 Dec 2008 21:13:51 +0100
Subject: [Dsa-hl-svn] r4621 - in rl/branches/persistence: common/include
	common/src rules/src ui/include ui/src
Message-ID: <200812012013.mB1KDpUZ004545@sheep.berlios.de>

Author: timm
Date: 2008-12-01 21:13:40 +0100 (Mon, 01 Dec 2008)
New Revision: 4621

Modified:
   rl/branches/persistence/common/include/MathUtil.h
   rl/branches/persistence/common/src/MathUtil.cpp
   rl/branches/persistence/rules/src/GoToJob.cpp
   rl/branches/persistence/ui/include/AbstractWindow.h
   rl/branches/persistence/ui/include/GameSettings.h
   rl/branches/persistence/ui/src/AbstractWindow.cpp
   rl/branches/persistence/ui/src/GameSettings.cpp
Log:
merged changes from trunk

Modified: rl/branches/persistence/common/include/MathUtil.h
===================================================================
--- rl/branches/persistence/common/include/MathUtil.h	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/common/include/MathUtil.h	2008-12-01 20:13:40 UTC (rev 4621)
@@ -1,39 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __MathUtil_H__
-#define __MathUtil_H__
-
-#include "CommonPrerequisites.h"
-
-namespace rl {
-
-class _RlCommonExport MathUtil
-{
-    public:
-        static const Ogre::Real EPSILON;
-
-        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
-            Ogre::Radian azimuth, Ogre::Radian altitude);
-
-        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-            Ogre::Radian& azimuth, Ogre::Radian& altitude);
-        static Ogre::Real normaliseAngle(Ogre::Real angle);
-
-		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
-};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __MathUtil_H__
+#define __MathUtil_H__
+
+#include "CommonPrerequisites.h"
+
+namespace rl 
+{
+    
+    class _RlCommonExport MathUtil
+    {
+    public:
+        static const Ogre::Real EPSILON;
+        
+        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
+                                                  Ogre::Radian azimuth, Ogre::Radian altitude);
+        
+        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+                                         Ogre::Radian& azimuth, Ogre::Radian& altitude);
+        static Ogre::Real normaliseAngle(Ogre::Real angle);
+        
+		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
+        static Ogre::Real distance(const Ogre::Vector3& v, const Ogre::AxisAlignedBox& b);
+        static Ogre::Real distance(const Ogre::AxisAlignedBox& b, const Ogre::Vector3& v);
+    };
+    
+}
+#endif

Modified: rl/branches/persistence/common/src/MathUtil.cpp
===================================================================
--- rl/branches/persistence/common/src/MathUtil.cpp	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/common/src/MathUtil.cpp	2008-12-01 20:13:40 UTC (rev 4621)
@@ -1,78 +1,104 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h" //precompiled header
-
-#include "MathUtil.h"
-
-
-using namespace Ogre;
-
-namespace rl
-{
-    const Ogre::Real MathUtil::EPSILON = 0.00001f;
-
-    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
-        Ogre::Radian azimuth, Ogre::Radian altitude)
-    {
-        Vector3 rval;
-        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
-        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        return rval;
-    }
-
-    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-        Ogre::Radian& azimuth, Ogre::Radian& altitude)
-    {
-        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
-        azimuth = Math::ATan2(cartesian.x, cartesian.z);
-        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
-    }
-
-    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
-	{
-        Ogre::Real ang = angle;
-
-		while (ang < 0) ang += 360;
-		while (ang > 360) ang -= 360;
-
-		return ang;
-	}	
-
-	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
-	{
-		if (b1.intersects(b2))
-		{
-			return 0.0f;
-		}
-		else
-		{
-			Vector3 dv;
-
-			const Vector3& min1 = b1.getMinimum();
-			const Vector3& min2 = b2.getMinimum();
-			const Vector3& max1 = b1.getMaximum();
-			const Vector3& max2 = b2.getMaximum();
-
-			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
-			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
-			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
-
-			return dv.length();
-		}
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h" //precompiled header
+
+#include "MathUtil.h"
+
+
+using namespace Ogre;
+
+namespace rl
+{
+    const Ogre::Real MathUtil::EPSILON = 0.00001f;
+
+    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
+        Ogre::Radian azimuth, Ogre::Radian altitude)
+    {
+        Vector3 rval;
+        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
+        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        return rval;
+    }
+
+    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+        Ogre::Radian& azimuth, Ogre::Radian& altitude)
+    {
+        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
+        azimuth = Math::ATan2(cartesian.x, cartesian.z);
+        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
+    }
+
+    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
+	{
+        Ogre::Real ang = angle;
+
+		while (ang < 0) ang += 360;
+		while (ang > 360) ang -= 360;
+
+		return ang;
+	}	
+
+	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
+	{
+		if (b1.intersects(b2))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+
+			const Vector3& min1 = b1.getMinimum();
+			const Vector3& min2 = b2.getMinimum();
+			const Vector3& max1 = b1.getMaximum();
+			const Vector3& max2 = b2.getMaximum();
+
+			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
+			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
+			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
+
+			return dv.length();
+		}
+	}
+    
+	Real MathUtil::distance(const Vector3& v, const AxisAlignedBox& b)
+    {
+        return MathUtil::distance(b, v);
+    }
+    
+	Real MathUtil::distance(const AxisAlignedBox& b, const Vector3& v)
+	{
+		if (b.contains(v))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+            
+			const Vector3& min1 = b.getMinimum();
+			const Vector3& max1 = b.getMaximum();
+            
+			dv.x = min1.x > v.x ? min1.x - v.x : v.x > max1.x ? v.x - max1.x : 0.0f;
+			dv.y = min1.y > v.y ? min1.y - v.y : v.y > max1.y ? v.y - max1.y : 0.0f;
+			dv.z = min1.z > v.z ? min1.z - v.z : v.z > max1.z ? v.z - max1.z : 0.0f;
+            
+			return dv.length();
+		}
+	}
+}

Modified: rl/branches/persistence/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/GoToJob.cpp	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/rules/src/GoToJob.cpp	2008-12-01 20:13:40 UTC (rev 4621)
@@ -60,15 +60,22 @@
 			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
+        
+        Ogre::Real distance;
+        
 		// update target position
 		if (mTarget)
 		{
 			mTargetPos = mTarget->getPosition();
-		}
-
+            distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
+                                                     mActor->getCreature()->getWorldBoundingBox());
+        }
+        else 
+        {
+            distance = MathUtil::distance(mTargetPos, mActor->getCreature()->getWorldBoundingBox());
+        }
+        
 		// Are we there now?
-		Ogre::Real distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
-			mActor->getCreature()->getWorldBoundingBox());
 		if (distance < mMaxDistance)
 		{
 			// Stay put where ever we are.

Modified: rl/branches/persistence/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/persistence/ui/include/AbstractWindow.h	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/ui/include/AbstractWindow.h	2008-12-01 20:13:40 UTC (rev 4621)
@@ -22,6 +22,7 @@
 
 #include <CEGUIWindow.h>
 #include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIRadioButton.h>
 #include <elements/CEGUIEditbox.h>
 #include <elements/CEGUIListbox.h>
 #include <elements/CEGUIMultiColumnList.h>
@@ -77,6 +78,7 @@
 		CEGUI::MenuBase* getMenu(const char* name);
 		CEGUI::MenuItem* getMenuItem(const char* name);
 		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::RadioButton* getRadioButton(const char* name);
 		CEGUI::Combobox* getCombobox(const char* name);
 		CEGUI::ComboDropList* getComboDropList(const char* name);
         CEGUI::ScrollablePane* getScrollablePane(const char* name);

Modified: rl/branches/persistence/ui/include/GameSettings.h
===================================================================
--- rl/branches/persistence/ui/include/GameSettings.h	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/ui/include/GameSettings.h	2008-12-01 20:13:40 UTC (rev 4621)
@@ -84,7 +84,12 @@
 		bool onRenderSystemChanged();
         
         void update();
-
+        
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Checkbox* checkbox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Combobox* combobox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, std::vector<CEGUI::RadioButton*> radioGroup);
+        void createElements(CEGUI::Combobox* combobox, size_t count);
+        
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
@@ -93,6 +98,9 @@
         CEGUI::Combobox* mVideoRenderer;
         CEGUI::Combobox* mVideoResolution;
         CEGUI::Checkbox* mVideoFullscreen;
+        CEGUI::RadioButton* mVideoColorDepth32, *mVideoColorDepth16;
+        CEGUI::RadioButton* mVideoFsaa0, *mVideoFsaa2, *mVideoFsaa4, *mVideoFsaa8;
+        CEGUI::RadioButton* mVideoRttModeFBO, *mVideoRttModePBuffer, *mVideoRttModeCopy;
 	};
 }
 

Modified: rl/branches/persistence/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/AbstractWindow.cpp	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/ui/src/AbstractWindow.cpp	2008-12-01 20:13:40 UTC (rev 4621)
@@ -232,7 +232,12 @@
 	{
 		return static_cast<PushButton*>(getWindow(name, "PushButton"));
 	}
-
+    
+	RadioButton* AbstractWindow::getRadioButton(const char* name)
+	{
+		return static_cast<RadioButton*>(getWindow(name, "RadioButton"));
+	}
+    
 	Combobox* AbstractWindow::getCombobox(const char* name)
 	{
 		return static_cast<Combobox*>(getWindow(name, "Combobox"));

Modified: rl/branches/persistence/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSettings.cpp	2008-12-01 20:08:06 UTC (rev 4620)
+++ rl/branches/persistence/ui/src/GameSettings.cpp	2008-12-01 20:13:40 UTC (rev 4621)
@@ -18,14 +18,22 @@
 #include "GameSettings.h"
 
 #include <boost/bind.hpp>
+#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#include <CEGUI/elements/CEGUIFrameWindow.h>
+#include <CEGUI/elements/CEGUIListboxTextItem.h>
+#else
 #include <elements/CEGUIFrameWindow.h>
 #include <elements/CEGUIListboxTextItem.h>
+#endif
+
 #include <iostream>
 
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
 using namespace Ogre;
+using namespace CEGUI;
+using namespace std;
 
 namespace rl
 {
@@ -51,6 +59,37 @@
         mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
         mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
         mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
+        
+        mVideoColorDepth32 = getRadioButton("GameOptionsWindow/Video/ColorDepth/32");
+        mVideoColorDepth32->setUserData(new Ogre::String("32"));
+        mVideoColorDepth32->setGroupID(1);
+        mVideoColorDepth16 = getRadioButton("GameOptionsWindow/Video/ColorDepth/16");
+        mVideoColorDepth16->setUserData(new Ogre::String("16"));
+        mVideoColorDepth16->setGroupID(1);
+        
+        mVideoFsaa0 = getRadioButton("GameOptionsWindow/Video/FSAA/Off");
+        mVideoFsaa0->setUserData(new Ogre::String("0"));
+        mVideoFsaa0->setGroupID(2);
+        mVideoFsaa2 = getRadioButton("GameOptionsWindow/Video/FSAA/2x");
+        mVideoFsaa2->setUserData(new Ogre::String("2"));
+        mVideoFsaa2->setGroupID(2);
+        mVideoFsaa4 = getRadioButton("GameOptionsWindow/Video/FSAA/4x");
+        mVideoFsaa4->setUserData(new Ogre::String("4"));
+        mVideoFsaa4->setGroupID(2);
+        mVideoFsaa8 = getRadioButton("GameOptionsWindow/Video/FSAA/8x");
+        mVideoFsaa8->setUserData(new Ogre::String("8"));
+        mVideoFsaa8->setGroupID(2);
+        
+        mVideoRttModeFBO = getRadioButton("GameOptionsWindow/Video/RTT/FBO");
+        mVideoRttModeFBO->setUserData(new Ogre::String("FBO"));
+        mVideoRttModeFBO->setGroupID(3);
+        mVideoRttModePBuffer = getRadioButton("GameOptionsWindow/Video/RTT/PBuffer");
+        mVideoRttModePBuffer->setUserData(new Ogre::String("PBuffer"));
+        mVideoRttModePBuffer->setGroupID(3);
+        mVideoRttModeCopy = getRadioButton("GameOptionsWindow/Video/RTT/Copy");
+        mVideoRttModeCopy->setUserData(new Ogre::String("Copy"));
+        mVideoRttModeCopy->setGroupID(3);
+        
         centerWindow();
         setVisible(false);
         update();
@@ -137,50 +176,124 @@
     void GameSettings::update()
     {
         Root* root = Ogre::Root::getSingletonPtr();
+        
+        RenderSystemList* renderers = root->getAvailableRenderers();
         RenderSystem* renderer = root->getRenderSystem();
         
+        createElements(mVideoRenderer, renderers->size());
+
+        for (int i = 0; i < renderers->size(); ++i)
+        {
+            RenderSystem* cur = renderers->operator[](i);
+            ListboxItem* item = mVideoRenderer->getListboxItemFromIndex(i);
+            item->setText(cur->getName());
+            if (cur == renderer)
+            {
+                mVideoRenderer->setItemSelectState(item, true);
+            }
+        }
+        
         ConfigOptionMap config = renderer->getConfigOptions();
         
-		ConfigOptionMap::iterator cfi;
-		
-		cfi = config.find( "Full Screen" );
-		if( cfi != config.end() )
-		{
-			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
-		}
+        setOption(config, "Full Screen", mVideoFullscreen);
+        vector<RadioButton*> videoColorDepth;
+        videoColorDepth.push_back(mVideoColorDepth32);
+        videoColorDepth.push_back(mVideoColorDepth16);
         
-/*		cfi = config.find( "FSAA" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "0" )
-			{
-				SetControlValue( iFSAARef, 1 );
-			}
-			else if( cfi->second.currentValue == "2" )
-			{
-				SetControlValue( iFSAARef, 2 );
-			}
-			else if( cfi->second.currentValue == "4" )
-			{
-				SetControlValue( iFSAARef, 3 );
-			}
-			else if( cfi->second.currentValue == "6" )
-			{
-				SetControlValue( iFSAARef, 4 );
-			}
-		}
+        setOption(config, "Colour Depth", videoColorDepth);
+        vector<RadioButton*> videoAntiAliasing;
+        videoAntiAliasing.push_back(mVideoFsaa0);
+        videoAntiAliasing.push_back(mVideoFsaa2);
+        videoAntiAliasing.push_back(mVideoFsaa4);
+        videoAntiAliasing.push_back(mVideoFsaa8);
+        setOption(config, "FSAA", videoAntiAliasing);
         
-		cfi = config.find( "Colour Depth" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "32" )
-			{
-				SetControlValue( iColorDepthRef, 1 );
-			}
-			else
-			{
-				SetControlValue( iColorDepthRef, 2 );
-			}
-		}*/
+        vector<RadioButton*> videoRttMode;
+        videoRttMode.push_back(mVideoRttModeFBO);
+        videoRttMode.push_back(mVideoRttModePBuffer);
+        videoRttMode.push_back(mVideoRttModeCopy);
+        setOption(config, "RTT Preferred Mode", videoRttMode);
+        
+        setOption(config, "Video Mode", mVideoResolution);
     }
+    
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Checkbox* checkbox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            checkbox->setSelected(cfi->second.currentValue == "Yes");            
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Combobox* combobox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            int delta = curOption.possibleValues.size() - combobox->getItemCount();
+            if (delta > 0)
+            {
+                for (int i = 0; i < delta; ++i)
+                {
+                    combobox->addItem(new ListboxTextItem(""));
+                }
+            }
+            else if (delta < 0)
+            {
+                for (int i = 0; i < -delta; ++i)
+                {
+                    ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                    combobox->removeItem(item);
+                    delete item;
+                }
+            }
+            
+            for (int i = 0; i < combobox->getItemCount(); ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(i);
+                item->setText(curOption.possibleValues[i]);
+            }
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, std::vector<RadioButton*> radioGroup)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            for (std::vector<RadioButton*>::const_iterator it = radioGroup.begin(); it != radioGroup.end(); ++it)
+            {
+                Ogre::String* value = static_cast<Ogre::String*>((*it)->getUserData());
+                if (value && (*value == curOption.currentValue))
+                {
+                    (*it)->setSelected(true);
+                    break;
+                }
+            }
+        }
+    }
+    
+    void GameSettings::createElements(CEGUI::Combobox* combobox, size_t count)
+    {
+        int delta = count - combobox->getItemCount();
+        if (delta > 0)
+        {
+            for (int i = 0; i < delta; ++i)
+            {
+                combobox->addItem(new ListboxTextItem(""));
+            }
+        }
+        else if (delta < 0)
+        {
+            for (int i = 0; i < -delta; ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                combobox->removeItem(item);
+                delete item;
+            }
+        }
+    }    
 }



From blakharaz at mail.berlios.de  Mon Dec  1 22:14:15 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 22:14:15 +0100
Subject: [Dsa-hl-svn] r4622 - modules/common/dsa
Message-ID: <200812012114.mB1LEFlr010738@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 22:14:14 +0100 (Mon, 01 Dec 2008)
New Revision: 4622

Modified:
   modules/common/dsa/animals.gof
Log:
30 LeP for wolf

Modified: modules/common/dsa/animals.gof
===================================================================
--- modules/common/dsa/animals.gof	2008-12-01 20:13:40 UTC (rev 4621)
+++ modules/common/dsa/animals.gof	2008-12-01 21:14:14 UTC (rev 4622)
@@ -33,6 +33,7 @@
 			</property>
 		</property>
 	</property>
+    <property name="current_le" type="INT" data="30"/>
 	<property name="ai" type="MAP">
 		<property name="behaviours" type="ARRAY">
 			<property type="STRING" data="DefaultWanderBehaviour"/>



From blakharaz at mail.berlios.de  Mon Dec  1 22:18:57 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 22:18:57 +0100
Subject: [Dsa-hl-svn] r4623 - in rl/trunk/engine/rules: include src
Message-ID: <200812012118.mB1LIvWD011120@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 22:18:53 +0100 (Mon, 01 Dec 2008)
New Revision: 4623

Modified:
   rl/trunk/engine/rules/include/ApplyDamageJob.h
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/include/Combatant.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Weapon.h
   rl/trunk/engine/rules/src/ApplyDamageJob.cpp
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/rules/src/Combatant.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Weapon.cpp
Log:
Rules for natural weapons

Modified: rl/trunk/engine/rules/include/ApplyDamageJob.h
===================================================================
--- rl/trunk/engine/rules/include/ApplyDamageJob.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/ApplyDamageJob.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include "RulesPrerequisites.h"
-
-#include "Job.h"
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include "RulesPrerequisites.h"
+
+#include "Job.h"
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Combat.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include "RulesPrerequisites.h"
-
-#include <set>
-#include <vector>
-#include <boost/tuple/tuple.hpp>
-
-#include "JobListener.h"
-#include "Kampfaktion.h"
-#include "MessagePump.h"
-#include "RulesConstants.h"
-#include "Effect.h"
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set<Combatant*> CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet& getAllPlayerOpponents() const;
-        const CombatantSet& getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector<ActionEntry> ActionEntryVector;
-		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
-		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
-        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set<int> mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include "RulesPrerequisites.h"
+
+#include <set>
+#include <vector>
+#include <boost/tuple/tuple.hpp>
+
+#include "Creature.h"
+#include "Effect.h"
+#include "JobListener.h"
+#include "Kampfaktion.h"
+#include "MessagePump.h"
+#include "RulesConstants.h"
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set<Combatant*> CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector<ActionEntry> ActionEntryVector;
+		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
+		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
+        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set<int> mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Combatant.h
===================================================================
--- rl/trunk/engine/rules/include/Combatant.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Combatant.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Creature.h"
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Creature.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,870 +1,877 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __CREATURE_H__
-#define __CREATURE_H__
-
-#include "RulesPrerequisites.h"
-
-#include "Date.h"
-#include "Effect.h"
-#include "Effect.h"
-#include "Eigenschaft.h"
-#include "GameObject.h"
-#include "ZauberStateSet.h"
-#include "SonderfertigkeitenStateSet.h"
-
-namespace rl
-{
-    class Container;
-    class Inventory;
-    class Item;
-    class Weapon;
-
-///////////////////////////////////////////////////////////////////////////////
-// Konstanten
-
-    /**
-    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
-    /**
-    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
-
-    /// Eine Doppel-1
-    static const int RESULT_AUTOERFOLG = 100;
-    /// Eine Dreifach-1
-    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
-    /// Eine Doppel-20
-    static const int RESULT_AUTOMISSERFOLG = -100;
-    /// Eine Dreifach-20
-    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
-    /**
-     *  Eine bestaetigte 1 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
-     *  eine einfache 1 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_GLUECKLICH = 100;
-    /**
-     *  Eine bestaetigte 20 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
-     *  eine einfache 20 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_PATZER = -100;
-    /// Eine normal gelungene Attacke oder Parade
-    static const int RESULT_ERFOLG = 1;
-    /// Eine normal misslungene Attacke oder Parade
-    static const int RESULT_MISSERFOLG = -1;
-
-
-    /// Basistalente
-    /// @todo Passenderen Ort suchen
-    static const CeGuiString TALENT_ART_BASIS = "Basis";
-    /// Spezialtalente
-    static const CeGuiString TALENT_ART_SPEZIAL = "Spezial";
-    /// Berufstalente
-    static const CeGuiString TALENT_ART_BERUF = "Beruf";
-
-    /**
-     *  @defgroup CreatureRubyExports Creature
-     *  @ingroup RulesRubyExports
-     **/
-
-    /**
-    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
-    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
-    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
-    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
-    * Spielwelt noetig ist (z.B. Proben).
-    */
-    class _RlRulesExport Creature : public GameObject
-    {
-        public:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  List of all talents. Consists of the (german) name of the talent
-             *  (e.g. "Athletik") as key and its value (TaW)
-             **/
-            typedef std::map<const CeGuiString, int> TalentMap;
-
-            static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_AI;
-            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
-			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
-            static const Ogre::String PROPERTY_CURRENT_LE;
-            static const Ogre::String PROPERTY_CURRENT_AE;
-            static const Ogre::String PROPERTY_CURRENT_AU;
-            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
-            static const Ogre::String PROPERTY_EFFECTS;
-            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
-            static const Ogre::String PROPERTY_TALENTE;
-            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
-            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
-            static const Ogre::String PROPERTY_VORTEILE;
-            static const Ogre::String PROPERTY_NACHTEILE;
-            static const Ogre::String PROPERTY_SF;
-            static const Ogre::String PROPERTY_WERTE;
-            static const Ogre::String PROPERTY_AP;
-            static const Ogre::String PROPERTY_INVENTORY;
-            static const Ogre::String PROPERTY_ANIMATIONS;
-            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
-
-            typedef Ogre::String Wert;
-
-            // some targets
-			static const std::string ALL_EIGENSCHAFTEN;
-			static const std::string ALL_TALENTE;
-
-            static const Wert WERT_MOD_AE;
-            static const Wert WERT_MOD_LE;
-            static const Wert WERT_MOD_AU;
-            static const Wert WERT_MOD_MR;
-            static const Wert WERT_MOD_AT;
-            static const Wert WERT_MOD_PA;
-            static const Wert WERT_MOD_FK;
-            static const Wert WERT_GS;
-            static const Wert WERT_SOZIALSTATUS;
-            static const Wert WERT_BE;
-            static const Wert WERT_RS;
-            static const Wert WERT_INI;
-            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
-            static const Wert WERT_REGENERATION;
-    			
-			Creature(unsigned int id);
-
-            /// Der Standarddestruktor.
-            virtual ~Creature();
-
-///////////////////////////////////////////////////////////////////////////////
-// Enums
-            /// Alignment of a Creature towards the player. This determines
-            /// whether a combat is entered.
-            enum Alignment
-            {
-                ALIGNMENT_ALLY    = 1, ///< Creature fights with the player.
-                ALIGNMENT_NEUTRAL = 2, ///< Creature doesn't fight for either side.
-                ALIGNMENT_ENEMY   = 4  ///< Creature fights against the player.
-            };
-
-            /// Determines the damage type
-            enum DamageTag
-            {
-                DAMAGETAG_NORMAL = 1,
-                DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
-                DAMAGETAG_FIRE
-            };
-            /// The differente states a @ref abbdes "SF" can be in.
-             enum SfStatus
-            {
-                SFSTATUS_IN_TRAINING = 1,
-                SFSTATUS_OK,
-                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Werte
-
-            /**
-             *  Modifies the current @ref abbdel "LE" of the creature.
-             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
-             *  value).
-             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
-             **/
-            virtual void modifyLe(int mod, bool ignoreMax = false);
-            /**
-             *  Returns the current @ref abbdel "LE" of the creature.
-             **/
-            virtual int getLe() const;
-            /**
-             *  Returns the maximum @ref abbdel "LE" the creature can have.
-             **/
-            virtual int getLeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
-             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAe(int mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
-             **/
-            virtual int getAe() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
-             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAu(float mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
-             **/
-            virtual float getAu() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAuMax() const;
-
-            /**
-             *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
-             **/
-            virtual int getAttackeBasis() const;
-            /**
-             *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
-             **/
-            virtual int getParadeBasis() const;
-            /**
-             *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
-             **/
-            virtual int getFernkampfBasis() const;
-            /**
-             *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
-             **/
-            virtual int getInitiativeBasis() const;
-
-            /**
-             *  Setzt den Basiswert \a wertId auf \a value.
-             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
-             *  @param value Der neue wert des Basiswerts.
-             *  @see Wert
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void setWert(Wert wertId, int value);
-            /**
-                   *  Liefert den Basiswert \a wertId zurueck.
-             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
-                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
-                   *   zurueckgegeben.
-             *  @return Der Wert des Basiswerts.
-             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
-             *    gefunden werden.
-             **/
-            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
-
-            /**
-             *  Gibt der Kreatur @ref abbddea "AP".
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyAp(int modifier);
-            /**
-             *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
-             **/
-            int getAp() const;
-            /**
-             *  Veraendert die verbrauchten @ref abbdea "AP", wird beim Steigern
-             *  aufgerufen.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyUsedAp(int modifier);
-            /**
-             *  Liefert die verbrauchten @refabbdea "AP" zurueck.
-             **/
-            int getUsedAp() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Eigenschaften
-
-            /**
-             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @abbdef "FF", etc.).
-             *  @return Der Wert der Eigenschaft.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
-            /**
-             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @ref abbdef "FF", etc.).
-             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
-            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @ref abbdef "FF", etc.).
-             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
-
-///////////////////////////////////////////////////////////////////////////////
-// Talente
-
-            /**
-                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
-             *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
-             *  @param talentName Bezeichnet das Talent.
-                   *  @param value Startwert des Talents.
-             *  @throws InvalidArgumentException Das Talent konnte nicht
-             *    gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            void addTalent(const CeGuiString talentName, int value = 0);
-            /**
-                   *  Liefert den Wert des Talents \a talentName zurueck.
-             *  @param talentName Bezeichnet das Talent.
-             *  @return @ref abbdet "TaW"
-                   *  @ingroup CreatureRubyExports
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-             */
-
-            /**
-                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
-              * @param talentName Bezeichnet das Talent
-              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
-            */
-            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
-
-            virtual int getTalent(const CeGuiString talentName) const;
-            /**
-                   *  Setzt den Wert des Talents \a talentName.
-             *  @param talentName Bezeichnet das zu veraendernde Talent.
-             *  @param value Der neue @ref abbdet TaW.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void setTalent(const CeGuiString talentName, int value);
-            /**
-                   *  Erhoeht das Talent \a talentName um \a mod.
-             *  @param talentName Bezeichnet das zu steigernde Talent.
-             *  @param mod Der Wert um den das Talent gesteigert werden soll.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void modifyTalent(const CeGuiString talentName, int mod);
-            /**
-             * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
-             * Dies wird auch der komplette Talentspiegel genannt.
-             **/
-            virtual const Creature::TalentMap& getAllTalents() const;
-            /**
-                   *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
-                   *  Spezielle Erfahrungen, MFF 47.
-             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void addSe(const CeGuiString talentName);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampftechniken
-
-            /**
-             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
-             *  @param kampftechnikName Bezeichnet die Kampftechnik.
-             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
-             *  (0,0).
-             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
-                   *  @ingroup CreatureRubyExports
-             **/
-            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value = std::make_pair(0, 0));
-            /**
-                   *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
-                   *  bestimmten Kampftechnik zurueck.
-             *  @param kampftechnikName Beszeichnet die Kampftechnik.
-             *  @return Ein std::pair<AT, PA>.
-             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
-             *   \c mKampftechniken gefunden werden.
-             **/
-            virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
-            /**
-                   *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
-                   *  Kampftechnik.
-             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
-             *  @param value Die neuen AT/PA Werte.
-             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
-             *    konnte nicht in \c mKampftechniken gefunden werden.
-             **/
-            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampfaktionen (Attacke, Parade, etc..)
-
-            void addKampfaktion(const CeGuiString& kampfaktionName);
-            bool hasKampfaktion(const CeGuiString& kampfaktionName) const;
-			const std::set<CeGuiString>& getAllKampfaktionen() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Vorteile
-            /**
-             *  Fuegt einen Vorteil hinzu.
-             *  @param vorteilName Der Name des Vorteils.
-             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
-             *   Vorteils (z.B. Astrale Regeneration 3).
-             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
-             **/
-            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
-
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
-             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
-             **/
-            virtual bool hasVorteil(const CeGuiString vorteilName) const;
- 
-///////////////////////////////////////////////////////////////////////////////
-// Nachteile
-            /**
-             *  Fuegt einen Nachteil hinzu.
-             *  @param nachteilName Der Name des Nachteils.
-             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
-             *   die Stufe des Nachteils.
-             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
-             **/
-            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
-             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
-             **/
-            virtual bool hasNachteil(const CeGuiString nachteilName) const;
-            /**
-             *  Liefert das StateSet des Nachteils zurueck.
-             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
-             *  abzufragen.
-             *  @param nachteilName Der Name der Schlechten Eigenschaft.
-             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
-             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
-             *   nicht gefunden werden.
-             **/
-            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Sonderfertigkeiten
-
-            /**
-                    *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
-             *  @param sfName Bezeichnet die SF.
-                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
-             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
-             *    werden.
-                    *  @see SfStatus
-             */
-            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-            /**
-                   *  Liefert den Wert der @ref abbdes "SF" zurueck.
-             *  @param sfName Bezeichnet die SF
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual int getSf(const CeGuiString sfName) const;
-            /**
-                   *  Setzt den Wert der @ref abbdes "SF".
-             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
-             *   werden soll.
-             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
-             *   soll.
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual void setSf(const CeGuiString sfName, SfStatus value);
-
-            /**
-             *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
-             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
-            *  @throws InvalidArgumentException \a sfName kann nicht in 
-            *   \c mSonderfertigkeiten gefunden werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Status
-            /**
-             * Gets the status of a creature.
-             **/
-			Effect::LifeState getLifeState() const;
-
-
-            bool isMagic() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Inventory
-
-
-            /**
-             *  Gibt das Inventar der Kreatur zurueck.
-             *  @return Liefert einen Zeiger auf Inventar der Kreatur
-             **/
-            Inventory* getInventory() const;
-
-        const Ogre::String& getInventoryWindowType() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Aktionen
-            /**
-            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
-            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
-            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
-            *  die Angabe einer Spezialisierung.
-            *  @param talentName Bezeichnet das Talent
-            *  @param spezialisierungId Bezeichnet die Spezialisierung
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
-            *     gewuerfelt werden soll
-            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
-            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
-            *  @return uebrig gebliebene Talentpunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
-            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
-            */
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int,int)
-             *  This is the function that should be used in most cases.
-             **/
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int);
-             *  This is the function you should usually use, if there is no fitting
-             *  specialization for the task.
-             *  @ingroup CreatureRubyExports
-             **/
-            /**
-             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
-             **/
-		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
-                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
-                                                 CeGuiString eigenschaft3Name);
-            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
-
-			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-                                      int modifier);
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
-
-            /**
-            *  Durchfuehren einer Eigenschaftsprobe.
-            *  @param eigenschaftName Bezeichnet die Eigenschaft
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
-            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
-            *  @ingroup CreatureRubyExports
-            */
-			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-            /**
-            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Attacke ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Attacke.
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   mKampftechniken gefunden.
-            **/
-            int doAttacke(const CeGuiString kampftechnikName, int modifier);
-            /**
-            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Parade ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Parade.
-            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-            *  @retval RESULT_GLUECKLICH Eine gute Parade.
-            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   \c mKampftechniken gefunden.
-            **/
-            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
-
-            /**
-             *  Fuehrt einen Initiativewurf durch.
-             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
-             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
-             *    'Orientieren'.
-             **/
-            int doInitiativeWurf(bool getMaxInitiative = false);
-
-			int doTrefferpunkteWurf(Weapon* weapon) const;
-
-            /**
-             *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
-             *  @param tp die Trefferpunkte
-                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
-                   *   etc. korrekt zu beruecksichtigen.
-             **/
-            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-            static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
-
-            /**
-             *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
-             *  @param aup die Trefferpunkte
-             **/
-            void damageAe(int asp);
-
-            /**
-            *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
-            *  @param aup die Trefferpunkte
-             *  @param damageType Typ des Schadens, um Resistenzen
-             *   etc. korrekt zu beruecksichtigen.
-            **/
-            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
-            static const int AUDAMAGE_NORMAL = 0;
-            static const int AUDAMAGE_HEAT = 1;
-            static const int AUDAMAGE_COLD = 2;
-            static const int AUDAMAGE_CHOKE = 4;
-            static const int AUDAMAGE_DROWN = 8;
-
-            /**
-             *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateLe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateAe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
-             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
-             *  Parameter time aufgerufen werden.
-             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
-             *   selten eingesetzt werden.
-             *  @param time Sollte nur benutzt werden, falls es nicht m???lich ist
-             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
-             **/
-            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
-
-
-            virtual const Property getProperty(const CeGuiString& key) const;
-            virtual void setProperty(const CeGuiString& key, const Property& value);
-            virtual PropertyKeys getAllPropertyKeys() const;
-
-            void setAlignment(Alignment);
-            Alignment getAlignment() const;
-
-
-
-            /**
-             * Gibt an, ob die Creature mit den H??nden an den Gegenstand herankommt,
-             * ihn also ber??hren kann, mit ihm interagieren etc
-            **/
-            virtual bool canReachItem(const Item* item) const;
-
-            /**
-             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
-             * den CreatureController
-            **/
-            typedef std::pair<Ogre::String, Ogre::Real> AnimationSpeedPair;
-            /**
-             * Gibt die Animation aus der AnimationsMap f??r den CreatureController zur??ck
-             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
-             * der Schl??sse name und eine Geschwindigkeit von 1 zurueckgegeben
-            **/
-            AnimationSpeedPair getAnimation(const CeGuiString& name) const;
-
-        protected:
-           /**
-             *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
-             **/
-            virtual int getAeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
-             **/
-            virtual int getAuBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
-             **/
-            virtual int getLeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
-             **/
-            virtual int getMrBasis() const;
-            /**
-             *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
-             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
-             **/
-            virtual int getCurrentBe() const;
-
-            /// inherited from GameObject
-            virtual void doPlaceIntoScene();
-
-            /// inherited from GameObject
-            virtual void doRemoveFromScene();
-
-
-
-
-        private:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  Liste der Werte.
-             *  @see Wert
-             **/
-            typedef std::map<const Wert, int> WertMap;
-            /**
-                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
-                   *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
-                   *  und einem Zeiger auf ihr StateSet.
-             **/
-            typedef std::map<const CeGuiString, int> EigenschaftMap;
-            /**
-             *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
-             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
-             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
-                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
-             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
-             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
-             *  Kampftalent entsprechen.
-             **/
-            typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
-            /**
-             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
-             *  den Vorteilen, verhalten sich aber wie Talente.
-             **/
-            typedef std::map<const CeGuiString, int> VorteilMap;
-            /**
-             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
-             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
-             **/
-            typedef std::map<const CeGuiString, int> NachteilMap;
-            /**
-                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
-                   *  Sonderfertigkeit als Schluessel und ihrem Status.
-             */
-            typedef std::map<const CeGuiString , SonderfertigkeitenStateSet*> SonderfertigkeitMap;
-            /**
-                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl??ssel ist Bezeichner der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
-                    * an.
-            **/
-            typedef std::map<const CeGuiString, CeGuiString> AnimationsMap;
-            /**
-                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
-                    * CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl??ssel ist Bezeichner, der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird.
-            **/
-            typedef std::map<const CeGuiString, Ogre::Real> AnimationSpeedsMap;
-            struct Ap
-            {
-                int total;
-                int used;
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Membervariablen
-            /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
-            int mCurrentLe;
-            /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
-            int mCurrentAe;
-            /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
-            float mCurrentAu;
-            /// Die aktuelle Erschoepfung der Kreatur.
-            int mErschoepfung;
-            /// Zuletzt zugewiesene Bewegungsart
-            int mMovementType;
-
-            /// Zeigt auf die gerade aktive Waffe.
-            EigenschaftMap mEigenschaften;
-            TalentMap mTalente;
-            KampftechnikMap mKampftechniken;
-			std::set<CeGuiString> mKampfaktionen;
-            VorteilMap mVorteile;
-            NachteilMap mNachteile;
-            SonderfertigkeitMap mSonderfertigkeiten;
-            WertMap mWerte;
-            AnimationsMap mAnimations;
-            AnimationSpeedsMap mAnimationSpeeds;
-            Ap mAp;
-            /// Zeigt auf das Inventar der Kreatur.
-            Inventory* mInventory;
-            Ogre::String mInventoryWindowType;
-
-            Property mAiProperties;
-
-            Alignment mAlignment;
-
-            /// this variable is only used in regenerateAu
-            float mTimeSinceLastRegeneration;
-            /// this variable is only used in regenerateAu (must be initialized with 3W6)
-            int mLastCalculatedAuToRegenerate;
-
-            /**
-             *  Sets a the status \a statusVariable. It uses a reference counting
-             *  System to do this, so if for example severeal effects put the creature
-             *  to sleep, and one effect ends the creature doesn't awake until all
-             *  the other effects end too. 
-             *  @param statusVariable is a reference to the status to be set, such as
-             *   \c mBlind.
-             *  @param value If true, the reference is increased, if false it is decreased.
-             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
-             *   than it was with \c true (i.e. the status is removed more often than
-             *   it was applied), \c setStatus throws an exception with \a errorMessage as
-             *   text.
-             *  @throw InvalidArgumentException see \a errorMessage.
-             **/
-            void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
-    };
-}
-#endif //__CREATURE_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __CREATURE_H__
+#define __CREATURE_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Date.h"
+#include "Effect.h"
+#include "Effect.h"
+#include "Eigenschaft.h"
+#include "GameObject.h"
+#include "ZauberStateSet.h"
+#include "SonderfertigkeitenStateSet.h"
+
+namespace rl
+{
+    class Container;
+    class Inventory;
+    class Item;
+    class Weapon;
+
+///////////////////////////////////////////////////////////////////////////////
+// Konstanten
+
+    /**
+    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
+    /**
+    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
+
+    /// Eine Doppel-1
+    static const int RESULT_AUTOERFOLG = 100;
+    /// Eine Dreifach-1
+    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
+    /// Eine Doppel-20
+    static const int RESULT_AUTOMISSERFOLG = -100;
+    /// Eine Dreifach-20
+    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
+    /**
+     *  Eine bestaetigte 1 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
+     *  eine einfache 1 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_GLUECKLICH = 100;
+    /**
+     *  Eine bestaetigte 20 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
+     *  eine einfache 20 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_PATZER = -100;
+    /// Eine normal gelungene Attacke oder Parade
+    static const int RESULT_ERFOLG = 1;
+    /// Eine normal misslungene Attacke oder Parade
+    static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
+
+    /// Basistalente
+    /// @todo Passenderen Ort suchen
+    static const CeGuiString TALENT_ART_BASIS = "Basis";
+    /// Spezialtalente
+    static const CeGuiString TALENT_ART_SPEZIAL = "Spezial";
+    /// Berufstalente
+    static const CeGuiString TALENT_ART_BERUF = "Beruf";
+
+    /**
+     *  @defgroup CreatureRubyExports Creature
+     *  @ingroup RulesRubyExports
+     **/
+
+    /**
+    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
+    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
+    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
+    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
+    * Spielwelt noetig ist (z.B. Proben).
+    */
+    class _RlRulesExport Creature : public GameObject
+    {
+        public:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  List of all talents. Consists of the (german) name of the talent
+             *  (e.g. "Athletik") as key and its value (TaW)
+             **/
+            typedef std::map<const CeGuiString, int> TalentMap;
+
+            static const Ogre::String CLASS_NAME;
+            static const Ogre::String PROPERTY_AI;
+            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
+			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+            static const Ogre::String PROPERTY_CURRENT_LE;
+            static const Ogre::String PROPERTY_CURRENT_AE;
+            static const Ogre::String PROPERTY_CURRENT_AU;
+            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
+            static const Ogre::String PROPERTY_EFFECTS;
+            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
+            static const Ogre::String PROPERTY_TALENTE;
+            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
+            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
+            static const Ogre::String PROPERTY_VORTEILE;
+            static const Ogre::String PROPERTY_NACHTEILE;
+            static const Ogre::String PROPERTY_SF;
+            static const Ogre::String PROPERTY_WERTE;
+            static const Ogre::String PROPERTY_AP;
+            static const Ogre::String PROPERTY_INVENTORY;
+            static const Ogre::String PROPERTY_ANIMATIONS;
+            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
+
+            typedef Ogre::String Wert;
+
+            // some targets
+			static const std::string ALL_EIGENSCHAFTEN;
+			static const std::string ALL_TALENTE;
+
+            static const Wert WERT_MOD_AE;
+            static const Wert WERT_MOD_LE;
+            static const Wert WERT_MOD_AU;
+            static const Wert WERT_MOD_MR;
+            static const Wert WERT_MOD_AT;
+            static const Wert WERT_MOD_PA;
+            static const Wert WERT_MOD_FK;
+            static const Wert WERT_GS;
+            static const Wert WERT_SOZIALSTATUS;
+            static const Wert WERT_BE;
+            static const Wert WERT_RS;
+            static const Wert WERT_INI;
+            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
+            static const Wert WERT_REGENERATION;
+    			
+			Creature(unsigned int id);
+
+            /// Der Standarddestruktor.
+            virtual ~Creature();
+
+///////////////////////////////////////////////////////////////////////////////
+// Enums
+            /// Alignment of a Creature towards the player. This determines
+            /// whether a combat is entered.
+            enum Alignment
+            {
+                ALIGNMENT_ALLY    = 1, ///< Creature fights with the player.
+                ALIGNMENT_NEUTRAL = 2, ///< Creature doesn't fight for either side.
+                ALIGNMENT_ENEMY   = 4  ///< Creature fights against the player.
+            };
+
+            /// Determines the damage type
+            enum DamageTag
+            {
+                DAMAGETAG_NORMAL = 1,
+                DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
+                DAMAGETAG_FIRE
+            };
+            /// The differente states a @ref abbdes "SF" can be in.
+             enum SfStatus
+            {
+                SFSTATUS_IN_TRAINING = 1,
+                SFSTATUS_OK,
+                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Werte
+
+            /**
+             *  Modifies the current @ref abbdel "LE" of the creature.
+             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
+             *  value).
+             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
+             **/
+            virtual void modifyLe(int mod, bool ignoreMax = false);
+            /**
+             *  Returns the current @ref abbdel "LE" of the creature.
+             **/
+            virtual int getLe() const;
+            /**
+             *  Returns the maximum @ref abbdel "LE" the creature can have.
+             **/
+            virtual int getLeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
+             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAe(int mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
+             **/
+            virtual int getAe() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
+             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAu(float mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
+             **/
+            virtual float getAu() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAuMax() const;
+
+            /**
+             *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
+             **/
+            virtual int getAttackeBasis() const;
+            /**
+             *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
+             **/
+            virtual int getParadeBasis() const;
+            /**
+             *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
+             **/
+            virtual int getFernkampfBasis() const;
+            /**
+             *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
+             **/
+            virtual int getInitiativeBasis() const;
+
+            /**
+             *  Setzt den Basiswert \a wertId auf \a value.
+             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
+             *  @param value Der neue wert des Basiswerts.
+             *  @see Wert
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void setWert(Wert wertId, int value);
+            /**
+                   *  Liefert den Basiswert \a wertId zurueck.
+             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
+                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
+                   *   zurueckgegeben.
+             *  @return Der Wert des Basiswerts.
+             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
+             *    gefunden werden.
+             **/
+            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
+
+            /**
+             *  Gibt der Kreatur @ref abbddea "AP".
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyAp(int modifier);
+            /**
+             *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
+             **/
+            int getAp() const;
+            /**
+             *  Veraendert die verbrauchten @ref abbdea "AP", wird beim Steigern
+             *  aufgerufen.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyUsedAp(int modifier);
+            /**
+             *  Liefert die verbrauchten @refabbdea "AP" zurueck.
+             **/
+            int getUsedAp() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Eigenschaften
+
+            /**
+             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @abbdef "FF", etc.).
+             *  @return Der Wert der Eigenschaft.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
+            /**
+             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
+            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
+
+///////////////////////////////////////////////////////////////////////////////
+// Talente
+
+            /**
+                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
+             *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
+             *  @param talentName Bezeichnet das Talent.
+                   *  @param value Startwert des Talents.
+             *  @throws InvalidArgumentException Das Talent konnte nicht
+             *    gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            void addTalent(const CeGuiString talentName, int value = 0);
+            /**
+                   *  Liefert den Wert des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent.
+             *  @return @ref abbdet "TaW"
+                   *  @ingroup CreatureRubyExports
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+             */
+
+            /**
+                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
+              * @param talentName Bezeichnet das Talent
+              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
+            */
+            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
+
+            virtual int getTalent(const CeGuiString talentName) const;
+            /**
+                   *  Setzt den Wert des Talents \a talentName.
+             *  @param talentName Bezeichnet das zu veraendernde Talent.
+             *  @param value Der neue @ref abbdet TaW.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void setTalent(const CeGuiString talentName, int value);
+            /**
+                   *  Erhoeht das Talent \a talentName um \a mod.
+             *  @param talentName Bezeichnet das zu steigernde Talent.
+             *  @param mod Der Wert um den das Talent gesteigert werden soll.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void modifyTalent(const CeGuiString talentName, int mod);
+            /**
+             * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
+             * Dies wird auch der komplette Talentspiegel genannt.
+             **/
+            virtual const Creature::TalentMap& getAllTalents() const;
+            /**
+                   *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
+                   *  Spezielle Erfahrungen, MFF 47.
+             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void addSe(const CeGuiString talentName);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampftechniken
+
+            /**
+             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
+             *  @param kampftechnikName Bezeichnet die Kampftechnik.
+             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
+             *  (0,0).
+             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
+                   *  @ingroup CreatureRubyExports
+             **/
+            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value = std::make_pair(0, 0));
+            /**
+                   *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
+                   *  bestimmten Kampftechnik zurueck.
+             *  @param kampftechnikName Beszeichnet die Kampftechnik.
+             *  @return Ein std::pair<AT, PA>.
+             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
+             *   \c mKampftechniken gefunden werden.
+             **/
+            virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
+            /**
+                   *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
+                   *  Kampftechnik.
+             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
+             *  @param value Die neuen AT/PA Werte.
+             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
+             *    konnte nicht in \c mKampftechniken gefunden werden.
+             **/
+            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampfaktionen (Attacke, Parade, etc..)
+
+            void addKampfaktion(const CeGuiString& kampfaktionName);
+            bool hasKampfaktion(const CeGuiString& kampfaktionName) const;
+			const std::set<CeGuiString>& getAllKampfaktionen() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Vorteile
+            /**
+             *  Fuegt einen Vorteil hinzu.
+             *  @param vorteilName Der Name des Vorteils.
+             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
+             *   Vorteils (z.B. Astrale Regeneration 3).
+             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
+             **/
+            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
+
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
+             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
+             **/
+            virtual bool hasVorteil(const CeGuiString vorteilName) const;
+ 
+///////////////////////////////////////////////////////////////////////////////
+// Nachteile
+            /**
+             *  Fuegt einen Nachteil hinzu.
+             *  @param nachteilName Der Name des Nachteils.
+             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
+             *   die Stufe des Nachteils.
+             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
+             **/
+            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
+             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
+             **/
+            virtual bool hasNachteil(const CeGuiString nachteilName) const;
+            /**
+             *  Liefert das StateSet des Nachteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
+             *  abzufragen.
+             *  @param nachteilName Der Name der Schlechten Eigenschaft.
+             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
+             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Sonderfertigkeiten
+
+            /**
+                    *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
+             *  @param sfName Bezeichnet die SF.
+                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
+             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
+             *    werden.
+                    *  @see SfStatus
+             */
+            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+            /**
+                   *  Liefert den Wert der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual int getSf(const CeGuiString sfName) const;
+            /**
+                   *  Setzt den Wert der @ref abbdes "SF".
+             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
+             *   werden soll.
+             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
+             *   soll.
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual void setSf(const CeGuiString sfName, SfStatus value);
+
+            /**
+             *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
+            *  @throws InvalidArgumentException \a sfName kann nicht in 
+            *   \c mSonderfertigkeiten gefunden werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Status
+            /**
+             * Gets the status of a creature.
+             **/
+			Effect::LifeState getLifeState() const;
+
+
+            bool isMagic() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Inventory
+
+
+            /**
+             *  Gibt das Inventar der Kreatur zurueck.
+             *  @return Liefert einen Zeiger auf Inventar der Kreatur
+             **/
+            Inventory* getInventory() const;
+
+        const Ogre::String& getInventoryWindowType() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Aktionen
+            /**
+            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
+            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
+            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
+            *  die Angabe einer Spezialisierung.
+            *  @param talentName Bezeichnet das Talent
+            *  @param spezialisierungId Bezeichnet die Spezialisierung
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
+            *     gewuerfelt werden soll
+            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
+            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
+            *  @return uebrig gebliebene Talentpunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
+            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
+            */
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int,int)
+             *  This is the function that should be used in most cases.
+             **/
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int);
+             *  This is the function you should usually use, if there is no fitting
+             *  specialization for the task.
+             *  @ingroup CreatureRubyExports
+             **/
+            /**
+             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
+             **/
+		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
+                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
+                                                 CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
+
+			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+                                      int modifier);
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
+
+            /**
+            *  Durchfuehren einer Eigenschaftsprobe.
+            *  @param eigenschaftName Bezeichnet die Eigenschaft
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
+            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
+            *  @ingroup CreatureRubyExports
+            */
+			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+            /**
+            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Attacke ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Attacke.
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   mKampftechniken gefunden.
+            **/
+            int doAttacke(const CeGuiString kampftechnikName, int modifier);
+            /**
+            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Parade ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Parade.
+            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+            *  @retval RESULT_GLUECKLICH Eine gute Parade.
+            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   \c mKampftechniken gefunden.
+            **/
+            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
+
+            /**
+             *  Fuehrt einen Initiativewurf durch.
+             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
+             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
+             *    'Orientieren'.
+             **/
+            int doInitiativeWurf(bool getMaxInitiative = false);
+
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
+
+            /**
+             *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
+             *  @param tp die Trefferpunkte
+                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
+                   *   etc. korrekt zu beruecksichtigen.
+             **/
+            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+            static const int LEDAMAGE_NORMAL = 0;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
+
+            /**
+             *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
+             *  @param aup die Trefferpunkte
+             **/
+            void damageAe(int asp);
+
+            /**
+            *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
+            *  @param aup die Trefferpunkte
+             *  @param damageType Typ des Schadens, um Resistenzen
+             *   etc. korrekt zu beruecksichtigen.
+            **/
+            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
+            static const int AUDAMAGE_NORMAL = 0;
+            static const int AUDAMAGE_HEAT = 1;
+            static const int AUDAMAGE_COLD = 2;
+            static const int AUDAMAGE_CHOKE = 4;
+            static const int AUDAMAGE_DROWN = 8;
+
+            /**
+             *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateLe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateAe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
+             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+             *  Parameter time aufgerufen werden.
+             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
+             *   selten eingesetzt werden.
+             *  @param time Sollte nur benutzt werden, falls es nicht m???lich ist
+             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
+             **/
+            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
+
+
+            virtual const Property getProperty(const CeGuiString& key) const;
+            virtual void setProperty(const CeGuiString& key, const Property& value);
+            virtual PropertyKeys getAllPropertyKeys() const;
+
+            void setAlignment(Alignment);
+            Alignment getAlignment() const;
+
+
+
+            /**
+             * Gibt an, ob die Creature mit den H??nden an den Gegenstand herankommt,
+             * ihn also ber??hren kann, mit ihm interagieren etc
+            **/
+            virtual bool canReachItem(const Item* item) const;
+
+            /**
+             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
+             * den CreatureController
+            **/
+            typedef std::pair<Ogre::String, Ogre::Real> AnimationSpeedPair;
+            /**
+             * Gibt die Animation aus der AnimationsMap f??r den CreatureController zur??ck
+             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
+             * der Schl??sse name und eine Geschwindigkeit von 1 zurueckgegeben
+            **/
+            AnimationSpeedPair getAnimation(const CeGuiString& name) const;
+
+        protected:
+           /**
+             *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
+             **/
+            virtual int getAeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
+             **/
+            virtual int getAuBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
+             **/
+            virtual int getLeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
+             **/
+            virtual int getMrBasis() const;
+            /**
+             *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
+             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
+             **/
+            virtual int getCurrentBe() const;
+
+            /// inherited from GameObject
+            virtual void doPlaceIntoScene();
+
+            /// inherited from GameObject
+            virtual void doRemoveFromScene();
+
+
+
+
+        private:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  Liste der Werte.
+             *  @see Wert
+             **/
+            typedef std::map<const Wert, int> WertMap;
+            /**
+                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
+                   *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
+                   *  und einem Zeiger auf ihr StateSet.
+             **/
+            typedef std::map<const CeGuiString, int> EigenschaftMap;
+            /**
+             *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
+             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
+             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
+                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
+             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
+             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
+             *  Kampftalent entsprechen.
+             **/
+            typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
+            /**
+             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
+             *  den Vorteilen, verhalten sich aber wie Talente.
+             **/
+            typedef std::map<const CeGuiString, int> VorteilMap;
+            /**
+             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
+             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
+             **/
+            typedef std::map<const CeGuiString, int> NachteilMap;
+            /**
+                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
+                   *  Sonderfertigkeit als Schluessel und ihrem Status.
+             */
+            typedef std::map<const CeGuiString , SonderfertigkeitenStateSet*> SonderfertigkeitMap;
+            /**
+                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl??ssel ist Bezeichner der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
+                    * an.
+            **/
+            typedef std::map<const CeGuiString, CeGuiString> AnimationsMap;
+            /**
+                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
+                    * CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl??ssel ist Bezeichner, der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird.
+            **/
+            typedef std::map<const CeGuiString, Ogre::Real> AnimationSpeedsMap;
+            struct Ap
+            {
+                int total;
+                int used;
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Membervariablen
+            /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
+            int mCurrentLe;
+            /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
+            int mCurrentAe;
+            /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
+            float mCurrentAu;
+            /// Die aktuelle Erschoepfung der Kreatur.
+            int mErschoepfung;
+            /// Zuletzt zugewiesene Bewegungsart
+            int mMovementType;
+
+            /// Zeigt auf die gerade aktive Waffe.
+            EigenschaftMap mEigenschaften;
+            TalentMap mTalente;
+            KampftechnikMap mKampftechniken;
+			std::set<CeGuiString> mKampfaktionen;
+            VorteilMap mVorteile;
+            NachteilMap mNachteile;
+            SonderfertigkeitMap mSonderfertigkeiten;
+            WertMap mWerte;
+            AnimationsMap mAnimations;
+            AnimationSpeedsMap mAnimationSpeeds;
+            Ap mAp;
+            /// Zeigt auf das Inventar der Kreatur.
+            Inventory* mInventory;
+            Ogre::String mInventoryWindowType;
+
+            Property mAiProperties;
+
+            Alignment mAlignment;
+
+            /// this variable is only used in regenerateAu
+            float mTimeSinceLastRegeneration;
+            /// this variable is only used in regenerateAu (must be initialized with 3W6)
+            int mLastCalculatedAuToRegenerate;
+
+            /**
+             *  Sets a the status \a statusVariable. It uses a reference counting
+             *  System to do this, so if for example severeal effects put the creature
+             *  to sleep, and one effect ends the creature doesn't awake until all
+             *  the other effects end too. 
+             *  @param statusVariable is a reference to the status to be set, such as
+             *   \c mBlind.
+             *  @param value If true, the reference is increased, if false it is decreased.
+             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
+             *   than it was with \c true (i.e. the status is removed more often than
+             *   it was applied), \c setStatus throws an exception with \a errorMessage as
+             *   text.
+             *  @throw InvalidArgumentException see \a errorMessage.
+             **/
+            void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
+    };
+}
+#endif //__CREATURE_H__

Modified: rl/trunk/engine/rules/include/Weapon.h
===================================================================
--- rl/trunk/engine/rules/include/Weapon.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Weapon.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (unsigned int id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString& getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/trunk/engine/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/ApplyDamageJob.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/ApplyDamageJob.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,41 +1,42 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h"
-#include "ApplyDamageJob.h"
-
-#include "Creature.h"
-
-namespace rl 
-{
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
-:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
-    mTarget(target), 
-    mTp(tp)
-{
-}
-
-ApplyDamageJob::~ApplyDamageJob()
-{
-}
-
-bool ApplyDamageJob::execute(Ogre::Real time)
-{
-    mTarget->damageLe(mTp);
-    return true;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h"
+#include "ApplyDamageJob.h"
+
+#include "Creature.h"
+
+namespace rl 
+{
+
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
+:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
+    mTarget(target), 
+    mDamage(damage),
+    mType(damageType)
+{
+}
+
+ApplyDamageJob::~ApplyDamageJob()
+{
+}
+
+bool ApplyDamageJob::execute(Ogre::Real time)
+{
+    mTarget->damageLe(mDamage, mType);
+    return true;
+}
+
+} // namespace rl

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Combat.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft nach "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft nach "
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant->doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft zu "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft zu "
 							    + entry.target->getName(), GET_COMBAT);
 						    combatant->doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor->getName() + " attackiert " + target->getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor->rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult >= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent("Erfolg, aber pariert.", GET_COMBAT);
-                        if (target->getActiveWeapon()->isNatural())
+                        if (target->getActiveWeapon()->isNatural() && !actor->getActiveWeapon()->isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target->getActiveWeapon()->isNatural() && actor->getActiveWeapon()->isNatural())
+                        {
+                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target->getActiveWeapon()->isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target->doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetDamage, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor->rollTrefferpunkte();
-            jobSetAnims->add(new ApplyDamageJob(target->getCreature(), tp));
-
-			CeGuiString msg = actor->getName() + " trifft f?r "
+			int tp = actor->rollTrefferpunkte(damageStrength);
+            jobSet->add(new ApplyDamageJob(target->getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor->getName() + " trifft fuer "
             + CeGuiString(StringConverter::toString(tp))
             + " Trefferpunkte";
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature->getName() + " ist jetzt ";
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += "kampfunf?hig.";
+						msg += "kampfunf???hig.";
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/trunk/engine/rules/src/Combatant.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combatant.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Combatant.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -85,9 +85,9 @@
 		return getCreature()->doParade(weapon->getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()->doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()->doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Creature.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,1304 +1,1314 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Creature.h"
-
-#include "Actor.h"
-#include "Container.h"
-#include "CreatureControllerManager.h"
-#include "DsaManager.h"
-#include "Eigenschaft.h"
-#include "EffectFactory.h"
-#include "EffectManager.h"
-#include "Exception.h"
-#include "Inventory.h"
-#include "Kampftechnik.h"
-#include "MeshObject.h"
-#include "MessagePump.h"
-#include "RulesMessages.h"
-#include "StateSet.h"
-#include "Slot.h"
-#include "Talent.h"
-#include "Weapon.h"
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Creature::CLASS_NAME = "Creature";
-
-    const Ogre::String Creature::PROPERTY_AI = "ai";
-    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = "behaviours";
-    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
-    const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
-    const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
-    const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
-    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = "current_fatigue";
-    const Ogre::String Creature::PROPERTY_EFFECTS = "effects";
-    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = "eigenschaften";
-    const Ogre::String Creature::PROPERTY_TALENTE = "talente";
-    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = "kampftechniken";
-    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = "kampfaktionen";
-    const Ogre::String Creature::PROPERTY_VORTEILE = "vorteile";
-    const Ogre::String Creature::PROPERTY_NACHTEILE = "nachteile";
-    const Ogre::String Creature::PROPERTY_SF = "sonderfertigkeiten";
-    const Ogre::String Creature::PROPERTY_WERTE = "werte";
-    const Ogre::String Creature::PROPERTY_AP = "ap";
-    const Ogre::String Creature::PROPERTY_INVENTORY = "inventory";
-    const Ogre::String Creature::PROPERTY_ANIMATIONS = "animations";
-    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = "animationspeeds";
-
-    // some targets
-	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
-	const std::string Creature::ALL_TALENTE = "alle Talente";
-	const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
-    const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
-    const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
-    const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
-    const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
-    const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
-    const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
-    const Creature::Wert Creature::WERT_GS = "GS";
-    const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
-    const Creature::Wert Creature::WERT_BE = "BE";
-    const Creature::Wert Creature::WERT_RS = "RS";
-    const Creature::Wert Creature::WERT_INI = "INI";
-    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
-    const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-
-
-
-    Creature::Creature(unsigned int id)
-        : GameObject(id),
-		mCurrentLe(0),
-        mCurrentAu(0),
-        mCurrentAe(0),
-		mInventory(NULL),
-		mEigenschaften(),
-		mWerte(),
-		mTalente(),
-        mKampftechniken(),
-		mKampfaktionen(),
-        mSonderfertigkeiten(),
-        mErschoepfung(0),
-        mMovementType(0),
-        mAlignment(ALIGNMENT_NEUTRAL),
-        mTimeSinceLastRegeneration(0),
-        mLastCalculatedAuToRegenerate(
-                  DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6())
-    {
-        mQueryFlags |= QUERYFLAG_CREATURE;
-
-		setWert(WERT_MOD_AE, 0);
-		setWert(WERT_MOD_LE, 0);
-		setWert(WERT_MOD_AU, 0);
-		setWert(WERT_MOD_MR, 0);
-		setWert(WERT_GS, 8);
-        setWert(WERT_RS, 0);
-        setWert(WERT_BE, 0);
-        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
-		mEigenschaften[E_MUT] = 0;
-		mEigenschaften[E_KLUGHEIT] = 0;
-		mEigenschaften[E_INTUITION] = 0;
-		mEigenschaften[E_CHARISMA] = 0;
-		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
-		mEigenschaften[E_GEWANDTHEIT] = 0;
-		mEigenschaften[E_KONSTITUTION] = 0;
-		mEigenschaften[E_KOERPERKRAFT] = 0;
-
-		mInventory = new Inventory(this);
-    }
-
-	Creature::~Creature()
-    {
-        delete mInventory;
-
-        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
-            delete it->second;
-        mSonderfertigkeiten.clear();
-        CreatureControllerManager::getSingleton().detachController(this);
-    }
-
-    int Creature::getAttackeBasis() const
-    {
-		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getParadeBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getFernkampfBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getInitiativeBasis() const
-    {
-      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getMrBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getLeBasis() const
-    {
-      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-    int Creature::getAuBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-	int Creature::getAeBasis() const
-	{
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-	int Creature::getWert(Wert wertId, bool getUnmodified) const
-	{
-		WertMap::const_iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + ": Wert " + wertId.c_str() + " nicht gefunden.").c_str());
-            return 0;
-        }
-        int rval = it->second;
-        if (!getUnmodified)
-        {
-          rval += mEffectManager->getMod(wertId, Effect::MODTYPE_SUM);
-          rval *= mEffectManager->getMod(wertId, Effect::MODTYPE_MULT);
-        }
-		return rval;
-	}
-
-	int Creature::getCurrentBe() const
-	{
-		pair<int,int> be = mInventory->getOverallBe();
-        ///@todo Ruestungsgewoehnung?
-		return be.first+be.second;
-	}
-
-	void Creature::setWert(Wert wertId, int value)
-	{
-		WertMap::iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-			mWerte.insert(make_pair(wertId, value));
-        }
-		else
-		{
-			it->second = value;
-		}
-	}
-
-   void Creature::modifyLe(int mod, bool ignoreMax)
-    {
-        int oldLe = mCurrentLe;
-        mCurrentLe += mod;
-		if (!ignoreMax)
-		{
-			mCurrentLe = min(mCurrentLe, getLeMax());
-		}
-
-        if (mCurrentLe <= -getEigenschaft("KO") && oldLe > -getEigenschaft("KO"))
-        {
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("DeadEffect"));
-        }
-        else if (mCurrentLe > -getEigenschaft("KO") && oldLe <= -getEigenschaft("KO"))
-        {
-            mEffectManager->removeEffect("DeadEffect");
-        }
-        else if (mCurrentLe <= 0 && oldLe > 0)
-        {
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("UnconsciousEffect"));
-        }
-        else if (mCurrentLe > 0 && oldLe <= 0)
-        {
-            mEffectManager->removeEffect("UnconciousEffect");
-        }
-		else if (mCurrentLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
-            oldLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("IncapacitatedEffect"));
-		}
-		else if (mCurrentLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
-            oldLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager->removeEffect("IncapacitatedEffect");
-		}
-
-        fireObjectStateChangeEvent();
-
-    }
-
-    int Creature::getLe() const
-    {
-        return mCurrentLe;
-    }
-
-    int Creature::getLeMax() const
-    {
-		return getLeBasis() + getWert(WERT_MOD_LE);
-    }
-
-    void Creature::modifyAe(int mod, bool ignoreMax)
-    {
-        mCurrentAe += mod;
-		if (!ignoreMax)
-			mCurrentAe = min(mCurrentAe, getAeMax());
-		fireObjectStateChangeEvent();
-    }
-
-    int Creature::getAe() const
-    {
-        return mCurrentAe;
-    }
-
-    int Creature::getAeMax() const
-    {
-		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
-    }
-
-    void Creature::modifyAu(float mod, bool ignoreMax)
-    {
-        mCurrentAu = max(mCurrentAu + mod, 0.0f);
-		if (!ignoreMax)
-			mCurrentAu = min(mCurrentAu, float(getAuMax()));
-        if (getAu() <= 0)
-        {
-            ///@todo set incapacitated
-        }
-		fireObjectStateChangeEvent();
-    }
-
-    float Creature::getAu() const
-    {
-        return mCurrentAu;
-    }
-
-    int Creature::getAuMax() const
-    {
-		return getAuBasis() + getWert(WERT_MOD_AU);
-    }
-
-    void Creature::modifyAp(int modifier)
-    {
-        mAp.total += modifier;
-    }
-
-    int Creature::getAp() const
-    {
-        return mAp.total;
-    }
-
-    void Creature::modifyUsedAp(int modifier)
-    {
-        mAp.used += modifier;
-    }
-
-    int Creature::getUsedAp() const
-    {
-        return mAp.used;
-    }
-
-    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
-    {
-		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-		if (it == mEigenschaften.end())
-		{
-			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-		}
-		int result = it->second;
-        result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
-        return result;
-    }
-
-    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
-    {
-        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
-        if (it == mEigenschaften.end())
-        {
-            Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-        }
-		it->second = value;
-        fireObjectStateChangeEvent();
-    }
-
-    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
-    {
-		mEigenschaften[eigenschaftName] += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
-    {
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-            return true;
-        /*
-        if( ausweich )
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt != ausweichTalente.end())
-            {
-                return true;
-            }
-        }
-        */
-		
-        return false;
-    }
-
-    int Creature::getTalent(const CeGuiString talentName) const
-    {
-        LOG_DEBUG(Logger::RULES, "Using talent " + talentName);
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt == ausweichTalente.end())
-            {
-                Throw(IllegalArgumentException, "Talent nicht gefunden.");
-            }
-            int rval = getTalent(ausweichIt->first) - ausweichIt->second;
-            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
-            {
-                int tempAusweichTaw = getTalent(ausweichIt->first)
-                    - ausweichIt->second;
-                if (tempAusweichTaw > rval) rval = tempAusweichTaw;
-            }
-            return rval;
-        } //if (it == mTalente.end())
-		return it->second;
-    }
-
-	void Creature::addTalent(const CeGuiString talentName, int value)
-	{
-		TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-        {
-			Throw(IllegalArgumentException, "Talent schon in mTalente enthalten.");
-        }
-	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
-		mTalente[talentName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::modifyTalent(const CeGuiString talentName, int mod)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		it->second += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-	const Creature::TalentMap& Creature::getAllTalents() const
-	{
-		return mTalente;
-	}
-
-    void Creature::setTalent(const CeGuiString talentName, int value)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		it->second = value;
-		fireObjectStateChangeEvent();
-    }
-
-	void Creature::addSe(const CeGuiString talentName)
-	{
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		//it->second->setSe( true );
-        /// @todo Implement SEs
-	}
-
-	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it != mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException,
-				"Kampftechnik schon in mKampftechniken enthalten.");
-		}
-		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
-		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
-		mKampftechniken[kampftechnikName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    pair<int, int> Creature::getKampftechnik(const CeGuiString kampftechnikName) const
-    {
-        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
-        }
-        return (*it).second;
-    }
-
-    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair<int, int>& value)
-    {
-        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
-        }
-        (*it).second = value;
-		fireObjectStateChangeEvent();
-    }
-
-    void Creature::addKampfaktion(const CeGuiString& kampfaktionName)
-	{
-		mKampfaktionen.insert(kampfaktionName);
-	}
-
-    bool Creature::hasKampfaktion(const CeGuiString& kampfaktionName) const
-	{
-		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
-	}
-
-	const std::set<CeGuiString>& Creature::getAllKampfaktionen() const
-	{
-		return mKampfaktionen;
-	}
-
-    void Creature::addVorteil(const CeGuiString vorteilName, int value)
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            Throw(IllegalArgumentException, "Vorteil schon in mVorteile enthalten");
-        }
-        mVorteile[vorteilName] = value;
-    }
-
-    bool Creature::hasVorteil(const CeGuiString vorteilName) const
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    void Creature::addNachteil(const CeGuiString nachteilName, int value)
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            Throw(IllegalArgumentException, "Nachteil schon in mNachteile enthalten");
-        }
-        mNachteile[nachteilName] = value;
-    }
-
-    bool Creature::hasNachteil(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it == mNachteile.end())
-        {
-            Throw(IllegalArgumentException, "Nachteil nicht gefunden.");
-        }
-		else return it->second + mEffectManager->getMod(nachteilName, Effect::MODTYPE_SUM);
-    }
-
-    int Creature::getSf(const CeGuiString sfName) const
-    {
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		return it->second->getValue();
-    }
-
-	void Creature::addSf(const CeGuiString sfName, SfStatus value)
-	{
-		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-		if (it != mSonderfertigkeiten.end())
-		{
-			Throw(IllegalArgumentException, "Sonderfertigkeit schon in mSonderfertigkeiten enthalten.");
-		}
-		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
-        /// @todo
-		//DsaManager::getSingleton().getSf(sfName);
-		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
-		mSonderfertigkeiten[sfName]->setOriginalValue( value );
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::setSf(const CeGuiString sfName, SfStatus value)
-    {
-        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		it->second->setOriginalValue( value );
-		fireObjectStateChangeEvent();
-    }
-
-	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
-	{
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		return it->second;
-	}
-
-    Effect::LifeState Creature::getLifeState() const
-    {
-      return mEffectManager->getLifeState();
-    }
-
-	bool Creature::isMagic() const
-	{
-		return getWert(WERT_MOD_AE) > 0;
-	}
-
-    void Creature::setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage)
-    {
-        if (value == true)
-        {
-            statusVariable++;
-        }
-        else //value == false
-        {
-            if (statusVariable > 0)
-            {
-                statusVariable--;
-            }
-            else
-            {
-                LOG_MESSAGE(Logger::RULES, errorMessage);
-            }
-        } //value == false
-    }
-
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) ||
-			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
-		{
-          /// @todo Find proper return value. Prompt an error message?
-			//Throw(OutOfRangeException, "TaW zu niedrig");
-          return -1;
-		}
-        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
-
-        // Der Probenwurf
-        Tripel<int> probe(DsaManager::getSingleton().roll3D20());
-
-		// Glueckliche
-		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) )
-		{
-			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
-			modifyTalent(talentName, +1);
-			return RESULT_SPEKT_AUTOERFOLG;
-		}
-		if ( ((probe.first == 1) && (probe.second == 1)) ||
-			 ((probe.first == 1) && (probe.third == 1)) ||
-			 ((probe.second == 1) && (probe.third == 1)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOERFOLG;
-		}
-		// Patzer
-		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20))
-		{
-			addSe(talentName);
-			return RESULT_SPEKT_AUTOMISSERFOLG;
-		}
-		if ( ((probe.first == 20) && (probe.second == 20)) ||
-			 ((probe.first == 20) && (probe.third == 20)) ||
-			 ((probe.second == 20) && (probe.third == 20)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOMISSERFOLG;
-		}
-
-
-        // Vor dem Vergleich hat man den Talentwert ??brig.
-		int eBe = DsaManager::getSingleton().getTalent(talentName)->calculateEbe(mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM));
-		int taW = getTalent(talentName);
-		int rval = taW - modifier - mEffectManager->getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
-            - mEffectManager->getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
-		// Bei negativen TaP*
-		int handicap = 0;
-		if (rval < 0)
-		{
-			handicap = -rval;
-			rval = 0;
-		}
-
-        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
-        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
-        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
-
-        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
-        // wird die Differenz vom Talentwert abgezogen.
-        rval = diff1 < 0 ? rval + diff1 : rval;
-        rval = diff2 < 0 ? rval + diff2 : rval;
-        rval = diff3 < 0 ? rval + diff3 : rval;
-
-		// TaP* niemals gr????er als TaW (MFF14)
-		if (rval > taW) rval = taW;
-        return rval;
-    }
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
-			eigenschaft2Name, eigenschaft3Name);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
-			et.first, et. second, et.third);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
-			et. second, et.third);
-	}
-
-    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
-    {
-        int rval;
-
-        int probe = DsaManager::getSingleton().rollD20();
-        if (probe == 1)
-        {
-            rval = RESULT_GLUECKLICH;
-        }
-        else if (probe == 20)
-        {
-            rval = RESULT_PATZER;
-        }
-        else
-        {
-			rval = getEigenschaft(eigenschaftName) -
-                (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
-        }
-        return rval;
-    }
-
-
-	Inventory* Creature::getInventory() const
-	{
-		return mInventory;
-	}
-
-    const Ogre::String& Creature::getInventoryWindowType() const
-    {
-        return mInventoryWindowType;
-    }
-
-	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
-		}
-		int rval;
-		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best??tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20) /// @todo Best??tigen
-		{
-			rval = RESULT_PATZER;
-		}
-		else
-		{
-			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
-                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval < 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
-		}
-		int rval;
-		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best??tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20)
-		{
-			rval = RESULT_PATZER; /// @todo Best??tigen
-		}
-		else
-		{
-			/// @todo Gute Parade
-			rval = getParadeBasis() + (*it).second.second - (probe + modifier
-                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval < 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doInitiativeWurf(bool getMaxInitiave)
-	{
-		int rval = getInitiativeBasis();
-		rval += mEffectManager->getMod(WERT_INI, Effect::MODTYPE_SUM);
-		rval -= mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM);
-		if (getMaxInitiave)
-        {
-            rval += 6;
-        }
-        else
-        {
-            rval += DsaManager::getSingleton().rollD6();
-        }
-		return rval;
-	}
-
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
-	{
-		// Roll dice
-		const Tripel<int>& weaponTp = weapon->getTp();
-		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
-		rval += weaponTp.third;
-
-		// Apply TP/KK
-
-		int kk = getEigenschaft(E_KOERPERKRAFT);
-		std::pair<int, int> tpkk = weapon->getTpKk();
-		
-		int bonus = (kk - tpkk.first) / tpkk.second;
-		rval += bonus;
-
-		return rval;
-	}
-
-	/// @todo Implement correctly
-	void Creature::damageLe(int tp, int damageType)
-	{
-        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-        if (tp < 0)
-        {
-            tp = 0;
-        }
-
-        ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
-        {
-            LOG_ERROR("Creature", "Fire damage not handled!"); ///@todo implement
-        }
-        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER)
-        {
-            LOG_ERROR("Creature", "Water damage not handled!"); ///@todo implement
-        }
-        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
-        {
-            LOG_ERROR("Creature", "Demonic damage not handled!"); ///@todo implement
-        }
-
-        if ((damageType & LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
-        {
-            damageAu(tp, AUDAMAGE_NORMAL);
-            tp = (int)floor(tp/2.);
-        }
-
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
-		modifyLe(sp);
-
-        if (sp >= getEigenschaft("KO"))
-        {
-            LOG_ERROR("Creature", "TODO: Add a wound."); ///@todo implement
-        }
-	}
-
-    void Creature::damageAe(int asp)
-    {
-        if (asp < 0)
-        {
-         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           asp = 0;
-        }
-        modifyAe(-asp);
-    }
-
-    void Creature::damageAu(float aup, int damageType)
-    {
-        if (aup < 0)
-        {
-         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           aup = 0;
-           ///@todo evtl. eine modifyErschoepfung()?
-           mErschoepfung += DsaManager::getSingleton().rollD6();
-           ///@todo set incapacitated
-        }
-        // bei ??beranstrengung, kostet alles doppelte Au!!!!!
-        if( mErschoepfung > getEigenschaft("KO") )
-            aup *= 2;
-        modifyAu(-aup);
-    }
-
-    void Creature::regenerateLe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedLe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedLe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
-            0, Effect::MODTAG_REGENERATION_LE))
-        {
-            regeneratedLe++;
-        }
-        //modifiziere die aktuellen LE
-        modifyLe(regeneratedLe);
-    }
-
-    void Creature::regenerateAe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedAe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedAe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN",
-            0, Effect::MODTAG_REGENERATION_AE))
-        {
-            regeneratedAe++;
-        }
-        //modifiziere die aktuellen AE
-        modifyAe(regeneratedAe);
-    }
-
-    void Creature::regenerateAu(int modifier, float factor, float time)
-    {
-        // das Ganze nur jede Spielrunde machen
-        mTimeSinceLastRegeneration += time;
-
-
-        if( getAu() == getAuMax() )
-        {
-            mTimeSinceLastRegeneration = 0;
-            return;
-        }
-
-
-        while( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE )
-        {
-            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
-
-
-            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
-            //Grundregeneration von 3W6
-            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6();
-            //Addiere eventuelle Modifikatoren hinzu
-            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
-            //Bei gelungener KO Probe addiere 1
-            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
-                0, mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
-            {
-                modifyAu(6*factor);
-            }
-
-            if( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
-            {
-                //modifiziere die aktuellen AU
-                time -= Date::ONE_SPIELRUNDE;
-                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
-            }
-
-            if( getAu() == getAuMax() )
-            {
-                mTimeSinceLastRegeneration = 0;
-                return;
-            }
-        }
-
-        // Restbetrag regenerieren:
-        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
-        modifyAu(regeneratedAuPerTime*factor);
-    }
-
-    void Creature::setAlignment(Creature::Alignment alignment)
-    {
-        mAlignment = alignment;
-    }
-
-    Creature::Alignment Creature::getAlignment() const
-    {
-        return mAlignment;
-    }
-
-    void Creature::setProperty(const CeGuiString& key, const Property& value)
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            mAiProperties = value;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            mInventoryWindowType = value.toString().c_str();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            mCurrentLe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            mCurrentAe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            mCurrentAu = value.toReal();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            mErschoepfung = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            mEigenschaften.clear();
-            convertToMap(value.toMap(), mEigenschaften);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            mTalente.clear();
-            convertToMap(value.toMap(), mTalente);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            mKampftechniken.clear();
-            convertToMap(value.toMap(), mKampftechniken);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            mKampfaktionen.clear();
-            convertToSet(value.toArray(), mKampfaktionen);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            mVorteile.clear();
-            convertToMap(value.toMap(), mVorteile);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            mNachteile.clear();
-            convertToMap(value.toMap(), mNachteile);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            mWerte.clear();
-            convertToMap(value.toMap(), mWerte);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            IntPair ip = value.toIntPair();
-            mAp.total = ip.first;
-            mAp.used = ip.second;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            mInventory->setProperties(value.toMap());
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            mAnimations.clear();
-            convertToMap(value.toMap(), mAnimations);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            mAnimationSpeeds.clear();
-            convertToMap(value.toMap(), mAnimationSpeeds);
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Creature::getProperty(const CeGuiString& key) const
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            return mAiProperties;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            return Property(mInventoryWindowType);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            return Property(mCurrentLe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            return Property(mCurrentAe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            return Property(mCurrentAu);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            return Property(mErschoepfung);
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mTalente);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
-            return Property(vec);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mVorteile);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mNachteile);
-            return Property(map);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mWerte);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            return Property(make_pair(mAp.total, mAp.used));
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-			return mInventory->getAllProperties()->toPropertyMap();
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimations);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
-            return Property(map);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Creature::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Creature::PROPERTY_AI);
-        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
-        keys.insert(Creature::PROPERTY_CURRENT_LE);
-        keys.insert(Creature::PROPERTY_CURRENT_AE);
-        keys.insert(Creature::PROPERTY_CURRENT_AU);
-        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
-        keys.insert(Creature::PROPERTY_TALENTE);
-        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
-        keys.insert(Creature::PROPERTY_VORTEILE);
-        keys.insert(Creature::PROPERTY_NACHTEILE);
-        //keys.insert(Creature::PROPERTY_SF);
-        keys.insert(Creature::PROPERTY_WERTE);
-        keys.insert(Creature::PROPERTY_AP);
-        keys.insert(Creature::PROPERTY_INVENTORY);
-        keys.insert(Creature::PROPERTY_ANIMATIONS);
-        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
-
-        return keys;
-    }
-
-    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString& name) const
-    {
-        AnimationSpeedPair ret;
-        AnimationsMap::const_iterator itName = mAnimations.find(name);
-        if( itName != mAnimations.end() )
-            ret.first = itName->second.c_str();
-        else
-            ret.first = name.c_str();
-
-        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
-        if( itSpeed != mAnimationSpeeds.end() )
-            ret.second = itSpeed->second;
-        else
-            ret.second = 1;
-
-        return ret;
-    }
-
-    bool Creature::canReachItem(const Item* item) const
-    {
-        return (item->getPosition() - getPosition()).length() <= 3.0f;
-    }
-
-    void Creature::doPlaceIntoScene()
-    {
-        GameObject::doPlaceIntoScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory->getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it->second->update();
-        }
-    }
-
-    void Creature::doRemoveFromScene()
-    {
-        GameObject::doRemoveFromScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory->getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it->second->update();
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Creature.h"
+
+#include "Actor.h"
+#include "Container.h"
+#include "CreatureControllerManager.h"
+#include "DsaManager.h"
+#include "Eigenschaft.h"
+#include "EffectFactory.h"
+#include "EffectManager.h"
+#include "Exception.h"
+#include "Inventory.h"
+#include "Kampftechnik.h"
+#include "MeshObject.h"
+#include "MessagePump.h"
+#include "RulesMessages.h"
+#include "StateSet.h"
+#include "Slot.h"
+#include "Talent.h"
+#include "Weapon.h"
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Creature::CLASS_NAME = "Creature";
+
+    const Ogre::String Creature::PROPERTY_AI = "ai";
+    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = "behaviours";
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
+    const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
+    const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
+    const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = "current_fatigue";
+    const Ogre::String Creature::PROPERTY_EFFECTS = "effects";
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = "eigenschaften";
+    const Ogre::String Creature::PROPERTY_TALENTE = "talente";
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = "kampftechniken";
+    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = "kampfaktionen";
+    const Ogre::String Creature::PROPERTY_VORTEILE = "vorteile";
+    const Ogre::String Creature::PROPERTY_NACHTEILE = "nachteile";
+    const Ogre::String Creature::PROPERTY_SF = "sonderfertigkeiten";
+    const Ogre::String Creature::PROPERTY_WERTE = "werte";
+    const Ogre::String Creature::PROPERTY_AP = "ap";
+    const Ogre::String Creature::PROPERTY_INVENTORY = "inventory";
+    const Ogre::String Creature::PROPERTY_ANIMATIONS = "animations";
+    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = "animationspeeds";
+
+    // some targets
+	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+	const std::string Creature::ALL_TALENTE = "alle Talente";
+	const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
+    const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
+    const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
+    const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
+    const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
+    const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
+    const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
+    const Creature::Wert Creature::WERT_GS = "GS";
+    const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
+    const Creature::Wert Creature::WERT_BE = "BE";
+    const Creature::Wert Creature::WERT_RS = "RS";
+    const Creature::Wert Creature::WERT_INI = "INI";
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
+    const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
+
+
+
+    Creature::Creature(unsigned int id)
+        : GameObject(id),
+		mCurrentLe(0),
+        mCurrentAu(0),
+        mCurrentAe(0),
+		mInventory(NULL),
+		mEigenschaften(),
+		mWerte(),
+		mTalente(),
+        mKampftechniken(),
+		mKampfaktionen(),
+        mSonderfertigkeiten(),
+        mErschoepfung(0),
+        mMovementType(0),
+        mAlignment(ALIGNMENT_NEUTRAL),
+        mTimeSinceLastRegeneration(0),
+        mLastCalculatedAuToRegenerate(
+                  DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6())
+    {
+        mQueryFlags |= QUERYFLAG_CREATURE;
+
+		setWert(WERT_MOD_AE, 0);
+		setWert(WERT_MOD_LE, 0);
+		setWert(WERT_MOD_AU, 0);
+		setWert(WERT_MOD_MR, 0);
+		setWert(WERT_GS, 8);
+        setWert(WERT_RS, 0);
+        setWert(WERT_BE, 0);
+        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
+		mEigenschaften[E_MUT] = 0;
+		mEigenschaften[E_KLUGHEIT] = 0;
+		mEigenschaften[E_INTUITION] = 0;
+		mEigenschaften[E_CHARISMA] = 0;
+		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
+		mEigenschaften[E_GEWANDTHEIT] = 0;
+		mEigenschaften[E_KONSTITUTION] = 0;
+		mEigenschaften[E_KOERPERKRAFT] = 0;
+
+		mInventory = new Inventory(this);
+    }
+
+	Creature::~Creature()
+    {
+        delete mInventory;
+
+        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
+            delete it->second;
+        mSonderfertigkeiten.clear();
+        CreatureControllerManager::getSingleton().detachController(this);
+    }
+
+    int Creature::getAttackeBasis() const
+    {
+		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getParadeBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getFernkampfBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getInitiativeBasis() const
+    {
+      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getMrBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getLeBasis() const
+    {
+      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+    int Creature::getAuBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+	int Creature::getAeBasis() const
+	{
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+	int Creature::getWert(Wert wertId, bool getUnmodified) const
+	{
+		WertMap::const_iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + ": Wert " + wertId.c_str() + " nicht gefunden.").c_str());
+            return 0;
+        }
+        int rval = it->second;
+        if (!getUnmodified)
+        {
+          rval += mEffectManager->getMod(wertId, Effect::MODTYPE_SUM);
+          rval *= mEffectManager->getMod(wertId, Effect::MODTYPE_MULT);
+        }
+		return rval;
+	}
+
+	int Creature::getCurrentBe() const
+	{
+		pair<int,int> be = mInventory->getOverallBe();
+        ///@todo Ruestungsgewoehnung?
+		return be.first+be.second;
+	}
+
+	void Creature::setWert(Wert wertId, int value)
+	{
+		WertMap::iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+			mWerte.insert(make_pair(wertId, value));
+        }
+		else
+		{
+			it->second = value;
+		}
+	}
+
+   void Creature::modifyLe(int mod, bool ignoreMax)
+    {
+        int oldLe = mCurrentLe;
+        mCurrentLe += mod;
+		if (!ignoreMax)
+		{
+			mCurrentLe = min(mCurrentLe, getLeMax());
+		}
+
+        if (mCurrentLe <= -getEigenschaft("KO") && oldLe > -getEigenschaft("KO"))
+        {
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("DeadEffect"));
+        }
+        else if (mCurrentLe > -getEigenschaft("KO") && oldLe <= -getEigenschaft("KO"))
+        {
+            mEffectManager->removeEffect("DeadEffect");
+        }
+        else if (mCurrentLe <= 0 && oldLe > 0)
+        {
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("UnconsciousEffect"));
+        }
+        else if (mCurrentLe > 0 && oldLe <= 0)
+        {
+            mEffectManager->removeEffect("UnconciousEffect");
+        }
+		else if (mCurrentLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
+            oldLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("IncapacitatedEffect"));
+		}
+		else if (mCurrentLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
+            oldLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager->removeEffect("IncapacitatedEffect");
+		}
+
+        fireObjectStateChangeEvent();
+
+    }
+
+    int Creature::getLe() const
+    {
+        return mCurrentLe;
+    }
+
+    int Creature::getLeMax() const
+    {
+		return getLeBasis() + getWert(WERT_MOD_LE);
+    }
+
+    void Creature::modifyAe(int mod, bool ignoreMax)
+    {
+        mCurrentAe += mod;
+		if (!ignoreMax)
+			mCurrentAe = min(mCurrentAe, getAeMax());
+		fireObjectStateChangeEvent();
+    }
+
+    int Creature::getAe() const
+    {
+        return mCurrentAe;
+    }
+
+    int Creature::getAeMax() const
+    {
+		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
+    }
+
+    void Creature::modifyAu(float mod, bool ignoreMax)
+    {
+        mCurrentAu = max(mCurrentAu + mod, 0.0f);
+		if (!ignoreMax)
+			mCurrentAu = min(mCurrentAu, float(getAuMax()));
+        if (getAu() <= 0)
+        {
+            ///@todo set incapacitated
+        }
+		fireObjectStateChangeEvent();
+    }
+
+    float Creature::getAu() const
+    {
+        return mCurrentAu;
+    }
+
+    int Creature::getAuMax() const
+    {
+		return getAuBasis() + getWert(WERT_MOD_AU);
+    }
+
+    void Creature::modifyAp(int modifier)
+    {
+        mAp.total += modifier;
+    }
+
+    int Creature::getAp() const
+    {
+        return mAp.total;
+    }
+
+    void Creature::modifyUsedAp(int modifier)
+    {
+        mAp.used += modifier;
+    }
+
+    int Creature::getUsedAp() const
+    {
+        return mAp.used;
+    }
+
+    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
+    {
+		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
+		if (it == mEigenschaften.end())
+		{
+			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
+		}
+		int result = it->second;
+        result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
+        return result;
+    }
+
+    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
+    {
+        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
+        if (it == mEigenschaften.end())
+        {
+            Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
+        }
+		it->second = value;
+        fireObjectStateChangeEvent();
+    }
+
+    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
+    {
+		mEigenschaften[eigenschaftName] += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
+    {
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+            return true;
+        /*
+        if( ausweich )
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt != ausweichTalente.end())
+            {
+                return true;
+            }
+        }
+        */
+		
+        return false;
+    }
+
+    int Creature::getTalent(const CeGuiString talentName) const
+    {
+        LOG_DEBUG(Logger::RULES, "Using talent " + talentName);
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt == ausweichTalente.end())
+            {
+                Throw(IllegalArgumentException, "Talent nicht gefunden.");
+            }
+            int rval = getTalent(ausweichIt->first) - ausweichIt->second;
+            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
+            {
+                int tempAusweichTaw = getTalent(ausweichIt->first)
+                    - ausweichIt->second;
+                if (tempAusweichTaw > rval) rval = tempAusweichTaw;
+            }
+            return rval;
+        } //if (it == mTalente.end())
+		return it->second;
+    }
+
+	void Creature::addTalent(const CeGuiString talentName, int value)
+	{
+		TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+        {
+			Throw(IllegalArgumentException, "Talent schon in mTalente enthalten.");
+        }
+	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
+		mTalente[talentName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::modifyTalent(const CeGuiString talentName, int mod)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		it->second += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+	const Creature::TalentMap& Creature::getAllTalents() const
+	{
+		return mTalente;
+	}
+
+    void Creature::setTalent(const CeGuiString talentName, int value)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		it->second = value;
+		fireObjectStateChangeEvent();
+    }
+
+	void Creature::addSe(const CeGuiString talentName)
+	{
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		//it->second->setSe( true );
+        /// @todo Implement SEs
+	}
+
+	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it != mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException,
+				"Kampftechnik schon in mKampftechniken enthalten.");
+		}
+		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
+		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
+		mKampftechniken[kampftechnikName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    pair<int, int> Creature::getKampftechnik(const CeGuiString kampftechnikName) const
+    {
+        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
+        }
+        return (*it).second;
+    }
+
+    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair<int, int>& value)
+    {
+        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
+        }
+        (*it).second = value;
+		fireObjectStateChangeEvent();
+    }
+
+    void Creature::addKampfaktion(const CeGuiString& kampfaktionName)
+	{
+		mKampfaktionen.insert(kampfaktionName);
+	}
+
+    bool Creature::hasKampfaktion(const CeGuiString& kampfaktionName) const
+	{
+		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
+	}
+
+	const std::set<CeGuiString>& Creature::getAllKampfaktionen() const
+	{
+		return mKampfaktionen;
+	}
+
+    void Creature::addVorteil(const CeGuiString vorteilName, int value)
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            Throw(IllegalArgumentException, "Vorteil schon in mVorteile enthalten");
+        }
+        mVorteile[vorteilName] = value;
+    }
+
+    bool Creature::hasVorteil(const CeGuiString vorteilName) const
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    void Creature::addNachteil(const CeGuiString nachteilName, int value)
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            Throw(IllegalArgumentException, "Nachteil schon in mNachteile enthalten");
+        }
+        mNachteile[nachteilName] = value;
+    }
+
+    bool Creature::hasNachteil(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it == mNachteile.end())
+        {
+            Throw(IllegalArgumentException, "Nachteil nicht gefunden.");
+        }
+		else return it->second + mEffectManager->getMod(nachteilName, Effect::MODTYPE_SUM);
+    }
+
+    int Creature::getSf(const CeGuiString sfName) const
+    {
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		return it->second->getValue();
+    }
+
+	void Creature::addSf(const CeGuiString sfName, SfStatus value)
+	{
+		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+		if (it != mSonderfertigkeiten.end())
+		{
+			Throw(IllegalArgumentException, "Sonderfertigkeit schon in mSonderfertigkeiten enthalten.");
+		}
+		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
+        /// @todo
+		//DsaManager::getSingleton().getSf(sfName);
+		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
+		mSonderfertigkeiten[sfName]->setOriginalValue( value );
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::setSf(const CeGuiString sfName, SfStatus value)
+    {
+        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		it->second->setOriginalValue( value );
+		fireObjectStateChangeEvent();
+    }
+
+	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
+	{
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		return it->second;
+	}
+
+    Effect::LifeState Creature::getLifeState() const
+    {
+      return mEffectManager->getLifeState();
+    }
+
+	bool Creature::isMagic() const
+	{
+		return getWert(WERT_MOD_AE) > 0;
+	}
+
+    void Creature::setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage)
+    {
+        if (value == true)
+        {
+            statusVariable++;
+        }
+        else //value == false
+        {
+            if (statusVariable > 0)
+            {
+                statusVariable--;
+            }
+            else
+            {
+                LOG_MESSAGE(Logger::RULES, errorMessage);
+            }
+        } //value == false
+    }
+
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) ||
+			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
+		{
+          /// @todo Find proper return value. Prompt an error message?
+			//Throw(OutOfRangeException, "TaW zu niedrig");
+          return -1;
+		}
+        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
+
+        // Der Probenwurf
+        Tripel<int> probe(DsaManager::getSingleton().roll3D20());
+
+		// Glueckliche
+		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) )
+		{
+			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
+			modifyTalent(talentName, +1);
+			return RESULT_SPEKT_AUTOERFOLG;
+		}
+		if ( ((probe.first == 1) && (probe.second == 1)) ||
+			 ((probe.first == 1) && (probe.third == 1)) ||
+			 ((probe.second == 1) && (probe.third == 1)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOERFOLG;
+		}
+		// Patzer
+		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20))
+		{
+			addSe(talentName);
+			return RESULT_SPEKT_AUTOMISSERFOLG;
+		}
+		if ( ((probe.first == 20) && (probe.second == 20)) ||
+			 ((probe.first == 20) && (probe.third == 20)) ||
+			 ((probe.second == 20) && (probe.third == 20)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOMISSERFOLG;
+		}
+
+
+        // Vor dem Vergleich hat man den Talentwert ??brig.
+		int eBe = DsaManager::getSingleton().getTalent(talentName)->calculateEbe(mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM));
+		int taW = getTalent(talentName);
+		int rval = taW - modifier - mEffectManager->getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
+            - mEffectManager->getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
+		// Bei negativen TaP*
+		int handicap = 0;
+		if (rval < 0)
+		{
+			handicap = -rval;
+			rval = 0;
+		}
+
+        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
+        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
+        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
+
+        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
+        // wird die Differenz vom Talentwert abgezogen.
+        rval = diff1 < 0 ? rval + diff1 : rval;
+        rval = diff2 < 0 ? rval + diff2 : rval;
+        rval = diff3 < 0 ? rval + diff3 : rval;
+
+		// TaP* niemals gr????er als TaW (MFF14)
+		if (rval > taW) rval = taW;
+        return rval;
+    }
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
+			eigenschaft2Name, eigenschaft3Name);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent->getEigenschaften());
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
+			et.first, et. second, et.third);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent->getEigenschaften());
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
+			et. second, et.third);
+	}
+
+    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
+    {
+        int rval;
+
+        int probe = DsaManager::getSingleton().rollD20();
+        if (probe == 1)
+        {
+            rval = RESULT_GLUECKLICH;
+        }
+        else if (probe == 20)
+        {
+            rval = RESULT_PATZER;
+        }
+        else
+        {
+			rval = getEigenschaft(eigenschaftName) -
+                (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
+        }
+        return rval;
+    }
+
+
+	Inventory* Creature::getInventory() const
+	{
+		return mInventory;
+	}
+
+    const Ogre::String& Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
+
+	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
+		}
+		int rval;
+		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best??tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20) /// @todo Best??tigen
+		{
+			rval = RESULT_PATZER;
+		}
+		else
+		{
+			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
+                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval < 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
+		}
+		int rval;
+		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best??tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20)
+		{
+			rval = RESULT_PATZER; /// @todo Best??tigen
+		}
+		else
+		{
+			/// @todo Gute Parade
+			rval = getParadeBasis() + (*it).second.second - (probe + modifier
+                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval < 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doInitiativeWurf(bool getMaxInitiave)
+	{
+		int rval = getInitiativeBasis();
+		rval += mEffectManager->getMod(WERT_INI, Effect::MODTYPE_SUM);
+		rval -= mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM);
+		if (getMaxInitiave)
+        {
+            rval += 6;
+        }
+        else
+        {
+            rval += DsaManager::getSingleton().rollD6();
+        }
+		return rval;
+	}
+
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
+	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
+		// Roll dice
+		const Tripel<int>& weaponTp = weapon->getTp();
+		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
+		rval += weaponTp.third;
+
+		// Apply TP/KK
+
+		int kk = getEigenschaft(E_KOERPERKRAFT);
+		std::pair<int, int> tpkk = weapon->getTpKk();
+		
+		int bonus = (kk - tpkk.first) / tpkk.second;
+		rval += bonus;
+
+		return rval;
+	}
+
+	/// @todo Implement correctly
+	void Creature::damageLe(int tp, int damageType)
+	{
+        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+        if (tp < 0)
+        {
+            tp = 0;
+        }
+
+        ///@todo auf Verletzlichkeiten und Immunitaeten achten
+        if (damageType & LEDAMAGE_FIRE)
+        {
+            LOG_ERROR("Creature", "Fire damage not handled!"); ///@todo implement
+        }
+        if (damageType & LEDAMAGE_WATER)
+        {
+            LOG_ERROR("Creature", "Water damage not handled!"); ///@todo implement
+        }
+        if (damageType & LEDAMAGE_DEMONIC)
+        {
+            LOG_ERROR("Creature", "Demonic damage not handled!"); ///@todo implement
+        }
+
+        if (damageType & LEDAMAGE_TP_A)
+        {
+            damageAu(tp, AUDAMAGE_NORMAL);
+            tp = (int)floor(tp/2.);
+        }
+
+        int sp = -tp;
+        if (!(damageType & LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
+		modifyLe(sp);
+
+        if (sp >= getEigenschaft("KO"))
+        {
+            LOG_ERROR("Creature", "TODO: Add a wound."); ///@todo implement
+        }
+	}
+
+    void Creature::damageAe(int asp)
+    {
+        if (asp < 0)
+        {
+         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           asp = 0;
+        }
+        modifyAe(-asp);
+    }
+
+    void Creature::damageAu(float aup, int damageType)
+    {
+        if (aup < 0)
+        {
+         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           aup = 0;
+           ///@todo evtl. eine modifyErschoepfung()?
+           mErschoepfung += DsaManager::getSingleton().rollD6();
+           ///@todo set incapacitated
+        }
+        // bei ??beranstrengung, kostet alles doppelte Au!!!!!
+        if( mErschoepfung > getEigenschaft("KO") )
+            aup *= 2;
+        modifyAu(-aup);
+    }
+
+    void Creature::regenerateLe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedLe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedLe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
+            0, Effect::MODTAG_REGENERATION_LE))
+        {
+            regeneratedLe++;
+        }
+        //modifiziere die aktuellen LE
+        modifyLe(regeneratedLe);
+    }
+
+    void Creature::regenerateAe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedAe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedAe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN",
+            0, Effect::MODTAG_REGENERATION_AE))
+        {
+            regeneratedAe++;
+        }
+        //modifiziere die aktuellen AE
+        modifyAe(regeneratedAe);
+    }
+
+    void Creature::regenerateAu(int modifier, float factor, float time)
+    {
+        // das Ganze nur jede Spielrunde machen
+        mTimeSinceLastRegeneration += time;
+
+
+        if( getAu() == getAuMax() )
+        {
+            mTimeSinceLastRegeneration = 0;
+            return;
+        }
+
+
+        while( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE )
+        {
+            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
+
+
+            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
+            //Grundregeneration von 3W6
+            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6();
+            //Addiere eventuelle Modifikatoren hinzu
+            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
+            //Bei gelungener KO Probe addiere 1
+            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
+                0, mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
+            {
+                modifyAu(6*factor);
+            }
+
+            if( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            {
+                //modifiziere die aktuellen AU
+                time -= Date::ONE_SPIELRUNDE;
+                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
+            }
+
+            if( getAu() == getAuMax() )
+            {
+                mTimeSinceLastRegeneration = 0;
+                return;
+            }
+        }
+
+        // Restbetrag regenerieren:
+        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        modifyAu(regeneratedAuPerTime*factor);
+    }
+
+    void Creature::setAlignment(Creature::Alignment alignment)
+    {
+        mAlignment = alignment;
+    }
+
+    Creature::Alignment Creature::getAlignment() const
+    {
+        return mAlignment;
+    }
+
+    void Creature::setProperty(const CeGuiString& key, const Property& value)
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            mAiProperties = value;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            mCurrentLe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toReal();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            mKampfaktionen.clear();
+            convertToSet(value.toArray(), mKampfaktionen);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory->setProperties(value.toMap());
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            mAnimations.clear();
+            convertToMap(value.toMap(), mAnimations);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            mAnimationSpeeds.clear();
+            convertToMap(value.toMap(), mAnimationSpeeds);
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Creature::getProperty(const CeGuiString& key) const
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            return mAiProperties;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            return Property(mCurrentLe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            return Property(mCurrentAe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            return Property(mCurrentAu);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            return Property(mErschoepfung);
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
+            return Property(vec);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+            return Property(map);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            return Property(make_pair(mAp.total, mAp.used));
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+			return mInventory->getAllProperties()->toPropertyMap();
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimations);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
+            return Property(map);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Creature::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Creature::PROPERTY_AI);
+        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
+        keys.insert(Creature::PROPERTY_CURRENT_LE);
+        keys.insert(Creature::PROPERTY_CURRENT_AE);
+        keys.insert(Creature::PROPERTY_CURRENT_AU);
+        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
+        keys.insert(Creature::PROPERTY_TALENTE);
+        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
+        keys.insert(Creature::PROPERTY_VORTEILE);
+        keys.insert(Creature::PROPERTY_NACHTEILE);
+        //keys.insert(Creature::PROPERTY_SF);
+        keys.insert(Creature::PROPERTY_WERTE);
+        keys.insert(Creature::PROPERTY_AP);
+        keys.insert(Creature::PROPERTY_INVENTORY);
+        keys.insert(Creature::PROPERTY_ANIMATIONS);
+        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
+
+        return keys;
+    }
+
+    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString& name) const
+    {
+        AnimationSpeedPair ret;
+        AnimationsMap::const_iterator itName = mAnimations.find(name);
+        if( itName != mAnimations.end() )
+            ret.first = itName->second.c_str();
+        else
+            ret.first = name.c_str();
+
+        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
+        if( itSpeed != mAnimationSpeeds.end() )
+            ret.second = itSpeed->second;
+        else
+            ret.second = 1;
+
+        return ret;
+    }
+
+    bool Creature::canReachItem(const Item* item) const
+    {
+        return (item->getPosition() - getPosition()).length() <= 3.0f;
+    }
+
+    void Creature::doPlaceIntoScene()
+    {
+        GameObject::doPlaceIntoScene();
+
+        // check items in inventory
+        Inventory::SlotMap slots = mInventory->getAllSlots();
+        Inventory::SlotMap::iterator it = slots.begin();
+        for( ; it != slots.end(); it++ )
+        {
+            it->second->update();
+        }
+    }
+
+    void Creature::doRemoveFromScene()
+    {
+        GameObject::doRemoveFromScene();
+
+        ///@todo check if this is really necessary
+        // check items in inventory
+        //Inventory::SlotMap slots = mInventory->getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it->second->update();
+        //}
+    }
+}

Modified: rl/trunk/engine/rules/src/Weapon.cpp
===================================================================
--- rl/trunk/engine/rules/src/Weapon.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Weapon.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -36,7 +36,8 @@
     const Ogre::String Weapon::PROPERTY_TP_DK = "DK";
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = "kampftechnik";
     const Ogre::String Weapon::PROPERTY_NATURAL = "natural";
-
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = "avoidarmor";
+    
 	Weapon::Weapon(unsigned int id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +47,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(""),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +186,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString& key, const Property& value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +251,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +312,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +333,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }



From blakharaz at mail.berlios.de  Mon Dec  1 22:19:30 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 22:19:30 +0100
Subject: [Dsa-hl-svn] r4624 - modules/common/dsa
Message-ID: <200812012119.mB1LJU6v011171@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 22:19:29 +0100 (Mon, 01 Dec 2008)
New Revision: 4624

Modified:
   modules/common/dsa/animals.gof
Log:


Modified: modules/common/dsa/animals.gof
===================================================================
--- modules/common/dsa/animals.gof	2008-12-01 21:18:53 UTC (rev 4623)
+++ modules/common/dsa/animals.gof	2008-12-01 21:19:29 UTC (rev 4624)
@@ -101,5 +101,6 @@
 		<property name="INI" type="INT" data="2"/>
 		<property name="WM" type="INTPAIR" data="0,-5"/>
 		<property name="DK" type="STRING" data="HN"/>
+		<property name="natural" type="BOOL" data="true"/>
 	</gameobjectclass>
 </GameObjectDefinitions>



From blakharaz at mail.berlios.de  Mon Dec  1 22:20:44 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 1 Dec 2008 22:20:44 +0100
Subject: [Dsa-hl-svn] r4625 -
	dependencies/opensteer/macosx/OpenSteer.xcodeproj
Message-ID: <200812012120.mB1LKiuE011229@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-01 22:20:43 +0100 (Mon, 01 Dec 2008)
New Revision: 4625

Modified:
   dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
Log:


Modified: dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
===================================================================
--- dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj	2008-12-01 21:19:29 UTC (rev 4624)
+++ dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj	2008-12-01 21:20:43 UTC (rev 4625)
@@ -154,7 +154,7 @@
 		32FFF56B06E9CECE00E1D8A3 /* Soccer.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = Soccer.cpp; sourceTree = "<group>"; };
 		32FFF58006E9CF3800E1D8A3 /* OpenSteer.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; path = OpenSteer.icns; sourceTree = "<group>"; };
 		4425B3E60B7B61DB0067899D /* OpenSteer.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = OpenSteer.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		4425B3E70B7B61DB0067899D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = Info.plist; sourceTree = "<group>"; };
+		4425B3E70B7B61DB0067899D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 		4425B40A0B7B678E0067899D /* SharedPointer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SharedPointer.h; sourceTree = "<group>"; };
 		4425B41C0B7B67F90067899D /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
 		4425B47B0B7B76740067899D /* PolylineSegmentedPathTest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PolylineSegmentedPathTest.cpp; path = ../test/PolylineSegmentedPathTest.cpp; sourceTree = SOURCE_ROOT; };
@@ -165,7 +165,7 @@
 		841E3BFC0736BF4400E3AD2C /* Obstacle.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = Obstacle.cpp; sourceTree = "<group>"; };
 		84AD12AD070E221100559513 /* OpenSteerDemo.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = OpenSteerDemo.h; sourceTree = "<group>"; };
 		84AD12B1070E224000559513 /* OpenSteerDemo.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = OpenSteerDemo.cpp; sourceTree = "<group>"; };
-		8D1107310486CEB800E47090 /* OpenSteerDemo-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xml; path = "OpenSteerDemo-Info.plist"; sourceTree = "<group>"; };
+		8D1107310486CEB800E47090 /* OpenSteerDemo-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = "OpenSteerDemo-Info.plist"; sourceTree = "<group>"; };
 		8D1107320486CEB800E47090 /* OpenSteerDemo.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = OpenSteerDemo.app; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
 



From melven at mail.berlios.de  Tue Dec  2 00:18:35 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 2 Dec 2008 00:18:35 +0100
Subject: [Dsa-hl-svn] r4626 - in modules: common/scripts intro/scripts
Message-ID: <200812012318.mB1NIZDA023674@sheep.berlios.de>

Author: melven
Date: 2008-12-02 00:18:34 +0100 (Tue, 02 Dec 2008)
New Revision: 4626

Modified:
   modules/common/scripts/moduleconfig.rb
   modules/intro/scripts/moduleconfig.rb
Log:
strange and dirty fix...
  CoreSubsystem.getSingleton() in globals.rb works fine, when
  CoreSubsystem.getSingleton() is already called once before
  in the common-moduleconfig.rb
  TODO: fix the real error (I only committed this, because it could
        probably help to find the bug)


Modified: modules/common/scripts/moduleconfig.rb
===================================================================
--- modules/common/scripts/moduleconfig.rb	2008-12-01 21:20:43 UTC (rev 4625)
+++ modules/common/scripts/moduleconfig.rb	2008-12-01 23:18:34 UTC (rev 4626)
@@ -23,10 +23,11 @@
 
     def start()
 	UiSubsystem.getSingleton().initializeSubsystem()
+    CoreSubsystem.getSingleton() # with these strange things here, globals.rb works
 
-	load "globals.rb"
-	load "startup-global.rb"	
+	require "globals.rb"
+	require "startup-global.rb"	
     end
 end
 
-CoreSubsystem.getSingleton().registerModule(CommonModule.new())
\ No newline at end of file
+CoreSubsystem.getSingleton().registerModule(CommonModule.new())

Modified: modules/intro/scripts/moduleconfig.rb
===================================================================
--- modules/intro/scripts/moduleconfig.rb	2008-12-01 21:20:43 UTC (rev 4625)
+++ modules/intro/scripts/moduleconfig.rb	2008-12-01 23:18:34 UTC (rev 4626)
@@ -1,3 +1,5 @@
+include RlScript
+
 class IntroModule < ContentModule
     def initialize()
         super("intro", "Intro", false, 200603030)
@@ -33,4 +35,4 @@
     end
 end
 
-CoreSubsystem.getSingleton().registerModule(IntroModule.new())
\ No newline at end of file
+CoreSubsystem.getSingleton().registerModule(IntroModule.new())



From blakharaz at mail.berlios.de  Wed Dec  3 07:52:02 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 3 Dec 2008 07:52:02 +0100
Subject: [Dsa-hl-svn] r4627 - in rl/trunk/engine/core: include src
Message-ID: <200812030652.mB36q26E004616@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-03 07:51:56 +0100 (Wed, 03 Dec 2008)
New Revision: 4627

Modified:
   rl/trunk/engine/core/include/ConfigurationManager.h
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
Log:
Remove broken modules instead of throwing an exception

Modified: rl/trunk/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/trunk/engine/core/include/ConfigurationManager.h	2008-12-01 23:18:34 UTC (rev 4626)
+++ rl/trunk/engine/core/include/ConfigurationManager.h	2008-12-03 06:51:56 UTC (rev 4627)
@@ -190,6 +190,13 @@
             Ogre::StringVector getModuleList() const;
 
             /**
+             * Remove modules from the module list (e.g. because they are broken)
+             *
+             * @param modules the modules to remove
+             */
+            void removeModules(const Ogre::StringVector& modules);
+
+            /**
              * Returns the filename of the current keymap file used by
              * Rastullah
              *

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-12-01 23:18:34 UTC (rev 4626)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-12-03 06:51:56 UTC (rev 4627)
@@ -184,6 +184,21 @@
         return mModuleList;
     }
 
+    void ConfigurationManager::removeModules(const Ogre::StringVector& modules)
+    {
+        for (Ogre::StringVector::const_iterator it = modules.begin(), end = modules.end(); it != end; ++it)
+        {
+            for (Ogre::StringVector::iterator itDel = mModuleList.begin(), endDel = mModuleList.end(); itDel != endDel; ++itDel)
+            {
+                if (*itDel == *it)
+                {
+                    mModuleList.erase(itDel);
+                    break;
+                }
+            }
+        }
+    }
+
     void ConfigurationManager::loadConfig()
     {
         setRastullahCfgPath();

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-12-01 23:18:34 UTC (rev 4626)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-12-03 06:51:56 UTC (rev 4627)
@@ -329,6 +329,8 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
+        Ogre::StringVector brokenModules;
+
         for (size_t i = 0; i < modulesList.size(); i++)
         {
             mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
@@ -337,8 +339,9 @@
 
             if (module == NULL)
             {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "'");
+                LOG_WARNING("CoreSubsystem",
+                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "', removed.");
+                brokenModules.push_back(modulesList[i]);
             }
             //else
             //{
@@ -349,6 +352,8 @@
             //    }
             //}
         }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
     }
 
     ContentModule* CoreSubsystem::getModule(const Ogre::String& moduleId) const



From blakharaz at mail.berlios.de  Wed Dec  3 07:52:45 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 3 Dec 2008 07:52:45 +0100
Subject: [Dsa-hl-svn] r4628 - in rl/trunk/engine/ui: . include src
Message-ID: <200812030652.mB36qjcb004767@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-03 07:52:41 +0100 (Wed, 03 Dec 2008)
New Revision: 4628

Modified:
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Remove all windows before a scene change

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2008-12-03 06:51:56 UTC (rev 4627)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2008-12-03 06:52:41 UTC (rev 4628)
@@ -432,6 +432,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\CharacterSelectionWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\CharacterSheetWindow.h"
 					>
 				</File>
@@ -677,6 +681,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\CharacterSelectionWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\CharacterSheetWindow.cpp"
 					>
 				</File>

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2008-12-03 06:51:56 UTC (rev 4627)
+++ rl/trunk/engine/ui/include/WindowManager.h	2008-12-03 06:52:41 UTC (rev 4628)
@@ -19,6 +19,8 @@
 
 #include "UiPrerequisites.h"
 
+#include "MessagePump.h"
+
 namespace rl {
 
 	class AbstractWindow;
@@ -33,6 +35,7 @@
 		void registerWindow(AbstractWindow* window);
 		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
+        bool destroyAllWindows();
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
@@ -47,6 +50,7 @@
 
 	private:
 		std::list<AbstractWindow*> mWindowList;
+        MessagePump::ScopedConnection mSceneClearConnection;
 
         unsigned short mNumActiveWindowsMouseInput;
         unsigned short mNumActiveWindowsKeyboardInput;

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2008-12-03 06:51:56 UTC (rev 4627)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2008-12-03 06:52:41 UTC (rev 4628)
@@ -18,8 +18,9 @@
 #include "WindowManager.h"
 #include <CEGUIWindowManager.h>
 
+#include "AbstractWindow.h"
+#include "CoreMessages.h"
 #include "CoreSubsystem.h"
-#include "AbstractWindow.h"
 #include "Exception.h"
 #include "GameLoop.h"
 #include "UiSubsystem.h"
@@ -35,6 +36,8 @@
           mNumActiveWindowsMouseInput(0),
           mNumActiveWindowsKeyboardInput(0)
 	{
+        mSceneClearConnection = MessagePump::getSingleton().addMessageHandler<MessageType_SceneClearing>(
+            boost::bind(&WindowManager::destroyAllWindows, this));
 	}
 
 	WindowManager::~WindowManager()
@@ -123,10 +126,9 @@
     AbstractWindow* WindowManager::getActiveWindow()
     {
         // iterate through windows
-        std::list<AbstractWindow*>::iterator it;
-        for( it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
         {
-            if( (*it)->getWindow()->isActive() )
+            if ( (*it)->getWindow()->isActive() )
             {
                 return *it;
             }
@@ -134,4 +136,23 @@
 
         return NULL;
     }
+
+    bool WindowManager::destroyAllWindows()
+    {
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        {
+            AbstractWindow* cur = *it;
+//			if (cur->isVisible())
+//			{
+				cur->setVisible(false, true);
+//			}
+//          else 
+//          {
+//              delete cur;
+//          }
+        }
+
+        mWindowList.clear();
+        return true;
+    }
 }



From chrber at mail.berlios.de  Thu Dec  4 00:12:06 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Thu, 4 Dec 2008 00:12:06 +0100
Subject: [Dsa-hl-svn] r4629 - in rl/trunk: . cmake engine/ai engine/ai/src
	engine/common engine/common/include engine/common/src
	engine/core engine/core/src
Message-ID: <200812032312.mB3NC6oH010355@sheep.berlios.de>

Author: chrber
Date: 2008-12-04 00:12:01 +0100 (Thu, 04 Dec 2008)
New Revision: 4629

Added:
   rl/trunk/cmake/FindOgreNewt.cmake
   rl/trunk/engine/ai/CMakeLists.txt
   rl/trunk/engine/common/CMakeLists.txt
   rl/trunk/engine/core/CMakeLists.txt
Modified:
   rl/trunk/CMakeLists.txt
   rl/trunk/cmake/FindOGRE.cmake
   rl/trunk/engine/ai/src/DialogLoader.cpp
   rl/trunk/engine/common/include/WriteableDataStream.h
   rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
   rl/trunk/engine/core/src/ContentLoader.cpp
Log:
Added check routine for OgreNewt
Added building of ai, common and core (core does not build => check for meshmagick missing)
Added extracting of plugindir variable from Ogre's pkg-config file
Added moduledir directive to preprocesser defines
Added missing newlines at end of file
Converted one file to unix line endings


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/CMakeLists.txt	2008-12-03 23:12:01 UTC (rev 4629)
@@ -3,11 +3,16 @@
 CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
 
 # Cmake handles escaping of preprocessor directives
-CMAKE_POLICY(SET CMP0005 NEW)
+CMAKE_POLICY(SET CMP0005 OLD)
 
 # Include required cmake macros
 INCLUDE(FeatureSummary)
 
+# Version information
+SET(RL_MAJOR_VERSION 0)
+SET(RL_MINOR_VERSION 3)
+SET(RL_PATCH_VERSION 0)
+
 # Add directory with RL's own macro definitions
 # (checked before ${CMAKE_ROOT}/Modules)
 SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
@@ -21,7 +26,9 @@
 SET(RL_UI_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/ui/include INTERNAL)
 
 # Check for required components
+FIND_PACKAGE(PkgConfig)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
+FIND_PACKAGE(OgreNewt REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
 FIND_PACKAGE(SWIG REQUIRED)
@@ -39,8 +46,7 @@
 SET(ENABLE_OPENAL "Enable OpenAL sound support (unsupported)" OFF)
 
 # Handle options
-SET(DATADIR ${DATAROOTDIR}/${DATADIRNAME})
-ADD_DEFINITIONS(-DDATADIR=${DATADIR})
+ADD_DEFINITIONS(-DRL_MODULEDIR=\\"${DATAROOTDIR}/${DATADIRNAME}/modules\\")
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)

Modified: rl/trunk/cmake/FindOGRE.cmake
===================================================================
--- rl/trunk/cmake/FindOGRE.cmake	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/cmake/FindOGRE.cmake	2008-12-03 23:12:01 UTC (rev 4629)
@@ -47,6 +47,9 @@
 	CACHE STRING ""
 )
 
+# Allow to set Ogre plugin path manually
+SET(OGRE_PLUGINDIR "" CACHE STRING "Ogre plugin directory")
+
 #Search for the headers and libraries
 IF (WIN32) #Windows
 	MESSAGE(STATUS "Looking for OGRE")
@@ -57,6 +60,10 @@
 	IF(PKG_CONFIG_FOUND)
 		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
 		PKG_SEARCH_MODULE(OGRE OGRE)
+		IF(NOT PKGCONFIG_FAILED)
+			_PKGCONFIG_INVOKE(OGRE "OGRE" PLUGINDIR "" --variable=plugindir)
+			ADD_DEFINITIONS(-DOGRE_PLUGINDIR=\\"${OGRE_PLUGINDIR}\\")
+		ENDIF(NOT PKGCONFIG_FAILED)
 		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
 		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
 		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING "")

Added: rl/trunk/cmake/FindOgreNewt.cmake
===================================================================
--- rl/trunk/cmake/FindOgreNewt.cmake	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/cmake/FindOgreNewt.cmake	2008-12-03 23:12:01 UTC (rev 4629)
@@ -0,0 +1,22 @@
+# Find OgreNewt (Newton physic library bindings for OGRE)
+#
+# This module defines
+# OGRENEWT_FOUND
+# OGRENEWT_INCLUDE_DIR
+# OGRENEWT_LIBRARY
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(OGRENEWT_INCLUDE_DIRS AND OGRENEWT_LIBRARY)
+	SET(OGRENEWT_FOUND_QUIETLY TRUE)
+ENDIF(OGRENEWT_INCLUDE_DIRS AND OGRENEWT_LIBRARY)
+
+IF(WIN32)
+
+ELSE(WIN32)
+	IF(PKG_CONFIG_FOUND)
+		PKG_SEARCH_MODULE(OGRENEWT OgreNewt)
+	ENDIF(PKG_CONFIG_FOUND)
+ENDIF(WIN32)
\ No newline at end of file

Added: rl/trunk/engine/ai/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ai/CMakeLists.txt	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/ai/CMakeLists.txt	2008-12-03 23:12:01 UTC (rev 4629)
@@ -0,0 +1,53 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${RL_COMMON_INCLUDE_DIR}
+${RL_CORE_INCLUDE_DIR}
+${RL_RULES_INCLUDE_DIR}
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS}
+${OGRENEWT_INCLUDE_DIRS})
+
+SET(RlAi_LIB_SRCS
+src/Agent.cpp
+src/AgentCombatState.cpp
+src/AgentDialogState.cpp
+src/AgentManager.cpp
+src/AgentSteeringState.cpp
+src/AiSubsystem.cpp
+src/AiWorld.cpp
+src/AStarCosts.cpp
+src/AStar.cpp
+src/AStarHeuristic.cpp
+src/AStarNodePool.cpp
+src/AStarWayPointNode.cpp
+src/CreatureWalkPathJob.cpp
+src/Dialog.cpp
+src/DialogCondition.cpp
+src/DialogElement.cpp
+src/DialogImplication.cpp
+src/DialogLoader.cpp
+src/DialogManager.cpp
+src/DialogOption.cpp
+src/DialogParagraph.cpp
+src/DialogResponse.cpp
+src/DialogVariable.cpp
+src/FuzzyState.cpp
+src/FuzzyStateMachine.cpp
+src/Landmark.cpp
+src/LandmarkPath.cpp
+src/PhysicalObstacle.cpp
+src/SimpleVehicle.cpp
+src/SteeringVehicle.cpp
+src/WalkPathBehaviour.cpp
+src/WayPointNode.cpp
+src/WayPointGraph.cpp
+src/WayPointGraphManager.cpp)
+
+ADD_LIBRARY(RlAi SHARED ${RlAi_LIB_SRCS})
+
+TARGET_LINK_LIBRARIES(RlAi ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARIES})
+
+SET_TARGET_PROPERTIES(RlAi PROPERTIES
+	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
+	DEFINE_SYMBOL RLAI_EXPORTS)
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2008-12-03 23:12:01 UTC (rev 4629)
@@ -751,4 +751,5 @@
         }
     }
 
-}
\ No newline at end of file
+}
+

Added: rl/trunk/engine/common/CMakeLists.txt
===================================================================
--- rl/trunk/engine/common/CMakeLists.txt	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/common/CMakeLists.txt	2008-12-03 23:12:01 UTC (rev 4629)
@@ -0,0 +1,33 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS})
+
+SET(RlCommon_LIB_SRCS
+src/ConfigFile.cpp
+src/EventObject.cpp
+src/EventSource.cpp
+src/GameTask.cpp
+src/Logger.cpp
+src/MathUtil.cpp
+src/OgreXercesInput.cpp
+src/Properties.cpp
+src/Property.cpp
+src/ScriptWrapper.cpp
+src/WriteableDataStream.cpp
+src/WriteableDataStreamFormatTarget.cpp
+src/WriteableFileSystemArchiv.cpp
+src/XmlProcessor.cpp
+src/XmlPropertyReader.cpp
+src/XmlPropertyWriter.cpp
+src/XmlResource.cpp
+src/XmlResourceManager.cpp)
+
+ADD_LIBRARY(RlCommon SHARED ${RlCommon_LIB_SRCS})
+
+TARGET_LINK_LIBRARIES(RlCommon ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES})
+
+SET_TARGET_PROPERTIES(RlCommon PROPERTIES
+	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
+	DEFINE_SYMBOL RLCOMMON_EXPORTS)
\ No newline at end of file

Modified: rl/trunk/engine/common/include/WriteableDataStream.h
===================================================================
--- rl/trunk/engine/common/include/WriteableDataStream.h	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/common/include/WriteableDataStream.h	2008-12-03 23:12:01 UTC (rev 4629)
@@ -71,4 +71,5 @@
     };
 
     typedef Ogre::SharedPtr<WriteableFileStreamDataStream> WriteableFileStreamDataStreamPtr;
-}
\ No newline at end of file
+}
+

Modified: rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-03 23:12:01 UTC (rev 4629)
@@ -34,4 +34,5 @@
     {
         mStream->flush();
     }
-}
\ No newline at end of file
+}
+

Added: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/core/CMakeLists.txt	2008-12-03 23:12:01 UTC (rev 4629)
@@ -0,0 +1,94 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${RL_COMMON_INCLUDE_DIR}
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS}
+${OGRENEWT_INCLUDE_DIRS})
+
+SET(RlCore_LIB_SRCS
+src/Actor.cpp
+src/ActorControlledObject.cpp
+src/ActorManager.cpp
+src/AnimationManager.cpp
+src/BaseAnimation.cpp
+src/BoxPrimitive.cpp
+src/CameraObject.cpp
+src/ConfigurationManager.cpp
+src/ContentLoader.cpp
+src/ContentModule.cpp
+src/CoreSubsystem.cpp
+src/DebugVisualisable.cpp
+src/DebugVisualsManager.cpp
+src/DotSceneLoader.cpp
+src/DotSceneOctreeWorld.cpp
+src/FadeAnimation.cpp
+src/GameAreaEvent.cpp
+src/GameAreaEventSource.cpp
+src/GameAreaListener.cpp
+src/GameAreaTypes.cpp
+src/GameEventManager.cpp
+src/GameLoop.cpp
+src/Job.cpp
+src/JobQueue.cpp
+src/JobScheduler.cpp
+src/LightObject.cpp
+src/LightFadeJob.cpp
+src/LineSetPrimitive.cpp
+src/ListenerObject.cpp
+src/ListenerMovable.cpp
+src/LinearSoundFadeFunctor.cpp
+src/MergeableMeshObject.cpp
+src/MeshAnimation.cpp
+src/MeshObject.cpp
+src/MessagePump.cpp
+src/MovableText.cpp
+src/ParticleSystemObject.cpp
+src/PhysicsContactListener.cpp
+src/PhysicalThing.cpp
+src/PhysicsGenericContactCallback.cpp
+src/PhysicsManager.cpp
+src/PhysicsMaterialRaycast.cpp
+src/PlayAnimationJob.cpp
+src/PlaySoundJob.cpp
+src/PolynomicSoundFadeFunctor.cpp
+src/PrimitiveObject.cpp
+src/RubyInterpreter.cpp
+src/SaveAble.cpp
+src/SaveAbleCollection.cpp
+src/SaveAbleFactory.cpp
+src/SaveAbleManager.cpp
+src/SaveGameFile.cpp
+src/SaveGameFileReader.cpp
+src/SaveGameFileWriter.cpp
+src/SaveGameManager.cpp
+src/SceneQuery.cpp
+src/SoundManager.cpp
+src/SoundObject.cpp
+src/SoundDriver.cpp
+src/Sound.cpp
+src/SoundEvents.cpp
+src/SoundResource.cpp
+src/SoundFadeJob.cpp
+src/SoundFadeFunctor.cpp
+src/SoundStitching.cpp
+src/SoundStitchingObject.cpp
+src/StartAnimationJob.cpp
+src/TimeSource.cpp
+src/Trigger.cpp
+src/TrackAnimation.cpp
+src/World.cpp
+src/Zone.cpp
+src/ZoneManager.cpp
+src/nulldriver/NullDriver.cpp
+src/nulldriver/NullListener.cpp
+src/nulldriver/NullSound.cpp
+src/nulldriver/NullSoundStitching.cpp)
+
+ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
+
+#TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES})
+
+SET_TARGET_PROPERTIES(RlCore PROPERTIES
+	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
+	DEFINE_SYMBOL RLCORE_EXPORTS)
\ No newline at end of file

Modified: rl/trunk/engine/core/src/ContentLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentLoader.cpp	2008-12-03 06:52:41 UTC (rev 4628)
+++ rl/trunk/engine/core/src/ContentLoader.cpp	2008-12-03 23:12:01 UTC (rev 4629)
@@ -1,33 +1,33 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "ContentLoader.h"
-
-namespace rl
-{
-    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
-    {
-    }
-
-    ContentLoader::~ContentLoader()
-    {
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "ContentLoader.h"
+
+namespace rl
+{
+    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
+    {
+    }
+
+    ContentLoader::~ContentLoader()
+    {
+    }
+
     const Property ContentLoader::getProperty(const CeGuiString& key) const
     {
         LOG_WARNING(Logger::CORE, key + " is not a property of this ContentLoader");
@@ -38,9 +38,10 @@
     {
     }
 
-    PropertyKeys ContentLoader::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-}
\ No newline at end of file
+    PropertyKeys ContentLoader::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        return keys;
+    }
+}
+



From blakharaz at mail.berlios.de  Thu Dec  4 20:17:15 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 4 Dec 2008 20:17:15 +0100
Subject: [Dsa-hl-svn] r4630 - in rl/trunk: Mac/Rastullah.xcodeproj
	engine/ai/include engine/ai/src
Message-ID: <200812041917.mB4JHF9T012325@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-04 20:17:08 +0100 (Thu, 04 Dec 2008)
New Revision: 4630

Added:
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/ai/include/DialogLoader.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/DialogLoader.cpp
   rl/trunk/engine/ai/src/Makefile.am
Log:
Moved implementation of DialogLoader to separate class to hide the Xerces imports

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-04 19:17:08 UTC (rev 4630)
@@ -478,7 +478,6 @@
 		48389C290D867B1A00AFAB66 /* Trigger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05860D71EDF20024198D /* Trigger.cpp */; };
 		48389C2C0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */; };
 		48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */; };
-		483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31100D85B1AF003477A0 /* NullSoundStitching.h */; };
 		483D31130D85B1C2003477A0 /* NullSoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */; };
 		483D31200D85B215003477A0 /* Combatant.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31150D85B215003477A0 /* Combatant.h */; };
 		483D31210D85B215003477A0 /* EffectManagementTask.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31160D85B215003477A0 /* EffectManagementTask.h */; };
@@ -562,6 +561,7 @@
 		484FE6C10E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		48500B790D906A1000EAD8DB /* RlScriptExportsMac.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */; };
+		4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */; };
 		48570C210D8A6C9000096E35 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
 		48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
 		48570C230D8A6C9000096E35 /* AbstractMapNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */; };
@@ -619,6 +619,8 @@
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
 		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
+		4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */ = {isa = PBXBuildFile; fileRef = 4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */; };
+		4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -884,14 +886,14 @@
 		1870340FFE93FCAF11CA0CD7 /* English */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = English; path = English.lproj/main.nib; sourceTree = "<group>"; };
 		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
 		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = stdinc.cpp; sourceTree = "<group>"; };
 		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
 		440785DD0C09D231006E496D /* libmeshmagick.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libmeshmagick.dylib; path = /usr/local/lib/libmeshmagick.dylib; sourceTree = "<absolute>"; };
-		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
-		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
+		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightFadeJob.cpp; sourceTree = "<group>"; };
+		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MergeableMeshObject.cpp; sourceTree = "<group>"; };
+		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MergeableMeshObject.h; sourceTree = "<group>"; };
 		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
@@ -952,117 +954,116 @@
 		444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Tripel.h; path = ../engine/common/include/Tripel.h; sourceTree = SOURCE_ROOT; };
 		444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResource.h; path = ../engine/common/include/XmlResource.h; sourceTree = SOURCE_ROOT; };
 		444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResourceManager.h; path = ../engine/common/include/XmlResourceManager.h; sourceTree = SOURCE_ROOT; };
-		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Actor.cpp; path = ../engine/core/src/Actor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorControlledObject.cpp; path = ../engine/core/src/ActorControlledObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorManager.cpp; path = ../engine/core/src/ActorManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AnimationManager.cpp; path = ../engine/core/src/AnimationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BaseAnimation.cpp; path = ../engine/core/src/BaseAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BoxPrimitive.cpp; path = ../engine/core/src/BoxPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CameraObject.cpp; path = ../engine/core/src/CameraObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigurationManager.cpp; path = ../engine/core/src/ConfigurationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentModule.cpp; path = ../engine/core/src/ContentModule.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CoreSubsystem.cpp; path = ../engine/core/src/CoreSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualisable.cpp; path = ../engine/core/src/DebugVisualisable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualsManager.cpp; path = ../engine/core/src/DebugVisualsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneLoader.cpp; path = ../engine/core/src/DotSceneLoader.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneOctreeWorld.cpp; path = ../engine/core/src/DotSceneOctreeWorld.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FadeAnimation.cpp; path = ../engine/core/src/FadeAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEvent.cpp; path = ../engine/core/src/GameAreaEvent.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEventSource.cpp; path = ../engine/core/src/GameAreaEventSource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaListener.cpp; path = ../engine/core/src/GameAreaListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaTypes.cpp; path = ../engine/core/src/GameAreaTypes.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameEventManager.cpp; path = ../engine/core/src/GameEventManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoop.cpp; path = ../engine/core/src/GameLoop.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Job.cpp; path = ../engine/core/src/Job.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobScheduler.cpp; path = ../engine/core/src/JobScheduler.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightObject.cpp; path = ../engine/core/src/LightObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LineSetPrimitive.cpp; path = ../engine/core/src/LineSetPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerMovable.cpp; path = ../engine/core/src/ListenerMovable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerObject.cpp; path = ../engine/core/src/ListenerObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshAnimation.cpp; path = ../engine/core/src/MeshAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshObject.cpp; path = ../engine/core/src/MeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovableText.cpp; path = ../engine/core/src/MovableText.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB420BD0E2B600C6D4A0 /* nulldriver */ = {isa = PBXFileReference; lastKnownFileType = folder; name = nulldriver; path = ../engine/core/src/nulldriver; sourceTree = SOURCE_ROOT; };
-		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = ../engine/core/src/nulldriver/NullDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = ../engine/core/src/nulldriver/NullListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = ../engine/core/src/nulldriver/NullSound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ParticleSystemObject.cpp; path = ../engine/core/src/ParticleSystemObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicalThing.cpp; path = ../engine/core/src/PhysicalThing.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsContactListener.cpp; path = ../engine/core/src/PhysicsContactListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsGenericContactCallback.cpp; path = ../engine/core/src/PhysicsGenericContactCallback.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsManager.cpp; path = ../engine/core/src/PhysicsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsMaterialRaycast.cpp; path = ../engine/core/src/PhysicsMaterialRaycast.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlayAnimationJob.cpp; path = ../engine/core/src/PlayAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaySoundJob.cpp; path = ../engine/core/src/PlaySoundJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PrimitiveObject.cpp; path = ../engine/core/src/PrimitiveObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RubyInterpreter.cpp; path = ../engine/core/src/RubyInterpreter.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneQuery.cpp; path = ../engine/core/src/SceneQuery.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Sound.cpp; path = ../engine/core/src/Sound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriver.cpp; path = ../engine/core/src/SoundDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundEvents.cpp; path = ../engine/core/src/SoundEvents.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundManager.cpp; path = ../engine/core/src/SoundManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundObject.cpp; path = ../engine/core/src/SoundObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundResource.cpp; path = ../engine/core/src/SoundResource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TrackAnimation.cpp; path = ../engine/core/src/TrackAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = World.cpp; path = ../engine/core/src/World.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Actor.cpp; sourceTree = "<group>"; };
+		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorControlledObject.cpp; sourceTree = "<group>"; };
+		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorManager.cpp; sourceTree = "<group>"; };
+		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AnimationManager.cpp; sourceTree = "<group>"; };
+		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BaseAnimation.cpp; sourceTree = "<group>"; };
+		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BoxPrimitive.cpp; sourceTree = "<group>"; };
+		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CameraObject.cpp; sourceTree = "<group>"; };
+		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ConfigurationManager.cpp; sourceTree = "<group>"; };
+		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentModule.cpp; sourceTree = "<group>"; };
+		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CoreSubsystem.cpp; sourceTree = "<group>"; };
+		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualisable.cpp; sourceTree = "<group>"; };
+		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualsManager.cpp; sourceTree = "<group>"; };
+		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneLoader.cpp; sourceTree = "<group>"; };
+		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneOctreeWorld.cpp; sourceTree = "<group>"; };
+		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FadeAnimation.cpp; sourceTree = "<group>"; };
+		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEvent.cpp; sourceTree = "<group>"; };
+		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEventSource.cpp; sourceTree = "<group>"; };
+		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaListener.cpp; sourceTree = "<group>"; };
+		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaTypes.cpp; sourceTree = "<group>"; };
+		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameEventManager.cpp; sourceTree = "<group>"; };
+		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameLoop.cpp; sourceTree = "<group>"; };
+		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Job.cpp; sourceTree = "<group>"; };
+		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobScheduler.cpp; sourceTree = "<group>"; };
+		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightObject.cpp; sourceTree = "<group>"; };
+		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LineSetPrimitive.cpp; sourceTree = "<group>"; };
+		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerMovable.cpp; sourceTree = "<group>"; };
+		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerObject.cpp; sourceTree = "<group>"; };
+		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshAnimation.cpp; sourceTree = "<group>"; };
+		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshObject.cpp; sourceTree = "<group>"; };
+		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MovableText.cpp; sourceTree = "<group>"; };
+		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = nulldriver/NullDriver.cpp; sourceTree = "<group>"; };
+		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = nulldriver/NullListener.cpp; sourceTree = "<group>"; };
+		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = nulldriver/NullSound.cpp; sourceTree = "<group>"; };
+		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ParticleSystemObject.cpp; sourceTree = "<group>"; };
+		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicalThing.cpp; sourceTree = "<group>"; };
+		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsContactListener.cpp; sourceTree = "<group>"; };
+		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsGenericContactCallback.cpp; sourceTree = "<group>"; };
+		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsManager.cpp; sourceTree = "<group>"; };
+		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsMaterialRaycast.cpp; sourceTree = "<group>"; };
+		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlayAnimationJob.cpp; sourceTree = "<group>"; };
+		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlaySoundJob.cpp; sourceTree = "<group>"; };
+		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PrimitiveObject.cpp; sourceTree = "<group>"; };
+		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RubyInterpreter.cpp; sourceTree = "<group>"; };
+		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SceneQuery.cpp; sourceTree = "<group>"; };
+		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Sound.cpp; sourceTree = "<group>"; };
+		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundDriver.cpp; sourceTree = "<group>"; };
+		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundEvents.cpp; sourceTree = "<group>"; };
+		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundManager.cpp; sourceTree = "<group>"; };
+		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundObject.cpp; sourceTree = "<group>"; };
+		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundResource.cpp; sourceTree = "<group>"; };
+		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TrackAnimation.cpp; sourceTree = "<group>"; };
+		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = World.cpp; sourceTree = "<group>"; };
 		444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlCore.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Actor.h; path = ../engine/core/include/Actor.h; sourceTree = SOURCE_ROOT; };
-		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorControlledObject.h; path = ../engine/core/include/ActorControlledObject.h; sourceTree = SOURCE_ROOT; };
-		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorManager.h; path = ../engine/core/include/ActorManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AnimationManager.h; path = ../engine/core/include/AnimationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BaseAnimation.h; path = ../engine/core/include/BaseAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BoxPrimitive.h; path = ../engine/core/include/BoxPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CameraObject.h; path = ../engine/core/include/CameraObject.h; sourceTree = SOURCE_ROOT; };
-		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigurationManager.h; path = ../engine/core/include/ConfigurationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentModule.h; path = ../engine/core/include/ContentModule.h; sourceTree = SOURCE_ROOT; };
-		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CorePrerequisites.h; path = ../engine/core/include/CorePrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreSubsystem.h; path = ../engine/core/include/CoreSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualisable.h; path = ../engine/core/include/DebugVisualisable.h; sourceTree = SOURCE_ROOT; };
-		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualsManager.h; path = ../engine/core/include/DebugVisualsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneLoader.h; path = ../engine/core/include/DotSceneLoader.h; sourceTree = SOURCE_ROOT; };
-		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneOctreeWorld.h; path = ../engine/core/include/DotSceneOctreeWorld.h; sourceTree = SOURCE_ROOT; };
-		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FadeAnimation.h; path = ../engine/core/include/FadeAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEvent.h; path = ../engine/core/include/GameAreaEvent.h; sourceTree = SOURCE_ROOT; };
-		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEventSource.h; path = ../engine/core/include/GameAreaEventSource.h; sourceTree = SOURCE_ROOT; };
-		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaListener.h; path = ../engine/core/include/GameAreaListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaTypes.h; path = ../engine/core/include/GameAreaTypes.h; sourceTree = SOURCE_ROOT; };
-		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameEventManager.h; path = ../engine/core/include/GameEventManager.h; sourceTree = SOURCE_ROOT; };
-		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoop.h; path = ../engine/core/include/GameLoop.h; sourceTree = SOURCE_ROOT; };
-		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Job.h; path = ../engine/core/include/Job.h; sourceTree = SOURCE_ROOT; };
-		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobListener.h; path = ../engine/core/include/JobListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobScheduler.h; path = ../engine/core/include/JobScheduler.h; sourceTree = SOURCE_ROOT; };
-		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightObject.h; path = ../engine/core/include/LightObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LineSetPrimitive.h; path = ../engine/core/include/LineSetPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerMovable.h; path = ../engine/core/include/ListenerMovable.h; sourceTree = SOURCE_ROOT; };
-		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerObject.h; path = ../engine/core/include/ListenerObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshAnimation.h; path = ../engine/core/include/MeshAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshObject.h; path = ../engine/core/include/MeshObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovableText.h; path = ../engine/core/include/MovableText.h; sourceTree = SOURCE_ROOT; };
-		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = ../engine/core/include/nulldriver/NullDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = ../engine/core/include/nulldriver/NullListener.h; sourceTree = SOURCE_ROOT; };
-		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = ../engine/core/include/nulldriver/NullSound.h; sourceTree = SOURCE_ROOT; };
-		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ParticleSystemObject.h; path = ../engine/core/include/ParticleSystemObject.h; sourceTree = SOURCE_ROOT; };
-		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalObject.h; path = ../engine/core/include/PhysicalObject.h; sourceTree = SOURCE_ROOT; };
-		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalThing.h; path = ../engine/core/include/PhysicalThing.h; sourceTree = SOURCE_ROOT; };
-		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsContactListener.h; path = ../engine/core/include/PhysicsContactListener.h; sourceTree = SOURCE_ROOT; };
-		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsController.h; path = ../engine/core/include/PhysicsController.h; sourceTree = SOURCE_ROOT; };
-		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsGenericContactCallback.h; path = ../engine/core/include/PhysicsGenericContactCallback.h; sourceTree = SOURCE_ROOT; };
-		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsManager.h; path = ../engine/core/include/PhysicsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsMaterialRaycast.h; path = ../engine/core/include/PhysicsMaterialRaycast.h; sourceTree = SOURCE_ROOT; };
-		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlayAnimationJob.h; path = ../engine/core/include/PlayAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaySoundJob.h; path = ../engine/core/include/PlaySoundJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PrimitiveObject.h; path = ../engine/core/include/PrimitiveObject.h; sourceTree = SOURCE_ROOT; };
-		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuadTree.h; path = ../engine/core/include/QuadTree.h; sourceTree = SOURCE_ROOT; };
-		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RubyInterpreter.h; path = ../engine/core/include/RubyInterpreter.h; sourceTree = SOURCE_ROOT; };
-		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneQuery.h; path = ../engine/core/include/SceneQuery.h; sourceTree = SOURCE_ROOT; };
-		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Sound.h; path = ../engine/core/include/Sound.h; sourceTree = SOURCE_ROOT; };
-		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriver.h; path = ../engine/core/include/SoundDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundEvents.h; path = ../engine/core/include/SoundEvents.h; sourceTree = SOURCE_ROOT; };
-		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundManager.h; path = ../engine/core/include/SoundManager.h; sourceTree = SOURCE_ROOT; };
-		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundObject.h; path = ../engine/core/include/SoundObject.h; sourceTree = SOURCE_ROOT; };
-		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundResource.h; path = ../engine/core/include/SoundResource.h; sourceTree = SOURCE_ROOT; };
-		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TrackAnimation.h; path = ../engine/core/include/TrackAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = World.h; path = ../engine/core/include/World.h; sourceTree = SOURCE_ROOT; };
+		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Actor.h; sourceTree = "<group>"; };
+		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorControlledObject.h; sourceTree = "<group>"; };
+		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorManager.h; sourceTree = "<group>"; };
+		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AnimationManager.h; sourceTree = "<group>"; };
+		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BaseAnimation.h; sourceTree = "<group>"; };
+		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BoxPrimitive.h; sourceTree = "<group>"; };
+		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CameraObject.h; sourceTree = "<group>"; };
+		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConfigurationManager.h; sourceTree = "<group>"; };
+		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentModule.h; sourceTree = "<group>"; };
+		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CorePrerequisites.h; sourceTree = "<group>"; };
+		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreSubsystem.h; sourceTree = "<group>"; };
+		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualisable.h; sourceTree = "<group>"; };
+		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualsManager.h; sourceTree = "<group>"; };
+		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneLoader.h; sourceTree = "<group>"; };
+		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneOctreeWorld.h; sourceTree = "<group>"; };
+		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FadeAnimation.h; sourceTree = "<group>"; };
+		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEvent.h; sourceTree = "<group>"; };
+		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEventSource.h; sourceTree = "<group>"; };
+		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaListener.h; sourceTree = "<group>"; };
+		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaTypes.h; sourceTree = "<group>"; };
+		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventManager.h; sourceTree = "<group>"; };
+		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameLoop.h; sourceTree = "<group>"; };
+		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Job.h; sourceTree = "<group>"; };
+		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobListener.h; sourceTree = "<group>"; };
+		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobScheduler.h; sourceTree = "<group>"; };
+		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightObject.h; sourceTree = "<group>"; };
+		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LineSetPrimitive.h; sourceTree = "<group>"; };
+		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerMovable.h; sourceTree = "<group>"; };
+		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerObject.h; sourceTree = "<group>"; };
+		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshAnimation.h; sourceTree = "<group>"; };
+		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshObject.h; sourceTree = "<group>"; };
+		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MovableText.h; sourceTree = "<group>"; };
+		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = nulldriver/NullDriver.h; sourceTree = "<group>"; };
+		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = nulldriver/NullListener.h; sourceTree = "<group>"; };
+		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = nulldriver/NullSound.h; sourceTree = "<group>"; };
+		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ParticleSystemObject.h; sourceTree = "<group>"; };
+		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalObject.h; sourceTree = "<group>"; };
+		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalThing.h; sourceTree = "<group>"; };
+		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsContactListener.h; sourceTree = "<group>"; };
+		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsController.h; sourceTree = "<group>"; };
+		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsGenericContactCallback.h; sourceTree = "<group>"; };
+		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsManager.h; sourceTree = "<group>"; };
+		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsMaterialRaycast.h; sourceTree = "<group>"; };
+		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlayAnimationJob.h; sourceTree = "<group>"; };
+		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlaySoundJob.h; sourceTree = "<group>"; };
+		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PrimitiveObject.h; sourceTree = "<group>"; };
+		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuadTree.h; sourceTree = "<group>"; };
+		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RubyInterpreter.h; sourceTree = "<group>"; };
+		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SceneQuery.h; sourceTree = "<group>"; };
+		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Sound.h; sourceTree = "<group>"; };
+		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundDriver.h; sourceTree = "<group>"; };
+		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundEvents.h; sourceTree = "<group>"; };
+		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundManager.h; sourceTree = "<group>"; };
+		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundObject.h; sourceTree = "<group>"; };
+		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundResource.h; sourceTree = "<group>"; };
+		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TrackAnimation.h; sourceTree = "<group>"; };
+		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = World.h; sourceTree = "<group>"; };
 		444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlAi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlRules.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlUi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -1259,12 +1260,12 @@
 		444EB0880BD1153500C6D4A0 /* OgreNewt.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreNewt.framework; path = /Library/Frameworks/OgreNewt.framework; sourceTree = "<absolute>"; };
 		444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenSteer.framework; path = /Library/Frameworks/OpenSteer.framework; sourceTree = "<absolute>"; };
 		444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreCEGUIRenderer.framework; path = /Library/Frameworks/OgreCEGUIRenderer.framework; sourceTree = "<absolute>"; };
-		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LinearSoundFadeFunctor.h; path = ../engine/core/include/LinearSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeFunctor.h; path = ../engine/core/include/SoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeJob.h; path = ../engine/core/include/SoundFadeJob.h; sourceTree = SOURCE_ROOT; };
-		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LinearSoundFadeFunctor.cpp; path = ../engine/core/src/LinearSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeFunctor.cpp; path = ../engine/core/src/SoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeJob.cpp; path = ../engine/core/src/SoundFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinearSoundFadeFunctor.h; sourceTree = "<group>"; };
+		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeFunctor.h; sourceTree = "<group>"; };
+		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeJob.h; sourceTree = "<group>"; };
+		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinearSoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeJob.cpp; sourceTree = "<group>"; };
 		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureController.h; sourceTree = "<group>"; };
 		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureControllerManager.h; sourceTree = "<group>"; };
 		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectFactory.h; sourceTree = "<group>"; };
@@ -1300,21 +1301,21 @@
 		44D814680BF7B5C700534175 /* LandmarkPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LandmarkPath.cpp; path = ../engine/ai/src/LandmarkPath.cpp; sourceTree = SOURCE_ROOT; };
 		44D8146B0BF7B5E800534175 /* Landmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Landmark.h; path = ../engine/ai/include/Landmark.h; sourceTree = SOURCE_ROOT; };
 		44D8146C0BF7B5E800534175 /* LandmarkPath.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LandmarkPath.h; path = ../engine/ai/include/LandmarkPath.h; sourceTree = SOURCE_ROOT; };
-		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Zone.cpp; path = ../engine/core/src/Zone.cpp; sourceTree = SOURCE_ROOT; };
-		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZoneManager.cpp; path = ../engine/core/src/ZoneManager.cpp; sourceTree = SOURCE_ROOT; };
-		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreDefines.h; path = ../engine/core/include/CoreDefines.h; sourceTree = SOURCE_ROOT; };
-		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightFadeJob.h; path = ../engine/core/include/LightFadeJob.h; sourceTree = SOURCE_ROOT; };
-		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
-		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
-		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
-		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
-		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentLoader.cpp; path = ../engine/core/src/ContentLoader.cpp; sourceTree = SOURCE_ROOT; };
-		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitching.cpp; path = ../engine/core/src/SoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Zone.cpp; sourceTree = "<group>"; };
+		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ZoneManager.cpp; sourceTree = "<group>"; };
+		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreDefines.h; sourceTree = "<group>"; };
+		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightFadeJob.h; sourceTree = "<group>"; };
+		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Trigger.h; sourceTree = "<group>"; };
+		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Zone.h; sourceTree = "<group>"; };
+		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = "<group>"; };
+		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = "<group>"; };
+		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = "<group>"; };
+		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = "<group>"; };
+		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentLoader.cpp; sourceTree = "<group>"; };
+		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitching.cpp; sourceTree = "<group>"; };
 		483646A10D83D57800912FEC /* libruby.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libruby.dylib; path = /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/libruby.dylib; sourceTree = "<absolute>"; };
 		4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Xerces.framework; path = /Library/Frameworks/Xerces.framework; sourceTree = "<absolute>"; };
-		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StartAnimationJob.cpp; path = ../engine/core/src/StartAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
+		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StartAnimationJob.cpp; sourceTree = "<group>"; };
 		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatGui.cpp; sourceTree = "<group>"; };
 		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameSaveLoadWindow.cpp; sourceTree = "<group>"; };
 		48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuLoadWindow.cpp; sourceTree = "<group>"; };
@@ -1349,12 +1350,11 @@
 		48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlPropertyKeys.swig; path = ../engine/script/swig/TypeRlPropertyKeys.swig; sourceTree = SOURCE_ROOT; };
 		48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeStdPairIntInt.swig; path = ../engine/script/swig/TypeStdPairIntInt.swig; sourceTree = SOURCE_ROOT; };
 		48389C020D86787900AFAB66 /* RlExports.i */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.interfacer; name = RlExports.i; path = ../engine/script/swig/RlExports.i; sourceTree = SOURCE_ROOT; };
-		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitchingObject.h; path = ../engine/core/include/SoundStitchingObject.h; sourceTree = SOURCE_ROOT; };
-		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitchingObject.cpp; path = ../engine/core/src/SoundStitchingObject.cpp; sourceTree = SOURCE_ROOT; };
+		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitchingObject.h; sourceTree = "<group>"; };
+		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitchingObject.cpp; sourceTree = "<group>"; };
 		48389C190D867AA900AFAB66 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/script/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
 		48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TriggerFactory.cpp; path = ../engine/script/src/TriggerFactory.cpp; sourceTree = SOURCE_ROOT; };
-		483D31100D85B1AF003477A0 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = ../engine/core/include/nulldriver/NullSoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = ../engine/core/src/nulldriver/NullSoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = nulldriver/NullSoundStitching.cpp; sourceTree = "<group>"; };
 		483D31150D85B215003477A0 /* Combatant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Combatant.h; sourceTree = "<group>"; };
 		483D31160D85B215003477A0 /* EffectManagementTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectManagementTask.h; sourceTree = "<group>"; };
 		483D31170D85B215003477A0 /* GameEventLog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventLog.h; sourceTree = "<group>"; };
@@ -1421,28 +1421,29 @@
 		483D87C90D8C55E500F3629E /* RlScript.bundle */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = RlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
 		484FE6B90E17BC8800FA880F /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
 		48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlScriptExportsMac.cpp; path = ../engine/script/swig/RlScriptExportsMac.cpp; sourceTree = SOURCE_ROOT; };
+		4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = nulldriver/NullSoundStitching.h; sourceTree = "<group>"; };
 		48570C1B0D8A6C5400096E35 /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		4857E4E40D46A664009D376D /* OIS.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OIS.framework; path = /Library/Frameworks/OIS.framework; sourceTree = "<absolute>"; };
-		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreMessages.h; path = ../engine/core/include/CoreMessages.h; sourceTree = SOURCE_ROOT; };
-		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobQueue.h; path = ../engine/core/include/JobQueue.h; sourceTree = SOURCE_ROOT; };
+		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreMessages.h; sourceTree = "<group>"; };
+		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobQueue.h; sourceTree = "<group>"; };
 		485A056A0D71EDC40024198D /* MessageObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageObject.h; path = ../engine/core/include/MessageObject.h; sourceTree = SOURCE_ROOT; };
 		485A056B0D71EDC40024198D /* MessagePump.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessagePump.h; path = ../engine/core/include/MessagePump.h; sourceTree = SOURCE_ROOT; };
 		485A056C0D71EDC40024198D /* MessageType.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageType.h; path = ../engine/core/include/MessageType.h; sourceTree = SOURCE_ROOT; };
-		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PolynomicSoundFadeFunctor.h; path = ../engine/core/include/PolynomicSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFile.h; path = ../engine/core/include/SaveGameFile.h; sourceTree = SOURCE_ROOT; };
-		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileReader.h; path = ../engine/core/include/SaveGameFileReader.h; sourceTree = SOURCE_ROOT; };
-		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileWriter.h; path = ../engine/core/include/SaveGameFileWriter.h; sourceTree = SOURCE_ROOT; };
-		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameManager.h; path = ../engine/core/include/SaveGameManager.h; sourceTree = SOURCE_ROOT; };
-		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimeSource.h; path = ../engine/core/include/TimeSource.h; sourceTree = SOURCE_ROOT; };
-		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobQueue.cpp; path = ../engine/core/src/JobQueue.cpp; sourceTree = SOURCE_ROOT; };
+		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PolynomicSoundFadeFunctor.h; sourceTree = "<group>"; };
+		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFile.h; sourceTree = "<group>"; };
+		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileReader.h; sourceTree = "<group>"; };
+		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileWriter.h; sourceTree = "<group>"; };
+		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameManager.h; sourceTree = "<group>"; };
+		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TimeSource.h; sourceTree = "<group>"; };
+		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobQueue.cpp; sourceTree = "<group>"; };
 		485A057E0D71EDF20024198D /* MessagePump.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MessagePump.cpp; path = ../engine/core/src/MessagePump.cpp; sourceTree = SOURCE_ROOT; };
-		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PolynomicSoundFadeFunctor.cpp; path = ../engine/core/src/PolynomicSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFile.cpp; path = ../engine/core/src/SaveGameFile.cpp; sourceTree = SOURCE_ROOT; };
-		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileReader.cpp; path = ../engine/core/src/SaveGameFileReader.cpp; sourceTree = SOURCE_ROOT; };
-		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileWriter.cpp; path = ../engine/core/src/SaveGameFileWriter.cpp; sourceTree = SOURCE_ROOT; };
-		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameManager.cpp; path = ../engine/core/src/SaveGameManager.cpp; sourceTree = SOURCE_ROOT; };
-		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimeSource.cpp; path = ../engine/core/src/TimeSource.cpp; sourceTree = SOURCE_ROOT; };
-		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Trigger.cpp; path = ../engine/core/src/Trigger.cpp; sourceTree = SOURCE_ROOT; };
+		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PolynomicSoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFile.cpp; sourceTree = "<group>"; };
+		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileReader.cpp; sourceTree = "<group>"; };
+		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileWriter.cpp; sourceTree = "<group>"; };
+		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameManager.cpp; sourceTree = "<group>"; };
+		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TimeSource.cpp; sourceTree = "<group>"; };
+		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Trigger.cpp; sourceTree = "<group>"; };
 		485B89510E15794A00D5B19C /* Scene.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Scene.h; path = ../engine/script/include/Scene.h; sourceTree = SOURCE_ROOT; };
 		485B89520E15794A00D5B19C /* SceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneLoader.h; path = ../engine/script/include/SceneLoader.h; sourceTree = SOURCE_ROOT; };
 		485B89530E15794A00D5B19C /* SceneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneManager.h; path = ../engine/script/include/SceneManager.h; sourceTree = SOURCE_ROOT; };
@@ -1457,6 +1458,8 @@
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
 		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = "<absolute>"; };
+		4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoaderImpl.h; path = ai/include/DialogLoaderImpl.h; sourceTree = "<group>"; };
+		4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoaderImpl.cpp; path = ai/src/DialogLoaderImpl.cpp; sourceTree = "<group>"; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbstractMovement.h; sourceTree = "<group>"; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FallDownMovement.h; sourceTree = "<group>"; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogBackwardsMovement.h; sourceTree = "<group>"; };
@@ -1505,24 +1508,24 @@
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
 		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = "<absolute>"; };
-		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
-		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleCollection.h; path = ../engine/core/include/SaveAbleCollection.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleFactory.h; path = ../engine/core/include/SaveAbleFactory.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleManager.h; path = ../engine/core/include/SaveAbleManager.h; sourceTree = SOURCE_ROOT; };
+		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAble.h; sourceTree = "<group>"; };
+		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleCollection.h; sourceTree = "<group>"; };
+		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleFactory.h; sourceTree = "<group>"; };
+		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleManager.h; sourceTree = "<group>"; };
 		48D0BE300E273C8000863824 /* WriteableDataStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStream.h; path = ../engine/common/include/WriteableDataStream.h; sourceTree = SOURCE_ROOT; };
 		48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStreamFormatTarget.h; path = ../engine/common/include/WriteableDataStreamFormatTarget.h; sourceTree = SOURCE_ROOT; };
 		48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableFileSystemArchiv.h; path = ../engine/common/include/WriteableFileSystemArchiv.h; sourceTree = SOURCE_ROOT; };
 		48D0BE360E273C9700863824 /* WriteableDataStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStream.cpp; path = ../engine/common/src/WriteableDataStream.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStreamFormatTarget.cpp; path = ../engine/common/src/WriteableDataStreamFormatTarget.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableFileSystemArchiv.cpp; path = ../engine/common/src/WriteableFileSystemArchiv.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAble.cpp; path = ../engine/core/src/SaveAble.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleCollection.cpp; path = ../engine/core/src/SaveAbleCollection.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleFactory.cpp; path = ../engine/core/src/SaveAbleFactory.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleManager.cpp; path = ../engine/core/src/SaveAbleManager.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAble.cpp; sourceTree = "<group>"; };
+		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleCollection.cpp; sourceTree = "<group>"; };
+		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleFactory.cpp; sourceTree = "<group>"; };
+		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleManager.cpp; sourceTree = "<group>"; };
 		48D0BE680E273FF400863824 /* DialogLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoader.h; path = ../engine/ai/include/DialogLoader.h; sourceTree = SOURCE_ROOT; };
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
-		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
-		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
+		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameData.h; sourceTree = "<group>"; };
+		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameData.cpp; sourceTree = "<group>"; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = "<group>"; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = "<group>"; };
@@ -1823,171 +1826,11 @@
 		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
 			isa = PBXGroup;
 			children = (
-				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
-				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
-				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
-				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
-				48D0BE280E273C5E00863824 /* SaveAble.h */,
-				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
-				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
-				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
-				485A05860D71EDF20024198D /* Trigger.cpp */,
-				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
-				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
-				485A05690D71EDC40024198D /* JobQueue.h */,
-				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
-				485A05720D71EDC40024198D /* TimeSource.h */,
-				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
-				48D34A610D90F5D500C89477 /* SaveGameData.h */,
-				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
-				483D31100D85B1AF003477A0 /* NullSoundStitching.h */,
-				485A05850D71EDF20024198D /* TimeSource.cpp */,
-				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
-				483646960D83D13700912FEC /* ContentLoader.h */,
-				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
-				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
-				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
-				485A056E0D71EDC40024198D /* SaveGameFile.h */,
-				485A05670D71ED8D0024198D /* CoreMessages.h */,
-				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
-				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
-				485A05710D71EDC40024198D /* SaveGameManager.h */,
-				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
-				483646970D83D13700912FEC /* SoundStitching.h */,
-				483646980D83D13700912FEC /* StartAnimationJob.h */,
-				485A057D0D71EDF20024198D /* JobQueue.cpp */,
-				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
-				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
-				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
-				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
-				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
-				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
-				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
-				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
-				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
-				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
-				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
-				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
-				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
-				44D814730BF7B62F00534175 /* CoreDefines.h */,
-				44D814740BF7B62F00534175 /* LightFadeJob.h */,
-				44D814750BF7B62F00534175 /* Trigger.h */,
-				44D814760BF7B62F00534175 /* Zone.h */,
-				44D814770BF7B62F00534175 /* ZoneManager.h */,
-				44D8146F0BF7B61500534175 /* Zone.cpp */,
-				44D814700BF7B61500534175 /* ZoneManager.cpp */,
-				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
-				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
-				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
-				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
-				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
-				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
-				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
-				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
-				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
-				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
-				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
-				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
-				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
-				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
-				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
-				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
-				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
-				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
-				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
-				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
-				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
-				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
-				444EABB50BD0E33300C6D4A0 /* Job.h */,
-				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
-				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
-				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
-				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
-				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
-				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
-				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
-				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
-				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
-				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
-				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
-				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
-				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
-				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
-				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
-				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
-				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
-				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
-				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
-				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
-				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
-				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
-				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
-				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
-				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
-				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
-				444EABD60BD0E33300C6D4A0 /* Sound.h */,
-				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
-				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
-				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
-				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
-				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
-				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
-				444EABDD0BD0E33300C6D4A0 /* World.h */,
-				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
-				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
-				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
-				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
-				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
-				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
-				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
-				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
-				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
-				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
-				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
-				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
-				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
-				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
-				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
-				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
-				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
-				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
-				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
-				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
-				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
-				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
-				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
-				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
-				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
-				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
-				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
-				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
-				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
-				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
-				444EAB420BD0E2B600C6D4A0 /* nulldriver */,
-				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
-				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
-				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
-				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
-				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
-				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
-				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
-				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
-				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
-				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
-				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
-				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
-				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
-				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
-				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
-				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
-				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
-				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
-				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
-				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
-				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
-				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+				4851EA4C0EDDC82400AB79E9 /* Source */,
+				4851EA4D0EDDC8CA00AB79E9 /* Header */,
 			);
 			name = RlCore;
+			path = core;
 			sourceTree = "<group>";
 		};
 		444EAC220BD0E3E000C6D4A0 /* RlAi */ = {
@@ -2066,7 +1909,9 @@
 				444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */,
 				444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */,
 				48D0BE680E273FF400863824 /* DialogLoader.h */,
+				4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */,
 				48D0BE6B0E27401E00863824 /* DialogLoader.cpp */,
+				4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */,
 			);
 			name = RlAi;
 			sourceTree = "<group>";
@@ -2174,6 +2019,184 @@
 			path = src;
 			sourceTree = "<group>";
 		};
+		4851EA4C0EDDC82400AB79E9 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
+				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
+				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
+				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
+				485A05860D71EDF20024198D /* Trigger.cpp */,
+				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
+				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
+				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
+				485A05850D71EDF20024198D /* TimeSource.cpp */,
+				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
+				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
+				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
+				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
+				485A057D0D71EDF20024198D /* JobQueue.cpp */,
+				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
+				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
+				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
+				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
+				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
+				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
+				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
+				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
+				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
+				44D8146F0BF7B61500534175 /* Zone.cpp */,
+				44D814700BF7B61500534175 /* ZoneManager.cpp */,
+				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
+				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
+				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
+				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
+				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
+				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
+				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
+				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
+				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
+				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
+				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
+				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
+				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
+				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
+				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
+				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
+				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
+				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
+				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
+				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
+				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
+				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
+				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
+				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
+				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
+				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
+				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
+				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
+				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
+				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
+				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
+				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
+				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
+				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
+				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
+				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
+				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
+				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
+				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
+				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
+				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
+				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
+				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
+				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
+				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
+				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
+				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
+				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
+				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
+				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
+				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
+				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+			);
+			name = Source;
+			path = src;
+			sourceTree = "<group>";
+		};
+		4851EA4D0EDDC8CA00AB79E9 /* Header */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE280E273C5E00863824 /* SaveAble.h */,
+				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
+				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
+				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
+				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
+				485A05690D71EDC40024198D /* JobQueue.h */,
+				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
+				485A05720D71EDC40024198D /* TimeSource.h */,
+				48D34A610D90F5D500C89477 /* SaveGameData.h */,
+				483646960D83D13700912FEC /* ContentLoader.h */,
+				485A056E0D71EDC40024198D /* SaveGameFile.h */,
+				485A05670D71ED8D0024198D /* CoreMessages.h */,
+				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
+				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
+				485A05710D71EDC40024198D /* SaveGameManager.h */,
+				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
+				483646970D83D13700912FEC /* SoundStitching.h */,
+				483646980D83D13700912FEC /* StartAnimationJob.h */,
+				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
+				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
+				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
+				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
+				44D814730BF7B62F00534175 /* CoreDefines.h */,
+				44D814740BF7B62F00534175 /* LightFadeJob.h */,
+				44D814750BF7B62F00534175 /* Trigger.h */,
+				44D814760BF7B62F00534175 /* Zone.h */,
+				44D814770BF7B62F00534175 /* ZoneManager.h */,
+				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
+				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
+				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
+				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
+				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
+				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
+				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
+				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
+				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
+				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
+				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
+				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
+				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
+				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
+				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
+				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
+				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
+				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
+				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
+				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
+				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
+				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
+				444EABB50BD0E33300C6D4A0 /* Job.h */,
+				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
+				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
+				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
+				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
+				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
+				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
+				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
+				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
+				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
+				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
+				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
+				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
+				4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */,
+				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
+				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
+				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
+				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
+				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
+				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
+				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
+				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
+				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
+				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
+				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
+				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
+				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
+				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
+				444EABD60BD0E33300C6D4A0 /* Sound.h */,
+				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
+				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
+				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
+				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
+				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
+				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
+				444EABDD0BD0E33300C6D4A0 /* World.h */,
+			);
+			name = Header;
+			path = include;
+			sourceTree = "<group>";
+		};
 		48B006C30ECABFB0008141C2 /* windows */ = {
 			isa = PBXGroup;
 			children = (
@@ -2651,7 +2674,6 @@
 				483646990D83D13700912FEC /* ContentLoader.h in Headers */,
 				4836469A0D83D13700912FEC /* SoundStitching.h in Headers */,
 				4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */,
-				483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */,
 				48389C0F0D86797000AFAB66 /* SoundStitchingObject.h in Headers */,
 				48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */,
 				48D34A630D90F5D500C89477 /* SaveGameData.h in Headers */,
@@ -2664,6 +2686,7 @@
 				48D0BE2D0E273C5E00863824 /* SaveAbleCollection.h in Headers */,
 				48D0BE2E0E273C5E00863824 /* SaveAbleFactory.h in Headers */,
 				48D0BE2F0E273C5E00863824 /* SaveAbleManager.h in Headers */,
+				4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2710,6 +2733,7 @@
 				483D31630D85B398003477A0 /* SimpleVehicle.h in Headers */,
 				483D31640D85B398003477A0 /* WalkPathBehaviour.h in Headers */,
 				48D0BE690E273FF400863824 /* DialogLoader.h in Headers */,
+				4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3317,6 +3341,7 @@
 				48389BC10D8675E700AFAB66 /* DialogResponse.cpp in Sources */,
 				48389BC20D8675E700AFAB66 /* DialogVariable.cpp in Sources */,
 				48D0BE6D0E27401E00863824 /* DialogLoader.cpp in Sources */,
+				4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/trunk/engine/ai/include/DialogLoader.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoader.h	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/include/DialogLoader.h	2008-12-04 19:17:08 UTC (rev 4630)
@@ -18,24 +18,13 @@
 
 #include "AiPrerequisites.h"
 
-#include "Properties.h"
-#include "XmlProcessor.h"
- 
 namespace rl 
 {
 	class Creature;
     class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-	class Property;
+    class DialogLoaderImpl;
 
-
-	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	class DialogLoader : public Ogre::ScriptLoader
 	{
 	public:
 		DialogLoader();
@@ -48,48 +37,9 @@
 		Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
 
 	private: 
-		class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString& id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString& id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
-            void setProperty(const CeGuiString& key, const Property& value);
-
-        private:
-            std::map<CeGuiString, DialogOption*> mOptionCache;
-            std::map<CeGuiString, DialogResponse*> mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-		
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
-
         Ogre::StringVector mScriptPatterns;
-        std::map<Ogre::String, DialogPrototype*> mDialogs;
-
-	};
+        DialogLoaderImpl* mLoaderImplementation;
+    };
 }
 
 #endif //__DialogLoader_H__

Added: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2008-12-04 19:17:08 UTC (rev 4630)
@@ -0,0 +1,79 @@
+/*
+ *  DialogLoaderImpl.h
+ *  Rastullah
+ *
+ *  Created by Sascha Kolewa on 04.12.08.
+ *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *
+ */
+
+#include "AiPrerequisites.h"
+
+#include "Properties.h"
+#include "XmlProcessor.h"
+
+namespace rl
+{
+    class Creature;
+    class Dialog;
+    class DialogCondition;
+    class DialogElement;
+    class DialogImplication;
+    class DialogOption;
+    class DialogParagraph;
+    class DialogResponse;
+    class DialogVariable;
+	class Property;
+    
+    class DialogLoaderImpl : private XmlProcessor
+    {
+    public:
+        DialogLoaderImpl();
+        ~DialogLoaderImpl();
+        
+        Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
+        void parseDialog(Ogre::DataStreamPtr& stream, const Ogre::String& groupName);
+
+    private:
+        class DialogPrototype
+        {
+        public:
+            DialogPrototype();
+            ~DialogPrototype();
+            void addOption(DialogOption* option);
+            DialogOption* getOption(const CeGuiString& id) const;
+            void addResponse(DialogResponse* option);
+            DialogResponse* getResponse(const CeGuiString& id) const;
+            
+            void setStartResponse(DialogResponse* response);
+            Dialog* createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
+            void setProperty(const CeGuiString& key, const Property& value);
+            
+        private:
+            std::map<CeGuiString, DialogOption*> mOptionCache;
+            std::map<CeGuiString, DialogResponse*> mResponseCache;
+            DialogResponse* mDialogStart;
+            PropertyRecord mPropertyVariables;
+        };
+
+        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
+        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
+        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
+        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
+        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
+        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
+        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
+        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
+        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
+        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
+        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
+        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
+        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
+
+        std::map<Ogre::String, DialogPrototype*> mDialogs;
+
+    };
+}
\ No newline at end of file

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/include/Makefile.am	2008-12-04 19:17:08 UTC (rev 4630)
@@ -20,6 +20,7 @@
 	DialogElementSelection.h \
 	DialogImplication.h \
 	DialogLoader.h \
+	DialogLoaderImpl.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2008-12-04 19:17:08 UTC (rev 4630)
@@ -1,57 +1,38 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #include "stdinc.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "DialogLoader.h"
+#include "DialogLoaderImpl.h"
 
-#include "ConfigurationManager.h"
-#include "Dialog.h"
-#include "DialogCondition.h"
-#include "DialogElement.h"
-#include "DialogImplication.h"
-#include "DialogOption.h"
-#include "DialogParagraph.h"
-#include "DialogResponse.h"
-#include "DialogVariable.h"
-#include "XmlPropertyReader.h"
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
 	DialogLoader::DialogLoader()
-	      : XmlProcessor(), ScriptLoader()
+	      : ScriptLoader()
     {
+        mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back("*.dialog");
   	}
 	
     DialogLoader::~DialogLoader()
     {
-		std::map<Ogre::String, DialogPrototype*>::iterator itr = mDialogs.begin();
-        std::map<Ogre::String, DialogPrototype*>::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
-        {
-			DialogPrototype* p = itr->second;
-			delete p;
-		}
-        mDialogs.clear();
+        delete mLoaderImplementation;
 	}
  
     const StringVector& DialogLoader::getScriptPatterns() const
@@ -63,693 +44,16 @@
     {
         return 1000;
     }
-
-    void DialogLoader::parseScript(DataStreamPtr& stream, const Ogre::String& groupName)
+    
+    void DialogLoader::parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
-
-            for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes->item(i);
-                processDialog(static_cast<DOMElement*>(cur));
-            }
-        }
-
-        shutdownXml();
+        mLoaderImplementation->parseDialog(stream, groupName);
     }
-	
-	Dialog* DialogLoader::createDialog(const String& name, const std::vector<Creature*>& pcs, 
-		const std::vector<Creature*>& npcs) const
-	{
-		std::map<Ogre::String, DialogPrototype*>::const_iterator it =
-			mDialogs.find(name);
-			
-		if (it == mDialogs.end())
-		{
-			return NULL;
-		}
-		
-		return it->second->createDialog(pcs, npcs);
-	}
-	
-    void DialogLoader::processDialog(DOMElement* dialogElem)
+    
+    Dialog* DialogLoader::createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const
     {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, "option", dialogPrototype);
-        processElementNodes(dialogElem, "switchoption", dialogPrototype);
-        processElementNodes(dialogElem, "response", dialogPrototype);
-        processElementNodes(dialogElem, "switchresponse", dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
-        {
-            if (hasNodeName(curChild, "variable"))
-            {
-                createDialogVariable(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "option"))
-            {
-                processOption(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchoption"))
-            {
-                processSwitchOption(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "response"))
-            {
-                processResponse(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchresponse"))
-            {
-                processSwitchResponse(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "start"))
-            {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild->getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype->setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
+        return mLoaderImplementation->createDialog(name, pcs, npcs);
     }
 
-    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml->getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i < dialogElemNodes->getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast<DOMElement*>(dialogElemNodes->item(i));
-            if (!hasAttribute(dialogElemXml, "id"))
-            {
-                Throw(WrongFormatException, "option/switchoption/response/switchresponse node without id found");
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
-            CeGuiString text = getValueAsString(dialogElemXml);
-
-            if (hasNodeName(dialogElemXml, "switchoption"))
-            {
-                DialogOption* option = new DialogSelection<DialogOption>(id);
-                option->setLabel(text);
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "option"))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, "autoSelect");
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, "label"))
-                {
-                    option->setLabel(getAttributeValueAsString(dialogElemXml, "label"));
-                }
-                else
-                {
-                    option->setLabel(text);
-                }
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "response"))
-            {
-                dialogPrototype->addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, "switchresponse"))
-            {
-                dialogPrototype->addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, "response"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "gotoresponse"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchresponse"))
-        {
-            response = processSwitchResponse(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, "id");
-
-        DialogResponse* response = dialogPrototype->getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response->addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response->addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, "p"))
-                {
-                    response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, "gotoresponse"))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast<DOMElement*>(cur), "id");
-                    response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response->addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
-        DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                response->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response->addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, "option"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "optionref"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchoption"))
-        {
-            option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, "id");
-
-        DialogOption* option = dialogPrototype->getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option->setResponse(response);
-                }
-                else if (hasNodeName(cur, "if"))
-                {
-                    option->setPrecondition(processIf(static_cast<DOMElement*>(cur)));
-                }
-                else if (hasNodeName(cur, "p"))
-                {
-                    option->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, "label");
-                        if(!label.empty())
-                        {
-                            option->setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option->addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, "label");
-            if(!label.empty())
-            {
-                option->setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
-        DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                option->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option->addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, "t"))
-            {
-                DOMElement* translation = static_cast<DOMElement*>(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, "language") == 
-                    ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, "label");
-                    if(!label.empty())
-                    {
-                        option->setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype->setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast<DOMElement*>(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond->setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = "";
-        if (hasAttribute(paragraphXml, "voicefile"))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, "voicefile");
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast<DOMElement*>(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    DialogLoader::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogLoader::DialogPrototype::~DialogPrototype()
-    {
-        std::map<CeGuiString, DialogOption*>::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it->second != NULL )
-                delete it->second;
-
-        std::map<CeGuiString, DialogResponse*>::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1->second != NULL )
-                delete it1->second;
-    }
-
-    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option->getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate option/switchoption ID "+ option->getId()).c_str());
-        }
-        mOptionCache[option->getId()] = option;
-    }
-
-    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogOption*>::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response->getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate Response/switchResponse ID "+ response->getId()).c_str());
-        }
-        mResponseCache[response->getId()] = response;
-    }
-
-    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogResponse*>::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog->setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog->setProperty(it->first, it->second);
-        }
-
-        return dialog;
-    }
-
-    void DialogLoader::DialogPrototype::setProperty(const CeGuiString& key, const Property& value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-
-    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, "equals"))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "inrange"))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, "from"),
-                getAttributeValueAsReal(conditionXml, "to"));
-        }
-        else if (hasNodeName(conditionXml, "lower"))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "lowereq"))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greater"))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greatereq"))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, "dialogvariable"))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, "name"));
-        }
-        else if (hasNodeName(variableXml, "queststate"))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, "quest");
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, "property");
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, "attributecheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "attribute");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, "talentcheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "talent");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-		else if (hasNodeName(variableXml, "random"))
-		{
-			int maximum = getAttributeValueAsInteger(variableXml, "maximum");
-			return new RandomVariable(maximum);
-		}
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
-
-            if (hasNodeName(implicationElem, "setvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "incvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "decvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "setoptionactive"))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, "id");
-                bool value = getAttributeValueAsBool(implicationElem, "value");
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, "exit"))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, "changequest"))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, "quest");
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, "property");
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, "newvalue");
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (hasNodeName(cur, "p"))
-            {
-                element->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-            }
-        }
-    }
-
 }
 

Added: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2008-12-04 19:17:08 UTC (rev 4630)
@@ -0,0 +1,737 @@
+/*
+ *  DialogLoaderImpl.cpp
+ *  Rastullah
+ *
+ *  Created by Sascha Kolewa on 04.12.08.
+ *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *
+ */
+#include "stdinc.h"
+
+#include <xercesc/dom/DOM.hpp>
+
+#include "DialogLoaderImpl.h"
+
+#include "ConfigurationManager.h"
+#include "Dialog.h"
+#include "DialogCondition.h"
+#include "DialogElement.h"
+#include "DialogImplication.h"
+#include "DialogOption.h"
+#include "DialogParagraph.h"
+#include "DialogResponse.h"
+#include "DialogVariable.h"
+#include "XmlPropertyReader.h"
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+    DialogLoaderImpl::DialogLoaderImpl()
+    : XmlProcessor()
+    {
+    }
+    
+    DialogLoaderImpl::~DialogLoaderImpl()
+    {
+		std::map<Ogre::String, DialogPrototype*>::iterator itr = mDialogs.begin();
+        std::map<Ogre::String, DialogPrototype*>::iterator end = mDialogs.end();
+        for(; itr != end; ++itr)
+        {
+			DialogPrototype* p = itr->second;
+			delete p;
+		}
+        mDialogs.clear();
+	}
+    
+
+    void DialogLoaderImpl::parseDialog(DataStreamPtr& stream, const Ogre::String& groupName)
+    {
+        initializeXml();
+        
+        DOMDocument* doc = loadDocument(stream);
+        if (doc)
+        {
+            DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
+            
+            for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
+            {
+                DOMNode* cur = dialogNodes->item(i);
+                processDialog(static_cast<DOMElement*>(cur));
+            }
+        }
+        
+        shutdownXml();
+    }
+
+    Dialog* DialogLoaderImpl::createDialog(const String& name, const std::vector<Creature*>& pcs, 
+                                       const std::vector<Creature*>& npcs) const
+    {
+        std::map<Ogre::String, DialogPrototype*>::const_iterator it =
+        mDialogs.find(name);
+        
+        if (it == mDialogs.end())
+        {
+            return NULL;
+        }
+        
+        return it->second->createDialog(pcs, npcs);
+    }
+
+    void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
+    {
+        DialogPrototype* dialogPrototype = new DialogPrototype();
+        Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
+        mDialogs[name] = dialogPrototype;
+        
+        // first step: process all possible references
+        processElementNodes(dialogElem, "option", dialogPrototype);
+        processElementNodes(dialogElem, "switchoption", dialogPrototype);
+        processElementNodes(dialogElem, "response", dialogPrototype);
+        processElementNodes(dialogElem, "switchresponse", dialogPrototype);
+        
+        for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
+        {
+            if (hasNodeName(curChild, "variable"))
+            {
+                createDialogVariable(static_cast<DOMElement*>(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, "option"))
+            {
+                processOption(static_cast<DOMElement*>(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, "switchoption"))
+            {
+                processSwitchOption(static_cast<DOMElement*>(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, "response"))
+            {
+                processResponse(static_cast<DOMElement*>(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, "switchresponse"))
+            {
+                processSwitchResponse(static_cast<DOMElement*>(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, "start"))
+            {
+                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL; 
+                     curChildChild = curChildChild->getNextSibling())
+                {
+                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    if (response)
+                    {
+                        dialogPrototype->setStartResponse(response);
+                    }
+                }
+            }
+        }
+        LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
+    }
+
+    void DialogLoaderImpl::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
+    {
+        DOMNodeList* dialogElemNodes = dialogXml->getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
+        for (XMLSize_t i = 0; i < dialogElemNodes->getLength(); ++i)
+        {
+            DOMElement* dialogElemXml = static_cast<DOMElement*>(dialogElemNodes->item(i));
+            if (!hasAttribute(dialogElemXml, "id"))
+            {
+                Throw(WrongFormatException, "option/switchoption/response/switchresponse node without id found");
+            }
+            CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
+            CeGuiString text = getValueAsString(dialogElemXml);
+            
+            if (hasNodeName(dialogElemXml, "switchoption"))
+            {
+                DialogOption* option = new DialogSelection<DialogOption>(id);
+                option->setLabel(text);
+                dialogPrototype->addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, "option"))
+            {
+                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, "autoSelect");
+                DialogOption* option = new DialogOption(id, isAutoSelected);
+                if (hasAttribute(dialogElemXml, "label"))
+                {
+                    option->setLabel(getAttributeValueAsString(dialogElemXml, "label"));
+                }
+                else
+                {
+                    option->setLabel(text);
+                }
+                dialogPrototype->addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, "response"))
+            {
+                dialogPrototype->addResponse(new DialogResponse(id));
+            }
+            else if (hasNodeName(dialogElemXml, "switchresponse"))
+            {
+                dialogPrototype->addResponse(new DialogResponseSelection(id));
+            }
+        }
+        
+    }
+
+    DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogResponse* response = NULL;
+        if (hasNodeName(node, "response"))
+        {
+            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, "gotoresponse"))
+        {
+            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, "switchresponse"))
+        {
+            response = processSwitchResponse(static_cast<DOMElement*>(node), dialogPrototype);
+        }
+        return response;
+    }
+
+    DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        CeGuiString id = getAttributeValueAsString(responseXml, "id");
+        
+        DialogResponse* response = dialogPrototype->getResponse(id);
+        
+        if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
+        
+        bool languageDefined = false;
+        DOMElement* defaultLanguage = NULL;
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+            
+            for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+            {
+                DialogOption* option = processOptionClasses(cur, dialogPrototype);
+                if (option)
+                {
+                    response->addOption(option);
+                    continue;
+                }
+                
+                DialogImplication* implication = processImplicationClasses(cur);
+                if (implication)
+                {
+                    response->addImplication(implication);
+                    continue;
+                }
+                
+                if (hasNodeName(cur, "p"))
+                {
+                    response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+                    paragraphsDefined = true;
+                }
+                // process translations
+                else if (hasNodeName(cur, "t"))
+                {
+                    DOMElement* translation = static_cast<DOMElement*>(cur);
+                    // check loca
+                    if(getAttributeValueAsStdString(translation, "language") 
+                       == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
+                    {
+                        processTranslation(response, translation);
+                        languageDefined = true;
+                    }
+                    // set german as default language
+                    if(getAttributeValueAsStdString(translation, "language") == "de")
+                    {
+                        defaultLanguage = translation;
+                    }
+                    paragraphsDefined = true;
+                }
+                else if (hasNodeName(cur, "gotoresponse"))
+                {
+                    CeGuiString id = getAttributeValueAsString(static_cast<DOMElement*>(cur), "id");
+                    response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
+                }
+            }
+            
+            if (!paragraphsDefined)
+            {
+                CeGuiString responseXmlText = getValueAsString(responseXml);
+                response->addParagraph(new DialogParagraph(responseXmlText));
+            }
+        }            
+        // use german as the default language if german is not set as
+        // default language but no other language was found!
+        if(!languageDefined && defaultLanguage != NULL 
+           && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
+        {
+            processTranslation(response, defaultLanguage);
+            languageDefined = true;
+        }
+        
+        return response;
+    }
+
+    DialogResponse* DialogLoaderImpl::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
+    {
+        CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
+        DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
+        
+        if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
+        
+        for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
+            if (variable != NULL)
+            {
+                response->setVariable(variable);
+            }
+            else if (hasNodeName(cur, "case"))
+            {
+                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
+                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
+                {
+                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
+                    if (responseCase)
+                    {
+                        response->addElement(condition, responseCase);
+                        break;
+                    }
+                }               
+            }
+        }
+        
+        
+        return response;
+    }
+
+    DialogOption* DialogLoaderImpl::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogOption* option = NULL;
+        if (hasNodeName(node, "option"))
+        {
+            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, "optionref"))
+        {
+            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, "switchoption"))
+        {
+            option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
+        }
+        return option;
+    }
+
+    DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        CeGuiString id = getAttributeValueAsString(optionXml, "id");
+        
+        DialogOption* option = dialogPrototype->getOption(id);
+        
+        if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
+        
+        bool languageDefined = false;
+        DOMElement* defaultLanguage = NULL;
+        
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+            
+            for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+            {
+                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
+                if (response)
+                {
+                    option->setResponse(response);
+                }
+                else if (hasNodeName(cur, "if"))
+                {
+                    option->setPrecondition(processIf(static_cast<DOMElement*>(cur)));
+                }
+                else if (hasNodeName(cur, "p"))
+                {
+                    option->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+                    paragraphsDefined = true;
+                }
+                // process translations
+                else if (hasNodeName(cur, "t"))
+                {
+                    DOMElement* translation = static_cast<DOMElement*>(cur);
+                    // check loca
+                    if(getAttributeValueAsStdString(translation, "language") 
+                       == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
+                    {
+                        defaultLanguage = translation;
+                        processTranslation(option, translation);
+                        std::string label = getAttributeValueAsStdString(translation, "label");
+                        if(!label.empty())
+                        {
+                            option->setLabel(label);
+                        }
+                        languageDefined = true;
+                    }
+                    // set german as default language
+                    if(getAttributeValueAsStdString(translation, "language") == "de")
+                    {
+                        defaultLanguage = translation;
+                    }
+                    paragraphsDefined = true;
+                }
+            }
+            
+            if (!paragraphsDefined)
+            {
+                CeGuiString optionXmlText = getValueAsString(optionXml);
+                option->addParagraph(new DialogParagraph(optionXmlText));
+            }
+        }
+        // use german as the default language if german is not set as
+        // default language but no other language was found!
+        if(!languageDefined && defaultLanguage != NULL 
+           && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
+        {
+            processTranslation(option, defaultLanguage);
+            std::string label = getAttributeValueAsStdString(defaultLanguage, "label");
+            if(!label.empty())
+            {
+                option->setLabel(label);
+            }
+            languageDefined = true;
+        }
+        
+        return option;
+    }
+
+    DialogOption* DialogLoaderImpl::processSwitchOption(DOMElement *switchOptXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    {
+        CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
+        DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
+        
+        if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
+        
+        for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
+            if (variable != NULL)
+            {
+                option->setVariable(variable);
+            }
+            else if (hasNodeName(cur, "case"))
+            {
+                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
+                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
+                {
+                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
+                    if (optionCase)
+                    {
+                        option->addElement(condition, optionCase);
+                        break;
+                    }
+                }               
+            }
+            // process translations
+            else if (hasNodeName(cur, "t"))
+            {
+                DOMElement* translation = static_cast<DOMElement*>(cur);
+                // check loca
+                if(getAttributeValueAsStdString(translation, "language") == 
+                   ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
+                {
+                    std::string label = getAttributeValueAsStdString(translation, "label");
+                    if(!label.empty())
+                    {
+                        option->setLabel(label);
+                    }
+                } 
+            }
+        }
+        
+        return option;
+    }
+
+    void DialogLoaderImpl::createDialogVariable(DOMElement *variableXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    {
+        XmlPropertyReader reader;
+        PropertyEntry entry = reader.processProperty(variableXml);
+        dialogPrototype->setProperty(entry.first, entry.second);
+    }
+
+    DialogCondition* DialogLoaderImpl::processIf(DOMElement *ifXml)
+    {
+        DialogCondition* cond = NULL;
+        DialogVariable* var = NULL;
+        
+        for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DOMElement* curElem = static_cast<DOMElement*>(cur);
+                
+                DialogCondition* curCond = processConditionClasses(curElem);
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+                
+                DialogVariable* curVar = processVariableClasses(curElem);
+                if (curVar)
+                {
+                    var = curVar;
+                }
+            }
+        }
+        
+        cond->setVariable(var);
+        return cond;
+    }
+
+    DialogParagraph* DialogLoaderImpl::processParagraph(DOMElement* paragraphXml)
+    {
+        Ogre::String voicefile = "";
+        if (hasAttribute(paragraphXml, "voicefile"))
+        {
+            voicefile = getAttributeValueAsStdString(paragraphXml, "voicefile");
+        }
+        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
+    }
+
+    DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
+    {
+        DialogCondition* cond = NULL;
+        
+        for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DialogCondition* curCond = processConditionClasses(static_cast<DOMElement*>(cur));
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+            }
+        }
+        
+        return cond;
+    }
+
+    DialogLoaderImpl::DialogPrototype::DialogPrototype()
+    {
+    }
+
+    DialogLoaderImpl::DialogPrototype::~DialogPrototype()
+    {
+        std::map<CeGuiString, DialogOption*>::iterator it;
+        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
+            if( it->second != NULL )
+                delete it->second;
+        
+        std::map<CeGuiString, DialogResponse*>::iterator it1;
+        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
+            if( it1->second != NULL )
+                delete it1->second;
+    }
+
+    void DialogLoaderImpl::DialogPrototype::addOption(DialogOption* option)
+    {
+        if (mOptionCache.find(option->getId()) != mOptionCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                  CeGuiString("Duplicate option/switchoption ID "+ option->getId()).c_str());
+        }
+        mOptionCache[option->getId()] = option;
+    }
+
+    DialogOption* DialogLoaderImpl::DialogPrototype::getOption(const CeGuiString& id) const
+    {
+        std::map<CeGuiString, DialogOption*>::const_iterator it = mOptionCache.find(id);
+        if (it == mOptionCache.end())
+        {
+            return NULL;
+        }
+        return it->second;
+    }
+
+    void DialogLoaderImpl::DialogPrototype::addResponse(DialogResponse* response)
+    {
+        if (mResponseCache.find(response->getId()) != mResponseCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                  CeGuiString("Duplicate Response/switchResponse ID "+ response->getId()).c_str());
+        }
+        mResponseCache[response->getId()] = response;
+    }
+
+    DialogResponse* DialogLoaderImpl::DialogPrototype::getResponse(const CeGuiString& id) const
+    {
+        std::map<CeGuiString, DialogResponse*>::const_iterator it = mResponseCache.find(id);
+        if (it == mResponseCache.end())
+        {
+            return NULL;
+        }
+        return it->second;
+    }
+
+    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
+    {
+        Dialog* dialog = new Dialog(pcs, npcs);
+        dialog->setStartResponse(mDialogStart);
+        
+        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+             it != mPropertyVariables.end(); ++it)
+        {
+            dialog->setProperty(it->first, it->second);
+        }
+        
+        return dialog;
+    }
+
+    void DialogLoaderImpl::DialogPrototype::setProperty(const CeGuiString& key, const Property& value)
+    {
+        mPropertyVariables.setProperty(key, value);
+    }
+
+    void DialogLoaderImpl::DialogPrototype::setStartResponse(DialogResponse* start)
+    {
+        mDialogStart = start;
+    }
+
+
+    DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
+    {
+        if (hasNodeName(conditionXml, "equals"))
+        {
+            return new DialogConditionEquals(
+                                             getAttributeValueAsString(conditionXml, "value"));
+        }
+        else if (hasNodeName(conditionXml, "inrange"))
+        {
+            return new DialogConditionInRange(
+                                              getAttributeValueAsReal(conditionXml, "from"),
+                                              getAttributeValueAsReal(conditionXml, "to"));
+        }
+        else if (hasNodeName(conditionXml, "lower"))
+        {
+            return new DialogConditionLowerThan(
+                                                getAttributeValueAsReal(conditionXml, "value"));
+        }
+        else if (hasNodeName(conditionXml, "lowereq"))
+        {
+            return new DialogConditionLowerOrEquals(
+                                                    getAttributeValueAsReal(conditionXml, "value"));
+        }
+        else if (hasNodeName(conditionXml, "greater"))
+        {
+            return new DialogConditionGreaterThan(
+                                                  getAttributeValueAsReal(conditionXml, "value"));
+        }
+        else if (hasNodeName(conditionXml, "greatereq"))
+        {
+            return new DialogConditionGreaterOrEquals(
+                                                      getAttributeValueAsReal(conditionXml, "value"));
+        }
+        
+        return NULL;
+    }
+
+    DialogVariable* DialogLoaderImpl::processVariableClasses(DOMElement* variableXml)
+    {
+        if (hasNodeName(variableXml, "dialogvariable"))
+        {
+            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, "name"));
+        }
+        else if (hasNodeName(variableXml, "queststate"))
+        {
+            Ogre::String questId = getAttributeValueAsStdString(variableXml, "quest");
+            Ogre::String prop = getAttributeValueAsStdString(variableXml, "property");
+            return new QuestStateVariable(questId, prop);
+        }
+        else if (hasNodeName(variableXml, "attributecheck"))
+        {
+            CeGuiString attr = getAttributeValueAsString(variableXml, "attribute");
+            CeGuiString target = getAttributeValueAsString(variableXml, "target");
+            int modifier = 0;
+            if (hasAttribute(variableXml, "modifier"))
+            {
+                modifier = getAttributeValueAsInteger(variableXml, "modifier");
+            }
+            return new EigenschaftsProbeVariable(attr, modifier, target);
+        }
+        else if (hasNodeName(variableXml, "talentcheck"))
+        {
+            CeGuiString attr = getAttributeValueAsString(variableXml, "talent");
+            CeGuiString target = getAttributeValueAsString(variableXml, "target");
+            int modifier = 0;
+            if (hasAttribute(variableXml, "modifier"))
+            {
+                modifier = getAttributeValueAsInteger(variableXml, "modifier");
+            }
+            return new TalentProbeVariable(attr, modifier, target);
+        }
+        else if (hasNodeName(variableXml, "random"))
+        {
+            int maximum = getAttributeValueAsInteger(variableXml, "maximum");
+            return new RandomVariable(maximum);
+        }
+        
+        return NULL;
+    }
+
+
+    DialogImplication* DialogLoaderImpl::processImplicationClasses(DOMNode* implicationXml)
+    {
+        if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
+        {
+            DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
+            
+            if (hasNodeName(implicationElem, "setvariable"))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
+                return new DialogVariableAssignment(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, "incvariable"))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
+                return new DialogVariableIncrease(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, "decvariable"))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
+                return new DialogVariableDecrease(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, "setoptionactive"))
+            {
+                CeGuiString id = getAttributeValueAsString(implicationElem, "id");
+                bool value = getAttributeValueAsBool(implicationElem, "value");
+                return new DialogElementActivation(id, value, true);
+            }
+            else if (hasNodeName(implicationElem, "exit"))
+            {
+                return new DialogExit();
+            }
+            else if (hasNodeName(implicationElem, "changequest"))
+            {
+                Ogre::String questId = getAttributeValueAsStdString(implicationElem, "quest");
+                Ogre::String prop = getAttributeValueAsStdString(implicationElem, "property");
+                CeGuiString newvalue = getAttributeValueAsString(implicationElem, "newvalue");
+                return new QuestPropertyAssignment(questId, prop, newvalue);
+            }
+        }
+        
+        return NULL;
+    }
+
+    void DialogLoaderImpl::processTranslation(DialogElement* element, DOMNode* translationXml)
+    {
+        for (DOMNode* cur = translationXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (hasNodeName(cur, "p"))
+            {
+                element->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+            }
+        }
+    }
+    
+}
+

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2008-12-03 23:12:01 UTC (rev 4629)
+++ rl/trunk/engine/ai/src/Makefile.am	2008-12-04 19:17:08 UTC (rev 4630)
@@ -22,6 +22,7 @@
 	DialogElement.cpp \
 	DialogImplication.cpp \
 	DialogLoader.cpp \
+	DialogLoaderImpl.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \



From blakharaz at mail.berlios.de  Thu Dec  4 20:17:38 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 4 Dec 2008 20:17:38 +0100
Subject: [Dsa-hl-svn] r4631 - rl/trunk/engine/rules/include
Message-ID: <200812041917.mB4JHcDp012348@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-04 20:17:37 +0100 (Thu, 04 Dec 2008)
New Revision: 4631

Modified:
   rl/trunk/engine/rules/include/Slot.h
Log:
Commented the slot classes

Modified: rl/trunk/engine/rules/include/Slot.h
===================================================================
--- rl/trunk/engine/rules/include/Slot.h	2008-12-04 19:17:08 UTC (rev 4630)
+++ rl/trunk/engine/rules/include/Slot.h	2008-12-04 19:17:37 UTC (rev 4631)
@@ -1,92 +1,224 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __SLOT_H__
-#define __SLOT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl {
-
-class Creature;
-class Item;
-
-class _RlRulesExport Slot
-{
-public:
-    Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
-    virtual ~Slot();
-
-    // provides standard behaviour, sets
-    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
-    // subclasses MUST call this method when overriding
-    virtual bool setItem(Item* item);
-    virtual void update(); // this must only be called from creature::doPlaceIntoScene
-    Item* getItem() const;
-    bool isAllowed(const Item* item) const;
-    bool isEmpty() const {return mItem == NULL;}
-    bool canReady(const Item* item) const;
-	bool isReady() { return mItem != NULL && canReady(mItem); }
-    CeGuiString getName() const {return mName;}
-
-protected:
-
-    Creature* mOwner;
-    Item* mItem;
-
-private:
-    CeGuiString mName;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemHeldMask;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemReadyMask;
-};
-
-class BoneSlot : public Slot
-{
-public:
-    BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mBone;
-};
-
-class SubmeshSlot : public Slot
-{
-public:
-    SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-class MaterialSlot : public Slot
-{
-public:
-    MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-} // namespace rl
-
-#endif //__SLOT_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __SLOT_H__
+#define __SLOT_H__
+
+#include "RulesPrerequisites.h"
+
+namespace rl {
+    
+    class Creature;
+    class Item;
+    
+    /**
+     * A class to represent a place where an Item can be attached to a creature
+     *
+     */
+    class _RlRulesExport Slot
+    {
+    public:
+        
+        /**
+         * Creates a slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         */
+        Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
+        virtual ~Slot();
+        
+        /**
+         * Puts an item into the slot, may depend on the actual slot type
+         *
+         * Note: this method provides standard behaviour, sets item-state etc
+         * subclasses MUST call this method when overriding
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * Updates the slot to match the owner's state
+         *
+         * Note: this must only be called from Creature::doPlaceIntoScene
+         */
+        virtual void update();
+        
+        /**
+         * Gets the item in the slot
+         *
+         * @returns the item, NULL if the slot is empty
+         */
+        Item* getItem() const;
+        
+        /**
+         * Check if an item can be held in this slot
+         *
+         * @param item an item
+         * @returns true if the item can be put into this slot, false otherwise
+         */
+        bool isAllowed(const Item* item) const;
+        
+        /** 
+         * Check if the slot is empty
+         *
+         * @returns true if the slot is empty, false otherwise
+         */
+        bool isEmpty() const {return mItem == NULL;}
+        
+        /**
+         * Check if an item is readied in this slot (e.g. trousers in the legs slot) or not (e.g. trousers in the left hand slot)
+         *
+         * @param item an item
+         * @returns true if the item is readied in this slot, false otherwise
+         */
+        bool canReady(const Item* item) const;
+        
+        /**
+         * Check if the slot holds a ready item
+         *
+         */
+        bool isReady() { return mItem != NULL && canReady(mItem); }
+        
+        /**
+         * Get the slot's name
+         *
+         * @returns the name
+         */
+        CeGuiString getName() const {return mName;}
+        
+    protected:
+        
+        Creature* mOwner;
+        Item* mItem;
+        
+    private:
+        CeGuiString mName;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemHeldMask;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemReadyMask;
+    };
+    
+    /**
+     * A slot implemented by a model bone, if objects are put into the slot, their models are attached at the bone
+     */
+    class BoneSlot : public Slot
+    {
+    public:
+        
+        /**
+         * Creates a bone slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param bone the bone name
+         */
+        BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
+        
+        /**
+         * Puts an item into the slot by attaching its mesh to the bone of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mBone;
+    };
+    
+    /**
+     * A slot implemented by a submesh "baked" into the owner mesh. If an item is put into that slot it creates or 
+     * replaces a specified submesh, this is used for armor to be able to animate the armor meshes on an easy way
+     *
+     * Note: the item meshes must have the same skeleton as the owner mesh
+     */
+    class SubmeshSlot : public Slot
+    {
+    public:
+
+        /**
+         * Creates a submesh slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by creating or replacing a submesh in the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+    /**
+     * A slot implemented by changing a material on a specified submesh of the owner mesh. This is used for clothes.
+     */
+    class MaterialSlot : public Slot
+    {
+    public:
+        /**
+         * Creates a material slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by replacing the material in one submesh of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+} // namespace rl
+
+#endif //__SLOT_H__



From blakharaz at mail.berlios.de  Thu Dec  4 20:38:23 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 4 Dec 2008 20:38:23 +0100
Subject: [Dsa-hl-svn] r4632 - rl/trunk/engine/rules/src
Message-ID: <200812041938.mB4JcNa9014934@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-04 20:38:22 +0100 (Thu, 04 Dec 2008)
New Revision: 4632

Modified:
   rl/trunk/engine/rules/src/Creature.cpp
Log:
Commented the slot classes

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2008-12-04 19:17:37 UTC (rev 4631)
+++ rl/trunk/engine/rules/src/Creature.cpp	2008-12-04 19:38:22 UTC (rev 4632)
@@ -880,6 +880,15 @@
 		
 		int bonus = (kk - tpkk.first) / tpkk.second;
 		rval += bonus;
+        
+        if (damage == DMG_HALF)
+        {
+            rval = (rval + 1) / 2;
+        }
+        else if (damage == DMG_DOUBLE)
+        {
+            rval *= 2; ///@TODO check if correct
+        }
 
 		return rval;
 	}



From blakharaz at mail.berlios.de  Thu Dec  4 22:34:51 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 4 Dec 2008 22:34:51 +0100
Subject: [Dsa-hl-svn] r4633 - in rl/trunk/engine: ai/include ai/src core/src
Message-ID: <200812042134.mB4LYpa9027920@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-04 22:34:49 +0100 (Thu, 04 Dec 2008)
New Revision: 4633

Modified:
   rl/trunk/engine/ai/include/DialogImplication.h
   rl/trunk/engine/ai/src/DialogImplication.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/core/src/PlayAnimationJob.cpp
Log:
Added DialogImplication to start a fight from within a dialog

Modified: rl/trunk/engine/ai/include/DialogImplication.h
===================================================================
--- rl/trunk/engine/ai/include/DialogImplication.h	2008-12-04 19:38:22 UTC (rev 4632)
+++ rl/trunk/engine/ai/include/DialogImplication.h	2008-12-04 21:34:49 UTC (rev 4633)
@@ -1,96 +1,103 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DialogImplication_H__
-#define __DialogImplication_H__
-
-#include "AiPrerequisites.h"
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport DialogImplication
-    {
-    public:
-        DialogImplication();
-        virtual ~DialogImplication();
-        
-        virtual void apply(Dialog* dialog) = 0;
-    };
-
-    class DialogVariableAssignment : public DialogImplication
-    {
-    public:
-        DialogVariableAssignment(const Ogre::String& variableName, 
-                                 const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-
-    protected:
-        Ogre::String mVariableName; 
-        CeGuiString mValue;
-    };
-
-    class DialogVariableIncrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableIncrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogVariableDecrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableDecrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogElementActivation : public DialogImplication
-    {
-    public:
-        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
-        virtual void apply(Dialog* dialog);
-    private:
-        CeGuiString mElementId;
-        bool mValue;
-        bool mIsOption;
-    };
-
-	class DialogExit : public DialogImplication
-	{
-	public:
-		virtual void apply(Dialog* dialog);
-	};
-
-    class QuestPropertyAssignment : public DialogImplication
-    {
-    public:
-        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
-        virtual void apply(Dialog* dialog);
-
-    private:
-        Ogre::String mQuestId;
-        Ogre::String mProperty;
-        CeGuiString mNewValue;
-    };
-}
-
-#endif //__DialogImplication_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String& variableName, 
+                                 const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+
+    protected:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+
+    class DialogVariableIncrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableIncrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogVariableDecrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableDecrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogElementActivation : public DialogImplication
+    {
+    public:
+        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
+        virtual void apply(Dialog* dialog);
+    private:
+        CeGuiString mElementId;
+        bool mValue;
+        bool mIsOption;
+    };
+
+	class DialogExit : public DialogImplication
+	{
+	public:
+		virtual void apply(Dialog* dialog);
+	};
+
+    class QuestPropertyAssignment : public DialogImplication
+    {
+    public:
+        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mQuestId;
+        Ogre::String mProperty;
+        CeGuiString mNewValue;
+    };
+    
+    class CombatStart : public DialogImplication
+    {
+    public:
+        CombatStart();
+        virtual void apply(Dialog* dialog);
+    };
+}
+
+#endif //__DialogImplication_H__

Modified: rl/trunk/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogImplication.cpp	2008-12-04 19:38:22 UTC (rev 4632)
+++ rl/trunk/engine/ai/src/DialogImplication.cpp	2008-12-04 21:34:49 UTC (rev 4633)
@@ -1,137 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"
-
-#include "DialogImplication.h"
-
-#include "Dialog.h"
-#include "RulesSubsystem.h"
-#include "Property.h"
-#include "QuestBook.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    DialogImplication::DialogImplication()
-    {
-    }
-
-    DialogImplication::~DialogImplication()
-    {
-    }
-
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
-                                                       const CeGuiString& value)
-        : mVariableName(variableName), mValue(value)
-    {
-    }
-
-    void DialogVariableAssignment::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        prop.getFromString(mValue);
-        dialog->setProperty(mVariableName, prop);
-    }
-
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableIncrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableDecrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
-                                                     bool value,
-                                                     bool isOption)
-        : mElementId(id), mValue(value), mIsOption(isOption)
-    {
-    }
-
-    void DialogElementActivation::apply(Dialog* dialog)
-    {
-        Property prop;
-        if(mIsOption)
-        {
-            dialog->setProperty("option" + mElementId + "isActive", mValue);
-        }
-        else
-        {
-            dialog->setProperty("response" + mElementId + "isActive", mValue);
-        }
-    }
-
-	void DialogExit::apply(rl::Dialog *dialog)
-	{
-		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
-	}
-
-    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
-        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
-    {
-    }
-
-    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
-    {
-        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
-        quest->setPropertyAsString(mProperty, mNewValue);
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "DialogImplication.h"
+
+#include "Combat.h"
+#include "CombatManager.h"
+#include "Dialog.h"
+#include "Property.h"
+#include "QuestBook.h"
+#include "RulesSubsystem.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
+                                                       const CeGuiString& value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog->setProperty(mVariableName, prop);
+    }
+
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableIncrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableDecrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
+                                                     bool value,
+                                                     bool isOption)
+        : mElementId(id), mValue(value), mIsOption(isOption)
+    {
+    }
+
+    void DialogElementActivation::apply(Dialog* dialog)
+    {
+        Property prop;
+        if(mIsOption)
+        {
+            dialog->setProperty("option" + mElementId + "isActive", mValue);
+        }
+        else
+        {
+            dialog->setProperty("response" + mElementId + "isActive", mValue);
+        }
+    }
+
+	void DialogExit::apply(rl::Dialog *dialog)
+	{
+		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
+	}
+
+    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
+        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
+    {
+    }
+
+    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
+    {
+        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
+        quest->setPropertyAsString(mProperty, mNewValue);
+    }
+    
+    CombatStart::CombatStart()
+    {
+    }
+    
+    void CombatStart::apply(Dialog* dialog)
+    {
+        Combat* combat = CombatManager::getSingleton().startCombat();
+        std::vector<Creature*> allies = dialog->getPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = allies.begin(); it != allies.end(); ++it)
+        {
+            combat->addAlly(*it);            
+        }
+        std::vector<Creature*> enemies = dialog->getNonPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = enemies.begin(); it != enemies.end(); ++it)
+        {
+            combat->addOpponent(*it);
+        }
+        combat->start();
+    }
+
+}

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2008-12-04 19:38:22 UTC (rev 4632)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2008-12-04 21:34:49 UTC (rev 4633)
@@ -717,6 +717,10 @@
                 CeGuiString newvalue = getAttributeValueAsString(implicationElem, "newvalue");
                 return new QuestPropertyAssignment(questId, prop, newvalue);
             }
+            else if (hasNodeName(implicationElem, "startcombat"))
+            {
+                return new CombatStart();
+            }
         }
         
         return NULL;

Modified: rl/trunk/engine/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/trunk/engine/core/src/PlayAnimationJob.cpp	2008-12-04 19:38:22 UTC (rev 4632)
+++ rl/trunk/engine/core/src/PlayAnimationJob.cpp	2008-12-04 21:34:49 UTC (rev 4633)
@@ -1,114 +1,122 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "PlayAnimationJob.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, Ogre::Real duration,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mDuration(duration),
-          mReplaceAllAnims(replaceAllAnims),
-          mLoops(-1),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, int loops,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mLoops(loops),
-          mDuration(-1),
-          mReplaceAllAnims(replaceAllAnims),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::~PlayAnimationJob()
-    {
-    }
-
-    void PlayAnimationJob::setHoldOnEnd(bool hold)
-    {
-        mHoldOnEnd = hold;
-    }
-
-    bool PlayAnimationJob::execute(Ogre::Real time)
-    {
-        if (mActor && !mAnimationRunning)
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(mActor->getControlledObject());
-
-            if (mReplaceAllAnims)
-            {
-                mo->stopAllAnimationsExcept(mAnimName);
-            }                
-
-            if (mDuration > 0)
-            {
-                mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
-                mTimeToGo = mDuration;
-                mAnimationRunning = true;
-            }
-            else
-            {
-                MeshAnimation* animation = mo->startAnimation(mAnimName, 1.0f, mLoops);
-                mTimeToGo = animation->getLength() * (float)mLoops;
-                mAnimationRunning = true;
-            }
-        }
-
-        mTimeToGo -= time;
-
-        if (mTimeToGo <= 0.0f)
-        {
-            if (mAnimationRunning && mAnimation) 
-            {
-                mAnimationRunning = false;
-                if (mHoldOnEnd) 
-                {
-                    mAnimation->pause();
-                }
-                else
-                {
-                    mAnimation->stop();
-                    delete mAnimation;
-                }
-                mAnimation = NULL;
-            }
-            return true;
-        }
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "PlayAnimationJob.h"
+#include "MeshAnimation.h"
+#include "MeshObject.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, Ogre::Real duration,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mDuration(duration),
+          mReplaceAllAnims(replaceAllAnims),
+          mLoops(-1),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, int loops,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mLoops(loops),
+          mDuration(-1),
+          mReplaceAllAnims(replaceAllAnims),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::~PlayAnimationJob()
+    {
+    }
+
+    void PlayAnimationJob::setHoldOnEnd(bool hold)
+    {
+        mHoldOnEnd = hold;
+    }
+
+    bool PlayAnimationJob::execute(Ogre::Real time)
+    {
+        if (mActor && !mAnimationRunning)
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(mActor->getControlledObject());
+
+            if (mReplaceAllAnims)
+            {
+                mo->stopAllAnimationsExcept(mAnimName);
+            }                
+            
+            if (mo->hasAnimation(mAnimName))
+            {
+                if (mDuration > 0)
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation->getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
+            }
+            else 
+            {
+                mAnimation = NULL;
+                mTimeToGo = 0;
+            }
+        }
+
+        mTimeToGo -= time;
+
+        if (mTimeToGo <= 0.0f)
+        {
+            if (mAnimationRunning && mAnimation) 
+            {
+                mAnimationRunning = false;
+                if (mHoldOnEnd) 
+                {
+                    mAnimation->pause();
+                }
+                else
+                {
+                    mAnimation->stop();
+                    delete mAnimation;
+                }
+                mAnimation = NULL;
+            }
+            return true;
+        }
+
+        return false;
+    }
+}



From blakharaz at mail.berlios.de  Thu Dec  4 22:35:19 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 4 Dec 2008 22:35:19 +0100
Subject: [Dsa-hl-svn] r4634 - in modules/regressiontest: dialogs dsa scripts
Message-ID: <200812042135.mB4LZJbi028092@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-04 22:35:17 +0100 (Thu, 04 Dec 2008)
New Revision: 4634

Added:
   modules/regressiontest/dialogs/combatdialog.dialog
Removed:
   modules/regressiontest/dialogs/testdialog.aiml
Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/CombatTest.rb
Log:
Test starting a fight from within a dialog

Added: modules/regressiontest/dialogs/combatdialog.dialog
===================================================================
--- modules/regressiontest/dialogs/combatdialog.dialog	2008-12-04 21:34:49 UTC (rev 4633)
+++ modules/regressiontest/dialogs/combatdialog.dialog	2008-12-04 21:35:17 UTC (rev 4634)
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<dialog name="combatdialog">
+	<start>
+    	<response id="1">
+			<p>Tach. Auf's Maul?</p>
+			<option id="2">
+				Klar, los geht's.
+				<response id="21"><startcombat/></response>
+			</option>
+			<option id="3">
+				Och n?, heute nicht.
+				<response id="31"><exit/></response>
+			</option>
+		</response>
+	</start>
+</dialog>
\ No newline at end of file

Deleted: modules/regressiontest/dialogs/testdialog.aiml
===================================================================
--- modules/regressiontest/dialogs/testdialog.aiml	2008-12-04 21:34:49 UTC (rev 4633)
+++ modules/regressiontest/dialogs/testdialog.aiml	2008-12-04 21:35:17 UTC (rev 4634)
@@ -1,96 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- !DOCTYPE aiml SYSTEM "includes.dtd" -->
-
-<aiml  version="1.0.1"
-            xmlns="http://alicebot.org/2001/AIML"
-			xmlns:rldialog="http://team-pantheon.de/projekt/rl/dialog">
-
-
-	<category>
-		<pattern>1</pattern>
-		<template>
-			<gossip rldialog:type="response">
-				<li>Du solltest mir nur drohen, wenn Geheimnis 1 ist. Geheimnis ist momentan <get type="default" name="geheimnis"/></li>
-			</gossip>
-			<gossip rldialog:type="option">
-				<li>Abstraktionstext
-					<gossip rldialog:type="selection">
-						<li rldialog:patternRef ="2">Selectiontext; nach dem Auswahlklick angezeigt. Jetzt gehts zu Pattern 2.</li>
-					</gossip>
-				</li>
-				
-				<li>[Dem NSC drohen]
-					<gossip rldialog:type="selection">
-						<condition type="default" name="geheimnis">
-							<li value="" rldialog:patternRef ="3">Ich drohe dir, kenne aber dein Geheimnis nicht!</li>
-							<li value="1" rldialog:patternRef ="5">Ich drohe dir, und kenne dein schreckliches Geheimnis!</li>
-						</condition>
-					</gossip>
-				</li>
-
-				<li rldialog:patternRef ="4">Wie lautet das Geheimnis?</li>
-				<li rldialog:patternRef ="EXIT">Ende</li>
-			</gossip>
-		</template>
-	</category>
-
-	<category>
-		<pattern>2</pattern>
-		<template>
-			<gossip rldialog:type="response">
-				<li>Dies ist Pattern 2</li>
-			</gossip>
-			<gossip rldialog:type="option">
-				<li rldialog:patternRef ="1">Zu Pattern 1</li>
-			</gossip>
-		</template>
-	</category>
-
-	
-	<category>
-		<pattern>3</pattern>
-		<template>
-			<gossip rldialog:type="response">
-				<li>Dann mu?t du sterben! bzw. den Dialog verlassen!</li>
-			</gossip>
-			<gossip rldialog:type="option">
-				<li rldialog:patternRef ="EXIT">ok.. schade</li>
-			</gossip>
-		</template>
-	</category>
-
-	<category>
-		<pattern>4</pattern>
-		<template>
-			<gossip rldialog:type="response">
-				<li>Mein Geheimnis ist: Ich kann keine Geheimnisse behalten! *schluchz*</li>
-			</gossip>
-			<gossip rldialog:type="option">
-				<li rldialog:patternRef ="1"><set type="default" name="geheimnis" value="1"/>Har har har.. na warte Freundchen.</li>
-			</gossip>
-		</template>
-	</category>
-
-
-	
-	<category>
-		<pattern>5</pattern>
-		<template>
-			<gossip rldialog:type="response">
-				<li>Oh nein! Ich gebe auf! Du darfst ins Men? zur?ck!</li>
-			</gossip>
-			<gossip rldialog:type="option">
-				<li rldialog:patternRef ="1">Tja. Informiertheit ist alles. Gut, dass ich das Tutorial zu dem Thema gelesen habe. Danke, Steele.</li>
-			</gossip>
-		</template>
-	</category>
-
-<!-- ================Standardoptionen ================ -->
-	<category>
-	<pattern>EXIT</pattern> 
-		<template>
-			<system cmd="exit"/>
-		</template>
-	</category>	
-
-</aiml>
\ No newline at end of file

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-12-04 21:34:49 UTC (rev 4633)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-12-04 21:35:17 UTC (rev 4634)
@@ -94,6 +94,10 @@
 			<property name="laufen" type="REAL" data="0.5"/>
 			<property name="rennen" type="REAL" data="0.4"/>
 		</property>
+		<property name="kampftechniken" type="MAP">
+			<property name="Schwerter" type="INTPAIR" data="1,1"/>
+		</property>
+
     </gameobjectclass>
 
     <gameobjectclass classid="TestPersonCapsule" baseclass="NPC">

Modified: modules/regressiontest/scripts/CombatTest.rb
===================================================================
--- modules/regressiontest/scripts/CombatTest.rb	2008-12-04 21:34:49 UTC (rev 4633)
+++ modules/regressiontest/scripts/CombatTest.rb	2008-12-04 21:35:17 UTC (rev 4634)
@@ -4,12 +4,30 @@
     def execute()
 		MapLoader.new().loadMap("combatarena.rlmap");
 		
+		insertWolf();
+		insertTestDialog();
+	end
+	
+	def insertWolf()
 		wolf = $GOM.getGameObject(100);
+		
 		wolf.setAlignment(Creature::ALIGNMENT_ENEMY);
+		
 		wolf.modifyAu(1000)
 
+		
 		schnauze = $GOM.createGameObject("Wolfsschnauze");
+		
 		wolf.getInventory().ready(schnauze, "Snout");
 
 	end
+	
+	def insertTestDialog()
+		npc = $GOM.createGameObject("TestPerson");
+		npc.setProperty("dialog", "combatdialog");
+		npc.getInventory().ready($GOM.createGameObject("Kurzschwert"), "Right Hand");
+
+		npc.setPosition(getCenter());
+		npc.placeIntoScene();
+	end
 end
\ No newline at end of file



From timm at mail.berlios.de  Fri Dec  5 19:16:49 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 5 Dec 2008 19:16:49 +0100
Subject: [Dsa-hl-svn] r4635 - in rl/branches/persistence: ai ai/include
	ai/src common common/include common/src core core/include
	core/src rules/include rules/src ui/include ui/src
Message-ID: <200812051816.mB5IGn4G021964@sheep.berlios.de>

Author: timm
Date: 2008-12-05 19:15:18 +0100 (Fri, 05 Dec 2008)
New Revision: 4635

Added:
   rl/branches/persistence/ai/CMakeLists.txt
   rl/branches/persistence/ai/include/DialogLoaderImpl.h
   rl/branches/persistence/ai/src/DialogLoaderImpl.cpp
   rl/branches/persistence/common/CMakeLists.txt
   rl/branches/persistence/core/CMakeLists.txt
Modified:
   rl/branches/persistence/ai/RlAI2005.vcproj
   rl/branches/persistence/ai/include/DialogImplication.h
   rl/branches/persistence/ai/include/DialogLoader.h
   rl/branches/persistence/ai/include/Makefile.am
   rl/branches/persistence/ai/src/DialogImplication.cpp
   rl/branches/persistence/ai/src/DialogLoader.cpp
   rl/branches/persistence/ai/src/Makefile.am
   rl/branches/persistence/common/include/WriteableDataStream.h
   rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
   rl/branches/persistence/common/src/WriteableDataStream.cpp
   rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence/core/include/ConfigurationManager.h
   rl/branches/persistence/core/include/SaveAbleFactory.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/include/SaveGameFile.h
   rl/branches/persistence/core/src/ConfigurationManager.cpp
   rl/branches/persistence/core/src/ContentLoader.cpp
   rl/branches/persistence/core/src/CoreSubsystem.cpp
   rl/branches/persistence/core/src/PlayAnimationJob.cpp
   rl/branches/persistence/core/src/SaveAbleFactory.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/core/src/SaveGameFile.cpp
   rl/branches/persistence/core/src/SaveGameFileReader.cpp
   rl/branches/persistence/core/src/SaveGameFileWriter.cpp
   rl/branches/persistence/core/src/SaveGameManager.cpp
   rl/branches/persistence/rules/include/ApplyDamageJob.h
   rl/branches/persistence/rules/include/Combat.h
   rl/branches/persistence/rules/include/Combatant.h
   rl/branches/persistence/rules/include/Creature.h
   rl/branches/persistence/rules/include/QuestBook.h
   rl/branches/persistence/rules/include/Slot.h
   rl/branches/persistence/rules/include/Weapon.h
   rl/branches/persistence/rules/src/ApplyDamageJob.cpp
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/rules/src/Combatant.cpp
   rl/branches/persistence/rules/src/Creature.cpp
   rl/branches/persistence/rules/src/QuestBook.cpp
   rl/branches/persistence/rules/src/Weapon.cpp
   rl/branches/persistence/ui/include/WindowManager.h
   rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
   rl/branches/persistence/ui/src/WindowManager.cpp
Log:
- completing write able data stream
- rewrite of save game file
- added new methodes to save able manager
- changes on save able factory
- started with writing features of save able serializer
- WIP save game window
- merged from trunk

Copied: rl/branches/persistence/ai/CMakeLists.txt (from rev 4634, rl/trunk/engine/ai/CMakeLists.txt)

Modified: rl/branches/persistence/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/persistence/ai/RlAI2005.vcproj	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/RlAI2005.vcproj	2008-12-05 18:15:18 UTC (rev 4635)
@@ -367,6 +367,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\DialogLoaderImpl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\DialogManager.cpp"
 				>
 			</File>
@@ -541,6 +545,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\DialogLoaderImpl.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\DialogManager.h"
 				>
 			</File>

Modified: rl/branches/persistence/ai/include/DialogImplication.h
===================================================================
--- rl/branches/persistence/ai/include/DialogImplication.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/DialogImplication.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,96 +1,103 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DialogImplication_H__
-#define __DialogImplication_H__
-
-#include "AiPrerequisites.h"
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport DialogImplication
-    {
-    public:
-        DialogImplication();
-        virtual ~DialogImplication();
-        
-        virtual void apply(Dialog* dialog) = 0;
-    };
-
-    class DialogVariableAssignment : public DialogImplication
-    {
-    public:
-        DialogVariableAssignment(const Ogre::String& variableName, 
-                                 const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-
-    protected:
-        Ogre::String mVariableName; 
-        CeGuiString mValue;
-    };
-
-    class DialogVariableIncrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableIncrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogVariableDecrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableDecrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogElementActivation : public DialogImplication
-    {
-    public:
-        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
-        virtual void apply(Dialog* dialog);
-    private:
-        CeGuiString mElementId;
-        bool mValue;
-        bool mIsOption;
-    };
-
-	class DialogExit : public DialogImplication
-	{
-	public:
-		virtual void apply(Dialog* dialog);
-	};
-
-    class QuestPropertyAssignment : public DialogImplication
-    {
-    public:
-        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
-        virtual void apply(Dialog* dialog);
-
-    private:
-        Ogre::String mQuestId;
-        Ogre::String mProperty;
-        CeGuiString mNewValue;
-    };
-}
-
-#endif //__DialogImplication_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String& variableName, 
+                                 const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+
+    protected:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+
+    class DialogVariableIncrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableIncrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogVariableDecrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableDecrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogElementActivation : public DialogImplication
+    {
+    public:
+        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
+        virtual void apply(Dialog* dialog);
+    private:
+        CeGuiString mElementId;
+        bool mValue;
+        bool mIsOption;
+    };
+
+	class DialogExit : public DialogImplication
+	{
+	public:
+		virtual void apply(Dialog* dialog);
+	};
+
+    class QuestPropertyAssignment : public DialogImplication
+    {
+    public:
+        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mQuestId;
+        Ogre::String mProperty;
+        CeGuiString mNewValue;
+    };
+    
+    class CombatStart : public DialogImplication
+    {
+    public:
+        CombatStart();
+        virtual void apply(Dialog* dialog);
+    };
+}
+
+#endif //__DialogImplication_H__

Modified: rl/branches/persistence/ai/include/DialogLoader.h
===================================================================
--- rl/branches/persistence/ai/include/DialogLoader.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/DialogLoader.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -18,24 +18,13 @@
 
 #include "AiPrerequisites.h"
 
-#include "Properties.h"
-#include "XmlProcessor.h"
- 
 namespace rl 
 {
 	class Creature;
     class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-	class Property;
+    class DialogLoaderImpl;
 
-
-	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	class DialogLoader : public Ogre::ScriptLoader
 	{
 	public:
 		DialogLoader();
@@ -48,48 +37,9 @@
 		Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
 
 	private: 
-		class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString& id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString& id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
-            void setProperty(const CeGuiString& key, const Property& value);
-
-        private:
-            std::map<CeGuiString, DialogOption*> mOptionCache;
-            std::map<CeGuiString, DialogResponse*> mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-		
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
-
         Ogre::StringVector mScriptPatterns;
-        std::map<Ogre::String, DialogPrototype*> mDialogs;
-
-	};
+        DialogLoaderImpl* mLoaderImplementation;
+    };
 }
 
 #endif //__DialogLoader_H__

Copied: rl/branches/persistence/ai/include/DialogLoaderImpl.h (from rev 4634, rl/trunk/engine/ai/include/DialogLoaderImpl.h)

Modified: rl/branches/persistence/ai/include/Makefile.am
===================================================================
--- rl/branches/persistence/ai/include/Makefile.am	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/Makefile.am	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,6 +20,7 @@
 	DialogElementSelection.h \
 	DialogImplication.h \
 	DialogLoader.h \
+	DialogLoaderImpl.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/branches/persistence/ai/src/DialogImplication.cpp
===================================================================
--- rl/branches/persistence/ai/src/DialogImplication.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/DialogImplication.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,137 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"
-
-#include "DialogImplication.h"
-
-#include "Dialog.h"
-#include "RulesSubsystem.h"
-#include "Property.h"
-#include "QuestBook.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    DialogImplication::DialogImplication()
-    {
-    }
-
-    DialogImplication::~DialogImplication()
-    {
-    }
-
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
-                                                       const CeGuiString& value)
-        : mVariableName(variableName), mValue(value)
-    {
-    }
-
-    void DialogVariableAssignment::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        prop.getFromString(mValue);
-        dialog->setProperty(mVariableName, prop);
-    }
-
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableIncrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableDecrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
-                                                     bool value,
-                                                     bool isOption)
-        : mElementId(id), mValue(value), mIsOption(isOption)
-    {
-    }
-
-    void DialogElementActivation::apply(Dialog* dialog)
-    {
-        Property prop;
-        if(mIsOption)
-        {
-            dialog->setProperty("option" + mElementId + "isActive", mValue);
-        }
-        else
-        {
-            dialog->setProperty("response" + mElementId + "isActive", mValue);
-        }
-    }
-
-	void DialogExit::apply(rl::Dialog *dialog)
-	{
-		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
-	}
-
-    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
-        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
-    {
-    }
-
-    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
-    {
-        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
-        quest->setPropertyAsString(mProperty, mNewValue);
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "DialogImplication.h"
+
+#include "Combat.h"
+#include "CombatManager.h"
+#include "Dialog.h"
+#include "Property.h"
+#include "QuestBook.h"
+#include "RulesSubsystem.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
+                                                       const CeGuiString& value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog->setProperty(mVariableName, prop);
+    }
+
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableIncrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableDecrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
+                                                     bool value,
+                                                     bool isOption)
+        : mElementId(id), mValue(value), mIsOption(isOption)
+    {
+    }
+
+    void DialogElementActivation::apply(Dialog* dialog)
+    {
+        Property prop;
+        if(mIsOption)
+        {
+            dialog->setProperty("option" + mElementId + "isActive", mValue);
+        }
+        else
+        {
+            dialog->setProperty("response" + mElementId + "isActive", mValue);
+        }
+    }
+
+	void DialogExit::apply(rl::Dialog *dialog)
+	{
+		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
+	}
+
+    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
+        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
+    {
+    }
+
+    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
+    {
+        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
+        quest->setPropertyAsString(mProperty, mNewValue);
+    }
+    
+    CombatStart::CombatStart()
+    {
+    }
+    
+    void CombatStart::apply(Dialog* dialog)
+    {
+        Combat* combat = CombatManager::getSingleton().startCombat();
+        std::vector<Creature*> allies = dialog->getPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = allies.begin(); it != allies.end(); ++it)
+        {
+            combat->addAlly(*it);            
+        }
+        std::vector<Creature*> enemies = dialog->getNonPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = enemies.begin(); it != enemies.end(); ++it)
+        {
+            combat->addOpponent(*it);
+        }
+        combat->start();
+    }
+
+}

Modified: rl/branches/persistence/ai/src/DialogLoader.cpp
===================================================================
--- rl/branches/persistence/ai/src/DialogLoader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/DialogLoader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,57 +1,38 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #include "stdinc.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "DialogLoader.h"
+#include "DialogLoaderImpl.h"
 
-#include "ConfigurationManager.h"
-#include "Dialog.h"
-#include "DialogCondition.h"
-#include "DialogElement.h"
-#include "DialogImplication.h"
-#include "DialogOption.h"
-#include "DialogParagraph.h"
-#include "DialogResponse.h"
-#include "DialogVariable.h"
-#include "XmlPropertyReader.h"
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
 	DialogLoader::DialogLoader()
-	      : XmlProcessor(), ScriptLoader()
+	      : ScriptLoader()
     {
+        mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back("*.dialog");
   	}
 	
     DialogLoader::~DialogLoader()
     {
-		std::map<Ogre::String, DialogPrototype*>::iterator itr = mDialogs.begin();
-        std::map<Ogre::String, DialogPrototype*>::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
-        {
-			DialogPrototype* p = itr->second;
-			delete p;
-		}
-        mDialogs.clear();
+        delete mLoaderImplementation;
 	}
  
     const StringVector& DialogLoader::getScriptPatterns() const
@@ -63,692 +44,16 @@
     {
         return 1000;
     }
-
-    void DialogLoader::parseScript(DataStreamPtr& stream, const Ogre::String& groupName)
+    
+    void DialogLoader::parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
-
-            for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes->item(i);
-                processDialog(static_cast<DOMElement*>(cur));
-            }
-        }
-
-        shutdownXml();
+        mLoaderImplementation->parseDialog(stream, groupName);
     }
-	
-	Dialog* DialogLoader::createDialog(const String& name, const std::vector<Creature*>& pcs, 
-		const std::vector<Creature*>& npcs) const
-	{
-		std::map<Ogre::String, DialogPrototype*>::const_iterator it =
-			mDialogs.find(name);
-			
-		if (it == mDialogs.end())
-		{
-			return NULL;
-		}
-		
-		return it->second->createDialog(pcs, npcs);
-	}
-	
-    void DialogLoader::processDialog(DOMElement* dialogElem)
+    
+    Dialog* DialogLoader::createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const
     {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, "option", dialogPrototype);
-        processElementNodes(dialogElem, "switchoption", dialogPrototype);
-        processElementNodes(dialogElem, "response", dialogPrototype);
-        processElementNodes(dialogElem, "switchresponse", dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
-        {
-            if (hasNodeName(curChild, "variable"))
-            {
-                createDialogVariable(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "option"))
-            {
-                processOption(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchoption"))
-            {
-                processSwitchOption(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "response"))
-            {
-                processResponse(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchresponse"))
-            {
-                processSwitchResponse(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "start"))
-            {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild->getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype->setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
+        return mLoaderImplementation->createDialog(name, pcs, npcs);
     }
 
-    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml->getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i < dialogElemNodes->getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast<DOMElement*>(dialogElemNodes->item(i));
-            if (!hasAttribute(dialogElemXml, "id"))
-            {
-                Throw(WrongFormatException, "option/switchoption/response/switchresponse node without id found");
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
-            CeGuiString text = getValueAsString(dialogElemXml);
+}
 
-            if (hasNodeName(dialogElemXml, "switchoption"))
-            {
-                DialogOption* option = new DialogSelection<DialogOption>(id);
-                option->setLabel(text);
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "option"))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, "autoSelect");
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, "label"))
-                {
-                    option->setLabel(getAttributeValueAsString(dialogElemXml, "label"));
-                }
-                else
-                {
-                    option->setLabel(text);
-                }
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "response"))
-            {
-                dialogPrototype->addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, "switchresponse"))
-            {
-                dialogPrototype->addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, "response"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "gotoresponse"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchresponse"))
-        {
-            response = processSwitchResponse(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, "id");
-
-        DialogResponse* response = dialogPrototype->getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response->addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response->addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, "p"))
-                {
-                    response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, "gotoresponse"))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast<DOMElement*>(cur), "id");
-                    response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response->addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
-        DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                response->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response->addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, "option"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "optionref"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchoption"))
-        {
-            option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, "id");
-
-        DialogOption* option = dialogPrototype->getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option->setResponse(response);
-                }
-                else if (hasNodeName(cur, "if"))
-                {
-                    option->setPrecondition(processIf(static_cast<DOMElement*>(cur)));
-                }
-                else if (hasNodeName(cur, "p"))
-                {
-                    option->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, "label");
-                        if(!label.empty())
-                        {
-                            option->setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option->addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, "label");
-            if(!label.empty())
-            {
-                option->setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
-        DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                option->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option->addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, "t"))
-            {
-                DOMElement* translation = static_cast<DOMElement*>(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, "language") == 
-                    ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, "label");
-                    if(!label.empty())
-                    {
-                        option->setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype->setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast<DOMElement*>(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond->setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = "";
-        if (hasAttribute(paragraphXml, "voicefile"))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, "voicefile");
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast<DOMElement*>(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    DialogLoader::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogLoader::DialogPrototype::~DialogPrototype()
-    {
-        std::map<CeGuiString, DialogOption*>::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it->second != NULL )
-                delete it->second;
-
-        std::map<CeGuiString, DialogResponse*>::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1->second != NULL )
-                delete it1->second;
-    }
-
-    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option->getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate option/switchoption ID "+ option->getId()).c_str());
-        }
-        mOptionCache[option->getId()] = option;
-    }
-
-    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogOption*>::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response->getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate Response/switchResponse ID "+ response->getId()).c_str());
-        }
-        mResponseCache[response->getId()] = response;
-    }
-
-    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogResponse*>::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog->setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog->setProperty(it->first, it->second);
-        }
-
-        return dialog;
-    }
-
-    void DialogLoader::DialogPrototype::setProperty(const CeGuiString& key, const Property& value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-
-    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, "equals"))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "inrange"))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, "from"),
-                getAttributeValueAsReal(conditionXml, "to"));
-        }
-        else if (hasNodeName(conditionXml, "lower"))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "lowereq"))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greater"))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greatereq"))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, "dialogvariable"))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, "name"));
-        }
-        else if (hasNodeName(variableXml, "queststate"))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, "quest");
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, "property");
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, "attributecheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "attribute");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, "talentcheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "talent");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-		else if (hasNodeName(variableXml, "random"))
-		{
-			int maximum = getAttributeValueAsInteger(variableXml, "maximum");
-			return new RandomVariable(maximum);
-		}
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
-
-            if (hasNodeName(implicationElem, "setvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "incvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "decvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "setoptionactive"))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, "id");
-                bool value = getAttributeValueAsBool(implicationElem, "value");
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, "exit"))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, "changequest"))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, "quest");
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, "property");
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, "newvalue");
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (hasNodeName(cur, "p"))
-            {
-                element->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-            }
-        }
-    }
-
-}
\ No newline at end of file

Copied: rl/branches/persistence/ai/src/DialogLoaderImpl.cpp (from rev 4634, rl/trunk/engine/ai/src/DialogLoaderImpl.cpp)

Modified: rl/branches/persistence/ai/src/Makefile.am
===================================================================
--- rl/branches/persistence/ai/src/Makefile.am	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/Makefile.am	2008-12-05 18:15:18 UTC (rev 4635)
@@ -22,6 +22,7 @@
 	DialogElement.cpp \
 	DialogImplication.cpp \
 	DialogLoader.cpp \
+	DialogLoaderImpl.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \

Copied: rl/branches/persistence/common/CMakeLists.txt (from rev 4634, rl/trunk/engine/common/CMakeLists.txt)

Modified: rl/branches/persistence/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -14,6 +14,9 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
+#ifndef _H_WriteableDataStream
+#define _H_WriteableDataStream
+
 #include "CommonPrerequisites.h"
 
 #include <iostream>
@@ -23,6 +26,8 @@
     class _RlCommonExport WriteableDataStream : public Ogre::DataStream
     {
     public:
+		WriteableDataStream() : Ogre::DataStream() {}
+		WriteableDataStream(const Ogre::String &name) : Ogre::DataStream(name) {}
         virtual void write(void* buf, size_t count) = 0;
         virtual void flush() = 0;
     };
@@ -71,4 +76,7 @@
     };
 
     typedef Ogre::SharedPtr<WriteableFileStreamDataStream> WriteableFileStreamDataStreamPtr;
-}
\ No newline at end of file
+}
+
+#endif
+

Modified: rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,7 +20,7 @@
 
 namespace rl
 {
-    class WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
+    class _RlCommonExport WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
     {
     public:
         WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);

Modified: rl/branches/persistence/common/src/WriteableDataStream.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStream.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/src/WriteableDataStream.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -24,7 +24,7 @@
 namespace rl
 {
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(std::fstream* s, 
-            bool freeOnClose)
+		bool freeOnClose) : WriteableDataStream(), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mpStream->seekg(0, std::ios_base::end);
         mSize = mpStream->tellg();
@@ -33,7 +33,7 @@
 
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(const Ogre::String& name, 
             std::fstream* s, 
-            bool freeOnClose)
+			bool freeOnClose) : WriteableDataStream(name), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mpStream->seekg(0, std::ios_base::end);
         mSize = mpStream->tellg();
@@ -43,7 +43,7 @@
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(const Ogre::String& name, 
             std::fstream* s, 
             size_t size, 
-            bool freeOnClose)
+			bool freeOnClose) : WriteableDataStream(name), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mSize = size;
     }

Modified: rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -34,4 +34,5 @@
     {
         mStream->flush();
     }
-}
\ No newline at end of file
+}
+

Copied: rl/branches/persistence/core/CMakeLists.txt (from rev 4634, rl/trunk/engine/core/CMakeLists.txt)

Modified: rl/branches/persistence/core/include/ConfigurationManager.h
===================================================================
--- rl/branches/persistence/core/include/ConfigurationManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/ConfigurationManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -190,6 +190,13 @@
             Ogre::StringVector getModuleList() const;
 
             /**
+             * Remove modules from the module list (e.g. because they are broken)
+             *
+             * @param modules the modules to remove
+             */
+            void removeModules(const Ogre::StringVector& modules);
+
+            /**
              * Returns the filename of the current keymap file used by
              * Rastullah
              *

Modified: rl/branches/persistence/core/include/SaveAbleFactory.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -25,7 +25,8 @@
 	class _RlCoreExport SaveAbleFactory : public Ogre::Singleton<SaveAbleFactory>, PropertyHolder
 	{
 	public:
-		virtual SaveAblePtr createSaveAble(PropertyRecordPtr params) = 0;
+		virtual SaveAblePtr createSaveAble(const CeGuiString &id, PropertyRecordPtr params) = 0;
+		virtual void removeSaveAble(const CeGuiString &id) = 0;
 	};
 
 	class _RlCoreExport SaveAbleFactoryPool : public Ogre::Singleton<SaveAbleFactoryPool>

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,6 +20,7 @@
 #include "CorePrerequisites.h"
 #include "SaveAble.h"
 #include "SaveAbleCollection.h"
+#include "SaveAbleFactory.h"
 
 namespace rl
 {
@@ -28,21 +29,32 @@
 	protected:
 		typedef std::map<CeGuiString, SaveAbleCollection*> SaveAbleCollectionMap;
 	public:
+		typedef std::map<CeGuiString, SaveAblePtr> SaveAbleMap;
+		typedef std::map<CeGuiString, PropertyRecordPtr> SaveAbleStateMap;
 		void saveState();
-		void addSaveAble(SaveAblePtr save);
+		void loadState();
+		void addSaveAble(SaveAblePtr save, const CeGuiString &collectionId);
+		void moveSaveAbleToCollection(SaveAblePtr save, const CeGuiString &collectionId);
+		void moveSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
 		void removeSaveAble(SaveAblePtr save);
 		void removeSaveAble(const CeGuiString &id);
 		void removeAllSaveAbles();
-		void attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
-		void deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
-		void restoreState();
-		void restoreSaveAble(const CeGuiString &id);
+		//void attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
+		//void deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
+		
 		SaveAbleCollectionMap getCollections();
+		SaveAbleStateMap getSaveAbleStates();
+
+		SaveAbleFactory* getFactory(SaveAblePtr saveAble);
+		SaveAbleFactory* getFactory(const CeGuiString &id);
 	protected:
-		std::map<CeGuiString, PropertyRecordPtr> mSaveAbleStates;
-		std::map<CeGuiString, SaveAblePtr> mSaveAbles;
-		
+		SaveAbleStateMap mSaveAbleStates;
+		SaveAbleMap mSaveAbles;
 		SaveAbleCollectionMap mSaveAbleCollections;
+
+		void storeSaveAbleStates();
+		void restoreSaveAblesFromStates();
+		void restoreSaveAbleFromState(const CeGuiString &id);		
 	};
 }
 

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -36,6 +36,8 @@
 
 		SaveGameEntryMap listSaveGames();
 		SaveGameEntryMap listSaveGames(const CeGuiString &moduleId);
+		bool SaveGameExists(const CeGuiString &name, const CeGuiString &moduleId);
+		SaveGameFile* getSaveGame(const CeGuiString &name, const CeGuiString &moduleId);
 
 		virtual const Ogre::StringVector&  getScriptPatterns(void) const;
         virtual void parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName);
@@ -50,7 +52,7 @@
 		void writeToSaveGameFile(SaveGameFile* file);
 		void readFromSaveGameFile(SaveGameFile* file);
 
-		SaveGameEntryMap mSaveGameFile;
+		SaveGameEntryMap mSaveGameFiles;
 		SaveGameFileReader mReader;
 		SaveGameFileWriter mWriter;
 

Modified: rl/branches/persistence/core/include/SaveGameFile.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameFile.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveGameFile.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -31,7 +31,7 @@
 
 namespace rl
 {
-    class _RlCoreExport SaveGameFile : public PropertyHolder, public ScriptSerializer
+    class _RlCoreExport SaveGameFile : public PropertyHolder
     {
     public:
         static const Ogre::String PROPERTY_MODULEID;
@@ -39,25 +39,17 @@
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_MODULENAME;
 
-        SaveGameFile(const CeGuiString &name, int id = 0);
+        SaveGameFile(int id, WriteableDataStreamPtr stream);
         ~SaveGameFile();
-        CeGuiString buildFilename();
         CeGuiString getName() const;
 		CeGuiString getModuleId() const;
-        int getId();
-        bool saveGameExists();
+		int getId() const;
 
         //access to file
         WriteableDataStreamPtr &getDataStream();
-        void closeDataStream();
         XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
-        void deleteFileFromStorage();
+        void deleteFileFromStorage(); //erwuenscht?
 
-        //data to be saved
-        virtual const Ogre::StringVector&  getScriptPatterns(void) const;
-        virtual void parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName);
-        virtual Ogre::Real getLoadingOrder(void) const;
-
         //propertyholder
         virtual const Property getProperty(const CeGuiString& key) const;
         virtual void setProperty(const CeGuiString& key, const Property& value);

Modified: rl/branches/persistence/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -184,6 +184,21 @@
         return mModuleList;
     }
 
+    void ConfigurationManager::removeModules(const Ogre::StringVector& modules)
+    {
+        for (Ogre::StringVector::const_iterator it = modules.begin(), end = modules.end(); it != end; ++it)
+        {
+            for (Ogre::StringVector::iterator itDel = mModuleList.begin(), endDel = mModuleList.end(); itDel != endDel; ++itDel)
+            {
+                if (*itDel == *it)
+                {
+                    mModuleList.erase(itDel);
+                    break;
+                }
+            }
+        }
+    }
+
     void ConfigurationManager::loadConfig()
     {
         setRastullahCfgPath();

Modified: rl/branches/persistence/core/src/ContentLoader.cpp
===================================================================
--- rl/branches/persistence/core/src/ContentLoader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/ContentLoader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,33 +1,33 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "ContentLoader.h"
-
-namespace rl
-{
-    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
-    {
-    }
-
-    ContentLoader::~ContentLoader()
-    {
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "ContentLoader.h"
+
+namespace rl
+{
+    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
+    {
+    }
+
+    ContentLoader::~ContentLoader()
+    {
+    }
+
     const Property ContentLoader::getProperty(const CeGuiString& key) const
     {
         LOG_WARNING(Logger::CORE, key + " is not a property of this ContentLoader");
@@ -38,9 +38,10 @@
     {
     }
 
-    PropertyKeys ContentLoader::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-}
\ No newline at end of file
+    PropertyKeys ContentLoader::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        return keys;
+    }
+}
+

Modified: rl/branches/persistence/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -334,6 +334,8 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
+        Ogre::StringVector brokenModules;
+
         for (size_t i = 0; i < modulesList.size(); i++)
         {
             mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
@@ -342,8 +344,9 @@
 
             if (module == NULL)
             {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "'");
+                LOG_WARNING("CoreSubsystem",
+                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "', removed.");
+                brokenModules.push_back(modulesList[i]);
             }
             //else
             //{
@@ -354,6 +357,8 @@
             //    }
             //}
         }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
     }
 
     ContentModule* CoreSubsystem::getModule(const Ogre::String& moduleId) const

Modified: rl/branches/persistence/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -73,18 +73,26 @@
             {
                 mo->stopAllAnimationsExcept(mAnimName);
             }                
-
-            if (mDuration > 0)
+            
+            if (mo->hasAnimation(mAnimName))
             {
-                mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
-                mTimeToGo = mDuration;
-                mAnimationRunning = true;
+                if (mDuration > 0)
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation->getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
             }
-            else
+            else 
             {
-                MeshAnimation* animation = mo->startAnimation(mAnimName, 1.0f, mLoops);
-                mTimeToGo = animation->getLength() * (float)mLoops;
-                mAnimationRunning = true;
+                mAnimation = NULL;
+                mTimeToGo = 0;
             }
         }
 

Modified: rl/branches/persistence/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -39,6 +39,15 @@
 
 	void SaveAbleFactoryPool::unregisterFactory(rl::SaveAbleFactory *fac)
 	{
+		std::map<Ogre::String,SaveAbleFactory*>::iterator it;
+		for(it = mFactories.begin(); it != mFactories.end(); it++)
+		{
+			if(it->second == fac)
+			{
+				mFactories.erase(it);
+				return;
+			}
+		}
 	}
 
 	SaveAbleFactory* SaveAbleFactoryPool::getFactory(const Ogre::String &key)

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -26,7 +26,7 @@
 	{
 	}
 
-	void SaveAbleManager::addSaveAble(SaveAblePtr save)
+	void SaveAbleManager::addSaveAble(SaveAblePtr save, const CeGuiString &collectionId)
 	{
 	}
 
@@ -42,15 +42,36 @@
 	{
 	}
 		
-	void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
+	/*void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
 	{
-	}
+	}*/
 		
-	void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
+	/*void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
 	{
-	}
+	}*/
 		
-	void SaveAbleManager::restoreState()
+	void SaveAbleManager::restoreSaveAblesFromStates()
 	{
 	}
+
+	void SaveAbleManager::restoreSaveAbleFromState(const CeGuiString &id)
+	{
+	}
+
+	void SaveAbleManager::storeSaveAbleStates()
+	{
+		mSaveAbleStates.clear();
+
+		SaveAbleMap::const_iterator it;
+		for(it = mSaveAbles.begin(); it != mSaveAbles.end(); it++)
+		{
+			PropertyRecordPtr Properties;
+			Properties->setProperty("Properties", it->second->getAllProperties()->toPropertyMap());
+
+			// Ein dickes TODO ------
+			Properties->setProperty("CreationProperties", Property());
+			Properties->setProperty("Factory", Property("ID der Factory"));
+			mSaveAbleStates[it->first] = Properties;
+		}
+	}
 }

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -64,6 +64,10 @@
 
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
+		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
+		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = 
+			new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),
+			WriteableDataStreamPtr(dynamic_cast<WriteableDataStream*>(stream.get())));
 	}
 
 	const Ogre::StringVector& SaveAbleSerializer::getScriptPatterns() const
@@ -75,6 +79,50 @@
     {
         return 2000.0f;
     }
+	
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames()
+	{
+		return mSaveGameFiles;
+	}
 
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames(const CeGuiString &moduleId)
+	{
+		SaveGameEntryMap files;
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			if(iter->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+				files[iter->first] = iter->second;
+		}
+		return files;
+	}
 
+	bool SaveAbleSerializer::SaveGameExists(const CeGuiString &name, const CeGuiString &moduleId)
+	{
+		bool exists = false;
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end() && !exists; iter++)
+		{
+			if(iter->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+			{
+				if(iter->second->getName() == name)
+					exists = true;
+			}
+		}
+		return exists;
+	}
+
+	SaveGameFile* SaveAbleSerializer::getSaveGame(const CeGuiString &name, const CeGuiString &moduleId)
+	{
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			if(iter->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+			{
+				if(iter->second->getName() == name)
+					return iter->second;
+			}
+		}
+		return NULL;
+	}
 }

Modified: rl/branches/persistence/core/src/SaveGameFile.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -19,6 +19,7 @@
 #include "SaveGameFile.h"
 #include "SaveGameManager.h"
 #include <xercesc/framework/LocalFileFormatTarget.hpp>
+#include "WriteableDataStreamFormatTarget.h"
 
 #include <ConfigurationManager.h>
 #include <CoreSubsystem.h>
@@ -32,27 +33,15 @@
     const Ogre::String SaveGameFile::PROPERTY_MODULENAME = "modulename";
 
 
-    SaveGameFile::SaveGameFile(const CeGuiString &name, int id) : mStream((WriteableDataStream*)NULL)
+    SaveGameFile::SaveGameFile(int id, WriteableDataStreamPtr stream) : mStream(stream)
     {
-        setProperty(PROPERTY_NAME,name);
-        mSaveGameId = id;
+		mSaveGameId = id;  
     }
 
     SaveGameFile::~SaveGameFile()
     {
     }
 
-    CeGuiString SaveGameFile::buildFilename()
-    {
-#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        return Ogre::String(::getenv("HOME")) + "/.rastullah/saves/" 
-            + Ogre::StringConverter::toString(mSaveGameId) + ".save";
-#       else
-        return ConfigurationManager::getSingleton().getModulesRootDirectory() + "/saves/" 
-            + Ogre::StringConverter::toString(mSaveGameId) + ".save";
-#       endif        
-    }
-
     CeGuiString SaveGameFile::getName() const
     {
         return getProperty(PROPERTY_NAME);
@@ -63,54 +52,30 @@
 		return mModuleID;
 	}
 
-    int SaveGameFile::getId()
+    int SaveGameFile::getId() const
     {
         return mSaveGameId;
     }
 
     WriteableDataStreamPtr &SaveGameFile::getDataStream()
     {
-        Ogre::ResourceGroupManager::getSingleton().createResourceGroup("SaveGame");
-
-        mScriptPatterns.push_back((Ogre::StringConverter::toString(mSaveGameId) + ".save").c_str());
-
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-
-        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
-            + "/saves", "FileSystem", "SaveGame");
-        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGame");
-
-        ///@todo: decryption
-        return mStream;
+		return mStream;
     }
 
-    void SaveGameFile::closeDataStream()
-    {
-        Ogre::ResourceGroupManager::getSingleton().clearResourceGroup("SaveGame"); //close all resource files -> make them writable
-        Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup("SaveGame");
-
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-    }
-
     XERCES_CPP_NAMESPACE::XMLFormatTarget* SaveGameFile::getFormatTarget()
     {
         ///@todo: encryption
-        return new XERCES_CPP_NAMESPACE::LocalFileFormatTarget(this->buildFilename().c_str());
+		return new WriteableDataStreamFormatTarget(mStream);
     }
 
     void SaveGameFile::deleteFileFromStorage()
     {
-        if(remove(buildFilename().c_str()))
+        /*if(remove(buildFilename().c_str()))
             LOG_ERROR(Logger::RULES, "SaveGameFile is not removed from filesystem. The file doesn't exists!");
         else 
-            LOG_MESSAGE(Logger::RULES,"SaveGameFile successfully removed from filesystem");
+            LOG_MESSAGE(Logger::RULES,"SaveGameFile successfully removed from filesystem");*/
     }
 
-    bool SaveGameFile::saveGameExists()
-    {
-        return !Ogre::DataStreamPtr( new Ogre::FileHandleDataStream(fopen(this->buildFilename().c_str(), "r"))).isNull();
-    }
-
     const Property SaveGameFile::getProperty(const CeGuiString& key) const
     {
         if(key == PROPERTY_MODULEID)
@@ -158,19 +123,4 @@
         set.insert(PROPERTY_MODULENAME);
         return set;
     }
-
-    const Ogre::StringVector& SaveGameFile::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SaveGameFile::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
-    {
-		mStream.bind(static_cast<WriteableDataStream*>(stream.get()));
-    }
-
-    Ogre::Real SaveGameFile::getLoadingOrder() const
-    {
-        return 1000.0f;
-    }
 }

Modified: rl/branches/persistence/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -34,60 +34,60 @@
 
     void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &map)
     {
-        initializeXml();
+        //initializeXml();
 
-        mDocument = loadDocument(file->getDataStream());
+        //mDocument = loadDocument(file->getDataStream());
 
-        int version = getAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion");
-        if(version >= CoreSubsystem::getSingleton().getEngineBuildNumber())
-            LOG_MESSAGE(Logger::CORE, "Loading save game: Engine version is ok");
-        else
-            LOG_ERROR(Logger::CORE, "Loading save game: Save game version is newer then engine version! Loading save game could crash");
+        //int version = getAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion");
+        //if(version >= CoreSubsystem::getSingleton().getEngineBuildNumber())
+        //    LOG_MESSAGE(Logger::CORE, "Loading save game: Engine version is ok");
+        //else
+        //    LOG_ERROR(Logger::CORE, "Loading save game: Save game version is newer then engine version! Loading save game could crash");
 
-        for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
-        {
-            data_iter->second->readData(this);
-        }
+        //for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
+        //{
+        //    data_iter->second->readData(this);
+        //}
 
 
-        file->closeDataStream(); //make the save game writable
+        //file->closeDataStream(); //make the save game writable
 
-        mDocument = NULL;
+        //mDocument = NULL;
 
-        shutdownXml();
+        //shutdownXml();
     }
 
     void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &stream, const Ogre::String &groupName, SaveGameFile* file)
     {
-        initializeXml();
+        //initializeXml();
 
-        if(stream->size())
-        {
-            DOMDocument* doc = loadDocument(stream);
+        //if(stream->size())
+        //{
+        //    DOMDocument* doc = loadDocument(stream);
 
-             DOMNodeList* headerDefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("header").data());
-             if(headerDefsXml->getLength())
-             {
-                 DOMElement* elem = static_cast<DOMElement*>(headerDefsXml->item(0));
-                 /*DOMNodeList* headerDefChildren = elem->getChildNodes();
-                 for(XMLSize_t childIdx = 0; childIdx < headerDefChildren->getLength(); childIdx++)
-                 {
-                     DOMNode* curChild = headerDefChildren->item(childIdx);
-                     if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
-                     {
-                         PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
-                         if(entry.first != "")
-                         {
-                            file->setProperty(entry.first, entry.second);
-                         }
-                     }
-                 }*/
-                 PropertyRecordPtr set = getPropertiesAsRecord(elem);
-                 file->setProperties(set);
-             }
-        }
+        //     DOMNodeList* headerDefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("header").data());
+        //     if(headerDefsXml->getLength())
+        //     {
+        //         DOMElement* elem = static_cast<DOMElement*>(headerDefsXml->item(0));
+        //         /*DOMNodeList* headerDefChildren = elem->getChildNodes();
+        //         for(XMLSize_t childIdx = 0; childIdx < headerDefChildren->getLength(); childIdx++)
+        //         {
+        //             DOMNode* curChild = headerDefChildren->item(childIdx);
+        //             if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+        //             {
+        //                 PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+        //                 if(entry.first != "")
+        //                 {
+        //                    file->setProperty(entry.first, entry.second);
+        //                 }
+        //             }
+        //         }*/
+        //         PropertyRecordPtr set = getPropertiesAsRecord(elem);
+        //         file->setProperties(set);
+        //     }
+        //}
 
-        shutdownXml();
+        //shutdownXml();
     }
 
     PropertyRecordPtr SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)

Modified: rl/branches/persistence/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -48,8 +48,31 @@
 	{
 		initializeXml();
 
+		XMLCh tempStr[100];
+        XMLString::transcode("LS", tempStr, 99);
+        mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
+		mTarget = file->getFormatTarget();
+		mWriter = static_cast<DOMImplementationLS*>(mImplementation)->createDOMWriter();
+		mDocument = static_cast<DOMImplementation*>(mImplementation)->createDocument(0, XMLString::transcode("SaveGameFile"), 0);
 
+		 if (mWriter->canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
+            mWriter->setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
 
+        if (mWriter->canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
+             mWriter->setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
+
+		mDocument->setNodeValue(XMLString::transcode("SaveGameFile")); //Set name of document root node
+
+		setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.6");
+		setAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
+
+
+        mWriter->writeNode(mTarget, *mDocument);
+
+        mWriter->release();
+
+        delete mDocument;
+
 		shutdownXml();
 	}
 

Modified: rl/branches/persistence/core/src/SaveGameManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -56,15 +56,15 @@
 
     SaveGameManager::SaveGameManager() : mHighestSaveGameNumber(0)
     { 
-        Ogre::ResourceGroupManager::getSingleton().createResourceGroup("SaveGames");
+        //Ogre::ResourceGroupManager::getSingleton().createResourceGroup("SaveGames");
 
-        mScriptPatterns.push_back("*.save");
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+        //mScriptPatterns.push_back("*.save");
+        //Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
 
-        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
-            + "/saves", "FileSystem", "SaveGames");
-        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGames");
-        Ogre::ResourceGroupManager::getSingleton().clearResourceGroup("SaveGames"); //close all resource files -> make them writable
+        //Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
+        //    + "/saves", "FileSystem", "SaveGames");
+        //Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGames");
+        //Ogre::ResourceGroupManager::getSingleton().clearResourceGroup("SaveGames"); //close all resource files -> make them writable
     }
 
     SaveGameManager::~SaveGameManager()
@@ -92,33 +92,33 @@
 
     void SaveGameManager::saveSaveGameFile(const CeGuiString &name)
     {
-        MessagePump::getSingleton().sendMessage<MessageType_SaveGameSaving>();
+    //    MessagePump::getSingleton().sendMessage<MessageType_SaveGameSaving>();
 
-        time_t rawTime;
-        tm* localTime; 
-        time(&rawTime);
-        localTime = localtime(&rawTime);
+    //    time_t rawTime;
+    //    tm* localTime; 
+    //    time(&rawTime);
+    //    localTime = localtime(&rawTime);
 
-        SaveGameFile* file = NULL;
+    //    SaveGameFile* file = NULL;
 
-        if(SaveGameFileExists(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
-        {
-             file = getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-             //new SaveGameFile(name,getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId())->getId());
-        }
-        else
-        {
-            mHighestSaveGameNumber++;
-            file = new SaveGameFile(name, mHighestSaveGameNumber);
-        }
-        
-        file->setProperty(SaveGameFile::PROPERTY_TIME, Property(printTimeAsString(localTime)));
-        file->setProperty(SaveGameFile::PROPERTY_MODULEID, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()));
-        file->setProperty(SaveGameFile::PROPERTY_MODULENAME, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()->getName()));
+    //    if(SaveGameFileExists(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
+    //    {
+    //         file = getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
+    //         //new SaveGameFile(name,getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId())->getId());
+    //    }
+    //    else
+    //    {
+    //        mHighestSaveGameNumber++;
+    //        file = new SaveGameFile(name, mHighestSaveGameNumber);
+    //    }
+    //    
+    //    file->setProperty(SaveGameFile::PROPERTY_TIME, Property(printTimeAsString(localTime)));
+    //    file->setProperty(SaveGameFile::PROPERTY_MODULEID, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()));
+    //    file->setProperty(SaveGameFile::PROPERTY_MODULENAME, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()->getName()));
 
-        mSaveGames[file->getId()] = file;
+    //    mSaveGames[file->getId()] = file;
 
-        SaveGameFileWriter writer;
+    //    SaveGameFileWriter writer;
         //writer.buildSaveGameFile(file, mSaveGameDataOrderMap);
 
         //freeSaveGameMap();
@@ -126,12 +126,12 @@
         //Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGames");
         //Ogre::ResourceGroupManager::getSingleton().clearResourceGroup("SaveGames"); //close all resource files -> make them writable
 
-        MessagePump::getSingleton().sendMessage<MessageType_SaveGameSaved>();
+        //MessagePump::getSingleton().sendMessage<MessageType_SaveGameSaved>();
     }
 
     void SaveGameManager::loadSaveGameFile(const CeGuiString &name, const CeGuiString &moduleId)
     {
-        if(SaveGameFileExists(name, moduleId))
+     /*   if(SaveGameFileExists(name, moduleId))
         {
             MessagePump::getSingleton().sendMessage<MessageType_SaveGameLoading>();
 
@@ -144,7 +144,7 @@
             ///@todo: SaveGameReader
 
             MessagePump::getSingleton().sendMessage<MessageType_SaveGameLoaded>();
-        }
+        }*/
     }
 
     void SaveGameManager::loadSaveGameFile(int id)
@@ -235,24 +235,24 @@
 
     void SaveGameManager::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
     {
-        Ogre::String name = stream->getName();
-        name = name.substr(0, name.length()-5); //delete ".save" at the and of the name
-        int pointpos = name.find_last_of(".");
-        name = name.substr(0, pointpos);
+        //Ogre::String name = stream->getName();
+        //name = name.substr(0, name.length()-5); //delete ".save" at the and of the name
+        //int pointpos = name.find_last_of(".");
+        //name = name.substr(0, pointpos);
 
-        if(Ogre::StringConverter::isNumber(name))
-        {
-            mHighestSaveGameNumber = std::max(mHighestSaveGameNumber, Ogre::StringConverter::parseInt(name));
+        //if(Ogre::StringConverter::isNumber(name))
+        //{
+        //    mHighestSaveGameNumber = std::max(mHighestSaveGameNumber, Ogre::StringConverter::parseInt(name));
 
-            SaveGameFile* file = new SaveGameFile("", Ogre::StringConverter::parseInt(name));        
-            
-            LOG_MESSAGE(Logger::RULES, "Parsing header of save game: " + name + ".save");
-            SaveGameFileReader reader;
-            reader.parseSaveGameFileHeader(stream, groupName, file);
-            
-            if(file->getProperty(SaveGameFile::PROPERTY_MODULEID) != "") // broken save game
-                mSaveGames[Ogre::StringConverter::parseInt(name)] = file;
-        }
+        //    SaveGameFile* file = new SaveGameFile("", Ogre::StringConverter::parseInt(name));        
+        //    
+        //    LOG_MESSAGE(Logger::RULES, "Parsing header of save game: " + name + ".save");
+        //    SaveGameFileReader reader;
+        //    reader.parseSaveGameFileHeader(stream, groupName, file);
+        //    
+        //    if(file->getProperty(SaveGameFile::PROPERTY_MODULEID) != "") // broken save game
+        //        mSaveGames[Ogre::StringConverter::parseInt(name)] = file;
+        //}
     }
 
     void SaveGameManager::registerSaveGameData(SaveGameData* data)

Modified: rl/branches/persistence/rules/include/ApplyDamageJob.h
===================================================================
--- rl/branches/persistence/rules/include/ApplyDamageJob.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/ApplyDamageJob.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include "RulesPrerequisites.h"
-
-#include "Job.h"
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include "RulesPrerequisites.h"
+
+#include "Job.h"
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/branches/persistence/rules/include/Combat.h
===================================================================
--- rl/branches/persistence/rules/include/Combat.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Combat.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include "RulesPrerequisites.h"
-
-#include <set>
-#include <vector>
-#include <boost/tuple/tuple.hpp>
-
-#include "JobListener.h"
-#include "Kampfaktion.h"
-#include "MessagePump.h"
-#include "RulesConstants.h"
-#include "Effect.h"
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set<Combatant*> CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet& getAllPlayerOpponents() const;
-        const CombatantSet& getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector<ActionEntry> ActionEntryVector;
-		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
-		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
-        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set<int> mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include "RulesPrerequisites.h"
+
+#include <set>
+#include <vector>
+#include <boost/tuple/tuple.hpp>
+
+#include "Creature.h"
+#include "Effect.h"
+#include "JobListener.h"
+#include "Kampfaktion.h"
+#include "MessagePump.h"
+#include "RulesConstants.h"
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set<Combatant*> CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector<ActionEntry> ActionEntryVector;
+		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
+		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
+        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set<int> mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/branches/persistence/rules/include/Combatant.h
===================================================================
--- rl/branches/persistence/rules/include/Combatant.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Combatant.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Creature.h"
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/branches/persistence/rules/include/Creature.h
===================================================================
--- rl/branches/persistence/rules/include/Creature.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Creature.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -73,8 +73,14 @@
     static const int RESULT_ERFOLG = 1;
     /// Eine normal misslungene Attacke oder Parade
     static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
 
-
     /// Basistalente
     /// @todo Passenderen Ort suchen
     static const CeGuiString TALENT_ART_BASIS = "Basis";
@@ -632,7 +638,7 @@
              **/
             int doInitiativeWurf(bool getMaxInitiative = false);
 
-			int doTrefferpunkteWurf(Weapon* weapon) const;
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
 
             /**
              *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
@@ -642,10 +648,11 @@
              **/
             void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
             static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
 
             /**
              *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.

Modified: rl/branches/persistence/rules/include/QuestBook.h
===================================================================
--- rl/branches/persistence/rules/include/QuestBook.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/QuestBook.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -67,7 +67,8 @@
 	 *@param params Params needed for creation
 	 *@return SaveAble which has been created
 	 */
-	SaveAblePtr createSaveAble(PropertyRecordPtr params);
+	SaveAblePtr createSaveAble(const CeGuiString &id, PropertyRecordPtr params);
+	virtual void removeSaveAble(const CeGuiString &id);
 
     /**
      *  Adds a journal entry to the quest book.

Modified: rl/branches/persistence/rules/include/Slot.h
===================================================================
--- rl/branches/persistence/rules/include/Slot.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Slot.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,92 +1,224 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __SLOT_H__
-#define __SLOT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl {
-
-class Creature;
-class Item;
-
-class _RlRulesExport Slot
-{
-public:
-    Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
-    virtual ~Slot();
-
-    // provides standard behaviour, sets
-    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
-    // subclasses MUST call this method when overriding
-    virtual bool setItem(Item* item);
-    virtual void update(); // this must only be called from creature::doPlaceIntoScene
-    Item* getItem() const;
-    bool isAllowed(const Item* item) const;
-    bool isEmpty() const {return mItem == NULL;}
-    bool canReady(const Item* item) const;
-	bool isReady() { return mItem != NULL && canReady(mItem); }
-    CeGuiString getName() const {return mName;}
-
-protected:
-
-    Creature* mOwner;
-    Item* mItem;
-
-private:
-    CeGuiString mName;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemHeldMask;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemReadyMask;
-};
-
-class BoneSlot : public Slot
-{
-public:
-    BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mBone;
-};
-
-class SubmeshSlot : public Slot
-{
-public:
-    SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-class MaterialSlot : public Slot
-{
-public:
-    MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-} // namespace rl
-
-#endif //__SLOT_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __SLOT_H__
+#define __SLOT_H__
+
+#include "RulesPrerequisites.h"
+
+namespace rl {
+    
+    class Creature;
+    class Item;
+    
+    /**
+     * A class to represent a place where an Item can be attached to a creature
+     *
+     */
+    class _RlRulesExport Slot
+    {
+    public:
+        
+        /**
+         * Creates a slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         */
+        Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
+        virtual ~Slot();
+        
+        /**
+         * Puts an item into the slot, may depend on the actual slot type
+         *
+         * Note: this method provides standard behaviour, sets item-state etc
+         * subclasses MUST call this method when overriding
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * Updates the slot to match the owner's state
+         *
+         * Note: this must only be called from Creature::doPlaceIntoScene
+         */
+        virtual void update();
+        
+        /**
+         * Gets the item in the slot
+         *
+         * @returns the item, NULL if the slot is empty
+         */
+        Item* getItem() const;
+        
+        /**
+         * Check if an item can be held in this slot
+         *
+         * @param item an item
+         * @returns true if the item can be put into this slot, false otherwise
+         */
+        bool isAllowed(const Item* item) const;
+        
+        /** 
+         * Check if the slot is empty
+         *
+         * @returns true if the slot is empty, false otherwise
+         */
+        bool isEmpty() const {return mItem == NULL;}
+        
+        /**
+         * Check if an item is readied in this slot (e.g. trousers in the legs slot) or not (e.g. trousers in the left hand slot)
+         *
+         * @param item an item
+         * @returns true if the item is readied in this slot, false otherwise
+         */
+        bool canReady(const Item* item) const;
+        
+        /**
+         * Check if the slot holds a ready item
+         *
+         */
+        bool isReady() { return mItem != NULL && canReady(mItem); }
+        
+        /**
+         * Get the slot's name
+         *
+         * @returns the name
+         */
+        CeGuiString getName() const {return mName;}
+        
+    protected:
+        
+        Creature* mOwner;
+        Item* mItem;
+        
+    private:
+        CeGuiString mName;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemHeldMask;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemReadyMask;
+    };
+    
+    /**
+     * A slot implemented by a model bone, if objects are put into the slot, their models are attached at the bone
+     */
+    class BoneSlot : public Slot
+    {
+    public:
+        
+        /**
+         * Creates a bone slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param bone the bone name
+         */
+        BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
+        
+        /**
+         * Puts an item into the slot by attaching its mesh to the bone of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mBone;
+    };
+    
+    /**
+     * A slot implemented by a submesh "baked" into the owner mesh. If an item is put into that slot it creates or 
+     * replaces a specified submesh, this is used for armor to be able to animate the armor meshes on an easy way
+     *
+     * Note: the item meshes must have the same skeleton as the owner mesh
+     */
+    class SubmeshSlot : public Slot
+    {
+    public:
+
+        /**
+         * Creates a submesh slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by creating or replacing a submesh in the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+    /**
+     * A slot implemented by changing a material on a specified submesh of the owner mesh. This is used for clothes.
+     */
+    class MaterialSlot : public Slot
+    {
+    public:
+        /**
+         * Creates a material slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by replacing the material in one submesh of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+} // namespace rl
+
+#endif //__SLOT_H__

Modified: rl/branches/persistence/rules/include/Weapon.h
===================================================================
--- rl/branches/persistence/rules/include/Weapon.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Weapon.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (const CeGuiString &id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString& getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/branches/persistence/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,11 +20,11 @@
 
 namespace rl 
 {
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
 :   Job("",false, true, TimeSource::GAMETIME, Job::PERSISTENT),
     mTarget(target), 
-    mTp(tp)
+    mDamage(damage),
+    mType(damageType)
 {
 }
 
@@ -34,7 +34,7 @@
 
 bool ApplyDamageJob::execute(Ogre::Real time)
 {
-    mTarget->damageLe(mTp);
+    mTarget->damageLe(mDamage, mType);
     return true;
 }
 

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft nach "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft nach "
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant->doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft zu "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft zu "
 							    + entry.target->getName(), GET_COMBAT);
 						    combatant->doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor->getName() + " attackiert " + target->getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor->rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult >= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent("Erfolg, aber pariert.", GET_COMBAT);
-                        if (target->getActiveWeapon()->isNatural())
+                        if (target->getActiveWeapon()->isNatural() && !actor->getActiveWeapon()->isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target->getActiveWeapon()->isNatural() && actor->getActiveWeapon()->isNatural())
+                        {
+                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target->getActiveWeapon()->isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target->doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetDamage, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor->rollTrefferpunkte();
-            jobSetAnims->add(new ApplyDamageJob(target->getCreature(), tp));
-
-			CeGuiString msg = actor->getName() + " trifft f?r "
+			int tp = actor->rollTrefferpunkte(damageStrength);
+            jobSet->add(new ApplyDamageJob(target->getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor->getName() + " trifft fuer "
             + CeGuiString(StringConverter::toString(tp))
             + " Trefferpunkte";
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature->getName() + " ist jetzt ";
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += "kampfunf?hig.";
+						msg += "kampfunf???hig.";
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/branches/persistence/rules/src/Combatant.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combatant.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Combatant.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -85,9 +85,9 @@
 		return getCreature()->doParade(weapon->getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()->doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()->doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/branches/persistence/rules/src/Creature.cpp
===================================================================
--- rl/branches/persistence/rules/src/Creature.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Creature.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -861,8 +861,13 @@
 		return rval;
 	}
 
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
 	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
 		// Roll dice
 		const Tripel<int>& weaponTp = weapon->getTp();
 		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
@@ -875,6 +880,15 @@
 		
 		int bonus = (kk - tpkk.first) / tpkk.second;
 		rval += bonus;
+        
+        if (damage == DMG_HALF)
+        {
+            rval = (rval + 1) / 2;
+        }
+        else if (damage == DMG_DOUBLE)
+        {
+            rval *= 2; ///@TODO check if correct
+        }
 
 		return rval;
 	}
@@ -890,27 +904,31 @@
         }
 
         ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
+        if (damageType & LEDAMAGE_FIRE)
         {
             LOG_ERROR("Creature", "Fire damage not handled!"); ///@todo implement
         }
-        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER)
+        if (damageType & LEDAMAGE_WATER)
         {
             LOG_ERROR("Creature", "Water damage not handled!"); ///@todo implement
         }
-        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
+        if (damageType & LEDAMAGE_DEMONIC)
         {
             LOG_ERROR("Creature", "Demonic damage not handled!"); ///@todo implement
         }
 
-        if ((damageType & LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
+        if (damageType & LEDAMAGE_TP_A)
         {
             damageAu(tp, AUDAMAGE_NORMAL);
             tp = (int)floor(tp/2.);
         }
 
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
+        int sp = -tp;
+        if (!(damageType & LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
 		modifyLe(sp);
 
         if (sp >= getEigenschaft("KO"))
@@ -1293,12 +1311,13 @@
     {
         GameObject::doRemoveFromScene();
 
+        ///@todo check if this is really necessary
         // check items in inventory
-        Inventory::SlotMap slots = mInventory->getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it->second->update();
-        }
+        //Inventory::SlotMap slots = mInventory->getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it->second->update();
+        //}
     }
 }

Modified: rl/branches/persistence/rules/src/QuestBook.cpp
===================================================================
--- rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -84,13 +84,18 @@
 	    mRootQuest->addSubquest(quest);
     }
 
-	SaveAblePtr QuestBook::createSaveAble(PropertyRecordPtr params)
+	SaveAblePtr QuestBook::createSaveAble(const CeGuiString &id, PropertyRecordPtr params)
 	{
 		SaveAblePtr ptr;
 		ptr.bind(static_cast<SaveAble*>(new Quest(""))); //TODO !!!!!
+		_fireQuestBookChanged(static_cast<Quest*>(ptr.get()), 0);
 		return ptr; // TODO
 	}
 
+	void QuestBook::removeSaveAble(const CeGuiString &id)
+	{
+	}
+
     void QuestBook::_fireQuestBookChanged(Quest *quest, int reason)
     {
 	    QuestEvent* evt = new QuestEvent(this, reason);

Modified: rl/branches/persistence/rules/src/Weapon.cpp
===================================================================
--- rl/branches/persistence/rules/src/Weapon.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Weapon.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -37,6 +37,8 @@
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = "kampftechnik";
     const Ogre::String Weapon::PROPERTY_NATURAL = "natural";
 
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = "avoidarmor";
+    
 	Weapon::Weapon(const CeGuiString &id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +48,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(""),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +187,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString& key, const Property& value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +252,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +313,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +334,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }

Modified: rl/branches/persistence/ui/include/WindowManager.h
===================================================================
--- rl/branches/persistence/ui/include/WindowManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/include/WindowManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -19,6 +19,8 @@
 
 #include "UiPrerequisites.h"
 
+#include "MessagePump.h"
+
 namespace rl {
 
 	class AbstractWindow;
@@ -33,6 +35,7 @@
 		void registerWindow(AbstractWindow* window);
 		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
+        bool destroyAllWindows();
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
@@ -47,6 +50,7 @@
 
 	private:
 		std::list<AbstractWindow*> mWindowList;
+        MessagePump::ScopedConnection mSceneClearConnection;
 
         unsigned short mNumActiveWindowsMouseInput;
         unsigned short mNumActiveWindowsKeyboardInput;

Modified: rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -35,6 +35,7 @@
 #include "WindowFactory.h"
 #include "ConfigurationManager.h"
 #include "SaveGameManager.h"
+#include "SaveAbleSerializer.h"
 #include "CoreSubsystem.h"
 #include "ContentModule.h"
 
@@ -104,8 +105,7 @@
 
     void GameSaveLoadWindow::initialize()
     {
-        //mSaveGameTable->autoSizeColumnHeader(0);
-        //mSaveGameTable->autoSizeColumnHeader(1);
+		listSaveGames();
     }
 
     //------------------------------------------------------- LoadEvent
@@ -137,7 +137,7 @@
 
         if(filename != "")
         {
-
+			if(SaveAbleSerializer::getSingleton().SaveGameExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()));
         }
         else
         {
@@ -159,8 +159,23 @@
 
     void GameSaveLoadWindow::listSaveGames()
     {
-        //mSaveGameTable->autoSizeColumnHeader(0);
-        //mSaveGameTable->autoSizeColumnHeader(1);
+		mSaveGameTable->clearAllSelections();
+
+		while(mSaveGameTable->getRowCount() > 0)
+			mSaveGameTable->removeRow(0);
+
+		SaveGameEntryMap saveGames = SaveAbleSerializer::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
+		int count = saveGames.size();
+
+		for(int i = 0; i < count; i++)
+		{
+			mSaveGameTable->addRow(i);
+			mSaveGameTable->setItem(new ListboxTextItem(saveGames[i]->getName(),0,saveGames[i]),0,i); 
+			mSaveGameTable->setItem(new ListboxTextItem(saveGames[i]->getProperty(SaveGameFile::PROPERTY_TIME).toString()),1,i);
+		}
+
+        mSaveGameTable->autoSizeColumnHeader(0);
+        mSaveGameTable->autoSizeColumnHeader(1);
     }
 
     bool GameSaveLoadWindow::handleSelectSaveGame()

Modified: rl/branches/persistence/ui/src/WindowManager.cpp
===================================================================
--- rl/branches/persistence/ui/src/WindowManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/src/WindowManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -18,8 +18,9 @@
 #include "WindowManager.h"
 #include <CEGUIWindowManager.h>
 
+#include "AbstractWindow.h"
+#include "CoreMessages.h"
 #include "CoreSubsystem.h"
-#include "AbstractWindow.h"
 #include "Exception.h"
 #include "GameLoop.h"
 #include "UiSubsystem.h"
@@ -35,6 +36,8 @@
           mNumActiveWindowsMouseInput(0),
           mNumActiveWindowsKeyboardInput(0)
 	{
+        mSceneClearConnection = MessagePump::getSingleton().addMessageHandler<MessageType_SceneClearing>(
+            boost::bind(&WindowManager::destroyAllWindows, this));
 	}
 
 	WindowManager::~WindowManager()
@@ -123,10 +126,9 @@
     AbstractWindow* WindowManager::getActiveWindow()
     {
         // iterate through windows
-        std::list<AbstractWindow*>::iterator it;
-        for( it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
         {
-            if( (*it)->getWindow()->isActive() )
+            if ( (*it)->getWindow()->isActive() )
             {
                 return *it;
             }
@@ -134,4 +136,23 @@
 
         return NULL;
     }
+
+    bool WindowManager::destroyAllWindows()
+    {
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        {
+            AbstractWindow* cur = *it;
+//			if (cur->isVisible())
+//			{
+				cur->setVisible(false, true);
+//			}
+//          else 
+//          {
+//              delete cur;
+//          }
+        }
+
+        mWindowList.clear();
+        return true;
+    }
 }



From timm at mail.berlios.de  Sat Dec  6 13:39:25 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 6 Dec 2008 13:39:25 +0100
Subject: [Dsa-hl-svn] r4636 - in rl/branches/persistence: core/include
	core/src ui/src
Message-ID: <200812061239.mB6CdPvP022401@sheep.berlios.de>

Author: timm
Date: 2008-12-06 13:39:16 +0100 (Sat, 06 Dec 2008)
New Revision: 4636

Modified:
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
Log:
fixed bug in save game save load window

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-05 18:15:18 UTC (rev 4635)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-06 12:39:16 UTC (rev 4636)
@@ -34,8 +34,8 @@
 
 		typedef std::map<int, SaveGameFile*> SaveGameEntryMap;
 
-		SaveGameEntryMap listSaveGames();
-		SaveGameEntryMap listSaveGames(const CeGuiString &moduleId);
+		SaveGameEntryMap listSaveGames() const;
+		SaveGameEntryMap listSaveGames(const CeGuiString &moduleId) const;
 		bool SaveGameExists(const CeGuiString &name, const CeGuiString &moduleId);
 		SaveGameFile* getSaveGame(const CeGuiString &name, const CeGuiString &moduleId);
 

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-05 18:15:18 UTC (rev 4635)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 12:39:16 UTC (rev 4636)
@@ -80,12 +80,12 @@
         return 2000.0f;
     }
 	
-	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames()
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames() const
 	{
 		return mSaveGameFiles;
 	}
 
-	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames(const CeGuiString &moduleId)
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames(const CeGuiString &moduleId) const
 	{
 		SaveGameEntryMap files;
 		SaveGameEntryMap::const_iterator iter;

Modified: rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-05 18:15:18 UTC (rev 4635)
+++ rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-06 12:39:16 UTC (rev 4636)
@@ -165,13 +165,13 @@
 			mSaveGameTable->removeRow(0);
 
 		SaveGameEntryMap saveGames = SaveAbleSerializer::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-		int count = saveGames.size();
+		SaveGameEntryMap::const_iterator iter = saveGames.begin();
 
-		for(int i = 0; i < count; i++)
+		for(int i = 0; iter != saveGames.end(); i++, iter++)
 		{
 			mSaveGameTable->addRow(i);
-			mSaveGameTable->setItem(new ListboxTextItem(saveGames[i]->getName(),0,saveGames[i]),0,i); 
-			mSaveGameTable->setItem(new ListboxTextItem(saveGames[i]->getProperty(SaveGameFile::PROPERTY_TIME).toString()),1,i);
+			mSaveGameTable->setItem(new ListboxTextItem(iter->second->getName(),0,iter->second),0,i); 
+			mSaveGameTable->setItem(new ListboxTextItem(iter->second->getProperty(SaveGameFile::PROPERTY_TIME).toString()),1,i);
 		}
 
         mSaveGameTable->autoSizeColumnHeader(0);



From blakharaz at mail.berlios.de  Sat Dec  6 14:22:25 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 6 Dec 2008 14:22:25 +0100
Subject: [Dsa-hl-svn] r4637 - rl/trunk/engine/ai
Message-ID: <200812061322.mB6DMPg8025647@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-06 14:22:24 +0100 (Sat, 06 Dec 2008)
New Revision: 4637

Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
Log:
Added DialogLoaderImpl also to VS project


Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2008-12-06 12:39:16 UTC (rev 4636)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2008-12-06 13:22:24 UTC (rev 4637)
@@ -367,6 +367,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\DialogLoaderImpl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\DialogManager.cpp"
 				>
 			</File>
@@ -541,6 +545,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\DialogLoaderImpl.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\DialogManager.h"
 				>
 			</File>



From timm at mail.berlios.de  Sat Dec  6 14:23:47 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 6 Dec 2008 14:23:47 +0100
Subject: [Dsa-hl-svn] r4638 - in rl/branches/persistence/core: include src
Message-ID: <200812061323.mB6DNl0K025711@sheep.berlios.de>

Author: timm
Date: 2008-12-06 14:23:35 +0100 (Sat, 06 Dec 2008)
New Revision: 4638

Modified:
   rl/branches/persistence/core/include/SaveGameFileReader.h
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/core/src/SaveGameFileReader.cpp
Log:
Parsing save game headers

Modified: rl/branches/persistence/core/include/SaveGameFileReader.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameFileReader.h	2008-12-06 13:22:24 UTC (rev 4637)
+++ rl/branches/persistence/core/include/SaveGameFileReader.h	2008-12-06 13:23:35 UTC (rev 4638)
@@ -32,7 +32,7 @@
     public:
         SaveGameFileReader();
         void parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &map);
-        void parseSaveGameFileHeader(Ogre::DataStreamPtr &stream, const Ogre::String &groupName, SaveGameFile* file);
+        void parseSaveGameFileHeader(SaveGameFile* file);
 
         PropertyRecordPtr getAllPropertiesAsRecord(SaveGameData* data);
 

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 13:22:24 UTC (rev 4637)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 13:23:35 UTC (rev 4638)
@@ -65,9 +65,10 @@
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
 		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
-		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = 
-			new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),
+		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),
 			WriteableDataStreamPtr(dynamic_cast<WriteableDataStream*>(stream.get())));
+		mReader.parseSaveGameFileHeader(file);
+		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;
 	}
 
 	const Ogre::StringVector& SaveAbleSerializer::getScriptPatterns() const

Modified: rl/branches/persistence/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-06 13:22:24 UTC (rev 4637)
+++ rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-06 13:23:35 UTC (rev 4638)
@@ -57,37 +57,42 @@
         //shutdownXml();
     }
 
-    void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &stream, const Ogre::String &groupName, SaveGameFile* file)
+    void SaveGameFileReader::parseSaveGameFileHeader(SaveGameFile* file)
     {
-        //initializeXml();
+		initializeXml();
 
-        //if(stream->size())
-        //{
-        //    DOMDocument* doc = loadDocument(stream);
+		WriteableDataStreamPtr stream = file->getDataStream();
 
-        //     DOMNodeList* headerDefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("header").data());
-        //     if(headerDefsXml->getLength())
-        //     {
-        //         DOMElement* elem = static_cast<DOMElement*>(headerDefsXml->item(0));
-        //         /*DOMNodeList* headerDefChildren = elem->getChildNodes();
-        //         for(XMLSize_t childIdx = 0; childIdx < headerDefChildren->getLength(); childIdx++)
-        //         {
-        //             DOMNode* curChild = headerDefChildren->item(childIdx);
-        //             if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
-        //             {
-        //                 PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
-        //                 if(entry.first != "")
-        //                 {
-        //                    file->setProperty(entry.first, entry.second);
-        //                 }
-        //             }
-        //         }*/
-        //         PropertyRecordPtr set = getPropertiesAsRecord(elem);
-        //         file->setProperties(set);
-        //     }
-        //}
+		if(stream->size())
+		{
+			DOMDocument* doc = loadDocument(stream);
+			DOMNodeList* headerDefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("header").data());
 
-        //shutdownXml();
+			if(headerDefsXml->getLength())
+			{
+				DOMElement* elem = static_cast<DOMElement*>(headerDefsXml->item(0));
+				DOMNodeList* headerDefChildren = elem->getChildNodes();
+
+				for(XMLSize_t childIdx = 0; childIdx < headerDefChildren->getLength(); childIdx++)
+				{
+					DOMNode* curChild = headerDefChildren->item(childIdx);
+					if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+                    {
+                        PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+                        if(entry.first != "")
+                        {
+                           file->setProperty(entry.first, entry.second);
+                        }
+                    }
+                }
+
+
+                PropertyRecordPtr set = getPropertiesAsRecord(elem);
+                file->setProperties(set);
+            }
+		}
+
+		shutdownXml();
     }
 
     PropertyRecordPtr SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)



From blakharaz at mail.berlios.de  Sat Dec  6 15:23:33 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 6 Dec 2008 15:23:33 +0100
Subject: [Dsa-hl-svn] r4639 - rl/trunk/engine/rules/src
Message-ID: <200812061423.mB6ENXfk032086@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-06 15:23:32 +0100 (Sat, 06 Dec 2008)
New Revision: 4639

Modified:
   rl/trunk/engine/rules/src/Combat.cpp
Log:


Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2008-12-06 13:23:35 UTC (rev 4638)
+++ rl/trunk/engine/rules/src/Combat.cpp	2008-12-06 14:23:32 UTC (rev 4639)
@@ -486,7 +486,7 @@
                         }
                         else if (!target->getActiveWeapon()->isNatural() && actor->getActiveWeapon()->isNatural())
                         {
-                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            doDamage(jobSetAnims, DMG_HALF, target, actor);
                             rollDamage = DMG_NONE;
                         }
                         else
@@ -522,7 +522,7 @@
 			target->doGetroffen(jobSetAnims);
 		}
 		
-        doDamage(jobSetDamage, rollDamage, actor, target);
+        doDamage(jobSetAnims, rollDamage, actor, target);
 	}
     
     void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)



From blakharaz at mail.berlios.de  Sat Dec  6 15:24:38 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 6 Dec 2008 15:24:38 +0100
Subject: [Dsa-hl-svn] r4640 - in rl/trunk/engine: ai/include rules/include
	ui/src
Message-ID: <200812061424.mB6EOcZS032135@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-06 15:24:35 +0100 (Sat, 06 Dec 2008)
New Revision: 4640

Modified:
   rl/trunk/engine/ai/include/FuzzyStateMachine.h
   rl/trunk/engine/rules/include/RulesPrerequisites.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
line endings

Modified: rl/trunk/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyStateMachine.h	2008-12-06 14:23:32 UTC (rev 4639)
+++ rl/trunk/engine/ai/include/FuzzyStateMachine.h	2008-12-06 14:24:35 UTC (rev 4640)
@@ -1,167 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __RlAI_FuzzyStateMachine_H__
-#define __RlAI_FuzzyStateMachine_H__
-#include <list>
-#include "AiPrerequisites.h"
-#include "FuzzyState.h"
-#include "ScriptWrapper.h"
-
-namespace rl
-{
-	/** manages a set of FuzzyState objects 
-	 */
-	template <class Controller> class FuzzyStateMachine :
-		public FuzzyState<Controller>
-	{
-	public:
-		//! typedefinition for pointer to a FuzzyState
-		typedef FuzzyState<Controller>* FuzzyStatePtr;
-
-		/** Constructor
-		 * sets parent and controller for the FuzzyStateMachine
-		 * @param parent gives the parent FuzzyState object
-		 * @param controller sets the controller object
-		 */
-		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
-			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
-
-		/** destructor.
-		 * removes internally stored Fuzzystate objects
-		 */
-		virtual ~FuzzyStateMachine(void)
-		{
-			clearStates();
-		}
-
-		/** adds a FuzzyState object
-		 * @param state a FuzzyState object to add.
-		 */
-		virtual void addState(FuzzyStatePtr state)
-		{
-			mStates.push_back(State(false, state));
-            ScriptWrapper::getSingleton().owned( state );
-		}
-		/** removes all stored FuzzyState objects
-		 */
-        virtual void clearStates()
-		{
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.begin(); ++itr)
-			{
-                ScriptWrapper::getSingleton().disowned( itr->second );
-				delete itr->second;
-			}
-			mStates.clear();
-		}
-
-		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
-		 * So always return false (no).
-		 * @returns false
-		 */
-		virtual bool isActive(FuzzyStatePtr state)
-		{
-			return false; 
-		}
-		/** reset function for resetting the FuzzyStateMachine
-		 */
-		virtual void reset(){}
-
-		/** sets the maximum number of concurrently active states.
-		 * @param count maximum number of concurrently active states.
-		 */
-		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
-		/** fetches the maximum number of concurrently active states.
-		 * @param int returns the maximum number of concurrently active states.
-		 */
-		virtual int getMaxActivity() { return mMaxActiveStates; }
-
-		/** calculates the activation value.
-		 * @returns float containing the calculated activation value.
-		 */
-		float calculateActivation(void){ return 0.0f; }
-
-		/** initializes the fuzzy state.
-		 */
-		virtual void init(){}
-		/** should activate the fuzzy state.
-		 */
-		virtual void activate(){}
-		/** deactivates fuzzy state.
-		 */
-		virtual void deactivate(){}
-		/** tells the fuzzy state machine to update for the elapsed time.
-		 * For each stored FuzzyState the activation is calculated and
-		 * testified whether it activates the state or not. When a state
-		 * is active its update function is called with the elapsed time.
-		 * @param elapsedtime gives the elapsed time as a float
-		 */
-		virtual void update(const float elapsedTime)
-		{
-			if(mStates.empty())
-				return;
-
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.end(); ++itr)
-			{
-				bool isActive = (itr->second->calculateActivation() > 0);
-				if(isActive)
-				{
-				//  if state is already active, update it, otherwise activate it
-					if(itr->first)
-					{
-						itr->second->update(elapsedTime);
-					}
-					else
-					{
-						itr->second->activate();
-						itr->first = true;
-						// maybe call update here, too
-					}
-				}
-				else
-				{
-				//	if state was active, deactivate it, otherwise do nothing
-					if(itr->first)
-					{
-						itr->second->deactivate();
-						itr->first = false;
-					}	
-				}
-			}
-		}
-
-
-	protected:
-		//! maximum number of active states
-		int mMaxActiveStates;
-		/** typedefinition for active/inactive and FuzzyState objects.
-		 * When the boolean is true, the state is active, otherwise not
-		 */
-		typedef std::pair<bool, FuzzyStatePtr> State;
-		//! defines a double linked list of states
-		typedef std::list<State> StateList;
-		//! the double linked list of stored FuzzyState objects
-		StateList mStates;
-	};
-
-/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
-	{
-
-	}
-*/
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __RlAI_FuzzyStateMachine_H__
+#define __RlAI_FuzzyStateMachine_H__
+#include <list>
+#include "AiPrerequisites.h"
+#include "FuzzyState.h"
+#include "ScriptWrapper.h"
+
+namespace rl
+{
+	/** manages a set of FuzzyState objects 
+	 */
+	template <class Controller> class FuzzyStateMachine :
+		public FuzzyState<Controller>
+	{
+	public:
+		//! typedefinition for pointer to a FuzzyState
+		typedef FuzzyState<Controller>* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
+		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
+			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
+
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
+		virtual ~FuzzyStateMachine(void)
+		{
+			clearStates();
+		}
+
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
+		virtual void addState(FuzzyStatePtr state)
+		{
+			mStates.push_back(State(false, state));
+            ScriptWrapper::getSingleton().owned( state );
+		}
+		/** removes all stored FuzzyState objects
+		 */
+        virtual void clearStates()
+		{
+			for(typename StateList::iterator itr = mStates.begin(); itr != mStates.end(); ++itr)
+			{
+                FuzzyStatePtr state = itr->second;
+                ScriptWrapper::getSingleton().disowned( state );
+				delete state;
+			}
+			mStates.clear();
+		}
+
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
+		virtual bool isActive(FuzzyStatePtr state)
+		{
+			return false; 
+		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
+		virtual void reset(){}
+
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
+		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
+		virtual int getMaxActivity() { return mMaxActiveStates; }
+
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
+		float calculateActivation(void){ return 0.0f; }
+
+		/** initializes the fuzzy state.
+		 */
+		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
+		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
+		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
+		virtual void update(const float elapsedTime)
+		{
+			if(mStates.empty())
+				return;
+
+			typename StateList::iterator itr = mStates.begin();
+			for(; itr != mStates.end(); ++itr)
+			{
+				bool isActive = (itr->second->calculateActivation() > 0);
+				if(isActive)
+				{
+				//  if state is already active, update it, otherwise activate it
+					if(itr->first)
+					{
+						itr->second->update(elapsedTime);
+					}
+					else
+					{
+						itr->second->activate();
+						itr->first = true;
+						// maybe call update here, too
+					}
+				}
+				else
+				{
+				//	if state was active, deactivate it, otherwise do nothing
+					if(itr->first)
+					{
+						itr->second->deactivate();
+						itr->first = false;
+					}	
+				}
+			}
+		}
+
+
+	protected:
+		//! maximum number of active states
+		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
+		typedef std::pair<bool, FuzzyStatePtr> State;
+		//! defines a double linked list of states
+		typedef std::list<State> StateList;
+		//! the double linked list of stored FuzzyState objects
+		StateList mStates;
+	};
+
+/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
+	{
+
+	}
+*/
+}
+#endif

Modified: rl/trunk/engine/rules/include/RulesPrerequisites.h
===================================================================
--- rl/trunk/engine/rules/include/RulesPrerequisites.h	2008-12-06 14:23:32 UTC (rev 4639)
+++ rl/trunk/engine/rules/include/RulesPrerequisites.h	2008-12-06 14:24:35 UTC (rev 4640)
@@ -91,6 +91,7 @@
 
 	typedef std::vector<Action*> ActionVector;
 	
-	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString actionName);
+	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString& actionName);
+	ActionVector::const_iterator findAction(ActionVector::const_iterator& begin, ActionVector::const_iterator& end, const CeGuiString& actionName);
 }
 #endif

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2008-12-06 14:23:32 UTC (rev 4639)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2008-12-06 14:24:35 UTC (rev 4640)
@@ -1,1535 +1,1535 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "MovementControlState.h"
-
-#include <utility>
-
-#include "AbstractMovement.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "DebugWindow.h"
-#include "Exception.h"
-#include "GameObjectManager.h"
-#include "InputManager.h"
-#include "Logger.h"
-#include "MeshObject.h"
-#include "MeshAnimation.h"
-#include "MovementControlState.h"
-#include "PhysicsManager.h"
-#include "PhysicsMaterialRaycast.h"
-#include "PhysicalThing.h"
-#include "RulesMessages.h"
-#include "World.h"
-#include "LineSetPrimitive.h"
-#include "WindowFactory.h"
-#include "AnimationManager.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#include <numeric>
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(
-            mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
-            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
-            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-        {
-            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->freeze();
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL && go->isHighlighted())
-        {
-            go->setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear())
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen->calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement & TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement & TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw <= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw >= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw > Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw <= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw < Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw >= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement & MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController->setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement & MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement & MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController->setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_JUMP && 
-                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController->setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement & MOVE_RUN_LOCK )
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement & MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement & MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController->setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController->setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement & MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController->setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement & MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController->setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance < mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance > mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr?e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-        AxisAlignedBox aabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode->lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor->getPosition() - charPos).length();
-            cameraNode->lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody->getCollision(), camOri, camPos,
-                    mCharBody->getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor->setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor->setVisible(true);
-            }
-        }
-        mCameraActor->setOrientation(cameraNode->getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
-            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor->_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node->getPosition();
-        Quaternion egal;
-        mCamBody->getPositionOrientation(bodpos,egal);
-        ss
-            << "scene node : " << playpos << std::endl
-            << "player velocity : " << -mController->getVelocity().z << std::endl
-            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
-            << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera pos : " << bodpos << std::endl
-            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
-            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr?e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr?e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr?e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta < buffSize )
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta >= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody->getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody->getMassMatrix(mass, inertia);
-
-            //mCamBody->setPositionOrientation(newCamPos, camOri);
-            mCamBody->setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody->setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr?e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &&
-                desiredDistance > mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance > desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
-        {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
-            if (creature &&
-				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
-				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL && oldGo != newGo)
-        {
-            oldGo->setHighlighted(false);
-        }
-
-        if (newGo != NULL && newGo != oldGo)
-        {
-            newGo->setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
-        {
-            newGo->doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
-        }
-        catch(...)
-        {
-            aabb = charMesh->getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr?e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        aab = mesh->getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh->getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr?e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor->setVisible(false);
-        else
-            mCharacterActor->setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, "Camera resetted.");
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
-            if (command == "")
-            {
-                // No. So try global actions.
-                command = mCommandMapper->getGlobalAction(code);
-            }
-            else if (command == "freeflight_mode")
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == "reset_camera")
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == "toggle_view_mode")
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper->getMovement(evt.key);
-
-                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper->getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL && !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo->getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo->doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode->getParent() == NULL)
-        {
-            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()->setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "MovementControlState.h"
+
+#include <utility>
+
+#include "AbstractMovement.h"
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "DebugWindow.h"
+#include "Exception.h"
+#include "GameObjectManager.h"
+#include "InputManager.h"
+#include "Logger.h"
+#include "MeshObject.h"
+#include "MeshAnimation.h"
+#include "MovementControlState.h"
+#include "PhysicsManager.h"
+#include "PhysicsMaterialRaycast.h"
+#include "PhysicalThing.h"
+#include "RulesMessages.h"
+#include "World.h"
+#include "LineSetPrimitive.h"
+#include "WindowFactory.h"
+#include "AnimationManager.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#include <numeric>
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mObstractedFrameCount(0),
+        mObstractedTime(0.0f),
+        mCameraJammedFrameCount(0),
+        mCameraJammedTime(0.0f),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(20),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(
+            mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb = charMesh->getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
+            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
+            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
+        {
+            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL && go->isHighlighted())
+        {
+            go->setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+
+
+        // Do we need to reset the Camera?
+        Vector3 charPos = mCharacterActor->getWorldPosition();
+        Quaternion charOri = mCharacterActor->getWorldOrientation();
+        //mCharBody->getPositionOrientation(charPos, charOri);
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+
+        float maxdistance;
+        if (mViewMode == VM_FIRST_PERSON)
+            maxdistance = 0.25;
+        else
+            maxdistance = 1.3f * mDesiredDistance + 1.4f;
+
+        // if we have more than 250ms and at least five frames with camera distance higher
+        // than desired distance, reset camera
+        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
+        {
+            mCameraJammedTime += elapsedTime;
+            ++mCameraJammedFrameCount;
+        }
+        else
+        {
+            mCameraJammedTime = 0.0f;
+            mCameraJammedFrameCount = 0;
+        }
+
+        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
+        {
+            mCameraJammedFrameCount = 0;
+            resetCamera();
+        }
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen->calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement & TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement & TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw <= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw >= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw > Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw <= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw < Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw >= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement & MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController->setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement & MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement & MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController->setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_JUMP && 
+                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController->setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement & MOVE_RUN_LOCK )
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement & MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement & MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController->setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement & MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController->setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement & MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController->setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance < mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance > mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr?e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox aabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode->lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode->lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor->getPosition() - charPos).length();
+            cameraNode->lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody->getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody->getCollision(), camOri, camPos,
+                    mCharBody->getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor->setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor->setVisible(true);
+            }
+        }
+        mCameraActor->setOrientation(cameraNode->getOrientation());
+    }
+
+    // -------------------------------------------------------------
+    // character collision moved to CreatureController(Manager)
+    int MovementControlState::userProcess()
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
+            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
+        {
+            return 0;
+        }
+
+        setContactSoftness(0.8f);
+        setContactElasticity(0.0f);
+        mLastCameraCollision = 0;
+
+        return 1;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+        Real timestep = world->getTimeStep();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor->_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node->getPosition();
+        Quaternion egal;
+        mCamBody->getPositionOrientation(bodpos,egal);
+        ss
+            << "scene node : " << playpos << std::endl
+            << "player velocity : " << -mController->getVelocity().z << std::endl
+            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
+            << "camera posder : " << static_cast<Camera*>(
+                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
+            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera pos : " << bodpos << std::endl
+            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
+            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr?e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr?e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr?e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos,
+                charPos,
+                true);
+
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+                mCharacterOccludedTime = 0;
+
+            if( infoCastOptPos.mBody )
+            {
+                if( !infoCastChar.mBody ) // Character noch im Blickfeld
+                {
+                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                    // und erreichbar ist
+                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                    RaycastInfo infoCastNewPos;
+                    Real delta = lenToOptCamPos/2.0f;
+                    Vector3 temp = charPos + delta * normToOptCamPos;
+                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                    {
+                        infoCastNewPos = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                            temp,
+                            true);
+                        delta = delta/2.0f;
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                        {
+                            temp = temp - delta * normToOptCamPos;
+                        }
+                        else // kein Hindernis gefunden, weiter von Char weg
+                        {
+                            temp = temp + delta * normToOptCamPos;
+                        }
+                    }
+
+                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                    temp = temp - 0.05 * normToOptCamPos;
+                    // Groesse der Kamera einbeziehen
+                    optimalCamPos = temp - camRadius * normToOptCamPos;
+                    // so ab hier kann ganz normal weiter gerechnet werden!
+                }
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
+                // und durch "Geraden" miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta < buffSize )
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta >= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody->getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody->getMassMatrix(mass, inertia);
+
+            //mCamBody->setPositionOrientation(newCamPos, camOri);
+            mCamBody->setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody->setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+
+            // Kamera-Gr?e beziehen
+            CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+            AxisAlignedBox aabb = ogreCam->getDefaultSize();
+            // Radius berechnen
+            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
+            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
+            // unds eigentlich ne kugel ist!
+
+
+
+            Vector3 startRay[6], endRay[6];
+
+            Real sinPitchRad = Math::Sin(mPitch) * radius;
+            Real cosPitchRad = Math::Cos(mPitch) * radius;
+            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
+
+            startRay[0] = charPos;
+            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
+                                      // dadurch kann aber sichergestellt
+                                      // werden, dass kein Objekt direkt
+                                      // hinter dem Helden bersehen wird
+            startRay[1] = charPos + radiusOffset;
+            endRay[1] = targetCamPos + radiusOffset;
+            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
+            startRay[2] = charPos + radiusOffset;
+            endRay[2] = targetCamPos + radiusOffset;
+            startRay[3] = charPos - radiusOffset;
+            endRay[3] = targetCamPos - radiusOffset;
+            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
+            startRay[4] = charPos + radiusOffset;
+            endRay[4] = targetCamPos + radiusOffset;
+            startRay[5] = charPos - radiusOffset;
+            endRay[5] = targetCamPos - radiusOffset;
+
+            const OgreNewt::MaterialID* materialId =
+                mCharBody->getMaterialGroupID();
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 diff = targetCamPos - charPos;
+            bool CollisionFound = false;
+            for( int i = 0; i < 6; i++ )
+            {
+                RaycastInfo info = mRaycast->execute(
+                    world,
+                    materialId,
+                    startRay[i],
+                    endRay[i],
+                    true);
+
+                if( info.mBody && info.mBody != mCamBody )
+                {
+                    CollisionFound = true;
+                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
+                    if( newdiff.squaredLength() < diff.squaredLength() )
+                        diff = newdiff;
+                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
+                    {
+                        if( diff.squaredLength() < radius*radius )
+                        {
+                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
+                            break;
+                        }
+                    }
+                }
+            }
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &&
+                desiredDistance > mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance > desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i < end; ++i)
+        {
+            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
+            if (creature &&
+				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
+				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        //InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL && oldGo != newGo)
+        {
+            oldGo->setHighlighted(false);
+        }
+
+        if (newGo != NULL && newGo != oldGo)
+        {
+            newGo->setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
+        {
+            newGo->doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
+        }
+        catch(...)
+        {
+            aabb = charMesh->getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr?e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        aab = mesh->getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh->getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr?e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor->setVisible(false);
+        else
+            mCharacterActor->setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, "Camera resetted.");
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
+            if (command == "")
+            {
+                // No. So try global actions.
+                command = mCommandMapper->getGlobalAction(code);
+            }
+            else if (command == "freeflight_mode")
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == "reset_camera")
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == "toggle_view_mode")
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper->getMovement(evt.key);
+
+                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL && !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo->getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo->doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode->getParent() == NULL)
+        {
+            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()->setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}



From blakharaz at mail.berlios.de  Sat Dec  6 15:26:41 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 6 Dec 2008 15:26:41 +0100
Subject: [Dsa-hl-svn] r4641 - modules/regressiontest/scripts/maps
Message-ID: <200812061426.mB6EQfgp032194@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-06 15:26:40 +0100 (Sat, 06 Dec 2008)
New Revision: 4641

Modified:
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
Even less LeP

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2008-12-06 14:24:35 UTC (rev 4640)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2008-12-06 14:26:40 UTC (rev 4641)
@@ -11,7 +11,7 @@
 
 $SCRIPT.log("Prepare hero for being the active character")
 $hero = $GOM.getGameObject(10);
-$hero.modifyLe(-20);
+$hero.modifyLe(-28);
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")



From timm at mail.berlios.de  Sat Dec  6 15:39:20 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 6 Dec 2008 15:39:20 +0100
Subject: [Dsa-hl-svn] r4642 - in rl/branches/persistence: ai/include
	core/include core/src rules/include rules/src ui/src
Message-ID: <200812061439.mB6EdK40000281@sheep.berlios.de>

Author: timm
Date: 2008-12-06 15:39:04 +0100 (Sat, 06 Dec 2008)
New Revision: 4642

Modified:
   rl/branches/persistence/ai/include/FuzzyStateMachine.h
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/src/PlayAnimationJob.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/rules/include/RulesPrerequisites.h
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/ui/src/MovementControlState.cpp
Log:
merged from trunk

Modified: rl/branches/persistence/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/branches/persistence/ai/include/FuzzyStateMachine.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/ai/include/FuzzyStateMachine.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -1,167 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __RlAI_FuzzyStateMachine_H__
-#define __RlAI_FuzzyStateMachine_H__
-#include <list>
-#include "AiPrerequisites.h"
-#include "FuzzyState.h"
-#include "ScriptWrapper.h"
-
-namespace rl
-{
-	/** manages a set of FuzzyState objects 
-	 */
-	template <class Controller> class FuzzyStateMachine :
-		public FuzzyState<Controller>
-	{
-	public:
-		//! typedefinition for pointer to a FuzzyState
-		typedef FuzzyState<Controller>* FuzzyStatePtr;
-
-		/** Constructor
-		 * sets parent and controller for the FuzzyStateMachine
-		 * @param parent gives the parent FuzzyState object
-		 * @param controller sets the controller object
-		 */
-		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
-			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
-
-		/** destructor.
-		 * removes internally stored Fuzzystate objects
-		 */
-		virtual ~FuzzyStateMachine(void)
-		{
-			clearStates();
-		}
-
-		/** adds a FuzzyState object
-		 * @param state a FuzzyState object to add.
-		 */
-		virtual void addState(FuzzyStatePtr state)
-		{
-			mStates.push_back(State(false, state));
-            ScriptWrapper::getSingleton().owned( state );
-		}
-		/** removes all stored FuzzyState objects
-		 */
-        virtual void clearStates()
-		{
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.begin(); ++itr)
-			{
-                ScriptWrapper::getSingleton().disowned( itr->second );
-				delete itr->second;
-			}
-			mStates.clear();
-		}
-
-		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
-		 * So always return false (no).
-		 * @returns false
-		 */
-		virtual bool isActive(FuzzyStatePtr state)
-		{
-			return false; 
-		}
-		/** reset function for resetting the FuzzyStateMachine
-		 */
-		virtual void reset(){}
-
-		/** sets the maximum number of concurrently active states.
-		 * @param count maximum number of concurrently active states.
-		 */
-		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
-		/** fetches the maximum number of concurrently active states.
-		 * @param int returns the maximum number of concurrently active states.
-		 */
-		virtual int getMaxActivity() { return mMaxActiveStates; }
-
-		/** calculates the activation value.
-		 * @returns float containing the calculated activation value.
-		 */
-		float calculateActivation(void){ return 0.0f; }
-
-		/** initializes the fuzzy state.
-		 */
-		virtual void init(){}
-		/** should activate the fuzzy state.
-		 */
-		virtual void activate(){}
-		/** deactivates fuzzy state.
-		 */
-		virtual void deactivate(){}
-		/** tells the fuzzy state machine to update for the elapsed time.
-		 * For each stored FuzzyState the activation is calculated and
-		 * testified whether it activates the state or not. When a state
-		 * is active its update function is called with the elapsed time.
-		 * @param elapsedtime gives the elapsed time as a float
-		 */
-		virtual void update(const float elapsedTime)
-		{
-			if(mStates.empty())
-				return;
-
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.end(); ++itr)
-			{
-				bool isActive = (itr->second->calculateActivation() > 0);
-				if(isActive)
-				{
-				//  if state is already active, update it, otherwise activate it
-					if(itr->first)
-					{
-						itr->second->update(elapsedTime);
-					}
-					else
-					{
-						itr->second->activate();
-						itr->first = true;
-						// maybe call update here, too
-					}
-				}
-				else
-				{
-				//	if state was active, deactivate it, otherwise do nothing
-					if(itr->first)
-					{
-						itr->second->deactivate();
-						itr->first = false;
-					}	
-				}
-			}
-		}
-
-
-	protected:
-		//! maximum number of active states
-		int mMaxActiveStates;
-		/** typedefinition for active/inactive and FuzzyState objects.
-		 * When the boolean is true, the state is active, otherwise not
-		 */
-		typedef std::pair<bool, FuzzyStatePtr> State;
-		//! defines a double linked list of states
-		typedef std::list<State> StateList;
-		//! the double linked list of stored FuzzyState objects
-		StateList mStates;
-	};
-
-/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
-	{
-
-	}
-*/
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __RlAI_FuzzyStateMachine_H__
+#define __RlAI_FuzzyStateMachine_H__
+#include <list>
+#include "AiPrerequisites.h"
+#include "FuzzyState.h"
+#include "ScriptWrapper.h"
+
+namespace rl
+{
+	/** manages a set of FuzzyState objects 
+	 */
+	template <class Controller> class FuzzyStateMachine :
+		public FuzzyState<Controller>
+	{
+	public:
+		//! typedefinition for pointer to a FuzzyState
+		typedef FuzzyState<Controller>* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
+		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
+			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
+
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
+		virtual ~FuzzyStateMachine(void)
+		{
+			clearStates();
+		}
+
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
+		virtual void addState(FuzzyStatePtr state)
+		{
+			mStates.push_back(State(false, state));
+            ScriptWrapper::getSingleton().owned( state );
+		}
+		/** removes all stored FuzzyState objects
+		 */
+        virtual void clearStates()
+		{
+			for(typename StateList::iterator itr = mStates.begin(); itr != mStates.end(); ++itr)
+			{
+                FuzzyStatePtr state = itr->second;
+                ScriptWrapper::getSingleton().disowned( state );
+				delete state;
+			}
+			mStates.clear();
+		}
+
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
+		virtual bool isActive(FuzzyStatePtr state)
+		{
+			return false; 
+		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
+		virtual void reset(){}
+
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
+		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
+		virtual int getMaxActivity() { return mMaxActiveStates; }
+
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
+		float calculateActivation(void){ return 0.0f; }
+
+		/** initializes the fuzzy state.
+		 */
+		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
+		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
+		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
+		virtual void update(const float elapsedTime)
+		{
+			if(mStates.empty())
+				return;
+
+			typename StateList::iterator itr = mStates.begin();
+			for(; itr != mStates.end(); ++itr)
+			{
+				bool isActive = (itr->second->calculateActivation() > 0);
+				if(isActive)
+				{
+				//  if state is already active, update it, otherwise activate it
+					if(itr->first)
+					{
+						itr->second->update(elapsedTime);
+					}
+					else
+					{
+						itr->second->activate();
+						itr->first = true;
+						// maybe call update here, too
+					}
+				}
+				else
+				{
+				//	if state was active, deactivate it, otherwise do nothing
+					if(itr->first)
+					{
+						itr->second->deactivate();
+						itr->first = false;
+					}	
+				}
+			}
+		}
+
+
+	protected:
+		//! maximum number of active states
+		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
+		typedef std::pair<bool, FuzzyStatePtr> State;
+		//! defines a double linked list of states
+		typedef std::list<State> StateList;
+		//! the double linked list of stored FuzzyState objects
+		StateList mStates;
+	};
+
+/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
+	{
+
+	}
+*/
+}
+#endif

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -34,6 +34,7 @@
 
 		typedef std::map<int, SaveGameFile*> SaveGameEntryMap;
 
+		void updateFileList();
 		SaveGameEntryMap listSaveGames() const;
 		SaveGameEntryMap listSaveGames(const CeGuiString &moduleId) const;
 		bool SaveGameExists(const CeGuiString &name, const CeGuiString &moduleId);
@@ -43,9 +44,13 @@
         virtual void parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName);
         virtual Ogre::Real getLoadingOrder(void) const;
 
-		void createNewSaveGame();
+		SaveGameFile* createNewSaveGame();
+		void deleteSaveGame(int fileId);
+		void deleteSaveGame(SaveGameFile* save);
 		void writeSaveGame(int fileId);
+		void writeSaveGame(SaveGameFile* save);
 		void readSaveGame(int fileId);
+		void readSaveGame(SaveGameFile* save);
 
 		int getHighestSaveGameNumber();
 	protected:

Modified: rl/branches/persistence/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -73,26 +73,26 @@
             {
                 mo->stopAllAnimationsExcept(mAnimName);
             }                
-            
-            if (mo->hasAnimation(mAnimName))
+            
+            if (mo->hasAnimation(mAnimName))
             {
-                if (mDuration > 0)
-                {
-                    mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
-                    mTimeToGo = mDuration;
-                    mAnimationRunning = true;
-                }
-                else
-                {
-                    mAnimation = mo->startAnimation(mAnimName, 1.0f, mLoops);
-                    mTimeToGo = mAnimation->getLength() * (float)mLoops;
-                    mAnimationRunning = true;
-                }
+                if (mDuration > 0)
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation->getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
             }
-            else 
+            else 
             {
-                mAnimation = NULL;
-                mTimeToGo = 0;
+                mAnimation = NULL;
+                mTimeToGo = 0;
             }
         }
 
@@ -119,4 +119,4 @@
 
         return false;
     }
-}
+}
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -68,6 +68,7 @@
 		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),
 			WriteableDataStreamPtr(dynamic_cast<WriteableDataStream*>(stream.get())));
 		mReader.parseSaveGameFileHeader(file);
+		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream->getName()) > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
 		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;
 	}
 
@@ -126,4 +127,57 @@
 		}
 		return NULL;
 	}
+
+	void SaveAbleSerializer::updateFileList()
+	{
+		Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup("SaveGameFiles");
+
+		SaveGameEntryMap::iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			delete iter->second;
+		}
+
+		mSaveGameFiles.clear();
+
+		Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGameFiles");
+	}
+
+
+///---------------------------------------------------------------
+
+
+	SaveGameFile* SaveAbleSerializer::createNewSaveGame()
+	{
+		return NULL;
+	}
+
+	void SaveAbleSerializer::deleteSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::deleteSaveGame(SaveGameFile* save)
+	{
+	}
+
+	void SaveAbleSerializer::writeSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::writeSaveGame(SaveGameFile* save)
+	{
+	}
+
+	void SaveAbleSerializer::readSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::readSaveGame(SaveGameFile* save)
+	{
+	}
+
+	int SaveAbleSerializer::getHighestSaveGameNumber()
+	{
+		return mHighestSaveGameNumber;
+	}
 }

Modified: rl/branches/persistence/rules/include/RulesPrerequisites.h
===================================================================
--- rl/branches/persistence/rules/include/RulesPrerequisites.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/rules/include/RulesPrerequisites.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -91,6 +91,7 @@
 
 	typedef std::vector<Action*> ActionVector;
 	
-	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString actionName);
+	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString& actionName);
+	ActionVector::const_iterator findAction(ActionVector::const_iterator& begin, ActionVector::const_iterator& end, const CeGuiString& actionName);
 }
 #endif

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -486,7 +486,7 @@
                         }
                         else if (!target->getActiveWeapon()->isNatural() && actor->getActiveWeapon()->isNatural())
                         {
-                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            doDamage(jobSetAnims, DMG_HALF, target, actor);
                             rollDamage = DMG_NONE;
                         }
                         else
@@ -522,7 +522,7 @@
 			target->doGetroffen(jobSetAnims);
 		}
 		
-        doDamage(jobSetDamage, rollDamage, actor, target);
+        doDamage(jobSetAnims, rollDamage, actor, target);
 	}
     
     void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)

Modified: rl/branches/persistence/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence/ui/src/MovementControlState.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/ui/src/MovementControlState.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -1,1535 +1,1535 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "MovementControlState.h"
-
-#include <utility>
-
-#include "AbstractMovement.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "DebugWindow.h"
-#include "Exception.h"
-#include "GameObjectManager.h"
-#include "InputManager.h"
-#include "Logger.h"
-#include "MeshObject.h"
-#include "MeshAnimation.h"
-#include "MovementControlState.h"
-#include "PhysicsManager.h"
-#include "PhysicsMaterialRaycast.h"
-#include "PhysicalThing.h"
-#include "RulesMessages.h"
-#include "World.h"
-#include "LineSetPrimitive.h"
-#include "WindowFactory.h"
-#include "AnimationManager.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#include <numeric>
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(
-            mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
-            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
-            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-        {
-            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->freeze();
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL && go->isHighlighted())
-        {
-            go->setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear())
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen->calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement & TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement & TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw <= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw >= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw > Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw <= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw < Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw >= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement & MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController->setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement & MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement & MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController->setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_JUMP && 
-                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController->setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement & MOVE_RUN_LOCK )
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement & MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement & MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController->setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController->setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement & MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController->setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement & MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController->setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance < mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance > mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr?e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-        AxisAlignedBox aabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode->lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor->getPosition() - charPos).length();
-            cameraNode->lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody->getCollision(), camOri, camPos,
-                    mCharBody->getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor->setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor->setVisible(true);
-            }
-        }
-        mCameraActor->setOrientation(cameraNode->getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
-            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor->_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node->getPosition();
-        Quaternion egal;
-        mCamBody->getPositionOrientation(bodpos,egal);
-        ss
-            << "scene node : " << playpos << std::endl
-            << "player velocity : " << -mController->getVelocity().z << std::endl
-            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
-            << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera pos : " << bodpos << std::endl
-            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
-            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr?e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr?e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr?e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta < buffSize )
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta >= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody->getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody->getMassMatrix(mass, inertia);
-
-            //mCamBody->setPositionOrientation(newCamPos, camOri);
-            mCamBody->setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody->setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr?e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &&
-                desiredDistance > mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance > desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
-        {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
-            if (creature &&
-				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
-				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL && oldGo != newGo)
-        {
-            oldGo->setHighlighted(false);
-        }
-
-        if (newGo != NULL && newGo != oldGo)
-        {
-            newGo->setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
-        {
-            newGo->doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
-        }
-        catch(...)
-        {
-            aabb = charMesh->getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr?e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        aab = mesh->getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh->getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr?e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor->setVisible(false);
-        else
-            mCharacterActor->setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, "Camera resetted.");
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
-            if (command == "")
-            {
-                // No. So try global actions.
-                command = mCommandMapper->getGlobalAction(code);
-            }
-            else if (command == "freeflight_mode")
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == "reset_camera")
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == "toggle_view_mode")
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper->getMovement(evt.key);
-
-                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper->getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL && !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo->getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo->doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode->getParent() == NULL)
-        {
-            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()->setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "MovementControlState.h"
+
+#include <utility>
+
+#include "AbstractMovement.h"
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "DebugWindow.h"
+#include "Exception.h"
+#include "GameObjectManager.h"
+#include "InputManager.h"
+#include "Logger.h"
+#include "MeshObject.h"
+#include "MeshAnimation.h"
+#include "MovementControlState.h"
+#include "PhysicsManager.h"
+#include "PhysicsMaterialRaycast.h"
+#include "PhysicalThing.h"
+#include "RulesMessages.h"
+#include "World.h"
+#include "LineSetPrimitive.h"
+#include "WindowFactory.h"
+#include "AnimationManager.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#include <numeric>
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mObstractedFrameCount(0),
+        mObstractedTime(0.0f),
+        mCameraJammedFrameCount(0),
+        mCameraJammedTime(0.0f),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(20),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(
+            mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb = charMesh->getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
+            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
+            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
+        {
+            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL && go->isHighlighted())
+        {
+            go->setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+
+
+        // Do we need to reset the Camera?
+        Vector3 charPos = mCharacterActor->getWorldPosition();
+        Quaternion charOri = mCharacterActor->getWorldOrientation();
+        //mCharBody->getPositionOrientation(charPos, charOri);
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+
+        float maxdistance;
+        if (mViewMode == VM_FIRST_PERSON)
+            maxdistance = 0.25;
+        else
+            maxdistance = 1.3f * mDesiredDistance + 1.4f;
+
+        // if we have more than 250ms and at least five frames with camera distance higher
+        // than desired distance, reset camera
+        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
+        {
+            mCameraJammedTime += elapsedTime;
+            ++mCameraJammedFrameCount;
+        }
+        else
+        {
+            mCameraJammedTime = 0.0f;
+            mCameraJammedFrameCount = 0;
+        }
+
+        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
+        {
+            mCameraJammedFrameCount = 0;
+            resetCamera();
+        }
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen->calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement & TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement & TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw <= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw >= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw > Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw <= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw < Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw >= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement & MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController->setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement & MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement & MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController->setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_JUMP && 
+                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController->setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement & MOVE_RUN_LOCK )
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement & MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement & MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController->setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement & MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController->setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement & MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController->setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance < mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance > mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr?e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox aabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode->lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode->lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor->getPosition() - charPos).length();
+            cameraNode->lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody->getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody->getCollision(), camOri, camPos,
+                    mCharBody->getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor->setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor->setVisible(true);
+            }
+        }
+        mCameraActor->setOrientation(cameraNode->getOrientation());
+    }
+
+    // -------------------------------------------------------------
+    // character collision moved to CreatureController(Manager)
+    int MovementControlState::userProcess()
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
+            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
+        {
+            return 0;
+        }
+
+        setContactSoftness(0.8f);
+        setContactElasticity(0.0f);
+        mLastCameraCollision = 0;
+
+        return 1;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+        Real timestep = world->getTimeStep();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor->_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node->getPosition();
+        Quaternion egal;
+        mCamBody->getPositionOrientation(bodpos,egal);
+        ss
+            << "scene node : " << playpos << std::endl
+            << "player velocity : " << -mController->getVelocity().z << std::endl
+            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
+            << "camera posder : " << static_cast<Camera*>(
+                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
+            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera pos : " << bodpos << std::endl
+            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
+            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr?e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr?e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr?e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos,
+                charPos,
+                true);
+
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+                mCharacterOccludedTime = 0;
+
+            if( infoCastOptPos.mBody )
+            {
+                if( !infoCastChar.mBody ) // Character noch im Blickfeld
+                {
+                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                    // und erreichbar ist
+                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                    RaycastInfo infoCastNewPos;
+                    Real delta = lenToOptCamPos/2.0f;
+                    Vector3 temp = charPos + delta * normToOptCamPos;
+                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                    {
+                        infoCastNewPos = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                            temp,
+                            true);
+                        delta = delta/2.0f;
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                        {
+                            temp = temp - delta * normToOptCamPos;
+                        }
+                        else // kein Hindernis gefunden, weiter von Char weg
+                        {
+                            temp = temp + delta * normToOptCamPos;
+                        }
+                    }
+
+                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                    temp = temp - 0.05 * normToOptCamPos;
+                    // Groesse der Kamera einbeziehen
+                    optimalCamPos = temp - camRadius * normToOptCamPos;
+                    // so ab hier kann ganz normal weiter gerechnet werden!
+                }
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
+                // und durch "Geraden" miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta < buffSize )
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta >= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody->getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody->getMassMatrix(mass, inertia);
+
+            //mCamBody->setPositionOrientation(newCamPos, camOri);
+            mCamBody->setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody->setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+
+            // Kamera-Gr?e beziehen
+            CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+            AxisAlignedBox aabb = ogreCam->getDefaultSize();
+            // Radius berechnen
+            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
+            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
+            // unds eigentlich ne kugel ist!
+
+
+
+            Vector3 startRay[6], endRay[6];
+
+            Real sinPitchRad = Math::Sin(mPitch) * radius;
+            Real cosPitchRad = Math::Cos(mPitch) * radius;
+            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
+
+            startRay[0] = charPos;
+            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
+                                      // dadurch kann aber sichergestellt
+                                      // werden, dass kein Objekt direkt
+                                      // hinter dem Helden bersehen wird
+            startRay[1] = charPos + radiusOffset;
+            endRay[1] = targetCamPos + radiusOffset;
+            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
+            startRay[2] = charPos + radiusOffset;
+            endRay[2] = targetCamPos + radiusOffset;
+            startRay[3] = charPos - radiusOffset;
+            endRay[3] = targetCamPos - radiusOffset;
+            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
+            startRay[4] = charPos + radiusOffset;
+            endRay[4] = targetCamPos + radiusOffset;
+            startRay[5] = charPos - radiusOffset;
+            endRay[5] = targetCamPos - radiusOffset;
+
+            const OgreNewt::MaterialID* materialId =
+                mCharBody->getMaterialGroupID();
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 diff = targetCamPos - charPos;
+            bool CollisionFound = false;
+            for( int i = 0; i < 6; i++ )
+            {
+                RaycastInfo info = mRaycast->execute(
+                    world,
+                    materialId,
+                    startRay[i],
+                    endRay[i],
+                    true);
+
+                if( info.mBody && info.mBody != mCamBody )
+                {
+                    CollisionFound = true;
+                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
+                    if( newdiff.squaredLength() < diff.squaredLength() )
+                        diff = newdiff;
+                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
+                    {
+                        if( diff.squaredLength() < radius*radius )
+                        {
+                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
+                            break;
+                        }
+                    }
+                }
+            }
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &&
+                desiredDistance > mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance > desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i < end; ++i)
+        {
+            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
+            if (creature &&
+				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
+				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        //InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL && oldGo != newGo)
+        {
+            oldGo->setHighlighted(false);
+        }
+
+        if (newGo != NULL && newGo != oldGo)
+        {
+            newGo->setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
+        {
+            newGo->doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
+        }
+        catch(...)
+        {
+            aabb = charMesh->getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr?e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        aab = mesh->getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh->getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr?e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor->setVisible(false);
+        else
+            mCharacterActor->setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, "Camera resetted.");
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
+            if (command == "")
+            {
+                // No. So try global actions.
+                command = mCommandMapper->getGlobalAction(code);
+            }
+            else if (command == "freeflight_mode")
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == "reset_camera")
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == "toggle_view_mode")
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper->getMovement(evt.key);
+
+                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL && !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo->getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo->doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode->getParent() == NULL)
+        {
+            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()->setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}



From timm at mail.berlios.de  Sat Dec  6 20:41:19 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 6 Dec 2008 20:41:19 +0100
Subject: [Dsa-hl-svn] r4643 - in rl/branches/persistence: common/include
	core/src ui/src
Message-ID: <200812061941.mB6JfJhr018102@sheep.berlios.de>

Author: timm
Date: 2008-12-06 20:41:11 +0100 (Sat, 06 Dec 2008)
New Revision: 4643

Modified:
   rl/branches/persistence/common/include/WriteableDataStream.h
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
Log:
writing dummy save game into file

Modified: rl/branches/persistence/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-06 14:39:04 UTC (rev 4642)
+++ rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-06 19:41:11 UTC (rev 4643)
@@ -54,25 +54,25 @@
 
         ~WriteableFileStreamDataStream();
 
-		size_t read(void* buf, size_t count);
+		virtual size_t read(void* buf, size_t count);
 
-        size_t readLine(char* buf, size_t maxCount, const Ogre::String& delim = "\n");
+        virtual size_t readLine(char* buf, size_t maxCount, const Ogre::String& delim = "\n");
 		
-		void skip(long count);
+		virtual void skip(long count);
 	
-	    void seek( size_t pos );
+	    virtual void seek( size_t pos );
 
-		size_t tell(void) const;
+		virtual size_t tell(void) const;
 
-	    bool eof(void) const;
+	    virtual bool eof(void) const;
 
-        void close(void);
+        virtual void close(void);
 
-        std::fstream* getFStream();
+        virtual std::fstream* getFStream();
 
-        void write(void* buf, size_t count);
+        virtual void write(void* buf, size_t count);
 
-        void flush();
+        virtual void flush();
     };
 
     typedef Ogre::SharedPtr<WriteableFileStreamDataStream> WriteableFileStreamDataStreamPtr;

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 14:39:04 UTC (rev 4642)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 19:41:11 UTC (rev 4643)
@@ -65,8 +65,7 @@
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
 		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
-		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),
-			WriteableDataStreamPtr(dynamic_cast<WriteableDataStream*>(stream.get())));
+		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)(WriteableDataStream*)stream.get());
 		mReader.parseSaveGameFileHeader(file);
 		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream->getName()) > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
 		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;
@@ -149,6 +148,8 @@
 
 	SaveGameFile* SaveAbleSerializer::createNewSaveGame()
 	{
+		//SaveGameFile* file = new SaveGameFile(NULL);
+		updateFileList();
 		return NULL;
 	}
 
@@ -158,22 +159,31 @@
 
 	void SaveAbleSerializer::deleteSaveGame(SaveGameFile* save)
 	{
+		//TODO!!!!!!111elf
 	}
 
 	void SaveAbleSerializer::writeSaveGame(int fileId)
 	{
+		if(mSaveGameFiles.find(fileId) != mSaveGameFiles.end())
+			writeSaveGame(mSaveGameFiles[fileId]);
 	}
 
 	void SaveAbleSerializer::writeSaveGame(SaveGameFile* save)
 	{
+		if(save != NULL)
+			writeToSaveGameFile(save);
 	}
 
 	void SaveAbleSerializer::readSaveGame(int fileId)
 	{
+		if(mSaveGameFiles.find(fileId) != mSaveGameFiles.end())
+			readSaveGame(mSaveGameFiles[fileId]);
 	}
 
 	void SaveAbleSerializer::readSaveGame(SaveGameFile* save)
 	{
+		if(save != NULL)
+			readFromSaveGameFile(save);
 	}
 
 	int SaveAbleSerializer::getHighestSaveGameNumber()

Modified: rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-06 14:39:04 UTC (rev 4642)
+++ rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-06 19:41:11 UTC (rev 4643)
@@ -137,7 +137,15 @@
 
         if(filename != "")
         {
-			if(SaveAbleSerializer::getSingleton().SaveGameExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()));
+			if(SaveAbleSerializer::getSingleton().SaveGameExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
+			{
+				SaveAbleSerializer::getSingleton().writeSaveGame(SaveAbleSerializer::getSingleton().getSaveGame(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()));
+			}
+			else
+			{
+			}
+			SaveAbleSerializer::getSingleton().updateFileList();
+			listSaveGames();
         }
         else
         {



From timm at mail.berlios.de  Sun Dec  7 21:22:27 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 7 Dec 2008 21:22:27 +0100
Subject: [Dsa-hl-svn] r4644 - in rl/branches/persistence: common/include
	common/src core core/include core/src rules/include rules/src
Message-ID: <200812072022.mB7KMRPV001489@sheep.berlios.de>

Author: timm
Date: 2008-12-07 21:22:18 +0100 (Sun, 07 Dec 2008)
New Revision: 4644

Added:
   rl/branches/persistence/core/include/GlobalData.h
   rl/branches/persistence/core/src/GlobalData.cpp
Modified:
   rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
   rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
   rl/branches/persistence/core/RlCore2005.vcproj
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/include/SaveAbleFactory.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/src/SaveAbleCollection.cpp
   rl/branches/persistence/core/src/SaveAbleFactory.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/rules/include/QuestBook.h
   rl/branches/persistence/rules/src/QuestBook.cpp
Log:
- working on SaveAbleCollection, SaveAbleFactory and SaveAbleManager
- tried to fix WriteableDataStreamFormatTarget
- introducing GlobalData

Modified: rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -24,8 +24,8 @@
     {
     public:
         WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);
-        void writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter);
-        void flush ();
+        virtual void writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter);
+        virtual void flush ();
     protected:
         WriteableDataStreamPtr mStream;
     };

Modified: rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -27,12 +27,22 @@
 
     void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)
     {
-        mStream->write((char*)toWrite, count);
+        if(static_cast<WriteableDataStream*>(mStream.get()))
+        {
+            mStream->write((char*)toWrite, count);
+        }
+        else
+            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");
     }
 
     void WriteableDataStreamFormatTarget::flush ()
     {
-        mStream->flush();
+        if(static_cast<WriteableDataStream*>(mStream.get()))
+        {
+            mStream->flush();
+        }
+        else
+            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");
     }
 }
 

Modified: rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -72,6 +72,7 @@
 
     DataStreamPtr WriteableFileSystemArchive::open(const String& filename) const
     {
+        LOG_MESSAGE(Logger::COMMON, "Opening WriteableFileStreamDataStream: " + filename);
         String full_path = concatenate_path(mName, filename);
 
         // Always open in binary mode

Modified: rl/branches/persistence/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence/core/RlCore2005.vcproj	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/RlCore2005.vcproj	2008-12-07 20:22:18 UTC (rev 4644)
@@ -663,6 +663,10 @@
 				Name="SaveGame"
 				>
 				<File
+					RelativePath=".\include\GlobalData.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\SaveAble.h"
 					>
 				</File>
@@ -1012,6 +1016,10 @@
 				Name="SaveGame"
 				>
 				<File
+					RelativePath=".\src\GlobalData.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\SaveAble.cpp"
 					>
 				</File>

Added: rl/branches/persistence/core/include/GlobalData.h
===================================================================
--- rl/branches/persistence/core/include/GlobalData.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/include/GlobalData.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -0,0 +1,37 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __GLOBALDATA_H__
+#define __GLOBALDATA_H__
+
+#include "SaveAbleCollection.h"
+
+namespace rl
+{
+    class GlobalData : public SaveAbleCollection
+    {
+    public:
+        GlobalData(const CeGuiString &id);
+        virtual ~GlobalData();
+        virtual void attachSaveAble(SaveAblePtr saveAble);
+		virtual void deattachSaveAble(SaveAblePtr saveAble);
+		virtual void deattachSaveAble(const CeGuiString &id);
+		virtual void deattachAllSaveAbles();
+    };
+}
+
+
+#endif
\ No newline at end of file

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -23,14 +23,17 @@
 	class _RlCoreExport SaveAbleCollection
 	{
 	public:
+        typedef std::map<CeGuiString, SaveAblePtr> SaveAbleMap;
+
 		SaveAbleCollection(const CeGuiString &id);
 		virtual void attachSaveAble(SaveAblePtr saveAble) = 0;
 		virtual void deattachSaveAble(SaveAblePtr saveAble) = 0;
 		virtual void deattachSaveAble(const CeGuiString &id) = 0;
 		virtual void deattachAllSaveAbles() = 0;
 		CeGuiString getId() const;
+        SaveAbleMap getSaveAbles() const;
 	protected:
-		std::map<int, SaveAblePtr> mSaveAbles;
+		SaveAbleMap mSaveAbles;
 		CeGuiString mId;
 	};
 

Modified: rl/branches/persistence/core/include/SaveAbleFactory.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -27,6 +27,7 @@
 	public:
 		virtual SaveAblePtr createSaveAble(const CeGuiString &id, PropertyRecordPtr params) = 0;
 		virtual void removeSaveAble(const CeGuiString &id) = 0;
+        virtual PropertyRecordPtr getCreationParams(const CeGuiString &id) const = 0;
 	};
 
 	class _RlCoreExport SaveAbleFactoryPool : public Ogre::Singleton<SaveAbleFactoryPool>

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -29,7 +29,6 @@
 	protected:
 		typedef std::map<CeGuiString, SaveAbleCollection*> SaveAbleCollectionMap;
 	public:
-		typedef std::map<CeGuiString, SaveAblePtr> SaveAbleMap;
 		typedef std::map<CeGuiString, PropertyRecordPtr> SaveAbleStateMap;
 		void saveState();
 		void loadState();
@@ -39,8 +38,6 @@
 		void removeSaveAble(SaveAblePtr save);
 		void removeSaveAble(const CeGuiString &id);
 		void removeAllSaveAbles();
-		//void attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
-		//void deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
 		
 		SaveAbleCollectionMap getCollections();
 		SaveAbleStateMap getSaveAbleStates();
@@ -49,7 +46,7 @@
 		SaveAbleFactory* getFactory(const CeGuiString &id);
 	protected:
 		SaveAbleStateMap mSaveAbleStates;
-		SaveAbleMap mSaveAbles;
+		//SaveAbleMap mSaveAbles;
 		SaveAbleCollectionMap mSaveAbleCollections;
 
 		void storeSaveAbleStates();

Added: rl/branches/persistence/core/src/GlobalData.cpp
===================================================================
--- rl/branches/persistence/core/src/GlobalData.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/src/GlobalData.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -0,0 +1,61 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h"
+
+#include "GlobalData.h"
+
+namespace rl
+{
+    GlobalData::GlobalData(const CeGuiString &id) : SaveAbleCollection(id)
+    {
+    }
+
+    GlobalData::~GlobalData()
+    {
+        deattachAllSaveAbles();
+    }
+
+    void GlobalData::attachSaveAble(SaveAblePtr saveAble)
+    {
+        SaveAbleMap::const_iterator iter;
+        for(iter = mSaveAbles.begin(); iter != mSaveAbles.end(); iter++)
+        {
+            if(iter->second == saveAble || iter->first == saveAble->getId())
+                return;
+        }
+        mSaveAbles[saveAble->getId()] = saveAble;
+    }
+
+    void GlobalData::deattachSaveAble(SaveAblePtr saveAble)
+    {
+        SaveAbleMap::iterator iter = mSaveAbles.find(saveAble->getId());
+        if(iter->second == saveAble && iter != mSaveAbles.end())
+            mSaveAbles.erase(iter);
+    }
+
+    void GlobalData::deattachSaveAble(const CeGuiString &id)
+    {
+        SaveAbleMap::iterator iter = mSaveAbles.find(id);
+        if(iter != mSaveAbles.end())
+            mSaveAbles.erase(iter);
+    }
+
+    void GlobalData::deattachAllSaveAbles()
+    {
+        mSaveAbles.clear();
+    }
+}
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -29,4 +29,9 @@
 	{
 		return mId;
 	}
+
+    SaveAbleCollection::SaveAbleMap SaveAbleCollection::getSaveAbles() const
+    {
+        return mSaveAbles;
+    }
 }
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -28,13 +28,17 @@
 	{
 		if(mFactories.find(key) != mFactories.end())
 			LOG_ERROR("CORE", "SaveAbleFactory already registered!");
-		mFactories[key] = fac;
+        else
+            mFactories[key] = fac;
 	}
 
 	void SaveAbleFactoryPool::unregisterFactory(const Ogre::String &key)
 	{
 		std::map<Ogre::String,SaveAbleFactory*>::iterator it = mFactories.find(key);
-		mFactories.erase(it);
+        if(it != mFactories.end())            
+            mFactories.erase(it);
+        else
+            LOG_ERROR(Logger::CORE, "SaveAbleFactory is not registered!");
 	}
 
 	void SaveAbleFactoryPool::unregisterFactory(rl::SaveAbleFactory *fac)

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -41,15 +41,7 @@
 	void SaveAbleManager::removeAllSaveAbles()
 	{
 	}
-		
-	/*void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
-	{
-	}*/
-		
-	/*void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
-	{
-	}*/
-		
+
 	void SaveAbleManager::restoreSaveAblesFromStates()
 	{
 	}
@@ -62,16 +54,23 @@
 	{
 		mSaveAbleStates.clear();
 
-		SaveAbleMap::const_iterator it;
-		for(it = mSaveAbles.begin(); it != mSaveAbles.end(); it++)
-		{
-			PropertyRecordPtr Properties;
-			Properties->setProperty("Properties", it->second->getAllProperties()->toPropertyMap());
+        SaveAbleCollectionMap::const_iterator iter_collection;
+        for(iter_collection = mSaveAbleCollections.begin(); iter_collection != mSaveAbleCollections.end(); iter_collection++)
+        {
+            SaveAbleCollection::SaveAbleMap saveAbles = iter_collection->second->getSaveAbles();
+            
+            SaveAbleCollection::SaveAbleMap::const_iterator iter_saveAbles;
+            for(iter_saveAbles = saveAbles.begin(); iter_saveAbles != saveAbles.end(); iter_saveAbles++)
+            {
+                PropertyRecordPtr properties;
+                properties->setProperty("Properties", iter_saveAbles->second->getAllProperties()->toPropertyMap());
 
-			// Ein dickes TODO ------
-			Properties->setProperty("CreationProperties", Property());
-			Properties->setProperty("Factory", Property("ID der Factory"));
-			mSaveAbleStates[it->first] = Properties;
-		}
+                //Hier fehlt noch einiges!!!!
+                properties->setProperty("Collection", iter_collection->second->getId());
+                properties->setProperty("Factory", Property("ID der Factory"));
+                properties->setProperty("CreationParams", Property());
+                mSaveAbleStates[iter_saveAbles->first] = properties;
+            }
+        }
 	}
 }

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -65,7 +65,7 @@
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
 		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
-		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)(WriteableDataStream*)stream.get());
+		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)static_cast<WriteableFileStreamDataStream*>(stream.get()));
 		mReader.parseSaveGameFileHeader(file);
 		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream->getName()) > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
 		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;

Modified: rl/branches/persistence/rules/include/QuestBook.h
===================================================================
--- rl/branches/persistence/rules/include/QuestBook.h	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/rules/include/QuestBook.h	2008-12-07 20:22:18 UTC (rev 4644)
@@ -69,6 +69,7 @@
 	 */
 	SaveAblePtr createSaveAble(const CeGuiString &id, PropertyRecordPtr params);
 	virtual void removeSaveAble(const CeGuiString &id);
+    virtual PropertyRecordPtr getCreationParams(const CeGuiString &id) const;
 
     /**
      *  Adds a journal entry to the quest book.

Modified: rl/branches/persistence/rules/src/QuestBook.cpp
===================================================================
--- rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-06 19:41:11 UTC (rev 4643)
+++ rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-07 20:22:18 UTC (rev 4644)
@@ -96,6 +96,11 @@
 	{
 	}
 
+    PropertyRecordPtr QuestBook::getCreationParams(const CeGuiString &id) const
+    {
+        return PropertyRecordPtr();
+    }
+
     void QuestBook::_fireQuestBookChanged(Quest *quest, int reason)
     {
 	    QuestEvent* evt = new QuestEvent(this, reason);



From timm at mail.berlios.de  Sun Dec 14 15:31:56 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 14 Dec 2008 15:31:56 +0100
Subject: [Dsa-hl-svn] r4645 - modules/ruchin/models
Message-ID: <200812141431.mBEEVuiA026719@sheep.berlios.de>

Author: timm
Date: 2008-12-14 15:31:51 +0100 (Sun, 14 Dec 2008)
New Revision: 4645

Modified:
   modules/ruchin/models/Stadtwache.material
Log:
fixed material file

Modified: modules/ruchin/models/Stadtwache.material
===================================================================
--- modules/ruchin/models/Stadtwache.material	2008-12-07 20:22:18 UTC (rev 4644)
+++ modules/ruchin/models/Stadtwache.material	2008-12-14 14:31:51 UTC (rev 4645)
@@ -1,7 +1,7 @@
 import Basic_Vertex_Shader from Basic_Vertex_Shader.program
 import Ruchin/base from Ruchintest.material
 import Ruchin_Stadtmauer/Dach from Stadtmauer.material
-import Ruchin_Stadtmauer/Wand from __unkown_material_file__
+import Ruchin_Stadtmauer/Wand from Stadtmauer.material
 
 material Stadtwache/Wand : Ruchin_Stadtmauer/Wand
 {



From timm at mail.berlios.de  Sun Dec 14 23:25:06 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 14 Dec 2008 23:25:06 +0100
Subject: [Dsa-hl-svn] r4646 - in modules/ruchin: maps scripts scripts/maps
Message-ID: <200812142225.mBEMP6Uu031495@sheep.berlios.de>

Author: timm
Date: 2008-12-14 23:24:57 +0100 (Sun, 14 Dec 2008)
New Revision: 4646

Added:
   modules/ruchin/maps/Ruchin_houses.rlmap.xml
   modules/ruchin/maps/ruchin.rlmap.xml
   modules/ruchin/maps/ruchin.rlscene
Removed:
   modules/ruchin/maps/Ruchin_houses.scene.xml
   modules/ruchin/maps/ruchin.scene
Modified:
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
   modules/ruchin/scripts/maps/maptest.rb
   modules/ruchin/scripts/moduleconfig.rb
Log:
new scene format of ruchin

Copied: modules/ruchin/maps/Ruchin_houses.rlmap.xml (from rev 4644, modules/ruchin/maps/Ruchin_houses.scene.xml)


Property changes on: modules/ruchin/maps/Ruchin_houses.rlmap.xml
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: modules/ruchin/maps/Ruchin_houses.scene.xml
===================================================================
--- modules/ruchin/maps/Ruchin_houses.scene.xml	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/maps/Ruchin_houses.scene.xml	2008-12-14 22:24:57 UTC (rev 4646)
@@ -1,178 +0,0 @@
-<scene formatVersion="0.4.0">
-    <nodes>
-<entity name="Ruchin_h_1" meshfile="Ruchin_h_1.mesh">
-<position x="-36.7346" y="-1.74214" z="-80.6494"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_2" meshfile="Ruchin_h_2.mesh">
-<position x="-46.75" y="0.426744" z="-124.241"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_3" meshfile="Ruchin_h_3.mesh">
-<position x="-42.9753" y="-1.06221" z="-100.227"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_4" meshfile="Ruchin_h_4.mesh">
-<position x="-45.9489" y="-0.107363" z="-112.792"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_5" meshfile="Ruchin_h_5.mesh">
-<position x="-23.3157" y="1.59727" z="-134.774"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_6" meshfile="Ruchin_h_6.mesh">
-<position x="-19.3854" y="3.72413" z="-125.555"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_7" meshfile="Ruchin_h_7.mesh">
-<position x="-34.827" y="1.85744" z="-134.22"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_8" meshfile="Ruchin_h_8.mesh">
-<position x="-33.9235" y="1.17716" z="-121.066"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_9" meshfile="Ruchin_h_9.mesh">
-<position x="-29.9153" y="0.163115" z="-106.061"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_h_10" meshfile="Ruchin_h_10.mesh">
-<position x="-23.9525" y="3.24528" z="-114.816"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_i" meshfile="Ruchin_i.mesh">
-<position x="-2.48193" y="2.08122" z="-104.883"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_j" meshfile="Ruchin_j.mesh">
-<position x="43.3627" y="3.85267" z="-104.826"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_o" meshfile="Ruchin_o.mesh">
-<position x="-22.104" y="-0.615151" z="-39.2483"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_w" meshfile="Ruchin_w.mesh">
-<position x="67.945" y="-0.158122" z="-51.3684"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_8" meshfile="Ruchin_r_8.mesh">
-<position x="91.2075" y="3.56148" z="23.0173"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_7" meshfile="Ruchin_r_7.mesh">
-<position x="84.0642" y="2.93498" z="31.3881"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_6" meshfile="Ruchin_r_6.mesh">
-<position x="60.6135" y="1.67732" z="38.6987"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_5" meshfile="Ruchin_r_5.mesh">
-<position x="64.7816" y="-0.204867" z="48.8519"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_4" meshfile="Ruchin_r_4.mesh">
-<position x="70.5042" y="0.21027" z="42.9895"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_3" meshfile="Ruchin_r_3.mesh">
-<position x="63.1021" y="9.60079" z="9.66196"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_2" meshfile="Ruchin_r_2.mesh">
-<position x="61.2059" y="9.56682" z="18.0424"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_1" meshfile="Ruchin_r_1.mesh">
-<position x="49.1976" y="9.86685" z="13.2181"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_p_1" meshfile="Ruchin_p_1.mesh">
-<position x="19.9707" y="1.7878" z="-20.8474"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_p_2" meshfile="Ruchin_p_2.mesh">
-<position x="18.4899" y="0.721264" z="-3.67395"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_p_3" meshfile="Ruchin_p_3.mesh">
-<position x="21.7188" y="1.6745" z="5.96143"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_p_4" meshfile="Ruchin_p_4.mesh">
-<position x="36.5999" y="3.56817" z="1.72206"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_5" meshfile="Ruchin_t_5.mesh">
-<position x="31.3442" y="-0.52218" z="28.9052"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_4" meshfile="Ruchin_t_4.mesh">
-<position x="35.7339" y="2.80352" z="22.5256"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_3" meshfile="Ruchin_t_3.mesh">
-<position x="13.2522" y="-1.01373" z="29.6587"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_2" meshfile="Ruchin_t_2.mesh">
-<position x="6.5219" y="-2.31604" z="36.0502"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_1" meshfile="Ruchin_t_1.mesh">
-<position x="10.1605" y="-0.465297" z="44.5057"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_8" meshfile="Ruchin_n_8.mesh">
-<position x="-3.40638" y="0.118809" z="-68.1982"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_7" meshfile="Ruchin_n_7.mesh">
-<position x="13.1112" y="2.76192" z="-60.7119"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_6" meshfile="Ruchin_n_6.mesh">
-<position x="-0.21451" y="1.94417" z="-52.791"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_5" meshfile="Ruchin_n_5.mesh">
-<position x="11.6031" y="2.21514" z="-49.0058"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_4" meshfile="Ruchin_n_4.mesh">
-<position x="-0.678421" y="-1.7869" z="-38.0685"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_3" meshfile="Ruchin_n_3.mesh">
-<position x="8.57446" y="0.0163641" z="-33.8764"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_2" meshfile="Ruchin_n_2.mesh">
-<position x="0.257071" y="1.31868" z="-22.2147"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_1" meshfile="Ruchin_n_1.mesh">
-<position x="2.59356" y="1.04296" z="-9.59551"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_5" meshfile="Ruchin_m_5.mesh">
-<position x="28.293" y="3.42061" z="-74.0239"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_4" meshfile="Ruchin_m_4.mesh">
-<position x="27.9652" y="1.62184" z="-58.6508"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_3" meshfile="Ruchin_m_3.mesh">
-<position x="42.6957" y="2.10235" z="-51.4972"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_2" meshfile="Ruchin_m_2.mesh">
-<position x="30.9865" y="2.40826" z="-42.7316"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_1" meshfile="Ruchin_m_1.mesh">
-<position x="46.5588" y="5.5831" z="-30.5969"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_8" meshfile="Ruchin_s_8.mesh">
-<position x="-2.75074" y="-0.199522" z="24.1009"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_7" meshfile="Ruchin_s_7.mesh">
-<position x="5.27965" y="-1.2008" z="16.2314"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_6" meshfile="Ruchin_s_6.mesh">
-<position x="-13.3514" y="-1.04859" z="22.7186"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_5" meshfile="Ruchin_s_5.mesh">
-<position x="0.343925" y="-1.33966" z="8.27932"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_3" meshfile="Ruchin_s_3.mesh">
-<position x="-5.80605" y="-0.955266" z="0.876742"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_4" meshfile="Ruchin_s_4.mesh">
-<position x="-16.9548" y="-2.3108" z="12.2247"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_2" meshfile="Ruchin_s_2.mesh">
-<position x="-11.66" y="0.550525" z="-6.81664"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_1" meshfile="Ruchin_s_1.mesh">
-<position x="-19.8759" y="0.0177184" z="-0.887024"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_t_6" meshfile="Ruchin_t_6.mesh">
-<position x="27.452" y="-0.642672" z="20.9355"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_r_9" meshfile="Ruchin_r_9.mesh">
-<position x="83.525" y="6.34115" z="18.7542"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_n_9" meshfile="Ruchin_n_9.mesh">
-<position x="8.16092" y="1.44112" z="-74.2352"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_p_5" meshfile="Ruchin_p_5.mesh">
-<position x="38.134" y="3.33584" z="-13.8649"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_m_6" meshfile="Ruchin_m_6.mesh">
-<position x="38.5894" y="3.78567" z="-64.6336"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Ruchin_s_9" meshfile="Ruchin_s_9.mesh">
-<position x="-8.75225" y="0.0711604" z="31.6625"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-    </nodes>
-</scene>
\ No newline at end of file

Added: modules/ruchin/maps/ruchin.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin.rlmap.xml	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/maps/ruchin.rlmap.xml	2008-12-14 22:24:57 UTC (rev 4646)
@@ -0,0 +1,7 @@
+<scene formatVersion="0.4.0">
+    <nodes>
+<entity name="Ivy" meshfile="Ruchin_ivy_01.mesh">
+<position x="22.5935" y="-2.88005" z="-20.0237"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+    </nodes>
+</scene>
\ No newline at end of file

Added: modules/ruchin/maps/ruchin.rlscene
===================================================================
--- modules/ruchin/maps/ruchin.rlscene	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/maps/ruchin.rlscene	2008-12-14 22:24:57 UTC (rev 4646)
@@ -0,0 +1,4 @@
+<scene name="ruchin">
+	<map file="ruchin.rlmap.xml"/>	
+	<map file="Ruchin_houses.rlmap.xml"/>
+</scene>
\ No newline at end of file

Deleted: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/maps/ruchin.scene	2008-12-14 22:24:57 UTC (rev 4646)
@@ -1,19 +0,0 @@
-<scene formatVersion="0.0" >
-	<nodes>
-		<node name="Ivy" id="1" >
-			<position x="22.5935" y="-2.88005" z="-20.0237" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<entity
-				name="Ivy"
-				id="2"
-				meshFile ="Ruchin_ivy_01.mesh"
-				materialFile="ruchin.material"
-				castsShadow="false"
-			/>
-
-  
-
-		</node>
-	</nodes>
-</scene>
\ No newline at end of file

Modified: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2008-12-14 22:24:57 UTC (rev 4646)
@@ -78,16 +78,7 @@
 			<staticgeometrygroup id="1"/>
 			<renderingdistance data="100" />
 		</entity>
-		
 
-		<entity name="Ruchin_h" meshfile ="Ruchin_h.mesh" visible="true" receivesShadow="false" castsShadows="true">
-			<position x="-31.0" y="0.0" z="-104.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
-			<scale x="1.0" y="1.0" z="1.0" />
-			<staticgeometrygroup id="0"/>
-			<renderingdistance data="100" />
-		</entity>	
-
 		<entity name="Ruchin_m_innen" meshfile ="Ruchin_m_innen.mesh" visible="true" receivesShadow="false">
 			<position x="45.0" y="0.0" z="-30.00" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/scripts/maps/maptest.rb	2008-12-14 22:24:57 UTC (rev 4646)
@@ -78,7 +78,7 @@
 
 loader = MapLoader.new("ruchin");
 loader.loadMap("ruchin_lightzones.rlmap.xml");
-loader.loadMap("Ruchin_houses.scene.xml");
+#loader.loadMap("Ruchin_houses.scene.xml");
 
 $SCRIPT.log("Fackellicht erstellen..");
 fackellicht = $AM.createLightActor("Das Licht der Fackel", LightObject::LT_POINT );

Modified: modules/ruchin/scripts/moduleconfig.rb
===================================================================
--- modules/ruchin/scripts/moduleconfig.rb	2008-12-14 14:31:51 UTC (rev 4645)
+++ modules/ruchin/scripts/moduleconfig.rb	2008-12-14 22:24:57 UTC (rev 4646)
@@ -25,7 +25,7 @@
     def start()
 		require 'clothing.rb'
 		
-        $CORE.loadMap("Octree", "ruchin.scene", "ruchin");
+		SceneManager::getSingleton().loadScene("ruchin", false);
         load "maptest.rb"
         $World = $CORE.getWorld();
     end



From timm at mail.berlios.de  Mon Dec 15 19:32:08 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 15 Dec 2008 19:32:08 +0100
Subject: [Dsa-hl-svn] r4647 - in modules/ruchin: maps models
Message-ID: <200812151832.mBFIW80v015135@sheep.berlios.de>

Author: timm
Date: 2008-12-15 19:24:33 +0100 (Mon, 15 Dec 2008)
New Revision: 4647

Modified:
   modules/ruchin/maps/ruchin_lightzones.rlmap.xml
   modules/ruchin/models/Ruchin_Stadtwache.mesh
   modules/ruchin/models/Ruchin_ground.mesh
   modules/ruchin/models/Ruchin_i.mesh
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchin_o.mesh
   modules/ruchin/models/Ruchin_u.mesh
   modules/ruchin/models/dome.mesh
   modules/ruchin/models/ruchin_terrain.mesh
   modules/ruchin/models/temple_innen.mesh
Log:
- updated mesh format
- fixed crash while loading ruchin

Modified: modules/ruchin/maps/ruchin_lightzones.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2008-12-14 22:24:57 UTC (rev 4646)
+++ modules/ruchin/maps/ruchin_lightzones.rlmap.xml	2008-12-15 18:24:33 UTC (rev 4647)
@@ -118,14 +118,14 @@
 		</entity>
 		<entity name="ruchin_terrain" meshfile ="ruchin_terrain.mesh" visible="true" receivesShadow="true">
 			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<staticgeometrygroup id="2"/>
 			<renderingdistance data="100" />
 		</entity>
 		<entity name="Ruchin_ground" meshfile ="Ruchin_ground.mesh" visible="true" receivesShadow="true">
 			<position x="0.0" y="0.0" z="0.0" />
-			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<staticgeometrygroup id="2"/>
 			<renderingdistance data="100" />

Modified: modules/ruchin/models/Ruchin_Stadtwache.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_ground.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_i.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_o.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_u.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ruchin_terrain.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/temple_innen.mesh
===================================================================
(Binary files differ)



From timm at mail.berlios.de  Mon Dec 15 21:25:12 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 15 Dec 2008 21:25:12 +0100
Subject: [Dsa-hl-svn] r4648 - modules/ruchin/models
Message-ID: <200812152025.mBFKPCtB000578@sheep.berlios.de>

Author: timm
Date: 2008-12-15 21:25:05 +0100 (Mon, 15 Dec 2008)
New Revision: 4648

Modified:
   modules/ruchin/models/Ruchin_ground.material
   modules/ruchin/models/ruchin_terrain.material
Log:
repaired material files for ground and terrain

Modified: modules/ruchin/models/Ruchin_ground.material
===================================================================
--- modules/ruchin/models/Ruchin_ground.material	2008-12-15 18:24:33 UTC (rev 4647)
+++ modules/ruchin/models/Ruchin_ground.material	2008-12-15 20:25:05 UTC (rev 4648)
@@ -15,13 +15,13 @@
    {
       pass
       {
-         fragment_program_ref
+         fragment_program_ref TerrainVColorBlending_Pixel_Shader_glsl
          {
             param_named scale_Detail4 float 30.050000 
             // Alpha
          }
 
-         vertex_program_ref
+         vertex_program_ref TerrainVColorBlending_Vertex_Shader_glsl
          {
 
             param_named scale_Texture0 float 30.58000 
@@ -50,13 +50,13 @@
    {
       pass
       {
-         fragment_program_ref
+         fragment_program_ref TerrainVColorBlending_Pixel_Shader
          {
             param_named scale_Detail4 float 100.050000 
             // Alpha
          }
 
-         vertex_program_ref
+         vertex_program_ref TerrainVColorBlending_Vertex_Shader
          {
 
             param_named scale_Texture0 float 30.58000 

Modified: modules/ruchin/models/ruchin_terrain.material
===================================================================
--- modules/ruchin/models/ruchin_terrain.material	2008-12-15 18:24:33 UTC (rev 4647)
+++ modules/ruchin/models/ruchin_terrain.material	2008-12-15 20:25:05 UTC (rev 4648)
@@ -15,13 +15,13 @@
    {
       pass
       {
-         fragment_program_ref
+         fragment_program_ref TerrainVColorBlending_Pixel_Shader_glsl
          {
             param_named scale_Detail4 float 20.050000 
             // Alpha
          }
 
-         vertex_program_ref
+         vertex_program_ref TerrainVColorBlending_Vertex_Shader_glsl
          {
 
             param_named scale_Texture0 float 20.018000 
@@ -50,13 +50,13 @@
    {
       pass
       {
-         fragment_program_ref
+         fragment_program_ref TerrainVColorBlending_Pixel_Shader
          {
             param_named scale_Detail4 float 20.050000 
             // Alpha
          }
 
-         vertex_program_ref
+         vertex_program_ref TerrainVColorBlending_Vertex_Shader
          {
 
             param_named scale_Texture0 float 20.018000 



From timm at mail.berlios.de  Mon Dec 15 21:53:30 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 15 Dec 2008 21:53:30 +0100
Subject: [Dsa-hl-svn] r4649 - modules/ruchin/models
Message-ID: <200812152053.mBFKrUC5003822@sheep.berlios.de>

Author: timm
Date: 2008-12-15 21:53:25 +0100 (Mon, 15 Dec 2008)
New Revision: 4649

Modified:
   modules/ruchin/models/Stadtwache.material
Log:
fixed material of Stadtwache

Modified: modules/ruchin/models/Stadtwache.material
===================================================================
--- modules/ruchin/models/Stadtwache.material	2008-12-15 20:25:05 UTC (rev 4648)
+++ modules/ruchin/models/Stadtwache.material	2008-12-15 20:53:25 UTC (rev 4649)
@@ -1,11 +1,13 @@
 import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+import Basic_Normalmapping from Basic_Normalmapping.material
 import Ruchin/base from Ruchintest.material
 import Ruchin_Stadtmauer/Dach from Stadtmauer.material
-import Ruchin_Stadtmauer/Wand from Stadtmauer.material
+import Ruchin_Stadtmauer from Stadtmauer.material
 
-material Stadtwache/Wand : Ruchin_Stadtmauer/Wand
+material Stadtwache/Wand : Basic_Normalmapping
 {
-
+	set_texture_alias DiffuseMap Ruchin_stadtmauer.png
+	set_texture_alias NormalMap Ruchin_stadtmauer_normal.png
 }
 
 material Stadtwache/Base : Ruchin/base



From blakharaz at mail.berlios.de  Mon Dec 15 22:10:06 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 15 Dec 2008 22:10:06 +0100
Subject: [Dsa-hl-svn] r4650 - rl/branches
Message-ID: <200812152110.mBFLA6Q8006392@sheep.berlios.de>

Author: blakharaz
Date: 2008-12-15 22:10:04 +0100 (Mon, 15 Dec 2008)
New Revision: 4650

Removed:
   rl/branches/ogre16/
Log:
Trunk is already ported to Ogre 1.6



From timm at mail.berlios.de  Mon Dec 15 22:19:14 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 15 Dec 2008 22:19:14 +0100
Subject: [Dsa-hl-svn] r4651 - in modules: common/materials/programs
	ruchin/models
Message-ID: <200812152119.mBFLJEwm007021@sheep.berlios.de>

Author: timm
Date: 2008-12-15 22:19:06 +0100 (Mon, 15 Dec 2008)
New Revision: 4651

Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.program
   modules/common/materials/programs/Basic_Vertex_Shader_AO.material
   modules/ruchin/models/Ruchintest.material
Log:
material files corrected

Modified: modules/common/materials/programs/Basic_Vertex_Shader.program
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.program	2008-12-15 21:10:04 UTC (rev 4650)
+++ modules/common/materials/programs/Basic_Vertex_Shader.program	2008-12-15 21:19:06 UTC (rev 4651)
@@ -335,7 +335,6 @@
 				
 				
 				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
 			}
 			
 			texture_unit

Modified: modules/common/materials/programs/Basic_Vertex_Shader_AO.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_AO.material	2008-12-15 21:10:04 UTC (rev 4650)
+++ modules/common/materials/programs/Basic_Vertex_Shader_AO.material	2008-12-15 21:19:06 UTC (rev 4651)
@@ -18,7 +18,7 @@
 
 material Basic_Vertex_Shader_AO
 {
-receive_shadows off
+	receive_shadows off
 	technique hlsl
 	{
 		

Modified: modules/ruchin/models/Ruchintest.material
===================================================================
--- modules/ruchin/models/Ruchintest.material	2008-12-15 21:10:04 UTC (rev 4650)
+++ modules/ruchin/models/Ruchintest.material	2008-12-15 21:19:06 UTC (rev 4651)
@@ -212,7 +212,7 @@
 }
 
 
-material Ruchin_m/Dach :Basic_Vertex_Shader_AO
+material Ruchin_m/Dach : Basic_Vertex_Shader_AO
 {
 set_texture_alias diffuse arc_schieferdach.png
 set_texture_alias ambient ruchin_ao_m.png



From fusion2 at mail.berlios.de  Mon Dec 15 22:21:12 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Mon, 15 Dec 2008 22:21:12 +0100
Subject: [Dsa-hl-svn] r4652 - in rl/trunk/editors/Lockenwickler/src: . media
Message-ID: <200812152121.mBFLLCMU007432@sheep.berlios.de>

Author: fusion2
Date: 2008-12-15 22:20:57 +0100 (Mon, 15 Dec 2008)
New Revision: 4652

Added:
   rl/trunk/editors/Lockenwickler/src/media/UniCube.mesh
   rl/trunk/editors/Lockenwickler/src/media/UniSphere.mesh
   rl/trunk/editors/Lockenwickler/src/media/lightbulp.blend
   rl/trunk/editors/Lockenwickler/src/media/lightbulp.mesh
   rl/trunk/editors/Lockenwickler/src/media/lightbulp.png
Removed:
   rl/trunk/editors/Lockenwickler/src/media/Barrel.mesh
   rl/trunk/editors/Lockenwickler/src/media/Example.material
   rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend
Modified:
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
Log:
- more updates on loading modules


Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-12-15 21:20:57 UTC (rev 4652)
@@ -124,6 +124,7 @@
         self.gocName = gameObjectClass
         self.node = node
         self.meshFile = meshFile
+        self.state = "IN_SCENE"
 
     def getType(self):
         return "GAME_OBJECT_REPRESENTATION"

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-12-15 21:20:57 UTC (rev 4652)
@@ -59,6 +59,8 @@
         self.objectPropertyWin = ObjectPropertyWin(self)
         self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
         self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
         self.createDockWindows()
@@ -273,6 +275,9 @@
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+        self.moduleManager.pivot.hide()
+
         oglog = og.LogManager.getSingleton().getDefaultLog()
         oglog.addListener(self.consoleWindow.lockenLog)
 

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-15 21:20:57 UTC (rev 4652)
@@ -97,9 +97,8 @@
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
-        QObject.connect(self.modelSearchBox,SIGNAL("textChanged(QString)"),self.listWidget.clearSelection)
-        QMetaObject.connectSlotsByName(self)
 
+
     def retranslateUi(self):
         self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
 
@@ -115,14 +114,14 @@
         self.node.setScale(og.Vector3(1,1,1))
         bb = self.ent.getBoundingBox()
 
-    def scanDirForModels(self, dir, name):
+    def scanDirForModels(self, dir):
         for file in os.listdir(dir):
             curFile = dir + "/" + file
 
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
             if isdir(curFile):
-                self.scanDirForModels(curFile, file)
+                self.scanDirForModels(curFile)
                 continue
             if isfile(curFile):
                 if file.endswith(".mesh"):
@@ -143,6 +142,7 @@
         if event.type() == 5:
             self.startDrag()
             event.accept()
+            return True
 
         return False
 
@@ -152,6 +152,7 @@
                 self.ogreModelPrevWindow.zoomCamera(-5)
             else:
                 self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
 
         if event.type() == 5: #mouse moved while button down
             rotX = (event.globalX() - self.lastMousePosX) * 0.01
@@ -162,10 +163,12 @@
 
             self.lastMousePosX = event.globalX()
             self.lastMousePosY = event.globalY()
+            return True
 
         if event.type() == 3: # mouse released
             self.lastMousePosX = 0
             self.lastMousePosY = 0
+            return True
 
         return False
 

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-12-15 21:20:57 UTC (rev 4652)
@@ -35,32 +35,77 @@
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
 
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
         self.pathToMapFile = pathToFile
         self.sceneManager = sceneManager
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
 
         xmlTree = xml.parse(pathToFile)
         root = xmlTree.getroot()
 
         if root.attrib["formatVersion"] == "0.4.0":
-            self.parseMap(root)
+            self.parseMapNodes(root.find("nodes"))
+            #self.parseMapZones(root.find("zones"))
         else:
             print pathToFile + " has wrong format version. It needs to be 0.4.0"
             return
 
-    def parseMap(self, rootElement):
-        nodes = rootElement.getiterator("entity")
-        for n in nodes:
-            entityName = n.attrib["name"]
-            meshFile = n.attrib["meshfile"]
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("entity")
+        if len(nodes) > 0:
+            self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        if len(nodes) > 0:
+            self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        if len(nodes) > 0:
+            self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("gameobject")
+        if len(nodes) > 0:
+            self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        if len(nodes) > 0:
+            self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            print entityName
+            meshFile = nodes.attrib["meshfile"]
             nodePosition = None
             nodeRotation = None
             nodeScale = None
 
-            transformations = n.getiterator()
+            transformations = nodes.getiterator()
             for t in transformations:
                 if t.tag == "position":
                     x = float(t.attrib["x"])
@@ -83,7 +128,7 @@
                 e = self.sceneManager.createEntity(entityName, meshFile)
             except:
                 print "Warning: Meshfile " + meshFile + " could not be found."
-                return
+                continue
 
             n = self.mapNode.createChild(entityName + "_node")
             n.attachObject(e)
@@ -91,17 +136,113 @@
             n.setOrientation(nodeRotation)
             n.setScale(nodeScale)
 
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationlinear = None
+            lightAttenuationQuadratic = None
 
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationlinear = float(t.attrib["linear"])
+                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
 
+            e = self.sceneManager.createEntity(lightName, "lightbulp.mesh")
+            n = self.mapNode.createChild(lightName + "_node")
+            n.attachObject(e)
+            n.setPosition(lightPosition)
 
+    def createSound(self, soundNodes):
+        raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            id = int(g.attrib["id"])
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        raise NotImplementedError
+        return
+
 class Scene():
     def __init__(self):
         return
 
 class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
 
         self.name = name
         self.moduleRoot = join(modulePath, name)
@@ -164,11 +305,15 @@
         self.setResourcePaths()
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
         if not self.isCommon():
             cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
             maps = glob.glob(cmd)
             for m in maps:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
 
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
@@ -191,7 +336,7 @@
 
 
             if file.startswith('.'): #ignore dot files (hidden)
-                pass
+                continue
             if os.path.isdir(curFile):
                 og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
                 self.setResourcePaths(curFile)
@@ -202,10 +347,17 @@
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
         self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
 
         self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
 
+
         self.mainModule = []
         self.mainModuledependencieList =[]
         self.moduleList = []
@@ -213,16 +365,12 @@
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
 
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
         self.listenerDings = MyRaySceneQueryListener()
 
         self.lastRay = None
 #        self.rayLine = None
 
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
         self.pivot = None
         self.movingPivot = False
 
@@ -253,7 +401,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
 
         self.moduleConfigIsParsed = True
 
@@ -280,20 +428,33 @@
         if dlg.exec_():
             self.loadModule(str(list.currentItem().text()))
 
+    # I'm sorry for this
     def loadModule(self, moduleName):
         for m in self.moduleList:
             if m.name == moduleName:
-                if m.hasDependencies:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
                     for moduleDependencie in m.moduleDependencies:
                         for m2 in self.moduleList:
                             if m2.name == moduleDependencie:
                                 m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
                 m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
                 self.mainModule = m
 
+        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
+        e.setMaterialName("Lockenwickler_Area")
 
+        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
+        e2.setMaterialName("Lockenwickler_Area")
+
+        n.attachObject(e)
+        n.attachObject(e2)
+        n.setScale(og.Vector3(10, 5, 20))
+
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
         self.listenerDings.reset()
@@ -496,9 +657,9 @@
 
     def startDropGameObjectAction(self, classid, ray):
         go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
 
         if go is not None:
+            meshFile = go.getMeshFileName()
             dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
             dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
             dropNode.attachObject(dropEntity)

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-15 21:20:57 UTC (rev 4652)
@@ -150,6 +150,7 @@
 
     def eventFilter(self, obj, event):
         if event.type() == 2:
+            self.ogreRenderWindow.setFocus()
             if event.button() == 1: # left mouse button is pressed
                 self.leftMouseDown = True
                 self.moduleManager.leftMouseDown = True

Deleted: rl/trunk/editors/Lockenwickler/src/media/Barrel.mesh
===================================================================
(Binary files differ)

Deleted: rl/trunk/editors/Lockenwickler/src/media/Example.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Example.material	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/media/Example.material	2008-12-15 21:20:57 UTC (rev 4652)
@@ -1,18 +0,0 @@
-material RustyBarrel
-{
-	technique
-	{
-		pass
-		{
-			ambient 0.5 0.5 0.5 1.0
-			diffuse 1.0 1.0 1.0 1.0
-			specular 0.0 0.0 0.0 1.0 12.5
-			emissive 0.0 0.0 0.0 1.0
-			texture_unit
-			{
-				texture RustyBarrel.png
-				filtering trilinear
-			}
-		}
-	}
-}

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-15 21:19:06 UTC (rev 4651)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-15 21:20:57 UTC (rev 4652)
@@ -4,8 +4,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 1.0 0.0 0.0 0.5
 			diffuse 1.0 0.0 0.0 0.5
 			specular 1.0 0.0 0.0 0.5 12.5
@@ -21,8 +19,6 @@
 
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -37,8 +33,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 1.0 0.0 0.5
 			diffuse 0.0 1.0 0.0 0.5
 			specular 0.0 1.0 0.0 0.5 12.5
@@ -60,4 +54,44 @@
 		}
 	}
 }
+
+material SOLID/TEX/lightbulp.png
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+				texture lightbulp.png
+			}
+		}
+	}
+}
+
+material Lockenwickler_Area
+{
+	technique
+	{
+                pass
+		{
+                        depth_write off
+                        scene_blend alpha_blend
+                        
+			ambient 0.0 1.0 0.0 0.2
+			diffuse 0.0 1.0 0.0 0.2
+			emissive 0.0 1.0 0.0 0.2
+		}
+
+		pass
+		{
+                        polygon_mode wireframe
+
+			ambient 0.0 1.0 0.0 1.0
+			diffuse 0.0 1.0 0.0 1.0
+			emissive 0.0 1.0 0.0 1.0
+		}
+	}
+}
+
  

Added: rl/trunk/editors/Lockenwickler/src/media/UniCube.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/UniCube.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/UniSphere.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/UniSphere.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend
===================================================================
(Binary files differ)

Added: rl/trunk/editors/Lockenwickler/src/media/lightbulp.blend
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/lightbulp.blend
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/lightbulp.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/lightbulp.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/lightbulp.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/lightbulp.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From timm at mail.berlios.de  Tue Dec 16 01:27:05 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 16 Dec 2008 01:27:05 +0100
Subject: [Dsa-hl-svn] r4653 - modules/kanalisation/materials
Message-ID: <200812160027.mBG0R5jm020695@sheep.berlios.de>

Author: timm
Date: 2008-12-16 01:26:55 +0100 (Tue, 16 Dec 2008)
New Revision: 4653

Modified:
   modules/kanalisation/materials/DirtyWater.material
   modules/kanalisation/materials/TotalReflectDirtWater.source
Log:
tried to add diffuse light to dirty water shader

Modified: modules/kanalisation/materials/DirtyWater.material
===================================================================
--- modules/kanalisation/materials/DirtyWater.material	2008-12-15 21:20:57 UTC (rev 4652)
+++ modules/kanalisation/materials/DirtyWater.material	2008-12-16 00:26:55 UTC (rev 4653)
@@ -30,6 +30,8 @@
 			{
 				param_named_auto worldViewProjMatrix worldviewproj_matrix
 				param_named_auto eyePosition camera_position_object_space
+				param_named_auto lightPosition light_position_object_space 0
+				param_named_auto lightDiffuse light_diffuse_colour 0
 				param_named_auto timeVal time 0.05
 				param_named_auto ambient ambient_light_colour
 				param_named scroll float 1  

Modified: modules/kanalisation/materials/TotalReflectDirtWater.source
===================================================================
--- modules/kanalisation/materials/TotalReflectDirtWater.source	2008-12-15 21:20:57 UTC (rev 4652)
+++ modules/kanalisation/materials/TotalReflectDirtWater.source	2008-12-16 00:26:55 UTC (rev 4653)
@@ -13,6 +13,8 @@
 		out float4 color   : COLOR,
 		
 		uniform float4x4 worldViewProjMatrix,
+		uniform float3 lightPosition, //object space
+		uniform float4 lightDiffuse,
 		uniform float3 eyePosition, // object space
 		uniform float timeVal,
 		uniform float scale,  // the amount to scale the noise texture by
@@ -35,8 +37,11 @@
 	oEyeDir = normalize(pos.xyz - eyePosition); 
 	oNormal = normal.rgb; 
 	
+	float3 N = normalize(normal);
+	float3 L = normalize(lightPosition - pos.xyz);
+	
 	oTex = tex;
-	color = ambient;
+	color = ambient + lightDiffuse * max(dot(N, L) , 0);
 }
 
 // Fragment program for distorting a texture using a 3D noise texture
@@ -63,7 +68,7 @@
 	float2 final = projectionCoord.xy / projectionCoord.w;
 
 	// Noise
-	float3 noiseNormal = (tex2D(noiseMap, (noiseCoord.xy / 5)).rgb - 0.5).rbg * noiseScale;
+	float3 noiseNormal = (tex2D(noiseMap, (noiseCoord.xy )).rgb - 0.5).rbg * noiseScale;
 	final += noiseNormal.xz;
 
 	// Fresnel



From melven at mail.berlios.de  Wed Dec 17 21:11:32 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 17 Dec 2008 21:11:32 +0100
Subject: [Dsa-hl-svn] r4654 - in rl/branches/newton20: .
	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler/src
	editors/Lockenwickler/src/media engine/ai engine/ai/include
	engine/ai/src engine/common engine/common/include
	engine/common/src engine/core engine/core/include
	engine/core/src engine/rules/include engine/rules/src
	engine/ui engine/ui/include engine/ui/src
Message-ID: <200812172011.mBHKBWFw012914@sheep.berlios.de>

Author: melven
Date: 2008-12-17 21:11:09 +0100 (Wed, 17 Dec 2008)
New Revision: 4654

Added:
   rl/branches/newton20/cmake/FindOgreNewt.cmake
   rl/branches/newton20/editors/Lockenwickler/src/media/UniCube.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/UniSphere.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.blend
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.png
   rl/branches/newton20/engine/ai/CMakeLists.txt
   rl/branches/newton20/engine/ai/include/DialogLoaderImpl.h
   rl/branches/newton20/engine/ai/src/DialogLoaderImpl.cpp
   rl/branches/newton20/engine/common/CMakeLists.txt
   rl/branches/newton20/engine/core/CMakeLists.txt
Removed:
   rl/branches/newton20/editors/Lockenwickler/src/media/Barrel.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/Example.material
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
Modified:
   rl/branches/newton20/CMakeLists.txt
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/newton20/engine/ai/RlAI2005.vcproj
   rl/branches/newton20/engine/ai/include/DialogImplication.h
   rl/branches/newton20/engine/ai/include/DialogLoader.h
   rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h
   rl/branches/newton20/engine/ai/include/Makefile.am
   rl/branches/newton20/engine/ai/src/DialogImplication.cpp
   rl/branches/newton20/engine/ai/src/DialogLoader.cpp
   rl/branches/newton20/engine/ai/src/Makefile.am
   rl/branches/newton20/engine/common/include/MathUtil.h
   rl/branches/newton20/engine/common/include/WriteableDataStream.h
   rl/branches/newton20/engine/common/src/MathUtil.cpp
   rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/newton20/engine/core/include/ConfigurationManager.h
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/ContentLoader.cpp
   rl/branches/newton20/engine/core/src/CoreSubsystem.cpp
   rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp
   rl/branches/newton20/engine/rules/include/ApplyDamageJob.h
   rl/branches/newton20/engine/rules/include/Combat.h
   rl/branches/newton20/engine/rules/include/Combatant.h
   rl/branches/newton20/engine/rules/include/Creature.h
   rl/branches/newton20/engine/rules/include/RulesPrerequisites.h
   rl/branches/newton20/engine/rules/include/Slot.h
   rl/branches/newton20/engine/rules/include/Weapon.h
   rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp
   rl/branches/newton20/engine/rules/src/Combat.cpp
   rl/branches/newton20/engine/rules/src/Combatant.cpp
   rl/branches/newton20/engine/rules/src/Creature.cpp
   rl/branches/newton20/engine/rules/src/GoToJob.cpp
   rl/branches/newton20/engine/rules/src/Weapon.cpp
   rl/branches/newton20/engine/ui/RlUI2005.vcproj
   rl/branches/newton20/engine/ui/include/AbstractWindow.h
   rl/branches/newton20/engine/ui/include/GameSettings.h
   rl/branches/newton20/engine/ui/include/WindowManager.h
   rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
   rl/branches/newton20/engine/ui/src/GameSettings.cpp
   rl/branches/newton20/engine/ui/src/MovementControlState.cpp
   rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
   rl/branches/newton20/engine/ui/src/WindowManager.cpp
Log:
merged changes from trunk


Modified: rl/branches/newton20/CMakeLists.txt
===================================================================
--- rl/branches/newton20/CMakeLists.txt	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/CMakeLists.txt	2008-12-17 20:11:09 UTC (rev 4654)
@@ -3,11 +3,16 @@
 CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
 
 # Cmake handles escaping of preprocessor directives
-CMAKE_POLICY(SET CMP0005 NEW)
+CMAKE_POLICY(SET CMP0005 OLD)
 
 # Include required cmake macros
 INCLUDE(FeatureSummary)
 
+# Version information
+SET(RL_MAJOR_VERSION 0)
+SET(RL_MINOR_VERSION 3)
+SET(RL_PATCH_VERSION 0)
+
 # Add directory with RL's own macro definitions
 # (checked before ${CMAKE_ROOT}/Modules)
 SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
@@ -21,7 +26,9 @@
 SET(RL_UI_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/ui/include INTERNAL)
 
 # Check for required components
+FIND_PACKAGE(PkgConfig)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
+FIND_PACKAGE(OgreNewt REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
 FIND_PACKAGE(SWIG REQUIRED)
@@ -39,8 +46,7 @@
 SET(ENABLE_OPENAL "Enable OpenAL sound support (unsupported)" OFF)
 
 # Handle options
-SET(DATADIR ${DATAROOTDIR}/${DATADIRNAME})
-ADD_DEFINITIONS(-DDATADIR=${DATADIR})
+ADD_DEFINITIONS(-DRL_MODULEDIR=\\"${DATAROOTDIR}/${DATADIRNAME}/modules\\")
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -478,7 +478,6 @@
 		48389C290D867B1A00AFAB66 /* Trigger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05860D71EDF20024198D /* Trigger.cpp */; };
 		48389C2C0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */; };
 		48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */; };
-		483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31100D85B1AF003477A0 /* NullSoundStitching.h */; };
 		483D31130D85B1C2003477A0 /* NullSoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */; };
 		483D31200D85B215003477A0 /* Combatant.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31150D85B215003477A0 /* Combatant.h */; };
 		483D31210D85B215003477A0 /* EffectManagementTask.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31160D85B215003477A0 /* EffectManagementTask.h */; };
@@ -562,6 +561,7 @@
 		484FE6C10E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		48500B790D906A1000EAD8DB /* RlScriptExportsMac.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */; };
+		4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */; };
 		48570C210D8A6C9000096E35 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
 		48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
 		48570C230D8A6C9000096E35 /* AbstractMapNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */; };
@@ -619,6 +619,8 @@
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
 		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
+		4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */ = {isa = PBXBuildFile; fileRef = 4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */; };
+		4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -884,14 +886,14 @@
 		1870340FFE93FCAF11CA0CD7 /* English */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = English; path = English.lproj/main.nib; sourceTree = "<group>"; };
 		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
 		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = stdinc.cpp; sourceTree = "<group>"; };
 		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
 		440785DD0C09D231006E496D /* libmeshmagick.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libmeshmagick.dylib; path = /usr/local/lib/libmeshmagick.dylib; sourceTree = "<absolute>"; };
-		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
-		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
+		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightFadeJob.cpp; sourceTree = "<group>"; };
+		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MergeableMeshObject.cpp; sourceTree = "<group>"; };
+		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MergeableMeshObject.h; sourceTree = "<group>"; };
 		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
@@ -952,117 +954,116 @@
 		444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Tripel.h; path = ../engine/common/include/Tripel.h; sourceTree = SOURCE_ROOT; };
 		444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResource.h; path = ../engine/common/include/XmlResource.h; sourceTree = SOURCE_ROOT; };
 		444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResourceManager.h; path = ../engine/common/include/XmlResourceManager.h; sourceTree = SOURCE_ROOT; };
-		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Actor.cpp; path = ../engine/core/src/Actor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorControlledObject.cpp; path = ../engine/core/src/ActorControlledObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorManager.cpp; path = ../engine/core/src/ActorManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AnimationManager.cpp; path = ../engine/core/src/AnimationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BaseAnimation.cpp; path = ../engine/core/src/BaseAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BoxPrimitive.cpp; path = ../engine/core/src/BoxPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CameraObject.cpp; path = ../engine/core/src/CameraObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigurationManager.cpp; path = ../engine/core/src/ConfigurationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentModule.cpp; path = ../engine/core/src/ContentModule.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CoreSubsystem.cpp; path = ../engine/core/src/CoreSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualisable.cpp; path = ../engine/core/src/DebugVisualisable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualsManager.cpp; path = ../engine/core/src/DebugVisualsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneLoader.cpp; path = ../engine/core/src/DotSceneLoader.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneOctreeWorld.cpp; path = ../engine/core/src/DotSceneOctreeWorld.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FadeAnimation.cpp; path = ../engine/core/src/FadeAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEvent.cpp; path = ../engine/core/src/GameAreaEvent.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEventSource.cpp; path = ../engine/core/src/GameAreaEventSource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaListener.cpp; path = ../engine/core/src/GameAreaListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaTypes.cpp; path = ../engine/core/src/GameAreaTypes.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameEventManager.cpp; path = ../engine/core/src/GameEventManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoop.cpp; path = ../engine/core/src/GameLoop.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Job.cpp; path = ../engine/core/src/Job.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobScheduler.cpp; path = ../engine/core/src/JobScheduler.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightObject.cpp; path = ../engine/core/src/LightObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LineSetPrimitive.cpp; path = ../engine/core/src/LineSetPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerMovable.cpp; path = ../engine/core/src/ListenerMovable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerObject.cpp; path = ../engine/core/src/ListenerObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshAnimation.cpp; path = ../engine/core/src/MeshAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshObject.cpp; path = ../engine/core/src/MeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovableText.cpp; path = ../engine/core/src/MovableText.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB420BD0E2B600C6D4A0 /* nulldriver */ = {isa = PBXFileReference; lastKnownFileType = folder; name = nulldriver; path = ../engine/core/src/nulldriver; sourceTree = SOURCE_ROOT; };
-		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = ../engine/core/src/nulldriver/NullDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = ../engine/core/src/nulldriver/NullListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = ../engine/core/src/nulldriver/NullSound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ParticleSystemObject.cpp; path = ../engine/core/src/ParticleSystemObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicalThing.cpp; path = ../engine/core/src/PhysicalThing.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsContactListener.cpp; path = ../engine/core/src/PhysicsContactListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsGenericContactCallback.cpp; path = ../engine/core/src/PhysicsGenericContactCallback.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsManager.cpp; path = ../engine/core/src/PhysicsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsMaterialRaycast.cpp; path = ../engine/core/src/PhysicsMaterialRaycast.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlayAnimationJob.cpp; path = ../engine/core/src/PlayAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaySoundJob.cpp; path = ../engine/core/src/PlaySoundJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PrimitiveObject.cpp; path = ../engine/core/src/PrimitiveObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RubyInterpreter.cpp; path = ../engine/core/src/RubyInterpreter.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneQuery.cpp; path = ../engine/core/src/SceneQuery.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Sound.cpp; path = ../engine/core/src/Sound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriver.cpp; path = ../engine/core/src/SoundDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundEvents.cpp; path = ../engine/core/src/SoundEvents.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundManager.cpp; path = ../engine/core/src/SoundManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundObject.cpp; path = ../engine/core/src/SoundObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundResource.cpp; path = ../engine/core/src/SoundResource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TrackAnimation.cpp; path = ../engine/core/src/TrackAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = World.cpp; path = ../engine/core/src/World.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Actor.cpp; sourceTree = "<group>"; };
+		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorControlledObject.cpp; sourceTree = "<group>"; };
+		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorManager.cpp; sourceTree = "<group>"; };
+		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AnimationManager.cpp; sourceTree = "<group>"; };
+		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BaseAnimation.cpp; sourceTree = "<group>"; };
+		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BoxPrimitive.cpp; sourceTree = "<group>"; };
+		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CameraObject.cpp; sourceTree = "<group>"; };
+		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ConfigurationManager.cpp; sourceTree = "<group>"; };
+		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentModule.cpp; sourceTree = "<group>"; };
+		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CoreSubsystem.cpp; sourceTree = "<group>"; };
+		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualisable.cpp; sourceTree = "<group>"; };
+		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualsManager.cpp; sourceTree = "<group>"; };
+		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneLoader.cpp; sourceTree = "<group>"; };
+		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneOctreeWorld.cpp; sourceTree = "<group>"; };
+		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FadeAnimation.cpp; sourceTree = "<group>"; };
+		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEvent.cpp; sourceTree = "<group>"; };
+		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEventSource.cpp; sourceTree = "<group>"; };
+		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaListener.cpp; sourceTree = "<group>"; };
+		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaTypes.cpp; sourceTree = "<group>"; };
+		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameEventManager.cpp; sourceTree = "<group>"; };
+		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameLoop.cpp; sourceTree = "<group>"; };
+		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Job.cpp; sourceTree = "<group>"; };
+		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobScheduler.cpp; sourceTree = "<group>"; };
+		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightObject.cpp; sourceTree = "<group>"; };
+		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LineSetPrimitive.cpp; sourceTree = "<group>"; };
+		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerMovable.cpp; sourceTree = "<group>"; };
+		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerObject.cpp; sourceTree = "<group>"; };
+		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshAnimation.cpp; sourceTree = "<group>"; };
+		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshObject.cpp; sourceTree = "<group>"; };
+		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MovableText.cpp; sourceTree = "<group>"; };
+		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = nulldriver/NullDriver.cpp; sourceTree = "<group>"; };
+		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = nulldriver/NullListener.cpp; sourceTree = "<group>"; };
+		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = nulldriver/NullSound.cpp; sourceTree = "<group>"; };
+		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ParticleSystemObject.cpp; sourceTree = "<group>"; };
+		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicalThing.cpp; sourceTree = "<group>"; };
+		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsContactListener.cpp; sourceTree = "<group>"; };
+		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsGenericContactCallback.cpp; sourceTree = "<group>"; };
+		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsManager.cpp; sourceTree = "<group>"; };
+		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsMaterialRaycast.cpp; sourceTree = "<group>"; };
+		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlayAnimationJob.cpp; sourceTree = "<group>"; };
+		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlaySoundJob.cpp; sourceTree = "<group>"; };
+		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PrimitiveObject.cpp; sourceTree = "<group>"; };
+		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RubyInterpreter.cpp; sourceTree = "<group>"; };
+		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SceneQuery.cpp; sourceTree = "<group>"; };
+		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Sound.cpp; sourceTree = "<group>"; };
+		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundDriver.cpp; sourceTree = "<group>"; };
+		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundEvents.cpp; sourceTree = "<group>"; };
+		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundManager.cpp; sourceTree = "<group>"; };
+		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundObject.cpp; sourceTree = "<group>"; };
+		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundResource.cpp; sourceTree = "<group>"; };
+		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TrackAnimation.cpp; sourceTree = "<group>"; };
+		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = World.cpp; sourceTree = "<group>"; };
 		444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlCore.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Actor.h; path = ../engine/core/include/Actor.h; sourceTree = SOURCE_ROOT; };
-		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorControlledObject.h; path = ../engine/core/include/ActorControlledObject.h; sourceTree = SOURCE_ROOT; };
-		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorManager.h; path = ../engine/core/include/ActorManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AnimationManager.h; path = ../engine/core/include/AnimationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BaseAnimation.h; path = ../engine/core/include/BaseAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BoxPrimitive.h; path = ../engine/core/include/BoxPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CameraObject.h; path = ../engine/core/include/CameraObject.h; sourceTree = SOURCE_ROOT; };
-		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigurationManager.h; path = ../engine/core/include/ConfigurationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentModule.h; path = ../engine/core/include/ContentModule.h; sourceTree = SOURCE_ROOT; };
-		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CorePrerequisites.h; path = ../engine/core/include/CorePrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreSubsystem.h; path = ../engine/core/include/CoreSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualisable.h; path = ../engine/core/include/DebugVisualisable.h; sourceTree = SOURCE_ROOT; };
-		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualsManager.h; path = ../engine/core/include/DebugVisualsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneLoader.h; path = ../engine/core/include/DotSceneLoader.h; sourceTree = SOURCE_ROOT; };
-		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneOctreeWorld.h; path = ../engine/core/include/DotSceneOctreeWorld.h; sourceTree = SOURCE_ROOT; };
-		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FadeAnimation.h; path = ../engine/core/include/FadeAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEvent.h; path = ../engine/core/include/GameAreaEvent.h; sourceTree = SOURCE_ROOT; };
-		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEventSource.h; path = ../engine/core/include/GameAreaEventSource.h; sourceTree = SOURCE_ROOT; };
-		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaListener.h; path = ../engine/core/include/GameAreaListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaTypes.h; path = ../engine/core/include/GameAreaTypes.h; sourceTree = SOURCE_ROOT; };
-		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameEventManager.h; path = ../engine/core/include/GameEventManager.h; sourceTree = SOURCE_ROOT; };
-		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoop.h; path = ../engine/core/include/GameLoop.h; sourceTree = SOURCE_ROOT; };
-		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Job.h; path = ../engine/core/include/Job.h; sourceTree = SOURCE_ROOT; };
-		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobListener.h; path = ../engine/core/include/JobListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobScheduler.h; path = ../engine/core/include/JobScheduler.h; sourceTree = SOURCE_ROOT; };
-		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightObject.h; path = ../engine/core/include/LightObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LineSetPrimitive.h; path = ../engine/core/include/LineSetPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerMovable.h; path = ../engine/core/include/ListenerMovable.h; sourceTree = SOURCE_ROOT; };
-		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerObject.h; path = ../engine/core/include/ListenerObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshAnimation.h; path = ../engine/core/include/MeshAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshObject.h; path = ../engine/core/include/MeshObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovableText.h; path = ../engine/core/include/MovableText.h; sourceTree = SOURCE_ROOT; };
-		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = ../engine/core/include/nulldriver/NullDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = ../engine/core/include/nulldriver/NullListener.h; sourceTree = SOURCE_ROOT; };
-		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = ../engine/core/include/nulldriver/NullSound.h; sourceTree = SOURCE_ROOT; };
-		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ParticleSystemObject.h; path = ../engine/core/include/ParticleSystemObject.h; sourceTree = SOURCE_ROOT; };
-		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalObject.h; path = ../engine/core/include/PhysicalObject.h; sourceTree = SOURCE_ROOT; };
-		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalThing.h; path = ../engine/core/include/PhysicalThing.h; sourceTree = SOURCE_ROOT; };
-		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsContactListener.h; path = ../engine/core/include/PhysicsContactListener.h; sourceTree = SOURCE_ROOT; };
-		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsController.h; path = ../engine/core/include/PhysicsController.h; sourceTree = SOURCE_ROOT; };
-		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsGenericContactCallback.h; path = ../engine/core/include/PhysicsGenericContactCallback.h; sourceTree = SOURCE_ROOT; };
-		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsManager.h; path = ../engine/core/include/PhysicsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsMaterialRaycast.h; path = ../engine/core/include/PhysicsMaterialRaycast.h; sourceTree = SOURCE_ROOT; };
-		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlayAnimationJob.h; path = ../engine/core/include/PlayAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaySoundJob.h; path = ../engine/core/include/PlaySoundJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PrimitiveObject.h; path = ../engine/core/include/PrimitiveObject.h; sourceTree = SOURCE_ROOT; };
-		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuadTree.h; path = ../engine/core/include/QuadTree.h; sourceTree = SOURCE_ROOT; };
-		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RubyInterpreter.h; path = ../engine/core/include/RubyInterpreter.h; sourceTree = SOURCE_ROOT; };
-		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneQuery.h; path = ../engine/core/include/SceneQuery.h; sourceTree = SOURCE_ROOT; };
-		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Sound.h; path = ../engine/core/include/Sound.h; sourceTree = SOURCE_ROOT; };
-		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriver.h; path = ../engine/core/include/SoundDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundEvents.h; path = ../engine/core/include/SoundEvents.h; sourceTree = SOURCE_ROOT; };
-		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundManager.h; path = ../engine/core/include/SoundManager.h; sourceTree = SOURCE_ROOT; };
-		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundObject.h; path = ../engine/core/include/SoundObject.h; sourceTree = SOURCE_ROOT; };
-		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundResource.h; path = ../engine/core/include/SoundResource.h; sourceTree = SOURCE_ROOT; };
-		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TrackAnimation.h; path = ../engine/core/include/TrackAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = World.h; path = ../engine/core/include/World.h; sourceTree = SOURCE_ROOT; };
+		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Actor.h; sourceTree = "<group>"; };
+		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorControlledObject.h; sourceTree = "<group>"; };
+		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorManager.h; sourceTree = "<group>"; };
+		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AnimationManager.h; sourceTree = "<group>"; };
+		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BaseAnimation.h; sourceTree = "<group>"; };
+		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BoxPrimitive.h; sourceTree = "<group>"; };
+		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CameraObject.h; sourceTree = "<group>"; };
+		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConfigurationManager.h; sourceTree = "<group>"; };
+		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentModule.h; sourceTree = "<group>"; };
+		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CorePrerequisites.h; sourceTree = "<group>"; };
+		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreSubsystem.h; sourceTree = "<group>"; };
+		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualisable.h; sourceTree = "<group>"; };
+		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualsManager.h; sourceTree = "<group>"; };
+		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneLoader.h; sourceTree = "<group>"; };
+		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneOctreeWorld.h; sourceTree = "<group>"; };
+		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FadeAnimation.h; sourceTree = "<group>"; };
+		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEvent.h; sourceTree = "<group>"; };
+		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEventSource.h; sourceTree = "<group>"; };
+		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaListener.h; sourceTree = "<group>"; };
+		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaTypes.h; sourceTree = "<group>"; };
+		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventManager.h; sourceTree = "<group>"; };
+		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameLoop.h; sourceTree = "<group>"; };
+		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Job.h; sourceTree = "<group>"; };
+		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobListener.h; sourceTree = "<group>"; };
+		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobScheduler.h; sourceTree = "<group>"; };
+		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightObject.h; sourceTree = "<group>"; };
+		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LineSetPrimitive.h; sourceTree = "<group>"; };
+		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerMovable.h; sourceTree = "<group>"; };
+		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerObject.h; sourceTree = "<group>"; };
+		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshAnimation.h; sourceTree = "<group>"; };
+		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshObject.h; sourceTree = "<group>"; };
+		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MovableText.h; sourceTree = "<group>"; };
+		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = nulldriver/NullDriver.h; sourceTree = "<group>"; };
+		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = nulldriver/NullListener.h; sourceTree = "<group>"; };
+		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = nulldriver/NullSound.h; sourceTree = "<group>"; };
+		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ParticleSystemObject.h; sourceTree = "<group>"; };
+		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalObject.h; sourceTree = "<group>"; };
+		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalThing.h; sourceTree = "<group>"; };
+		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsContactListener.h; sourceTree = "<group>"; };
+		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsController.h; sourceTree = "<group>"; };
+		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsGenericContactCallback.h; sourceTree = "<group>"; };
+		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsManager.h; sourceTree = "<group>"; };
+		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsMaterialRaycast.h; sourceTree = "<group>"; };
+		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlayAnimationJob.h; sourceTree = "<group>"; };
+		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlaySoundJob.h; sourceTree = "<group>"; };
+		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PrimitiveObject.h; sourceTree = "<group>"; };
+		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuadTree.h; sourceTree = "<group>"; };
+		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RubyInterpreter.h; sourceTree = "<group>"; };
+		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SceneQuery.h; sourceTree = "<group>"; };
+		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Sound.h; sourceTree = "<group>"; };
+		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundDriver.h; sourceTree = "<group>"; };
+		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundEvents.h; sourceTree = "<group>"; };
+		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundManager.h; sourceTree = "<group>"; };
+		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundObject.h; sourceTree = "<group>"; };
+		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundResource.h; sourceTree = "<group>"; };
+		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TrackAnimation.h; sourceTree = "<group>"; };
+		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = World.h; sourceTree = "<group>"; };
 		444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlAi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlRules.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlUi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -1259,12 +1260,12 @@
 		444EB0880BD1153500C6D4A0 /* OgreNewt.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreNewt.framework; path = /Library/Frameworks/OgreNewt.framework; sourceTree = "<absolute>"; };
 		444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenSteer.framework; path = /Library/Frameworks/OpenSteer.framework; sourceTree = "<absolute>"; };
 		444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreCEGUIRenderer.framework; path = /Library/Frameworks/OgreCEGUIRenderer.framework; sourceTree = "<absolute>"; };
-		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LinearSoundFadeFunctor.h; path = ../engine/core/include/LinearSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeFunctor.h; path = ../engine/core/include/SoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeJob.h; path = ../engine/core/include/SoundFadeJob.h; sourceTree = SOURCE_ROOT; };
-		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LinearSoundFadeFunctor.cpp; path = ../engine/core/src/LinearSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeFunctor.cpp; path = ../engine/core/src/SoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeJob.cpp; path = ../engine/core/src/SoundFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinearSoundFadeFunctor.h; sourceTree = "<group>"; };
+		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeFunctor.h; sourceTree = "<group>"; };
+		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeJob.h; sourceTree = "<group>"; };
+		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinearSoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeJob.cpp; sourceTree = "<group>"; };
 		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureController.h; sourceTree = "<group>"; };
 		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureControllerManager.h; sourceTree = "<group>"; };
 		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectFactory.h; sourceTree = "<group>"; };
@@ -1300,21 +1301,21 @@
 		44D814680BF7B5C700534175 /* LandmarkPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LandmarkPath.cpp; path = ../engine/ai/src/LandmarkPath.cpp; sourceTree = SOURCE_ROOT; };
 		44D8146B0BF7B5E800534175 /* Landmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Landmark.h; path = ../engine/ai/include/Landmark.h; sourceTree = SOURCE_ROOT; };
 		44D8146C0BF7B5E800534175 /* LandmarkPath.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LandmarkPath.h; path = ../engine/ai/include/LandmarkPath.h; sourceTree = SOURCE_ROOT; };
-		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Zone.cpp; path = ../engine/core/src/Zone.cpp; sourceTree = SOURCE_ROOT; };
-		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZoneManager.cpp; path = ../engine/core/src/ZoneManager.cpp; sourceTree = SOURCE_ROOT; };
-		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreDefines.h; path = ../engine/core/include/CoreDefines.h; sourceTree = SOURCE_ROOT; };
-		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightFadeJob.h; path = ../engine/core/include/LightFadeJob.h; sourceTree = SOURCE_ROOT; };
-		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
-		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
-		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
-		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
-		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentLoader.cpp; path = ../engine/core/src/ContentLoader.cpp; sourceTree = SOURCE_ROOT; };
-		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitching.cpp; path = ../engine/core/src/SoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Zone.cpp; sourceTree = "<group>"; };
+		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ZoneManager.cpp; sourceTree = "<group>"; };
+		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreDefines.h; sourceTree = "<group>"; };
+		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightFadeJob.h; sourceTree = "<group>"; };
+		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Trigger.h; sourceTree = "<group>"; };
+		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Zone.h; sourceTree = "<group>"; };
+		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = "<group>"; };
+		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = "<group>"; };
+		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = "<group>"; };
+		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = "<group>"; };
+		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentLoader.cpp; sourceTree = "<group>"; };
+		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitching.cpp; sourceTree = "<group>"; };
 		483646A10D83D57800912FEC /* libruby.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libruby.dylib; path = /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/libruby.dylib; sourceTree = "<absolute>"; };
 		4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Xerces.framework; path = /Library/Frameworks/Xerces.framework; sourceTree = "<absolute>"; };
-		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StartAnimationJob.cpp; path = ../engine/core/src/StartAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
+		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StartAnimationJob.cpp; sourceTree = "<group>"; };
 		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatGui.cpp; sourceTree = "<group>"; };
 		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameSaveLoadWindow.cpp; sourceTree = "<group>"; };
 		48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuLoadWindow.cpp; sourceTree = "<group>"; };
@@ -1349,12 +1350,11 @@
 		48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlPropertyKeys.swig; path = ../engine/script/swig/TypeRlPropertyKeys.swig; sourceTree = SOURCE_ROOT; };
 		48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeStdPairIntInt.swig; path = ../engine/script/swig/TypeStdPairIntInt.swig; sourceTree = SOURCE_ROOT; };
 		48389C020D86787900AFAB66 /* RlExports.i */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.interfacer; name = RlExports.i; path = ../engine/script/swig/RlExports.i; sourceTree = SOURCE_ROOT; };
-		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitchingObject.h; path = ../engine/core/include/SoundStitchingObject.h; sourceTree = SOURCE_ROOT; };
-		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitchingObject.cpp; path = ../engine/core/src/SoundStitchingObject.cpp; sourceTree = SOURCE_ROOT; };
+		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitchingObject.h; sourceTree = "<group>"; };
+		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitchingObject.cpp; sourceTree = "<group>"; };
 		48389C190D867AA900AFAB66 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/script/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
 		48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TriggerFactory.cpp; path = ../engine/script/src/TriggerFactory.cpp; sourceTree = SOURCE_ROOT; };
-		483D31100D85B1AF003477A0 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = ../engine/core/include/nulldriver/NullSoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = ../engine/core/src/nulldriver/NullSoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = nulldriver/NullSoundStitching.cpp; sourceTree = "<group>"; };
 		483D31150D85B215003477A0 /* Combatant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Combatant.h; sourceTree = "<group>"; };
 		483D31160D85B215003477A0 /* EffectManagementTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectManagementTask.h; sourceTree = "<group>"; };
 		483D31170D85B215003477A0 /* GameEventLog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventLog.h; sourceTree = "<group>"; };
@@ -1421,28 +1421,29 @@
 		483D87C90D8C55E500F3629E /* RlScript.bundle */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = RlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
 		484FE6B90E17BC8800FA880F /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
 		48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlScriptExportsMac.cpp; path = ../engine/script/swig/RlScriptExportsMac.cpp; sourceTree = SOURCE_ROOT; };
+		4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = nulldriver/NullSoundStitching.h; sourceTree = "<group>"; };
 		48570C1B0D8A6C5400096E35 /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		4857E4E40D46A664009D376D /* OIS.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OIS.framework; path = /Library/Frameworks/OIS.framework; sourceTree = "<absolute>"; };
-		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreMessages.h; path = ../engine/core/include/CoreMessages.h; sourceTree = SOURCE_ROOT; };
-		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobQueue.h; path = ../engine/core/include/JobQueue.h; sourceTree = SOURCE_ROOT; };
+		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreMessages.h; sourceTree = "<group>"; };
+		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobQueue.h; sourceTree = "<group>"; };
 		485A056A0D71EDC40024198D /* MessageObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageObject.h; path = ../engine/core/include/MessageObject.h; sourceTree = SOURCE_ROOT; };
 		485A056B0D71EDC40024198D /* MessagePump.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessagePump.h; path = ../engine/core/include/MessagePump.h; sourceTree = SOURCE_ROOT; };
 		485A056C0D71EDC40024198D /* MessageType.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageType.h; path = ../engine/core/include/MessageType.h; sourceTree = SOURCE_ROOT; };
-		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PolynomicSoundFadeFunctor.h; path = ../engine/core/include/PolynomicSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFile.h; path = ../engine/core/include/SaveGameFile.h; sourceTree = SOURCE_ROOT; };
-		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileReader.h; path = ../engine/core/include/SaveGameFileReader.h; sourceTree = SOURCE_ROOT; };
-		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileWriter.h; path = ../engine/core/include/SaveGameFileWriter.h; sourceTree = SOURCE_ROOT; };
-		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameManager.h; path = ../engine/core/include/SaveGameManager.h; sourceTree = SOURCE_ROOT; };
-		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimeSource.h; path = ../engine/core/include/TimeSource.h; sourceTree = SOURCE_ROOT; };
-		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobQueue.cpp; path = ../engine/core/src/JobQueue.cpp; sourceTree = SOURCE_ROOT; };
+		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PolynomicSoundFadeFunctor.h; sourceTree = "<group>"; };
+		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFile.h; sourceTree = "<group>"; };
+		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileReader.h; sourceTree = "<group>"; };
+		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileWriter.h; sourceTree = "<group>"; };
+		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameManager.h; sourceTree = "<group>"; };
+		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TimeSource.h; sourceTree = "<group>"; };
+		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobQueue.cpp; sourceTree = "<group>"; };
 		485A057E0D71EDF20024198D /* MessagePump.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MessagePump.cpp; path = ../engine/core/src/MessagePump.cpp; sourceTree = SOURCE_ROOT; };
-		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PolynomicSoundFadeFunctor.cpp; path = ../engine/core/src/PolynomicSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFile.cpp; path = ../engine/core/src/SaveGameFile.cpp; sourceTree = SOURCE_ROOT; };
-		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileReader.cpp; path = ../engine/core/src/SaveGameFileReader.cpp; sourceTree = SOURCE_ROOT; };
-		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileWriter.cpp; path = ../engine/core/src/SaveGameFileWriter.cpp; sourceTree = SOURCE_ROOT; };
-		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameManager.cpp; path = ../engine/core/src/SaveGameManager.cpp; sourceTree = SOURCE_ROOT; };
-		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimeSource.cpp; path = ../engine/core/src/TimeSource.cpp; sourceTree = SOURCE_ROOT; };
-		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Trigger.cpp; path = ../engine/core/src/Trigger.cpp; sourceTree = SOURCE_ROOT; };
+		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PolynomicSoundFadeFunctor.cpp; sourceTree = "<group>"; };
+		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFile.cpp; sourceTree = "<group>"; };
+		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileReader.cpp; sourceTree = "<group>"; };
+		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileWriter.cpp; sourceTree = "<group>"; };
+		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameManager.cpp; sourceTree = "<group>"; };
+		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TimeSource.cpp; sourceTree = "<group>"; };
+		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Trigger.cpp; sourceTree = "<group>"; };
 		485B89510E15794A00D5B19C /* Scene.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Scene.h; path = ../engine/script/include/Scene.h; sourceTree = SOURCE_ROOT; };
 		485B89520E15794A00D5B19C /* SceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneLoader.h; path = ../engine/script/include/SceneLoader.h; sourceTree = SOURCE_ROOT; };
 		485B89530E15794A00D5B19C /* SceneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneManager.h; path = ../engine/script/include/SceneManager.h; sourceTree = SOURCE_ROOT; };
@@ -1457,6 +1458,8 @@
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
 		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = "<absolute>"; };
+		4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoaderImpl.h; path = ai/include/DialogLoaderImpl.h; sourceTree = "<group>"; };
+		4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoaderImpl.cpp; path = ai/src/DialogLoaderImpl.cpp; sourceTree = "<group>"; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbstractMovement.h; sourceTree = "<group>"; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FallDownMovement.h; sourceTree = "<group>"; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogBackwardsMovement.h; sourceTree = "<group>"; };
@@ -1505,24 +1508,24 @@
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
 		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = "<absolute>"; };
-		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
-		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleCollection.h; path = ../engine/core/include/SaveAbleCollection.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleFactory.h; path = ../engine/core/include/SaveAbleFactory.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleManager.h; path = ../engine/core/include/SaveAbleManager.h; sourceTree = SOURCE_ROOT; };
+		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAble.h; sourceTree = "<group>"; };
+		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleCollection.h; sourceTree = "<group>"; };
+		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleFactory.h; sourceTree = "<group>"; };
+		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleManager.h; sourceTree = "<group>"; };
 		48D0BE300E273C8000863824 /* WriteableDataStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStream.h; path = ../engine/common/include/WriteableDataStream.h; sourceTree = SOURCE_ROOT; };
 		48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStreamFormatTarget.h; path = ../engine/common/include/WriteableDataStreamFormatTarget.h; sourceTree = SOURCE_ROOT; };
 		48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableFileSystemArchiv.h; path = ../engine/common/include/WriteableFileSystemArchiv.h; sourceTree = SOURCE_ROOT; };
 		48D0BE360E273C9700863824 /* WriteableDataStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStream.cpp; path = ../engine/common/src/WriteableDataStream.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStreamFormatTarget.cpp; path = ../engine/common/src/WriteableDataStreamFormatTarget.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableFileSystemArchiv.cpp; path = ../engine/common/src/WriteableFileSystemArchiv.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAble.cpp; path = ../engine/core/src/SaveAble.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleCollection.cpp; path = ../engine/core/src/SaveAbleCollection.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleFactory.cpp; path = ../engine/core/src/SaveAbleFactory.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleManager.cpp; path = ../engine/core/src/SaveAbleManager.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAble.cpp; sourceTree = "<group>"; };
+		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleCollection.cpp; sourceTree = "<group>"; };
+		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleFactory.cpp; sourceTree = "<group>"; };
+		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleManager.cpp; sourceTree = "<group>"; };
 		48D0BE680E273FF400863824 /* DialogLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoader.h; path = ../engine/ai/include/DialogLoader.h; sourceTree = SOURCE_ROOT; };
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
-		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
-		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
+		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameData.h; sourceTree = "<group>"; };
+		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameData.cpp; sourceTree = "<group>"; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = "<group>"; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = "<group>"; };
@@ -1823,171 +1826,11 @@
 		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
 			isa = PBXGroup;
 			children = (
-				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
-				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
-				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
-				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
-				48D0BE280E273C5E00863824 /* SaveAble.h */,
-				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
-				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
-				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
-				485A05860D71EDF20024198D /* Trigger.cpp */,
-				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
-				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
-				485A05690D71EDC40024198D /* JobQueue.h */,
-				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
-				485A05720D71EDC40024198D /* TimeSource.h */,
-				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
-				48D34A610D90F5D500C89477 /* SaveGameData.h */,
-				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
-				483D31100D85B1AF003477A0 /* NullSoundStitching.h */,
-				485A05850D71EDF20024198D /* TimeSource.cpp */,
-				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
-				483646960D83D13700912FEC /* ContentLoader.h */,
-				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
-				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
-				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
-				485A056E0D71EDC40024198D /* SaveGameFile.h */,
-				485A05670D71ED8D0024198D /* CoreMessages.h */,
-				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
-				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
-				485A05710D71EDC40024198D /* SaveGameManager.h */,
-				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
-				483646970D83D13700912FEC /* SoundStitching.h */,
-				483646980D83D13700912FEC /* StartAnimationJob.h */,
-				485A057D0D71EDF20024198D /* JobQueue.cpp */,
-				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
-				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
-				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
-				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
-				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
-				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
-				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
-				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
-				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
-				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
-				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
-				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
-				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
-				44D814730BF7B62F00534175 /* CoreDefines.h */,
-				44D814740BF7B62F00534175 /* LightFadeJob.h */,
-				44D814750BF7B62F00534175 /* Trigger.h */,
-				44D814760BF7B62F00534175 /* Zone.h */,
-				44D814770BF7B62F00534175 /* ZoneManager.h */,
-				44D8146F0BF7B61500534175 /* Zone.cpp */,
-				44D814700BF7B61500534175 /* ZoneManager.cpp */,
-				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
-				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
-				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
-				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
-				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
-				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
-				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
-				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
-				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
-				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
-				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
-				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
-				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
-				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
-				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
-				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
-				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
-				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
-				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
-				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
-				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
-				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
-				444EABB50BD0E33300C6D4A0 /* Job.h */,
-				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
-				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
-				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
-				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
-				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
-				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
-				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
-				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
-				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
-				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
-				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
-				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
-				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
-				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
-				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
-				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
-				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
-				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
-				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
-				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
-				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
-				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
-				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
-				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
-				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
-				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
-				444EABD60BD0E33300C6D4A0 /* Sound.h */,
-				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
-				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
-				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
-				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
-				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
-				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
-				444EABDD0BD0E33300C6D4A0 /* World.h */,
-				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
-				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
-				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
-				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
-				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
-				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
-				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
-				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
-				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
-				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
-				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
-				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
-				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
-				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
-				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
-				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
-				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
-				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
-				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
-				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
-				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
-				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
-				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
-				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
-				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
-				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
-				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
-				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
-				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
-				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
-				444EAB420BD0E2B600C6D4A0 /* nulldriver */,
-				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
-				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
-				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
-				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
-				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
-				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
-				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
-				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
-				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
-				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
-				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
-				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
-				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
-				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
-				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
-				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
-				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
-				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
-				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
-				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
-				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
-				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+				4851EA4C0EDDC82400AB79E9 /* Source */,
+				4851EA4D0EDDC8CA00AB79E9 /* Header */,
 			);
 			name = RlCore;
+			path = core;
 			sourceTree = "<group>";
 		};
 		444EAC220BD0E3E000C6D4A0 /* RlAi */ = {
@@ -2066,7 +1909,9 @@
 				444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */,
 				444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */,
 				48D0BE680E273FF400863824 /* DialogLoader.h */,
+				4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */,
 				48D0BE6B0E27401E00863824 /* DialogLoader.cpp */,
+				4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */,
 			);
 			name = RlAi;
 			sourceTree = "<group>";
@@ -2174,6 +2019,184 @@
 			path = src;
 			sourceTree = "<group>";
 		};
+		4851EA4C0EDDC82400AB79E9 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
+				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
+				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
+				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
+				485A05860D71EDF20024198D /* Trigger.cpp */,
+				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
+				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
+				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
+				485A05850D71EDF20024198D /* TimeSource.cpp */,
+				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
+				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
+				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
+				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
+				485A057D0D71EDF20024198D /* JobQueue.cpp */,
+				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
+				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
+				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
+				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
+				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
+				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
+				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
+				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
+				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
+				44D8146F0BF7B61500534175 /* Zone.cpp */,
+				44D814700BF7B61500534175 /* ZoneManager.cpp */,
+				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
+				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
+				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
+				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
+				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
+				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
+				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
+				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
+				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
+				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
+				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
+				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
+				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
+				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
+				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
+				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
+				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
+				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
+				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
+				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
+				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
+				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
+				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
+				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
+				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
+				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
+				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
+				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
+				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
+				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
+				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
+				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
+				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
+				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
+				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
+				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
+				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
+				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
+				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
+				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
+				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
+				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
+				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
+				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
+				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
+				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
+				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
+				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
+				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
+				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
+				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
+				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+			);
+			name = Source;
+			path = src;
+			sourceTree = "<group>";
+		};
+		4851EA4D0EDDC8CA00AB79E9 /* Header */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE280E273C5E00863824 /* SaveAble.h */,
+				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
+				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
+				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
+				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
+				485A05690D71EDC40024198D /* JobQueue.h */,
+				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
+				485A05720D71EDC40024198D /* TimeSource.h */,
+				48D34A610D90F5D500C89477 /* SaveGameData.h */,
+				483646960D83D13700912FEC /* ContentLoader.h */,
+				485A056E0D71EDC40024198D /* SaveGameFile.h */,
+				485A05670D71ED8D0024198D /* CoreMessages.h */,
+				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
+				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
+				485A05710D71EDC40024198D /* SaveGameManager.h */,
+				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
+				483646970D83D13700912FEC /* SoundStitching.h */,
+				483646980D83D13700912FEC /* StartAnimationJob.h */,
+				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
+				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
+				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
+				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
+				44D814730BF7B62F00534175 /* CoreDefines.h */,
+				44D814740BF7B62F00534175 /* LightFadeJob.h */,
+				44D814750BF7B62F00534175 /* Trigger.h */,
+				44D814760BF7B62F00534175 /* Zone.h */,
+				44D814770BF7B62F00534175 /* ZoneManager.h */,
+				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
+				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
+				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
+				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
+				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
+				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
+				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
+				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
+				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
+				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
+				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
+				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
+				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
+				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
+				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
+				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
+				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
+				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
+				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
+				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
+				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
+				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
+				444EABB50BD0E33300C6D4A0 /* Job.h */,
+				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
+				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
+				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
+				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
+				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
+				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
+				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
+				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
+				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
+				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
+				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
+				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
+				4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */,
+				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
+				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
+				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
+				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
+				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
+				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
+				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
+				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
+				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
+				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
+				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
+				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
+				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
+				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
+				444EABD60BD0E33300C6D4A0 /* Sound.h */,
+				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
+				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
+				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
+				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
+				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
+				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
+				444EABDD0BD0E33300C6D4A0 /* World.h */,
+			);
+			name = Header;
+			path = include;
+			sourceTree = "<group>";
+		};
 		48B006C30ECABFB0008141C2 /* windows */ = {
 			isa = PBXGroup;
 			children = (
@@ -2651,7 +2674,6 @@
 				483646990D83D13700912FEC /* ContentLoader.h in Headers */,
 				4836469A0D83D13700912FEC /* SoundStitching.h in Headers */,
 				4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */,
-				483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */,
 				48389C0F0D86797000AFAB66 /* SoundStitchingObject.h in Headers */,
 				48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */,
 				48D34A630D90F5D500C89477 /* SaveGameData.h in Headers */,
@@ -2664,6 +2686,7 @@
 				48D0BE2D0E273C5E00863824 /* SaveAbleCollection.h in Headers */,
 				48D0BE2E0E273C5E00863824 /* SaveAbleFactory.h in Headers */,
 				48D0BE2F0E273C5E00863824 /* SaveAbleManager.h in Headers */,
+				4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2710,6 +2733,7 @@
 				483D31630D85B398003477A0 /* SimpleVehicle.h in Headers */,
 				483D31640D85B398003477A0 /* WalkPathBehaviour.h in Headers */,
 				48D0BE690E273FF400863824 /* DialogLoader.h in Headers */,
+				4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3317,6 +3341,7 @@
 				48389BC10D8675E700AFAB66 /* DialogResponse.cpp in Sources */,
 				48389BC20D8675E700AFAB66 /* DialogVariable.cpp in Sources */,
 				48D0BE6D0E27401E00863824 /* DialogLoader.cpp in Sources */,
+				4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/cmake/FindOGRE.cmake
===================================================================
--- rl/branches/newton20/cmake/FindOGRE.cmake	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/cmake/FindOGRE.cmake	2008-12-17 20:11:09 UTC (rev 4654)
@@ -47,6 +47,9 @@
 	CACHE STRING ""
 )
 
+# Allow to set Ogre plugin path manually
+SET(OGRE_PLUGINDIR "" CACHE STRING "Ogre plugin directory")
+
 #Search for the headers and libraries
 IF (WIN32) #Windows
 	MESSAGE(STATUS "Looking for OGRE")
@@ -57,6 +60,10 @@
 	IF(PKG_CONFIG_FOUND)
 		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
 		PKG_SEARCH_MODULE(OGRE OGRE)
+		IF(NOT PKGCONFIG_FAILED)
+			_PKGCONFIG_INVOKE(OGRE "OGRE" PLUGINDIR "" --variable=plugindir)
+			ADD_DEFINITIONS(-DOGRE_PLUGINDIR=\\"${OGRE_PLUGINDIR}\\")
+		ENDIF(NOT PKGCONFIG_FAILED)
 		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
 		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
 		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING "")

Copied: rl/branches/newton20/cmake/FindOgreNewt.cmake (from rev 4644, rl/trunk/cmake/FindOgreNewt.cmake)

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -124,6 +124,7 @@
         self.gocName = gameObjectClass
         self.node = node
         self.meshFile = meshFile
+        self.state = "IN_SCENE"
 
     def getType(self):
         return "GAME_OBJECT_REPRESENTATION"

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -59,6 +59,8 @@
         self.objectPropertyWin = ObjectPropertyWin(self)
         self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
         self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
         self.createDockWindows()
@@ -273,6 +275,9 @@
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+        self.moduleManager.pivot.hide()
+
         oglog = og.LogManager.getSingleton().getDefaultLog()
         oglog.addListener(self.consoleWindow.lockenLog)
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -97,9 +97,8 @@
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
-        QObject.connect(self.modelSearchBox,SIGNAL("textChanged(QString)"),self.listWidget.clearSelection)
-        QMetaObject.connectSlotsByName(self)
 
+
     def retranslateUi(self):
         self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
 
@@ -115,14 +114,14 @@
         self.node.setScale(og.Vector3(1,1,1))
         bb = self.ent.getBoundingBox()
 
-    def scanDirForModels(self, dir, name):
+    def scanDirForModels(self, dir):
         for file in os.listdir(dir):
             curFile = dir + "/" + file
 
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
             if isdir(curFile):
-                self.scanDirForModels(curFile, file)
+                self.scanDirForModels(curFile)
                 continue
             if isfile(curFile):
                 if file.endswith(".mesh"):
@@ -143,6 +142,7 @@
         if event.type() == 5:
             self.startDrag()
             event.accept()
+            return True
 
         return False
 
@@ -152,6 +152,7 @@
                 self.ogreModelPrevWindow.zoomCamera(-5)
             else:
                 self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
 
         if event.type() == 5: #mouse moved while button down
             rotX = (event.globalX() - self.lastMousePosX) * 0.01
@@ -162,10 +163,12 @@
 
             self.lastMousePosX = event.globalX()
             self.lastMousePosY = event.globalY()
+            return True
 
         if event.type() == 3: # mouse released
             self.lastMousePosX = 0
             self.lastMousePosY = 0
+            return True
 
         return False
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -35,32 +35,77 @@
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
 
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
         self.pathToMapFile = pathToFile
         self.sceneManager = sceneManager
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
 
         xmlTree = xml.parse(pathToFile)
         root = xmlTree.getroot()
 
         if root.attrib["formatVersion"] == "0.4.0":
-            self.parseMap(root)
+            self.parseMapNodes(root.find("nodes"))
+            #self.parseMapZones(root.find("zones"))
         else:
             print pathToFile + " has wrong format version. It needs to be 0.4.0"
             return
 
-    def parseMap(self, rootElement):
-        nodes = rootElement.getiterator("entity")
-        for n in nodes:
-            entityName = n.attrib["name"]
-            meshFile = n.attrib["meshfile"]
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("entity")
+        if len(nodes) > 0:
+            self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        if len(nodes) > 0:
+            self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        if len(nodes) > 0:
+            self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("gameobject")
+        if len(nodes) > 0:
+            self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        if len(nodes) > 0:
+            self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            print entityName
+            meshFile = nodes.attrib["meshfile"]
             nodePosition = None
             nodeRotation = None
             nodeScale = None
 
-            transformations = n.getiterator()
+            transformations = nodes.getiterator()
             for t in transformations:
                 if t.tag == "position":
                     x = float(t.attrib["x"])
@@ -83,7 +128,7 @@
                 e = self.sceneManager.createEntity(entityName, meshFile)
             except:
                 print "Warning: Meshfile " + meshFile + " could not be found."
-                return
+                continue
 
             n = self.mapNode.createChild(entityName + "_node")
             n.attachObject(e)
@@ -91,17 +136,113 @@
             n.setOrientation(nodeRotation)
             n.setScale(nodeScale)
 
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationlinear = None
+            lightAttenuationQuadratic = None
 
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationlinear = float(t.attrib["linear"])
+                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
 
+            e = self.sceneManager.createEntity(lightName, "lightbulp.mesh")
+            n = self.mapNode.createChild(lightName + "_node")
+            n.attachObject(e)
+            n.setPosition(lightPosition)
 
+    def createSound(self, soundNodes):
+        raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            id = int(g.attrib["id"])
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        raise NotImplementedError
+        return
+
 class Scene():
     def __init__(self):
         return
 
 class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
 
         self.name = name
         self.moduleRoot = join(modulePath, name)
@@ -164,11 +305,15 @@
         self.setResourcePaths()
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
         if not self.isCommon():
             cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
             maps = glob.glob(cmd)
             for m in maps:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
 
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
@@ -191,7 +336,7 @@
 
 
             if file.startswith('.'): #ignore dot files (hidden)
-                pass
+                continue
             if os.path.isdir(curFile):
                 og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
                 self.setResourcePaths(curFile)
@@ -202,10 +347,17 @@
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
         self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
 
         self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
 
+
         self.mainModule = []
         self.mainModuledependencieList =[]
         self.moduleList = []
@@ -213,16 +365,12 @@
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
 
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
         self.listenerDings = MyRaySceneQueryListener()
 
         self.lastRay = None
 #        self.rayLine = None
 
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
         self.pivot = None
         self.movingPivot = False
 
@@ -253,7 +401,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
 
         self.moduleConfigIsParsed = True
 
@@ -280,20 +428,33 @@
         if dlg.exec_():
             self.loadModule(str(list.currentItem().text()))
 
+    # I'm sorry for this
     def loadModule(self, moduleName):
         for m in self.moduleList:
             if m.name == moduleName:
-                if m.hasDependencies:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
                     for moduleDependencie in m.moduleDependencies:
                         for m2 in self.moduleList:
                             if m2.name == moduleDependencie:
                                 m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
                 m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
                 self.mainModule = m
 
+        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
+        e.setMaterialName("Lockenwickler_Area")
 
+        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
+        e2.setMaterialName("Lockenwickler_Area")
+
+        n.attachObject(e)
+        n.attachObject(e2)
+        n.setScale(og.Vector3(10, 5, 20))
+
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
         self.listenerDings.reset()
@@ -496,9 +657,9 @@
 
     def startDropGameObjectAction(self, classid, ray):
         go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
 
         if go is not None:
+            meshFile = go.getMeshFileName()
             dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
             dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
             dropNode.attachObject(dropEntity)

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -150,6 +150,7 @@
 
     def eventFilter(self, obj, event):
         if event.type() == 2:
+            self.ogreRenderWindow.setFocus()
             if event.button() == 1: # left mouse button is pressed
                 self.leftMouseDown = True
                 self.moduleManager.leftMouseDown = True

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/Barrel.mesh
===================================================================
(Binary files differ)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/Example.material
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/media/Example.material	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/media/Example.material	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,18 +0,0 @@
-material RustyBarrel
-{
-	technique
-	{
-		pass
-		{
-			ambient 0.5 0.5 0.5 1.0
-			diffuse 1.0 1.0 1.0 1.0
-			specular 0.0 0.0 0.0 1.0 12.5
-			emissive 0.0 0.0 0.0 1.0
-			texture_unit
-			{
-				texture RustyBarrel.png
-				filtering trilinear
-			}
-		}
-	}
-}

Modified: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-17 20:11:09 UTC (rev 4654)
@@ -4,8 +4,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 1.0 0.0 0.0 0.5
 			diffuse 1.0 0.0 0.0 0.5
 			specular 1.0 0.0 0.0 0.5 12.5
@@ -21,8 +19,6 @@
 
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -37,8 +33,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 1.0 0.0 0.5
 			diffuse 0.0 1.0 0.0 0.5
 			specular 0.0 1.0 0.0 0.5 12.5
@@ -60,4 +54,44 @@
 		}
 	}
 }
+
+material SOLID/TEX/lightbulp.png
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+				texture lightbulp.png
+			}
+		}
+	}
+}
+
+material Lockenwickler_Area
+{
+	technique
+	{
+                pass
+		{
+                        depth_write off
+                        scene_blend alpha_blend
+                        
+			ambient 0.0 1.0 0.0 0.2
+			diffuse 0.0 1.0 0.0 0.2
+			emissive 0.0 1.0 0.0 0.2
+		}
+
+		pass
+		{
+                        polygon_mode wireframe
+
+			ambient 0.0 1.0 0.0 1.0
+			diffuse 0.0 1.0 0.0 1.0
+			emissive 0.0 1.0 0.0 1.0
+		}
+	}
+}
+
  

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/UniCube.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/UniCube.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/UniSphere.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/UniSphere.mesh)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.blend (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.blend)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.png (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.png)

Copied: rl/branches/newton20/engine/ai/CMakeLists.txt (from rev 4644, rl/trunk/engine/ai/CMakeLists.txt)

Modified: rl/branches/newton20/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ai/RlAI2005.vcproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/RlAI2005.vcproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -367,6 +367,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\DialogLoaderImpl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\DialogManager.cpp"
 				>
 			</File>
@@ -541,6 +545,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\DialogLoaderImpl.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\DialogManager.h"
 				>
 			</File>

Modified: rl/branches/newton20/engine/ai/include/DialogImplication.h
===================================================================
--- rl/branches/newton20/engine/ai/include/DialogImplication.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/DialogImplication.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,96 +1,103 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DialogImplication_H__
-#define __DialogImplication_H__
-
-#include "AiPrerequisites.h"
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport DialogImplication
-    {
-    public:
-        DialogImplication();
-        virtual ~DialogImplication();
-        
-        virtual void apply(Dialog* dialog) = 0;
-    };
-
-    class DialogVariableAssignment : public DialogImplication
-    {
-    public:
-        DialogVariableAssignment(const Ogre::String& variableName, 
-                                 const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-
-    protected:
-        Ogre::String mVariableName; 
-        CeGuiString mValue;
-    };
-
-    class DialogVariableIncrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableIncrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogVariableDecrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableDecrease(const Ogre::String& variableName, 
-                               const CeGuiString& value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogElementActivation : public DialogImplication
-    {
-    public:
-        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
-        virtual void apply(Dialog* dialog);
-    private:
-        CeGuiString mElementId;
-        bool mValue;
-        bool mIsOption;
-    };
-
-	class DialogExit : public DialogImplication
-	{
-	public:
-		virtual void apply(Dialog* dialog);
-	};
-
-    class QuestPropertyAssignment : public DialogImplication
-    {
-    public:
-        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
-        virtual void apply(Dialog* dialog);
-
-    private:
-        Ogre::String mQuestId;
-        Ogre::String mProperty;
-        CeGuiString mNewValue;
-    };
-}
-
-#endif //__DialogImplication_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String& variableName, 
+                                 const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+
+    protected:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+
+    class DialogVariableIncrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableIncrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogVariableDecrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableDecrease(const Ogre::String& variableName, 
+                               const CeGuiString& value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogElementActivation : public DialogImplication
+    {
+    public:
+        DialogElementActivation(const CeGuiString& id, bool value, bool isOption);
+        virtual void apply(Dialog* dialog);
+    private:
+        CeGuiString mElementId;
+        bool mValue;
+        bool mIsOption;
+    };
+
+	class DialogExit : public DialogImplication
+	{
+	public:
+		virtual void apply(Dialog* dialog);
+	};
+
+    class QuestPropertyAssignment : public DialogImplication
+    {
+    public:
+        QuestPropertyAssignment(const Ogre::String& questId, const Ogre::String& prop, const CeGuiString& newValue);
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mQuestId;
+        Ogre::String mProperty;
+        CeGuiString mNewValue;
+    };
+    
+    class CombatStart : public DialogImplication
+    {
+    public:
+        CombatStart();
+        virtual void apply(Dialog* dialog);
+    };
+}
+
+#endif //__DialogImplication_H__

Modified: rl/branches/newton20/engine/ai/include/DialogLoader.h
===================================================================
--- rl/branches/newton20/engine/ai/include/DialogLoader.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/DialogLoader.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,24 +18,13 @@
 
 #include "AiPrerequisites.h"
 
-#include "Properties.h"
-#include "XmlProcessor.h"
- 
 namespace rl 
 {
 	class Creature;
     class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-	class Property;
+    class DialogLoaderImpl;
 
-
-	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	class DialogLoader : public Ogre::ScriptLoader
 	{
 	public:
 		DialogLoader();
@@ -48,48 +37,9 @@
 		Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
 
 	private: 
-		class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString& id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString& id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
-            void setProperty(const CeGuiString& key, const Property& value);
-
-        private:
-            std::map<CeGuiString, DialogOption*> mOptionCache;
-            std::map<CeGuiString, DialogResponse*> mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-		
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
-
         Ogre::StringVector mScriptPatterns;
-        std::map<Ogre::String, DialogPrototype*> mDialogs;
-
-	};
+        DialogLoaderImpl* mLoaderImplementation;
+    };
 }
 
 #endif //__DialogLoader_H__

Copied: rl/branches/newton20/engine/ai/include/DialogLoaderImpl.h (from rev 4644, rl/trunk/engine/ai/include/DialogLoaderImpl.h)

Modified: rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,167 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __RlAI_FuzzyStateMachine_H__
-#define __RlAI_FuzzyStateMachine_H__
-#include <list>
-#include "AiPrerequisites.h"
-#include "FuzzyState.h"
-#include "ScriptWrapper.h"
-
-namespace rl
-{
-	/** manages a set of FuzzyState objects 
-	 */
-	template <class Controller> class FuzzyStateMachine :
-		public FuzzyState<Controller>
-	{
-	public:
-		//! typedefinition for pointer to a FuzzyState
-		typedef FuzzyState<Controller>* FuzzyStatePtr;
-
-		/** Constructor
-		 * sets parent and controller for the FuzzyStateMachine
-		 * @param parent gives the parent FuzzyState object
-		 * @param controller sets the controller object
-		 */
-		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
-			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
-
-		/** destructor.
-		 * removes internally stored Fuzzystate objects
-		 */
-		virtual ~FuzzyStateMachine(void)
-		{
-			clearStates();
-		}
-
-		/** adds a FuzzyState object
-		 * @param state a FuzzyState object to add.
-		 */
-		virtual void addState(FuzzyStatePtr state)
-		{
-			mStates.push_back(State(false, state));
-            ScriptWrapper::getSingleton().owned( state );
-		}
-		/** removes all stored FuzzyState objects
-		 */
-        virtual void clearStates()
-		{
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.begin(); ++itr)
-			{
-                ScriptWrapper::getSingleton().disowned( itr->second );
-				delete itr->second;
-			}
-			mStates.clear();
-		}
-
-		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
-		 * So always return false (no).
-		 * @returns false
-		 */
-		virtual bool isActive(FuzzyStatePtr state)
-		{
-			return false; 
-		}
-		/** reset function for resetting the FuzzyStateMachine
-		 */
-		virtual void reset(){}
-
-		/** sets the maximum number of concurrently active states.
-		 * @param count maximum number of concurrently active states.
-		 */
-		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
-		/** fetches the maximum number of concurrently active states.
-		 * @param int returns the maximum number of concurrently active states.
-		 */
-		virtual int getMaxActivity() { return mMaxActiveStates; }
-
-		/** calculates the activation value.
-		 * @returns float containing the calculated activation value.
-		 */
-		float calculateActivation(void){ return 0.0f; }
-
-		/** initializes the fuzzy state.
-		 */
-		virtual void init(){}
-		/** should activate the fuzzy state.
-		 */
-		virtual void activate(){}
-		/** deactivates fuzzy state.
-		 */
-		virtual void deactivate(){}
-		/** tells the fuzzy state machine to update for the elapsed time.
-		 * For each stored FuzzyState the activation is calculated and
-		 * testified whether it activates the state or not. When a state
-		 * is active its update function is called with the elapsed time.
-		 * @param elapsedtime gives the elapsed time as a float
-		 */
-		virtual void update(const float elapsedTime)
-		{
-			if(mStates.empty())
-				return;
-
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.end(); ++itr)
-			{
-				bool isActive = (itr->second->calculateActivation() > 0);
-				if(isActive)
-				{
-				//  if state is already active, update it, otherwise activate it
-					if(itr->first)
-					{
-						itr->second->update(elapsedTime);
-					}
-					else
-					{
-						itr->second->activate();
-						itr->first = true;
-						// maybe call update here, too
-					}
-				}
-				else
-				{
-				//	if state was active, deactivate it, otherwise do nothing
-					if(itr->first)
-					{
-						itr->second->deactivate();
-						itr->first = false;
-					}	
-				}
-			}
-		}
-
-
-	protected:
-		//! maximum number of active states
-		int mMaxActiveStates;
-		/** typedefinition for active/inactive and FuzzyState objects.
-		 * When the boolean is true, the state is active, otherwise not
-		 */
-		typedef std::pair<bool, FuzzyStatePtr> State;
-		//! defines a double linked list of states
-		typedef std::list<State> StateList;
-		//! the double linked list of stored FuzzyState objects
-		StateList mStates;
-	};
-
-/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
-	{
-
-	}
-*/
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __RlAI_FuzzyStateMachine_H__
+#define __RlAI_FuzzyStateMachine_H__
+#include <list>
+#include "AiPrerequisites.h"
+#include "FuzzyState.h"
+#include "ScriptWrapper.h"
+
+namespace rl
+{
+	/** manages a set of FuzzyState objects 
+	 */
+	template <class Controller> class FuzzyStateMachine :
+		public FuzzyState<Controller>
+	{
+	public:
+		//! typedefinition for pointer to a FuzzyState
+		typedef FuzzyState<Controller>* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
+		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
+			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
+
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
+		virtual ~FuzzyStateMachine(void)
+		{
+			clearStates();
+		}
+
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
+		virtual void addState(FuzzyStatePtr state)
+		{
+			mStates.push_back(State(false, state));
+            ScriptWrapper::getSingleton().owned( state );
+		}
+		/** removes all stored FuzzyState objects
+		 */
+        virtual void clearStates()
+		{
+			for(typename StateList::iterator itr = mStates.begin(); itr != mStates.end(); ++itr)
+			{
+                FuzzyStatePtr state = itr->second;
+                ScriptWrapper::getSingleton().disowned( state );
+				delete state;
+			}
+			mStates.clear();
+		}
+
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
+		virtual bool isActive(FuzzyStatePtr state)
+		{
+			return false; 
+		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
+		virtual void reset(){}
+
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
+		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
+		virtual int getMaxActivity() { return mMaxActiveStates; }
+
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
+		float calculateActivation(void){ return 0.0f; }
+
+		/** initializes the fuzzy state.
+		 */
+		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
+		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
+		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
+		virtual void update(const float elapsedTime)
+		{
+			if(mStates.empty())
+				return;
+
+			typename StateList::iterator itr = mStates.begin();
+			for(; itr != mStates.end(); ++itr)
+			{
+				bool isActive = (itr->second->calculateActivation() > 0);
+				if(isActive)
+				{
+				//  if state is already active, update it, otherwise activate it
+					if(itr->first)
+					{
+						itr->second->update(elapsedTime);
+					}
+					else
+					{
+						itr->second->activate();
+						itr->first = true;
+						// maybe call update here, too
+					}
+				}
+				else
+				{
+				//	if state was active, deactivate it, otherwise do nothing
+					if(itr->first)
+					{
+						itr->second->deactivate();
+						itr->first = false;
+					}	
+				}
+			}
+		}
+
+
+	protected:
+		//! maximum number of active states
+		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
+		typedef std::pair<bool, FuzzyStatePtr> State;
+		//! defines a double linked list of states
+		typedef std::list<State> StateList;
+		//! the double linked list of stored FuzzyState objects
+		StateList mStates;
+	};
+
+/*	template <class Controller> void FuzzyStateMachine<Controller>::update(float elapsedTime)
+	{
+
+	}
+*/
+}
+#endif

Modified: rl/branches/newton20/engine/ai/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ai/include/Makefile.am	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/Makefile.am	2008-12-17 20:11:09 UTC (rev 4654)
@@ -20,6 +20,7 @@
 	DialogElementSelection.h \
 	DialogImplication.h \
 	DialogLoader.h \
+	DialogLoaderImpl.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/branches/newton20/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/DialogImplication.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/DialogImplication.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,137 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"
-
-#include "DialogImplication.h"
-
-#include "Dialog.h"
-#include "RulesSubsystem.h"
-#include "Property.h"
-#include "QuestBook.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    DialogImplication::DialogImplication()
-    {
-    }
-
-    DialogImplication::~DialogImplication()
-    {
-    }
-
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
-                                                       const CeGuiString& value)
-        : mVariableName(variableName), mValue(value)
-    {
-    }
-
-    void DialogVariableAssignment::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        prop.getFromString(mValue);
-        dialog->setProperty(mVariableName, prop);
-    }
-
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableIncrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
-                                                   const CeGuiString& value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableDecrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog->getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog->getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
-            prop.setValue(value);
-            dialog->setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
-                                      + mVariableName
-                                      + "'. The variable's type is not a number");
-        }
-    }
-
-    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
-                                                     bool value,
-                                                     bool isOption)
-        : mElementId(id), mValue(value), mIsOption(isOption)
-    {
-    }
-
-    void DialogElementActivation::apply(Dialog* dialog)
-    {
-        Property prop;
-        if(mIsOption)
-        {
-            dialog->setProperty("option" + mElementId + "isActive", mValue);
-        }
-        else
-        {
-            dialog->setProperty("response" + mElementId + "isActive", mValue);
-        }
-    }
-
-	void DialogExit::apply(rl::Dialog *dialog)
-	{
-		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
-	}
-
-    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
-        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
-    {
-    }
-
-    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
-    {
-        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
-        quest->setPropertyAsString(mProperty, mNewValue);
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "DialogImplication.h"
+
+#include "Combat.h"
+#include "CombatManager.h"
+#include "Dialog.h"
+#include "Property.h"
+#include "QuestBook.h"
+#include "RulesSubsystem.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
+                                                       const CeGuiString& value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog->setProperty(mVariableName, prop);
+    }
+
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableIncrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
+                                                   const CeGuiString& value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableDecrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog->getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog->getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
+            prop.setValue(value);
+            dialog->setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
+                                      + mVariableName
+                                      + "'. The variable's type is not a number");
+        }
+    }
+
+    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
+                                                     bool value,
+                                                     bool isOption)
+        : mElementId(id), mValue(value), mIsOption(isOption)
+    {
+    }
+
+    void DialogElementActivation::apply(Dialog* dialog)
+    {
+        Property prop;
+        if(mIsOption)
+        {
+            dialog->setProperty("option" + mElementId + "isActive", mValue);
+        }
+        else
+        {
+            dialog->setProperty("response" + mElementId + "isActive", mValue);
+        }
+    }
+
+	void DialogExit::apply(rl::Dialog *dialog)
+	{
+		dialog->setProperty(Dialog::PROP_EXIT_REQUESTED, true);
+	}
+
+    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &questId, const Ogre::String &prop, const rl::CeGuiString &newValue)
+        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
+    {
+    }
+
+    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
+    {
+        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
+        quest->setPropertyAsString(mProperty, mNewValue);
+    }
+    
+    CombatStart::CombatStart()
+    {
+    }
+    
+    void CombatStart::apply(Dialog* dialog)
+    {
+        Combat* combat = CombatManager::getSingleton().startCombat();
+        std::vector<Creature*> allies = dialog->getPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = allies.begin(); it != allies.end(); ++it)
+        {
+            combat->addAlly(*it);            
+        }
+        std::vector<Creature*> enemies = dialog->getNonPlayerCharacters();
+        for (std::vector<Creature*>::iterator it = enemies.begin(); it != enemies.end(); ++it)
+        {
+            combat->addOpponent(*it);
+        }
+        combat->start();
+    }
+
+}

Modified: rl/branches/newton20/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/DialogLoader.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/DialogLoader.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,57 +1,38 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
 #include "stdinc.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "DialogLoader.h"
+#include "DialogLoaderImpl.h"
 
-#include "ConfigurationManager.h"
-#include "Dialog.h"
-#include "DialogCondition.h"
-#include "DialogElement.h"
-#include "DialogImplication.h"
-#include "DialogOption.h"
-#include "DialogParagraph.h"
-#include "DialogResponse.h"
-#include "DialogVariable.h"
-#include "XmlPropertyReader.h"
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
 	DialogLoader::DialogLoader()
-	      : XmlProcessor(), ScriptLoader()
+	      : ScriptLoader()
     {
+        mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back("*.dialog");
   	}
 	
     DialogLoader::~DialogLoader()
     {
-		std::map<Ogre::String, DialogPrototype*>::iterator itr = mDialogs.begin();
-        std::map<Ogre::String, DialogPrototype*>::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
-        {
-			DialogPrototype* p = itr->second;
-			delete p;
-		}
-        mDialogs.clear();
+        delete mLoaderImplementation;
 	}
  
     const StringVector& DialogLoader::getScriptPatterns() const
@@ -63,692 +44,16 @@
     {
         return 1000;
     }
-
-    void DialogLoader::parseScript(DataStreamPtr& stream, const Ogre::String& groupName)
+    
+    void DialogLoader::parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
-
-            for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes->item(i);
-                processDialog(static_cast<DOMElement*>(cur));
-            }
-        }
-
-        shutdownXml();
+        mLoaderImplementation->parseDialog(stream, groupName);
     }
-	
-	Dialog* DialogLoader::createDialog(const String& name, const std::vector<Creature*>& pcs, 
-		const std::vector<Creature*>& npcs) const
-	{
-		std::map<Ogre::String, DialogPrototype*>::const_iterator it =
-			mDialogs.find(name);
-			
-		if (it == mDialogs.end())
-		{
-			return NULL;
-		}
-		
-		return it->second->createDialog(pcs, npcs);
-	}
-	
-    void DialogLoader::processDialog(DOMElement* dialogElem)
+    
+    Dialog* DialogLoader::createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const
     {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, "option", dialogPrototype);
-        processElementNodes(dialogElem, "switchoption", dialogPrototype);
-        processElementNodes(dialogElem, "response", dialogPrototype);
-        processElementNodes(dialogElem, "switchresponse", dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
-        {
-            if (hasNodeName(curChild, "variable"))
-            {
-                createDialogVariable(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "option"))
-            {
-                processOption(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchoption"))
-            {
-                processSwitchOption(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "response"))
-            {
-                processResponse(static_cast<DOMElement*>(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, "switchresponse"))
-            {
-                processSwitchResponse(static_cast<DOMElement*>(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, "start"))
-            {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild->getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype->setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
+        return mLoaderImplementation->createDialog(name, pcs, npcs);
     }
 
-    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml->getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i < dialogElemNodes->getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast<DOMElement*>(dialogElemNodes->item(i));
-            if (!hasAttribute(dialogElemXml, "id"))
-            {
-                Throw(WrongFormatException, "option/switchoption/response/switchresponse node without id found");
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
-            CeGuiString text = getValueAsString(dialogElemXml);
+}
 
-            if (hasNodeName(dialogElemXml, "switchoption"))
-            {
-                DialogOption* option = new DialogSelection<DialogOption>(id);
-                option->setLabel(text);
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "option"))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, "autoSelect");
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, "label"))
-                {
-                    option->setLabel(getAttributeValueAsString(dialogElemXml, "label"));
-                }
-                else
-                {
-                    option->setLabel(text);
-                }
-                dialogPrototype->addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, "response"))
-            {
-                dialogPrototype->addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, "switchresponse"))
-            {
-                dialogPrototype->addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, "response"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "gotoresponse"))
-        {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchresponse"))
-        {
-            response = processSwitchResponse(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, "id");
-
-        DialogResponse* response = dialogPrototype->getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response->addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response->addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, "p"))
-                {
-                    response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, "gotoresponse"))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast<DOMElement*>(cur), "id");
-                    response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response->addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
-        DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                response->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response->addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, "option"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, "optionref"))
-        {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, "switchoption"))
-        {
-            option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, "id");
-
-        DialogOption* option = dialogPrototype->getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option->setResponse(response);
-                }
-                else if (hasNodeName(cur, "if"))
-                {
-                    option->setPrecondition(processIf(static_cast<DOMElement*>(cur)));
-                }
-                else if (hasNodeName(cur, "p"))
-                {
-                    option->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, "t"))
-                {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
-                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, "label");
-                        if(!label.empty())
-                        {
-                            option->setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option->addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
-            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, "label");
-            if(!label.empty())
-            {
-                option->setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
-        DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
-            if (variable != NULL)
-            {
-                option->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option->addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, "t"))
-            {
-                DOMElement* translation = static_cast<DOMElement*>(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, "language") == 
-                    ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, "label");
-                    if(!label.empty())
-                    {
-                        option->setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype->setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast<DOMElement*>(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond->setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = "";
-        if (hasAttribute(paragraphXml, "voicefile"))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, "voicefile");
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast<DOMElement*>(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    DialogLoader::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogLoader::DialogPrototype::~DialogPrototype()
-    {
-        std::map<CeGuiString, DialogOption*>::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it->second != NULL )
-                delete it->second;
-
-        std::map<CeGuiString, DialogResponse*>::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1->second != NULL )
-                delete it1->second;
-    }
-
-    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option->getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate option/switchoption ID "+ option->getId()).c_str());
-        }
-        mOptionCache[option->getId()] = option;
-    }
-
-    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogOption*>::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response->getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString("Duplicate Response/switchResponse ID "+ response->getId()).c_str());
-        }
-        mResponseCache[response->getId()] = response;
-    }
-
-    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString& id) const
-    {
-        std::map<CeGuiString, DialogResponse*>::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it->second;
-    }
-
-    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog->setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog->setProperty(it->first, it->second);
-        }
-
-        return dialog;
-    }
-
-    void DialogLoader::DialogPrototype::setProperty(const CeGuiString& key, const Property& value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-
-    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, "equals"))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "inrange"))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, "from"),
-                getAttributeValueAsReal(conditionXml, "to"));
-        }
-        else if (hasNodeName(conditionXml, "lower"))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "lowereq"))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greater"))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-        else if (hasNodeName(conditionXml, "greatereq"))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, "value"));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, "dialogvariable"))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, "name"));
-        }
-        else if (hasNodeName(variableXml, "queststate"))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, "quest");
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, "property");
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, "attributecheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "attribute");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, "talentcheck"))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, "talent");
-            CeGuiString target = getAttributeValueAsString(variableXml, "target");
-            int modifier = 0;
-            if (hasAttribute(variableXml, "modifier"))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, "modifier");
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-		else if (hasNodeName(variableXml, "random"))
-		{
-			int maximum = getAttributeValueAsInteger(variableXml, "maximum");
-			return new RandomVariable(maximum);
-		}
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
-
-            if (hasNodeName(implicationElem, "setvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "incvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "decvariable"))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, "value");
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, "setoptionactive"))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, "id");
-                bool value = getAttributeValueAsBool(implicationElem, "value");
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, "exit"))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, "changequest"))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, "quest");
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, "property");
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, "newvalue");
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (hasNodeName(cur, "p"))
-            {
-                element->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
-            }
-        }
-    }
-
-}
\ No newline at end of file

Copied: rl/branches/newton20/engine/ai/src/DialogLoaderImpl.cpp (from rev 4644, rl/trunk/engine/ai/src/DialogLoaderImpl.cpp)

Modified: rl/branches/newton20/engine/ai/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ai/src/Makefile.am	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/Makefile.am	2008-12-17 20:11:09 UTC (rev 4654)
@@ -22,6 +22,7 @@
 	DialogElement.cpp \
 	DialogImplication.cpp \
 	DialogLoader.cpp \
+	DialogLoaderImpl.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \

Copied: rl/branches/newton20/engine/common/CMakeLists.txt (from rev 4644, rl/trunk/engine/common/CMakeLists.txt)

Modified: rl/branches/newton20/engine/common/include/MathUtil.h
===================================================================
--- rl/branches/newton20/engine/common/include/MathUtil.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/include/MathUtil.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,39 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __MathUtil_H__
-#define __MathUtil_H__
-
-#include "CommonPrerequisites.h"
-
-namespace rl {
-
-class _RlCommonExport MathUtil
-{
-    public:
-        static const Ogre::Real EPSILON;
-
-        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
-            Ogre::Radian azimuth, Ogre::Radian altitude);
-
-        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-            Ogre::Radian& azimuth, Ogre::Radian& altitude);
-        static Ogre::Real normaliseAngle(Ogre::Real angle);
-
-		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
-};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __MathUtil_H__
+#define __MathUtil_H__
+
+#include "CommonPrerequisites.h"
+
+namespace rl 
+{
+    
+    class _RlCommonExport MathUtil
+    {
+    public:
+        static const Ogre::Real EPSILON;
+        
+        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
+                                                  Ogre::Radian azimuth, Ogre::Radian altitude);
+        
+        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+                                         Ogre::Radian& azimuth, Ogre::Radian& altitude);
+        static Ogre::Real normaliseAngle(Ogre::Real angle);
+        
+		static Ogre::Real distance(const Ogre::AxisAlignedBox& b1, const Ogre::AxisAlignedBox& b2);
+        static Ogre::Real distance(const Ogre::Vector3& v, const Ogre::AxisAlignedBox& b);
+        static Ogre::Real distance(const Ogre::AxisAlignedBox& b, const Ogre::Vector3& v);
+    };
+    
+}
+#endif

Modified: rl/branches/newton20/engine/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/newton20/engine/common/include/WriteableDataStream.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/include/WriteableDataStream.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -71,4 +71,5 @@
     };
 
     typedef Ogre::SharedPtr<WriteableFileStreamDataStream> WriteableFileStreamDataStreamPtr;
-}
\ No newline at end of file
+}
+

Modified: rl/branches/newton20/engine/common/src/MathUtil.cpp
===================================================================
--- rl/branches/newton20/engine/common/src/MathUtil.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/src/MathUtil.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,78 +1,104 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h" //precompiled header
-
-#include "MathUtil.h"
-
-
-using namespace Ogre;
-
-namespace rl
-{
-    const Ogre::Real MathUtil::EPSILON = 0.00001f;
-
-    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
-        Ogre::Radian azimuth, Ogre::Radian altitude)
-    {
-        Vector3 rval;
-        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
-        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        return rval;
-    }
-
-    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
-        Ogre::Radian& azimuth, Ogre::Radian& altitude)
-    {
-        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
-        azimuth = Math::ATan2(cartesian.x, cartesian.z);
-        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
-    }
-
-    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
-	{
-        Ogre::Real ang = angle;
-
-		while (ang < 0) ang += 360;
-		while (ang > 360) ang -= 360;
-
-		return ang;
-	}	
-
-	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
-	{
-		if (b1.intersects(b2))
-		{
-			return 0.0f;
-		}
-		else
-		{
-			Vector3 dv;
-
-			const Vector3& min1 = b1.getMinimum();
-			const Vector3& min2 = b2.getMinimum();
-			const Vector3& max1 = b1.getMaximum();
-			const Vector3& max2 = b2.getMaximum();
-
-			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
-			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
-			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
-
-			return dv.length();
-		}
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h" //precompiled header
+
+#include "MathUtil.h"
+
+
+using namespace Ogre;
+
+namespace rl
+{
+    const Ogre::Real MathUtil::EPSILON = 0.00001f;
+
+    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
+        Ogre::Radian azimuth, Ogre::Radian altitude)
+    {
+        Vector3 rval;
+        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
+        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        return rval;
+    }
+
+    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real& r,
+        Ogre::Radian& azimuth, Ogre::Radian& altitude)
+    {
+        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
+        azimuth = Math::ATan2(cartesian.x, cartesian.z);
+        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
+    }
+
+    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
+	{
+        Ogre::Real ang = angle;
+
+		while (ang < 0) ang += 360;
+		while (ang > 360) ang -= 360;
+
+		return ang;
+	}	
+
+	Real MathUtil::distance(const AxisAlignedBox& b1, const AxisAlignedBox& b2)
+	{
+		if (b1.intersects(b2))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+
+			const Vector3& min1 = b1.getMinimum();
+			const Vector3& min2 = b2.getMinimum();
+			const Vector3& max1 = b1.getMaximum();
+			const Vector3& max2 = b2.getMaximum();
+
+			dv.x = min1.x > max2.x ? min1.x - max2.x : min2.x > max1.x ? min2.x - max1.x : 0.0f;
+			dv.y = min1.y > max2.y ? min1.y - max2.y : min2.y > max1.y ? min2.y - max1.y : 0.0f;
+			dv.z = min1.z > max2.z ? min1.z - max2.z : min2.z > max1.z ? min2.z - max1.z : 0.0f;
+
+			return dv.length();
+		}
+	}
+    
+	Real MathUtil::distance(const Vector3& v, const AxisAlignedBox& b)
+    {
+        return MathUtil::distance(b, v);
+    }
+    
+	Real MathUtil::distance(const AxisAlignedBox& b, const Vector3& v)
+	{
+		if (b.contains(v))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+            
+			const Vector3& min1 = b.getMinimum();
+			const Vector3& max1 = b.getMaximum();
+            
+			dv.x = min1.x > v.x ? min1.x - v.x : v.x > max1.x ? v.x - max1.x : 0.0f;
+			dv.y = min1.y > v.y ? min1.y - v.y : v.y > max1.y ? v.y - max1.y : 0.0f;
+			dv.z = min1.z > v.z ? min1.z - v.z : v.z > max1.z ? v.z - max1.z : 0.0f;
+            
+			return dv.length();
+		}
+	}
+}

Modified: rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -34,4 +34,5 @@
     {
         mStream->flush();
     }
-}
\ No newline at end of file
+}
+

Copied: rl/branches/newton20/engine/core/CMakeLists.txt (from rev 4644, rl/trunk/engine/core/CMakeLists.txt)

Modified: rl/branches/newton20/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/ConfigurationManager.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/include/ConfigurationManager.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -190,6 +190,13 @@
             Ogre::StringVector getModuleList() const;
 
             /**
+             * Remove modules from the module list (e.g. because they are broken)
+             *
+             * @param modules the modules to remove
+             */
+            void removeModules(const Ogre::StringVector& modules);
+
+            /**
              * Returns the filename of the current keymap file used by
              * Rastullah
              *

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -184,6 +184,21 @@
         return mModuleList;
     }
 
+    void ConfigurationManager::removeModules(const Ogre::StringVector& modules)
+    {
+        for (Ogre::StringVector::const_iterator it = modules.begin(), end = modules.end(); it != end; ++it)
+        {
+            for (Ogre::StringVector::iterator itDel = mModuleList.begin(), endDel = mModuleList.end(); itDel != endDel; ++itDel)
+            {
+                if (*itDel == *it)
+                {
+                    mModuleList.erase(itDel);
+                    break;
+                }
+            }
+        }
+    }
+
     void ConfigurationManager::loadConfig()
     {
         setRastullahCfgPath();

Modified: rl/branches/newton20/engine/core/src/ContentLoader.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ContentLoader.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/ContentLoader.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,33 +1,33 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "ContentLoader.h"
-
-namespace rl
-{
-    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
-    {
-    }
-
-    ContentLoader::~ContentLoader()
-    {
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "ContentLoader.h"
+
+namespace rl
+{
+    ContentLoader::ContentLoader(const Ogre::String& resourceGroup)
+    {
+    }
+
+    ContentLoader::~ContentLoader()
+    {
+    }
+
     const Property ContentLoader::getProperty(const CeGuiString& key) const
     {
         LOG_WARNING(Logger::CORE, key + " is not a property of this ContentLoader");
@@ -38,9 +38,10 @@
     {
     }
 
-    PropertyKeys ContentLoader::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-}
\ No newline at end of file
+    PropertyKeys ContentLoader::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        return keys;
+    }
+}
+

Modified: rl/branches/newton20/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/CoreSubsystem.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/CoreSubsystem.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -329,6 +329,8 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
+        Ogre::StringVector brokenModules;
+
         for (size_t i = 0; i < modulesList.size(); i++)
         {
             mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
@@ -337,8 +339,9 @@
 
             if (module == NULL)
             {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "'");
+                LOG_WARNING("CoreSubsystem",
+                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "', removed.");
+                brokenModules.push_back(modulesList[i]);
             }
             //else
             //{
@@ -349,6 +352,8 @@
             //    }
             //}
         }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
     }
 
     ContentModule* CoreSubsystem::getModule(const Ogre::String& moduleId) const

Modified: rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,114 +1,122 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "PlayAnimationJob.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, Ogre::Real duration,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mDuration(duration),
-          mReplaceAllAnims(replaceAllAnims),
-          mLoops(-1),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, int loops,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mLoops(loops),
-          mDuration(-1),
-          mReplaceAllAnims(replaceAllAnims),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::~PlayAnimationJob()
-    {
-    }
-
-    void PlayAnimationJob::setHoldOnEnd(bool hold)
-    {
-        mHoldOnEnd = hold;
-    }
-
-    bool PlayAnimationJob::execute(Ogre::Real time)
-    {
-        if (mActor && !mAnimationRunning)
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(mActor->getControlledObject());
-
-            if (mReplaceAllAnims)
-            {
-                mo->stopAllAnimationsExcept(mAnimName);
-            }                
-
-            if (mDuration > 0)
-            {
-                mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
-                mTimeToGo = mDuration;
-                mAnimationRunning = true;
-            }
-            else
-            {
-                MeshAnimation* animation = mo->startAnimation(mAnimName, 1.0f, mLoops);
-                mTimeToGo = animation->getLength() * (float)mLoops;
-                mAnimationRunning = true;
-            }
-        }
-
-        mTimeToGo -= time;
-
-        if (mTimeToGo <= 0.0f)
-        {
-            if (mAnimationRunning && mAnimation) 
-            {
-                mAnimationRunning = false;
-                if (mHoldOnEnd) 
-                {
-                    mAnimation->pause();
-                }
-                else
-                {
-                    mAnimation->stop();
-                    delete mAnimation;
-                }
-                mAnimation = NULL;
-            }
-            return true;
-        }
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "PlayAnimationJob.h"
+#include "MeshAnimation.h"
+#include "MeshObject.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, Ogre::Real duration,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mDuration(duration),
+          mReplaceAllAnims(replaceAllAnims),
+          mLoops(-1),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String& anim, int loops,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mLoops(loops),
+          mDuration(-1),
+          mReplaceAllAnims(replaceAllAnims),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::~PlayAnimationJob()
+    {
+    }
+
+    void PlayAnimationJob::setHoldOnEnd(bool hold)
+    {
+        mHoldOnEnd = hold;
+    }
+
+    bool PlayAnimationJob::execute(Ogre::Real time)
+    {
+        if (mActor && !mAnimationRunning)
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(mActor->getControlledObject());
+
+            if (mReplaceAllAnims)
+            {
+                mo->stopAllAnimationsExcept(mAnimName);
+            }                
+            
+            if (mo->hasAnimation(mAnimName))
+            {
+                if (mDuration > 0)
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo->startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation->getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
+            }
+            else 
+            {
+                mAnimation = NULL;
+                mTimeToGo = 0;
+            }
+        }
+
+        mTimeToGo -= time;
+
+        if (mTimeToGo <= 0.0f)
+        {
+            if (mAnimationRunning && mAnimation) 
+            {
+                mAnimationRunning = false;
+                if (mHoldOnEnd) 
+                {
+                    mAnimation->pause();
+                }
+                else
+                {
+                    mAnimation->stop();
+                    delete mAnimation;
+                }
+                mAnimation = NULL;
+            }
+            return true;
+        }
+
+        return false;
+    }
+}

Modified: rl/branches/newton20/engine/rules/include/ApplyDamageJob.h
===================================================================
--- rl/branches/newton20/engine/rules/include/ApplyDamageJob.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/ApplyDamageJob.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include "RulesPrerequisites.h"
-
-#include "Job.h"
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include "RulesPrerequisites.h"
+
+#include "Job.h"
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/branches/newton20/engine/rules/include/Combat.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combat.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Combat.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include "RulesPrerequisites.h"
-
-#include <set>
-#include <vector>
-#include <boost/tuple/tuple.hpp>
-
-#include "JobListener.h"
-#include "Kampfaktion.h"
-#include "MessagePump.h"
-#include "RulesConstants.h"
-#include "Effect.h"
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set<Combatant*> CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet& getAllPlayerOpponents() const;
-        const CombatantSet& getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector<ActionEntry> ActionEntryVector;
-		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
-		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
-        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set<int> mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include "RulesPrerequisites.h"
+
+#include <set>
+#include <vector>
+#include <boost/tuple/tuple.hpp>
+
+#include "Creature.h"
+#include "Effect.h"
+#include "JobListener.h"
+#include "Kampfaktion.h"
+#include "MessagePump.h"
+#include "RulesConstants.h"
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set<Combatant*> CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3& targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector<ActionEntry> ActionEntryVector;
+		typedef std::map<Combatant*, ActionEntryVector> CombatantActionsMap;
+		typedef std::map<Combatant*, Reaktion> CombatantReactionsMap;
+        typedef std::vector<std::pair<int, Combatant*> > CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set<int> mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/Combatant.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combatant.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Combatant.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Creature.h"
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3& targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/Creature.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Creature.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Creature.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,870 +1,877 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __CREATURE_H__
-#define __CREATURE_H__
-
-#include "RulesPrerequisites.h"
-
-#include "Date.h"
-#include "Effect.h"
-#include "Effect.h"
-#include "Eigenschaft.h"
-#include "GameObject.h"
-#include "ZauberStateSet.h"
-#include "SonderfertigkeitenStateSet.h"
-
-namespace rl
-{
-    class Container;
-    class Inventory;
-    class Item;
-    class Weapon;
-
-///////////////////////////////////////////////////////////////////////////////
-// Konstanten
-
-    /**
-    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
-    /**
-    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
-
-    /// Eine Doppel-1
-    static const int RESULT_AUTOERFOLG = 100;
-    /// Eine Dreifach-1
-    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
-    /// Eine Doppel-20
-    static const int RESULT_AUTOMISSERFOLG = -100;
-    /// Eine Dreifach-20
-    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
-    /**
-     *  Eine bestaetigte 1 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
-     *  eine einfache 1 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_GLUECKLICH = 100;
-    /**
-     *  Eine bestaetigte 20 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
-     *  eine einfache 20 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_PATZER = -100;
-    /// Eine normal gelungene Attacke oder Parade
-    static const int RESULT_ERFOLG = 1;
-    /// Eine normal misslungene Attacke oder Parade
-    static const int RESULT_MISSERFOLG = -1;
-
-
-    /// Basistalente
-    /// @todo Passenderen Ort suchen
-    static const CeGuiString TALENT_ART_BASIS = "Basis";
-    /// Spezialtalente
-    static const CeGuiString TALENT_ART_SPEZIAL = "Spezial";
-    /// Berufstalente
-    static const CeGuiString TALENT_ART_BERUF = "Beruf";
-
-    /**
-     *  @defgroup CreatureRubyExports Creature
-     *  @ingroup RulesRubyExports
-     **/
-
-    /**
-    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
-    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
-    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
-    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
-    * Spielwelt noetig ist (z.B. Proben).
-    */
-    class _RlRulesExport Creature : public GameObject
-    {
-        public:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  List of all talents. Consists of the (german) name of the talent
-             *  (e.g. "Athletik") as key and its value (TaW)
-             **/
-            typedef std::map<const CeGuiString, int> TalentMap;
-
-            static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_AI;
-            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
-			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
-            static const Ogre::String PROPERTY_CURRENT_LE;
-            static const Ogre::String PROPERTY_CURRENT_AE;
-            static const Ogre::String PROPERTY_CURRENT_AU;
-            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
-            static const Ogre::String PROPERTY_EFFECTS;
-            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
-            static const Ogre::String PROPERTY_TALENTE;
-            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
-            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
-            static const Ogre::String PROPERTY_VORTEILE;
-            static const Ogre::String PROPERTY_NACHTEILE;
-            static const Ogre::String PROPERTY_SF;
-            static const Ogre::String PROPERTY_WERTE;
-            static const Ogre::String PROPERTY_AP;
-            static const Ogre::String PROPERTY_INVENTORY;
-            static const Ogre::String PROPERTY_ANIMATIONS;
-            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
-
-            typedef Ogre::String Wert;
-
-            // some targets
-			static const std::string ALL_EIGENSCHAFTEN;
-			static const std::string ALL_TALENTE;
-
-            static const Wert WERT_MOD_AE;
-            static const Wert WERT_MOD_LE;
-            static const Wert WERT_MOD_AU;
-            static const Wert WERT_MOD_MR;
-            static const Wert WERT_MOD_AT;
-            static const Wert WERT_MOD_PA;
-            static const Wert WERT_MOD_FK;
-            static const Wert WERT_GS;
-            static const Wert WERT_SOZIALSTATUS;
-            static const Wert WERT_BE;
-            static const Wert WERT_RS;
-            static const Wert WERT_INI;
-            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
-            static const Wert WERT_REGENERATION;
-    			
-			Creature(unsigned int id);
-
-            /// Der Standarddestruktor.
-            virtual ~Creature();
-
-///////////////////////////////////////////////////////////////////////////////
-// Enums
-            /// Alignment of a Creature towards the player. This determines
-            /// whether a combat is entered.
-            enum Alignment
-            {
-                ALIGNMENT_ALLY    = 1, ///< Creature fights with the player.
-                ALIGNMENT_NEUTRAL = 2, ///< Creature doesn't fight for either side.
-                ALIGNMENT_ENEMY   = 4  ///< Creature fights against the player.
-            };
-
-            /// Determines the damage type
-            enum DamageTag
-            {
-                DAMAGETAG_NORMAL = 1,
-                DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
-                DAMAGETAG_FIRE
-            };
-            /// The differente states a @ref abbdes "SF" can be in.
-             enum SfStatus
-            {
-                SFSTATUS_IN_TRAINING = 1,
-                SFSTATUS_OK,
-                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Werte
-
-            /**
-             *  Modifies the current @ref abbdel "LE" of the creature.
-             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
-             *  value).
-             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
-             **/
-            virtual void modifyLe(int mod, bool ignoreMax = false);
-            /**
-             *  Returns the current @ref abbdel "LE" of the creature.
-             **/
-            virtual int getLe() const;
-            /**
-             *  Returns the maximum @ref abbdel "LE" the creature can have.
-             **/
-            virtual int getLeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
-             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAe(int mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
-             **/
-            virtual int getAe() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
-             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAu(float mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
-             **/
-            virtual float getAu() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAuMax() const;
-
-            /**
-             *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
-             **/
-            virtual int getAttackeBasis() const;
-            /**
-             *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
-             **/
-            virtual int getParadeBasis() const;
-            /**
-             *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
-             **/
-            virtual int getFernkampfBasis() const;
-            /**
-             *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
-             **/
-            virtual int getInitiativeBasis() const;
-
-            /**
-             *  Setzt den Basiswert \a wertId auf \a value.
-             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
-             *  @param value Der neue wert des Basiswerts.
-             *  @see Wert
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void setWert(Wert wertId, int value);
-            /**
-                   *  Liefert den Basiswert \a wertId zurueck.
-             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
-                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
-                   *   zurueckgegeben.
-             *  @return Der Wert des Basiswerts.
-             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
-             *    gefunden werden.
-             **/
-            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
-
-            /**
-             *  Gibt der Kreatur @ref abbddea "AP".
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyAp(int modifier);
-            /**
-             *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
-             **/
-            int getAp() const;
-            /**
-             *  Veraendert die verbrauchten @ref abbdea "AP", wird beim Steigern
-             *  aufgerufen.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyUsedAp(int modifier);
-            /**
-             *  Liefert die verbrauchten @refabbdea "AP" zurueck.
-             **/
-            int getUsedAp() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Eigenschaften
-
-            /**
-             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @abbdef "FF", etc.).
-             *  @return Der Wert der Eigenschaft.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
-            /**
-             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @ref abbdef "FF", etc.).
-             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
-            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-                   *   @ref abbdef "FF", etc.).
-             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
-
-///////////////////////////////////////////////////////////////////////////////
-// Talente
-
-            /**
-                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
-             *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
-             *  @param talentName Bezeichnet das Talent.
-                   *  @param value Startwert des Talents.
-             *  @throws InvalidArgumentException Das Talent konnte nicht
-             *    gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            void addTalent(const CeGuiString talentName, int value = 0);
-            /**
-                   *  Liefert den Wert des Talents \a talentName zurueck.
-             *  @param talentName Bezeichnet das Talent.
-             *  @return @ref abbdet "TaW"
-                   *  @ingroup CreatureRubyExports
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-             */
-
-            /**
-                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
-              * @param talentName Bezeichnet das Talent
-              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
-            */
-            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
-
-            virtual int getTalent(const CeGuiString talentName) const;
-            /**
-                   *  Setzt den Wert des Talents \a talentName.
-             *  @param talentName Bezeichnet das zu veraendernde Talent.
-             *  @param value Der neue @ref abbdet TaW.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void setTalent(const CeGuiString talentName, int value);
-            /**
-                   *  Erhoeht das Talent \a talentName um \a mod.
-             *  @param talentName Bezeichnet das zu steigernde Talent.
-             *  @param mod Der Wert um den das Talent gesteigert werden soll.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void modifyTalent(const CeGuiString talentName, int mod);
-            /**
-             * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
-             * Dies wird auch der komplette Talentspiegel genannt.
-             **/
-            virtual const Creature::TalentMap& getAllTalents() const;
-            /**
-                   *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
-                   *  Spezielle Erfahrungen, MFF 47.
-             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void addSe(const CeGuiString talentName);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampftechniken
-
-            /**
-             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
-             *  @param kampftechnikName Bezeichnet die Kampftechnik.
-             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
-             *  (0,0).
-             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
-                   *  @ingroup CreatureRubyExports
-             **/
-            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value = std::make_pair(0, 0));
-            /**
-                   *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
-                   *  bestimmten Kampftechnik zurueck.
-             *  @param kampftechnikName Beszeichnet die Kampftechnik.
-             *  @return Ein std::pair<AT, PA>.
-             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
-             *   \c mKampftechniken gefunden werden.
-             **/
-            virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
-            /**
-                   *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
-                   *  Kampftechnik.
-             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
-             *  @param value Die neuen AT/PA Werte.
-             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
-             *    konnte nicht in \c mKampftechniken gefunden werden.
-             **/
-            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampfaktionen (Attacke, Parade, etc..)
-
-            void addKampfaktion(const CeGuiString& kampfaktionName);
-            bool hasKampfaktion(const CeGuiString& kampfaktionName) const;
-			const std::set<CeGuiString>& getAllKampfaktionen() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Vorteile
-            /**
-             *  Fuegt einen Vorteil hinzu.
-             *  @param vorteilName Der Name des Vorteils.
-             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
-             *   Vorteils (z.B. Astrale Regeneration 3).
-             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
-             **/
-            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
-
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
-             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
-             **/
-            virtual bool hasVorteil(const CeGuiString vorteilName) const;
- 
-///////////////////////////////////////////////////////////////////////////////
-// Nachteile
-            /**
-             *  Fuegt einen Nachteil hinzu.
-             *  @param nachteilName Der Name des Nachteils.
-             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
-             *   die Stufe des Nachteils.
-             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
-             **/
-            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
-             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
-             **/
-            virtual bool hasNachteil(const CeGuiString nachteilName) const;
-            /**
-             *  Liefert das StateSet des Nachteils zurueck.
-             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
-             *  abzufragen.
-             *  @param nachteilName Der Name der Schlechten Eigenschaft.
-             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
-             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
-             *   nicht gefunden werden.
-             **/
-            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Sonderfertigkeiten
-
-            /**
-                    *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
-             *  @param sfName Bezeichnet die SF.
-                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
-             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
-             *    werden.
-                    *  @see SfStatus
-             */
-            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-            /**
-                   *  Liefert den Wert der @ref abbdes "SF" zurueck.
-             *  @param sfName Bezeichnet die SF
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual int getSf(const CeGuiString sfName) const;
-            /**
-                   *  Setzt den Wert der @ref abbdes "SF".
-             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
-             *   werden soll.
-             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
-             *   soll.
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual void setSf(const CeGuiString sfName, SfStatus value);
-
-            /**
-             *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
-             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
-            *  @throws InvalidArgumentException \a sfName kann nicht in 
-            *   \c mSonderfertigkeiten gefunden werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Status
-            /**
-             * Gets the status of a creature.
-             **/
-			Effect::LifeState getLifeState() const;
-
-
-            bool isMagic() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Inventory
-
-
-            /**
-             *  Gibt das Inventar der Kreatur zurueck.
-             *  @return Liefert einen Zeiger auf Inventar der Kreatur
-             **/
-            Inventory* getInventory() const;
-
-        const Ogre::String& getInventoryWindowType() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Aktionen
-            /**
-            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
-            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
-            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
-            *  die Angabe einer Spezialisierung.
-            *  @param talentName Bezeichnet das Talent
-            *  @param spezialisierungId Bezeichnet die Spezialisierung
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
-            *     gewuerfelt werden soll
-            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
-            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
-            *  @return uebrig gebliebene Talentpunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
-            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
-            */
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int,int)
-             *  This is the function that should be used in most cases.
-             **/
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int);
-             *  This is the function you should usually use, if there is no fitting
-             *  specialization for the task.
-             *  @ingroup CreatureRubyExports
-             **/
-            /**
-             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
-             **/
-		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
-                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
-                                                 CeGuiString eigenschaft3Name);
-            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
-
-			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-                                      int modifier);
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
-
-            /**
-            *  Durchfuehren einer Eigenschaftsprobe.
-            *  @param eigenschaftName Bezeichnet die Eigenschaft
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
-            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
-            *  @ingroup CreatureRubyExports
-            */
-			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-            /**
-            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Attacke ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Attacke.
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   mKampftechniken gefunden.
-            **/
-            int doAttacke(const CeGuiString kampftechnikName, int modifier);
-            /**
-            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Parade ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Parade.
-            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-            *  @retval RESULT_GLUECKLICH Eine gute Parade.
-            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   \c mKampftechniken gefunden.
-            **/
-            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
-
-            /**
-             *  Fuehrt einen Initiativewurf durch.
-             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
-             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
-             *    'Orientieren'.
-             **/
-            int doInitiativeWurf(bool getMaxInitiative = false);
-
-			int doTrefferpunkteWurf(Weapon* weapon) const;
-
-            /**
-             *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
-             *  @param tp die Trefferpunkte
-                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
-                   *   etc. korrekt zu beruecksichtigen.
-             **/
-            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-            static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
-
-            /**
-             *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
-             *  @param aup die Trefferpunkte
-             **/
-            void damageAe(int asp);
-
-            /**
-            *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
-            *  @param aup die Trefferpunkte
-             *  @param damageType Typ des Schadens, um Resistenzen
-             *   etc. korrekt zu beruecksichtigen.
-            **/
-            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
-            static const int AUDAMAGE_NORMAL = 0;
-            static const int AUDAMAGE_HEAT = 1;
-            static const int AUDAMAGE_COLD = 2;
-            static const int AUDAMAGE_CHOKE = 4;
-            static const int AUDAMAGE_DROWN = 8;
-
-            /**
-             *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateLe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateAe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
-             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
-             *  Parameter time aufgerufen werden.
-             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
-             *   selten eingesetzt werden.
-             *  @param time Sollte nur benutzt werden, falls es nicht m???lich ist
-             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
-             **/
-            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
-
-
-            virtual const Property getProperty(const CeGuiString& key) const;
-            virtual void setProperty(const CeGuiString& key, const Property& value);
-            virtual PropertyKeys getAllPropertyKeys() const;
-
-            void setAlignment(Alignment);
-            Alignment getAlignment() const;
-
-
-
-            /**
-             * Gibt an, ob die Creature mit den H??nden an den Gegenstand herankommt,
-             * ihn also ber??hren kann, mit ihm interagieren etc
-            **/
-            virtual bool canReachItem(const Item* item) const;
-
-            /**
-             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
-             * den CreatureController
-            **/
-            typedef std::pair<Ogre::String, Ogre::Real> AnimationSpeedPair;
-            /**
-             * Gibt die Animation aus der AnimationsMap f??r den CreatureController zur??ck
-             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
-             * der Schl??sse name und eine Geschwindigkeit von 1 zurueckgegeben
-            **/
-            AnimationSpeedPair getAnimation(const CeGuiString& name) const;
-
-        protected:
-           /**
-             *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
-             **/
-            virtual int getAeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
-             **/
-            virtual int getAuBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
-             **/
-            virtual int getLeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
-             **/
-            virtual int getMrBasis() const;
-            /**
-             *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
-             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
-             **/
-            virtual int getCurrentBe() const;
-
-            /// inherited from GameObject
-            virtual void doPlaceIntoScene();
-
-            /// inherited from GameObject
-            virtual void doRemoveFromScene();
-
-
-
-
-        private:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  Liste der Werte.
-             *  @see Wert
-             **/
-            typedef std::map<const Wert, int> WertMap;
-            /**
-                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
-                   *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
-                   *  und einem Zeiger auf ihr StateSet.
-             **/
-            typedef std::map<const CeGuiString, int> EigenschaftMap;
-            /**
-             *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
-             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
-             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
-                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
-             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
-             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
-             *  Kampftalent entsprechen.
-             **/
-            typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
-            /**
-             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
-             *  den Vorteilen, verhalten sich aber wie Talente.
-             **/
-            typedef std::map<const CeGuiString, int> VorteilMap;
-            /**
-             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
-             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
-             **/
-            typedef std::map<const CeGuiString, int> NachteilMap;
-            /**
-                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
-                   *  Sonderfertigkeit als Schluessel und ihrem Status.
-             */
-            typedef std::map<const CeGuiString , SonderfertigkeitenStateSet*> SonderfertigkeitMap;
-            /**
-                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl??ssel ist Bezeichner der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
-                    * an.
-            **/
-            typedef std::map<const CeGuiString, CeGuiString> AnimationsMap;
-            /**
-                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
-                    * CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl??ssel ist Bezeichner, der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird.
-            **/
-            typedef std::map<const CeGuiString, Ogre::Real> AnimationSpeedsMap;
-            struct Ap
-            {
-                int total;
-                int used;
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Membervariablen
-            /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
-            int mCurrentLe;
-            /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
-            int mCurrentAe;
-            /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
-            float mCurrentAu;
-            /// Die aktuelle Erschoepfung der Kreatur.
-            int mErschoepfung;
-            /// Zuletzt zugewiesene Bewegungsart
-            int mMovementType;
-
-            /// Zeigt auf die gerade aktive Waffe.
-            EigenschaftMap mEigenschaften;
-            TalentMap mTalente;
-            KampftechnikMap mKampftechniken;
-			std::set<CeGuiString> mKampfaktionen;
-            VorteilMap mVorteile;
-            NachteilMap mNachteile;
-            SonderfertigkeitMap mSonderfertigkeiten;
-            WertMap mWerte;
-            AnimationsMap mAnimations;
-            AnimationSpeedsMap mAnimationSpeeds;
-            Ap mAp;
-            /// Zeigt auf das Inventar der Kreatur.
-            Inventory* mInventory;
-            Ogre::String mInventoryWindowType;
-
-            Property mAiProperties;
-
-            Alignment mAlignment;
-
-            /// this variable is only used in regenerateAu
-            float mTimeSinceLastRegeneration;
-            /// this variable is only used in regenerateAu (must be initialized with 3W6)
-            int mLastCalculatedAuToRegenerate;
-
-            /**
-             *  Sets a the status \a statusVariable. It uses a reference counting
-             *  System to do this, so if for example severeal effects put the creature
-             *  to sleep, and one effect ends the creature doesn't awake until all
-             *  the other effects end too. 
-             *  @param statusVariable is a reference to the status to be set, such as
-             *   \c mBlind.
-             *  @param value If true, the reference is increased, if false it is decreased.
-             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
-             *   than it was with \c true (i.e. the status is removed more often than
-             *   it was applied), \c setStatus throws an exception with \a errorMessage as
-             *   text.
-             *  @throw InvalidArgumentException see \a errorMessage.
-             **/
-            void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
-    };
-}
-#endif //__CREATURE_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __CREATURE_H__
+#define __CREATURE_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Date.h"
+#include "Effect.h"
+#include "Effect.h"
+#include "Eigenschaft.h"
+#include "GameObject.h"
+#include "ZauberStateSet.h"
+#include "SonderfertigkeitenStateSet.h"
+
+namespace rl
+{
+    class Container;
+    class Inventory;
+    class Item;
+    class Weapon;
+
+///////////////////////////////////////////////////////////////////////////////
+// Konstanten
+
+    /**
+    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
+    /**
+    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
+
+    /// Eine Doppel-1
+    static const int RESULT_AUTOERFOLG = 100;
+    /// Eine Dreifach-1
+    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
+    /// Eine Doppel-20
+    static const int RESULT_AUTOMISSERFOLG = -100;
+    /// Eine Dreifach-20
+    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
+    /**
+     *  Eine bestaetigte 1 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
+     *  eine einfache 1 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_GLUECKLICH = 100;
+    /**
+     *  Eine bestaetigte 20 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
+     *  eine einfache 20 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_PATZER = -100;
+    /// Eine normal gelungene Attacke oder Parade
+    static const int RESULT_ERFOLG = 1;
+    /// Eine normal misslungene Attacke oder Parade
+    static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
+
+    /// Basistalente
+    /// @todo Passenderen Ort suchen
+    static const CeGuiString TALENT_ART_BASIS = "Basis";
+    /// Spezialtalente
+    static const CeGuiString TALENT_ART_SPEZIAL = "Spezial";
+    /// Berufstalente
+    static const CeGuiString TALENT_ART_BERUF = "Beruf";
+
+    /**
+     *  @defgroup CreatureRubyExports Creature
+     *  @ingroup RulesRubyExports
+     **/
+
+    /**
+    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
+    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
+    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
+    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
+    * Spielwelt noetig ist (z.B. Proben).
+    */
+    class _RlRulesExport Creature : public GameObject
+    {
+        public:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  List of all talents. Consists of the (german) name of the talent
+             *  (e.g. "Athletik") as key and its value (TaW)
+             **/
+            typedef std::map<const CeGuiString, int> TalentMap;
+
+            static const Ogre::String CLASS_NAME;
+            static const Ogre::String PROPERTY_AI;
+            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
+			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+            static const Ogre::String PROPERTY_CURRENT_LE;
+            static const Ogre::String PROPERTY_CURRENT_AE;
+            static const Ogre::String PROPERTY_CURRENT_AU;
+            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
+            static const Ogre::String PROPERTY_EFFECTS;
+            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
+            static const Ogre::String PROPERTY_TALENTE;
+            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
+            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
+            static const Ogre::String PROPERTY_VORTEILE;
+            static const Ogre::String PROPERTY_NACHTEILE;
+            static const Ogre::String PROPERTY_SF;
+            static const Ogre::String PROPERTY_WERTE;
+            static const Ogre::String PROPERTY_AP;
+            static const Ogre::String PROPERTY_INVENTORY;
+            static const Ogre::String PROPERTY_ANIMATIONS;
+            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
+
+            typedef Ogre::String Wert;
+
+            // some targets
+			static const std::string ALL_EIGENSCHAFTEN;
+			static const std::string ALL_TALENTE;
+
+            static const Wert WERT_MOD_AE;
+            static const Wert WERT_MOD_LE;
+            static const Wert WERT_MOD_AU;
+            static const Wert WERT_MOD_MR;
+            static const Wert WERT_MOD_AT;
+            static const Wert WERT_MOD_PA;
+            static const Wert WERT_MOD_FK;
+            static const Wert WERT_GS;
+            static const Wert WERT_SOZIALSTATUS;
+            static const Wert WERT_BE;
+            static const Wert WERT_RS;
+            static const Wert WERT_INI;
+            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
+            static const Wert WERT_REGENERATION;
+    			
+			Creature(unsigned int id);
+
+            /// Der Standarddestruktor.
+            virtual ~Creature();
+
+///////////////////////////////////////////////////////////////////////////////
+// Enums
+            /// Alignment of a Creature towards the player. This determines
+            /// whether a combat is entered.
+            enum Alignment
+            {
+                ALIGNMENT_ALLY    = 1, ///< Creature fights with the player.
+                ALIGNMENT_NEUTRAL = 2, ///< Creature doesn't fight for either side.
+                ALIGNMENT_ENEMY   = 4  ///< Creature fights against the player.
+            };
+
+            /// Determines the damage type
+            enum DamageTag
+            {
+                DAMAGETAG_NORMAL = 1,
+                DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
+                DAMAGETAG_FIRE
+            };
+            /// The differente states a @ref abbdes "SF" can be in.
+             enum SfStatus
+            {
+                SFSTATUS_IN_TRAINING = 1,
+                SFSTATUS_OK,
+                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Werte
+
+            /**
+             *  Modifies the current @ref abbdel "LE" of the creature.
+             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
+             *  value).
+             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
+             **/
+            virtual void modifyLe(int mod, bool ignoreMax = false);
+            /**
+             *  Returns the current @ref abbdel "LE" of the creature.
+             **/
+            virtual int getLe() const;
+            /**
+             *  Returns the maximum @ref abbdel "LE" the creature can have.
+             **/
+            virtual int getLeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
+             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAe(int mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
+             **/
+            virtual int getAe() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
+             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAu(float mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
+             **/
+            virtual float getAu() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAuMax() const;
+
+            /**
+             *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
+             **/
+            virtual int getAttackeBasis() const;
+            /**
+             *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
+             **/
+            virtual int getParadeBasis() const;
+            /**
+             *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
+             **/
+            virtual int getFernkampfBasis() const;
+            /**
+             *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
+             **/
+            virtual int getInitiativeBasis() const;
+
+            /**
+             *  Setzt den Basiswert \a wertId auf \a value.
+             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
+             *  @param value Der neue wert des Basiswerts.
+             *  @see Wert
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void setWert(Wert wertId, int value);
+            /**
+                   *  Liefert den Basiswert \a wertId zurueck.
+             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
+                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
+                   *   zurueckgegeben.
+             *  @return Der Wert des Basiswerts.
+             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
+             *    gefunden werden.
+             **/
+            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
+
+            /**
+             *  Gibt der Kreatur @ref abbddea "AP".
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyAp(int modifier);
+            /**
+             *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
+             **/
+            int getAp() const;
+            /**
+             *  Veraendert die verbrauchten @ref abbdea "AP", wird beim Steigern
+             *  aufgerufen.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyUsedAp(int modifier);
+            /**
+             *  Liefert die verbrauchten @refabbdea "AP" zurueck.
+             **/
+            int getUsedAp() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Eigenschaften
+
+            /**
+             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @abbdef "FF", etc.).
+             *  @return Der Wert der Eigenschaft.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
+            /**
+             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
+            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
+
+///////////////////////////////////////////////////////////////////////////////
+// Talente
+
+            /**
+                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
+             *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
+             *  @param talentName Bezeichnet das Talent.
+                   *  @param value Startwert des Talents.
+             *  @throws InvalidArgumentException Das Talent konnte nicht
+             *    gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            void addTalent(const CeGuiString talentName, int value = 0);
+            /**
+                   *  Liefert den Wert des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent.
+             *  @return @ref abbdet "TaW"
+                   *  @ingroup CreatureRubyExports
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+             */
+
+            /**
+                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
+              * @param talentName Bezeichnet das Talent
+              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
+            */
+            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
+
+            virtual int getTalent(const CeGuiString talentName) const;
+            /**
+                   *  Setzt den Wert des Talents \a talentName.
+             *  @param talentName Bezeichnet das zu veraendernde Talent.
+             *  @param value Der neue @ref abbdet TaW.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void setTalent(const CeGuiString talentName, int value);
+            /**
+                   *  Erhoeht das Talent \a talentName um \a mod.
+             *  @param talentName Bezeichnet das zu steigernde Talent.
+             *  @param mod Der Wert um den das Talent gesteigert werden soll.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void modifyTalent(const CeGuiString talentName, int mod);
+            /**
+             * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
+             * Dies wird auch der komplette Talentspiegel genannt.
+             **/
+            virtual const Creature::TalentMap& getAllTalents() const;
+            /**
+                   *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
+                   *  Spezielle Erfahrungen, MFF 47.
+             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void addSe(const CeGuiString talentName);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampftechniken
+
+            /**
+             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
+             *  @param kampftechnikName Bezeichnet die Kampftechnik.
+             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
+             *  (0,0).
+             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
+                   *  @ingroup CreatureRubyExports
+             **/
+            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value = std::make_pair(0, 0));
+            /**
+                   *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
+                   *  bestimmten Kampftechnik zurueck.
+             *  @param kampftechnikName Beszeichnet die Kampftechnik.
+             *  @return Ein std::pair<AT, PA>.
+             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
+             *   \c mKampftechniken gefunden werden.
+             **/
+            virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
+            /**
+                   *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
+                   *  Kampftechnik.
+             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
+             *  @param value Die neuen AT/PA Werte.
+             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
+             *    konnte nicht in \c mKampftechniken gefunden werden.
+             **/
+            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampfaktionen (Attacke, Parade, etc..)
+
+            void addKampfaktion(const CeGuiString& kampfaktionName);
+            bool hasKampfaktion(const CeGuiString& kampfaktionName) const;
+			const std::set<CeGuiString>& getAllKampfaktionen() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Vorteile
+            /**
+             *  Fuegt einen Vorteil hinzu.
+             *  @param vorteilName Der Name des Vorteils.
+             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
+             *   Vorteils (z.B. Astrale Regeneration 3).
+             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
+             **/
+            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
+
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
+             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
+             **/
+            virtual bool hasVorteil(const CeGuiString vorteilName) const;
+ 
+///////////////////////////////////////////////////////////////////////////////
+// Nachteile
+            /**
+             *  Fuegt einen Nachteil hinzu.
+             *  @param nachteilName Der Name des Nachteils.
+             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
+             *   die Stufe des Nachteils.
+             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
+             **/
+            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
+             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
+             **/
+            virtual bool hasNachteil(const CeGuiString nachteilName) const;
+            /**
+             *  Liefert das StateSet des Nachteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
+             *  abzufragen.
+             *  @param nachteilName Der Name der Schlechten Eigenschaft.
+             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
+             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Sonderfertigkeiten
+
+            /**
+                    *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
+             *  @param sfName Bezeichnet die SF.
+                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
+             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
+             *    werden.
+                    *  @see SfStatus
+             */
+            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+            /**
+                   *  Liefert den Wert der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual int getSf(const CeGuiString sfName) const;
+            /**
+                   *  Setzt den Wert der @ref abbdes "SF".
+             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
+             *   werden soll.
+             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
+             *   soll.
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual void setSf(const CeGuiString sfName, SfStatus value);
+
+            /**
+             *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
+            *  @throws InvalidArgumentException \a sfName kann nicht in 
+            *   \c mSonderfertigkeiten gefunden werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Status
+            /**
+             * Gets the status of a creature.
+             **/
+			Effect::LifeState getLifeState() const;
+
+
+            bool isMagic() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Inventory
+
+
+            /**
+             *  Gibt das Inventar der Kreatur zurueck.
+             *  @return Liefert einen Zeiger auf Inventar der Kreatur
+             **/
+            Inventory* getInventory() const;
+
+        const Ogre::String& getInventoryWindowType() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Aktionen
+            /**
+            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
+            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
+            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
+            *  die Angabe einer Spezialisierung.
+            *  @param talentName Bezeichnet das Talent
+            *  @param spezialisierungId Bezeichnet die Spezialisierung
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
+            *     gewuerfelt werden soll
+            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
+            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
+            *  @return uebrig gebliebene Talentpunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
+            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
+            */
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int,int)
+             *  This is the function that should be used in most cases.
+             **/
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int);
+             *  This is the function you should usually use, if there is no fitting
+             *  specialization for the task.
+             *  @ingroup CreatureRubyExports
+             **/
+            /**
+             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
+             **/
+		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
+                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
+                                                 CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
+
+			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+                                      int modifier);
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
+
+            /**
+            *  Durchfuehren einer Eigenschaftsprobe.
+            *  @param eigenschaftName Bezeichnet die Eigenschaft
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
+            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
+            *  @ingroup CreatureRubyExports
+            */
+			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+            /**
+            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Attacke ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Attacke.
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   mKampftechniken gefunden.
+            **/
+            int doAttacke(const CeGuiString kampftechnikName, int modifier);
+            /**
+            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Parade ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Parade.
+            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+            *  @retval RESULT_GLUECKLICH Eine gute Parade.
+            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   \c mKampftechniken gefunden.
+            **/
+            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
+
+            /**
+             *  Fuehrt einen Initiativewurf durch.
+             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
+             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
+             *    'Orientieren'.
+             **/
+            int doInitiativeWurf(bool getMaxInitiative = false);
+
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
+
+            /**
+             *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
+             *  @param tp die Trefferpunkte
+                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
+                   *   etc. korrekt zu beruecksichtigen.
+             **/
+            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+            static const int LEDAMAGE_NORMAL = 0;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
+
+            /**
+             *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
+             *  @param aup die Trefferpunkte
+             **/
+            void damageAe(int asp);
+
+            /**
+            *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
+            *  @param aup die Trefferpunkte
+             *  @param damageType Typ des Schadens, um Resistenzen
+             *   etc. korrekt zu beruecksichtigen.
+            **/
+            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
+            static const int AUDAMAGE_NORMAL = 0;
+            static const int AUDAMAGE_HEAT = 1;
+            static const int AUDAMAGE_COLD = 2;
+            static const int AUDAMAGE_CHOKE = 4;
+            static const int AUDAMAGE_DROWN = 8;
+
+            /**
+             *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateLe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateAe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
+             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+             *  Parameter time aufgerufen werden.
+             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
+             *   selten eingesetzt werden.
+             *  @param time Sollte nur benutzt werden, falls es nicht m???lich ist
+             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
+             **/
+            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
+
+
+            virtual const Property getProperty(const CeGuiString& key) const;
+            virtual void setProperty(const CeGuiString& key, const Property& value);
+            virtual PropertyKeys getAllPropertyKeys() const;
+
+            void setAlignment(Alignment);
+            Alignment getAlignment() const;
+
+
+
+            /**
+             * Gibt an, ob die Creature mit den H??nden an den Gegenstand herankommt,
+             * ihn also ber??hren kann, mit ihm interagieren etc
+            **/
+            virtual bool canReachItem(const Item* item) const;
+
+            /**
+             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
+             * den CreatureController
+            **/
+            typedef std::pair<Ogre::String, Ogre::Real> AnimationSpeedPair;
+            /**
+             * Gibt die Animation aus der AnimationsMap f??r den CreatureController zur??ck
+             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
+             * der Schl??sse name und eine Geschwindigkeit von 1 zurueckgegeben
+            **/
+            AnimationSpeedPair getAnimation(const CeGuiString& name) const;
+
+        protected:
+           /**
+             *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
+             **/
+            virtual int getAeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
+             **/
+            virtual int getAuBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
+             **/
+            virtual int getLeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
+             **/
+            virtual int getMrBasis() const;
+            /**
+             *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
+             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
+             **/
+            virtual int getCurrentBe() const;
+
+            /// inherited from GameObject
+            virtual void doPlaceIntoScene();
+
+            /// inherited from GameObject
+            virtual void doRemoveFromScene();
+
+
+
+
+        private:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  Liste der Werte.
+             *  @see Wert
+             **/
+            typedef std::map<const Wert, int> WertMap;
+            /**
+                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
+                   *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
+                   *  und einem Zeiger auf ihr StateSet.
+             **/
+            typedef std::map<const CeGuiString, int> EigenschaftMap;
+            /**
+             *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
+             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
+             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
+                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
+             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
+             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
+             *  Kampftalent entsprechen.
+             **/
+            typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
+            /**
+             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
+             *  den Vorteilen, verhalten sich aber wie Talente.
+             **/
+            typedef std::map<const CeGuiString, int> VorteilMap;
+            /**
+             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
+             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
+             **/
+            typedef std::map<const CeGuiString, int> NachteilMap;
+            /**
+                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
+                   *  Sonderfertigkeit als Schluessel und ihrem Status.
+             */
+            typedef std::map<const CeGuiString , SonderfertigkeitenStateSet*> SonderfertigkeitMap;
+            /**
+                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl??ssel ist Bezeichner der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
+                    * an.
+            **/
+            typedef std::map<const CeGuiString, CeGuiString> AnimationsMap;
+            /**
+                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
+                    * CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl??ssel ist Bezeichner, der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird.
+            **/
+            typedef std::map<const CeGuiString, Ogre::Real> AnimationSpeedsMap;
+            struct Ap
+            {
+                int total;
+                int used;
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Membervariablen
+            /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
+            int mCurrentLe;
+            /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
+            int mCurrentAe;
+            /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
+            float mCurrentAu;
+            /// Die aktuelle Erschoepfung der Kreatur.
+            int mErschoepfung;
+            /// Zuletzt zugewiesene Bewegungsart
+            int mMovementType;
+
+            /// Zeigt auf die gerade aktive Waffe.
+            EigenschaftMap mEigenschaften;
+            TalentMap mTalente;
+            KampftechnikMap mKampftechniken;
+			std::set<CeGuiString> mKampfaktionen;
+            VorteilMap mVorteile;
+            NachteilMap mNachteile;
+            SonderfertigkeitMap mSonderfertigkeiten;
+            WertMap mWerte;
+            AnimationsMap mAnimations;
+            AnimationSpeedsMap mAnimationSpeeds;
+            Ap mAp;
+            /// Zeigt auf das Inventar der Kreatur.
+            Inventory* mInventory;
+            Ogre::String mInventoryWindowType;
+
+            Property mAiProperties;
+
+            Alignment mAlignment;
+
+            /// this variable is only used in regenerateAu
+            float mTimeSinceLastRegeneration;
+            /// this variable is only used in regenerateAu (must be initialized with 3W6)
+            int mLastCalculatedAuToRegenerate;
+
+            /**
+             *  Sets a the status \a statusVariable. It uses a reference counting
+             *  System to do this, so if for example severeal effects put the creature
+             *  to sleep, and one effect ends the creature doesn't awake until all
+             *  the other effects end too. 
+             *  @param statusVariable is a reference to the status to be set, such as
+             *   \c mBlind.
+             *  @param value If true, the reference is increased, if false it is decreased.
+             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
+             *   than it was with \c true (i.e. the status is removed more often than
+             *   it was applied), \c setStatus throws an exception with \a errorMessage as
+             *   text.
+             *  @throw InvalidArgumentException see \a errorMessage.
+             **/
+            void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
+    };
+}
+#endif //__CREATURE_H__

Modified: rl/branches/newton20/engine/rules/include/RulesPrerequisites.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesPrerequisites.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/RulesPrerequisites.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -91,6 +91,7 @@
 
 	typedef std::vector<Action*> ActionVector;
 	
-	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString actionName);
+	ActionVector::iterator findAction(ActionVector::iterator& begin, ActionVector::iterator& end, const CeGuiString& actionName);
+	ActionVector::const_iterator findAction(ActionVector::const_iterator& begin, ActionVector::const_iterator& end, const CeGuiString& actionName);
 }
 #endif

Modified: rl/branches/newton20/engine/rules/include/Slot.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Slot.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Slot.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,92 +1,224 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef __SLOT_H__
-#define __SLOT_H__
-
-#include "RulesPrerequisites.h"
-
-namespace rl {
-
-class Creature;
-class Item;
-
-class _RlRulesExport Slot
-{
-public:
-    Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
-    virtual ~Slot();
-
-    // provides standard behaviour, sets
-    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
-    // subclasses MUST call this method when overriding
-    virtual bool setItem(Item* item);
-    virtual void update(); // this must only be called from creature::doPlaceIntoScene
-    Item* getItem() const;
-    bool isAllowed(const Item* item) const;
-    bool isEmpty() const {return mItem == NULL;}
-    bool canReady(const Item* item) const;
-	bool isReady() { return mItem != NULL && canReady(mItem); }
-    CeGuiString getName() const {return mName;}
-
-protected:
-
-    Creature* mOwner;
-    Item* mItem;
-
-private:
-    CeGuiString mName;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemHeldMask;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemReadyMask;
-};
-
-class BoneSlot : public Slot
-{
-public:
-    BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mBone;
-};
-
-class SubmeshSlot : public Slot
-{
-public:
-    SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-class MaterialSlot : public Slot
-{
-public:
-    MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-} // namespace rl
-
-#endif //__SLOT_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __SLOT_H__
+#define __SLOT_H__
+
+#include "RulesPrerequisites.h"
+
+namespace rl {
+    
+    class Creature;
+    class Item;
+    
+    /**
+     * A class to represent a place where an Item can be attached to a creature
+     *
+     */
+    class _RlRulesExport Slot
+    {
+    public:
+        
+        /**
+         * Creates a slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         */
+        Slot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask);
+        virtual ~Slot();
+        
+        /**
+         * Puts an item into the slot, may depend on the actual slot type
+         *
+         * Note: this method provides standard behaviour, sets item-state etc
+         * subclasses MUST call this method when overriding
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * Updates the slot to match the owner's state
+         *
+         * Note: this must only be called from Creature::doPlaceIntoScene
+         */
+        virtual void update();
+        
+        /**
+         * Gets the item in the slot
+         *
+         * @returns the item, NULL if the slot is empty
+         */
+        Item* getItem() const;
+        
+        /**
+         * Check if an item can be held in this slot
+         *
+         * @param item an item
+         * @returns true if the item can be put into this slot, false otherwise
+         */
+        bool isAllowed(const Item* item) const;
+        
+        /** 
+         * Check if the slot is empty
+         *
+         * @returns true if the slot is empty, false otherwise
+         */
+        bool isEmpty() const {return mItem == NULL;}
+        
+        /**
+         * Check if an item is readied in this slot (e.g. trousers in the legs slot) or not (e.g. trousers in the left hand slot)
+         *
+         * @param item an item
+         * @returns true if the item is readied in this slot, false otherwise
+         */
+        bool canReady(const Item* item) const;
+        
+        /**
+         * Check if the slot holds a ready item
+         *
+         */
+        bool isReady() { return mItem != NULL && canReady(mItem); }
+        
+        /**
+         * Get the slot's name
+         *
+         * @returns the name
+         */
+        CeGuiString getName() const {return mName;}
+        
+    protected:
+        
+        Creature* mOwner;
+        Item* mItem;
+        
+    private:
+        CeGuiString mName;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemHeldMask;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemReadyMask;
+    };
+    
+    /**
+     * A slot implemented by a model bone, if objects are put into the slot, their models are attached at the bone
+     */
+    class BoneSlot : public Slot
+    {
+    public:
+        
+        /**
+         * Creates a bone slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param bone the bone name
+         */
+        BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone);
+        
+        /**
+         * Puts an item into the slot by attaching its mesh to the bone of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mBone;
+    };
+    
+    /**
+     * A slot implemented by a submesh "baked" into the owner mesh. If an item is put into that slot it creates or 
+     * replaces a specified submesh, this is used for armor to be able to animate the armor meshes on an easy way
+     *
+     * Note: the item meshes must have the same skeleton as the owner mesh
+     */
+    class SubmeshSlot : public Slot
+    {
+    public:
+
+        /**
+         * Creates a submesh slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        SubmeshSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by creating or replacing a submesh in the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+    /**
+     * A slot implemented by changing a material on a specified submesh of the owner mesh. This is used for clothes.
+     */
+    class MaterialSlot : public Slot
+    {
+    public:
+        /**
+         * Creates a material slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        MaterialSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& submesh);
+
+        /**
+         * Puts an item into the slot by replacing the material in one submesh of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+} // namespace rl
+
+#endif //__SLOT_H__

Modified: rl/branches/newton20/engine/rules/include/Weapon.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Weapon.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Weapon.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (unsigned int id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString& getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,41 +1,42 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h"
-#include "ApplyDamageJob.h"
-
-#include "Creature.h"
-
-namespace rl 
-{
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
-:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
-    mTarget(target), 
-    mTp(tp)
-{
-}
-
-ApplyDamageJob::~ApplyDamageJob()
-{
-}
-
-bool ApplyDamageJob::execute(Ogre::Real time)
-{
-    mTarget->damageLe(mTp);
-    return true;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h"
+#include "ApplyDamageJob.h"
+
+#include "Creature.h"
+
+namespace rl 
+{
+
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
+:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
+    mTarget(target), 
+    mDamage(damage),
+    mType(damageType)
+{
+}
+
+ApplyDamageJob::~ApplyDamageJob()
+{
+}
+
+bool ApplyDamageJob::execute(Ogre::Real time)
+{
+    mTarget->damageLe(mDamage, mType);
+    return true;
+}
+
+} // namespace rl

Modified: rl/branches/newton20/engine/rules/src/Combat.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combat.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Combat.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft nach "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft nach "
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant->doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l?uft zu "
+						    GameEventLog::getSingleton().logEvent(combatant->getName() + " l???uft zu "
 							    + entry.target->getName(), GET_COMBAT);
 						    combatant->doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor->getName() + " attackiert " + target->getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor->rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult >= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent("Erfolg, aber pariert.", GET_COMBAT);
-                        if (target->getActiveWeapon()->isNatural())
+                        if (target->getActiveWeapon()->isNatural() && !actor->getActiveWeapon()->isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target->getActiveWeapon()->isNatural() && actor->getActiveWeapon()->isNatural())
+                        {
+                            doDamage(jobSetAnims, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target->getActiveWeapon()->isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target->doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetAnims, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor->rollTrefferpunkte();
-            jobSetAnims->add(new ApplyDamageJob(target->getCreature(), tp));
-
-			CeGuiString msg = actor->getName() + " trifft f?r "
+			int tp = actor->rollTrefferpunkte(damageStrength);
+            jobSet->add(new ApplyDamageJob(target->getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor->getName() + " trifft fuer "
             + CeGuiString(StringConverter::toString(tp))
             + " Trefferpunkte";
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature->getName() + " ist jetzt ";
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += "kampfunf?hig.";
+						msg += "kampfunf???hig.";
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/branches/newton20/engine/rules/src/Combatant.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combatant.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Combatant.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -85,9 +85,9 @@
 		return getCreature()->doParade(weapon->getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()->doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()->doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/branches/newton20/engine/rules/src/Creature.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Creature.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Creature.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,1304 +1,1323 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Creature.h"
-
-#include "Actor.h"
-#include "Container.h"
-#include "CreatureControllerManager.h"
-#include "DsaManager.h"
-#include "Eigenschaft.h"
-#include "EffectFactory.h"
-#include "EffectManager.h"
-#include "Exception.h"
-#include "Inventory.h"
-#include "Kampftechnik.h"
-#include "MeshObject.h"
-#include "MessagePump.h"
-#include "RulesMessages.h"
-#include "StateSet.h"
-#include "Slot.h"
-#include "Talent.h"
-#include "Weapon.h"
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Creature::CLASS_NAME = "Creature";
-
-    const Ogre::String Creature::PROPERTY_AI = "ai";
-    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = "behaviours";
-    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
-    const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
-    const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
-    const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
-    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = "current_fatigue";
-    const Ogre::String Creature::PROPERTY_EFFECTS = "effects";
-    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = "eigenschaften";
-    const Ogre::String Creature::PROPERTY_TALENTE = "talente";
-    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = "kampftechniken";
-    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = "kampfaktionen";
-    const Ogre::String Creature::PROPERTY_VORTEILE = "vorteile";
-    const Ogre::String Creature::PROPERTY_NACHTEILE = "nachteile";
-    const Ogre::String Creature::PROPERTY_SF = "sonderfertigkeiten";
-    const Ogre::String Creature::PROPERTY_WERTE = "werte";
-    const Ogre::String Creature::PROPERTY_AP = "ap";
-    const Ogre::String Creature::PROPERTY_INVENTORY = "inventory";
-    const Ogre::String Creature::PROPERTY_ANIMATIONS = "animations";
-    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = "animationspeeds";
-
-    // some targets
-	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
-	const std::string Creature::ALL_TALENTE = "alle Talente";
-	const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
-    const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
-    const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
-    const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
-    const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
-    const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
-    const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
-    const Creature::Wert Creature::WERT_GS = "GS";
-    const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
-    const Creature::Wert Creature::WERT_BE = "BE";
-    const Creature::Wert Creature::WERT_RS = "RS";
-    const Creature::Wert Creature::WERT_INI = "INI";
-    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
-    const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-
-
-
-    Creature::Creature(unsigned int id)
-        : GameObject(id),
-		mCurrentLe(0),
-        mCurrentAu(0),
-        mCurrentAe(0),
-		mInventory(NULL),
-		mEigenschaften(),
-		mWerte(),
-		mTalente(),
-        mKampftechniken(),
-		mKampfaktionen(),
-        mSonderfertigkeiten(),
-        mErschoepfung(0),
-        mMovementType(0),
-        mAlignment(ALIGNMENT_NEUTRAL),
-        mTimeSinceLastRegeneration(0),
-        mLastCalculatedAuToRegenerate(
-                  DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6())
-    {
-        mQueryFlags |= QUERYFLAG_CREATURE;
-
-		setWert(WERT_MOD_AE, 0);
-		setWert(WERT_MOD_LE, 0);
-		setWert(WERT_MOD_AU, 0);
-		setWert(WERT_MOD_MR, 0);
-		setWert(WERT_GS, 8);
-        setWert(WERT_RS, 0);
-        setWert(WERT_BE, 0);
-        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
-		mEigenschaften[E_MUT] = 0;
-		mEigenschaften[E_KLUGHEIT] = 0;
-		mEigenschaften[E_INTUITION] = 0;
-		mEigenschaften[E_CHARISMA] = 0;
-		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
-		mEigenschaften[E_GEWANDTHEIT] = 0;
-		mEigenschaften[E_KONSTITUTION] = 0;
-		mEigenschaften[E_KOERPERKRAFT] = 0;
-
-		mInventory = new Inventory(this);
-    }
-
-	Creature::~Creature()
-    {
-        delete mInventory;
-
-        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
-            delete it->second;
-        mSonderfertigkeiten.clear();
-        CreatureControllerManager::getSingleton().detachController(this);
-    }
-
-    int Creature::getAttackeBasis() const
-    {
-		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getParadeBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getFernkampfBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getInitiativeBasis() const
-    {
-      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getMrBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 5.0 + 0.5);
-    }
-
-    int Creature::getLeBasis() const
-    {
-      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-    int Creature::getAuBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-	int Creature::getAeBasis() const
-	{
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
-
-        return static_cast<int>(es / 2.0 + 0.5);
-    }
-
-	int Creature::getWert(Wert wertId, bool getUnmodified) const
-	{
-		WertMap::const_iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + ": Wert " + wertId.c_str() + " nicht gefunden.").c_str());
-            return 0;
-        }
-        int rval = it->second;
-        if (!getUnmodified)
-        {
-          rval += mEffectManager->getMod(wertId, Effect::MODTYPE_SUM);
-          rval *= mEffectManager->getMod(wertId, Effect::MODTYPE_MULT);
-        }
-		return rval;
-	}
-
-	int Creature::getCurrentBe() const
-	{
-		pair<int,int> be = mInventory->getOverallBe();
-        ///@todo Ruestungsgewoehnung?
-		return be.first+be.second;
-	}
-
-	void Creature::setWert(Wert wertId, int value)
-	{
-		WertMap::iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-			mWerte.insert(make_pair(wertId, value));
-        }
-		else
-		{
-			it->second = value;
-		}
-	}
-
-   void Creature::modifyLe(int mod, bool ignoreMax)
-    {
-        int oldLe = mCurrentLe;
-        mCurrentLe += mod;
-		if (!ignoreMax)
-		{
-			mCurrentLe = min(mCurrentLe, getLeMax());
-		}
-
-        if (mCurrentLe <= -getEigenschaft("KO") && oldLe > -getEigenschaft("KO"))
-        {
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("DeadEffect"));
-        }
-        else if (mCurrentLe > -getEigenschaft("KO") && oldLe <= -getEigenschaft("KO"))
-        {
-            mEffectManager->removeEffect("DeadEffect");
-        }
-        else if (mCurrentLe <= 0 && oldLe > 0)
-        {
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("UnconsciousEffect"));
-        }
-        else if (mCurrentLe > 0 && oldLe <= 0)
-        {
-            mEffectManager->removeEffect("UnconciousEffect");
-        }
-		else if (mCurrentLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
-            oldLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("IncapacitatedEffect"));
-		}
-		else if (mCurrentLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
-            oldLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager->removeEffect("IncapacitatedEffect");
-		}
-
-        fireObjectStateChangeEvent();
-
-    }
-
-    int Creature::getLe() const
-    {
-        return mCurrentLe;
-    }
-
-    int Creature::getLeMax() const
-    {
-		return getLeBasis() + getWert(WERT_MOD_LE);
-    }
-
-    void Creature::modifyAe(int mod, bool ignoreMax)
-    {
-        mCurrentAe += mod;
-		if (!ignoreMax)
-			mCurrentAe = min(mCurrentAe, getAeMax());
-		fireObjectStateChangeEvent();
-    }
-
-    int Creature::getAe() const
-    {
-        return mCurrentAe;
-    }
-
-    int Creature::getAeMax() const
-    {
-		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
-    }
-
-    void Creature::modifyAu(float mod, bool ignoreMax)
-    {
-        mCurrentAu = max(mCurrentAu + mod, 0.0f);
-		if (!ignoreMax)
-			mCurrentAu = min(mCurrentAu, float(getAuMax()));
-        if (getAu() <= 0)
-        {
-            ///@todo set incapacitated
-        }
-		fireObjectStateChangeEvent();
-    }
-
-    float Creature::getAu() const
-    {
-        return mCurrentAu;
-    }
-
-    int Creature::getAuMax() const
-    {
-		return getAuBasis() + getWert(WERT_MOD_AU);
-    }
-
-    void Creature::modifyAp(int modifier)
-    {
-        mAp.total += modifier;
-    }
-
-    int Creature::getAp() const
-    {
-        return mAp.total;
-    }
-
-    void Creature::modifyUsedAp(int modifier)
-    {
-        mAp.used += modifier;
-    }
-
-    int Creature::getUsedAp() const
-    {
-        return mAp.used;
-    }
-
-    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
-    {
-		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-		if (it == mEigenschaften.end())
-		{
-			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-		}
-		int result = it->second;
-        result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
-        return result;
-    }
-
-    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
-    {
-        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
-        if (it == mEigenschaften.end())
-        {
-            Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-        }
-		it->second = value;
-        fireObjectStateChangeEvent();
-    }
-
-    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
-    {
-		mEigenschaften[eigenschaftName] += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
-    {
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-            return true;
-        /*
-        if( ausweich )
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt != ausweichTalente.end())
-            {
-                return true;
-            }
-        }
-        */
-		
-        return false;
-    }
-
-    int Creature::getTalent(const CeGuiString talentName) const
-    {
-        LOG_DEBUG(Logger::RULES, "Using talent " + talentName);
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt == ausweichTalente.end())
-            {
-                Throw(IllegalArgumentException, "Talent nicht gefunden.");
-            }
-            int rval = getTalent(ausweichIt->first) - ausweichIt->second;
-            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
-            {
-                int tempAusweichTaw = getTalent(ausweichIt->first)
-                    - ausweichIt->second;
-                if (tempAusweichTaw > rval) rval = tempAusweichTaw;
-            }
-            return rval;
-        } //if (it == mTalente.end())
-		return it->second;
-    }
-
-	void Creature::addTalent(const CeGuiString talentName, int value)
-	{
-		TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-        {
-			Throw(IllegalArgumentException, "Talent schon in mTalente enthalten.");
-        }
-	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
-		mTalente[talentName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::modifyTalent(const CeGuiString talentName, int mod)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		it->second += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-	const Creature::TalentMap& Creature::getAllTalents() const
-	{
-		return mTalente;
-	}
-
-    void Creature::setTalent(const CeGuiString talentName, int value)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		it->second = value;
-		fireObjectStateChangeEvent();
-    }
-
-	void Creature::addSe(const CeGuiString talentName)
-	{
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		//it->second->setSe( true );
-        /// @todo Implement SEs
-	}
-
-	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it != mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException,
-				"Kampftechnik schon in mKampftechniken enthalten.");
-		}
-		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
-		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
-		mKampftechniken[kampftechnikName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    pair<int, int> Creature::getKampftechnik(const CeGuiString kampftechnikName) const
-    {
-        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
-        }
-        return (*it).second;
-    }
-
-    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair<int, int>& value)
-    {
-        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
-        }
-        (*it).second = value;
-		fireObjectStateChangeEvent();
-    }
-
-    void Creature::addKampfaktion(const CeGuiString& kampfaktionName)
-	{
-		mKampfaktionen.insert(kampfaktionName);
-	}
-
-    bool Creature::hasKampfaktion(const CeGuiString& kampfaktionName) const
-	{
-		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
-	}
-
-	const std::set<CeGuiString>& Creature::getAllKampfaktionen() const
-	{
-		return mKampfaktionen;
-	}
-
-    void Creature::addVorteil(const CeGuiString vorteilName, int value)
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            Throw(IllegalArgumentException, "Vorteil schon in mVorteile enthalten");
-        }
-        mVorteile[vorteilName] = value;
-    }
-
-    bool Creature::hasVorteil(const CeGuiString vorteilName) const
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    void Creature::addNachteil(const CeGuiString nachteilName, int value)
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            Throw(IllegalArgumentException, "Nachteil schon in mNachteile enthalten");
-        }
-        mNachteile[nachteilName] = value;
-    }
-
-    bool Creature::hasNachteil(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it == mNachteile.end())
-        {
-            Throw(IllegalArgumentException, "Nachteil nicht gefunden.");
-        }
-		else return it->second + mEffectManager->getMod(nachteilName, Effect::MODTYPE_SUM);
-    }
-
-    int Creature::getSf(const CeGuiString sfName) const
-    {
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		return it->second->getValue();
-    }
-
-	void Creature::addSf(const CeGuiString sfName, SfStatus value)
-	{
-		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-		if (it != mSonderfertigkeiten.end())
-		{
-			Throw(IllegalArgumentException, "Sonderfertigkeit schon in mSonderfertigkeiten enthalten.");
-		}
-		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
-        /// @todo
-		//DsaManager::getSingleton().getSf(sfName);
-		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
-		mSonderfertigkeiten[sfName]->setOriginalValue( value );
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::setSf(const CeGuiString sfName, SfStatus value)
-    {
-        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		it->second->setOriginalValue( value );
-		fireObjectStateChangeEvent();
-    }
-
-	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
-	{
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
-        }
-		return it->second;
-	}
-
-    Effect::LifeState Creature::getLifeState() const
-    {
-      return mEffectManager->getLifeState();
-    }
-
-	bool Creature::isMagic() const
-	{
-		return getWert(WERT_MOD_AE) > 0;
-	}
-
-    void Creature::setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage)
-    {
-        if (value == true)
-        {
-            statusVariable++;
-        }
-        else //value == false
-        {
-            if (statusVariable > 0)
-            {
-                statusVariable--;
-            }
-            else
-            {
-                LOG_MESSAGE(Logger::RULES, errorMessage);
-            }
-        } //value == false
-    }
-
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) ||
-			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
-		{
-          /// @todo Find proper return value. Prompt an error message?
-			//Throw(OutOfRangeException, "TaW zu niedrig");
-          return -1;
-		}
-        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
-
-        // Der Probenwurf
-        Tripel<int> probe(DsaManager::getSingleton().roll3D20());
-
-		// Glueckliche
-		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) )
-		{
-			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
-			modifyTalent(talentName, +1);
-			return RESULT_SPEKT_AUTOERFOLG;
-		}
-		if ( ((probe.first == 1) && (probe.second == 1)) ||
-			 ((probe.first == 1) && (probe.third == 1)) ||
-			 ((probe.second == 1) && (probe.third == 1)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOERFOLG;
-		}
-		// Patzer
-		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20))
-		{
-			addSe(talentName);
-			return RESULT_SPEKT_AUTOMISSERFOLG;
-		}
-		if ( ((probe.first == 20) && (probe.second == 20)) ||
-			 ((probe.first == 20) && (probe.third == 20)) ||
-			 ((probe.second == 20) && (probe.third == 20)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOMISSERFOLG;
-		}
-
-
-        // Vor dem Vergleich hat man den Talentwert ??brig.
-		int eBe = DsaManager::getSingleton().getTalent(talentName)->calculateEbe(mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM));
-		int taW = getTalent(talentName);
-		int rval = taW - modifier - mEffectManager->getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
-            - mEffectManager->getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
-		// Bei negativen TaP*
-		int handicap = 0;
-		if (rval < 0)
-		{
-			handicap = -rval;
-			rval = 0;
-		}
-
-        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
-        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
-        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
-
-        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
-        // wird die Differenz vom Talentwert abgezogen.
-        rval = diff1 < 0 ? rval + diff1 : rval;
-        rval = diff2 < 0 ? rval + diff2 : rval;
-        rval = diff3 < 0 ? rval + diff3 : rval;
-
-		// TaP* niemals gr????er als TaW (MFF14)
-		if (rval > taW) rval = taW;
-        return rval;
-    }
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
-			eigenschaft2Name, eigenschaft3Name);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
-			et.first, et. second, et.third);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
-			et. second, et.third);
-	}
-
-    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
-    {
-        int rval;
-
-        int probe = DsaManager::getSingleton().rollD20();
-        if (probe == 1)
-        {
-            rval = RESULT_GLUECKLICH;
-        }
-        else if (probe == 20)
-        {
-            rval = RESULT_PATZER;
-        }
-        else
-        {
-			rval = getEigenschaft(eigenschaftName) -
-                (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
-        }
-        return rval;
-    }
-
-
-	Inventory* Creature::getInventory() const
-	{
-		return mInventory;
-	}
-
-    const Ogre::String& Creature::getInventoryWindowType() const
-    {
-        return mInventoryWindowType;
-    }
-
-	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
-		}
-		int rval;
-		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best??tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20) /// @todo Best??tigen
-		{
-			rval = RESULT_PATZER;
-		}
-		else
-		{
-			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
-                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval < 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
-		}
-		int rval;
-		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best??tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20)
-		{
-			rval = RESULT_PATZER; /// @todo Best??tigen
-		}
-		else
-		{
-			/// @todo Gute Parade
-			rval = getParadeBasis() + (*it).second.second - (probe + modifier
-                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval < 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doInitiativeWurf(bool getMaxInitiave)
-	{
-		int rval = getInitiativeBasis();
-		rval += mEffectManager->getMod(WERT_INI, Effect::MODTYPE_SUM);
-		rval -= mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM);
-		if (getMaxInitiave)
-        {
-            rval += 6;
-        }
-        else
-        {
-            rval += DsaManager::getSingleton().rollD6();
-        }
-		return rval;
-	}
-
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
-	{
-		// Roll dice
-		const Tripel<int>& weaponTp = weapon->getTp();
-		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
-		rval += weaponTp.third;
-
-		// Apply TP/KK
-
-		int kk = getEigenschaft(E_KOERPERKRAFT);
-		std::pair<int, int> tpkk = weapon->getTpKk();
-		
-		int bonus = (kk - tpkk.first) / tpkk.second;
-		rval += bonus;
-
-		return rval;
-	}
-
-	/// @todo Implement correctly
-	void Creature::damageLe(int tp, int damageType)
-	{
-        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-        if (tp < 0)
-        {
-            tp = 0;
-        }
-
-        ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
-        {
-            LOG_ERROR("Creature", "Fire damage not handled!"); ///@todo implement
-        }
-        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER)
-        {
-            LOG_ERROR("Creature", "Water damage not handled!"); ///@todo implement
-        }
-        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
-        {
-            LOG_ERROR("Creature", "Demonic damage not handled!"); ///@todo implement
-        }
-
-        if ((damageType & LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
-        {
-            damageAu(tp, AUDAMAGE_NORMAL);
-            tp = (int)floor(tp/2.);
-        }
-
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
-		modifyLe(sp);
-
-        if (sp >= getEigenschaft("KO"))
-        {
-            LOG_ERROR("Creature", "TODO: Add a wound."); ///@todo implement
-        }
-	}
-
-    void Creature::damageAe(int asp)
-    {
-        if (asp < 0)
-        {
-         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           asp = 0;
-        }
-        modifyAe(-asp);
-    }
-
-    void Creature::damageAu(float aup, int damageType)
-    {
-        if (aup < 0)
-        {
-         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           aup = 0;
-           ///@todo evtl. eine modifyErschoepfung()?
-           mErschoepfung += DsaManager::getSingleton().rollD6();
-           ///@todo set incapacitated
-        }
-        // bei ??beranstrengung, kostet alles doppelte Au!!!!!
-        if( mErschoepfung > getEigenschaft("KO") )
-            aup *= 2;
-        modifyAu(-aup);
-    }
-
-    void Creature::regenerateLe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedLe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedLe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
-            0, Effect::MODTAG_REGENERATION_LE))
-        {
-            regeneratedLe++;
-        }
-        //modifiziere die aktuellen LE
-        modifyLe(regeneratedLe);
-    }
-
-    void Creature::regenerateAe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedAe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedAe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN",
-            0, Effect::MODTAG_REGENERATION_AE))
-        {
-            regeneratedAe++;
-        }
-        //modifiziere die aktuellen AE
-        modifyAe(regeneratedAe);
-    }
-
-    void Creature::regenerateAu(int modifier, float factor, float time)
-    {
-        // das Ganze nur jede Spielrunde machen
-        mTimeSinceLastRegeneration += time;
-
-
-        if( getAu() == getAuMax() )
-        {
-            mTimeSinceLastRegeneration = 0;
-            return;
-        }
-
-
-        while( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE )
-        {
-            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
-
-
-            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
-            //Grundregeneration von 3W6
-            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6();
-            //Addiere eventuelle Modifikatoren hinzu
-            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
-            //Bei gelungener KO Probe addiere 1
-            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
-                0, mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
-            {
-                modifyAu(6*factor);
-            }
-
-            if( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
-            {
-                //modifiziere die aktuellen AU
-                time -= Date::ONE_SPIELRUNDE;
-                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
-            }
-
-            if( getAu() == getAuMax() )
-            {
-                mTimeSinceLastRegeneration = 0;
-                return;
-            }
-        }
-
-        // Restbetrag regenerieren:
-        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
-        modifyAu(regeneratedAuPerTime*factor);
-    }
-
-    void Creature::setAlignment(Creature::Alignment alignment)
-    {
-        mAlignment = alignment;
-    }
-
-    Creature::Alignment Creature::getAlignment() const
-    {
-        return mAlignment;
-    }
-
-    void Creature::setProperty(const CeGuiString& key, const Property& value)
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            mAiProperties = value;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            mInventoryWindowType = value.toString().c_str();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            mCurrentLe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            mCurrentAe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            mCurrentAu = value.toReal();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            mErschoepfung = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            mEigenschaften.clear();
-            convertToMap(value.toMap(), mEigenschaften);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            mTalente.clear();
-            convertToMap(value.toMap(), mTalente);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            mKampftechniken.clear();
-            convertToMap(value.toMap(), mKampftechniken);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            mKampfaktionen.clear();
-            convertToSet(value.toArray(), mKampfaktionen);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            mVorteile.clear();
-            convertToMap(value.toMap(), mVorteile);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            mNachteile.clear();
-            convertToMap(value.toMap(), mNachteile);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            mWerte.clear();
-            convertToMap(value.toMap(), mWerte);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            IntPair ip = value.toIntPair();
-            mAp.total = ip.first;
-            mAp.used = ip.second;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            mInventory->setProperties(value.toMap());
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            mAnimations.clear();
-            convertToMap(value.toMap(), mAnimations);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            mAnimationSpeeds.clear();
-            convertToMap(value.toMap(), mAnimationSpeeds);
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Creature::getProperty(const CeGuiString& key) const
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            return mAiProperties;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            return Property(mInventoryWindowType);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            return Property(mCurrentLe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            return Property(mCurrentAe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            return Property(mCurrentAu);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            return Property(mErschoepfung);
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mTalente);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
-            return Property(vec);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mVorteile);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mNachteile);
-            return Property(map);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mWerte);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            return Property(make_pair(mAp.total, mAp.used));
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-			return mInventory->getAllProperties()->toPropertyMap();
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimations);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
-            return Property(map);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Creature::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Creature::PROPERTY_AI);
-        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
-        keys.insert(Creature::PROPERTY_CURRENT_LE);
-        keys.insert(Creature::PROPERTY_CURRENT_AE);
-        keys.insert(Creature::PROPERTY_CURRENT_AU);
-        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
-        keys.insert(Creature::PROPERTY_TALENTE);
-        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
-        keys.insert(Creature::PROPERTY_VORTEILE);
-        keys.insert(Creature::PROPERTY_NACHTEILE);
-        //keys.insert(Creature::PROPERTY_SF);
-        keys.insert(Creature::PROPERTY_WERTE);
-        keys.insert(Creature::PROPERTY_AP);
-        keys.insert(Creature::PROPERTY_INVENTORY);
-        keys.insert(Creature::PROPERTY_ANIMATIONS);
-        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
-
-        return keys;
-    }
-
-    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString& name) const
-    {
-        AnimationSpeedPair ret;
-        AnimationsMap::const_iterator itName = mAnimations.find(name);
-        if( itName != mAnimations.end() )
-            ret.first = itName->second.c_str();
-        else
-            ret.first = name.c_str();
-
-        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
-        if( itSpeed != mAnimationSpeeds.end() )
-            ret.second = itSpeed->second;
-        else
-            ret.second = 1;
-
-        return ret;
-    }
-
-    bool Creature::canReachItem(const Item* item) const
-    {
-        return (item->getPosition() - getPosition()).length() <= 3.0f;
-    }
-
-    void Creature::doPlaceIntoScene()
-    {
-        GameObject::doPlaceIntoScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory->getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it->second->update();
-        }
-    }
-
-    void Creature::doRemoveFromScene()
-    {
-        GameObject::doRemoveFromScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory->getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it->second->update();
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Creature.h"
+
+#include "Actor.h"
+#include "Container.h"
+#include "CreatureControllerManager.h"
+#include "DsaManager.h"
+#include "Eigenschaft.h"
+#include "EffectFactory.h"
+#include "EffectManager.h"
+#include "Exception.h"
+#include "Inventory.h"
+#include "Kampftechnik.h"
+#include "MeshObject.h"
+#include "MessagePump.h"
+#include "RulesMessages.h"
+#include "StateSet.h"
+#include "Slot.h"
+#include "Talent.h"
+#include "Weapon.h"
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Creature::CLASS_NAME = "Creature";
+
+    const Ogre::String Creature::PROPERTY_AI = "ai";
+    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = "behaviours";
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
+    const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
+    const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
+    const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = "current_fatigue";
+    const Ogre::String Creature::PROPERTY_EFFECTS = "effects";
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = "eigenschaften";
+    const Ogre::String Creature::PROPERTY_TALENTE = "talente";
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = "kampftechniken";
+    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = "kampfaktionen";
+    const Ogre::String Creature::PROPERTY_VORTEILE = "vorteile";
+    const Ogre::String Creature::PROPERTY_NACHTEILE = "nachteile";
+    const Ogre::String Creature::PROPERTY_SF = "sonderfertigkeiten";
+    const Ogre::String Creature::PROPERTY_WERTE = "werte";
+    const Ogre::String Creature::PROPERTY_AP = "ap";
+    const Ogre::String Creature::PROPERTY_INVENTORY = "inventory";
+    const Ogre::String Creature::PROPERTY_ANIMATIONS = "animations";
+    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = "animationspeeds";
+
+    // some targets
+	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+	const std::string Creature::ALL_TALENTE = "alle Talente";
+	const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
+    const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
+    const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
+    const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
+    const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
+    const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
+    const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
+    const Creature::Wert Creature::WERT_GS = "GS";
+    const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
+    const Creature::Wert Creature::WERT_BE = "BE";
+    const Creature::Wert Creature::WERT_RS = "RS";
+    const Creature::Wert Creature::WERT_INI = "INI";
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
+    const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
+
+
+
+    Creature::Creature(unsigned int id)
+        : GameObject(id),
+		mCurrentLe(0),
+        mCurrentAu(0),
+        mCurrentAe(0),
+		mInventory(NULL),
+		mEigenschaften(),
+		mWerte(),
+		mTalente(),
+        mKampftechniken(),
+		mKampfaktionen(),
+        mSonderfertigkeiten(),
+        mErschoepfung(0),
+        mMovementType(0),
+        mAlignment(ALIGNMENT_NEUTRAL),
+        mTimeSinceLastRegeneration(0),
+        mLastCalculatedAuToRegenerate(
+                  DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6())
+    {
+        mQueryFlags |= QUERYFLAG_CREATURE;
+
+		setWert(WERT_MOD_AE, 0);
+		setWert(WERT_MOD_LE, 0);
+		setWert(WERT_MOD_AU, 0);
+		setWert(WERT_MOD_MR, 0);
+		setWert(WERT_GS, 8);
+        setWert(WERT_RS, 0);
+        setWert(WERT_BE, 0);
+        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
+		mEigenschaften[E_MUT] = 0;
+		mEigenschaften[E_KLUGHEIT] = 0;
+		mEigenschaften[E_INTUITION] = 0;
+		mEigenschaften[E_CHARISMA] = 0;
+		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
+		mEigenschaften[E_GEWANDTHEIT] = 0;
+		mEigenschaften[E_KONSTITUTION] = 0;
+		mEigenschaften[E_KOERPERKRAFT] = 0;
+
+		mInventory = new Inventory(this);
+    }
+
+	Creature::~Creature()
+    {
+        delete mInventory;
+
+        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
+            delete it->second;
+        mSonderfertigkeiten.clear();
+        CreatureControllerManager::getSingleton().detachController(this);
+    }
+
+    int Creature::getAttackeBasis() const
+    {
+		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getParadeBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getFernkampfBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getInitiativeBasis() const
+    {
+      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getMrBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 5.0 + 0.5);
+    }
+
+    int Creature::getLeBasis() const
+    {
+      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+    int Creature::getAuBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+	int Creature::getAeBasis() const
+	{
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
+
+        return static_cast<int>(es / 2.0 + 0.5);
+    }
+
+	int Creature::getWert(Wert wertId, bool getUnmodified) const
+	{
+		WertMap::const_iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + ": Wert " + wertId.c_str() + " nicht gefunden.").c_str());
+            return 0;
+        }
+        int rval = it->second;
+        if (!getUnmodified)
+        {
+          rval += mEffectManager->getMod(wertId, Effect::MODTYPE_SUM);
+          rval *= mEffectManager->getMod(wertId, Effect::MODTYPE_MULT);
+        }
+		return rval;
+	}
+
+	int Creature::getCurrentBe() const
+	{
+		pair<int,int> be = mInventory->getOverallBe();
+        ///@todo Ruestungsgewoehnung?
+		return be.first+be.second;
+	}
+
+	void Creature::setWert(Wert wertId, int value)
+	{
+		WertMap::iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+			mWerte.insert(make_pair(wertId, value));
+        }
+		else
+		{
+			it->second = value;
+		}
+	}
+
+   void Creature::modifyLe(int mod, bool ignoreMax)
+    {
+        int oldLe = mCurrentLe;
+        mCurrentLe += mod;
+		if (!ignoreMax)
+		{
+			mCurrentLe = min(mCurrentLe, getLeMax());
+		}
+
+        if (mCurrentLe <= -getEigenschaft("KO") && oldLe > -getEigenschaft("KO"))
+        {
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("DeadEffect"));
+        }
+        else if (mCurrentLe > -getEigenschaft("KO") && oldLe <= -getEigenschaft("KO"))
+        {
+            mEffectManager->removeEffect("DeadEffect");
+        }
+        else if (mCurrentLe <= 0 && oldLe > 0)
+        {
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("UnconsciousEffect"));
+        }
+        else if (mCurrentLe > 0 && oldLe <= 0)
+        {
+            mEffectManager->removeEffect("UnconciousEffect");
+        }
+		else if (mCurrentLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
+            oldLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager->addEffect(EffectFactoryManager::getSingleton().createEffect("IncapacitatedEffect"));
+		}
+		else if (mCurrentLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
+            oldLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager->removeEffect("IncapacitatedEffect");
+		}
+
+        fireObjectStateChangeEvent();
+
+    }
+
+    int Creature::getLe() const
+    {
+        return mCurrentLe;
+    }
+
+    int Creature::getLeMax() const
+    {
+		return getLeBasis() + getWert(WERT_MOD_LE);
+    }
+
+    void Creature::modifyAe(int mod, bool ignoreMax)
+    {
+        mCurrentAe += mod;
+		if (!ignoreMax)
+			mCurrentAe = min(mCurrentAe, getAeMax());
+		fireObjectStateChangeEvent();
+    }
+
+    int Creature::getAe() const
+    {
+        return mCurrentAe;
+    }
+
+    int Creature::getAeMax() const
+    {
+		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
+    }
+
+    void Creature::modifyAu(float mod, bool ignoreMax)
+    {
+        mCurrentAu = max(mCurrentAu + mod, 0.0f);
+		if (!ignoreMax)
+			mCurrentAu = min(mCurrentAu, float(getAuMax()));
+        if (getAu() <= 0)
+        {
+            ///@todo set incapacitated
+        }
+		fireObjectStateChangeEvent();
+    }
+
+    float Creature::getAu() const
+    {
+        return mCurrentAu;
+    }
+
+    int Creature::getAuMax() const
+    {
+		return getAuBasis() + getWert(WERT_MOD_AU);
+    }
+
+    void Creature::modifyAp(int modifier)
+    {
+        mAp.total += modifier;
+    }
+
+    int Creature::getAp() const
+    {
+        return mAp.total;
+    }
+
+    void Creature::modifyUsedAp(int modifier)
+    {
+        mAp.used += modifier;
+    }
+
+    int Creature::getUsedAp() const
+    {
+        return mAp.used;
+    }
+
+    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
+    {
+		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
+		if (it == mEigenschaften.end())
+		{
+			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
+		}
+		int result = it->second;
+        result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
+        return result;
+    }
+
+    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
+    {
+        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
+        if (it == mEigenschaften.end())
+        {
+            Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
+        }
+		it->second = value;
+        fireObjectStateChangeEvent();
+    }
+
+    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
+    {
+		mEigenschaften[eigenschaftName] += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
+    {
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+            return true;
+        /*
+        if( ausweich )
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt != ausweichTalente.end())
+            {
+                return true;
+            }
+        }
+        */
+		
+        return false;
+    }
+
+    int Creature::getTalent(const CeGuiString talentName) const
+    {
+        LOG_DEBUG(Logger::RULES, "Using talent " + talentName);
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt == ausweichTalente.end())
+            {
+                Throw(IllegalArgumentException, "Talent nicht gefunden.");
+            }
+            int rval = getTalent(ausweichIt->first) - ausweichIt->second;
+            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
+            {
+                int tempAusweichTaw = getTalent(ausweichIt->first)
+                    - ausweichIt->second;
+                if (tempAusweichTaw > rval) rval = tempAusweichTaw;
+            }
+            return rval;
+        } //if (it == mTalente.end())
+		return it->second;
+    }
+
+	void Creature::addTalent(const CeGuiString talentName, int value)
+	{
+		TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+        {
+			Throw(IllegalArgumentException, "Talent schon in mTalente enthalten.");
+        }
+	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
+		mTalente[talentName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::modifyTalent(const CeGuiString talentName, int mod)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		it->second += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+	const Creature::TalentMap& Creature::getAllTalents() const
+	{
+		return mTalente;
+	}
+
+    void Creature::setTalent(const CeGuiString talentName, int value)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		it->second = value;
+		fireObjectStateChangeEvent();
+    }
+
+	void Creature::addSe(const CeGuiString talentName)
+	{
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, "Talent nicht gefunden.");
+        }
+		//it->second->setSe( true );
+        /// @todo Implement SEs
+	}
+
+	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it != mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException,
+				"Kampftechnik schon in mKampftechniken enthalten.");
+		}
+		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
+		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
+		mKampftechniken[kampftechnikName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    pair<int, int> Creature::getKampftechnik(const CeGuiString kampftechnikName) const
+    {
+        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
+        }
+        return (*it).second;
+    }
+
+    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair<int, int>& value)
+    {
+        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, "Kampftechnik nicht gefunden.");
+        }
+        (*it).second = value;
+		fireObjectStateChangeEvent();
+    }
+
+    void Creature::addKampfaktion(const CeGuiString& kampfaktionName)
+	{
+		mKampfaktionen.insert(kampfaktionName);
+	}
+
+    bool Creature::hasKampfaktion(const CeGuiString& kampfaktionName) const
+	{
+		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
+	}
+
+	const std::set<CeGuiString>& Creature::getAllKampfaktionen() const
+	{
+		return mKampfaktionen;
+	}
+
+    void Creature::addVorteil(const CeGuiString vorteilName, int value)
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            Throw(IllegalArgumentException, "Vorteil schon in mVorteile enthalten");
+        }
+        mVorteile[vorteilName] = value;
+    }
+
+    bool Creature::hasVorteil(const CeGuiString vorteilName) const
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    void Creature::addNachteil(const CeGuiString nachteilName, int value)
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            Throw(IllegalArgumentException, "Nachteil schon in mNachteile enthalten");
+        }
+        mNachteile[nachteilName] = value;
+    }
+
+    bool Creature::hasNachteil(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it == mNachteile.end())
+        {
+            Throw(IllegalArgumentException, "Nachteil nicht gefunden.");
+        }
+		else return it->second + mEffectManager->getMod(nachteilName, Effect::MODTYPE_SUM);
+    }
+
+    int Creature::getSf(const CeGuiString sfName) const
+    {
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		return it->second->getValue();
+    }
+
+	void Creature::addSf(const CeGuiString sfName, SfStatus value)
+	{
+		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+		if (it != mSonderfertigkeiten.end())
+		{
+			Throw(IllegalArgumentException, "Sonderfertigkeit schon in mSonderfertigkeiten enthalten.");
+		}
+		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
+        /// @todo
+		//DsaManager::getSingleton().getSf(sfName);
+		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
+		mSonderfertigkeiten[sfName]->setOriginalValue( value );
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::setSf(const CeGuiString sfName, SfStatus value)
+    {
+        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		it->second->setOriginalValue( value );
+		fireObjectStateChangeEvent();
+    }
+
+	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
+	{
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, "Sonderfertigkeit nicht gefunden.");
+        }
+		return it->second;
+	}
+
+    Effect::LifeState Creature::getLifeState() const
+    {
+      return mEffectManager->getLifeState();
+    }
+
+	bool Creature::isMagic() const
+	{
+		return getWert(WERT_MOD_AE) > 0;
+	}
+
+    void Creature::setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage)
+    {
+        if (value == true)
+        {
+            statusVariable++;
+        }
+        else //value == false
+        {
+            if (statusVariable > 0)
+            {
+                statusVariable--;
+            }
+            else
+            {
+                LOG_MESSAGE(Logger::RULES, errorMessage);
+            }
+        } //value == false
+    }
+
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) ||
+			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
+		{
+          /// @todo Find proper return value. Prompt an error message?
+			//Throw(OutOfRangeException, "TaW zu niedrig");
+          return -1;
+		}
+        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
+
+        // Der Probenwurf
+        Tripel<int> probe(DsaManager::getSingleton().roll3D20());
+
+		// Glueckliche
+		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) )
+		{
+			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
+			modifyTalent(talentName, +1);
+			return RESULT_SPEKT_AUTOERFOLG;
+		}
+		if ( ((probe.first == 1) && (probe.second == 1)) ||
+			 ((probe.first == 1) && (probe.third == 1)) ||
+			 ((probe.second == 1) && (probe.third == 1)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOERFOLG;
+		}
+		// Patzer
+		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20))
+		{
+			addSe(talentName);
+			return RESULT_SPEKT_AUTOMISSERFOLG;
+		}
+		if ( ((probe.first == 20) && (probe.second == 20)) ||
+			 ((probe.first == 20) && (probe.third == 20)) ||
+			 ((probe.second == 20) && (probe.third == 20)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOMISSERFOLG;
+		}
+
+
+        // Vor dem Vergleich hat man den Talentwert ??brig.
+		int eBe = DsaManager::getSingleton().getTalent(talentName)->calculateEbe(mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM));
+		int taW = getTalent(talentName);
+		int rval = taW - modifier - mEffectManager->getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
+            - mEffectManager->getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
+		// Bei negativen TaP*
+		int handicap = 0;
+		if (rval < 0)
+		{
+			handicap = -rval;
+			rval = 0;
+		}
+
+        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
+        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
+        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
+
+        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
+        // wird die Differenz vom Talentwert abgezogen.
+        rval = diff1 < 0 ? rval + diff1 : rval;
+        rval = diff2 < 0 ? rval + diff2 : rval;
+        rval = diff3 < 0 ? rval + diff3 : rval;
+
+		// TaP* niemals gr????er als TaW (MFF14)
+		if (rval > taW) rval = taW;
+        return rval;
+    }
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
+			eigenschaft2Name, eigenschaft3Name);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent->getEigenschaften());
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
+			et.first, et. second, et.third);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent->getEigenschaften());
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
+			et. second, et.third);
+	}
+
+    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
+    {
+        int rval;
+
+        int probe = DsaManager::getSingleton().rollD20();
+        if (probe == 1)
+        {
+            rval = RESULT_GLUECKLICH;
+        }
+        else if (probe == 20)
+        {
+            rval = RESULT_PATZER;
+        }
+        else
+        {
+			rval = getEigenschaft(eigenschaftName) -
+                (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
+        }
+        return rval;
+    }
+
+
+	Inventory* Creature::getInventory() const
+	{
+		return mInventory;
+	}
+
+    const Ogre::String& Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
+
+	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
+		}
+		int rval;
+		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best??tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20) /// @todo Best??tigen
+		{
+			rval = RESULT_PATZER;
+		}
+		else
+		{
+			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
+                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval < 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
+		}
+		int rval;
+		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best??tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20)
+		{
+			rval = RESULT_PATZER; /// @todo Best??tigen
+		}
+		else
+		{
+			/// @todo Gute Parade
+			rval = getParadeBasis() + (*it).second.second - (probe + modifier
+                + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval < 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doInitiativeWurf(bool getMaxInitiave)
+	{
+		int rval = getInitiativeBasis();
+		rval += mEffectManager->getMod(WERT_INI, Effect::MODTYPE_SUM);
+		rval -= mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM);
+		if (getMaxInitiave)
+        {
+            rval += 6;
+        }
+        else
+        {
+            rval += DsaManager::getSingleton().rollD6();
+        }
+		return rval;
+	}
+
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
+	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
+		// Roll dice
+		const Tripel<int>& weaponTp = weapon->getTp();
+		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
+		rval += weaponTp.third;
+
+		// Apply TP/KK
+
+		int kk = getEigenschaft(E_KOERPERKRAFT);
+		std::pair<int, int> tpkk = weapon->getTpKk();
+		
+		int bonus = (kk - tpkk.first) / tpkk.second;
+		rval += bonus;
+        
+        if (damage == DMG_HALF)
+        {
+            rval = (rval + 1) / 2;
+        }
+        else if (damage == DMG_DOUBLE)
+        {
+            rval *= 2; ///@TODO check if correct
+        }
+
+		return rval;
+	}
+
+	/// @todo Implement correctly
+	void Creature::damageLe(int tp, int damageType)
+	{
+        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+        if (tp < 0)
+        {
+            tp = 0;
+        }
+
+        ///@todo auf Verletzlichkeiten und Immunitaeten achten
+        if (damageType & LEDAMAGE_FIRE)
+        {
+            LOG_ERROR("Creature", "Fire damage not handled!"); ///@todo implement
+        }
+        if (damageType & LEDAMAGE_WATER)
+        {
+            LOG_ERROR("Creature", "Water damage not handled!"); ///@todo implement
+        }
+        if (damageType & LEDAMAGE_DEMONIC)
+        {
+            LOG_ERROR("Creature", "Demonic damage not handled!"); ///@todo implement
+        }
+
+        if (damageType & LEDAMAGE_TP_A)
+        {
+            damageAu(tp, AUDAMAGE_NORMAL);
+            tp = (int)floor(tp/2.);
+        }
+
+        int sp = -tp;
+        if (!(damageType & LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
+		modifyLe(sp);
+
+        if (sp >= getEigenschaft("KO"))
+        {
+            LOG_ERROR("Creature", "TODO: Add a wound."); ///@todo implement
+        }
+	}
+
+    void Creature::damageAe(int asp)
+    {
+        if (asp < 0)
+        {
+         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           asp = 0;
+        }
+        modifyAe(-asp);
+    }
+
+    void Creature::damageAu(float aup, int damageType)
+    {
+        if (aup < 0)
+        {
+         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           aup = 0;
+           ///@todo evtl. eine modifyErschoepfung()?
+           mErschoepfung += DsaManager::getSingleton().rollD6();
+           ///@todo set incapacitated
+        }
+        // bei ??beranstrengung, kostet alles doppelte Au!!!!!
+        if( mErschoepfung > getEigenschaft("KO") )
+            aup *= 2;
+        modifyAu(-aup);
+    }
+
+    void Creature::regenerateLe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedLe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedLe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
+            0, Effect::MODTAG_REGENERATION_LE))
+        {
+            regeneratedLe++;
+        }
+        //modifiziere die aktuellen LE
+        modifyLe(regeneratedLe);
+    }
+
+    void Creature::regenerateAe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedAe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedAe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN",
+            0, Effect::MODTAG_REGENERATION_AE))
+        {
+            regeneratedAe++;
+        }
+        //modifiziere die aktuellen AE
+        modifyAe(regeneratedAe);
+    }
+
+    void Creature::regenerateAu(int modifier, float factor, float time)
+    {
+        // das Ganze nur jede Spielrunde machen
+        mTimeSinceLastRegeneration += time;
+
+
+        if( getAu() == getAuMax() )
+        {
+            mTimeSinceLastRegeneration = 0;
+            return;
+        }
+
+
+        while( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE )
+        {
+            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
+
+
+            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
+            //Grundregeneration von 3W6
+            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6();
+            //Addiere eventuelle Modifikatoren hinzu
+            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
+            //Bei gelungener KO Probe addiere 1
+            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
+                0, mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
+            {
+                modifyAu(6*factor);
+            }
+
+            if( mTimeSinceLastRegeneration >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            {
+                //modifiziere die aktuellen AU
+                time -= Date::ONE_SPIELRUNDE;
+                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
+            }
+
+            if( getAu() == getAuMax() )
+            {
+                mTimeSinceLastRegeneration = 0;
+                return;
+            }
+        }
+
+        // Restbetrag regenerieren:
+        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        modifyAu(regeneratedAuPerTime*factor);
+    }
+
+    void Creature::setAlignment(Creature::Alignment alignment)
+    {
+        mAlignment = alignment;
+    }
+
+    Creature::Alignment Creature::getAlignment() const
+    {
+        return mAlignment;
+    }
+
+    void Creature::setProperty(const CeGuiString& key, const Property& value)
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            mAiProperties = value;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            mCurrentLe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toReal();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            mKampfaktionen.clear();
+            convertToSet(value.toArray(), mKampfaktionen);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory->setProperties(value.toMap());
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            mAnimations.clear();
+            convertToMap(value.toMap(), mAnimations);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            mAnimationSpeeds.clear();
+            convertToMap(value.toMap(), mAnimationSpeeds);
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Creature::getProperty(const CeGuiString& key) const
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            return mAiProperties;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            return Property(mCurrentLe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            return Property(mCurrentAe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            return Property(mCurrentAu);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            return Property(mErschoepfung);
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
+            return Property(vec);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+            return Property(map);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            return Property(make_pair(mAp.total, mAp.used));
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+			return mInventory->getAllProperties()->toPropertyMap();
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimations);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
+            return Property(map);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Creature::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Creature::PROPERTY_AI);
+        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
+        keys.insert(Creature::PROPERTY_CURRENT_LE);
+        keys.insert(Creature::PROPERTY_CURRENT_AE);
+        keys.insert(Creature::PROPERTY_CURRENT_AU);
+        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
+        keys.insert(Creature::PROPERTY_TALENTE);
+        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
+        keys.insert(Creature::PROPERTY_VORTEILE);
+        keys.insert(Creature::PROPERTY_NACHTEILE);
+        //keys.insert(Creature::PROPERTY_SF);
+        keys.insert(Creature::PROPERTY_WERTE);
+        keys.insert(Creature::PROPERTY_AP);
+        keys.insert(Creature::PROPERTY_INVENTORY);
+        keys.insert(Creature::PROPERTY_ANIMATIONS);
+        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
+
+        return keys;
+    }
+
+    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString& name) const
+    {
+        AnimationSpeedPair ret;
+        AnimationsMap::const_iterator itName = mAnimations.find(name);
+        if( itName != mAnimations.end() )
+            ret.first = itName->second.c_str();
+        else
+            ret.first = name.c_str();
+
+        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
+        if( itSpeed != mAnimationSpeeds.end() )
+            ret.second = itSpeed->second;
+        else
+            ret.second = 1;
+
+        return ret;
+    }
+
+    bool Creature::canReachItem(const Item* item) const
+    {
+        return (item->getPosition() - getPosition()).length() <= 3.0f;
+    }
+
+    void Creature::doPlaceIntoScene()
+    {
+        GameObject::doPlaceIntoScene();
+
+        // check items in inventory
+        Inventory::SlotMap slots = mInventory->getAllSlots();
+        Inventory::SlotMap::iterator it = slots.begin();
+        for( ; it != slots.end(); it++ )
+        {
+            it->second->update();
+        }
+    }
+
+    void Creature::doRemoveFromScene()
+    {
+        GameObject::doRemoveFromScene();
+
+        ///@todo check if this is really necessary
+        // check items in inventory
+        //Inventory::SlotMap slots = mInventory->getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it->second->update();
+        //}
+    }
+}

Modified: rl/branches/newton20/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GoToJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/GoToJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -36,8 +36,6 @@
 		  mTimeLeft(duration)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
-                if( mActor == NULL )
-                    Throw(NullPointerException, "Couldn't get a CreatureController!");
 	}
 
 	GoToJob::GoToJob(Creature* actor, GameObject* target, Real maxDistance, Real duration)
@@ -49,10 +47,6 @@
 		  mTimeLeft(duration)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
-                if( mActor == NULL )
-                    Throw(NullPointerException, "Couldn't get a CreatureController!");
-                if( mTarget == NULL )
-                    Throw(NullPointerException, "Argument GameObject* target cannot be NULL!");
 	}
 
     GoToJob::~GoToJob()
@@ -68,25 +62,22 @@
 			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
-
-                Ogre::Real distance = 0;
-
+        
+        Ogre::Real distance;
+        
 		// update target position
 		if (mTarget)
 		{
 			mTargetPos = mTarget->getPosition();
-		        // Are we there now?
-		        distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
-			    mActor->getCreature()->getWorldBoundingBox());
-		}
-                else
-                {
-                    if( mActor->getCreature()->getWorldBoundingBox().intersects(mTargetPos) )
-                        distance = 0;
-                    else
-                        distance = (mTargetPos - mActor->getCreature()->getPosition()).length();
-                }
-
+            distance = MathUtil::distance(mTarget->getWorldBoundingBox(),
+                                                     mActor->getCreature()->getWorldBoundingBox());
+        }
+        else 
+        {
+            distance = MathUtil::distance(mTargetPos, mActor->getCreature()->getWorldBoundingBox());
+        }
+        
+		// Are we there now?
 		if (distance < mMaxDistance)
 		{
 			// Stay put where ever we are.
@@ -94,8 +85,6 @@
 			return true;
 		}
 
-
-                /*
 		// Hard set orientation.
 		/// @todo Use CreatureController properly to turn smoothly
 		Vector3 pos = mActor->getCreature()->getPosition();
@@ -104,13 +93,8 @@
 		targetPos.y = 0;
 		mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
 		mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
-                */
-		Vector3 pos = mActor->getCreature()->getPosition();
-                Radian yawDiff = Vector3::NEGATIVE_UNIT_Z.getRotationTo(mTargetPos-pos, Vector3::UNIT_Y).getYaw() - mActor->getYaw();
-                Vector3 rotation = Vector3::UNIT_Y*yawDiff.valueRadians();
-		mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, rotation);
 
-                mTimeLeft  -= time;
+		mTimeLeft  -= time;
 		return false;
 	}
 }

Modified: rl/branches/newton20/engine/rules/src/Weapon.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Weapon.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Weapon.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -36,7 +36,8 @@
     const Ogre::String Weapon::PROPERTY_TP_DK = "DK";
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = "kampftechnik";
     const Ogre::String Weapon::PROPERTY_NATURAL = "natural";
-
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = "avoidarmor";
+    
 	Weapon::Weapon(unsigned int id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +47,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(""),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +186,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString& key, const Property& value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +251,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +312,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +333,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }

Modified: rl/branches/newton20/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -432,6 +432,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\CharacterSelectionWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\CharacterSheetWindow.h"
 					>
 				</File>
@@ -677,6 +681,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\CharacterSelectionWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\CharacterSheetWindow.cpp"
 					>
 				</File>

Modified: rl/branches/newton20/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -22,6 +22,7 @@
 
 #include <CEGUIWindow.h>
 #include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIRadioButton.h>
 #include <elements/CEGUIEditbox.h>
 #include <elements/CEGUIListbox.h>
 #include <elements/CEGUIMultiColumnList.h>
@@ -77,6 +78,7 @@
 		CEGUI::MenuBase* getMenu(const char* name);
 		CEGUI::MenuItem* getMenuItem(const char* name);
 		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::RadioButton* getRadioButton(const char* name);
 		CEGUI::Combobox* getCombobox(const char* name);
 		CEGUI::ComboDropList* getComboDropList(const char* name);
         CEGUI::ScrollablePane* getScrollablePane(const char* name);

Modified: rl/branches/newton20/engine/ui/include/GameSettings.h
===================================================================
--- rl/branches/newton20/engine/ui/include/GameSettings.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/GameSettings.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -84,7 +84,12 @@
 		bool onRenderSystemChanged();
         
         void update();
-
+        
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Checkbox* checkbox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, CEGUI::Combobox* combobox);
+        void setOption(const Ogre::ConfigOptionMap& configuration, const Ogre::String& option, std::vector<CEGUI::RadioButton*> radioGroup);
+        void createElements(CEGUI::Combobox* combobox, size_t count);
+        
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
@@ -93,6 +98,9 @@
         CEGUI::Combobox* mVideoRenderer;
         CEGUI::Combobox* mVideoResolution;
         CEGUI::Checkbox* mVideoFullscreen;
+        CEGUI::RadioButton* mVideoColorDepth32, *mVideoColorDepth16;
+        CEGUI::RadioButton* mVideoFsaa0, *mVideoFsaa2, *mVideoFsaa4, *mVideoFsaa8;
+        CEGUI::RadioButton* mVideoRttModeFBO, *mVideoRttModePBuffer, *mVideoRttModeCopy;
 	};
 }
 

Modified: rl/branches/newton20/engine/ui/include/WindowManager.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowManager.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/WindowManager.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -19,6 +19,8 @@
 
 #include "UiPrerequisites.h"
 
+#include "MessagePump.h"
+
 namespace rl {
 
 	class AbstractWindow;
@@ -33,6 +35,7 @@
 		void registerWindow(AbstractWindow* window);
 		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
+        bool destroyAllWindows();
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
@@ -47,6 +50,7 @@
 
 	private:
 		std::list<AbstractWindow*> mWindowList;
+        MessagePump::ScopedConnection mSceneClearConnection;
 
         unsigned short mNumActiveWindowsMouseInput;
         unsigned short mNumActiveWindowsKeyboardInput;

Modified: rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -232,7 +232,12 @@
 	{
 		return static_cast<PushButton*>(getWindow(name, "PushButton"));
 	}
-
+    
+	RadioButton* AbstractWindow::getRadioButton(const char* name)
+	{
+		return static_cast<RadioButton*>(getWindow(name, "RadioButton"));
+	}
+    
 	Combobox* AbstractWindow::getCombobox(const char* name)
 	{
 		return static_cast<Combobox*>(getWindow(name, "Combobox"));

Modified: rl/branches/newton20/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,14 +18,22 @@
 #include "GameSettings.h"
 
 #include <boost/bind.hpp>
+#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#include <CEGUI/elements/CEGUIFrameWindow.h>
+#include <CEGUI/elements/CEGUIListboxTextItem.h>
+#else
 #include <elements/CEGUIFrameWindow.h>
 #include <elements/CEGUIListboxTextItem.h>
+#endif
+
 #include <iostream>
 
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
 using namespace Ogre;
+using namespace CEGUI;
+using namespace std;
 
 namespace rl
 {
@@ -51,6 +59,37 @@
         mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
         mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
         mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
+        
+        mVideoColorDepth32 = getRadioButton("GameOptionsWindow/Video/ColorDepth/32");
+        mVideoColorDepth32->setUserData(new Ogre::String("32"));
+        mVideoColorDepth32->setGroupID(1);
+        mVideoColorDepth16 = getRadioButton("GameOptionsWindow/Video/ColorDepth/16");
+        mVideoColorDepth16->setUserData(new Ogre::String("16"));
+        mVideoColorDepth16->setGroupID(1);
+        
+        mVideoFsaa0 = getRadioButton("GameOptionsWindow/Video/FSAA/Off");
+        mVideoFsaa0->setUserData(new Ogre::String("0"));
+        mVideoFsaa0->setGroupID(2);
+        mVideoFsaa2 = getRadioButton("GameOptionsWindow/Video/FSAA/2x");
+        mVideoFsaa2->setUserData(new Ogre::String("2"));
+        mVideoFsaa2->setGroupID(2);
+        mVideoFsaa4 = getRadioButton("GameOptionsWindow/Video/FSAA/4x");
+        mVideoFsaa4->setUserData(new Ogre::String("4"));
+        mVideoFsaa4->setGroupID(2);
+        mVideoFsaa8 = getRadioButton("GameOptionsWindow/Video/FSAA/8x");
+        mVideoFsaa8->setUserData(new Ogre::String("8"));
+        mVideoFsaa8->setGroupID(2);
+        
+        mVideoRttModeFBO = getRadioButton("GameOptionsWindow/Video/RTT/FBO");
+        mVideoRttModeFBO->setUserData(new Ogre::String("FBO"));
+        mVideoRttModeFBO->setGroupID(3);
+        mVideoRttModePBuffer = getRadioButton("GameOptionsWindow/Video/RTT/PBuffer");
+        mVideoRttModePBuffer->setUserData(new Ogre::String("PBuffer"));
+        mVideoRttModePBuffer->setGroupID(3);
+        mVideoRttModeCopy = getRadioButton("GameOptionsWindow/Video/RTT/Copy");
+        mVideoRttModeCopy->setUserData(new Ogre::String("Copy"));
+        mVideoRttModeCopy->setGroupID(3);
+        
         centerWindow();
         setVisible(false);
         update();
@@ -137,50 +176,124 @@
     void GameSettings::update()
     {
         Root* root = Ogre::Root::getSingletonPtr();
+        
+        RenderSystemList* renderers = root->getAvailableRenderers();
         RenderSystem* renderer = root->getRenderSystem();
         
+        createElements(mVideoRenderer, renderers->size());
+
+        for (int i = 0; i < renderers->size(); ++i)
+        {
+            RenderSystem* cur = renderers->operator[](i);
+            ListboxItem* item = mVideoRenderer->getListboxItemFromIndex(i);
+            item->setText(cur->getName());
+            if (cur == renderer)
+            {
+                mVideoRenderer->setItemSelectState(item, true);
+            }
+        }
+        
         ConfigOptionMap config = renderer->getConfigOptions();
         
-		ConfigOptionMap::iterator cfi;
-		
-		cfi = config.find( "Full Screen" );
-		if( cfi != config.end() )
-		{
-			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
-		}
+        setOption(config, "Full Screen", mVideoFullscreen);
+        vector<RadioButton*> videoColorDepth;
+        videoColorDepth.push_back(mVideoColorDepth32);
+        videoColorDepth.push_back(mVideoColorDepth16);
         
-/*		cfi = config.find( "FSAA" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "0" )
-			{
-				SetControlValue( iFSAARef, 1 );
-			}
-			else if( cfi->second.currentValue == "2" )
-			{
-				SetControlValue( iFSAARef, 2 );
-			}
-			else if( cfi->second.currentValue == "4" )
-			{
-				SetControlValue( iFSAARef, 3 );
-			}
-			else if( cfi->second.currentValue == "6" )
-			{
-				SetControlValue( iFSAARef, 4 );
-			}
-		}
+        setOption(config, "Colour Depth", videoColorDepth);
+        vector<RadioButton*> videoAntiAliasing;
+        videoAntiAliasing.push_back(mVideoFsaa0);
+        videoAntiAliasing.push_back(mVideoFsaa2);
+        videoAntiAliasing.push_back(mVideoFsaa4);
+        videoAntiAliasing.push_back(mVideoFsaa8);
+        setOption(config, "FSAA", videoAntiAliasing);
         
-		cfi = config.find( "Colour Depth" );
-		if( cfi != config.end() )
-		{
-			if( cfi->second.currentValue == "32" )
-			{
-				SetControlValue( iColorDepthRef, 1 );
-			}
-			else
-			{
-				SetControlValue( iColorDepthRef, 2 );
-			}
-		}*/
+        vector<RadioButton*> videoRttMode;
+        videoRttMode.push_back(mVideoRttModeFBO);
+        videoRttMode.push_back(mVideoRttModePBuffer);
+        videoRttMode.push_back(mVideoRttModeCopy);
+        setOption(config, "RTT Preferred Mode", videoRttMode);
+        
+        setOption(config, "Video Mode", mVideoResolution);
     }
+    
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Checkbox* checkbox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            checkbox->setSelected(cfi->second.currentValue == "Yes");            
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, Combobox* combobox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            int delta = curOption.possibleValues.size() - combobox->getItemCount();
+            if (delta > 0)
+            {
+                for (int i = 0; i < delta; ++i)
+                {
+                    combobox->addItem(new ListboxTextItem(""));
+                }
+            }
+            else if (delta < 0)
+            {
+                for (int i = 0; i < -delta; ++i)
+                {
+                    ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                    combobox->removeItem(item);
+                    delete item;
+                }
+            }
+            
+            for (int i = 0; i < combobox->getItemCount(); ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(i);
+                item->setText(curOption.possibleValues[i]);
+            }
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap& configuration, const Ogre::String& option, std::vector<RadioButton*> radioGroup)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi->second;
+            for (std::vector<RadioButton*>::const_iterator it = radioGroup.begin(); it != radioGroup.end(); ++it)
+            {
+                Ogre::String* value = static_cast<Ogre::String*>((*it)->getUserData());
+                if (value && (*value == curOption.currentValue))
+                {
+                    (*it)->setSelected(true);
+                    break;
+                }
+            }
+        }
+    }
+    
+    void GameSettings::createElements(CEGUI::Combobox* combobox, size_t count)
+    {
+        int delta = count - combobox->getItemCount();
+        if (delta > 0)
+        {
+            for (int i = 0; i < delta; ++i)
+            {
+                combobox->addItem(new ListboxTextItem(""));
+            }
+        }
+        else if (delta < 0)
+        {
+            for (int i = 0; i < -delta; ++i)
+            {
+                ListboxItem* item = combobox->getListboxItemFromIndex(combobox->getItemCount() - 1);
+                combobox->removeItem(item);
+                delete item;
+            }
+        }
+    }    
 }

Modified: rl/branches/newton20/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -268,7 +268,7 @@
 
         mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
 
-        if (isEnemyNear())
+        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
         {
             InputManager::getSingleton().pushControlState(CST_COMBAT);
         }

Modified: rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -166,6 +166,7 @@
             "UiSubsystem::initializeUiSubsystem");
 
         mWindowFactory->initialize();
+        LOG_MESSAGE2(Logger::UI, "WindowFactory initialized.", "UiSubsystem::initializeUiSubsystem");
     }
 
     CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()

Modified: rl/branches/newton20/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowManager.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/WindowManager.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,8 +18,9 @@
 #include "WindowManager.h"
 #include <CEGUIWindowManager.h>
 
+#include "AbstractWindow.h"
+#include "CoreMessages.h"
 #include "CoreSubsystem.h"
-#include "AbstractWindow.h"
 #include "Exception.h"
 #include "GameLoop.h"
 #include "UiSubsystem.h"
@@ -35,6 +36,8 @@
           mNumActiveWindowsMouseInput(0),
           mNumActiveWindowsKeyboardInput(0)
 	{
+        mSceneClearConnection = MessagePump::getSingleton().addMessageHandler<MessageType_SceneClearing>(
+            boost::bind(&WindowManager::destroyAllWindows, this));
 	}
 
 	WindowManager::~WindowManager()
@@ -123,10 +126,9 @@
     AbstractWindow* WindowManager::getActiveWindow()
     {
         // iterate through windows
-        std::list<AbstractWindow*>::iterator it;
-        for( it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
         {
-            if( (*it)->getWindow()->isActive() )
+            if ( (*it)->getWindow()->isActive() )
             {
                 return *it;
             }
@@ -134,4 +136,23 @@
 
         return NULL;
     }
+
+    bool WindowManager::destroyAllWindows()
+    {
+        for (std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        {
+            AbstractWindow* cur = *it;
+//			if (cur->isVisible())
+//			{
+				cur->setVisible(false, true);
+//			}
+//          else 
+//          {
+//              delete cur;
+//          }
+        }
+
+        mWindowList.clear();
+        return true;
+    }
 }



From melven at mail.berlios.de  Wed Dec 17 22:02:26 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 17 Dec 2008 22:02:26 +0100
Subject: [Dsa-hl-svn] r4655 - rl/branches/newton20/engine/ui/src
Message-ID: <200812172102.mBHL2QKb017141@sheep.berlios.de>

Author: melven
Date: 2008-12-17 22:02:25 +0100 (Wed, 17 Dec 2008)
New Revision: 4655

Modified:
   rl/branches/newton20/engine/ui/src/CombatControlState.cpp
Log:
-improved camera movement in combat (only changed the value of one variable, but looks nicer ;-) )


Modified: rl/branches/newton20/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-12-17 20:11:09 UTC (rev 4654)
+++ rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-12-17 21:02:25 UTC (rev 4655)
@@ -64,7 +64,7 @@
           mCameraCombatCenteredMinDistance(5.0f),
           mCameraThirdPersonMinDistance(1.0f),
           mCameraSwitchDist(30.0f),
-          mCameraSwitchTransitionDist(0.3f)
+          mCameraSwitchTransitionDist(0.8f)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);



From timm at mail.berlios.de  Tue Dec 23 16:36:29 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 23 Dec 2008 16:36:29 +0100
Subject: [Dsa-hl-svn] r4656 - modules/common/materials/programs
Message-ID: <200812231536.mBNFaTCK006457@sheep.berlios.de>

Author: timm
Date: 2008-12-23 16:36:10 +0100 (Tue, 23 Dec 2008)
New Revision: 4656

Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.source
Log:
c'n'p error in Basic_Vertex_Shader.source

Modified: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2008-12-17 21:02:25 UTC (rev 4655)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2008-12-23 15:36:10 UTC (rev 4656)
@@ -97,6 +97,7 @@
    
    AngleAttn = saturate( dot(Input.Normal ,LightDir));
    
+   EyeVect = normalize(Input.Position - eyePosition);
    HalfVect = normalize(LightDir - EyeVect);
    
    SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);



From timm at mail.berlios.de  Tue Dec 23 16:54:58 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 23 Dec 2008 16:54:58 +0100
Subject: [Dsa-hl-svn] r4657 - modules/common/materials/programs
Message-ID: <200812231554.mBNFsw1m008077@sheep.berlios.de>

Author: timm
Date: 2008-12-23 16:54:49 +0100 (Tue, 23 Dec 2008)
New Revision: 4657

Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.source
Log:
c'n'p error in Basic_Vertex_Shader.source

Modified: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2008-12-23 15:36:10 UTC (rev 4656)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2008-12-23 15:54:49 UTC (rev 4657)
@@ -75,8 +75,7 @@
    LightDir = LightDir / Dist;
    
    AngleAttn = saturate( dot(Input.Normal ,LightDir));
-   
-   EyeVect = normalize(Input.Position - vViewPosition);
+
    HalfVect = normalize(LightDir - EyeVect);
    
    SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
@@ -97,7 +96,6 @@
    
    AngleAttn = saturate( dot(Input.Normal ,LightDir));
    
-   EyeVect = normalize(Input.Position - eyePosition);
    HalfVect = normalize(LightDir - EyeVect);
    
    SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);



From chrber at mail.berlios.de  Tue Dec 30 23:25:52 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Tue, 30 Dec 2008 23:25:52 +0100
Subject: [Dsa-hl-svn] r4658 - in rl/trunk: . cmake engine/core
	engine/core/include engine/core/src engine/rules engine/ui plugins
Message-ID: <200812302225.mBUMPqkd028543@sheep.berlios.de>

Author: chrber
Date: 2008-12-30 23:25:45 +0100 (Tue, 30 Dec 2008)
New Revision: 4658

Added:
   rl/trunk/cmake/FindMeshMagick.cmake
   rl/trunk/cmake/FindOIS.cmake
   rl/trunk/engine/rules/CMakeLists.txt
   rl/trunk/engine/ui/CMakeLists.txt
Modified:
   rl/trunk/CMakeLists.txt
   rl/trunk/cmake/FindCEGUI.cmake
   rl/trunk/cmake/FindFMODEx.cmake
   rl/trunk/cmake/FindOGRE.cmake
   rl/trunk/cmake/FindOgreNewt.cmake
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/SaveAble.h
   rl/trunk/engine/core/include/SaveAbleCollection.h
   rl/trunk/engine/core/include/SaveAbleManager.h
   rl/trunk/engine/core/src/SaveAble.cpp
   rl/trunk/engine/core/src/SaveAbleCollection.cpp
   rl/trunk/engine/core/src/SaveAbleFactory.cpp
   rl/trunk/engine/core/src/SaveAbleManager.cpp
   rl/trunk/plugins/CMakeLists.txt
Log:
Corrected CMake macros
Added new CMakeLists.txt files for rules and ui
Corrected the typical bunch of missing line endings


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/CMakeLists.txt	2008-12-30 22:25:45 UTC (rev 4658)
@@ -2,9 +2,6 @@
 
 CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
 
-# Cmake handles escaping of preprocessor directives
-CMAKE_POLICY(SET CMP0005 OLD)
-
 # Include required cmake macros
 INCLUDE(FeatureSummary)
 
@@ -29,8 +26,11 @@
 FIND_PACKAGE(PkgConfig)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
 FIND_PACKAGE(OgreNewt REQUIRED)
+FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
+FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
+FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(SWIG REQUIRED)
 IF (NOT SWIG_DIR MATCHES -rl$)
 	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
@@ -42,11 +42,11 @@
 SET(DATADIRNAME "rastullah" CACHE STRING "change the name of the directory for the read-only architecture-independent game data")
 
 # Game options
-SET(ENABLE_FMOD4 "Enable FMOD 4.xx (FMODex) sound support" ON)
-SET(ENABLE_OPENAL "Enable OpenAL sound support (unsupported)" OFF)
+SET(WITH_FMOD4 ON CACHE BOOL "Enable FMOD 4.xx (FMODex) sound support")
+SET(WITH_OPENAL OFF CACHE BOOL "Enable OpenAL sound support (unsupported)")
 
 # Handle options
-ADD_DEFINITIONS(-DRL_MODULEDIR=\\"${DATAROOTDIR}/${DATADIRNAME}/modules\\")
+ADD_DEFINITIONS(-DRL_MODULEDIR="${DATAROOTDIR}/${DATADIRNAME}/modules")
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)

Modified: rl/trunk/cmake/FindCEGUI.cmake
===================================================================
--- rl/trunk/cmake/FindCEGUI.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindCEGUI.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -53,7 +53,7 @@
 	MESSAGE(STATUS "Looking for CEGUI")
 	FIND_PATH(CEGUI_INCLUDE_DIRS CEGUI.h ${CEGUI_INCLUDE_SEARCH_DIRS})
 	FIND_LIBRARY(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
-	
+
 # 	SET(OGRESOURCE $ENV{OGRE_NEW})
 # 	IF (OGRESDK)
 # 		MESSAGE(STATUS "Using CEGUI in OGRE SDK")
@@ -81,7 +81,6 @@
 	SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
 	SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
 
-	CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
 	FIND_PACKAGE(PkgConfig)
 	IF(PKG_CONFIG_FOUND)
 		PKG_SEARCH_MODULE(CEGUI CEGUI)

Modified: rl/trunk/cmake/FindFMODEx.cmake
===================================================================
--- rl/trunk/cmake/FindFMODEx.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindFMODEx.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -6,6 +6,7 @@
 # FMODEX_LIBRARY
 #
 # Based on the CMakeLists.txt of zdoom and FindFMOD.cmake of openfrag
+# Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
 #
 # Redistribution and use is allowed according to the terms of the BSD license.
 # For details see the accompanying COPYING-CMAKE-SCRIPTS file.
@@ -15,7 +16,7 @@
 	SET(FMODEX_FIND_QUIETLY TRUE)
 ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
 
-# Check for for 32/64 bit architecture
+# Check for 32/64 bit architecture
 IF(CMAKE_SIZEOF_VOID_P MATCHES "8")
 	SET(X64 64)
 ENDIF(CMAKE_SIZEOF_VOID_P MATCHES "8")
@@ -28,14 +29,14 @@
 	    /usr/include
 	    /usr/local/include
 	    /opt/fmodex/fmodex/include
-            /opt/include)
+            /opt/include INTERNAL)
 	SET(FMODEX_LIBRARY_SEARCH_DIRS
 	    /usr/lib
 	    /usr/lib64
 	    /usr/local/lib
 	    /usr/local/lib64
 	    /opt/fmodex/lib
-	    /opt/fmodex/lib64)
+	    /opt/fmodex/lib64 INTERNAL)
 	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES fmodex)
 ENDIF(WIN32)
 
@@ -60,38 +61,19 @@
 FIND_PATH(FMODEX_INCLUDE_DIR fmod.h
           PATHS ${FMODEX_INCLUDE_SEARCH_PATHS}
           PATH_SUFFIXES ${FMODEX_INC_DIR_SUFFIXES})
-IF(FMODEX_INCLUDE_DIR)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS "  includes: ${FMODEX_INCLUDE_DIR}")
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_INCLUDE_DIR)
-	MESSAGE(SEND_ERROR "FMODEx include files could not be found.")
-ENDIF(FMODEX_INCLUDE_DIR)
 
 FIND_LIBRARY(FMODEX_LIBRARY ${FMODEX_LIBRARY_NAME}
              PATHS ${FMODEX_LIBRARY_SEARCH_DIRS}
              PATH_SUFFIXES ${FMOD_LIB_DIR_SUFFIXES})
-IF(FMODEX_LIBRARY)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS "  libraries: ${FMODEX_LIBRARY}")
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_LIBRARY)
-	MESSAGE(SEND_ERROR, "FMODex library could not be found.")
-ENDIF(FMODEX_LIBRARY)
 
 IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
 	SET(FMODEX_FOUND TRUE)
 ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
 
-# Allow customisation of paths
-SET(FMODEX_INCLUDE_DIR ${FMODEX_INCLUDE_DIR})
-SET(FMODEX_LIBRARY ${FMODEX_LIBRARY})
-
 IF(FMODEX_INCLUDE_DIR)
 	# Extract the library version from the header file
 	SET(FMODEX_VERSION 0)
-	FILE(READ "${FMODEX_INCLUDE_DIR}/fmod.h"
-	     _FMODEX_FMOD_H_CONTENTS)
+	FILE(READ "${FMODEX_INCLUDE_DIR}/fmod.h" _FMODEX_FMOD_H_CONTENTS)
 	STRING(REGEX REPLACE ".*#define FMOD_VERSION    0x([0-9]+).*" "\\1"
 	       FMODEX_VERSION "${_FMODEX_FMOD_H_CONTENTS}")
 	IF(NOT "${FMODEX_VERSION}" STREQUAL 0)
@@ -105,7 +87,7 @@
 	IF(FMODEx_FIND_VERSION)
 		# Major and minor version are required
 		IF(NOT FMODEx_FIND_VERSION_MINOR)
-			MESSAGE(SEND_ERROR "When requesting a specific version of FMODEx , you must provide at least the major and minor version numbers, e.g., 4.20")
+			MESSAGE(SEND_ERROR "When requesting a specific version of FMODEx, you must provide at least the major and minor version numbers, e.g., 4.20")
 		ENDIF(NOT FMODEx_FIND_VERSION_MINOR)
 
 		IF ("${FMOD_VERSION}" VERSION_LESS "${FMODEx_FIND_VERSION}")
@@ -117,6 +99,15 @@
 
 IF(FMODEX_FOUND)
 	IF(NOT FMODEX_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries: ${FMODEX_LIBRARY}")
+		MESSAGE(STATUS "  includes: ${FMODEX_INCLUDE_DIR}")
 		MESSAGE(STATUS "  version: ${FMODEX_VERSION}")
 	ENDIF(NOT FMODEX_FIND_QUIETLY)
+ELSE(FMODEX_FOUND)
+	IF(NOT FMODEX_LIBRARY)
+		MESSAGE(SEND_ERROR, "FMODex library could not be found.")
+	ENDIF(NOT FMODEX_LIBRARY)
+	IF(NOT FMODEX_INCLUDE_DIR)
+		MESSAGE(SEND_ERROR "FMODEx include files could not be found.")
+	ENDIF(NOT FMODEX_INCLUDE_DIR)
 ENDIF(FMODEX_FOUND)
\ No newline at end of file

Added: rl/trunk/cmake/FindMeshMagick.cmake
===================================================================
--- rl/trunk/cmake/FindMeshMagick.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindMeshMagick.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -0,0 +1,78 @@
+# Find MeshMagick
+#
+# This module defines
+# MESHMAGICK_FOUND
+# MESHMAGICK_INCLUDE_DIR
+# MESHMAGICK_LIBRARY
+#
+# Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+MESSAGE(STATUS "Value of MESHMAGICK_INCLUDE_DIR from previous run: ${MESHMAGICK_INCLUDE_DIR}")
+MESSAGE(STATUS "Value of MESHMAGICK_LIBRARY from previous run: ${MESHMAGICK_LIBRARY}")
+
+# On a new cmake run, we do not need to be verbose
+IF(MESHMAGICK_INCLUDE_DIR AND MESHMAGICK_LIBRARY)
+	SET(MESHMAGICK_FIND_QUIETLY TRUE)
+ENDIF(MESHMAGICK_INCLUDE_DIR AND MESHMAGICK_LIBRARY)
+
+IF (NOT MESHMAGICK_FIND_QUIETLY)
+	MESSAGE(STATUS "Checking for MeshMagick")
+ENDIF(NOT MESHMAGICK_FIND_QUIETLY)
+
+# Search for headers and libraries
+IF(WIN32)
+
+ELSE(WIN32)
+	IF(PKG_CONFIG_FOUND)
+		PKG_SEARCH_MODULE(MESHMAGICK meshmagick)
+		SET(MESHMAGICK_INCLUDE_DIR ${MESHMAGICK_INCLUDE_DIRS})
+		SET(MESHMAGICK_LIBRARY ${MESHMAGICK_LIBRARIES})
+	ENDIF(PKG_CONFIG_FOUND)
+	IF(NOT MESHMAGICK_FOUND)
+		SET(MESHMAGICK_INCLUDE_SEARCH_DIRS
+		    /usr/include
+		    /usr/local/include
+		    /opt/include
+		    /opt/meshmagick/include)
+		SET(MESHMAGICK_LIBRARY_SEARCH_DIRS
+		    /usr/lib
+		    /usr/lib64
+		    /usr/local/lib
+		    /usr/local/lib64
+		    /opt/meshmagick/lib
+		    /opt/meshmagick/lib64)
+		SET(MESHMAGICK_INC_DIR_SUFFIXES PATH_SUFFIXES meshmagick)
+		FIND_PATH(MESHMAGICK_INCLUDE_DIR MeshMagickPrerequisites.h
+		          PATHS ${MESHMAGICK_INCLUDE_SEARCH_DIRS}
+		          PATH_SUFFIXES ${MESHMAGICK_INC_DIR_SUFFIXES})
+		FIND_LIBRARY(MESHMAGICK_LIBRARY meshmagick
+		             PATHS ${MESHMAGICK_LIBRARY_SEARCH_DIRS}
+		             PATH_SUFFIXES ${MESHMAGICK_LIB_DIR_SUFFIXES}})
+	ENDIF(NOT MESHMAGICK_FOUND)
+ENDIF(WIN32)
+
+SET(MESHMAGICK_INCLUDE_DIR ${MESHMAGICK_INCLUDE_DIR})
+SET(MESHMAGICK_LIBRARY ${MESHMAGICK_LIBRARY})
+
+IF(MESHMAGICK_INCLUDE_DIR AND MESHMAGICK_LIBRARY)
+	SET(MESHMAGICK_FOUND TRUE)
+ENDIF(MESHMAGICK_INCLUDE_DIR AND MESHMAGICK_LIBRARY)
+
+IF(MESHMAGICK_FOUND)
+	IF(NOT MESHMAGICK_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries: ${MESHMAGICK_LIBRARY} from ${MESHMAGICK_LIBRARY_DIRS}")
+		MESSAGE(STATUS "  includes: ${MESHMAGICK_INCLUDE_DIR}")
+	ENDIF(NOT MESHMAGICK_FIND_QUIETLY)
+ELSE(MESHMAGICK_FOUND)
+	IF(MeshMagick_FIND_REQUIRED)
+		IF(NOT MESHMAGICK_LIBRARY)
+			MESSAGE(SEND_ERROR, "MeshMagick library could not be found.")
+		ENDIF(NOT MESHMAGICK_LIBRARY)
+		IF(NOT MESHMAGICK_INCLUDE_DIR)
+			MESSAGE(SEND_ERROR "MeshMagick include files could not be found.")
+		ENDIF(NOT MESHMAGICK_INCLUDE_DIR)
+	ENDIF(MeshMagick_FIND_REQUIRED)
+ENDIF(MESHMAGICK_FOUND)
\ No newline at end of file

Modified: rl/trunk/cmake/FindOGRE.cmake
===================================================================
--- rl/trunk/cmake/FindOGRE.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindOGRE.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -11,6 +11,9 @@
 # Redistribution and use is allowed according to the terms of the BSD license.
 # For details see the accompanying COPYING-CMAKE-SCRIPTS file.
 
+MESSAGE(STATUS "Value of OGRE_INCLUDE_DIRS from previous run: ${OGRE_INCLUDE_DIRS}")
+MESSAGE(STATUS "Value of OGRE_LIBRARIES from previous run: ${OGRE_LIBRARIES}")
+
 IF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
 	SET(OGRE_FIND_QUIETLY TRUE) # Already in cache, be silent
 ENDIF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
@@ -58,11 +61,10 @@
 ELSE (WIN32) #Unix/OSX
 	FIND_PACKAGE(PkgConfig)
 	IF(PKG_CONFIG_FOUND)
-		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
 		PKG_SEARCH_MODULE(OGRE OGRE)
 		IF(NOT PKGCONFIG_FAILED)
 			_PKGCONFIG_INVOKE(OGRE "OGRE" PLUGINDIR "" --variable=plugindir)
-			ADD_DEFINITIONS(-DOGRE_PLUGINDIR=\\"${OGRE_PLUGINDIR}\\")
+			ADD_DEFINITIONS(-DOGRE_PLUGINDIR="${OGRE_PLUGINDIR}")
 		ENDIF(NOT PKGCONFIG_FAILED)
 		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
 		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})

Added: rl/trunk/cmake/FindOIS.cmake
===================================================================
--- rl/trunk/cmake/FindOIS.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindOIS.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -0,0 +1,78 @@
+# - Find OIS includes and library
+#
+# This module defines
+#  OIS_INCLUDE_DIRS
+#  OIS_LIBRARIES, the libraries to link against to use OIS.
+#  OIS_LIBRARY_DIRS, the location of the libraries
+#  OIS_FOUND, If false, do not try to use OIS
+#
+# Copyright ? 2007-2008, Matt Williams
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(OIS_INCLUDE_DIR AND OIS_LIBRARY)
+	SET(OIS_FIND_QUIETLY TRUE)
+ENDIF(OIS_INCLUDE_DIR AND OIS_LIBRARY)
+
+IF (WIN32)
+	MESSAGE(STATUS "Looking for OIS")
+	SET(OGRESDK $ENV{OGRE_HOME})
+	SET(OGRESOURCE $ENV{OGRE_NEW})
+	IF (OGRESDK)
+		MESSAGE(STATUS "Using OIS in OGRE SDK")
+		SET(OGRESDK $ENV{OGRE_HOME})
+		STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}")
+		SET(OIS_INCLUDE_DIRS ${OGRESDK}/include)
+		SET(OIS_LIBRARY_DIRS ${OGRESDK}/lib)
+		SET(OIS_LIBRARIES debug OIS_d optimized OIS)
+	ELSEIF (OGRESOURCE)
+		MESSAGE(STATUS "Using OIS in OGRE dependencies")
+		SET(OIS_INCLUDE_DIRS C:/ogrenew/Dependencies/include)
+		SET(OIS_LIBRARY_DIRS C:/ogrenew/Dependencies/lib/Release C:/ogrenew/Dependencies/lib/Debug)
+		SET(OIS_LIBRARIES debug OIS_d optimized OIS)
+	ELSE (OGRESDK)
+		IF (NOT DEPENDENCIES_PATH)
+			MESSAGE(STATUS "Please set DEPENDENCIES_PATH (the directory containing 'common' and 'dependencies')")
+		ELSE (NOT DEPENDENCIES_PATH)
+			SET(CEGUIOGRE_INCLUDE_DIRS ${DEPENDENCIES_PATH}/dependencies/Ogre/OIS)
+			SET(CEGUIOGRE_LIBRARIES optimized OIS debug OIS_d)
+			SET(CEGUIOGRE_LIBRARY_DIRS optimized ${DEPENDENCIES_PATH}/dependencies/lib/release debug ${DEPENDENCIES_PATH}/dependencies/lib/debug)
+		ENDIF (NOT DEPENDENCIES_PATH)
+	ENDIF (OGRESDK)
+ELSE(WIN32)
+	IF(PKG_CONFIG_FOUND)
+		PKG_SEARCH_MODULE(OIS OIS)
+		SET(OIS_INCLUDE_DIR ${OIS_INCLUDE_DIRS})
+		SET(OIS_LIBRARY ${OIS_LIBRARIES})
+	ENDIF(PKG_CONFIG_FOUND)
+	IF(NOT OIS_FOUND)
+
+	ENDIF(NOT OIS_FOUND)
+ENDIF(WIN32)
+
+#Do some preparation
+SEPARATE_ARGUMENTS(OIS_INCLUDE_DIRS)
+SEPARATE_ARGUMENTS(OIS_LIBRARIES)
+
+SET(OIS_INCLUDE_DIRS ${OIS_INCLUDE_DIRS})
+SET(OIS_LIBRARIES ${OIS_LIBRARIES})
+SET(OIS_LIBRARY_DIRS ${OIS_LIBRARY_DIRS})
+
+MARK_AS_ADVANCED(OIS_INCLUDE_DIRS OIS_LIBRARIES OIS_LIBRARY_DIRS)
+
+IF (OIS_INCLUDE_DIR AND OIS_LIBRARY)
+	SET(OIS_FOUND TRUE)
+ENDIF (OIS_INCLUDE_DIR AND OIS_LIBRARY)
+
+IF (OIS_FOUND)
+	IF (NOT OIS_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries : ${OIS_LIBRARIES} from ${OIS_LIBRARY_DIRS}")
+		MESSAGE(STATUS "  includes  : ${OIS_INCLUDE_DIRS}")
+	ENDIF (NOT OIS_FIND_QUIETLY)
+ELSE (OIS_FOUND)
+	IF (OIS_FIND_REQUIRED)
+		MESSAGE(FATAL_ERROR "Could not find OIS")
+	ENDIF (OIS_FIND_REQUIRED)
+ENDIF (OIS_FOUND)

Modified: rl/trunk/cmake/FindOgreNewt.cmake
===================================================================
--- rl/trunk/cmake/FindOgreNewt.cmake	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/cmake/FindOgreNewt.cmake	2008-12-30 22:25:45 UTC (rev 4658)
@@ -18,5 +18,7 @@
 ELSE(WIN32)
 	IF(PKG_CONFIG_FOUND)
 		PKG_SEARCH_MODULE(OGRENEWT OgreNewt)
+		SET(OGRENEWT_INCLUDE_DIR ${OGRENEWT_INCLUDE_DIRS})
+		SET(OGRENEWT_LIBRARY ${OGRENEWT_LIBRARIES})
 	ENDIF(PKG_CONFIG_FOUND)
 ENDIF(WIN32)
\ No newline at end of file

Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/CMakeLists.txt	2008-12-30 22:25:45 UTC (rev 4658)
@@ -1,9 +1,12 @@
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}/include
+${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
-${OGRENEWT_INCLUDE_DIRS})
+${OGRENEWT_INCLUDE_DIR}
+${MESHMAGICK_INCLUDE_DIR}
+${RUBY_INCLUDE_PATH})
 
 SET(RlCore_LIB_SRCS
 src/Actor.cpp
@@ -86,7 +89,7 @@
 
 ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
 
-#TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES})
+TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCore PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}

Modified: rl/trunk/engine/core/include/SaveAble.h
===================================================================
--- rl/trunk/engine/core/include/SaveAble.h	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/include/SaveAble.h	2008-12-30 22:25:45 UTC (rev 4658)
@@ -55,4 +55,5 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
+

Modified: rl/trunk/engine/core/include/SaveAbleCollection.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleCollection.h	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/include/SaveAbleCollection.h	2008-12-30 22:25:45 UTC (rev 4658)
@@ -31,4 +31,5 @@
 		Ogre::String mId;
 	};
 
-}
\ No newline at end of file
+}
+

Modified: rl/trunk/engine/core/include/SaveAbleManager.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleManager.h	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/include/SaveAbleManager.h	2008-12-30 22:25:45 UTC (rev 4658)
@@ -41,4 +41,5 @@
 	};
 }
 
-#endif
\ No newline at end of file
+#endif
+

Modified: rl/trunk/engine/core/src/SaveAble.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAble.cpp	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/src/SaveAble.cpp	2008-12-30 22:25:45 UTC (rev 4658)
@@ -55,4 +55,5 @@
 	{
 		return mId;
 	}
-}
\ No newline at end of file
+}
+

Modified: rl/trunk/engine/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleCollection.cpp	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/src/SaveAbleCollection.cpp	2008-12-30 22:25:45 UTC (rev 4658)
@@ -16,4 +16,5 @@
 
 #include "stdinc.h"
 
-#include "SaveAbleCollection.h"
\ No newline at end of file
+#include "SaveAbleCollection.h"
+

Modified: rl/trunk/engine/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleFactory.cpp	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/src/SaveAbleFactory.cpp	2008-12-30 22:25:45 UTC (rev 4658)
@@ -16,4 +16,5 @@
 
 #include "stdinc.h"
 
-#include "SaveAbleFactory.h"
\ No newline at end of file
+#include "SaveAbleFactory.h"
+

Modified: rl/trunk/engine/core/src/SaveAbleManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleManager.cpp	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/core/src/SaveAbleManager.cpp	2008-12-30 22:25:45 UTC (rev 4658)
@@ -16,4 +16,5 @@
 
 #include "stdinc.h"
 
-#include "SaveAbleManager.h"
\ No newline at end of file
+#include "SaveAbleManager.h"
+

Added: rl/trunk/engine/rules/CMakeLists.txt
===================================================================
--- rl/trunk/engine/rules/CMakeLists.txt	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/rules/CMakeLists.txt	2008-12-30 22:25:45 UTC (rev 4658)
@@ -0,0 +1,84 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${RL_COMMON_INCLUDE_DIR}
+${RL_CORE_INCLUDE_DIR}
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS}
+${OGRENEWT_INCLUDE_DIR})
+
+SET(RlRules_LIB_SRCS
+src/Action.cpp
+src/ActionManager.cpp
+src/ApplyDamageJob.cpp
+src/Armor.cpp
+src/Combat.cpp
+src/Combatant.cpp
+src/CombatManager.cpp
+src/Container.cpp
+src/Creature.cpp
+src/CreatureController.cpp
+src/CreatureControllerManager.cpp
+src/Date.cpp
+src/DsaDataLoader.cpp
+src/DsaManager.cpp
+src/Effect.cpp
+src/EffectFactory.cpp
+src/EffectManagementTask.cpp
+src/EffectManager.cpp
+src/Eigenschaft.cpp
+src/EigenschaftenStateSet.cpp
+src/GameEventLog.cpp
+src/GameObject.cpp
+src/GameObjectManager.cpp
+src/GameTimeSource.cpp
+src/GlobalProperties.cpp
+src/GoToJob.cpp
+src/FetchItemJob.cpp
+src/Item.cpp
+src/Inventory.cpp
+src/JournalEntry.cpp
+src/Kampfaktion.cpp
+src/Kampftechnik.cpp
+src/ObjectStateChangeEvent.cpp
+src/ObjectStateChangeEventSource.cpp
+src/ObjectStateChangeListener.cpp
+src/PartyManager.cpp
+src/Quest.cpp
+src/QuestBook.cpp
+src/QuestEvent.cpp
+src/QuestListener.cpp
+src/RulesSubsystem.cpp
+src/SelectionHelper.cpp
+src/Selector.cpp
+src/Slot.cpp
+src/SonderfertigkeitenStateSet.cpp
+src/StateSet.cpp
+src/Talent.cpp
+src/Talentgruppe.cpp
+src/TalentStateSet.cpp
+src/WaitJob.cpp
+src/Weapon.cpp
+src/ZauberStateSet.cpp
+src/FallDownMovement.cpp
+src/JogFastMovement.cpp
+src/JogMovement.cpp
+src/JumpHighMovement.cpp
+src/JumpLongMovement.cpp
+src/JumpToTargetMovement.cpp
+src/LieDownMovement.cpp
+src/RotateMovement.cpp
+src/SneakMovement.cpp
+src/SprintMovement.cpp
+src/StandAroundMovement.cpp
+src/StepRecognitionMovement.cpp
+src/StrafeMovement.cpp
+src/WalkMovement.cpp)
+
+ADD_LIBRARY(RlRules SHARED ${RlRules_LIB_SRCS})
+
+TARGET_LINK_LIBRARIES(RlRules ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY})
+
+SET_TARGET_PROPERTIES(RlRules PROPERTIES
+	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
+	DEFINE_SYMBOL RLRULES_EXPORTS)
\ No newline at end of file

Added: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/engine/ui/CMakeLists.txt	2008-12-30 22:25:45 UTC (rev 4658)
@@ -0,0 +1,73 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${RL_COMMON_INCLUDE_DIR}
+${RL_CORE_INCLUDE_DIR}
+${RL_RULES_INCLUDE_DIR}
+${RL_AI_INCLUDE_DIR}
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS}
+${OGRENEWT_INCLUDE_DIR}
+${OIS_INCLUDE_DIRS}
+${RUBY_INCLUDE_PATH})
+
+SET(RlUi_LIB_SRCS
+src/AboutWindow.cpp
+src/ActionChoiceWindow.cpp
+src/AbstractWindow.cpp
+src/CharacterSheetWindow.cpp
+src/CharacterStateWindow.cpp
+src/CloseConfirmationWindow.cpp
+src/CombatControlState.cpp
+src/CombatGui.cpp
+src/CombatWindow.cpp
+src/CommandMapper.cpp
+src/ConfigComponent.cpp
+src/ContainerContentWindow.cpp
+src/ControlState.cpp
+src/Console.cpp
+src/CutsceneControlState.cpp
+src/DebugWindow.cpp
+src/DialogControlState.cpp
+src/DialogWindow.cpp
+src/FreeflightControlState.cpp
+src/GameLoggerWindow.cpp
+src/GameObjectInfoWindow.cpp
+src/GameOverWindow.cpp
+src/GameSaveLoadWindow.cpp
+src/GameSettings.cpp
+src/InfoPopup.cpp
+src/InGameMenuWindow.cpp
+src/InputManager.cpp
+src/InventoryWindow.cpp
+src/ItemDragContainer.cpp
+src/ItemDescriptionDragContainer.cpp
+src/ItemIconDragContainer.cpp
+src/JournalWindow.cpp
+src/ListboxWrappedTextItem.cpp
+src/LogWindow.cpp
+src/MainMenuWindow.cpp
+src/MainMenuEngineWindow.cpp
+src/MainMenuLoadWindow.cpp
+src/MessageWindow.cpp
+src/MovementControlState.cpp
+src/ObjectDescriptionWindow.cpp
+src/PlaylistWindow.cpp
+src/ProgressWindow.cpp
+src/PropertiesWindow.cpp
+src/RenderSystemConfigComponent.cpp
+src/SoundConfig.cpp
+src/SoundDriverConfigComponent.cpp
+src/SubtitleWindow.cpp
+src/UiSubsystem.cpp
+src/WindowFactory.cpp
+src/WindowFadeJob.cpp
+src/WindowManager.cpp)
+
+ADD_LIBRARY(RlUi SHARED ${RlUi_LIB_SRCS})
+
+TARGET_LINK_LIBRARIES(RlUi ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${RUBY_LIBRARY})
+
+SET_TARGET_PROPERTIES(RlUi PROPERTIES
+	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
+	DEFINE_SYMBOL RLRULES_EXPORTS)
\ No newline at end of file

Modified: rl/trunk/plugins/CMakeLists.txt
===================================================================
--- rl/trunk/plugins/CMakeLists.txt	2008-12-23 15:54:49 UTC (rev 4657)
+++ rl/trunk/plugins/CMakeLists.txt	2008-12-30 22:25:45 UTC (rev 4658)
@@ -1,13 +1,13 @@
-IF (ENABLE_FMOD4)
+IF (WITH_FMOD4)
 	FIND_PACKAGE(FMODEx 4.20)
 	IF (FMODEX_FOUND)
 		ADD_SUBDIRECTORY(fmod4driver)
 	ENDIF (FMODEX_FOUND)
-ENDIF (ENABLE_FMOD4)
+ENDIF (WITH_FMOD4)
 
-IF (ENABLE_OPENAL)
+IF (WITH_OPENAL)
 	FIND_PACKAGE(OpenAL)
 	IF (OPENAL_FOUND)
 		ADD_SUBDIRECTORY(openaldriver)
 	ENDIF (OPENAL_FOUND)
-ENDIF (ENABLE_OPENAL)
\ No newline at end of file
+ENDIF (WITH_OPENAL)
\ No newline at end of file



From timm at mail.berlios.de  Wed Dec 31 14:13:18 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 31 Dec 2008 14:13:18 +0100
Subject: [Dsa-hl-svn] r4659 - modules/kanalisation/materials
Message-ID: <200812311313.mBVDDIE7002551@sheep.berlios.de>

Author: timm
Date: 2008-12-31 14:13:10 +0100 (Wed, 31 Dec 2008)
New Revision: 4659

Added:
   modules/kanalisation/materials/TotalReflectDirtWaterPixel_hlsl.source
   modules/kanalisation/materials/TotalReflectDirtWaterVertex_hlsl.source
Modified:
   modules/kanalisation/materials/DirtyWater.material
Log:
rewritten dirty water shader in hlsl

Modified: modules/kanalisation/materials/DirtyWater.material
===================================================================
--- modules/kanalisation/materials/DirtyWater.material	2008-12-30 22:25:45 UTC (rev 4658)
+++ modules/kanalisation/materials/DirtyWater.material	2008-12-31 13:13:10 UTC (rev 4659)
@@ -2,19 +2,18 @@
 // Distortion effects
 //----------------------------
 
-vertex_program TotalReflectDirtWaterVP cg
+vertex_program TotalReflectDirtWaterVS hlsl
 {
-	source TotalReflectDirtWater.source
-	entry_point main_vp
-	profiles vs_1_1 arbvp1
+	source TotalReflectDirtWaterVertex_hlsl.source
+	entry_point vs_main
+	target vs_2_0
 }
 
-fragment_program TotalReflectDirtWaterFP cg
+fragment_program TotalReflectDirtWaterPS hlsl
 {
-	source TotalReflectDirtWater.source
-	entry_point main_fp
-	// sorry, ps_1_1 and fp20 can't do this
-	profiles ps_2_0 arbfp1
+	source TotalReflectDirtWaterPixel_hlsl.source
+	entry_point ps_main
+	target ps_2_0
 }
 
 material DirtyWater
@@ -26,20 +25,37 @@
 		{
 			ambient 0.609804 0.609804 0.609804 1
 			
-			vertex_program_ref TotalReflectDirtWaterVP
+			vertex_program_ref TotalReflectDirtWaterVS
 			{
 				param_named_auto worldViewProjMatrix worldviewproj_matrix
 				param_named_auto eyePosition camera_position_object_space
-				param_named_auto lightPosition light_position_object_space 0
-				param_named_auto lightDiffuse light_diffuse_colour 0
+				
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto Light3_attenuation light_attenuation 2
+				param_named_auto Light3_color light_diffuse_colour 2
+				param_named_auto Light3_position light_position_object_space 2
+				param_named Light3_spec_power float 0.3
+				
 				param_named_auto timeVal time 0.05
-				param_named_auto ambient ambient_light_colour
+				//param_named_auto ambient ambient_light_colour
+				param_named skycolor float4 0.8 0.8 0.8 1.0
+				param_named groundcolor float4 0.40 0.40 0.40 1.0
+				
 				param_named scroll float 1  
 				param_named scale float 1 
 				param_named noise float 1 
 				// scroll and noisePos will need updating per frame
 			}
-			fragment_program_ref TotalReflectDirtWaterFP
+			fragment_program_ref TotalReflectDirtWaterPS
 			{
 				param_named fresnelBias float -0.1 
 				param_named fresnelScale float 1.8 

Added: modules/kanalisation/materials/TotalReflectDirtWaterPixel_hlsl.source
===================================================================
--- modules/kanalisation/materials/TotalReflectDirtWaterPixel_hlsl.source	2008-12-30 22:25:45 UTC (rev 4658)
+++ modules/kanalisation/materials/TotalReflectDirtWaterPixel_hlsl.source	2008-12-31 13:13:10 UTC (rev 4659)
@@ -0,0 +1,42 @@
+//pixel shader
+float noiseScale;
+float fresnelBias;
+float fresnelScale;
+float fresnelPower;
+
+sampler2D noiseMap;
+sampler2D reflectMap;
+sampler2D dirtMap;
+
+struct PS_INPUT
+{
+	float3 NoiseCoord : TEXCOORD0;
+	float4 ProjectionCoord : TEXCOORD1;
+	float3 EyeDir : TEXCOORD2;
+	float3 Normal : TEXCOORD3;
+	float2 Tex    : TEXCOORD4;
+	float4 Color   : COLOR;
+};
+
+float4 ps_main(PS_INPUT Input) : COLOR
+{
+	// Do the tex projection manually so we can distort _after_
+	float2 final = Input.ProjectionCoord.xy / Input.ProjectionCoord.w;
+
+	// Noise
+	float3 noiseNormal = (tex2D(noiseMap, (Input.NoiseCoord.xy )).rgb - 0.5).rbg * noiseScale;
+	final += noiseNormal.xz;
+
+	// Fresnel
+	//normal = normalize(Input.Normal + noiseNormal.xz);
+	float fresnel = fresnelBias + fresnelScale * (saturate(pow(1 + dot(Input.EyeDir, Input.Normal), fresnelPower)+0.2));
+
+	// Reflection / refraction
+	float4 reflectionColour = tex2D(reflectMap, final);
+	float4 dirtColour = tex2D(dirtMap, Input.Tex) * Input.Color;
+
+	// Final colour
+	float4 col = lerp(dirtColour, reflectionColour, fresnel);
+	
+	return col;
+}

Added: modules/kanalisation/materials/TotalReflectDirtWaterVertex_hlsl.source
===================================================================
--- modules/kanalisation/materials/TotalReflectDirtWaterVertex_hlsl.source	2008-12-30 22:25:45 UTC (rev 4658)
+++ modules/kanalisation/materials/TotalReflectDirtWaterVertex_hlsl.source	2008-12-31 13:13:10 UTC (rev 4659)
@@ -0,0 +1,143 @@
+//vertex shader
+
+float4x4 worldViewProjMatrix;
+float3 eyePosition; // object space
+float timeVal;
+float scale;  // the amount to scale the noise texture by
+float scroll; // the amount by which to scroll the noise
+float noise;  // the noise perturb as a factor of the  time
+float4 ambient;  //ambient light color
+
+//lights
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
+
+float4 Light3_attenuation;
+float4 Light3_position;
+float4 Light3_color;
+float4 Light3_spec_power;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION;
+   float2 Texcoord : TEXCOORD0;
+   float3 Normal   : NORMAL;   
+};
+
+struct VS_OUTPUT
+{
+	float4 Position		: POSITION;
+	float3 NoiseCoord 	: TEXCOORD0;
+	float4 ProjectionCoord 	: TEXCOORD1;
+	float3 EyeDir 	: TEXCOORD2;
+	float3 Normal 	: TEXCOORD3;
+	float2 Tex    	: TEXCOORD4;
+	float4 Color   	: COLOR;
+};
+
+VS_OUTPUT vs_main(VS_INPUT Input)
+{
+	VS_OUTPUT Output = (VS_OUTPUT) 0;
+	
+	Output.Position = mul(worldViewProjMatrix, Input.Position);
+	
+	
+	//Output color
+	Output.Color = lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+	
+	
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - eyePosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)*saturate(Light1_attenuation.x-Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light3
+   
+   LightDir = Light3_position - Input.Position * Light3_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light3_color * Light3_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light3_attenuation.y +
+                              Light3_attenuation.z * Dist +
+                              Light3_attenuation.w * Dist * Dist)*saturate(Light3_attenuation.x-Dist)
+                          ,0,1);
+   
+   Output.Color += (Light3_color * AngleAttn + SpecAttn) * DistAttn ;
+   
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)*saturate(Light2_attenuation.x-Dist)
+                        ,0,1);
+   
+   Output.Color += (Light2_color * AngleAttn + SpecAttn) * DistAttn ;
+	
+	//end color
+	
+	float4x4 scalemat = float4x4(0.5,   0,   0, 0.5, 
+	                               0,-0.5,   0, 0.5,
+								   0,   0, 0.5, 0.5,
+								   0,   0,   0,   1);
+
+	//output projection coord
+	Output.ProjectionCoord = mul(scalemat, Output.Position);
+	
+	//Noise Texture
+	Output.NoiseCoord.xy = (Input.Texcoord + (timeVal * scroll)) * scale;
+	Output.NoiseCoord.z = noise * timeVal;
+	
+	//Output Eye Dir
+	Output.EyeDir = normalize(Input.Position.xyz - eyePosition);
+	
+	//Output Normale
+	Output.Normal = Input.Normal.rgb; 
+	
+	//Output UV Texture
+	Output.Tex = Input.Texcoord;
+	
+	return Output;
+}
+



From timm at mail.berlios.de  Wed Dec 31 14:21:27 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 31 Dec 2008 14:21:27 +0100
Subject: [Dsa-hl-svn] r4660 - in rl/branches/persistence: common/include
	common/src core core/include core/src rules rules/include
	rules/src script/src script/swig ui
Message-ID: <200812311321.mBVDLR4Y002912@sheep.berlios.de>

Author: timm
Date: 2008-12-31 14:20:41 +0100 (Wed, 31 Dec 2008)
New Revision: 4660

Added:
   rl/branches/persistence/rules/CMakeLists.txt
   rl/branches/persistence/ui/CMakeLists.txt
Modified:
   rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
   rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence/core/CMakeLists.txt
   rl/branches/persistence/core/include/CoreSubsystem.h
   rl/branches/persistence/core/include/GlobalData.h
   rl/branches/persistence/core/include/SaveAble.h
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/include/SaveGameFile.h
   rl/branches/persistence/core/src/CoreSubsystem.cpp
   rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp
   rl/branches/persistence/core/src/GlobalData.cpp
   rl/branches/persistence/core/src/SaveAble.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/core/src/SaveGameFile.cpp
   rl/branches/persistence/rules/include/JournalEntry.h
   rl/branches/persistence/rules/src/JournalEntry.cpp
   rl/branches/persistence/rules/src/QuestBook.cpp
   rl/branches/persistence/script/src/SceneManager.cpp
   rl/branches/persistence/script/swig/RlRules.swig
Log:
- merged from trunk
- first try saving files
- process on persistence

Guten Rutsch!!!

Modified: rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -14,6 +14,8 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
+#ifndef __RlWriteableDataStreamFormatTarget_H_
+#define __RlWriteableDataStreamFormatTarget_H_
 
 #include <xercesc/framework/XMLFormatter.hpp>
 #include "WriteableDataStream.h"
@@ -29,4 +31,6 @@
     protected:
         WriteableDataStreamPtr mStream;
     };
-}
\ No newline at end of file
+}
+
+#endif

Modified: rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -27,7 +27,7 @@
 
     void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)
     {
-        if(static_cast<WriteableDataStream*>(mStream.get()))
+        if(dynamic_cast<WriteableDataStream*>(mStream.get()))
         {
             mStream->write((char*)toWrite, count);
         }
@@ -37,7 +37,7 @@
 
     void WriteableDataStreamFormatTarget::flush ()
     {
-        if(static_cast<WriteableDataStream*>(mStream.get()))
+        if(dynamic_cast<WriteableDataStream*>(mStream.get()))
         {
             mStream->flush();
         }

Modified: rl/branches/persistence/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence/core/CMakeLists.txt	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/CMakeLists.txt	2008-12-31 13:20:41 UTC (rev 4660)
@@ -1,9 +1,12 @@
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}/include
+${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
-${OGRENEWT_INCLUDE_DIRS})
+${OGRENEWT_INCLUDE_DIR}
+${MESHMAGICK_INCLUDE_DIR}
+${RUBY_INCLUDE_PATH})
 
 SET(RlCore_LIB_SRCS
 src/Actor.cpp
@@ -86,7 +89,7 @@
 
 ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
 
-#TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES})
+TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCore PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}

Modified: rl/branches/persistence/core/include/CoreSubsystem.h
===================================================================
--- rl/branches/persistence/core/include/CoreSubsystem.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/CoreSubsystem.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -43,6 +43,7 @@
 class SoundManager;
 class DebugVisualsManager;
 class SaveGameManager;
+class SaveAbleManager;
 class SaveAbleSerializer;
 class JobScheduler;
 class ZoneManager;
@@ -141,6 +142,7 @@
     SoundManager* mSoundManager;
     DebugVisualsManager* mDebugVisualsManager;
     SaveGameManager* mSaveGameManager;
+    SaveAbleManager* mSaveAbleManager;
 	SaveAbleSerializer* mSaveAbleSerializer;
     JobScheduler* mJobScheduler;
 	ZoneManager* mZoneManager;

Modified: rl/branches/persistence/core/include/GlobalData.h
===================================================================
--- rl/branches/persistence/core/include/GlobalData.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/GlobalData.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -14,24 +14,24 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-#ifndef __GLOBALDATA_H__
-#define __GLOBALDATA_H__
-
-#include "SaveAbleCollection.h"
-
-namespace rl
-{
-    class GlobalData : public SaveAbleCollection
-    {
-    public:
-        GlobalData(const CeGuiString &id);
-        virtual ~GlobalData();
+#ifndef __GLOBALDATA_H__
+#define __GLOBALDATA_H__
+
+#include "SaveAbleCollection.h"
+
+namespace rl
+{
+    class GlobalData : public SaveAbleCollection
+    {
+    public:
+        GlobalData(const CeGuiString &id);
+        virtual ~GlobalData();
         virtual void attachSaveAble(SaveAblePtr saveAble);
 		virtual void deattachSaveAble(SaveAblePtr saveAble);
 		virtual void deattachSaveAble(const CeGuiString &id);
-		virtual void deattachAllSaveAbles();
-    };
-}
-
-
+		virtual void deattachAllSaveAbles();
+    };
+}
+
+
 #endif
\ No newline at end of file

Modified: rl/branches/persistence/core/include/SaveAble.h
===================================================================
--- rl/branches/persistence/core/include/SaveAble.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/SaveAble.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -57,4 +57,5 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
+

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -14,6 +14,9 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#ifndef __RlSaveAbleCollection_H_
+#define __RlSaveAbleCollection_H_
+
 #include "CorePrerequisites.h"
 #include "SaveAble.h"
 
@@ -37,4 +40,7 @@
 		CeGuiString mId;
 	};
 
-}
\ No newline at end of file
+}
+
+#endif
+

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -55,4 +55,5 @@
 	};
 }
 
-#endif
\ No newline at end of file
+#endif
+

Modified: rl/branches/persistence/core/include/SaveGameFile.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameFile.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/include/SaveGameFile.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -46,7 +46,7 @@
 		int getId() const;
 
         //access to file
-        WriteableDataStreamPtr &getDataStream();
+        WriteableDataStreamPtr getDataStream() const;
         XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
         void deleteFileFromStorage(); //erwuenscht?
 

Modified: rl/branches/persistence/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -101,6 +101,7 @@
         delete mRubyInterpreter;
         delete mTimeSourceManager;
         delete mSaveGameManager;
+        delete mSaveAbleManager;
 		delete mSaveAbleSerializer;
         delete mGameLoop;
         //mXmlResourceManager->unloadAll();
@@ -247,6 +248,8 @@
         mSaveGameManager = new SaveGameManager();
         LOG_MESSAGE(Logger::RULES, "SaveGameManager erzeugt");
 
+        mSaveAbleManager = new SaveAbleManager();
+
 		mSaveAbleSerializer = new SaveAbleSerializer();
         LOG_MESSAGE(Logger::RULES, "SaveAbleSerializer erzeugt");
 		

Modified: rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -64,7 +64,6 @@
 
 			// Schwarzer Hintergrund
 			newVp->setBackgroundColour(ColourValue(0,0,0));
-
 		}
     }
 

Modified: rl/branches/persistence/core/src/GlobalData.cpp
===================================================================
--- rl/branches/persistence/core/src/GlobalData.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/GlobalData.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -18,17 +18,17 @@
 
 #include "GlobalData.h"
 
-namespace rl
-{
-    GlobalData::GlobalData(const CeGuiString &id) : SaveAbleCollection(id)
-    {
-    }
-
-    GlobalData::~GlobalData()
-    {
-        deattachAllSaveAbles();
-    }
-
+namespace rl
+{
+    GlobalData::GlobalData(const CeGuiString &id) : SaveAbleCollection(id)
+    {
+    }
+
+    GlobalData::~GlobalData()
+    {
+        deattachAllSaveAbles();
+    }
+
     void GlobalData::attachSaveAble(SaveAblePtr saveAble)
     {
         SaveAbleMap::const_iterator iter;

Modified: rl/branches/persistence/core/src/SaveAble.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAble.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/SaveAble.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -59,4 +59,5 @@
 	{
 		return mId;
 	}
-}
\ No newline at end of file
+}
+

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -24,6 +24,7 @@
 {
 	void SaveAbleManager::saveState()
 	{
+        storeSaveAbleStates();
 	}
 
 	void SaveAbleManager::addSaveAble(SaveAblePtr save, const CeGuiString &collectionId)

Modified: rl/branches/persistence/core/src/SaveGameFile.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -57,7 +57,7 @@
         return mSaveGameId;
     }
 
-    WriteableDataStreamPtr &SaveGameFile::getDataStream()
+    WriteableDataStreamPtr SaveGameFile::getDataStream() const
     {
 		return mStream;
     }

Copied: rl/branches/persistence/rules/CMakeLists.txt (from rev 4658, rl/trunk/engine/rules/CMakeLists.txt)

Modified: rl/branches/persistence/rules/include/JournalEntry.h
===================================================================
--- rl/branches/persistence/rules/include/JournalEntry.h	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/rules/include/JournalEntry.h	2008-12-31 13:20:41 UTC (rev 4660)
@@ -19,6 +19,7 @@
 
 #include "RulesPrerequisites.h"
 #include "EventObject.h"
+#include "SaveAble.h"
 
 namespace rl {
 
@@ -29,13 +30,13 @@
     * @todo Mit Zeitstempel versehen
     * @todo Mit Quest verkn?pfbar machen
     */
-    class _RlRulesExport JournalEntry
+    class _RlRulesExport JournalEntry : public SaveAble
     {
     public:
         static const Ogre::String PROPERTY_TEXT;
         static const Ogre::String PROPERTY_CAPTION;
 
-        JournalEntry(const CeGuiString caption, const CeGuiString text);
+        JournalEntry(const CeGuiString &id, const CeGuiString &caption, const CeGuiString &text);
         virtual ~JournalEntry();
 
         CeGuiString getCaption() const;

Modified: rl/branches/persistence/rules/src/JournalEntry.cpp
===================================================================
--- rl/branches/persistence/rules/src/JournalEntry.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/rules/src/JournalEntry.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -23,8 +23,8 @@
     const Ogre::String JournalEntry::PROPERTY_TEXT = "text";
     const Ogre::String JournalEntry::PROPERTY_CAPTION = "caption";
 
-    JournalEntry::JournalEntry(const CeGuiString caption, const CeGuiString text)
-        : mCaption(caption), mText(text)
+    JournalEntry::JournalEntry(const CeGuiString &id, const CeGuiString &caption, const CeGuiString &text)
+        : mCaption(caption), mText(text), SaveAble(id)
     {
     }
 

Modified: rl/branches/persistence/rules/src/QuestBook.cpp
===================================================================
--- rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -163,7 +163,7 @@
 
     void QuestBook::addJournalEntry(CeGuiString caption, CeGuiString text)
     {
-        addJournalEntry(new JournalEntry(caption, text));
+        addJournalEntry(new JournalEntry(caption, caption, text));
     }
 
     unsigned int QuestBook::getNumJournalEntries() const

Modified: rl/branches/persistence/script/src/SceneManager.cpp
===================================================================
--- rl/branches/persistence/script/src/SceneManager.cpp	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/script/src/SceneManager.cpp	2008-12-31 13:20:41 UTC (rev 4660)
@@ -23,6 +23,7 @@
 #include "PartyManager.h"
 #include "Scene.h"
 #include "SceneLoader.h"
+#include "SaveAbleManager.h"
 
 template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
 
@@ -60,6 +61,8 @@
             return;
         }
 
+        SaveAbleManager::getSingleton().saveState();
+
         Creature* activeChar = PartyManager::getSingleton().getActiveCharacter();
 
         if (activeChar) {
@@ -68,7 +71,7 @@
             activeChar->setState(GOS_LOADED);
         }
 
-        if (saveCurrent) 
+        if (saveCurrent && mCurrentScene) 
         {
             mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
         }

Modified: rl/branches/persistence/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence/script/swig/RlRules.swig	2008-12-31 13:13:10 UTC (rev 4659)
+++ rl/branches/persistence/script/swig/RlRules.swig	2008-12-31 13:20:41 UTC (rev 4660)
@@ -180,7 +180,7 @@
     class JournalEntry
     {
     public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        JournalEntry(const rl::CeGuiString &id, const rl::CeGuiString &caption, const rl::CeGuiString &text);
         virtual ~JournalEntry();
 
         rl::CeGuiString getCaption() const;

Copied: rl/branches/persistence/ui/CMakeLists.txt (from rev 4658, rl/trunk/engine/ui/CMakeLists.txt)



