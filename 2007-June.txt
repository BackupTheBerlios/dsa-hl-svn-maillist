From blakharaz at mail.berlios.de  Sat Jun  2 15:53:53 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 15:53:53 +0200
Subject: [Dsa-hl-svn] r3490 - rl/trunk/engine/script/swig
Message-ID: <200706021353.l52DrrKJ023569@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 15:53:46 +0200 (Sat, 02 Jun 2007)
New Revision: 3490

Modified:
   rl/trunk/engine/script/swig/TypeRlProperty.swig
Log:
Typemap for map properties (otherwise these won't work on director game object classes)


Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-05-30 21:31:44 UTC (rev 3489)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-06-02 13:53:46 UTC (rev 3490)
@@ -80,6 +80,20 @@
 			}
         }
     }
+    else if (TYPE(input) == T_HASH)
+    {
+        PropertyMap pmap;
+        VALUE keys = rb_funcall(input,rb_intern("keys"),0);
+        unsigned int size = RARRAY_LEN(keys);
+        for (unsigned int i=0; i<size; i++) 
+        {
+            VALUE key = RARRAY_PTR(keys)[i];
+            VALUE val = rb_hash_aref(input, key);
+            pmap[rl::CeGuiString(StringValuePtr(key))] 
+                = rl::convertValueToProperty(val);
+        }
+        rval.setValue(pmap);
+    }
     
     return rval;
 }
@@ -140,6 +154,20 @@
 		}
 		return rval;
     }
+    else if (input.isMap())
+    {
+        PropertyMap pmap = input.toMap();
+        VALUE rval = rb_hash_new();
+        for (PropertyMap::const_iterator it = pmap.begin(); 
+            it != pmap.end(); ++it) 
+        {
+            rb_hash_aset(
+                rval,
+                rb_str_buf_new2(it->first.c_str()),
+                rl::convertPropertyToValue(it->second));
+        }
+        return rval;
+    }
 
     return Qnil;
 }
@@ -155,7 +183,8 @@
 	    || TYPE($input) == T_STRING
 	    || TYPE($input) == T_TRUE 
 	    || TYPE($input) == T_FALSE
-	    || TYPE($input == T_ARRAY) 
+	    || TYPE($input) == T_HASH
+	    || TYPE($input) == T_ARRAY) 
     {
         return 1;
     }



From blakharaz at mail.berlios.de  Sat Jun  2 15:56:29 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 15:56:29 +0200
Subject: [Dsa-hl-svn] r3491 - in rl/trunk/engine: core/include core/src
	rules/src
Message-ID: <200706021356.l52DuTA4023784@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 15:56:06 +0200 (Sat, 02 Jun 2007)
New Revision: 3491

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/rules/src/Slot.cpp
Log:
Update physics proxy after merging


Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-06-02 13:53:46 UTC (rev 3490)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-06-02 13:56:06 UTC (rev 3491)
@@ -126,6 +126,7 @@
         void setMass(Ogre::Real mass);
 
 		void createPhysicsProxy(Ogre::SceneNode* node);
+        void updatePhysicsProxy();
 
         /** Called to update the collision of the physical thing, in order to adapt
          *  to a new animation state.
@@ -211,6 +212,8 @@
 		 */
 		GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
+
+        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia) const;
 	};
 }
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-02 13:53:46 UTC (rev 3490)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-02 13:56:06 UTC (rev 3491)
@@ -377,38 +377,9 @@
 	{
 		if (mBody == NULL) 
 		{
-            OgreNewt::CollisionPtr coll;
             Vector3 inertia;
+            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);
 
-            // there is a difference between a meshobject and a 'normal' object
-            // because a meshobject has got a mesh entity and therefore a it is
-            // likely that there will be more than one object with those collision 
-            // primitives, so they need to get cached.
-
-            if (mPhysicalObject->isMeshObject())
-            {
-                Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
-                coll = PhysicsManager::getSingleton().createCollision(
-                    entity,
-                    mGeometryType,
-                    "",
-                    NULL,
-                    NULL,
-                    mMass,
-                    &inertia);
-            }
-            else
-            {
-                const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
-                coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
-                    aabb,
-                    mGeometryType,
-                    NULL,
-                    NULL,
-                    mMass,
-                    &inertia);
-            }
-
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
 
@@ -424,6 +395,59 @@
         }
 	}
 
+    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3& inertia) const
+    {
+        OgreNewt::CollisionPtr coll;
+
+        // there is a difference between a meshobject and a 'normal' object
+        // because a meshobject has got a mesh entity and therefore a it is
+        // likely that there will be more than one object with those collision 
+        // primitives, so they need to get cached.
+
+        if (mPhysicalObject->isMeshObject())
+        {
+            Entity* entity = static_cast<MeshObject*>(mPhysicalObject)->getEntity();
+            coll = PhysicsManager::getSingleton().createCollision(
+                entity,
+                mGeometryType,
+                "",
+                NULL,
+                NULL,
+                mMass,
+                &inertia);
+        }
+        else
+        {
+            const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
+            coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
+                aabb,
+                mGeometryType,
+                NULL,
+                NULL,
+                mMass,
+                &inertia);
+        }
+
+        return coll;
+    }
+
+    void PhysicalThing::updatePhysicsProxy()
+    {
+        if (mBody)
+        {
+            mPoseCollisions.clear();
+
+            Vector3 inertia;
+            
+            // update the collision
+		    mBody->setCollision(createCollision(mPhysicalObject, inertia));
+		    if (mMass > 0.0 && mGeometryType != GT_MESH)
+            {
+                mBody->setMassMatrix(mMass, inertia);
+            }
+        }
+    }
+
     PhysicsController* PhysicalThing::getPhysicsController() const
     {
         return mPhysicsController;

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-06-02 13:53:46 UTC (rev 3490)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-06-02 13:56:06 UTC (rev 3491)
@@ -20,6 +20,7 @@
 #include "Item.h"
 #include "MeshObject.h"
 #include "MergeableMeshObject.h"
+#include "PhysicalThing.h"
 
 namespace rl {
 
@@ -118,6 +119,12 @@
 					}
 				}
 			}
+
+            if (mOwner->getActor() 
+                && mOwner->getActor()->getPhysicalThing())
+            {
+                mOwner->getActor()->getPhysicalThing()->updatePhysicsProxy();
+            }
 		}
     }
 } // namespace rl



From blakharaz at mail.berlios.de  Sat Jun  2 16:02:41 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 16:02:41 +0200
Subject: [Dsa-hl-svn] r3492 - in rl/trunk/engine: core/include core/src
	script/swig
Message-ID: <200706021402.l52E2fWe024534@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 16:02:38 +0200 (Sat, 02 Jun 2007)
New Revision: 3492

Modified:
   rl/trunk/engine/core/include/Actor.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/script/swig/RlCore.swig
Log:
Merge Actors directly (base actor has to be mergeable)


Modified: rl/trunk/engine/core/include/Actor.h
===================================================================
--- rl/trunk/engine/core/include/Actor.h	2007-06-02 13:56:06 UTC (rev 3491)
+++ rl/trunk/engine/core/include/Actor.h	2007-06-02 14:02:38 UTC (rev 3492)
@@ -242,8 +242,10 @@
         void detach(Actor* actor);
 
         /// Entfernt alle Kinder vom Node
-        void detachAllChildren( );
+        void detachAllChildren();
 
+        void merge(Actor* actor, const Ogre::String& slot);
+
         /**
          * Entfernt den Aktor von seinem Elternaktor
          */

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2007-06-02 13:56:06 UTC (rev 3491)
+++ rl/trunk/engine/core/src/Actor.cpp	2007-06-02 14:02:38 UTC (rev 3492)
@@ -22,6 +22,7 @@
 #include "CoreSubsystem.h"
 #include "Exception.h"
 #include "GameEventManager.h"
+#include "MergeableMeshObject.h"
 #include "MeshObject.h"
 #include "MovableText.h"
 #include "PhysicalThing.h"
@@ -857,4 +858,37 @@
     {
         return mSceneNode != NULL || mBone != NULL;
     }
+
+    void Actor::merge(Actor* actor, const Ogre::String& slot)
+    {
+        if (!getControlledObject()
+            || !getControlledObject()->isMeshObject()
+            || (actor
+                && (!actor->getControlledObject()
+                    || !actor->getControlledObject()->isMeshObject())))
+        {
+            LOG_ERROR(Logger::CORE, "Both actors must have a meshobject");
+            return;
+        }
+
+        MergeableMeshObject* baseMmo = dynamic_cast<MergeableMeshObject*>(mActorControlledObject);
+        if (!baseMmo)
+        {
+            LOG_ERROR(Logger::CORE, "Current actor '"+mName+"' is not mergeable.");
+        }
+
+        if (actor != NULL)
+        {
+            MeshObject* moToAdd = dynamic_cast<MeshObject*>(actor->getControlledObject());
+            actor->removeFromScene();
+            baseMmo->replaceSubmesh(slot, moToAdd->getMeshName());
+        }
+        else
+        {
+            baseMmo->removeSubmesh(slot);
+            ///@todo: Place removed child into scene
+        }
+
+        mPhysicalThing->updatePhysicsProxy();
+    }
 }

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-06-02 13:56:06 UTC (rev 3491)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-06-02 14:02:38 UTC (rev 3492)
@@ -551,7 +551,9 @@
             const Ogre::Radian& offsetRotation=Ogre::Radian(0) );
                     
     void detach(rl::Actor* actor);
-    
+
+    void merge(Actor* actor, const Ogre::String& slot);
+
     rl::Actor* getChildByName(const Ogre::String& name ) const;
     
     void setVisible( bool vis, bool cascade = true );



From blakharaz at mail.berlios.de  Sat Jun  2 16:03:25 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 16:03:25 +0200
Subject: [Dsa-hl-svn] r3493 - rl/trunk/engine/script/swig
Message-ID: <200706021403.l52E3PnC024572@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 16:03:20 +0200 (Sat, 02 Jun 2007)
New Revision: 3493

Modified:
   rl/trunk/engine/script/swig/RlRules.swig
Log:
remove swig warnings


Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-06-02 14:02:38 UTC (rev 3492)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-06-02 14:03:20 UTC (rev 3493)
@@ -731,7 +731,7 @@
         rl::TimerEventSource* getSource() const;
     };
     
-    class MovingCreature : public PhysicsController, PhysicsGenericContactCallback
+    class MovingCreature
     {
     public:
         MovingCreature(Creature *character); 



From blakharaz at mail.berlios.de  Sat Jun  2 16:07:08 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 16:07:08 +0200
Subject: [Dsa-hl-svn] r3494 - in modules/regressiontest: dsa maps scripts
	scripts/maps
Message-ID: <200706021407.l52E78Id024809@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 16:07:03 +0200 (Sat, 02 Jun 2007)
New Revision: 3494

Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/dsa/mapmeshparttest.gof
   modules/regressiontest/maps/regressiontest.scene
   modules/regressiontest/scripts/MergeableMeshTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/regressiontest/scripts/mckhero.rb
Log:
Test for construction kit hero
Added tests for physics proxy update on construction kit objects

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-02 14:07:03 UTC (rev 3494)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
-    <gameobjectclass classid="mckhero" baseclass="MCKHero">
-		<property name="geometrytype" type="STRING" data="ellipsoid" />
-		<property name="mass" type="REAL" data="75"/>
-		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
+        <property name="geometrytype" type="STRING" data="ellipsoid" />
+        <property name="mass" type="REAL" data="75"/>
+        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
         <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="meshparts" type="MAP">
             <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
@@ -14,16 +15,16 @@
             <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
             <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
         </property>
-	</gameobjectclass>
+    </gameobjectclass>
 
     <gameobjectclass classid="Holzscheit" baseclass="GameObject">
-        <property name="name" type="STRING" data="Holzscheit"/>        
+        <property name="name" type="STRING" data="Holzscheit"/>
         <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>
         <property name="meshfile" type="STRING" data="ver_holzscheit_01.mesh"/>
     </gameobjectclass>
 
     <gameobjectclass classid="apple" baseclass="GameObject">
-        <property name="name" type="STRING" data="Apfel"/>        
+        <property name="name" type="STRING" data="Apfel"/>
         <property name="description" type="STRING" data="Ein Apfel?"/>
         <property name="meshfile" type="STRING" data="sphere.1m.mesh"/>
         <property name="geometrytype" type="STRING" data="ellipsoid"/>
@@ -67,21 +68,21 @@
         <property name="name" type="STRING" data="Kurzschwert"/>
         <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
         <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
-		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
-		<property name="mass" type="REAL" data="3.0"/>
-		<property name="size" type="INTPAIR" data="2,4"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,4"/>
     </gameobjectclass>
 
     <gameobjectclass classid="leather backpack" baseclass="Container">
         <property name="name" type="STRING" data="Rucksack"/>
         <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
         <property name="meshfile" type="STRING" data="ins_rucksack.mesh"/>
-		<property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
         <property name="capacity" type="REAL" data="20.0"/>
         <property name="volume" type="INTPAIR" data="8,6"/>
         <property name="size" type="INTPAIR" data="2,2"/>
         <property name="actions" type="ARRAY">
-        	<property type="STRING" data="showcontainercontent"/>
+        <property type="STRING" data="showcontainercontent"/>
         </property>
         <property name="defaultaction" type="STRING" data="showcontainercontent"/>
     </gameobjectclass>
@@ -100,7 +101,7 @@
         <property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
         <property name="geometrytype" type="STRING" data="box"/>
     </gameobjectclass>
-    
+
     <!-- EffectTest -->
     <gameobjectclass classid="EffectTest" baseclass="GameObject">
         <property name="name" type="STRING" data="Bottich der Versteinerung"/>

Modified: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-06-02 14:07:03 UTC (rev 3494)
@@ -5,6 +5,7 @@
         <property name="name" type="STRING" data="M.C.K. Test object"/>
         <property name="description" type="STRING" data="This is the testing object for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="meshparts" type="MAP">
             <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
@@ -19,6 +20,7 @@
         <property name="name" type="STRING" data="M.C.K. Test creature"/>
         <property name="description" type="STRING" data="This is the testing creature for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="meshparts" type="MAP">
             <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
@@ -33,12 +35,14 @@
         <property name="name" type="STRING" data="M.C.K. Test item I"/>
         <property name="description" type="STRING" data="This is the 1st testing item for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_armor_garethplatte.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
     </gameobjectclass>
 
     <gameobjectclass classid="mesh construction kit test item 2" baseclass="Item">
         <property name="name" type="STRING" data="M.C.K. Test item II"/>
         <property name="description" type="STRING" data="This is the 2nd testing item for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_armor_kroetenhaut.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
     </gameobjectclass>
 
 </GameObjectDefinitions>

Modified: modules/regressiontest/maps/regressiontest.scene
===================================================================
--- modules/regressiontest/maps/regressiontest.scene	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/maps/regressiontest.scene	2007-06-02 14:07:03 UTC (rev 3494)
@@ -5,8 +5,10 @@
             <scale x="1.0" y="1.0" z="1.0" />
         </entity>
         <gameobject class="hero" id="1" state="IN_SCENE">
-			<position x="0" y="0.0" z="0"/>
-		</gameobject>
-        
+            <position x="0" y="0.0" z="0"/>
+        </gameobject>
+        <gameobject class="mckhero" id="10" state="IN_SCENE">
+            <position x="2" y="0.0" z="0"/>
+        </gameobject>
     </nodes>
 </scene>

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-02 14:07:03 UTC (rev 3494)
@@ -6,13 +6,20 @@
 
         $SCRIPT.log(">MergeableMeshTest Start");
 
+        testMergeableActor();
+        testMergeableSlots();
+
+        $SCRIPT.log(">MergeableMeshTest End");
+    end
+
+    def testMergeableSlots()
         test_obj1 = $GOM.createGameObject("mesh construction kit test object")
-        test_obj1.setPosition(center)
+        test_obj1.setPosition(rel_pos([1, 0, 0]))
         test_obj1.placeIntoScene();
 
 
         test_obj2 = $GOM.createGameObject("mesh construction kit test creature")
-        test_obj2.setPosition(rel_pos([1, 0, 0]))
+        test_obj2.setPosition(rel_pos([2, 0, 0]))
         test_obj2.placeIntoScene();
 #        test_obj2.getActor().getControlledObject().startAnimation("Walk")
         test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
@@ -22,7 +29,7 @@
         test_obj2.getInventory().hold(test_item2, "Armor")
 
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
-        test_obj3.setPosition(rel_pos([2, 0, 0]))
+        test_obj3.setPosition(rel_pos([3, 0, 0]))
         test_obj3.placeIntoScene();
         test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
@@ -32,7 +39,7 @@
         test_obj3.getActor().getControlledObject().startAnimation("Walk")
 
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
-        test_obj4.setPosition(rel_pos([3, 0, 0]))
+        test_obj4.setPosition(rel_pos([4, 0, 0]))
         test_obj4.placeIntoScene();
         test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
@@ -48,7 +55,39 @@
         test_obj3.getInventory().hold(sword3, "Right Hand");
         sword4 = $GOM.createGameObject("shortsword");
         test_obj4.getInventory().hold(sword4, "Right Hand");
+    end
 
-        $SCRIPT.log(">MergeableMeshTest End");
+    def testMergeableActor()
+      baseActor1 = $AM.createMeshActor("", "men_human_female_torso.mesh", GT_ELLIPSOID, 75, true)
+      baseActor1.getControlledObject().setBaseMeshPart("torso")
+      actorToAdd11 = $AM.createMeshActor("", "men_human_female_head_02.mesh")
+      actorToAdd12 = $AM.createMeshActor("", "men_human_female_leg_pants_01_long.mesh")
+      actorToAdd13 = $AM.createMeshActor("", "men_human_female_armor_kroetenhaut.mesh")
+      actorToAdd14 = $AM.createMeshActor("", "men_human_female_feet_boots_01.mesh")
+      baseActor1.merge(actorToAdd11, "head")
+      baseActor1.merge(actorToAdd12, "legs")
+      baseActor1.merge(actorToAdd13, "armor")
+      baseActor1.merge(actorToAdd14, "feet")
+      baseActor1.placeIntoScene(rel_pos([1, 0, 2]))
+
+      baseActor2 = $AM.createMeshActor("", "men_human_female_torso.mesh", GT_ELLIPSOID, 75, true)
+      baseActor2.getControlledObject().setBaseMeshPart("torso")
+      actorToAdd2 = $AM.createMeshActor("", "men_human_female_head_02.mesh")
+      actorToAdd2.placeIntoScene(rel_pos([2.5, 0, 2]))
+      baseActor2.merge(actorToAdd2, "head")
+      baseActor2.placeIntoScene(rel_pos([2, 0, 2]))
+
+      baseActor3 = $AM.createMeshActor("", "men_human_female_torso.mesh", GT_ELLIPSOID, 75, true)
+      baseActor3.getControlledObject().setBaseMeshPart("torso")
+      baseActor3.placeIntoScene(rel_pos([3, 0, 2]))
+      actorToAdd3 = $AM.createMeshActor("", "men_human_female_head_02.mesh")
+      baseActor3.merge(actorToAdd3, "head")
+
+      baseActor4 = $AM.createMeshActor("", "men_human_female_torso.mesh", GT_ELLIPSOID, 75, true)
+      baseActor4.getControlledObject().setBaseMeshPart("torso")
+      baseActor4.placeIntoScene(rel_pos([4, 0, 2]))
+      actorToAdd4 = $AM.createMeshActor("", "men_human_female_head_02.mesh")
+      actorToAdd2.placeIntoScene(rel_pos([4.5, 0, 2]))
+      baseActor4.merge(actorToAdd4, "head")
     end
 end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-02 14:07:03 UTC (rev 3494)
@@ -23,7 +23,8 @@
 $SCRIPT.log("init map 'regressiontest'...")
 
 $SCRIPT.log("Prepare hero for being the active character")
-$hero = $GOM.getGameObject(1);
+#$hero = $GOM.getGameObject(1); # single mesh hero
+$hero = $GOM.getGameObject(10); # construction kit hero
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")

Modified: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-06-02 14:03:20 UTC (rev 3493)
+++ modules/regressiontest/scripts/mckhero.rb	2007-06-02 14:07:03 UTC (rev 3494)
@@ -4,9 +4,9 @@
     def initialize(id)
         super(id);
         addQueryFlag(RlScript::QUERYFLAG_PLAYER)
-		    setName("Alrike");
-		    setDescription("Heldin von Berufung");
-		    $SCRIPT.log("Gute Eigenschaften zuweisen...");
+	setName("Alrike");
+	setDescription("Heldin von Berufung");
+	$SCRIPT.log("Gute Eigenschaften zuweisen...");
 
         setEigenschaft("MU", 12);
         setEigenschaft("KL", 8);
@@ -16,33 +16,30 @@
         setEigenschaft("GE", 12);
         setEigenschaft("KO", 13); #KO
         setEigenschaft("KK", 14); #KK
-		setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
+	setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
 
-		$SCRIPT.log("LeP und AuP auff?llen");
+	$SCRIPT.log("LeP und AuP auff?llen");
         modifyLe(1000, false); # LeP = LE
         modifyAu(1000); # Au = voll
         #modifyLe(-20); # 10 LeP abziehen
 
-		$SCRIPT.log("Talente hinzuf?gen");
-		addTalent("Athletik", 3);
-		#addTalent("K?rperbeherrschung", 3);
+	$SCRIPT.log("Talente hinzuf?gen");
+	addTalent("Athletik", 3);
+	#addTalent("K?rperbeherrschung", 3);
 
         $SCRIPT.log("Heldenaktor beschreiben...");
-        setProperty("meshfile", "men_alrike.mesh")
-		setProperty("physicsbody", PhysicsManager::GT_ELLIPSOID)
-		setProperty("mass", 75.0);
-	
-		$SCRIPT.log("Inventar konfigurieren.");
-		inv = getInventory();
-		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
-		inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
-		inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
-		inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-		inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
-    inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
 
-		#addSounds()
+	$SCRIPT.log("Inventar konfigurieren.");
+	inv = getInventory();
+	inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
+	inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
+	inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+	inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
+        inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
+
+	#addSounds()
         $SCRIPT.log("done.");
     end
 
@@ -51,7 +48,7 @@
         soundActor = $AM.createSoundSampleActor(heroActor.getName()+"_schlucken","schlucken.ogg");
         heroActor.attachToSlot(soundActor, "huefte");
         @mSchmerzSchreiSound = $AM.createSoundSampleActor("SchmerzSchreiSound","schmerz_schrei_au_01.ogg");
-        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte"); 
+        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte");
     end
 
 end



From blakharaz at mail.berlios.de  Sat Jun  2 17:42:23 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 2 Jun 2007 17:42:23 +0200
Subject: [Dsa-hl-svn] r3495 - in modules/ruchin: dsa scripts scripts/maps
Message-ID: <200706021542.l52FgN1f031253@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-02 17:42:19 +0200 (Sat, 02 Jun 2007)
New Revision: 3495

Added:
   modules/ruchin/dsa/mckherotest.gof
   modules/ruchin/scripts/mckhero.rb
Modified:
   modules/ruchin/scripts/maps/maptest.rb
Log:
Test construction kit hero in ruchin

Added: modules/ruchin/dsa/mckherotest.gof
===================================================================
--- modules/ruchin/dsa/mckherotest.gof	2007-06-02 14:07:03 UTC (rev 3494)
+++ modules/ruchin/dsa/mckherotest.gof	2007-06-02 15:42:19 UTC (rev 3495)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
+        <property name="geometrytype" type="STRING" data="ellipsoid" />
+        <property name="mass" type="REAL" data="75"/>
+        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
+        </property>
+    </gameobjectclass>
+    
+</GameObjectDefinitions>
\ No newline at end of file

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2007-06-02 14:07:03 UTC (rev 3494)
+++ modules/ruchin/scripts/maps/maptest.rb	2007-06-02 15:42:19 UTC (rev 3495)
@@ -2,6 +2,7 @@
 $World = $CORE.getWorld()
 require 'player.rb'
 require 'hero.rb'
+require 'mckhero.rb'
 require 'door.rb'
 
 # Physik aktivieren
@@ -35,7 +36,8 @@
 
 
 $SCRIPT.log("Create hero")
-$hero = $GOM.createGameObject("hero", 1);
+#$hero = $GOM.createGameObject("hero", 1);
+$hero = $GOM.createGameObject("mckhero", 1);
 
 $SCRIPT.log("Place hero into scene")
 $hero.placeIntoScene();

Added: modules/ruchin/scripts/mckhero.rb
===================================================================
--- modules/ruchin/scripts/mckhero.rb	2007-06-02 14:07:03 UTC (rev 3494)
+++ modules/ruchin/scripts/mckhero.rb	2007-06-02 15:42:19 UTC (rev 3495)
@@ -0,0 +1,55 @@
+load "embed.rb"
+
+class MCKHero < Person
+    def initialize(id)
+        super(id);
+        addQueryFlag(RlScript::QUERYFLAG_PLAYER)
+	setName("Alrike");
+	setDescription("Heldin von Berufung");
+	$SCRIPT.log("Gute Eigenschaften zuweisen...");
+
+        setEigenschaft("MU", 12);
+        setEigenschaft("KL", 8);
+        setEigenschaft("IN", 9);
+        setEigenschaft("CH", 10);
+        setEigenschaft("FF", 11);
+        setEigenschaft("GE", 12);
+        setEigenschaft("KO", 13); #KO
+        setEigenschaft("KK", 14); #KK
+	setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
+
+	$SCRIPT.log("LeP und AuP auff?llen");
+        modifyLe(1000, false); # LeP = LE
+        modifyAu(1000); # Au = voll
+        #modifyLe(-20); # 10 LeP abziehen
+
+	$SCRIPT.log("Talente hinzuf?gen");
+	addTalent("Athletik", 3);
+	#addTalent("K?rperbeherrschung", 3);
+
+        $SCRIPT.log("Heldenaktor beschreiben...");
+
+	$SCRIPT.log("Inventar konfigurieren.");
+	inv = getInventory();
+	inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
+	inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
+	inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+	inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
+        inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
+
+	#addSounds()
+        $SCRIPT.log("done.");
+    end
+
+    def addSounds
+        heroActor = getActor()
+        soundActor = $AM.createSoundSampleActor(heroActor.getName()+"_schlucken","schlucken.ogg");
+        heroActor.attachToSlot(soundActor, "huefte");
+        @mSchmerzSchreiSound = $AM.createSoundSampleActor("SchmerzSchreiSound","schmerz_schrei_au_01.ogg");
+        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte");
+    end
+
+end
+



From melven at mail.berlios.de  Sun Jun  3 21:59:26 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 3 Jun 2007 21:59:26 +0200
Subject: [Dsa-hl-svn] r3496 - rl/trunk/engine/rules/src
Message-ID: <200706031959.l53JxQ0n009065@sheep.berlios.de>

Author: melven
Date: 2007-06-03 21:59:10 +0200 (Sun, 03 Jun 2007)
New Revision: 3496

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
Fixed bug: problems with rotation

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-02 15:42:19 UTC (rev 3495)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-03 19:59:10 UTC (rev 3496)
@@ -27,6 +27,7 @@
 
 
 
+
 using namespace Ogre;
 using namespace std;
 
@@ -83,9 +84,8 @@
             mVelocity = direction * velocity;
             applyAuChanges(elapsedTime);
             setAnimation(elapsedTime);
-            if( rotation != Vector3::ZERO )
-                if( getRotationMovement()->isPossible() )
-                    return getRotationMovement()->run(elapsedTime, direction, rotation);
+            if( getRotationMovement()->isPossible() )
+                return getRotationMovement()->run(elapsedTime, direction, rotation);
             return false;
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
@@ -151,7 +151,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR;// &&
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
@@ -169,7 +169,9 @@
             OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
             body->getMassMatrix(mass, inertia);
 
-            Quaternion orientation = mMovingCreature->getCreature()->getActor()->getWorldOrientation();
+            Quaternion orientation;
+            Vector3 position;
+            body->getPositionOrientation(position, orientation);
             // Calculate angular velocity
             // We first need the yaw rotation from actual yaw to desired yaw
             Vector3 src = orientation*Vector3::UNIT_Z;
@@ -180,7 +182,7 @@
 
             // using a spring system to apply the rotation
             Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
-            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+            Vector3 omega = body->getOmega();
             omega.x = omega.z = 0;
             Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
             torque = mass * springAcc;
@@ -530,9 +532,8 @@
                 else
                     mMovingCreature->setAnimation("hocke_gehen");
                 applyAuChanges(elapsedTime);
-                if( rotation != Vector3::ZERO )
-                    if( getRotationMovement()->isPossible() )
-                        getRotationMovement()->run(elapsedTime, direction, rotation);
+                if( getRotationMovement()->isPossible() )
+                    getRotationMovement()->run(elapsedTime, direction, rotation);
             }
             else
                 mVelocity = Vector3::ZERO;



From melven at mail.berlios.de  Sun Jun  3 23:55:53 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 3 Jun 2007 23:55:53 +0200
Subject: [Dsa-hl-svn] r3497 - modules/common/scripts
Message-ID: <200706032155.l53LtrI5017618@sheep.berlios.de>

Author: melven
Date: 2007-06-03 23:55:43 +0200 (Sun, 03 Jun 2007)
New Revision: 3497

Modified:
   modules/common/scripts/steering.rb
Log:
setAnimation must not be used here any more. This is now done by MovingCreature.

Modified: modules/common/scripts/steering.rb
===================================================================
--- modules/common/scripts/steering.rb	2007-06-03 19:59:10 UTC (rev 3496)
+++ modules/common/scripts/steering.rb	2007-06-03 21:55:43 UTC (rev 3497)
@@ -17,7 +17,6 @@
 	
 	def activate()
 		$SCRIPT.log("Activate Wandering");
-		getController().setAnimation("gehen");
 	end
 		
 	def update(elapsedTime)



From melven at mail.berlios.de  Mon Jun  4 00:03:44 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 4 Jun 2007 00:03:44 +0200
Subject: [Dsa-hl-svn] r3498 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200706032203.l53M3iXv018200@sheep.berlios.de>

Author: melven
Date: 2007-06-04 00:03:29 +0200 (Mon, 04 Jun 2007)
New Revision: 3498

Modified:
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/PlayerVehicle.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Implented MovingCreature in AI.
Various Changes:
-all update-functions are now called by the GameTask AgentManager (there were update-functions called from Physics-Callbacks before)
-removed PhysicsCallbacks (this work is now done in MovingCreate)
-some constructors changed
-SteeringVehicle::update changed

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/include/Agent.h	2007-06-03 22:03:29 UTC (rev 3498)
@@ -16,7 +16,6 @@
 #ifndef __RlAI_Agent_H__
 #define __RlAI_Agent_H__
 
-#include "PhysicsController.h"
 #include "FuzzyState.h"
 #include "AgentManager.h"
 
@@ -36,7 +35,6 @@
 	 * and decission making (behaviours)
 	 */
 	class _RlAiExport Agent 
-		: public PhysicsController
 	{
 	public:
 		/** Constructor by Creature object.
@@ -104,7 +102,8 @@
 		 * applied to the creature stored.
 		 * @param thing PhysicalThing that is responsible for the creature.
 		 */
-		virtual void OnApplyForceAndTorque(PhysicalThing* thing);
+        // physcs handled by movingcreature
+		//virtual void OnApplyForceAndTorque(PhysicalThing* thing);
 
 	protected:
 		//! stores the type of the agent (Player, NPC, ...)

Modified: rl/trunk/engine/ai/include/PlayerVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/PlayerVehicle.h	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/include/PlayerVehicle.h	2007-06-03 22:03:29 UTC (rev 3498)
@@ -21,7 +21,7 @@
 namespace rl
 {
 	class Agent;
-	class Actor;
+	class Creature;
 	/** Represents the player as a vehicle.
 	 */
 	class PlayerVehicle :
@@ -31,7 +31,7 @@
 		/** Constructor
 		 * @param Actor gives the Actor representing the Player
 		 */
-		PlayerVehicle(Actor* character);
+		PlayerVehicle(Creature* character);
 		/** explicit destructor
 		 */
 		virtual ~PlayerVehicle(void);
@@ -44,7 +44,11 @@
 		 * @param currentTime const float current time
 		 * @param elapsedTime const float elapsed time since last call
 		 */
-		virtual void update(const float currentTime, const float elapsedTime);
+        // same as SteeringVehicle if mMovingCreature is not set
+		//virtual void update(const float currentTime, const float elapsedTime);
+    protected:
+        virtual void createMovingCreature() {}
+        virtual void destroyMovingCreature() {}
 	};
 }
 

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-03 22:03:29 UTC (rev 3498)
@@ -41,6 +41,7 @@
 	class Actor;
 	class Agent;
 	class PhysicalThing;
+    class MovingCreature;
 //	class PerceptionPool;
 
 	/**
@@ -57,7 +58,7 @@
 		 * @param parent Agent owning this vehicle
 		 * @param character Actor controlled by Agent
 		 */
-		SteeringVehicle(Agent* parent, Actor* character);
+		SteeringVehicle(Agent* parent, Creature* character);
 		/** explicit virtual destructor.
 		 */
 		virtual ~SteeringVehicle(void);
@@ -132,10 +133,11 @@
 		 * @param minTimeToCollision minimum time to next collision
 		 */
 		bool needAvoidance(const float minTimeToCollision);
-		/** Sets the animation of the actors mesh to a new keyframe.
+		
+        /** Sets the animation of the actors mesh to a new keyframe.
 		 * @param name of the animation to set the mesh of the actor to.
 		 */
-		void setAnimation(const CeGuiString& name);
+		//void setAnimation(const CeGuiString& name);
 	
 		/* TODO:
 		calcFollowPath
@@ -323,6 +325,9 @@
 		 */
 		void initialize();
 
+        virtual void createMovingCreature(); // permit PlayerVehicle to override this functions!
+        virtual void destroyMovingCreature();
+
 		/** retrieves the neighbours of this SteeringVehicle
 		 */
 		OpenSteer::AVGroup getNeighbors() const;
@@ -353,7 +358,7 @@
         OpenSteer::Vec3 _smoothedAcceleration;
 	*/	
 		//! mass of the steering vehicle retrieved from Newton body (is this really necessary ?)
-		Ogre::Real mMass;
+		//Ogre::Real mMass;
 		//! radius of for the bounding sphere (use newton to get this from)
 		Ogre::Real mRadius;
 		//! speed of the vehicle
@@ -369,13 +374,15 @@
 		//! direction vector
 		Ogre::Vector3 mForwardVector;
 		//! the yaw angle in radians
-		Ogre::Radian mYaw;
+		//Ogre::Radian mYaw;
 
 		//! Agent using this vehicle
 		Agent* mParent;
-		//! Actor object steered by this vehicle (and controlled by Agent).
-		Actor* mActor;
+        //! Creature object steered by this vehicle (and controlled by Agent).
+        Creature* mCreature;
 
+        MovingCreature* mMovingCreature;
+
         // measure path curvature (1/turning-radius), maintain smoothed version
       //  void measurePathCurvature (const float elapsedTime);
 	};

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-06-03 22:03:29 UTC (rev 3498)
@@ -58,8 +58,8 @@
 
 Agent::~Agent(void)
 {
-    if(mType == AgentManager::AGENT_STD_NPC)
-        mCreature->getActor()->getPhysicalThing()->setPhysicsController( NULL );
+    //if(mType == AgentManager::AGENT_STD_NPC)
+    //    mCreature->getActor()->getPhysicalThing()->setPhysicsController( NULL );
 
     delete mVehicle;
     delete mBehaviour;
@@ -81,7 +81,7 @@
 	if(mVehicle == NULL)
 	{
 		mType = AgentManager::AGENT_STD_NPC;
-		mVehicle = new SteeringVehicle(this, mCreature->getActor());
+		mVehicle = new SteeringVehicle(this, mCreature);
 	}
     LOG_MESSAGE(Logger::AI, 
         "created SteeringVehicle for Agent");
@@ -91,12 +91,15 @@
         "created SteeringMachine for Agent");
 //  a perceptron should be the controller, and the perceptron calculates
 //  the steering force with the help of different steering behaviours
+/*
+// physic handled by movingcreature
 	if(mType == AgentManager::AGENT_STD_NPC)
 	{
 		mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
         LOG_MESSAGE(Logger::AI, 
 			"added Agent to PhysicsManager as PhysicsController");
 	}
+*/
 }
 
 void Agent::addSteeringBehaviour(SteeringBehaviour* behaviour)
@@ -123,12 +126,16 @@
     mVehicle->update(0.0f, elapsedTime);
 }
 
+
+/*
+// physics handled in movingcreature
 void Agent::OnApplyForceAndTorque(PhysicalThing* thing)
 {
 	OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
 	Real elapsedTime = world->getTimeStep();
 	update(elapsedTime);
 }
+*/
 
 bool Agent::isDialogActive()
 {

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-06-03 22:03:29 UTC (rev 3498)
@@ -52,8 +52,9 @@
 	SteeringVehicle* vehicle = NULL;
 	if(type == AGENT_PLAYER)
 	{
-		vehicle = new PlayerVehicle(character->getActor());
+		vehicle = new PlayerVehicle(character);
 	}
+
     Agent* agent = new Agent(character, vehicle);
 	agent->setType(type);
 	if(type == AGENT_PLAYER)
@@ -61,6 +62,7 @@
 		mPlayer = agent;
 	}
 
+
 	addAgent(agent);
     return agent;
 }

Modified: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-06-03 22:03:29 UTC (rev 3498)
@@ -15,6 +15,7 @@
  */
 #include "PlayerVehicle.h"
 #include "Actor.h"
+#include "Creature.h"
 #include "MeshObject.h"
 #include "PhysicalThing.h"
 
@@ -23,7 +24,7 @@
 
 namespace rl {
 
-PlayerVehicle::PlayerVehicle(Actor* character)
+PlayerVehicle::PlayerVehicle(Creature* character)
 	: SteeringVehicle(NULL, character)
 {
 }
@@ -31,10 +32,10 @@
 PlayerVehicle::~PlayerVehicle(void)
 {
 }
-
+/*
 void PlayerVehicle::update(const float currentTime, const float elapsedTime)
 {
-	PhysicalThing* pt = mActor->getPhysicalThing();
+	PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
 	OgreNewt::Body* body = NULL;
 	if(pt) pt->_getBody();
 	if(body)
@@ -61,5 +62,5 @@
 	}
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
-
+*/
 }

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-03 22:03:29 UTC (rev 3498)
@@ -18,7 +18,9 @@
 #include "AiWorld.h" 
 #include "Agent.h"
 #include "Actor.h"
+#include "Creature.h"
 #include "MeshObject.h"
+#include "MovingCreature.h"
 #include "PhysicalThing.h"
 
 using namespace Ogre;
@@ -26,37 +28,55 @@
 
 namespace rl {
 
-SteeringVehicle::SteeringVehicle(Agent* parent, Actor* character)
+SteeringVehicle::SteeringVehicle(Agent* parent, Creature* character)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
-      mMass(),
+      //mMass(),
       mRadius(),
       mSpeed(1.0f),
 	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-      mYaw(115),
+      //mYaw(115),
 	  mParent(parent),
-	  mActor(character),
+	  mCreature(character),
+      mMovingCreature(NULL),
       mHeight(0)
 {
 	initialize();
+
+    createMovingCreature();
 }
 
 SteeringVehicle::~SteeringVehicle(void)
 {
+    destroyMovingCreature();
 }
 
+void SteeringVehicle::createMovingCreature()
+{
+    if( mMovingCreature == NULL )
+    {
+        mMovingCreature = new MovingCreature(mCreature);
+    }
+}
+
+void SteeringVehicle::destroyMovingCreature()
+{
+    if( mMovingCreature != NULL )
+        delete mMovingCreature;
+}
+
 void SteeringVehicle::resetLocalSpace()
 {
 	setForward(Vec3(mForwardVector.x, mForwardVector.y, mForwardVector.z));
 	setSide(localRotateForwardToSide(forward()));
 	setUp(OpenSteer::Vec3(0, 1, 0));
-	Vector3 pos = mActor->getPosition();
+	Vector3 pos = mCreature->getActor()->getPosition();
 	setPosition(Vec3(pos.x, pos.y, pos.z));
-	Vector3 src = mActor->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
-	Quaternion orientation = mActor->getOrientation();
-	mYaw = orientation.getYaw();
+	Vector3 src = mCreature->getActor()->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+	//Quaternion orientation = mCreature->getActor()->getOrientation();
+	//mYaw = orientation.getYaw();
 
 //  regenerate local space (by default: align vehicle's forward axis with
 //  new velocity, but this behavior may be overridden by derived classes.)
@@ -68,9 +88,9 @@
 //  reset LocalSpace state
 	resetLocalSpace();
 	
-//	mActor->_getSceneNode()->setOrientation(Ogre::Quaternion::IDENTITY);
-	Vector3 inertia;
-	mActor->getPhysicalThing()->_getBody()->getMassMatrix(mMass, inertia);
+//	mCreature->getActor()->_getSceneNode()->setOrientation(Ogre::Quaternion::IDENTITY);
+	//Vector3 inertia;
+	//mCreature->getActor()->getPhysicalThing()->_getBody()->getMassMatrix(mMass, inertia);
 
 //	mSpeed = (float)mCreature->getWert(Creature::WERT_GS) / (float)Date::ONE_KAMPFRUNDE * 1000.0f;
 
@@ -105,68 +125,78 @@
 
 void SteeringVehicle::update(const float currentTime, const float elapsedTime)
 {
-	OgreNewt::Body* body = mActor->getPhysicalThing()->_getBody();
-//  get the charater mass
-	Vector3 inertia;
-	body->getMassMatrix(mMass, inertia);
+// from PlayerVehicle
+// since physics schould by handled by movingcreature
 
-//  apply gravity
-	Vector3 force = mMass * PhysicsManager::getSingleton().getGravity();
+	OgreNewt::Body* body = mCreature->getActor()->getPhysicalThing()->_getBody();
 
-//  Get the velocity vector
+    Vector3 position;
+	Quaternion orientation;
+	body->getPositionOrientation(position, orientation);
+	setPosition(Vec3(position.x, position.y, position.z));
+
+    //  Get the velocity vector
 	mCurrentVelocity = body->getVelocity();
-
-//  setSpeed(mCurrentVelocity.length());
+	//  enforce speed limit
+	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
+	//  update speed
+	setSpeed(mCurrentVelocity.length());
 	Vec3 newVelocity(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);
-//  enforce speed limit
-//  newVelocity = newVelocity.truncateLength(maxSpeed ());
-//  update speed 
-    setSpeed (newVelocity.length());
 
-//  Gravity is applied above, so not needed here
-//  prevent adding a counter force against gravity
-	if (mCurrentVelocity.y < 0.0f) mCurrentVelocity.y = 0.0f;
+    //  regenerate local space (by default: align vehicle's forward axis with
+    //  new velocity, but this behavior may be overridden by derived classes.)
+	if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
 
+// end of inserting from playervehicle
 
-//	Vec3 aforce = adjustRawSteeringForce(Vec3(mCurrentForce.x, mCurrentForce.y, mCurrentForce.z)); 
-//	aforce = aforce.truncateLength (maxForce());
-//	aforce *=-1; // need for newton ?
-//	mCurrentForce = Vector3(aforce.x, aforce.y, aforce.z);
-	Vector3 temp;
-	Quaternion orientation;
-	body->getPositionOrientation(temp, orientation);
-	setPosition(Vec3(temp.x, temp.y, temp.z));
-	
-//	if(mCurrentForce.x != 0.0f)
-//	{
-	// Calculate angular velocity
-		mYaw -= Degree(mCurrentForce.x * 60.0f * elapsedTime);
 
-		while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-		while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-	//  We first need the yaw rotation from actual yaw to desired yaw
-		Vector3 src = orientation*Vector3::NEGATIVE_UNIT_Z;
-		src.y = 0.0f;
-		temp = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::NEGATIVE_UNIT_Z;
-		temp.y = 0.0f;
-		Radian yaw = src.getRotationTo(temp).getYaw();
 
-	//  Calculate omega in order to go this rotation in mMaxDelay seconds.
-		Real newOmega = yaw.valueRadians() / (1.0f/30.0f);
-		body->setOmega(Vector3(0.0f, newOmega, 0.0f));
+// only process if mMovingCreature not NULL
+    if( mMovingCreature == NULL )
+    {
+        mCurrentForce = Vector3::ZERO;
+        return;
+    }
+    
+// calculate the result of the force    
+    Vector3 result = mCurrentForce;// + mCurrentVelocity;
 
-		mCurrentForce.x = 0.0f;
-//	}
-	if(elapsedTime > 0.0f)
-	{
-		force += mMass*(orientation * mCurrentForce - mCurrentVelocity) / elapsedTime;
-	}
-	body->setForce(force);
+// @todo remove this
+if( mCreature->getAu() <= 6 )
+    mCreature->modifyAu(20,true);
 
-//  regenerate local space (by default: align vehicle's forward axis with
-//  new velocity, but this behavior may be overridden by derived classes.)
-	if (speed() > 0) regenerateOrthonormalBasisUF ( Vec3(temp.x, temp.y, temp.z) );
 
+    AbstractMovement *mov_drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+    Real vel_drehen(0);
+    Radian max_drehen = Degree(0);
+    if( mov_drehen->calculateBaseVelocity(vel_drehen) )
+    {
+        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
+    }
+
+    Ogre::Vector3 creatureDirection = orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    Radian yaw(0);
+    creatureDirection.y = result.y = 0;
+    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
+    if( yaw > Radian(0) && yaw > max_drehen )
+        yaw = max_drehen;
+    if( yaw < Radian(0) && yaw < -max_drehen )
+        yaw = -max_drehen;
+    // old version was -Degree(mCurrentForce.x * 60 * elapsedTime);
+    // should this really depend from the timestep!?!
+
+    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
+    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
+    MovingCreature::MovementType movement = MovingCreature::MT_STEHEN;
+    if( result != Ogre::Vector3::ZERO )
+    {
+        direction.z = -1;
+        movement = MovingCreature::MT_GEHEN;
+    }
+
+
+    mMovingCreature->setMovement(movement, direction, rotation);
+
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
 
@@ -182,7 +212,7 @@
 	Vec3 rVal = steerForSeek(Vec3(target.x, target.y, target.z)).setYtoZero();
 	rVal = rVal.normalize();
 	//rVal *= -0.1; //adjustment for newton
-	rVal.z=0;
+	//rVal.z=0;
 	return Vector3(rVal.x, rVal.y, rVal.z);
 }
 
@@ -247,17 +277,20 @@
 	return true;
 }
 
+/*
+// already in moveingcreature
 void SteeringVehicle::setAnimation(const CeGuiString& name)
 {
-	MeshObject* mesh = dynamic_cast<MeshObject*>(mActor->getControlledObject());
+	MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
 	mesh->stopAllAnimations();
     try
     {
 	    mesh->startAnimation(name.c_str());
-	    mActor->getPhysicalThing()->fitToPose(name.c_str());
+	    mCreature->getActor()->getPhysicalThing()->fitToPose(name.c_str());
     }
     catch( ... ) { }
 }
+*/
 
 
 AVGroup SteeringVehicle::getNeighbors() const
@@ -288,7 +321,7 @@
 
 float SteeringVehicle::mass (void) const 
 {
-	return mMass;
+    return mCreature->getActor()->getPhysicalThing()->getMass();
 }
 
 float SteeringVehicle::setMass (float m) 
@@ -334,7 +367,7 @@
 
 const Actor* SteeringVehicle::getActor(void) const  
 { 
-	return mActor; 
+	return mCreature->getActor(); 
 }
 
 float SteeringVehicle::maxForce (void) const 

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-06-03 21:55:43 UTC (rev 3497)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-06-03 22:03:29 UTC (rev 3498)
@@ -29,7 +29,7 @@
 	class SteeringVehicle
 	{
 	public:
-		SteeringVehicle(rl::Agent* agent, rl::Actor* character);
+		SteeringVehicle(rl::Agent* agent, rl::Creature* character);
 		
 		void addForce(const Ogre::Vector3& force);
 
@@ -56,8 +56,6 @@
 		bool isAhead(rl::Agent* agent, const float threshold);
 		
 		bool needAvoidance(const float minTimeToCollision);
-		
-		void setAnimation(rl::CeGuiString& name);
 	};
 	
 	%feature("director") SteeringBehaviour;



From melven at mail.berlios.de  Mon Jun  4 20:52:12 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 4 Jun 2007 20:52:12 +0200
Subject: [Dsa-hl-svn] r3499 - modules/common/scripts
Message-ID: <200706041852.l54IqCKY029577@sheep.berlios.de>

Author: melven
Date: 2007-06-04 20:52:05 +0200 (Mon, 04 Jun 2007)
New Revision: 3499

Modified:
   modules/common/scripts/steering.rb
Log:
removed forgotten setAnimation

Modified: modules/common/scripts/steering.rb
===================================================================
--- modules/common/scripts/steering.rb	2007-06-03 22:03:29 UTC (rev 3498)
+++ modules/common/scripts/steering.rb	2007-06-04 18:52:05 UTC (rev 3499)
@@ -63,7 +63,6 @@
 	
 	def activate()
 		$SCRIPT.log("Activate Idle");
-		getController().setAnimation("idle");
 	end
 		
 	def update(elapsedTime)



From melven at mail.berlios.de  Tue Jun  5 17:42:56 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 5 Jun 2007 17:42:56 +0200
Subject: [Dsa-hl-svn] r3500 - rl/trunk/engine/core/src
Message-ID: <200706051542.l55Fguae016267@sheep.berlios.de>

Author: melven
Date: 2007-06-05 17:42:45 +0200 (Tue, 05 Jun 2007)
New Revision: 3500

Modified:
   rl/trunk/engine/core/src/PhysicalThing.cpp
Log:
Setting Material "default" for all new bodies

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-04 18:52:05 UTC (rev 3499)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-05 15:42:45 UTC (rev 3500)
@@ -382,6 +382,7 @@
 
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
+            body->setMaterialGroupID(PhysicsManager::getSingleton().getMaterialID("default"));
 
 			Ogre::Real mass = mMass;
 			if (mass > 0.0 && mGeometryType != GT_MESH)



From melven at mail.berlios.de  Tue Jun  5 20:37:03 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 5 Jun 2007 20:37:03 +0200
Subject: [Dsa-hl-svn] r3501 - in rl/trunk/engine/rules: include src
Message-ID: <200706051837.l55Ib3KZ017721@sheep.berlios.de>

Author: melven
Date: 2007-06-05 20:36:56 +0200 (Tue, 05 Jun 2007)
New Revision: 3501

Modified:
   rl/trunk/engine/rules/include/MovingCreature.h
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
added method getYaw in order to determine the orientation the creature is turning to

Modified: rl/trunk/engine/rules/include/MovingCreature.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreature.h	2007-06-05 15:42:45 UTC (rev 3500)
+++ rl/trunk/engine/rules/include/MovingCreature.h	2007-06-05 18:36:56 UTC (rev 3501)
@@ -139,6 +139,10 @@
                           );
 
 
+        /// this method will return the yaw, the creature tries to turn to, if a rotation-movement is activated. if not, it will return the current yaw
+        Ogre::Radian getYaw();
+
+
     protected:
         Creature *mCreature;
         AbstractLocation mAbstractLocation;
@@ -169,7 +173,7 @@
         public OgreNewt::ContactCallback
     {
     public:
-        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature) {}
+        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
 
         /// returns the id of this movement
         virtual MovingCreature::MovementType getId() const = 0;
@@ -224,13 +228,15 @@
         /**
          * this function is called if this movement is activated.
          * it can be used to determine if a new "Talentprobe" is needed
+         * if you ovveride it, please make sure to call the base class method
          */
-        virtual void activate() {}
+        virtual void activate() {mActive = true;}
 
         /**
          * this function is called every time this movement is deactivated.
+         * if you ovveride it, please make sure to call the base class method
          */
-        virtual void deactivate() {}
+        virtual void deactivate() {mActive = false;}
 
         /**
          * this method is used to get to know if a movement can be used with a certain direction
@@ -246,8 +252,15 @@
          */
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const = 0;
 
+
+        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
+        bool isActive() const {return mActive;}
+
+        /// this method is used to return the yaw value of rotation movemenrts etc
+        virtual Ogre::Real getMovementDefinedValue() {return 0;}
     protected:
         MovingCreature *mMovingCreature;
+        bool mActive;
     };
 }
 #endif

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-05 15:42:45 UTC (rev 3500)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-05 18:36:56 UTC (rev 3501)
@@ -42,10 +42,12 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
         virtual void activate()
         {
+            AbstractMovement::activate();
             getRotationMovement()->activate();
         }
         virtual void deactivate()
         {
+            AbstractMovement::deactivate();
             getRotationMovement()->deactivate();
         }
         virtual bool calculateBaseVelocity(Real &velocity)
@@ -157,10 +159,12 @@
         }
         virtual void activate()
         {
+            AbstractMovement::activate();
             mYaw = mMovingCreature->getCreature()->getActor()->getWorldOrientation().getYaw();
         }
         virtual void deactivate()
         {
+            AbstractMovement::deactivate();
         }
         virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
         {
@@ -209,6 +213,7 @@
     protected:
         Ogre::Radian mYaw;
         Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
+        virtual Real getMovementDefinedValue() {return mYaw.valueRadians();}
     };
 
 
@@ -311,6 +316,7 @@
         }
         virtual void activate()
         {
+            AbstractMovement::activate();
             doTalentProbeIfNecessary();
         }
         virtual void doTalentProbeIfNecessary()
@@ -387,6 +393,7 @@
         }
         virtual void activate()
         {
+            AbstractMovement::activate();
             doTalentProbeIfNecessary();
         }
         virtual void doTalentProbeIfNecessary()
@@ -543,6 +550,7 @@
         virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
         virtual void activate()
         {
+            AbstractMovement::activate();
             mState = UPTODOWN;
             mMovingCreature->setAnimation("idle_zu_hocke",1,1,"idle");
             mTimer = 0;
@@ -574,6 +582,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
         virtual void activate()
         {
+            AbstractMovement::activate();
             mState = DOWNTOUP;
             mMovingCreature->setAnimation("idle_absprung",1,1,"idle");
             mTimer = 0;
@@ -605,6 +614,7 @@
         }
         virtual void deactivate()
         {
+            AbstractMovement::deactivate();
         }
         virtual bool calculateBaseVelocity(Real &velocity)
         {
@@ -736,6 +746,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
         virtual void activate()
         {
+            AbstractMovement::activate();
             mState = DOWNTOUP;
             mMovingCreature->setAnimation("rennen_absprung",1,1,"rennen");
             mTimer = 0;
@@ -767,6 +778,7 @@
         }
         virtual void deactivate()
         {
+            AbstractMovement::deactivate();
         }
         virtual bool calculateBaseVelocity(Real &velocity)
         {
@@ -1199,4 +1211,21 @@
 
         return false;
     }
+
+
+
+    Ogre::Radian MovingCreature::getYaw()
+    {
+        Radian yaw = mCreature->getActor()->getWorldOrientation().getYaw();
+
+        AbstractMovement *drehen = getMovementFromId(MT_DREHEN);
+        
+        if( drehen == NULL )
+            return yaw;
+
+        if( !drehen->isActive() )
+            return yaw;
+
+        return Radian(drehen->getMovementDefinedValue());
+    }
 }



From melven at mail.berlios.de  Tue Jun  5 20:40:05 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 5 Jun 2007 20:40:05 +0200
Subject: [Dsa-hl-svn] r3502 - in rl/trunk/engine/ai: include src
Message-ID: <200706051840.l55Ie5xI018075@sheep.berlios.de>

Author: melven
Date: 2007-06-05 20:39:51 +0200 (Tue, 05 Jun 2007)
New Revision: 3502

Modified:
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
Log:
NewtonWorldAsObstacle: 
-test for multiple materials (but the whole class doesn't seem to work correctly)

SteeringVehicle: 
-implemented some empty methods
-using future orientation of movingcreature

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-06-05 18:36:56 UTC (rev 3501)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-06-05 18:39:51 UTC (rev 3502)
@@ -18,6 +18,7 @@
 
 #include "OpenSteer/Obstacle.h"
 #include <OgreNewt.h>
+#include <vector>
 
 namespace rl
 {
@@ -74,7 +75,7 @@
             BOTTOM
         };
 		//! newton material id
-        const OgreNewt::MaterialID *mLevelMaterial;
+        std::vector<const OgreNewt::MaterialID *> mMaterialsToConsider;
 		//! newton world
         OgreNewt::World *mNewtonWorld;
     };

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-05 18:36:56 UTC (rev 3501)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-05 18:39:51 UTC (rev 3502)
@@ -360,12 +360,12 @@
 		//! mass of the steering vehicle retrieved from Newton body (is this really necessary ?)
 		//Ogre::Real mMass;
 		//! radius of for the bounding sphere (use newton to get this from)
-		Ogre::Real mRadius;
+		//Ogre::Real mRadius;
 		//! speed of the vehicle
 		Ogre::Real mSpeed;	
 
 		//! height of the vehicle ? (use newton to get this)
-        float mHeight;
+        //float mHeight;
 
 		//! current force 
 		Ogre::Vector3 mCurrentForce;

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-06-05 18:36:56 UTC (rev 3501)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-06-05 18:39:51 UTC (rev 3502)
@@ -73,7 +73,8 @@
 
 NewtonWorldAsObstacle::NewtonWorldAsObstacle(void)
 {
-    mLevelMaterial = PhysicsManager::getSingleton().getMaterialID("level");
+    mMaterialsToConsider.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+    mMaterialsToConsider.push_back(PhysicsManager::getSingleton().getMaterialID("default"));
     mNewtonWorld = PhysicsManager::getSingleton()._getNewtonWorld();
 }
 
@@ -90,7 +91,7 @@
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
     Vec3 _pos = vehicle.position();
-    Vec3 _futPos = vehicle.forward() * 2 + _pos;
+    Vec3 _futPos = vehicle.forward() * 5 + _pos;
 
 
     if( _pos == _futPos )
@@ -105,10 +106,11 @@
 
 
     // Versuchen wir mal das Casten, um das urspruengliche SteelingVehicle zu kriegen
-    const SteeringVehicle *steerVec = dynamic_cast<const SteeringVehicle *> (&vehicle);
+    const SteeringVehicle *steerVec = static_cast<const SteeringVehicle *> (&vehicle);
     // falls nich geklappt, ist das Ergebnis NULL, das wird spaeter abgefragt!
 
 
+    bool foundObstacle(false);
     for( int i = 0; i < 5; i++ )
     {
         Ogre::Vector3 castPos, castFutPos;  // die Koordinaten, die zum Casten verwendet werden
@@ -168,21 +170,29 @@
         // so alles richtig gesetzt!
         info = materialRaycast.execute(
             mNewtonWorld,
-            mLevelMaterial,
+            &mMaterialsToConsider,
             castPos,
             castFutPos);
 
 
         if( info.mBody )
-            break;
+        {
+            if( !info.mNormal.directionEquals(Ogre::Vector3::UNIT_Y, Degree(20)) )
+            {
+                foundObstacle = true;
+                break;
+            }
+        }
     }
 
+    if( !foundObstacle )
+        return;
 
+
     switch(raycastType)
     {
     case NONE:
         return;
-    case MIDDLE:
     default:
         pi.intersect = true;
         pi.obstacle = this;

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-05 18:36:56 UTC (rev 3501)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-05 18:39:51 UTC (rev 3502)
@@ -32,7 +32,7 @@
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       //mMass(),
-      mRadius(),
+      //mRadius(),
       mSpeed(1.0f),
 	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
@@ -40,8 +40,8 @@
       //mYaw(115),
 	  mParent(parent),
 	  mCreature(character),
-      mMovingCreature(NULL),
-      mHeight(0)
+      mMovingCreature(NULL)
+      //mHeight(0)
 {
 	initialize();
 
@@ -97,7 +97,7 @@
 //  reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();
 
-	setRadius (0.5f);     // size of bounding sphere
+//	setRadius (0.5f);     // size of bounding sphere
 
 	setMaxForce (1.0f);   // steering force is clipped to this magnitude
 	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
@@ -174,7 +174,8 @@
         max_drehen = Degree(vel_drehen * 360 * elapsedTime);
     }
 
-    Ogre::Vector3 creatureDirection = orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    Ogre::Quaternion future_orientation(mMovingCreature->getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
     Radian yaw(0);
     creatureDirection.y = result.y = 0;
     yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
@@ -343,26 +344,27 @@
 
 float SteeringVehicle::radius (void) const 
 {
-	// TODO: this should be handled by size of NewtonBody
-	return mRadius;
+	// this is only the radius in x axis, but i think, this is the value that should be used here
+    Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
+    return (aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
 float SteeringVehicle::setRadius (float m) 
 {
-	// TODO: this should be handled by size of NewtonBody
-	return mRadius = m;
+	// don't set mass here TODO: throw exception
+	return 1;
 }
 
 float SteeringVehicle::height (void) const 
 {
-	// TODO: this should be handled by height of NewtonBody
-	return mHeight;
+    Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
+    return aab.getMaximum().y - aab.getMinimum().y;
 }
 
 float SteeringVehicle::setHeight (float h) 
 {
-	// TODO: this should be handled by height of NewtonBody
-	return mHeight = h;
+	// don't set mass here TODO: throw exception
+	return 1;
 }
 
 const Actor* SteeringVehicle::getActor(void) const  



From josch at mail.berlios.de  Tue Jun  5 21:20:29 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Tue, 5 Jun 2007 21:20:29 +0200
Subject: [Dsa-hl-svn] r3503 - dependencies/dsa4wz/src
Message-ID: <200706051920.l55JKTXN021469@sheep.berlios.de>

Author: josch
Date: 2007-06-05 21:20:24 +0200 (Tue, 05 Jun 2007)
New Revision: 3503

Modified:
   dependencies/dsa4wz/src/
Log:



Property changes on: dependencies/dsa4wz/src
___________________________________________________________________
Name: svn:ignore
   - *.loT
.deps

   + *.loT
.deps
.libs
.dirstamp




From josch at mail.berlios.de  Tue Jun  5 22:30:49 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Tue, 5 Jun 2007 22:30:49 +0200
Subject: [Dsa-hl-svn] r3504 - in modules: common/materials common/scripts
	regressiontest/scripts
Message-ID: <200706052030.l55KUncJ026865@sheep.berlios.de>

Author: josch
Date: 2007-06-05 22:30:41 +0200 (Tue, 05 Jun 2007)
New Revision: 3504

Modified:
   modules/common/materials/Fackel.particle
   modules/common/materials/Rastullahs_particle_zumpi.material
   modules/common/scripts/torch.rb
   modules/regressiontest/scripts/SoundTest.rb
Log:
Torch now shows flare

Modified: modules/common/materials/Fackel.particle
===================================================================
--- modules/common/materials/Fackel.particle	2007-06-05 19:20:24 UTC (rev 3503)
+++ modules/common/materials/Fackel.particle	2007-06-05 20:30:41 UTC (rev 3504)
@@ -2,7 +2,7 @@
 flammen
 {
 	quota	10
-	material	feuer
+	material	fackel
 	particle_width	20.66
 	particle_height	23.12
 	cull_each	false

Modified: modules/common/materials/Rastullahs_particle_zumpi.material
===================================================================
--- modules/common/materials/Rastullahs_particle_zumpi.material	2007-06-05 19:20:24 UTC (rev 3503)
+++ modules/common/materials/Rastullahs_particle_zumpi.material	2007-06-05 20:30:41 UTC (rev 3504)
@@ -10,7 +10,7 @@
 
 			texture_unit
 			{
-				texture flamme.dds
+				texture flaretrail.dds
 			
 			}
 		}

Modified: modules/common/scripts/torch.rb
===================================================================
--- modules/common/scripts/torch.rb	2007-06-05 19:20:24 UTC (rev 3503)
+++ modules/common/scripts/torch.rb	2007-06-05 20:30:41 UTC (rev 3504)
@@ -22,6 +22,8 @@
     end
     
     def doAction(torch, user, target)
+        p torch.lit?
+        return if torch.lit?
         # Fackel hat ein Licht am Slot SLOT_FAR_END
         # Man k?nnte es auch so machen, dass dieses Licht jetzt
         # erzeugt und angeheftet wird. Spr?che einiges daf?r.
@@ -44,6 +46,7 @@
         # ausgeht.
         torch.sound.getSound().setPosition(torchActor.getPosition())
         torch.sound.play()
+        torch.flammen.getControlledObject().setActive(true)
         torch.setLit(true);
     end
 end
@@ -61,6 +64,7 @@
     end
     
     def doAction(torch, user, target)
+        return unless torch.lit?
         # Fackel hat ein Licht am Slot SLOT_FAR_END
         # Man k?nnte es auch so machen, dass dieses Licht jetzt
         # erzeugt und angeheftet wird. Spr?che einiges daf?r.
@@ -82,6 +86,7 @@
         #TODO timer setzen, damit die Fackel nach Ablauf ihrer Lebensdauer
         # ausgeht.
         torch.sound.stop();
+        torch.flammen.getControlledObject().setActive(false)
         torch.setLit(false);
     end
 end
@@ -90,9 +95,13 @@
 # TODO Persistenz *schreck*
 class Torch < GameObject
     include GameObjectProperties
+    attr_reader :flammen
     
     def initialize(id)
         super(id)
+        @flammen = $AM.createParticleSystemActor("torch" + id.to_s, "flammen")
+        @flammen.getControlledObject().setActive(false)
+        setLit(false)
     end
     
     def setLit(lit)
@@ -125,6 +134,7 @@
         sound.setLooping(true)
         sound.set3d(true)
         @_prop_Sound = SoundObject.new(sound, getId().to_s())
+        getActor().attachToSlot(@flammen, "SLOT_FAR_END")
         addActions()
     end
     
@@ -138,7 +148,7 @@
             addAction(@mLightAction, Action::ACT_DISABLED)
             addAction(@mPutoutAction, Action::ACT_DISABLED)
         end
-        doAction("lighttorch") unless @_prop_Lit
+        doAction("putouttorch") if @_prop_Lit
     end
     
     def getDefaultAction(actor)

Modified: modules/regressiontest/scripts/SoundTest.rb
===================================================================
--- modules/regressiontest/scripts/SoundTest.rb	2007-06-05 19:20:24 UTC (rev 3503)
+++ modules/regressiontest/scripts/SoundTest.rb	2007-06-05 20:30:41 UTC (rev 3504)
@@ -1,3 +1,4 @@
+require 'util/vector_util.rb'
 require 'testcase.rb'
 require 'torch.rb'
 



From blakharaz at mail.berlios.de  Tue Jun  5 23:39:48 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 5 Jun 2007 23:39:48 +0200
Subject: [Dsa-hl-svn] r3505 - rl/trunk/engine/rules/src
Message-ID: <200706052139.l55LdmYC001718@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-05 23:39:41 +0200 (Tue, 05 Jun 2007)
New Revision: 3505

Modified:
   rl/trunk/engine/rules/src/Creature.cpp
Log:
Set string keys for Creature's properties


Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-06-05 20:30:41 UTC (rev 3504)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-06-05 21:39:41 UTC (rev 3505)
@@ -40,20 +40,20 @@
 
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype"; 
-    const Ogre::String Creature::PROPERTY_CURRENT_LE;
-    const Ogre::String Creature::PROPERTY_CURRENT_AE;
-    const Ogre::String Creature::PROPERTY_CURRENT_AU;
-    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE;
-    const Ogre::String Creature::PROPERTY_EFFECTS;
-    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN;
-    const Ogre::String Creature::PROPERTY_TALENTE;
-    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN;
-    const Ogre::String Creature::PROPERTY_VORTEILE;
-    const Ogre::String Creature::PROPERTY_NACHTEILE;
-    const Ogre::String Creature::PROPERTY_SF;
-    const Ogre::String Creature::PROPERTY_WERTE;
-    const Ogre::String Creature::PROPERTY_AP;
-    const Ogre::String Creature::PROPERTY_INVENTORY;
+    const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
+    const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
+    const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = "current_fatigue";
+    const Ogre::String Creature::PROPERTY_EFFECTS = "effects";
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = "eigenschaften";
+    const Ogre::String Creature::PROPERTY_TALENTE = "talente";
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = "kampftechniken";
+    const Ogre::String Creature::PROPERTY_VORTEILE = "vorteile";
+    const Ogre::String Creature::PROPERTY_NACHTEILE = "nachteile";
+    const Ogre::String Creature::PROPERTY_SF = "sonderfertigkeiten";
+    const Ogre::String Creature::PROPERTY_WERTE = "werte";
+    const Ogre::String Creature::PROPERTY_AP = "ap";
+    const Ogre::String Creature::PROPERTY_INVENTORY = "inventory";
 
     // some targets
 	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";



From blakharaz at mail.berlios.de  Wed Jun  6 00:10:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 00:10:09 +0200
Subject: [Dsa-hl-svn] r3506 - in modules/common: dsa scripts
Message-ID: <200706052210.l55MA9pL004894@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 00:10:01 +0200 (Wed, 06 Jun 2007)
New Revision: 3506

Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/common/scripts/hero.rb
Log:
Move Alrike's properties from her Ruby class to the GOF file

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2007-06-05 21:39:41 UTC (rev 3505)
+++ modules/common/dsa/gameobjectdefinitions.gof	2007-06-05 22:10:01 UTC (rev 3506)
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+?<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
 	<gameobjectclass classid="door" baseclass="Door">
@@ -14,6 +14,23 @@
 		<property name="geometrytype" type="STRING" data="ellipsoid" />
 		<property name="mass" type="REAL" data="75"/>
 		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="name" type="STRING" data="Alrike"/>
+		<property name="description" type="STRING" data="Heldin von Berufung"/>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
+<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
+		</property>
 	</gameobjectclass>
 
 	<gameobjectclass classid="chest" baseclass="Chest">

Modified: modules/common/scripts/hero.rb
===================================================================
--- modules/common/scripts/hero.rb	2007-06-05 21:39:41 UTC (rev 3505)
+++ modules/common/scripts/hero.rb	2007-06-05 22:10:01 UTC (rev 3506)
@@ -4,18 +4,7 @@
     def initialize(id)
         super(id);
         addQueryFlag(RlScript::QUERYFLAG_PLAYER)
-		    setName("Alrike");
-		    setDescription("Heldin von Berufung");
-		    $SCRIPT.log("Gute Eigenschaften zuweisen...");
-
-        setEigenschaft("MU", 12);
-        setEigenschaft("KL", 8);
-        setEigenschaft("IN", 9);
-        setEigenschaft("CH", 10);
-        setEigenschaft("FF", 11);
-        setEigenschaft("GE", 12);
-        setEigenschaft("KO", 13); #KO
-        setEigenschaft("KK", 14); #KK
+		    
 		setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
 
 		$SCRIPT.log("LeP und AuP auff?llen");
@@ -23,15 +12,6 @@
         modifyAu(1000); # Au = voll
         #modifyLe(-20); # 10 LeP abziehen
 
-		$SCRIPT.log("Talente hinzuf?gen");
-		addTalent("Athletik", 3);
-		#addTalent("K?rperbeherrschung", 3);
-
-        $SCRIPT.log("Heldenaktor beschreiben...");
-        setProperty("meshfile", "men_alrike.mesh")
-		setProperty("physicsbody", PhysicsManager::GT_ELLIPSOID)
-		setProperty("mass", 75.0);
-	
 		$SCRIPT.log("Inventar konfigurieren.");
 		inv = getInventory();
 		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);



From timm at mail.berlios.de  Wed Jun  6 00:39:56 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 6 Jun 2007 00:39:56 +0200
Subject: [Dsa-hl-svn] r3507 - in rl/trunk/engine/ai: include src
Message-ID: <200706052239.l55MduAJ026473@sheep.berlios.de>

Author: timm
Date: 2007-06-06 00:39:47 +0200 (Wed, 06 Jun 2007)
New Revision: 3507

Modified:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
updated CreatureWalkPathJob

Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-06-05 22:10:01 UTC (rev 3506)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-06-05 22:39:47 UTC (rev 3507)
@@ -60,6 +60,8 @@
 
         Landmark* mCurrentLandmark;
         Landmark* mNextLandmark;
+
+        bool mNextLandmarkRequested;
     };
 }
 

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-05 22:10:01 UTC (rev 3506)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-05 22:39:47 UTC (rev 3507)
@@ -18,8 +18,8 @@
 
 namespace rl
 {
-    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark) : Job(true, true), 
-        mLandmarkPath("LandmarkPath" + name)
+    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark) 
+        : Job(true, true), mLandmarkPath("LandmarkPath" + name), mNextLandmarkRequested(false)
     {
         //the moving creature moves from the current position to the landmark
         mMovingCreature = movingCreature;
@@ -33,27 +33,24 @@
 
     bool CreatureWalkPathJob::execute(Ogre::Real time)
     {
-        if (mMovingCreature->getCreature()->getActor()->getPosition().x == mNextLandmark->getPosition().x 
-            && mMovingCreature->getCreature()->getActor()->getPosition().y == mNextLandmark->getPosition().y)
+        if(mNextLandmarkRequested)
         {
             if (mLandmarkPath.getPoints().size())
             {
                 mCurrentLandmark = mNextLandmark;
                 mNextLandmark = mLandmarkPath.getPoints().front();
                 mLandmarkPath.getPoints().pop_front();
+                mNextLandmarkRequested = false;
             }
             else
             {
                 mCurrentLandmark = mNextLandmark;
                 //@todo
             }
-            
         }
-        else if (mCurrentLandmark != mNextLandmark)
-        {
-            updateCreature(time);
-        }
 
+        updateCreature(true);
+
         return false;
     }
 
@@ -74,30 +71,32 @@
 
     void CreatureWalkPathJob::updateCreature(Ogre::Real time)
     {
-        //Max AU ist 0, deswegen erstmal vorl?ufig:
-        if(mMovingCreature->getCreature()->getAu() < 2.0f)
-            mMovingCreature->getCreature()->modifyAu(2,true);
+        static bool updatedDirection(false);
 
-        Ogre::Vector3 direction = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
+        Ogre::Vector3 direction = mNextLandmark->getPosition() - mMovingCreature->getCreature()->getActor()->getPosition();
+        direction.y = 0;
+        if( direction.squaredLength() < 0.04 )
+        {
+            mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3::ZERO, Ogre::Vector3::ZERO);
+            mNextLandmarkRequested = true;
+            updatedDirection = false;
+            return;
+        }
 
+        LOG_MESSAGE("",Ogre::StringConverter::toString(direction.squaredLength()));
+
         Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getActor()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
-        if(creatureViewVector.normalisedCopy().dotProduct(direction.normalisedCopy())  < 0.99)
+        creatureViewVector.y = 0;
+        Ogre::Quaternion rotation = creatureViewVector.getRotationTo(direction, Ogre::Vector3::UNIT_Y);
+        Ogre::Radian yaw = rotation.getYaw();
+        Ogre::Vector3 usedRotation(Ogre::Vector3::ZERO);
+        
+        if(!updatedDirection)
         {
-            //rotate until creature looks into the direction it wants to go to
-            //@todo: rotate
-            Ogre::Real rotate = Ogre::Math::ACos(creatureViewVector.normalisedCopy().dotProduct(direction.normalisedCopy())).valueRadians();
-            mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3(0,0,0),Ogre::Vector3(0,rotate,0));
-            //bool result = mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3(0,0,0), Ogre::Vector3(0,0.5,0));
+            usedRotation.y = yaw.valueRadians();
+            updatedDirection = true;
         }
-        else
-        {
-            //move creature to the target
-            mMovingCreature->setMovement(MovingCreature::MT_GEHEN, direction, Ogre::Vector3(0,0,0));
-        }
 
-        //make sure that the creature can't fail the landmark
-        //Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
-        if(direction.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getActor()->getPosition()) < 0)
-            mMovingCreature->getCreature()->getActor()->setPosition(mNextLandmark->getPosition());
+        mMovingCreature->setMovement(MovingCreature::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);
     }
 }



From timm at mail.berlios.de  Wed Jun  6 00:40:47 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 6 Jun 2007 00:40:47 +0200
Subject: [Dsa-hl-svn] r3508 - in modules/combattest: dsa scripts/maps
Message-ID: <200706052240.l55MelHC027439@sheep.berlios.de>

Author: timm
Date: 2007-06-06 00:40:33 +0200 (Wed, 06 Jun 2007)
New Revision: 3508

Modified:
   modules/combattest/dsa/gameobjectdefinitions.gof
   modules/combattest/scripts/maps/combattest.rb
Log:
updated test data for CreatureWalkPathJob

Modified: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-06-05 22:39:47 UTC (rev 3507)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-06-05 22:40:33 UTC (rev 3508)
@@ -24,5 +24,17 @@
     <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
     <property name="mass" type="REAL" data="30"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
+	<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
   </gameobjectclass>
 </GameObjectDefinitions>

Modified: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2007-06-05 22:39:47 UTC (rev 3507)
+++ modules/combattest/scripts/maps/combattest.rb	2007-06-05 22:40:33 UTC (rev 3508)
@@ -22,19 +22,21 @@
 $UI.setActiveCharacter($hero)
 $SCRIPT.log("Hero ready")
 
-wolf = $GOM.createGameObject("Wolf")
-wolf.placeIntoScene
-wolf.setPosition [0.0,0.0,-5.0]
-wolf.setAlignment(Creature::ALIGNMENT_ENEMY)
+#wolf = $GOM.createGameObject("Wolf")
+#wolf.placeIntoScene
+#wolf.setPosition [0.0,0.0,-6.0]
+#wolf.setAlignment(Creature::ALIGNMENT_ENEMY)
 
 wolf2 = $GOM.createGameObject("Wolf2")
 wolf2.placeIntoScene
 wolf2.setPosition [0.0,0.0,-3.0]
 wolf2.setAlignment(Creature::ALIGNMENT_ENEMY)
+wolf2.modifyAu(1000)
+#wolf2.setWert("ModAU", 10)
 
 movingCreature = MovingCreature.new(wolf2)
 
-job = CreatureWalkPathJob.new("TestWalkJob", movingCreature, Landmark.new("point", [0.0, 0.0, -10.0]))
+job = CreatureWalkPathJob.new("TestWalkJob", movingCreature, Landmark.new("point", [5.0, 0.0, -10.0]))
 job.addLandmark("1",[5.0,0.0,-20.0])
 job.addLandmark("2",[5.0,0.0,-15.0])
 $JS.addJob(job);



From timm at mail.berlios.de  Wed Jun  6 00:44:48 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 6 Jun 2007 00:44:48 +0200
Subject: [Dsa-hl-svn] r3509 - rl/trunk/engine/ai/src
Message-ID: <200706052244.l55MimV8001332@sheep.berlios.de>

Author: timm
Date: 2007-06-06 00:44:44 +0200 (Wed, 06 Jun 2007)
New Revision: 3509

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
removed debug messages

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-05 22:40:33 UTC (rev 3508)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-05 22:44:44 UTC (rev 3509)
@@ -83,8 +83,6 @@
             return;
         }
 
-        LOG_MESSAGE("",Ogre::StringConverter::toString(direction.squaredLength()));
-
         Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getActor()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
         creatureViewVector.y = 0;
         Ogre::Quaternion rotation = creatureViewVector.getRotationTo(direction, Ogre::Vector3::UNIT_Y);



From timm at mail.berlios.de  Wed Jun  6 00:53:12 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 6 Jun 2007 00:53:12 +0200
Subject: [Dsa-hl-svn] r3510 - rl/trunk/engine/core/src
Message-ID: <200706052253.l55MrCU2010277@sheep.berlios.de>

Author: timm
Date: 2007-06-06 00:52:54 +0200 (Wed, 06 Jun 2007)
New Revision: 3510

Modified:
   rl/trunk/engine/core/src/MovableText.cpp
Log:
First fix of the bounding boxes of the MovableText (aka bug 15)

Modified: rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2007-06-05 22:44:44 UTC (rev 3509)
+++ rl/trunk/engine/core/src/MovableText.cpp	2007-06-05 22:52:54 UTC (rev 3510)
@@ -402,9 +402,11 @@
         ptbuf->unlock();
 
         // update AABB/Sphere radius
-        mAABB = Ogre::AxisAlignedBox(min, max);
-        mRadius = Ogre::Math::Sqrt(maxSquaredRadius);
+        mAABB = Ogre::AxisAlignedBox(min/(300*currPos.x), max/(300*currPos.x));
+        //mAABB = Ogre::AxisAlignedBox(Vector3(0.001,0.001,0.001),Vector3(0.01, 0.01, 0.01));
 
+        mRadius = Ogre::Math::Sqrt(maxSquaredRadius)/(300*currPos.x);
+
         if (mUpdateColours)
         {
             this->_updateColours();



From blakharaz at mail.berlios.de  Wed Jun  6 21:50:08 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 21:50:08 +0200
Subject: [Dsa-hl-svn] r3511 - rl/trunk/engine/core/src
Message-ID: <200706061950.l56Jo8xo029046@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 21:50:05 +0200 (Wed, 06 Jun 2007)
New Revision: 3511

Modified:
   rl/trunk/engine/core/src/ContentModule.cpp
Log:
Clear scene when unloading a module

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2007-06-05 22:52:54 UTC (rev 3510)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2007-06-06 19:50:05 UTC (rev 3511)
@@ -23,6 +23,7 @@
 #include "CoreSubsystem.h"
 #include "RubyInterpreter.h"
 #include "SoundManager.h"
+#include "World.h"
 
 using namespace Ogre;
 
@@ -175,6 +176,7 @@
     void ContentModule::unload()
     {
         //TODO: unloadModule
+        CoreSubsystem::getSingleton().getWorld()->clearScene();
         mLoaded = false;
     }
 



From blakharaz at mail.berlios.de  Wed Jun  6 21:54:02 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 21:54:02 +0200
Subject: [Dsa-hl-svn] r3512 - in rl/trunk/engine/rules: include src
Message-ID: <200706061954.l56Js26t029229@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 21:53:56 +0200 (Wed, 06 Jun 2007)
New Revision: 3512

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/GameObject.cpp
Log:
Move EffectManager from Creature to GameObject

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-06-06 19:50:05 UTC (rev 3511)
+++ rl/trunk/engine/rules/include/Creature.h	2007-06-06 19:53:56 UTC (rev 3512)
@@ -29,7 +29,6 @@
 namespace rl
 {
     class Container;
-    class EffectManager;
     class Inventory;
     class Item;
     class Weapon;
@@ -675,14 +674,6 @@
              **/
             void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
 
-            /**
-             * Laesst einen Effekt auf der Kreatur wirken.
-             * @param effect Zeiger auf den Effekt.
-             * @ingroup CreatureRubyExports
-             **/
-            void addEffect(Effect* effect);
-            void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
-            void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
 
             virtual const Property getProperty(const Ogre::String& key) const;
             virtual void setProperty(const Ogre::String& key, const Property& value);
@@ -715,10 +706,6 @@
             virtual int getCurrentBe();
 
 
-            /**
-             * Ueberprueft die wirkenden Effekte auf Lebendigkeit
-             **/
-            void checkEffects();
 
         private:
 ///////////////////////////////////////////////////////////////////////////////
@@ -779,8 +766,6 @@
             /// Zuletzt zugewiesene Bewegungsart
             int mMovementType;
 
-            /// Verwaltet die Effekte die auf die Kreatur wirken.
-            EffectManager* mEffectManager;
             /// Zeigt auf die gerade aktive Waffe.
             EigenschaftMap mEigenschaften;
             TalentMap mTalente;

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-06-06 19:50:05 UTC (rev 3511)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-06-06 19:53:56 UTC (rev 3512)
@@ -29,6 +29,8 @@
 {
     class Actor;
     class Creature;
+    class Effect;
+    class EffectManager;
 
     /**
     * \brief Basisklasse aller spielrelevanten Objekte in RL.
@@ -70,8 +72,6 @@
         GameObject(unsigned int id);
         virtual ~GameObject();
 
-        virtual GameObject* clone();
-
         int getId() const;
 
         const Ogre::String getClassId() const;
@@ -158,6 +158,16 @@
 
         virtual void onStateChange(GameObjectState oldState, GameObjectState newState);
 
+        /**
+         * Laesst einen Effekt auf der Kreatur wirken.
+         * @param effect Zeiger auf den Effekt.
+         * @ingroup CreatureRubyExports
+         **/
+        void addEffect(Effect* effect);
+        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
+        void removeEffect(Effect* effect);
+
     protected:
         int mId;
         GameObjectState mState;
@@ -176,12 +186,20 @@
         /// Soll das GameObject ?berhaupt leuchten?
         bool mHighlightingEnabled;
 
+        /// Verwaltet die Effekte die auf die Kreatur wirken.
+        EffectManager* mEffectManager;
+
         Actor* createActor();
         void destroyActor();
 
         void doPlaceIntoScene();
         void doRemoveFromScene();
 
+        /**
+         * Ueberprueft die wirkenden Effekte auf Lebendigkeit
+         **/
+        void checkEffects();
+
     private:
         static int sNextGameObjectId;    
 

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-06-06 19:50:05 UTC (rev 3511)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-06-06 19:53:56 UTC (rev 3512)
@@ -18,8 +18,8 @@
 #include "Actor.h"
 #include "Container.h"
 #include "DsaManager.h"
-#include "EffectManager.h"
 #include "Eigenschaft.h"
+#include "EffectManager.h"
 #include "Exception.h"
 #include "Inventory.h"
 #include "Kampftechnik.h"
@@ -90,10 +90,8 @@
         mMovementType(0),
         mAlignment(ALIGNMENT_NEUTRAL)
     {
-        mEffectManager = new EffectManager();
         mQueryFlags |= QUERYFLAG_CREATURE;
 
-		//RlFail("Test");
 		setWert(WERT_MOD_AE, 0);
 		setWert(WERT_MOD_LE, 0);
 		setWert(WERT_MOD_AU, 0);
@@ -109,15 +107,12 @@
 		mEigenschaften[E_KONSTITUTION] = 0;
 		mEigenschaften[E_KOERPERKRAFT] = 0;
 
-        mEffectManager = new EffectManager();
-
 		mInventory = new Inventory(this);
     }
 
 	Creature::~Creature()
     {
         delete mInventory;
-	delete mEffectManager;
 
         for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
             delete it->second;
@@ -931,9 +926,6 @@
                 modifyAu((regeneratedAu-modifier)*factor);
             }
 
-
-
-
             if( getAu() == getAuMax() )
             {
                 lastSpielrunde = 0;
@@ -946,30 +938,6 @@
         modifyAu(regeneratedAuPerTime*factor);
     }
 
-	void Creature::addEffect(Effect* effect)
-	{
-		mEffectManager->addEffect(effect);
-	}
-    
-    void Creature::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
-    {
-      addEffect(effect);
-      mEffectManager->addTimeCheck(time, effect);
-    }
-    
-    void Creature::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
-    {
-      addEffect(effect);
-      mEffectManager->addDateCheck(date, effect);
-    }
-
-
-	void Creature::checkEffects()
-	{
-		/// @todo Nur einmal pro Aktion ausfuehren
-		mEffectManager->checkEffects();
-	}
-
     void Creature::setAlignment(Creature::Alignment alignment)
     {
         mAlignment = alignment;
@@ -994,65 +962,65 @@
         {
             mCurrentLe = value.toInt();
         }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            mCurrentAe = value.toInt();
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
         }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            mCurrentAu = value.toInt();
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toInt();
         }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            mErschoepfung = value.toInt();
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        //else if (key == Creature::PROPERTY_EFFECTS)
+        //{
+        //    mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
         //}
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            mEigenschaften.clear();
-            convertToMap(value.toMap(), mEigenschaften);
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
         }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            mTalente.clear();
-            convertToMap(value.toMap(), mTalente);
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
         }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            mKampftechniken.clear();
-            convertToMap(value.toMap(), mKampftechniken);
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
         }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            mVorteile.clear();
-            convertToMap(value.toMap(), mVorteile);
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
         }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            mNachteile.clear();
-            convertToMap(value.toMap(), mNachteile);
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
         }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
+//        else if (key == Creature::PROPERTY_SF)
+//        {
             ///@todo Sonderfertigkeiten
 //        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            mWerte.clear();
-            convertToMap(value.toMap(), mWerte);
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
         }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            IntPair ip = value.toIntPair();
-            mAp.total = ip.first;
-            mAp.used = ip.second;
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
         }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            mInventory->setProperty(Inventory::PROPERTY_CONTENT, value);
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory->setProperty(Inventory::PROPERTY_CONTENT, value);
         }
         else
         {
@@ -1074,63 +1042,63 @@
         {
             return Property(mCurrentLe);
         }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
             return Property(mCurrentAe);
         }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
             return Property(mCurrentAu);
         }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
             return Property(mErschoepfung);
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
+        //else if (key == Creature::PROPERTY_EFFECTS)
+        //{
         //    return Property(mEffectManager->getProperty(Creature::PROPERTY_EFFECTS));
         //}
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
             return Property(map);
         }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mTalente);
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
             return Property(map);
         }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
             return Property(map);
         }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
             return Property(map);
         }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
             return Property(map);
         }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
+//        else if (key == Creature::PROPERTY_SF)
+//        {
             ///@todo Sonderfertigkeiten
 //        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mWerte);
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
             return Property(map);
         }
-        else if (key == Creature::PROPERTY_AP)
-        {
+        else if (key == Creature::PROPERTY_AP)
+        {
             return Property(make_pair(mAp.total, mAp.used));
         }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            return mInventory->getProperty(Inventory::PROPERTY_CONTENT);
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            return mInventory->getProperty(Inventory::PROPERTY_CONTENT);
         }
         else
         {

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-06-06 19:50:05 UTC (rev 3511)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-06-06 19:53:56 UTC (rev 3512)
@@ -19,6 +19,7 @@
 #include "ActionManager.h"
 #include "Actor.h"
 #include "ActorManager.h"
+#include "EffectManager.h"
 #include "Exception.h"
 #include "ObjectStateChangeEventSource.h"
 #include "Property.h"
@@ -66,6 +67,8 @@
             mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
             mState(GOS_LOADED)
     {
+        mEffectManager = new EffectManager();
+
         // Standardactions registrieren
         Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
         if (defaultAction != NULL)
@@ -90,13 +93,9 @@
 
     GameObject::~GameObject(void)
     {
+    	delete mEffectManager;
     }
 
-    GameObject* GameObject::clone()
-    {
-        Throw(OperationNotSupportedException, "clone not yet implemented.");
-    }
-
     int GameObject::getId() const
     {
         return mId;
@@ -401,6 +400,34 @@
         mMass = mass;
     }
 
+    void GameObject::addEffect(Effect* effect)
+	{
+		mEffectManager->addEffect(effect);
+	}
+    
+    void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
+    {
+      addEffect(effect);
+      mEffectManager->addTimeCheck(time, effect);
+    }
+    
+    void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
+    {
+      addEffect(effect);
+      mEffectManager->addDateCheck(date, effect);
+    }
+
+	void GameObject::checkEffects()
+	{
+		/// @todo Nur einmal pro Aktion ausfuehren
+		mEffectManager->checkEffects();
+	}
+
+    void GameObject::removeEffect(Effect* effect)
+	{
+		mEffectManager->removeEffect(effect);
+	}
+    
     const Property GameObject::getProperty(const Ogre::String& key) const
     {
         Property prop;



From blakharaz at mail.berlios.de  Wed Jun  6 21:55:14 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 21:55:14 +0200
Subject: [Dsa-hl-svn] r3513 - in rl/trunk/engine/rules: include src
Message-ID: <200706061955.l56JtEJ5029329@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 21:55:11 +0200 (Wed, 06 Jun 2007)
New Revision: 3513

Modified:
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/src/Effect.cpp
Log:
Add properties to Effect

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-06-06 19:53:56 UTC (rev 3512)
+++ rl/trunk/engine/rules/include/Effect.h	2007-06-06 19:55:11 UTC (rev 3513)
@@ -19,12 +19,13 @@
 
 #include "RulesPrerequisites.h"
 #include "Date.h"
+#include "Properties.h"
 #include <set>
 
 
 namespace rl
 {
-	class _RlRulesExport Effect
+    class _RlRulesExport Effect : public PropertyHolder
 	{
 	public:
       
@@ -81,7 +82,7 @@
 
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);
-		virtual ~Effect();
+        virtual ~Effect() = 0 {};
 
         const CeGuiString getName() const;
         void setName(CeGuiString name);

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-06-06 19:53:56 UTC (rev 3512)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-06-06 19:55:11 UTC (rev 3513)
@@ -26,10 +26,6 @@
 		mQuantifier = QUANTIFIER_MULTIPLE;
 	}
 
-	Effect::~Effect()
-	{
-	}
-
 	const CeGuiString Effect::getName() const
 	{
 		return mName;



From blakharaz at mail.berlios.de  Wed Jun  6 21:58:22 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 21:58:22 +0200
Subject: [Dsa-hl-svn] r3514 - in rl/trunk/engine: rules rules/include
	rules/src script/swig
Message-ID: <200706061958.l56JwMF3029479@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 21:58:14 +0200 (Wed, 06 Jun 2007)
New Revision: 3514

Added:
   rl/trunk/engine/rules/include/EffectFactory.h
   rl/trunk/engine/rules/src/EffectFactory.cpp
Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Add factory for effects

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-06-06 19:58:14 UTC (rev 3514)
@@ -317,6 +317,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\EffectFactory.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\EffectManager.cpp"
 				>
 			</File>
@@ -507,6 +511,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\EffectFactory.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\EffectManager.h"
 				>
 			</File>

Added: rl/trunk/engine/rules/include/EffectFactory.h
===================================================================
--- rl/trunk/engine/rules/include/EffectFactory.h	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/rules/include/EffectFactory.h	2007-06-06 19:58:14 UTC (rev 3514)
@@ -0,0 +1,49 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __EffectFactory_H__
+#define __EffectFactory_H__
+
+#include "RulesPrerequisites.h"
+
+#include <OgreSingleton.h>
+
+namespace rl 
+{
+    class Effect;
+
+    class _RlRulesExport EffectFactory
+    {
+    public:
+        virtual ~EffectFactory() {};
+        virtual Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+    };
+
+    class _RlRulesExport EffectFactoryManager : public Ogre::Singleton<EffectFactoryManager>
+    {
+    public:
+        EffectFactoryManager();
+
+        Effect* createEffect(const Ogre::String& name, int stufe = 0);
+        void setEffectFactory(EffectFactory* factory);
+
+    private:
+        EffectFactory* mFactory;
+    };
+
+
+}
+
+#endif

Added: rl/trunk/engine/rules/src/EffectFactory.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectFactory.cpp	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/rules/src/EffectFactory.cpp	2007-06-06 19:58:14 UTC (rev 3514)
@@ -0,0 +1,53 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "EffectFactory.h"
+
+template <> 
+rl::EffectFactoryManager* Ogre::Singleton<rl::EffectFactoryManager>::ms_Singleton = 0;
+
+namespace rl
+{
+    EffectFactoryManager::EffectFactoryManager()
+    : mFactory(NULL)
+    {
+    }
+
+    Effect* EffectFactoryManager::createEffect(const Ogre::String& name, int stufe)
+    {
+        if (mFactory == NULL)
+        {
+            LOG_ERROR(Logger::RULES,
+                "Could not create effect "+name+". No factory registered");
+            return NULL;
+        }
+
+        Effect* rval = mFactory->createEffect(name, stufe);
+
+        if (rval == NULL)
+        {
+            LOG_ERROR(Logger::RULES,
+                "Effect "+name+" was not created.");
+        }
+
+        return rval;
+    }
+
+    void EffectFactoryManager::setEffectFactory(rl::EffectFactory *factory)
+    {
+        mFactory = factory;
+    }
+
+}

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-06-06 19:58:14 UTC (rev 3514)
@@ -20,6 +20,7 @@
 #include "DsaManager.h"
 //#include "XdimlLoader.h"
 #include "DsaDataLoader.h"
+#include "EffectFactory.h"
 #include "Logger.h"
 #include "MovingCreatureManager.h"
 #include "TimerManager.h"
@@ -61,6 +62,7 @@
 		mXdimlLoader = new XdimlLoader();
 		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
 		
+        new EffectFactoryManager();
         new GameObjectManager();
 		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");		
     }
@@ -75,6 +77,7 @@
         delete mActionManager;
         delete mXdimlLoader;
         delete GameObjectManager::getSingletonPtr();
+        delete EffectFactoryManager::getSingletonPtr();
     }
 
 	QuestBook* RulesSubsystem::getQuestBook()

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-06-06 19:58:14 UTC (rev 3514)
@@ -27,6 +27,7 @@
 #include "Date.h"
 #include "DsaManager.h"
 #include "Effect.h"
+#include "EffectFactory.h"
 #include "EigenschaftenStateSet.h"
 #include "GameObject.h"
 #include "GameObjectManager.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-06-06 19:55:11 UTC (rev 3513)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-06-06 19:58:14 UTC (rev 3514)
@@ -379,6 +379,11 @@
         bool isHighlightingEnabled();
         void setHighlightingEnabled( bool highlightenabled );
         
+        void addEffect(rl::Effect* effect);
+        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
+        void removeEffect(rl::Effect* effect);
+        
         virtual const rl::Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const rl::Property& value);
         virtual rl::PropertySet* getAllProperties() const;
@@ -573,7 +578,24 @@
 
         virtual Status getStatus();
         virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
+
+        virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
+        virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
+        virtual rl::PropertySet* getAllProperties() const = 0;
     };
+
+    class EffectFactory
+    {
+    public:
+        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+    };
+
+    class EffectFactoryManager
+    {
+    public:
+        void setEffectFactory(rl::EffectFactory* factory);
+        static rl::EffectFactoryManager& getSingleton();
+    };
     
     class Inventory 
     {
@@ -648,10 +670,6 @@
         
         rl::Inventory* getInventory();
         
-        void addEffect(Effect* effect);
-        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
-        
         void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
         static const int LEDAMAGE_NORMAL = 0;
         static const int LEDAMAGE_FIRE = 1;



From blakharaz at mail.berlios.de  Wed Jun  6 22:00:52 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 22:00:52 +0200
Subject: [Dsa-hl-svn] r3515 - in rl/trunk/engine/rules: include src
Message-ID: <200706062000.l56K0qws030023@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 22:00:46 +0200 (Wed, 06 Jun 2007)
New Revision: 3515

Modified:
   rl/trunk/engine/rules/include/Armor.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/src/Armor.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
Log:
Use effects for armor protection (create a matching effect when putting on armor, remove and delete the effect when removing the armor)

Modified: rl/trunk/engine/rules/include/Armor.h
===================================================================
--- rl/trunk/engine/rules/include/Armor.h	2007-06-06 19:58:14 UTC (rev 3514)
+++ rl/trunk/engine/rules/include/Armor.h	2007-06-06 20:00:46 UTC (rev 3515)
@@ -21,6 +21,8 @@
 
 namespace rl
 {
+    class Effect;
+
 	/// Objekte die sich mit Kampffertigkeiten einsetzen lassen
 	class _RlRulesExport Armor : public Item
 	{
@@ -71,6 +73,8 @@
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
+        virtual void onStateChange(GameObjectState oldState, GameObjectState newState);
+
 	private:
 		// R?stungsschutz
 		// Kopf
@@ -96,6 +100,8 @@
 		int mGRS;
 		// Gesamtbehinderung nach einfachem Modell
 		int mGBE;
+
+        Effect* mRsEffect;
 	};
 }
 #endif //__ARMOR_H__

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-06-06 19:58:14 UTC (rev 3514)
+++ rl/trunk/engine/rules/include/Item.h	2007-06-06 20:00:46 UTC (rev 3515)
@@ -79,16 +79,18 @@
         virtual void setState(GameObjectState state);
         void hold();
 
+        void setOwner(GameObject* go);
+        GameObject* getOwner() const;
+
         virtual const Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
     protected:
 		ItemType mItemType;
-
 		CeGuiString mImageName;
-
 		std::pair<int,int> mSize;
+        GameObject* mOwner;
 
 		void doHold();
 		void doLoose();

Modified: rl/trunk/engine/rules/src/Armor.cpp
===================================================================
--- rl/trunk/engine/rules/src/Armor.cpp	2007-06-06 19:58:14 UTC (rev 3514)
+++ rl/trunk/engine/rules/src/Armor.cpp	2007-06-06 20:00:46 UTC (rev 3515)
@@ -13,9 +13,12 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "Armor.h"
 
+#include "Creature.h"
 #include "DsaManager.h"
-#include "Armor.h"
+#include "Effect.h"
+#include "EffectFactory.h"
 
 using namespace std;
 
@@ -29,7 +32,8 @@
 	Armor::Armor(unsigned int id)
 		: Item(id),
 		mGRS(0),
-		mGBE(0)
+		mGBE(0),
+        mRsEffect(NULL)
 	{
         mQueryFlags |= QUERYFLAG_ARMOR;
 	}
@@ -144,6 +148,32 @@
         }
     }
 
+    void Armor::onStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+        if (oldState != newState)
+        {
+            if (newState == GOS_HELD)
+            {
+                if (getOwner())
+                {
+                    mRsEffect = EffectFactoryManager::getSingleton().createEffect(
+                        "Ruestung");
+                    mRsEffect->setProperty(Armor::PROPERTY_G_BE, Property(mGBE));
+                    mRsEffect->setProperty(Armor::PROPERTY_G_RS, Property(mGRS));
+                    getOwner()->addEffect(mRsEffect);
+                }
+            }
+            else if (oldState == GOS_HELD)
+            {
+                if (getOwner())
+                {
+                    getOwner()->removeEffect(mRsEffect);
+                    delete mRsEffect;
+                }
+            }
+        }
+    }
+
     const Property Armor::getProperty(const Ogre::String &key) const
     {
         if (key == Armor::PROPERTY_G_BE)

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-06-06 19:58:14 UTC (rev 3514)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-06-06 20:00:46 UTC (rev 3515)
@@ -175,7 +175,9 @@
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
-        (*slotIter).second->setItem(NULL);
+        slotIter->second->getItem()->setOwner(NULL);
+        slotIter->second->setItem(NULL);
+
 	}
 
     void Inventory::hold(Item* item, const CeGuiString& slotName)
@@ -186,7 +188,8 @@
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
         
-        (*slotIter).second->setItem(item);
+        slotIter->second->setItem(item);
+        item->setOwner(getOwner());
     }
 
 	bool Inventory::canHold(Item* item, const CeGuiString& slotName) const
@@ -197,7 +200,7 @@
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
         
-		return (*slotIter).second->isAllowed(item);
+		return slotIter->second->isAllowed(item);
     }
 
     Item* Inventory::getItem(const CeGuiString& slotName) const

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-06-06 19:58:14 UTC (rev 3514)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-06-06 20:00:46 UTC (rev 3515)
@@ -33,7 +33,8 @@
         : GameObject(id),
 		mItemType(ITEMTYPE_OTHER),
 		mImageName(""),
-		mSize(pair<int,int>(1,1))
+		mSize(pair<int,int>(1,1)),
+        mOwner(NULL)
     {
         mQueryFlags |= QUERYFLAG_ITEM;
     }
@@ -233,4 +234,14 @@
 
         return ps;
     }
+
+    void Item::setOwner(GameObject* owner)
+    {
+        mOwner = owner;
+    }
+
+    GameObject* Item::getOwner() const
+    {
+        return mOwner;
+    }
 }



From blakharaz at mail.berlios.de  Wed Jun  6 23:09:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 6 Jun 2007 23:09:18 +0200
Subject: [Dsa-hl-svn] r3516 - in rl/trunk/engine: ai/include core/src
	rules/include rules/src script/include script/swig
Message-ID: <200706062109.l56L9ISI002122@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-06 23:09:11 +0200 (Wed, 06 Jun 2007)
New Revision: 3516

Modified:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/include/WaypointProcessor.h
   rl/trunk/engine/script/include/ZoneProcessor.h
   rl/trunk/engine/script/swig/TypeRlProperty.swig
Log:
Fix Linux build


Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-06-06 21:09:11 UTC (rev 3516)
@@ -65,4 +65,4 @@
     };
 }
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-06 21:09:11 UTC (rev 3516)
@@ -51,7 +51,7 @@
 	 *
 	 * Maybe this should be used as interface instead of AbstractVehicle
 	 */
-	class _RlAiExport SteeringVehicle : protected SimpleVehicle_2
+	class _RlAiExport SteeringVehicle : public SimpleVehicle_2
 	{
 	public:
 		/** Constructor.

Modified: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-06-06 21:09:11 UTC (rev 3516)
@@ -78,7 +78,7 @@
 		setCastShadows( true ); 
 
         // Leerer String, keine Map laden
-        if( levelName.length()  )
+        if (levelName.length() != 0)
         {
             /// TODO - In den Sky-Sonnenpart verschieben
             mSceneMgr->setAmbientLight(ColourValue(0.55, 0.55, 0.55));
@@ -99,7 +99,9 @@
             }
         }
         else
+        {
             mSceneFile = "";
+        }
 
         initializeDefaultCamera();
         fireAfterSceneLoaded();

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/rules/include/Effect.h	2007-06-06 21:09:11 UTC (rev 3516)
@@ -82,7 +82,7 @@
 
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);
-        virtual ~Effect() = 0 {};
+        virtual ~Effect() {}
 
         const CeGuiString getName() const;
         void setName(CeGuiString name);

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-06-06 21:09:11 UTC (rev 3516)
@@ -10,6 +10,7 @@
 	DsaDataLoader.h \
 	DsaManager.h \
 	Effect.h \
+	EffectFactory.h \
 	EffectManager.h \
 	Eigenschaft.h \
 	EigenschaftenStateSet.h \

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-06-06 21:09:11 UTC (rev 3516)
@@ -14,6 +14,7 @@
 	DsaDataLoader.cpp \
 	DsaManager.cpp \
 	Effect.cpp \
+	EffectFactory.cpp \
 	EffectManager.cpp \
 	Eigenschaft.cpp \
 	EigenschaftenStateSet.cpp \

Modified: rl/trunk/engine/script/include/WaypointProcessor.h
===================================================================
--- rl/trunk/engine/script/include/WaypointProcessor.h	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/script/include/WaypointProcessor.h	2007-06-06 21:09:11 UTC (rev 3516)
@@ -29,4 +29,4 @@
 	};
 }
 
-#endif //__WaypointProcessor_H__
\ No newline at end of file
+#endif //__WaypointProcessor_H__

Modified: rl/trunk/engine/script/include/ZoneProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ZoneProcessor.h	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/script/include/ZoneProcessor.h	2007-06-06 21:09:11 UTC (rev 3516)
@@ -29,4 +29,4 @@
 	};
 }
 
-#endif //__ZoneNodeProcessor_H__
\ No newline at end of file
+#endif //__ZoneNodeProcessor_H__

Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-06-06 20:00:46 UTC (rev 3515)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-06-06 21:09:11 UTC (rev 3516)
@@ -83,16 +83,16 @@
     else if (TYPE(input) == T_HASH)
     {
         PropertyMap pmap;
-        VALUE keys = rb_funcall(input,rb_intern("keys"),0);
-        unsigned int size = RARRAY_LEN(keys);
-        for (unsigned int i=0; i<size; i++) 
-        {
-            VALUE key = RARRAY_PTR(keys)[i];
-            VALUE val = rb_hash_aref(input, key);
-            pmap[rl::CeGuiString(StringValuePtr(key))] 
-                = rl::convertValueToProperty(val);
-        }
-        rval.setValue(pmap);
+        VALUE keys = rb_funcall(input,rb_intern("keys"),0);
+        unsigned int size = RARRAY_LEN(keys);
+        for (unsigned int i=0; i<size; i++) 
+        {
+            VALUE key = RARRAY_PTR(keys)[i];
+            VALUE val = rb_hash_aref(input, key);
+            pmap[rl::CeGuiString(StringValuePtr(key))] 
+                = rl::convertValueToProperty(val);
+        }
+        rval.setValue(pmap);
     }
     
     return rval;
@@ -157,16 +157,16 @@
     else if (input.isMap())
     {
         PropertyMap pmap = input.toMap();
-        VALUE rval = rb_hash_new();
-        for (PropertyMap::const_iterator it = pmap.begin(); 
-            it != pmap.end(); ++it) 
-        {
-            rb_hash_aset(
-                rval,
-                rb_str_buf_new2(it->first.c_str()),
-                rl::convertPropertyToValue(it->second));
-        }
-        return rval;
+        VALUE rval = rb_hash_new();
+        for (PropertyMap::const_iterator it = pmap.begin(); 
+            it != pmap.end(); ++it) 
+        {
+            rb_hash_aset(
+                rval,
+                rb_str_buf_new2(it->first.c_str()),
+                rl::convertPropertyToValue(it->second));
+        }
+        return rval;
     }
 
     return Qnil;



From pnyx at mail.berlios.de  Thu Jun  7 12:09:25 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 7 Jun 2007 12:09:25 +0200
Subject: [Dsa-hl-svn] r3517 - rl/trunk/engine/rules/src
Message-ID: <200706071009.l57A9P0Q020385@sheep.berlios.de>

Author: pnyx
Date: 2007-06-07 12:09:22 +0200 (Thu, 07 Jun 2007)
New Revision: 3517

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
Animations changed in MovingCreature.cpp
melven, hit me if i did something wrong ;D
the animations and movement could be a bit faster, but i dunno how. I just adjusted the velocity to match the animation.

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-06 21:09:11 UTC (rev 3516)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-07 10:09:22 UTC (rev 3517)
@@ -100,7 +100,7 @@
                 if( omegaY < Degree(-20).valueRadians() )
                     mMovingCreature->setAnimation("drehen_rechts");
                 else
-                    mMovingCreature->setAnimation("idle");                            
+                    mMovingCreature->setAnimation("Idle");                            
             }
         }
         virtual void applyAuChanges(Ogre::Real elapsedTime)
@@ -225,7 +225,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 3.6f; 
+            velocity = mMovingCreature->getCurrentGS() / 8.0f; 
             return isPossible();
         }
         virtual bool isPossible() const
@@ -254,7 +254,7 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("gehen");
+            mMovingCreature->setAnimation("Walk");
         }
     };
 
@@ -266,7 +266,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 2.8f; 
+            velocity = mMovingCreature->getCurrentGS() / 3.8f; 
             return isPossible();
         }
         virtual bool isPossible() const
@@ -277,7 +277,7 @@
         virtual void applyAuChanges(Ogre::Real elapsedTime) {} // empty
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("rennen");
+            mMovingCreature->setAnimation("Run");
         }
     };
 
@@ -312,7 +312,7 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("rennen");
+            mMovingCreature->setAnimation("Run");
         }
         virtual void activate()
         {
@@ -389,7 +389,7 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("rennen");
+            mMovingCreature->setAnimation("Run");
         }
         virtual void activate()
         {
@@ -460,7 +460,7 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("rennen");
+            mMovingCreature->setAnimation("Run");
         }
     };
 
@@ -552,7 +552,7 @@
         {
             AbstractMovement::activate();
             mState = UPTODOWN;
-            mMovingCreature->setAnimation("idle_zu_hocke",1,1,"idle");
+            mMovingCreature->setAnimation("idle_zu_hocke",1,1,"Idle");
             mTimer = 0;
         }
         virtual bool canChangeToMovement(MovingCreature::MovementType id)
@@ -564,7 +564,7 @@
             if( mState == DOWN )
             {
                 mState = DOWNTOUP;
-                mMovingCreature->setAnimation("hocke_zu_stehen",1,1,"idle");
+                mMovingCreature->setAnimation("hocke_zu_stehen",1,1,"Idle");
                 mTimer = 0;
             }
         }
@@ -584,7 +584,7 @@
         {
             AbstractMovement::activate();
             mState = DOWNTOUP;
-            mMovingCreature->setAnimation("idle_absprung",1,1,"idle");
+            mMovingCreature->setAnimation("idle_absprung",1,1,"Idle");
             mTimer = 0;
             calculateBaseVelocity(mHeight);
 
@@ -695,7 +695,7 @@
                 else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
-                    mMovingCreature->setAnimation("idle_sprung_landung", 1, 1, "idle");
+                    mMovingCreature->setAnimation("idle_sprung_landung", 1, 1, "Idle");
                     mTimer = 0;
                 }
             }
@@ -748,7 +748,7 @@
         {
             AbstractMovement::activate();
             mState = DOWNTOUP;
-            mMovingCreature->setAnimation("rennen_absprung",1,1,"rennen");
+            mMovingCreature->setAnimation("rennen_absprung",1,1,"Run");
             mTimer = 0;
             calculateBaseVelocity(mWidth);
 
@@ -865,7 +865,7 @@
                 else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
-                    mMovingCreature->setAnimation("rennen_sprung_landung", 1, 1, "rennen");
+                    mMovingCreature->setAnimation("rennen_sprung_landung", 1, 1, "Run");
                     mTimer = 0;
                 }
             }



From pnyx at mail.berlios.de  Thu Jun  7 12:09:51 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 7 Jun 2007 12:09:51 +0200
Subject: [Dsa-hl-svn] r3518 - in modules: common/materials/model
	common/models ruchin/maps ruchin/materials/textures
	ruchin/models ruchin/scripts/maps
Message-ID: <200706071009.l57A9p7M020426@sheep.berlios.de>

Author: pnyx
Date: 2007-06-07 12:07:26 +0200 (Thu, 07 Jun 2007)
New Revision: 3518

Added:
   modules/common/models/men_human_female_backpack_leather_01.mesh
   modules/common/models/men_human_female_backpack_leather_01_smalll.mesh
   modules/ruchin/models/ruchin_terrain.material
   modules/ruchin/models/ruchin_terrain.mesh
Modified:
   modules/common/materials/model/obj_pants01.png
   modules/common/materials/model/obj_shortsleeve02_diffuse.png
   modules/common/models/men_human_female.skeleton
   modules/common/models/men_human_female_armor_garethplatte.mesh
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_feet_boots_01.mesh
   modules/common/models/men_human_female_hair_long_01_normal.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_head_02.mesh
   modules/common/models/men_human_female_leg_pants_01_long.mesh
   modules/common/models/men_human_female_torso.mesh
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/materials/textures/dome.png
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchintest.material
   modules/ruchin/models/dome_clouds_far.mesh
   modules/ruchin/models/dome_clouds_near.mesh
   modules/ruchin/scripts/maps/maptest.rb
Log:
men_human_female_xxx meshes rotated correctly
Some animations added to skeletonfile.

+ Little enviroment test in Ruchin.

Modified: modules/common/materials/model/obj_pants01.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/obj_shortsleeve02_diffuse.png
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_garethplatte.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_backpack_leather_01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_backpack_leather_01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_backpack_leather_01_smalll.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_backpack_leather_01_smalll.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_feet_boots_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_head_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_leg_pants_01_long.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-06-07 10:09:22 UTC (rev 3517)
+++ modules/ruchin/maps/ruchin.scene	2007-06-07 10:07:26 UTC (rev 3518)
@@ -166,7 +166,7 @@
 
 		</node>
 		<node name="dome_clouds_near" id="23" >
-			<position x="87.9637" y="196.696" z="-30.5118" />
+			<position x="0.0" y="0.0" z="0.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="5.08402" y="4.00516" z="4.00516" />
 			<entity
@@ -181,7 +181,7 @@
 
 		</node>
 		<node name="dome_clouds_far" id="25" >
-			<position x="119.321" y="358.829" z="-87.2079" />
+			<position x="0.0" y="0.0" z="0.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.7353" y="1.7353" z="1.7353" />
 			<entity
@@ -290,5 +290,20 @@
 
 		</node>
 		
+		<node name="Terrain" id="3" >
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Statue_01"
+				id="4"
+				meshFile ="ruchin_terrain.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Modified: modules/ruchin/materials/textures/dome.png
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchintest.material
===================================================================
--- modules/ruchin/models/Ruchintest.material	2007-06-07 10:09:22 UTC (rev 3517)
+++ modules/ruchin/models/Ruchintest.material	2007-06-07 10:07:26 UTC (rev 3518)
@@ -151,8 +151,8 @@
 	{
 		pass
 		{
-		 fog_override true
-			ambient 0.545098 0.545098 0.545098 1
+		 //fog_override true
+			ambient 1.0 1.0 1.0 1
 
 			scene_blend alpha_blend 
 

Modified: modules/ruchin/models/dome_clouds_far.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_clouds_near.mesh
===================================================================
(Binary files differ)

Added: modules/ruchin/models/ruchin_terrain.material
===================================================================
--- modules/ruchin/models/ruchin_terrain.material	2007-06-07 10:09:22 UTC (rev 3517)
+++ modules/ruchin/models/ruchin_terrain.material	2007-06-07 10:07:26 UTC (rev 3518)
@@ -0,0 +1,41 @@
+
+material ruchin_terrain: TerrainVColorBlending
+{
+
+   set_texture_alias black       nat_gras_01.dds
+   set_texture_alias red         nat_felsen_01.dds
+   set_texture_alias green       boden_02.png
+   set_texture_alias blue        nat_steingrund_01.dds
+   set_texture_alias alpha       Tiles.dds
+   set_texture_alias Lightingmap Lightingmap2.png
+   
+   technique
+   {
+      pass
+      {
+         fragment_program_ref
+         {
+            param_named scale_Detail4 float 0.050000 // Alpha
+         }
+
+         vertex_program_ref
+         {
+            param_named Light_Ambient float4 0.500000 0.500000 0.500000 1.000000
+
+            param_named scale_Texture0 float 0.018000 // Schwarz
+            param_named scale_Detail0 float 0.020000
+
+            param_named scale_Texture1 float 0.005700 // Rot
+            param_named scale_Detail1 float 0.100000
+
+            param_named scale_Texture2 float 0.028500 // Gruen
+            param_named scale_Detail2 float 0.060000
+
+            param_named scale_Texture3 float 0.008000 // Blau
+            param_named scale_Detail3 float 0.050000
+
+            param_named scale_Texture4 float 0.016000 // Alpha
+         }
+      }
+   }
+}
\ No newline at end of file

Added: modules/ruchin/models/ruchin_terrain.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/ruchin_terrain.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2007-06-07 10:09:22 UTC (rev 3517)
+++ modules/ruchin/scripts/maps/maptest.rb	2007-06-07 10:07:26 UTC (rev 3518)
@@ -15,7 +15,7 @@
 sunlight.getControlledObject().setDirection(-0.17101, -0.873647, 0.969846);
 sunlight.getControlledObject().setCastShadows(false);
 
-sunlight.getControlledObject().setDiffuseColour(1.0,1.0,1.0);
+sunlight.getControlledObject().setDiffuseColour(0.8,0.8,0.8);
 sunlight.getControlledObject().setSpecularColour(1.0,1.0,1.0);
 
 #sunlight.getControlledObject().setDiffuseColour(0.1,0.1,0.2);
@@ -31,7 +31,7 @@
 
 
 
-$World.setFog( World::FOG_EXP, [0.4,0.5,0.6,0.7], 0.00219, 0.5, 1.0);
+$World.setFog( World::FOG_EXP, [0.658,0.7568,0.9137,1.0], 0.00049, 0.8, 4.0);
 #$World.setAmbientLight( 0.3, 0.3, 0.3  );
 
 



From blakharaz at mail.berlios.de  Thu Jun  7 14:32:15 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 7 Jun 2007 14:32:15 +0200
Subject: [Dsa-hl-svn] r3519 - modules/common/scripts rl/trunk/engine/script
	rl/trunk/engine/script/include rl/trunk/engine/script/src
	rl/trunk/engine/script/swig
Message-ID: <200706071232.l57CWFqG014320@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-07 14:32:11 +0200 (Thu, 07 Jun 2007)
New Revision: 3519

Added:
   rl/trunk/engine/script/include/UnifiedFactory.h
   rl/trunk/engine/script/src/UnifiedFactory.cpp
Modified:
   modules/common/scripts/initialize_factories.rb
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/swig/RlScript.head.swig
   rl/trunk/engine/script/swig/RlScript.swig
Log:
Use one ruby factory class

Modified: modules/common/scripts/initialize_factories.rb
===================================================================
--- modules/common/scripts/initialize_factories.rb	2007-06-07 10:07:26 UTC (rev 3518)
+++ modules/common/scripts/initialize_factories.rb	2007-06-07 12:32:11 UTC (rev 3519)
@@ -1,4 +1,4 @@
-class RubyGameObjectFactory < GameObjectFactory
+class RubyClassFactory < UnifiedFactory
   def initialize()
     super();
   end
@@ -6,28 +6,22 @@
   def createRubyGameObject(classname, id)
     return Module.const_get(classname).new(id);
   end
-end
 
-class RubyBehaviourFactory < BehaviourFactory
-  def initialize()
-    super();
-  end
-
   def createBehaviour(classname)
     return Module.const_get(classname).new();
   end
-end
 
-class RubyTriggerFactory < TriggerFactory
-  def initialize()
-    super();
-  end
-
   def createTrigger(classname)
     return Module.const_get(classname).new();
   end
+
+  def createEffect(classname, stufe)
+    return Module.const_get(classname).new(id);
+  end
 end
 
-$GOM.setGameObjectFactory(RubyGameObjectFactory.new());
-$AI.setBehaviourFactory(RubyBehaviourFactory.new());
-$SCRIPT.setTriggerFactory(RubyTriggerFactory.new())
+factory = RubyClassFactory.new()
+$GOM.setGameObjectFactory(factory);
+$AI.setBehaviourFactory(factory);
+$SCRIPT.setTriggerFactory(factory)
+EffectFactoryManager.getSingleton().setEffectFactory(factory)

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-06-07 10:07:26 UTC (rev 3518)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-06-07 12:32:11 UTC (rev 3519)
@@ -351,6 +351,10 @@
 				RelativePath=".\include\TriggerFactory.h"
 				>
 			</File>
+			<File
+				RelativePath=".\include\UnifiedFactory.h"
+				>
+			</File>
 			<Filter
 				Name="map loading"
 				>

Added: rl/trunk/engine/script/include/UnifiedFactory.h
===================================================================
--- rl/trunk/engine/script/include/UnifiedFactory.h	2007-06-07 10:07:26 UTC (rev 3518)
+++ rl/trunk/engine/script/include/UnifiedFactory.h	2007-06-07 12:32:11 UTC (rev 3519)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __UnifiedFactory_H__
+#define __UnifiedFactory_H__
+
+#include "ScriptPrerequisites.h"
+#include "TriggerFactory.h"
+#include "EffectFactory.h"
+#include "GameObjectManager.h"
+#include "AgentManager.h"
+
+namespace rl
+{
+    class _RlScriptExport UnifiedFactory :
+        public TriggerFactory, 
+        public EffectFactory, 
+        public GameObjectFactory,
+        public BehaviourFactory
+    {
+    public:
+        virtual ~UnifiedFactory() {}
+
+		virtual Trigger* createTrigger(const Ogre::String& classname) = 0;
+        virtual Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+        virtual GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        virtual SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
+    };
+}
+
+#endif // __UnifiedFactory_H__

Added: rl/trunk/engine/script/src/UnifiedFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/UnifiedFactory.cpp	2007-06-07 10:07:26 UTC (rev 3518)
+++ rl/trunk/engine/script/src/UnifiedFactory.cpp	2007-06-07 12:32:11 UTC (rev 3519)
@@ -0,0 +1,9 @@
+#include "..\include\UnifiedFactory.h"
+
+UnifiedFactory::UnifiedFactory(void)
+{
+}
+
+UnifiedFactory::~UnifiedFactory(void)
+{
+}

Modified: rl/trunk/engine/script/swig/RlScript.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.swig	2007-06-07 10:07:26 UTC (rev 3518)
+++ rl/trunk/engine/script/swig/RlScript.head.swig	2007-06-07 12:32:11 UTC (rev 3519)
@@ -19,4 +19,5 @@
 #include "MapLoader.h"
 #include "ScriptSubsystem.h"
 #include "TriggerFactory.h"
+#include "UnifiedFactory.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-06-07 10:07:26 UTC (rev 3518)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-06-07 12:32:11 UTC (rev 3519)
@@ -39,4 +39,21 @@
 		virtual ~TriggerFactory();
 		virtual rl::Trigger* createTrigger(const Ogre::String& classname) = 0;
 	};
+
+	%feature("director") UnifiedFactory;    
+    class UnifiedFactory :
+        public rl::TriggerFactory, 
+        public rl::EffectFactory, 
+        public rl::GameObjectFactory,
+        public rl::BehaviourFactory
+    {
+    public:
+        virtual ~UnifiedFactory() {}
+
+		virtual rl::Trigger* createTrigger(const Ogre::String& classname) = 0;
+        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
+    };
+
 }
\ No newline at end of file



From blakharaz at mail.berlios.de  Thu Jun  7 22:37:56 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 7 Jun 2007 22:37:56 +0200
Subject: [Dsa-hl-svn] r3520 - in modules/regressiontest: dsa scripts
	scripts/maps
Message-ID: <200706072037.l57KbuUV013358@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-07 22:37:47 +0200 (Thu, 07 Jun 2007)
New Revision: 3520

Modified:
   modules/regressiontest/dsa/mapmeshparttest.gof
   modules/regressiontest/scripts/MergeableMeshTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/regressiontest/scripts/mckhero.rb
Log:
Test submesh bones in hero's inventory

Modified: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-06-07 12:32:11 UTC (rev 3519)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-06-07 20:37:47 UTC (rev 3520)
@@ -45,4 +45,14 @@
         <property name="geometrytype" type="STRING" data="ellipsoid"/>
     </gameobjectclass>
 
+    <gameobjectclass classid="kroetenhaut" baseclass="Armor">
+        <property name="name" type="STRING" data="Kroetenhaut"/>
+        <property name="description" type="STRING" data="Eine Ruestung aus mit Nieten verstaerktem Leder"/>
+        <property name="meshfile" type="STRING" data="men_human_female_armor_kroetenhaut.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="g_be" type="INT" data="2"/>
+        <property name="g_rs" type="INT" data="3"/>
+		<property name="itemtype" type="INT" data="32"/>
+    </gameobjectclass>
+
 </GameObjectDefinitions>

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-07 12:32:11 UTC (rev 3519)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-07 20:37:47 UTC (rev 3520)
@@ -6,9 +6,18 @@
 
         $SCRIPT.log(">MergeableMeshTest Start");
 
+        $SCRIPT.log(">>MergeableMeshTest Actor Start");
         testMergeableActor();
+        $SCRIPT.log(">>MergeableMeshTest Actor End");
+
+        $SCRIPT.log(">>MergeableMeshTest Slots Start");
         testMergeableSlots();
+        $SCRIPT.log(">>MergeableMeshTest Slots End");
 
+        $SCRIPT.log(">>MergeableMeshTest Inventory Start");
+        testMergeableInventory();
+        $SCRIPT.log(">>MergeableMeshTest Inventory End");
+
         $SCRIPT.log(">MergeableMeshTest End");
     end
 
@@ -90,4 +99,9 @@
       actorToAdd2.placeIntoScene(rel_pos([4.5, 0, 2]))
       baseActor4.merge(actorToAdd4, "head")
     end
+    
+    def testMergeableInventory()
+      testObj = $GOM.createGameObject("kroetenhaut")
+      $hero.getInventory().hold(testObj, "Armor")
+    end
 end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-07 12:32:11 UTC (rev 3519)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-07 20:37:47 UTC (rev 3520)
@@ -34,17 +34,17 @@
 
 $SCRIPT.log("begin tests.");
 
-         DoorTest.new([0, 0, -5])
-          NpcTest.new([-5, 0, 5])
-   NpcCapsuleTest.new([0, 0, 5])
-         TimeTest.new([-5, 0, -5])
-ErrorHandlingTest.new([-10, 0, 5])
-    InventoryTest.new([0, 0, 10])
-  JobSequenceTest.new([5, 0, -5])
-       EffectTest.new([5, 0, 5])
-        SoundTest.new([10, 0, 10])
-    LightzoneTest.new([-10, 0, -5])
-   MapLoadingTest.new([-5, 0, -10])
+#         DoorTest.new([0, 0, -5])
+#          NpcTest.new([-5, 0, 5])
+#   NpcCapsuleTest.new([0, 0, 5])
+#         TimeTest.new([-5, 0, -5])
+#ErrorHandlingTest.new([-10, 0, 5])
+#    InventoryTest.new([0, 0, 10])
+#  JobSequenceTest.new([5, 0, -5])
+#       EffectTest.new([5, 0, 5])
+#        SoundTest.new([10, 0, 10])
+#    LightzoneTest.new([-10, 0, -5])
+#   MapLoadingTest.new([-5, 0, -10])
 MergeableMeshTest.new([10, 0, 0])
 
 

Modified: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-06-07 12:32:11 UTC (rev 3519)
+++ modules/regressiontest/scripts/mckhero.rb	2007-06-07 20:37:47 UTC (rev 3520)
@@ -31,13 +31,13 @@
 
 	$SCRIPT.log("Inventar konfigurieren.");
 	inv = getInventory();
-	inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
-	inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-	inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
-        inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
+	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING);
+	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING);
+	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, false);
+	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
+    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, false);
 
 	#addSounds()
         $SCRIPT.log("done.");



From josch at mail.berlios.de  Thu Jun  7 22:45:01 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Thu, 7 Jun 2007 22:45:01 +0200
Subject: [Dsa-hl-svn] r3521 - in rl/trunk/engine: core/include core/src
	script/swig
Message-ID: <200706072045.l57Kj18Q014018@sheep.berlios.de>

Author: josch
Date: 2007-06-07 22:44:34 +0200 (Thu, 07 Jun 2007)
New Revision: 3521

Added:
   rl/trunk/engine/core/include/LinearSoundFadeFunctor.h
   rl/trunk/engine/core/include/SoundFadeFunctor.h
   rl/trunk/engine/core/include/SoundFadeJob.h
   rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
   rl/trunk/engine/core/src/SoundFadeFunctor.cpp
   rl/trunk/engine/core/src/SoundFadeJob.cpp
Modified:
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/src/Makefile.am
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
Log:
Started sound fading:
- SoundFadeJob handles fading for one sound.
- SoundFadeFunctor is abstract base class for calculating the fading curves.
- LinearFadeFunctor generates a linear fading curve.
TODO: Better SoundFadeFunctors, sound test

Added: rl/trunk/engine/core/include/LinearSoundFadeFunctor.h
===================================================================
--- rl/trunk/engine/core/include/LinearSoundFadeFunctor.h	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/include/LinearSoundFadeFunctor.h	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,36 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_LINEAR_SOUND_FADE_FUNCTOR_H__
+#define __RL_LINEAR_SOUND_FADE_FUNCTOR_H__
+
+#include "CorePrerequisites.h"
+#include "SoundFadeFunctor.h"
+
+namespace rl {
+    class SoundObject;
+
+    class _RlCoreExport LinearSoundFadeFunctor : public SoundFadeFunctor
+    {
+    public:
+        LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+
+        virtual int operator()(Ogre::Real time, SoundObject* sound);
+
+    };
+}
+
+#endif

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/include/Makefile.am	2007-06-07 20:44:34 UTC (rev 3521)
@@ -30,6 +30,7 @@
 	LightFadeJob.h \
 	LightObject.h \
 	LineSetPrimitive.h \
+	LinearSoundFadeFunctor.h \
 	ListenerMovable.h \
 	ListenerObject.h \
 	MergeableMeshObject.h \
@@ -56,6 +57,8 @@
 	SoundManager.h \
 	SoundObject.h \
 	SoundResource.h \
+	SoundFadeJob.h \
+	SoundFadeFunctor.h \
 	TrackAnimation.h \
 	Trigger.h \
 	World.h \

Added: rl/trunk/engine/core/include/SoundFadeFunctor.h
===================================================================
--- rl/trunk/engine/core/include/SoundFadeFunctor.h	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/include/SoundFadeFunctor.h	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,41 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_SOUND_FADE_FUNCTOR_H__
+#define __RL_SOUND_FADE_FUNCTOR_H__
+
+#include "CorePrerequisites.h"
+
+
+namespace rl {
+    class SoundObject;
+
+    class _RlCoreExport SoundFadeFunctor
+    {
+    public:
+        SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+
+        virtual int operator()(Ogre::Real time, SoundObject* sound) = 0;
+
+    protected:
+        int mStartVolume;
+        int mEndVolume;
+        int mDiff;
+        Ogre::Real mDuration;
+    };
+}
+
+#endif

Added: rl/trunk/engine/core/include/SoundFadeJob.h
===================================================================
--- rl/trunk/engine/core/include/SoundFadeJob.h	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/include/SoundFadeJob.h	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_SOUND_FADE_JOB_H__
+#define __RL_SOUND_FADE_JOB_H__
+
+#include "CorePrerequisites.h"
+#include <OgreSingleton.h>
+
+#include "Job.h"
+
+namespace rl {
+
+    class SoundObject;
+    class SoundFadeFunctor;
+
+    class _RlCoreExport SoundFadeJob : public Job
+    {
+    public:
+        SoundFadeJob(SoundObject* soundObject, SoundFadeFunctor* functor, bool destroyWhenDone);
+
+        virtual bool execute(Ogre::Real time);
+        virtual void discard();
+
+    protected:
+        /// The object we're operating on
+        SoundObject* mSoundObject;
+        /// The time passed since job start.
+        Ogre::Real mTime;
+        /// Functor which calculates the fading curve.
+        SoundFadeFunctor* mSoundFadeFunctor;
+    };
+}
+
+#endif

Added: rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,38 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "LinearSoundFadeFunctor.h"
+
+
+namespace rl
+{
+    LinearSoundFadeFunctor::LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration) :
+        SoundFadeFunctor(startvolume, endvolume, duration)
+    {
+    }
+
+    int LinearSoundFadeFunctor::operator()(Ogre::Real time, SoundObject* sound)
+    {
+        Ogre::Real factor = time / mDuration;
+        if (factor > 1.0)
+        {
+            return -1; // Done
+        } else {
+            return floor(mStartVolume + factor * mDiff);
+        }
+    }  
+    
+}

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/src/Makefile.am	2007-06-07 20:44:34 UTC (rev 3521)
@@ -36,6 +36,7 @@
 	LineSetPrimitive.cpp \
 	ListenerObject.cpp \
 	ListenerMovable.cpp \
+	LinearSoundFadeFunctor.cpp \
 	MergeableMeshObject.cpp \
 	MeshAnimation.cpp \
 	MeshObject.cpp \
@@ -57,6 +58,8 @@
 	Sound.cpp \
 	SoundEvents.cpp \
 	SoundResource.cpp \
+	SoundFadeJob.cpp \
+	SoundFadeFunctor.cpp \
 	TrackAnimation.cpp \
 	World.cpp \
 	Zone.cpp \

Added: rl/trunk/engine/core/src/SoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,31 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "SoundFadeFunctor.h"
+
+
+namespace rl
+{
+    SoundFadeFunctor::SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration) :
+        mDuration(duration),
+        mEndVolume(endvolume),
+        mStartVolume(startvolume)
+    {
+        mDiff = mEndVolume - mStartVolume;
+    }
+
+
+}

Added: rl/trunk/engine/core/src/SoundFadeJob.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-06-07 20:44:34 UTC (rev 3521)
@@ -0,0 +1,61 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "SoundFadeJob.h"
+#include "SoundFadeFunctor.h"
+#include "SoundObject.h"
+
+namespace rl
+{
+    SoundFadeJob::SoundFadeJob(SoundObject* soundObject, SoundFadeFunctor* fadeFunctor, bool destroyWhenDone)
+        : Job(true, destroyWhenDone),
+        mSoundObject(soundObject),
+        mSoundFadeFunctor(fadeFunctor),
+        mTime(0)
+    {
+    }
+
+    bool SoundFadeJob::execute(Ogre::Real time)
+    {
+        // Precondition: mLightObject != NULL
+        if (mSoundObject == NULL)
+        {
+            discard();
+            return true;
+        }
+
+        // add passed time to total time
+        mTime += time;
+        int volume = (*mSoundFadeFunctor)(mTime, mSoundObject);
+
+        // Are we done now?
+        if (volume < 0)
+        {
+            discard();
+            return true;
+        }
+        mSoundObject->setVolume(volume);
+        
+        return false;
+    }
+
+    void SoundFadeJob::discard()
+    {
+        mSoundObject->setVolume(0);
+        mSoundObject->stop();
+    }
+
+}

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-06-07 20:44:34 UTC (rev 3521)
@@ -60,6 +60,10 @@
 #include "Zone.h"
 #include "ZoneManager.h"
 //#include "LightFadeJob.h"
+#include "SoundFadeJob.h"
+#include "SoundFadeFunctor.h"
+#include "LinearSoundFadeFunctor.h"
+
 #undef message
 #undef send
 %}

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-06-07 20:37:47 UTC (rev 3520)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-06-07 20:44:34 UTC (rev 3521)
@@ -925,4 +925,30 @@
     virtual void setProperties(const rl::PropertySet* props);
 };
 
+class SoundFadeJob : public rl::Job
+{
+public:
+    SoundFadeJob(SoundObject* soundObject, rl::SoundFadeFunctor* functor, bool destroyWhenDone);
+
+    virtual bool execute(Ogre::Real time);
+    virtual void discard();
+};
+
+class SoundFadeFunctor
+{
+public:
+    SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+
+    virtual int operator()(Ogre::Real time, rl::SoundObject* sound) = 0;
+};
+
+class LinearSoundFadeFunctor : public rl::SoundFadeFunctor
+{
+public:
+    LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+
+    virtual int operator()(Ogre::Real time, rl::SoundObject* sound);
+};
+
+
 }



From melven at mail.berlios.de  Thu Jun  7 23:38:03 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 7 Jun 2007 23:38:03 +0200
Subject: [Dsa-hl-svn] r3522 - rl/trunk/engine/rules/src
Message-ID: <200706072138.l57Lc33v019140@sheep.berlios.de>

Author: melven
Date: 2007-06-07 23:37:56 +0200 (Thu, 07 Jun 2007)
New Revision: 3522

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
adopted velocity to new animations

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-07 20:44:34 UTC (rev 3521)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-07 21:37:56 UTC (rev 3522)
@@ -72,7 +72,7 @@
             body->getMassMatrix(mass, inertia);
 
             Vector3 vel = mMovingCreature->getVelocity();
-            Real delay (2 * PhysicsManager::getSingleton().getMaxTimestep());
+            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
             if(vel.squaredLength() > mVelocity.squaredLength())
                 delay *= 1.5;
             force = mass * (mVelocity - vel) / delay;
@@ -225,7 +225,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 8.0f; 
+            velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f; 
             return isPossible();
         }
         virtual bool isPossible() const
@@ -254,7 +254,11 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("Walk");
+            Real step = 1.49; // the width of a step
+            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
+            //Real length = charMesh->getAnimation("Run")->getLength();
+            Real length = 5./3.;
+            mMovingCreature->setAnimation("Walk", -mMovingCreature->getVelocity().z / (step / length) );
         }
     };
 
@@ -266,7 +270,7 @@
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 3.8f; 
+            velocity = mMovingCreature->getCurrentGS() / 2.8f; 
             return isPossible();
         }
         virtual bool isPossible() const
@@ -277,7 +281,14 @@
         virtual void applyAuChanges(Ogre::Real elapsedTime) {} // empty
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("Run");
+            Real step = 2.835; // the width of a step
+            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
+            // trynerror:
+            step += 0.5;
+            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
+            //Real length = charMesh->getAnimation("Run")->getLength();
+            Real length = 5./3.;
+            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
         }
     };
 
@@ -312,7 +323,14 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("Run");
+            Real step = 2.835; // the width of a step
+            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
+            // trynerror:
+            step += 0.5;
+            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
+            //Real length = charMesh->getAnimation("Run")->getLength();
+            Real length = 5./3.;
+            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
         }
         virtual void activate()
         {
@@ -389,7 +407,14 @@
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
         {
-            mMovingCreature->setAnimation("Run");
+            Real step = 2.835; // the width of a step
+            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
+            // trynerror:
+            step += 1.5;
+            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
+            //Real length = charMesh->getAnimation("Run")->getLength();
+            Real length = 5./3.;
+            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
         }
         virtual void activate()
         {
@@ -1031,7 +1056,6 @@
             }
             mesh->stopAllAnimations();
 
-
             mesh->startAnimation(name, speed, timesToPlay);
             mLastAnimationName = name;
             mLastAnimationSpeed = speed;



From pnyx at mail.berlios.de  Fri Jun  8 11:33:55 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Fri, 8 Jun 2007 11:33:55 +0200
Subject: [Dsa-hl-svn] r3523 - modules/common/models
Message-ID: <200706080933.l589Xtii031646@sheep.berlios.de>

Author: pnyx
Date: 2007-06-08 11:33:51 +0200 (Fri, 08 Jun 2007)
New Revision: 3523

Modified:
   modules/common/models/men_human_female.skeleton
Log:
Run animation fixed

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)



From timm at mail.berlios.de  Fri Jun  8 13:41:51 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 8 Jun 2007 13:41:51 +0200
Subject: [Dsa-hl-svn] r3524 - rl/trunk/engine/core
Message-ID: <200706081141.l58BfpK7022205@sheep.berlios.de>

Author: timm
Date: 2007-06-08 13:41:47 +0200 (Fri, 08 Jun 2007)
New Revision: 3524

Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
Log:
vs project for soundfadejob

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-06-08 09:33:51 UTC (rev 3523)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-06-08 11:41:47 UTC (rev 3524)
@@ -461,6 +461,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\LinearSoundFadeFunctor.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\LineSetPrimitive.h"
 				>
 			</File>
@@ -557,6 +561,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\SoundFadeFunctor.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\SoundFadeJob.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\SoundManager.h"
 				>
 			</File>
@@ -714,6 +726,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\LinearSoundFadeFunctor.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\LineSetPrimitive.cpp"
 				>
 			</File>
@@ -798,6 +814,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\SoundFadeFunctor.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\SoundFadeJob.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\SoundManager.cpp"
 				>
 			</File>



From tanis at mail.berlios.de  Sat Jun  9 00:49:31 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sat, 9 Jun 2007 00:49:31 +0200
Subject: [Dsa-hl-svn] r3525 - in rl/trunk/engine: startup ui ui/include
	ui/src
Message-ID: <200706082249.l58MnVXS025543@sheep.berlios.de>

Author: tanis
Date: 2007-06-09 00:47:58 +0200 (Sat, 09 Jun 2007)
New Revision: 3525

Added:
   rl/trunk/engine/ui/include/CombatWindow.h
   rl/trunk/engine/ui/src/CombatWindow.cpp
Modified:
   rl/trunk/engine/startup/RlStartup2005.vcproj
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/CharacterController.h
   rl/trunk/engine/ui/include/CombatCharacterController.h
   rl/trunk/engine/ui/include/CutsceneCharacterController.h
   rl/trunk/engine/ui/include/DialogCharacterController.h
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/AboutWindow.cpp
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
   rl/trunk/engine/ui/src/CharacterController.cpp
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/CharacterStateWindow.cpp
   rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
   rl/trunk/engine/ui/src/CommandMapper.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/GameLoggerWindow.cpp
   rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
   rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/InGameMenuWindow.cpp
   rl/trunk/engine/ui/src/InfoPopup.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/JournalWindow.cpp
   rl/trunk/engine/ui/src/LogWindow.cpp
   rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
   rl/trunk/engine/ui/src/MainMenuWindow.cpp
   rl/trunk/engine/ui/src/MessageWindow.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
   rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
   rl/trunk/engine/ui/src/PlaylistWindow.cpp
   rl/trunk/engine/ui/src/ProgressWindow.cpp
   rl/trunk/engine/ui/src/SaveLoadWindow.cpp
   rl/trunk/engine/ui/src/SoundConfig.cpp
   rl/trunk/engine/ui/src/SubtitleWindow.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Restructuring of input handling. InputManager doesn't preview input events anymore. Instead it only initialises and delegates input to the active control state, which handles all input now.
Specialised Control States handle the input they know about and deligate all other events back to the base class, which handles cegui and global game actions.
Now control states can decide for themself whether something is sent to cegui or handled inside the controller.

Modified: rl/trunk/engine/startup/RlStartup2005.vcproj
===================================================================
--- rl/trunk/engine/startup/RlStartup2005.vcproj	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/startup/RlStartup2005.vcproj	2007-06-08 22:47:58 UTC (rev 3525)
@@ -41,7 +41,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -131,7 +131,7 @@
 				Optimization="2"
 				InlineFunctionExpansion="1"
 				OmitFramePointers="true"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="true"
 				RuntimeLibrary="2"
@@ -217,7 +217,7 @@
 				Optimization="2"
 				InlineFunctionExpansion="1"
 				OmitFramePointers="true"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="true"
 				RuntimeLibrary="2"

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-06-08 22:47:58 UTC (rev 3525)
@@ -425,6 +425,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\CombatWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\ConfigComponent.h"
 					>
 				</File>
@@ -614,6 +618,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\CombatWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\ConfigComponent.cpp"
 					>
 				</File>

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -43,13 +43,13 @@
 	{
 	public:
 
-		enum WindowType
+		enum WindowInputType
 		{
-			WND_SHOW,
-			WND_MOUSE_INPUT,
-			WND_KEYBOARD_INPUT,
-			WND_ALL_INPUT,
+			WIT_NONE = 0x00,
+			WIT_MOUSE_INPUT = 0x01,
+			WIT_KEYBOARD_INPUT = 0x02
 		};
+
 		virtual ~AbstractWindow();	
 
 		CEGUI::Window* getWindow();
@@ -72,7 +72,7 @@
 		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
 		static CEGUI::Window* getRoot();
 
-		WindowType getWindowType();
+		int getWindowInputType();
 
         virtual bool isVisible();
         virtual void setVisible(bool visible, bool destroyAfterHide = false);
@@ -88,7 +88,7 @@
 	protected:
 		AbstractWindow(
 			const CeGuiString& xmlfile, 
-			WindowType type, 
+			int inputType, 
 			bool closeOnEscape = true,
 			bool modal = false);
 
@@ -112,7 +112,7 @@
 
 	private:
 		
-		WindowType mWindowType;
+		int mWindowInputType;
 		CeGuiString mNamePrefix;
 		CeGuiString mName;
 		bool mModal;

Modified: rl/trunk/engine/ui/include/CharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/CharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -19,8 +19,12 @@
 
 #include "UiPrerequisites.h"
 #include "GameTask.h"
+
 #include <OgreNewt.h>
 
+#include <OISMouse.h>
+#include <OISKeyboard.h>
+
 namespace rl {
 
     class Actor;
@@ -31,7 +35,7 @@
     /**
      * This class handles character control via user input.
      */
-	class _RlUiExport CharacterController
+    class _RlUiExport CharacterController : public OIS::KeyListener, public OIS::MouseListener
     {
 	public:
 
@@ -39,7 +43,8 @@
          *  @throw NullPointerException if camera or character is NULL.
          *  @throw InvalidArgumentException if character is not placed in the scene.
          */
-        CharacterController(CommandMapper* commandMapper, Actor* camera, Person* character);
+        CharacterController(CommandMapper* commandMapper, Actor* camera, Person* character,
+            ControlStateType type);
 		virtual ~CharacterController()= 0;
 
         virtual void pause() = 0;
@@ -47,14 +52,24 @@
 
         virtual void run(Ogre::Real elapsedTime) = 0;
 
-		virtual bool injectMouseDown(int mouseButtonMask) { return false; }
-		virtual bool injectMouseUp(int mouseButtonMask) { return false; }
-		virtual bool injectKeyDown(int keycode) { return false; }
-		virtual bool injectKeyUp(int keycode) { return false; }	
+        virtual bool mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
+        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
+        virtual bool mouseMoved(const OIS::MouseEvent& evt);
+        virtual bool keyPressed(const OIS::KeyEvent& evt);
+        virtual bool keyReleased(const OIS::KeyEvent& evt);
 
 	protected:
 		static bool startAction(const CeGuiString& actionName, Creature* character = NULL);
 
+        /// Returns true, if there is at least one window open,
+        /// that requires keyboard and/or mouse input. 
+        bool isCeguiActive() const;
+
+        /// Returns true, if the key event should be injected into CEGUI
+        /// This is the case, if an open window requests key input and it is
+        /// an input or navigation key.
+        bool CharacterController::sendKeyToCeGui(const OIS::KeyEvent& evt) const;
+
         Person* mCharacter;
 
         Actor* mCameraActor;
@@ -64,6 +79,8 @@
         OgreNewt::Body* mCharBody;
 
 		CommandMapper* mCommandMapper;
+
+        ControlStateType mType;
     };
 }
 #endif

Modified: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -24,8 +24,9 @@
 
 namespace rl {
 
-    class CombatManager;
     class Combat;
+    class CombatManager;
+    class CombatWindow;
 
 	class _RlUiExport CombatCharacterController : public CharacterController
 	{
@@ -41,15 +42,11 @@
 
 		void run(Ogre::Real elapsedTime);
 
-		virtual bool injectMouseDown(int mouseButtonMask);
-		virtual bool injectMouseUp(int mouseButtonMask);
-		virtual bool injectKeyDown(int keycode);
-		virtual bool injectKeyUp(int keycode);
-
     private:
         CombatManager* mCombatManager;
         // Current combat that is controlled.
         Combat* mCombat;
+        CombatWindow* mCombatWindow;
         HalfSphereSelector mEnemySelector;
 	};
 }

Added: rl/trunk/engine/ui/include/CombatWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CombatWindow.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/CombatWindow.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -0,0 +1,32 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __CombatWindow_H__
+#define __CombatWindow_H__
+
+#include "UiPrerequisites.h"
+#include "AbstractWindow.h"
+
+namespace rl {
+	
+	class _RlUiExport CombatWindow : public AbstractWindow
+	{
+	public:
+		CombatWindow();
+	};
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/CutsceneCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -41,8 +41,6 @@
         void setCameraPosition(const Ogre::Vector3& pos);
         void setCameraOrientation(const Ogre::Quaternion& orient);
         void lookAt(const Ogre::Vector3& point);
-
-        virtual bool injectKeyUp(int keycode);
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/DialogCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogCharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/DialogCharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -61,13 +61,12 @@
 		void setDialogPartner(Actor* partner);
 
 		/// Antwort eines der Dialogf?hrenden
-		void response(
-			Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
+		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
 
 		void setDialogWindow(DialogWindow* dialog);
 		void setSubtitleWindow(SubtitleWindow* subtitles);
 	
-		bool injectMouseUp(int mouseButtonMask);
+        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
 	private:
 		/// Die Zielkameraposition in lokalen Koordinaten
 		Ogre::Vector3 mTargetCameraPosition;

Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -46,8 +46,8 @@
 
 		virtual void run(Ogre::Real elapsedTime);
 
-		bool injectKeyDown(int keycode);
-		bool injectKeyUp(int keycode);
+        virtual bool keyPressed(const OIS::KeyEvent& evt);
+        virtual bool keyReleased(const OIS::KeyEvent& evt);
 
 	    void toggleCameraCollision();
 	    void resetCamera();

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -39,9 +39,7 @@
 
     class _RlUiExport InputManager
         :    public Ogre::Singleton<InputManager>,
-            public GameTask,
-            public OIS::KeyListener,
-            public OIS::MouseListener
+            public GameTask
     {
     public:
 
@@ -56,16 +54,6 @@
 
         void run(Ogre::Real elapsedTime);
 
-        void registerAbstractWindow(AbstractWindow* window);
-        void unregisterAbstractWindow(AbstractWindow* window);
-        bool isCeguiActive() const;
-
-        virtual bool mousePressed(const OIS::MouseEvent & arg, OIS::MouseButtonID id);
-        virtual bool mouseReleased(const OIS::MouseEvent & arg, OIS::MouseButtonID id);
-        virtual bool mouseMoved(const OIS::MouseEvent &arg);
-        virtual bool keyPressed(const OIS::KeyEvent &arg);
-        virtual bool keyReleased(const OIS::KeyEvent &arg);
-
         CeGuiString getKeyName(int scancode, int syskeys);
         CeGuiString getKeyName(int combinedKeyCode);
         int getScanCode(const CeGuiString& name);
@@ -92,14 +80,14 @@
 
         CharacterController* getCharacterController() const;
 
+        int getModifierCode() const;
+        const CEGUI::utf8& getKeyChar(int keycode, int modifiers) const;
+
     private:
         enum { NUM_MOUSE_BUTTON=4, NUM_KEYS=256 };
         enum Modifiers {ALT_MASK = 1, CTRL_MASK = 2, SHIFT_MASK = 4, SUPER_MASK = 8};
 
         void initializeOis(Ogre::RenderWindow* wnd);
-        bool sendKeyToCeGui(const OIS::KeyEvent& e) const;
-        int getModifierCode() const;
-        const CEGUI::utf8& getKeyChar(int keycode, int modifiers) const;
 
         Ogre::Vector3 mSavedMouseState;
 
@@ -120,10 +108,6 @@
         typedef std::map<int, CeGuiString> KeyCommandMap;
         KeyCommandMap mKeyRubyCommand;
 
-        int mNumActiveWindowsMouseInput;
-        int mNumActiveWindowsKeyboardInput;
-        int mNumActiveWindowsAllInput;
-
         typedef std::stack<CharacterController*> ControlStateStack;
         typedef std::vector<CharacterController*> ControlStateVector;
         ControlStateStack mControlStates;

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -75,10 +75,9 @@
         */
         void resetCamera();
 
-		virtual bool injectMouseDown(int mouseButtonMask);
-		virtual bool injectMouseUp(int mouseButtonMask);
-		virtual bool injectKeyDown(int keycode);
-		virtual bool injectKeyUp(int keycode);		
+        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
+        virtual bool keyPressed(const OIS::KeyEvent& evt);
+        virtual bool keyReleased(const OIS::KeyEvent& evt);
 
         // Overrides from DebugVisualisable
         virtual DebugVisualisableFlag getFlag() const;

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -36,6 +36,7 @@
     class CharacterStateWindow;
     class CharacterSheetWindow;
     class CloseConfirmationWindow;
+    class CombatWindow;
     class Console;
     class Container;
     class Creature;
@@ -105,6 +106,7 @@
 
         DialogWindow* getDialogWindow();
         SubtitleWindow* getSubtitleWindow();
+        CombatWindow* getCombatWindow();
 
         void checkForErrors();
         GameLoggerWindow* getGameLogger();
@@ -139,6 +141,7 @@
         MainMenuWindow* mMainMenuWindow;
         CloseConfirmationWindow* mCloseConfirmationWindow;
         GameSettings* mGameSettings;
+        CombatWindow* mCombatWindow;
     };
 }
 

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/include/WindowManager.h	2007-06-08 22:47:58 UTC (rev 3525)
@@ -45,8 +45,17 @@
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
 
+        /// Returns the combined input mask of all open windows
+        int getWindowInputMask() const;
+
+        /// Callback for Windows, called when there visibility is changed.
+        void _visiblityChanged(AbstractWindow* window, bool isVisible);
+
 	private:
 		std::list<AbstractWindow*> mWindowList;
+
+        unsigned short mNumActiveWindowsMouseInput;
+        unsigned short mNumActiveWindowsKeyboardInput;
 	};
 }
 

Modified: rl/trunk/engine/ui/src/AboutWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AboutWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/AboutWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -22,7 +22,7 @@
 namespace rl {
 
 AboutWindow::AboutWindow() :
-    AbstractWindow("aboutwindow.xml", WND_MOUSE_INPUT)
+    AbstractWindow("aboutwindow.xml", WIT_MOUSE_INPUT)
 {
     getWindow("AboutWindow/Text")->setText("Rastullahs Lockenpracht\n\nCopyright 2003-2007 Team Pantheon\
 \n\nBenutzte Bibliotheken: Ogre, fmod, Newton, boost, ...");

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -23,7 +23,6 @@
 #include "UiSubsystem.h"
 #include "AbstractWindow.h"
 #include "CeGuiHelper.h"
-#include "InputManager.h"
 #include "WindowManager.h"
 #include "WindowFadeJob.h"
 #include "JobScheduler.h"
@@ -37,10 +36,10 @@
 
 	int AbstractWindow::sNumAbstractWindows = 0;
 
-	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, WindowType type, bool closeOnEscape, bool modal)
+	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
 	: mVisible(false),
 		mModal(modal),
-		mWindowType(type),
+		mWindowInputType(inputType),
 		mCloseOnEscape(closeOnEscape)
 	{
         LOG_MESSAGE(Logger::UI, 
@@ -117,18 +116,17 @@
 		{
 			if (visible)
 			{
-				InputManager::getSingleton().registerAbstractWindow(this);
                 JobScheduler::getSingleton().addJob(
                     new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
 			}
 			else
 			{
-				InputManager::getSingleton().unregisterAbstractWindow(this);
                 JobScheduler::getSingleton().addJob(
                     new WindowFadeJob(this,
                     destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
                     0.0f));
 			}
+            WindowManager::getSingleton()._visiblityChanged(this, visible);
             mVisible = visible;
 		}
 	}
@@ -148,9 +146,9 @@
 		return mCloseOnEscape;
 	}
 
-	AbstractWindow::WindowType AbstractWindow::getWindowType()
+	int AbstractWindow::getWindowInputType()
 	{
-		return mWindowType;
+		return mWindowInputType;
 	}
 
 	CEGUI::Window* AbstractWindow::getRoot()

Modified: rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -38,7 +38,7 @@
 	const int MAX_NUM_SUBACTIONS = 7;
 
 	ActionChoiceWindow::ActionChoiceWindow(Person* actor)
-		:	AbstractWindow("actionchoicewindow.xml", WND_MOUSE_INPUT),
+		:	AbstractWindow("actionchoicewindow.xml", WIT_MOUSE_INPUT),
 			mActor(actor)
 	{
 		mHint = getWindow("ActionChoiceWindow/Hint");

Modified: rl/trunk/engine/ui/src/CharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -17,15 +17,19 @@
 
 #include <OgreSceneManager.h>
 
+#include "AbstractWindow.h"
 #include "Action.h"
 #include "ActionManager.h"
 #include "Actor.h"
 #include "CameraObject.h"
+#include "CommandMapper.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
 #include "Exception.h"
+#include "InputManager.h"
 #include "Person.h"
 #include "PhysicalThing.h"
+#include "WindowManager.h"
 #include "World.h"
 
 using namespace Ogre;
@@ -33,13 +37,14 @@
 namespace rl {
 
 	CharacterController::CharacterController(CommandMapper* commandMapper,
-        Actor* camera, Person* character)
+        Actor* camera, Person* character, ControlStateType type)
 		: mCharacter(character),
         mCameraActor(camera),
 		mCharacterActor(NULL),
 		mCamBody(NULL),
 		mCharBody(NULL),
-        mCommandMapper(commandMapper)
+        mCommandMapper(commandMapper),
+        mType(type)
 	{
 		if (mCameraActor == NULL)
 		{
@@ -117,7 +122,125 @@
 			character->doAction(actionName, character, character);
 		}
 		return true;
+	}
 
-		return false;
-	}
+    bool CharacterController::mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
+    {
+        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
+        {
+            CEGUI::System::getSingleton().injectMouseButtonDown(
+                static_cast<CEGUI::MouseButton>(id));
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    bool CharacterController::mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
+    {
+        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
+        {
+            CEGUI::System::getSingleton().injectMouseButtonUp(static_cast<CEGUI::MouseButton>(id));
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    bool CharacterController::mouseMoved(const OIS::MouseEvent& evt)
+    {
+        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
+        {
+            CEGUI::Renderer* renderer = CEGUI::System::getSingleton().getRenderer();
+            CEGUI::System::getSingleton().injectMouseMove(evt.state.X.rel, evt.state.Y.rel);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    bool CharacterController::keyPressed(const OIS::KeyEvent& evt)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        if (sendKeyToCeGui(evt))
+        {
+            CEGUI::System& cegui = CEGUI::System::getSingleton();
+            cegui.injectKeyUp(evt.key);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    bool CharacterController::keyReleased(const OIS::KeyEvent& evt)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        if (sendKeyToCeGui(evt))
+        {
+            CEGUI::System& cegui = CEGUI::System::getSingleton();
+            cegui.injectKeyDown(evt.key);
+            cegui.injectChar(im->getKeyChar(evt.key, im->getModifierCode()));
+            return true;
+        }
+        else
+        {
+            int code = CommandMapper::encodeKey(evt.key, im->getModifierCode());
+
+            // First see, if a control state action is defined
+		    CeGuiString action = mCommandMapper->getControlStateAction(code, mType);
+            if (action == "")
+            {
+                // No. So try global actions.
+                action = mCommandMapper->getGlobalAction(code);
+            }
+            return startAction(action, mCharacter);
+        }
+    }
+
+    bool CharacterController::isCeguiActive() const
+    {
+        return WindowManager::getSingleton().getWindowInputMask() != 0;
+    }
+
+    bool CharacterController::sendKeyToCeGui(const OIS::KeyEvent& evt) const
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // Wenn kein Fenster mit Tastatureingabe aktiv ist, kriegt CEGUI keine KeyEvents
+        if ((WindowManager::getSingleton().getWindowInputMask()
+            & AbstractWindow::WIT_KEYBOARD_INPUT) == 0)
+        {
+            return false;
+        }
+
+        // ---- Tastatureingabe gefordert ----
+
+        // Tasten, die Zeichen liefern sollen an CEGUI gesendet werden
+        if (im->getKeyChar(evt.key, im->getModifierCode()) != 0)
+        {
+            return true;
+        }
+
+        if (evt.key == OIS::KC_RETURN
+            || evt.key == OIS::KC_HOME || evt.key == OIS::KC_END
+            || evt.key == OIS::KC_LEFT || evt.key == OIS::KC_RIGHT
+            || evt.key == OIS::KC_BACK || evt.key == OIS::KC_DELETE
+            || evt.key == OIS::KC_UP   || evt.key == OIS::KC_DOWN
+            || evt.key == OIS::KC_RMENU)
+        {
+            return true;
+        }
+
+        return false;
+    }
 }

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -33,7 +33,7 @@
 namespace rl {
 
 CharacterSheetWindow::CharacterSheetWindow()
-	: AbstractWindow("charactersheet.xml", WND_MOUSE_INPUT)
+	: AbstractWindow("charactersheet.xml", WIT_MOUSE_INPUT)
 {
 	mTalentTable = getMultiColumnList("CharacterSheet/TalentSheet/Table");
 	mTalentTable->addColumn((utf8*)"Talent", 0, cegui_reldim(0.5));

Modified: rl/trunk/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -30,7 +30,7 @@
 namespace rl {
 
 CharacterStateWindow::CharacterStateWindow()
-: AbstractWindow("characterstatewindow.xml", WND_SHOW, false),
+: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
 	mCharacter(NULL)
 {
 	mLP = getProgressBar("CharacterStateWindow/LP");

Modified: rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -22,7 +22,7 @@
 namespace rl {
 
 CloseConfirmationWindow::CloseConfirmationWindow()
-: AbstractWindow("closeconfirmationwindow.xml", AbstractWindow::WND_ALL_INPUT, true, true)
+: AbstractWindow("closeconfirmationwindow.xml", WIT_MOUSE_INPUT | WIT_KEYBOARD_INPUT, true, true)
 {
 	getPushButton("CloseConfirmationWindow/YesButton")->subscribeEvent(
 		CEGUI::Window::EventMouseClick,

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -19,26 +19,32 @@
 #include "Actor.h"
 #include "Combat.h"
 #include "CombatManager.h"
+#include "CombatWindow.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
 #include "InputManager.h"
+#include "MeshObject.h"
 #include "Person.h"
 #include "PhysicalThing.h"
 #include "Selector.h"
+#include "WindowFactory.h"
 #include "World.h"
 
 namespace rl {
     CombatCharacterController::CombatCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character),
+        : CharacterController(cmdMapper, camera, character, CST_COMBAT),
           mCombatManager(CombatManager::getSingletonPtr()),
           mCombat(NULL),
+          mCombatWindow(NULL),
           mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
         mEnemySelector.setFilter(filter);
+
+        mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
     }
 
 	CombatCharacterController::~CombatCharacterController()
@@ -51,6 +57,10 @@
         mCameraActor->getPhysicalThing()->freeze();
         mCharacterActor->getPhysicalThing()->freeze();
 
+        ///\todo Richtig machen, nur tempor?r Ani hier setzen.
+        static_cast<MeshObject*>(mCharacterActor->getControlledObject())
+            ->startAnimation("kampf_schwerter_idle");
+
         // Set reference to character
         mEnemySelector.setCheckVisibility(true, mCharacter);
         mEnemySelector.track(mCharacter);
@@ -84,12 +94,16 @@
                 return;
             }
         }
+        mCombatWindow->setVisible(true);
     }
 
     void CombatCharacterController::pause()
     {
+        mCombatWindow->setVisible(false);
+
         mCameraActor->getPhysicalThing()->unfreeze();
         mCharacterActor->getPhysicalThing()->unfreeze();
+        static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
 
         // reset current combat, in order to avoid a potential dangling pointer
         mCombat = NULL;
@@ -98,24 +112,4 @@
 	void CombatCharacterController::run(Ogre::Real elapsedTime)
     {
     }
-
-	bool CombatCharacterController::injectMouseDown(int mouseButtonMask)
-    {
-        return false;
-    }
-
-    bool CombatCharacterController::injectMouseUp(int mouseButtonMask)
-    {
-        return false;
-    }
-
-    bool CombatCharacterController::injectKeyDown(int keycode)
-    {
-        return false;
-    }
-
-    bool CombatCharacterController::injectKeyUp(int keycode)
-    {
-        return false;
-    }
 }

Added: rl/trunk/engine/ui/src/CombatWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CombatWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -0,0 +1,29 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "CombatWindow.h"
+#include "CoreSubsystem.h"
+#include "ContentModule.h"
+
+using namespace CEGUI;
+
+namespace rl {
+
+    CombatWindow::CombatWindow() : AbstractWindow("combatwindow.xml", WIT_NONE)
+    {
+    }
+
+}

Modified: rl/trunk/engine/ui/src/CommandMapper.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapper.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CommandMapper.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -169,11 +169,12 @@
 
             for (size_t i = 0; i < keys.size(); i++)
             {
-                cmdMap[getKeyCode(keys[i])] = CeGuiString(it->first);
+                int keycode = getKeyCode(keys[i]);
+                cmdMap[keycode] = CeGuiString(it->first);
                 LOG_MESSAGE(Logger::UI,
                     Ogre::String("Key ") + keys[i] + " ("
-                    + StringConverter::toString(getKeyCode(keys[i]))
-                    + ") is assigned to command " + it->first + " globally");
+                    + StringConverter::toString(keycode)
+                    + ") is assigned to command " + it->first);
             }
         }
     }

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/Console.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -31,7 +31,7 @@
 namespace rl 
 {
 	Console::Console() : 
-		AbstractWindow("console.xml", WND_KEYBOARD_INPUT)
+		AbstractWindow("console.xml", WIT_KEYBOARD_INPUT)
 	{
 		using namespace CEGUI;
 		

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -33,7 +33,7 @@
 	int ContainerContentWindow::sItemCount = 0;
 
 	ContainerContentWindow::ContainerContentWindow(Container* container) 
-		: AbstractWindow("containercontentwindow.xml", WND_MOUSE_INPUT),
+		: AbstractWindow("containercontentwindow.xml", WIT_MOUSE_INPUT),
 		mContainer(container)
 	{
 		mContentWindow = getWindow("ContainerContentWindow/Content");

Modified: rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -27,7 +27,7 @@
 namespace rl {
 
 	CutsceneCharacterController::CutsceneCharacterController(CommandMapper* cmdMapper,
-        Actor* camera) : CharacterController(cmdMapper, camera, NULL)
+        Actor* camera) : CharacterController(cmdMapper, camera, NULL, CST_CUTSCENE)
 	{
 	}
 
@@ -67,9 +67,4 @@
         dynamic_cast<Ogre::Camera*>(mCameraActor->getControlledObject()->getMovableObject())
             ->lookAt(point);
     }
-
-    bool CutsceneCharacterController::injectKeyUp(int keycode)
-	{
-		return startAction(mCommandMapper->getControlStateAction(keycode, CST_CUTSCENE));		
-	}
 }

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -35,7 +35,7 @@
 
 namespace rl
 {
-    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WND_SHOW),
+    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WIT_NONE),
           mMessageText(),
           mPageCaption(),
           mPageText(),

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -49,7 +49,7 @@
 
     DialogCharacterController::DialogCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character),
+        : CharacterController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
         mCurrFadeTextTime(0),
@@ -281,10 +281,11 @@
         }
     }
 
-    bool DialogCharacterController::injectMouseUp(int mouseButtonMask)
+    bool DialogCharacterController::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id)
     {
 
-        if( mTextShown && (mCurrFadeTextTime+0.25)<mTotalFadeTextTime )
+        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
         {
             mCurrFadeTextTime = -1;
 

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -45,7 +45,7 @@
 const CeGuiString DialogWindow::DIALOG_EXIT = "EXIT";
 
 DialogWindow::DialogWindow(GameLoggerWindow* gamelogger)
-  : AbstractWindow("dialogwindow.xml", WND_MOUSE_INPUT, false),
+  : AbstractWindow("dialogwindow.xml", WIT_MOUSE_INPUT, false),
 	mBot(NULL), 
 	mCurrentResponse(NULL),
     mCurrentResponseText(""),

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -15,6 +15,7 @@
 */
 
 #include "FreeFlightCharacterController.h"
+
 #include "CoreSubsystem.h"
 #include "ConfigurationManager.h"
 #include "Exception.h"
@@ -34,7 +35,7 @@
 
 	FreeFlightCharacterController::FreeFlightCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-		: CharacterController(cmdMapper, camera, character),
+		: CharacterController(cmdMapper, camera, character, CST_FREEFLIGHT),
 		mMovementSpeed(5.0f),
 		mSpeedRange(0.03f, 90.0f),
 		mSpeedIncrement(0.02f),
@@ -108,6 +109,8 @@
 
 	void FreeFlightCharacterController::run(Real elapsedTime)
 	{
+        if (isCeguiActive()) return;
+
 		InputManager* im = InputManager::getSingletonPtr();
 
 		// Fetch current movement state
@@ -224,26 +227,22 @@
         mPitch = Degree(0);
 	}
 
-	bool FreeFlightCharacterController::injectKeyDown(int keycode)
+    bool FreeFlightCharacterController::keyPressed(const OIS::KeyEvent& evt)
 	{
-        int scancode;
-        mCommandMapper->decodeKey(keycode, &scancode, NULL);
-        int movement = mCommandMapper->getMovement(scancode);
+        int movement = mCommandMapper->getMovement(evt.key);
 
-
 		if (movement != MOVE_NONE)
 		{
 			mCurrentMovementState |= movement;
 			return true;
 		}
+
 		return false;
 	}
 
-	bool FreeFlightCharacterController::injectKeyUp(int keycode)
+    bool FreeFlightCharacterController::keyReleased(const OIS::KeyEvent& evt)
 	{
-        int scancode;
-        mCommandMapper->decodeKey(keycode, &scancode, NULL);
-        int movement = mCommandMapper->getMovement(scancode);
+        int movement = mCommandMapper->getMovement(evt.key);
 
 		if (movement != MOVE_NONE)
 		{
@@ -252,6 +251,8 @@
 		}
         else
         {
+            InputManager* im = InputManager::getSingletonPtr();
+            int keycode = CommandMapper::encodeKey(evt.key, im->getModifierCode());
             CeGuiString command = mCommandMapper->getControlStateAction(keycode, CST_FREEFLIGHT);
             if (command == "back_to_character_movement")
             {
@@ -265,14 +266,11 @@
             }
             else 
             {
-                return startAction(command);
+                return CharacterController::keyReleased(evt);
             }
         }
-			
-		return false;
 	}
 
-
     int FreeFlightCharacterController::userProcess()
     {
         if (m_body0 == mCamBody || m_body1 == mCamBody)

Modified: rl/trunk/engine/ui/src/GameLoggerWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -27,7 +27,7 @@
 CEGUI::colour GameLoggerWindow::COLOR_MISC(      0xFFFFFFFF);
 
 GameLoggerWindow::GameLoggerWindow() : 
-	AbstractWindow("gameloggerwindow.xml", WND_SHOW)
+	AbstractWindow("gameloggerwindow.xml", WIT_NONE)
 {
 	mLog = getListbox ("GameLogger/Log");
 	bindDestroyWindowToXButton();

Modified: rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -35,7 +35,7 @@
     //------------------------------------------------------- Constructor
 
 	GameObjectInfoWindow::GameObjectInfoWindow(GameObject* go, Creature* character) 
-	 :  AbstractWindow("gameobjectinfowindow.xml", WND_MOUSE_INPUT),
+	 :  AbstractWindow("gameobjectinfowindow.xml", WIT_MOUSE_INPUT),
 		mGameObject(go),
 		mCharacter(character),
 		mNumActionButtons(0)

Modified: rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -35,7 +35,7 @@
     //------------------------------------------------------- Constructor
 
 	GameObjectPropsWindow::GameObjectPropsWindow() :
-        AbstractWindow("gameobjectpropswindow.xml", WND_MOUSE_INPUT)
+        AbstractWindow("gameobjectpropswindow.xml", WIT_MOUSE_INPUT)
 	{
         // Get access to the tab control
         mTabPane = getTabControl("GameObjectPropsWindow/PropertiesTabPane");

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -26,7 +26,7 @@
 namespace rl
 {
     GameSettings::GameSettings()
-        : AbstractWindow("gamesettings.xml", WND_MOUSE_INPUT)
+        : AbstractWindow("gamesettings.xml", WIT_MOUSE_INPUT)
     {
         // Register sound driver components
         std::list<SoundDriver*> soundDriverList = SoundManager::getSingleton().getDriverList();

Modified: rl/trunk/engine/ui/src/InGameMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -33,7 +33,7 @@
 namespace rl {
 
 InGameMenuWindow::InGameMenuWindow()
-: AbstractWindow("ingamemenuwindow.xml", WND_MOUSE_INPUT)
+: AbstractWindow("ingamemenuwindow.xml", WIT_MOUSE_INPUT)
 {
 	update();
 }

Modified: rl/trunk/engine/ui/src/InfoPopup.cpp
===================================================================
--- rl/trunk/engine/ui/src/InfoPopup.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/InfoPopup.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -22,7 +22,7 @@
 namespace rl {
 
 	InfoPopup::InfoPopup()
-		: AbstractWindow("infopopup.xml", AbstractWindow::WND_SHOW, false)
+		: AbstractWindow("infopopup.xml", AbstractWindow::WIT_NONE, false)
 	{
 		mErrorIcon = getWindow("InfoPopup/ErrorIcon");
 		mQuestIcon = getWindow("InfoPopup/QuestIcon");

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -60,9 +60,6 @@
 namespace rl {
 
     InputManager::InputManager(Ogre::RenderWindow* win) :
-        mNumActiveWindowsMouseInput(0),
-        mNumActiveWindowsKeyboardInput(0),
-        mNumActiveWindowsAllInput(0),
         mKeyMapNormal(),
         mKeyMapShift(),
         mKeyMapAlt(),
@@ -131,9 +128,6 @@
         mMouse->getMouseState().width = width;
         mMouse->getMouseState().height = height;
 
-        mKeyboard->setEventCallback(this);
-        mMouse->setEventCallback(this);
-
         LOG_DEBUG(Logger::UI, "Done initializing input manager.");
     }
 
@@ -158,192 +152,27 @@
         }
     }
 
-    bool InputManager::mousePressed(const OIS::MouseEvent & e, MouseButtonID id)
-    {
-        if (isCeguiActive())
-        {
-            System::getSingleton().injectMouseButtonDown(
-                static_cast<CEGUI::MouseButton>(id));
-        }
-        else
-        {
-            if (!mControlStates.empty())
-            {
-                mControlStates.top()->injectMouseDown(
-                    CommandMapper::encodeKey(id, getModifierCode()));
-            }
-        }
-        return true;
-    }
-
     bool InputManager::isMouseButtonDown( OIS::MouseButtonID buttonID )
     {
         OIS::MouseState ms = mMouse->getMouseState();
         return ms.buttonDown( buttonID );
     }
 
-
-    bool InputManager::mouseReleased(const OIS::MouseEvent & arg, MouseButtonID id)
-    {
-        if (isCeguiActive())
-        {
-            System::getSingleton().injectMouseButtonUp(
-                static_cast<CEGUI::MouseButton>(id));
-            // return true;
-        }
-        else if (!mControlStates.empty())
-        {
-            mControlStates.top()->injectMouseUp(
-                CommandMapper::encodeKey(id, getModifierCode()));
-        }
-
-        return true;
-    }
-
-    bool InputManager::mouseMoved(const OIS::MouseEvent &arg)
-    {
-        if (isCeguiActive())
-        {
-            CEGUI::Renderer* renderer  = System::getSingleton().getRenderer();
-            System::getSingleton().injectMouseMove(arg.state.X.rel, arg.state.Y.rel);
-
-            return true;
-        }
-        return false;
-    }
-
     Ogre::Real InputManager::getMouseRelativeX() const
     {
-        if (isCeguiActive())
-        {
-            return 0;
-            return mSavedMouseState.x;
-        }
         return (float)mMouse->getMouseState().X.rel;
     }
 
     Ogre::Real InputManager::getMouseRelativeY() const
     {
-        if (isCeguiActive())
-        {
-            return 0;
-            return mSavedMouseState.y;
-        }
         return (float)mMouse->getMouseState().Y.rel;
     }
 
     Ogre::Real InputManager::getMouseRelativeZ() const
     {
-        if (isCeguiActive())
-        {
-            return 0;
-            return mSavedMouseState.z;
-        }
         return (float)mMouse->getMouseState().Z.rel;
     }
 
-    bool InputManager::sendKeyToCeGui(const OIS::KeyEvent& e) const
-    {
-        // Fenster, die alle Inputs wollen
-        if (mNumActiveWindowsAllInput > 0)
-        {
-            return true;
-        }
-
-        // Wenn kein Fenster mit Tastatureingabe aktiv ist, kriegt CEGUI keine KeyEvents
-        if (mNumActiveWindowsKeyboardInput == 0)
-        {
-            return false;
-        }
-
-        // ---- Tastatureingabe gefordert ----
-
-        // Tasten, die Zeichen liefern sollen an CEGUI gesendet werden
-        if (getKeyChar(e.key, getModifierCode()) != 0)
-        {
-            return true;
-        }
-
-        if (e.key == OIS::KC_RETURN
-            || e.key == OIS::KC_HOME || e.key == OIS::KC_END
-            || e.key == OIS::KC_LEFT || e.key == OIS::KC_RIGHT
-            || e.key == OIS::KC_BACK || e.key == OIS::KC_DELETE
-            || e.key == OIS::KC_UP   || e.key == OIS::KC_DOWN
-            || e.key == OIS::KC_RMENU)
-        {
-            return true;
-        }
-
-        return false;
-    }
-
-    bool InputManager::keyPressed(const OIS::KeyEvent& e)
-    {
-        if (sendKeyToCeGui(e))
-        {   // Send all events to CEGUI
-            CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyDown(e.key);
-            cegui.injectChar(getKeyChar(e.key, getModifierCode()));
-        }
-        else
-        {
-            int code = CommandMapper::encodeKey(e.key, getModifierCode());
-
-            // is there a ruby script command linked?
-            KeyCommandMap::iterator it;
-            it = mKeyRubyCommand.find(code);
-            if( it != mKeyRubyCommand.end() )
-            {
-                if( it->second.length() > 0 )
-                {
-                    bool error = CoreSubsystem::getSingleton().getRubyInterpreter()->execute(it->second.c_str());
-                    LOG_MESSAGE(Logger::UI, " (keyboard shortcut) execution of ruby command '" + it->second + "' " + (error == false ? "success." : "failure."));
-                    return true;
-                }
-            }
-
-            if (!mControlStates.empty())
-            {
-                mControlStates.top()->injectKeyDown(code);
-            }
-        }
-
-        return true;
-    }
-
-    bool InputManager::keyReleased(const OIS::KeyEvent& e)
-    {
-        LOG_MESSAGE2(Logger::UI, "Key released: " + mKeyboard->getAsString(e.key) ,
-            "InputManager::keyReleased");
-        if (sendKeyToCeGui(e))
-        {
-            CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyUp(e.key);
-            LOG_MESSAGE2(Logger::UI, "    fed to cegui", "InputManager::keyReleased");
-        }
-        else
-        {
-            int code = CommandMapper::encodeKey(e.key, getModifierCode());
-            Action* action = ActionManager::getSingleton().getInGameGlobalAction(
-                mCommandMapper->getGlobalAction(code));
-            if (action != NULL)
-            {
-                action->doAction(NULL, NULL, NULL);
-                LOG_MESSAGE2(Logger::UI, "    invoked action " + action->getName(),
-                    "InputManager::keyReleased");
-            }
-
-            if (!mControlStates.empty())
-            {
-                mControlStates.top()->injectKeyUp(e.key);
-                LOG_MESSAGE2(Logger::UI, "    fed to char controller",
-                    "InputManager::keyReleased");
-            }
-        }
-
-        return true;
-    }
-
     CeGuiString InputManager::getKeyName(int combinedKeyCode)
     {
         int scancode, syskeys;
@@ -409,71 +238,6 @@
         return rval;
     }
 
-    void InputManager::registerAbstractWindow(AbstractWindow* window)
-    {
-        if (window->getWindowType() == AbstractWindow::WND_SHOW)
-            return;
-
-        bool active = isCeguiActive();
-
-        if (window->getWindowType() == AbstractWindow::WND_MOUSE_INPUT)
-        {
-            mNumActiveWindowsMouseInput++;
-        }
-        else if (window->getWindowType() == AbstractWindow::WND_KEYBOARD_INPUT)
-        {
-            mNumActiveWindowsKeyboardInput++;
-        }
-        else if (window->getWindowType() == AbstractWindow::WND_ALL_INPUT)
-        {
-            mNumActiveWindowsAllInput++;
-        }
-
-        if (!active && isCeguiActive()) // war nicht aktiv, sollte jetzt aktiv sein -> anschalten
-        {
-            mSavedMouseState.x = mMouse->getMouseState().X.rel;
-            mSavedMouseState.y = mMouse->getMouseState().Y.rel;
-            mSavedMouseState.z = mMouse->getMouseState().Z.rel;
-            CEGUI::MouseCursor::getSingleton().show();
-        }
-    }
-
-    void InputManager::unregisterAbstractWindow(AbstractWindow* window)
-    {
-        if (window->getWindowType() == AbstractWindow::WND_SHOW)
-        {
-            return;
-        }
-
-        bool active = isCeguiActive();
-
-        if (window->getWindowType() == AbstractWindow::WND_MOUSE_INPUT)
-        {
-            mNumActiveWindowsMouseInput--;
-        }
-        else if (window->getWindowType() == AbstractWindow::WND_KEYBOARD_INPUT)
-        {
-            mNumActiveWindowsKeyboardInput--;
-        }
-        else if (window->getWindowType() == AbstractWindow::WND_ALL_INPUT)
-        {
-            mNumActiveWindowsAllInput--;
-        }
-
-        if (active && !isCeguiActive()) // war aktiv, sollte nicht mehr aktiv sein -> ausschalten
-        {
-            CEGUI::MouseCursor::getSingleton().hide();
-        }
-    }
-
-    bool InputManager::isCeguiActive() const
-    {
-        return
-            mNumActiveWindowsKeyboardInput > 0 ||
-            mNumActiveWindowsMouseInput > 0 ||
-            mNumActiveWindowsAllInput > 0;
-    }
-
     void InputManager::loadKeyMapping(const Ogre::String& filename)
     {
         using namespace XERCES_CPP_NAMESPACE;
@@ -666,6 +430,10 @@
         {
             mControlStates.top()->pause();
         }
+
+        mKeyboard->setEventCallback(controller);
+        mMouse->setEventCallback(controller);
+
         mControlStates.push(controller);
         mControlStates.top()->resume();
     }
@@ -679,8 +447,16 @@
 
         if (!mControlStates.empty())
         {
-            mControlStates.top()->resume();
+            CharacterController* newController = mControlStates.top();
+            mKeyboard->setEventCallback(newController);
+            mMouse->setEventCallback(newController);
+            newController->resume();
         }
+        else
+        {
+            mKeyboard->setEventCallback(NULL);
+            mMouse->setEventCallback(NULL);
+        }
     }
 
     void InputManager::clearControlStates()

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -32,7 +32,7 @@
 	const Ogre::String InventoryWindow::SLOTNAME = "slotname";
 
     InventoryWindow::InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory)
-        : AbstractWindow(inventoryWindow, AbstractWindow::WND_MOUSE_INPUT)
+        : AbstractWindow(inventoryWindow, AbstractWindow::WIT_MOUSE_INPUT)
     {
         mInventory = inventory;
 

Modified: rl/trunk/engine/ui/src/JournalWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/JournalWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/JournalWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -29,7 +29,7 @@
 namespace rl {
 
     JournalWindow::JournalWindow()
-        : AbstractWindow("journalwindow.xml", WND_MOUSE_INPUT),
+        : AbstractWindow("journalwindow.xml", WIT_MOUSE_INPUT),
         mQuests(0),
         mQuestTitle(0),
         mQuestState(0),

Modified: rl/trunk/engine/ui/src/LogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/LogWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/LogWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -23,7 +23,7 @@
 namespace rl
 {
 	LogWindow::LogWindow()
-		: AbstractWindow("logwindow.xml", WND_MOUSE_INPUT)
+		: AbstractWindow("logwindow.xml", WIT_MOUSE_INPUT)
 	{
 		mRastullahLog = getMultiLineEditbox("LogWindow/RastullahLog/Text");
 		mOgreLog = getMultiLineEditbox("LogWindow/OgreLog/Text");

Modified: rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -26,7 +26,7 @@
 namespace rl {
 
     MainMenuEngineWindow::MainMenuEngineWindow() :
-        AbstractWindow("mainmenuenginewindow.xml", WND_SHOW, false)
+        AbstractWindow("mainmenuenginewindow.xml", WIT_NONE, false)
     {
         getWindow("MainMenu/EngineVersion")->setText(
             CoreSubsystem::getSingleton().getEngineVersionString()+

Modified: rl/trunk/engine/ui/src/MainMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -31,7 +31,7 @@
 namespace rl {
 
 	MainMenuWindow::MainMenuWindow(MainMenuEngineWindow* enginewindow) :
-		AbstractWindow("mainmenuwindow.xml", WND_MOUSE_INPUT, false, false),
+		AbstractWindow("mainmenuwindow.xml", WIT_MOUSE_INPUT, false, false),
 		mActiveModule(NULL),
 		mEngineWindow(enginewindow)
 	{

Modified: rl/trunk/engine/ui/src/MessageWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MessageWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/MessageWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -20,7 +20,7 @@
 namespace rl {
 
 MessageWindow::MessageWindow() :
-	AbstractWindow("messagewindow.xml", WND_MOUSE_INPUT)
+	AbstractWindow("messagewindow.xml", WIT_MOUSE_INPUT)
 {
 	mTextField = getWindow("MessageWindow/Text");
 

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -67,7 +67,7 @@
 
     MovementCharacterController::MovementCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character),
+        : CharacterController(cmdMapper, camera, character, CST_MOVEMENT),
         mMovingCreature(NULL),
         mCharacterState(),
         mDesiredDistance(2.00),
@@ -225,6 +225,8 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::run(Real elapsedTime)
     {
+        if (isCeguiActive()) return;
+
         InputManager* im = InputManager::getSingletonPtr();
 
         updateCharacter(elapsedTime);
@@ -306,7 +308,7 @@
                     rotation = -elapsedTime * baseVel;
 
                 // mouse
-                if( !im->isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                if( !isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
                 {
                     if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
                     {
@@ -431,7 +433,7 @@
             mDesiredDistance = mDistanceRange.second;
         }
 
-        if( !im->isCeguiActive() && mViewMode == VM_FREE_CAMERA )
+        if( !isCeguiActive() && mViewMode == VM_FREE_CAMERA )
         {
             mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
 
@@ -510,7 +512,6 @@
         }
     }
 
-
     // -------------------------------------------------------------
     // character collision moved to MovingCreature(Manager)
     int MovementCharacterController::userProcess()
@@ -994,9 +995,9 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::updateSelection()
     {
+        if (isCeguiActive()) return;
+
         InputManager* im = InputManager::getSingletonPtr();
-        if( im->isCeguiActive() )
-            return;
 
         GameObject* oldGo = mSelector.getFirstSelectedObject();
 
@@ -1146,12 +1147,12 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::injectKeyDown(int keycode)
+    bool MovementCharacterController::keyPressed(const OIS::KeyEvent& evt)
     {
-        int scancode;
-        mCommandMapper->decodeKey(keycode, &scancode, NULL);
-        int movement = mCommandMapper->getMovement(scancode);
+        if (CharacterController::keyPressed(evt)) return true;
 
+        int movement = mCommandMapper->getMovement(evt.key);
+
         if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
         {
             mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
@@ -1166,12 +1167,16 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::injectKeyUp(int keycode)
+    bool MovementCharacterController::keyReleased(const OIS::KeyEvent& evt)
     {
-        int scancode;
-        mCommandMapper->decodeKey(keycode, &scancode, NULL);
-        int movement = mCommandMapper->getMovement(scancode);
+        // CEGUI is handled by base class, so hand it down if necessary.
+        if (sendKeyToCeGui(evt))
+        {
+            return CharacterController::keyReleased(evt);
+        }
 
+        int movement = mCommandMapper->getMovement(evt.key);
+
         if (movement != MOVE_NONE)
         {
             mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
@@ -1179,6 +1184,8 @@
         }
         else
         {
+            InputManager* im = InputManager::getSingletonPtr();
+            int keycode = CommandMapper::encodeKey(evt.key, im->getModifierCode());
             CeGuiString command = mCommandMapper->getControlStateAction(keycode, CST_MOVEMENT);
             if (command == "freeflight_mode")
             {
@@ -1197,7 +1204,8 @@
             }
             else
             {
-                return startAction(command);
+                // Nothing we handle here, see if base class can make something of this input.
+                return CharacterController::keyReleased(evt);
             }
         }
 
@@ -1205,22 +1213,19 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::injectMouseDown(int mouseButtonMask)
+    bool MovementCharacterController::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id)
     {
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementCharacterController::injectMouseUp(int mouseButtonMask)
-    {
-        if (!InputManager::getSingleton().isCeguiActive())
+        if (!isCeguiActive())
         {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
             return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
                 CST_MOVEMENT), mCharacter);
         }
         else
         {
-            return false;
+            return CharacterController::mouseReleased(evt, id);
         }
     }
 

Modified: rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -21,7 +21,7 @@
 namespace rl
 {
 	ObjectDescriptionWindow::ObjectDescriptionWindow()
-		: AbstractWindow("objectdescriptionwindow.xml", WND_SHOW)
+		: AbstractWindow("objectdescriptionwindow.xml", WIT_NONE)
 	{
 		mDescription = getMultiLineEditbox("ObjectDescriptionWindow/Text");
 	}

Modified: rl/trunk/engine/ui/src/PlaylistWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -29,7 +29,7 @@
 namespace rl {
 
 PlaylistWindow::PlaylistWindow()
-	: AbstractWindow("playlistwindow.xml", WND_MOUSE_INPUT)
+	: AbstractWindow("playlistwindow.xml", WIT_MOUSE_INPUT)
 {
 	mPlaylistTable = getMultiColumnList("PlaylistSheet/PlaylistSheet/Table");
 	mPlaylistTable->addColumn((utf8*)"Name", 0, cegui_reldim(0.5));

Modified: rl/trunk/engine/ui/src/ProgressWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ProgressWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/ProgressWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -19,7 +19,7 @@
 namespace rl {
 
 ProgressWindow::ProgressWindow()
-: AbstractWindow("progresswindow.xml", AbstractWindow::WND_SHOW, false, true)
+: AbstractWindow("progresswindow.xml", WIT_NONE, false, true)
 {
 	mProgressBar = getProgressBar("ProgressWindow/ProgressBar");
     mText = getWindow("ProgressWindow/Text");

Modified: rl/trunk/engine/ui/src/SaveLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -36,7 +36,7 @@
     //------------------------------------------------------- Constructor
 
     SaveLoadWindow::SaveLoadWindow() :
-        AbstractWindow("saveloadwindow.xml", WND_MOUSE_INPUT)
+        AbstractWindow("saveloadwindow.xml", WIT_MOUSE_INPUT)
     {
         // Get a access to the filename edit box
         mFilename = getEditbox("SaveLoadWindow/FileSheet/Filename");

Modified: rl/trunk/engine/ui/src/SoundConfig.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundConfig.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/SoundConfig.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -31,7 +31,7 @@
 {
 
 	SoundConfig::SoundConfig()
-		: AbstractWindow("soundconfig.xml", WND_ALL_INPUT),
+		: AbstractWindow("soundconfig.xml", WIT_MOUSE_INPUT | WIT_KEYBOARD_INPUT),
 		mDriverBox(NULL),
 		mVolumeSound(0),
 		mVolumeMusic(0),

Modified: rl/trunk/engine/ui/src/SubtitleWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -21,7 +21,7 @@
 namespace rl
 {
 	SubtitleWindow::SubtitleWindow()
-		: AbstractWindow("subtitlewindow.xml", WND_SHOW, false)
+		: AbstractWindow("subtitlewindow.xml", WIT_NONE, false)
 	{
 		mSubtitle = getMultiLineEditbox("SubtitleWindow/Text");
 	}

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -21,6 +21,7 @@
 #include "CharacterSheetWindow.h"
 #include "CharacterStateWindow.h"
 #include "CloseConfirmationWindow.h"
+#include "CombatWindow.h"
 #include "Console.h"
 #include "ContainerContentWindow.h"
 #include "CoreSubsystem.h"
@@ -82,7 +83,8 @@
         mObjectDescriptionWindow(NULL),
         mMainMenuWindow(NULL),
         mCloseConfirmationWindow(NULL),
-        mGameSettings(NULL)
+        mGameSettings(NULL),
+        mCombatWindow(NULL)
     {
     }
 
@@ -103,8 +105,6 @@
         mJournalWindow = new JournalWindow();
         mInfoPopup = new InfoPopup();
         mObjectDescriptionWindow = new ObjectDescriptionWindow();
-        mCloseConfirmationWindow = NULL;
-        mGameSettings = NULL;
 
         RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
         RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
@@ -131,6 +131,7 @@
         delete mGameSettings;
         delete mDialogWindow;
         delete mSubtitleWindow;
+        delete mCombatWindow;
     }
 
     void WindowFactory::showCharacterActionChoice()
@@ -426,4 +427,13 @@
         }
         return mSubtitleWindow;
     }
+
+    CombatWindow* WindowFactory::getCombatWindow()
+    {
+        if (mCombatWindow == NULL)
+        {
+            mCombatWindow = new CombatWindow();
+        }
+        return mCombatWindow;
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-06-08 11:41:47 UTC (rev 3524)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-06-08 22:47:58 UTC (rev 3525)
@@ -28,7 +28,10 @@
 
 namespace rl {
 
-	WindowManager::WindowManager()
+    WindowManager::WindowManager()
+        : mWindowList(),
+          mNumActiveWindowsMouseInput(0),
+          mNumActiveWindowsKeyboardInput(0)
 	{
 	}
 
@@ -78,4 +81,33 @@
 		mWindowList.push_back(window);
 		return true;
 	}
+
+    void WindowManager::_visiblityChanged(AbstractWindow* window, bool isVisible)
+    {
+        if (window->getWindowInputType() & AbstractWindow::WIT_MOUSE_INPUT)
+        {
+            mNumActiveWindowsMouseInput += isVisible ? +1 : -1;
+        }
+        else if (window->getWindowInputType() & AbstractWindow::WIT_KEYBOARD_INPUT)
+        {
+            mNumActiveWindowsKeyboardInput += isVisible ? +1 : -1;
+        }
+
+        if (mNumActiveWindowsMouseInput == 1)
+        {
+            CEGUI::MouseCursor::getSingleton().show();
+        }
+        else if (mNumActiveWindowsMouseInput == 0)
+        {
+            CEGUI::MouseCursor::getSingleton().hide();
+        }
+    }
+
+    int WindowManager::getWindowInputMask() const
+    {
+        int mask = 0;
+        mask |= mNumActiveWindowsMouseInput > 0 ? AbstractWindow::WIT_MOUSE_INPUT : 0;
+        mask |= mNumActiveWindowsKeyboardInput > 0 ? AbstractWindow::WIT_KEYBOARD_INPUT : 0;
+        return mask;
+    }
 }



From tanis at mail.berlios.de  Sat Jun  9 00:50:29 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sat, 9 Jun 2007 00:50:29 +0200
Subject: [Dsa-hl-svn] r3526 - modules/common/gui/windows
Message-ID: <200706082250.l58MoT6q027073@sheep.berlios.de>

Author: tanis
Date: 2007-06-09 00:50:20 +0200 (Sat, 09 Jun 2007)
New Revision: 3526

Modified:
   modules/common/gui/windows/combatwindow.xml
Log:
Restructuring of input handling. InputManager doesn't preview input events anymore. Instead it only initialises and delegates input to the active control state, which handles all input now.
Specialised Control States handle the input they know about and deligate all other events back to the base class, which handles cegui and global game actions.
Now control states can decide for themself whether something is sent to cegui or handled inside the controller.

Modified: modules/common/gui/windows/combatwindow.xml
===================================================================
--- modules/common/gui/windows/combatwindow.xml	2007-06-08 22:47:58 UTC (rev 3525)
+++ modules/common/gui/windows/combatwindow.xml	2007-06-08 22:50:20 UTC (rev 3526)
@@ -1,51 +1,13 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-    <Window Type="DefaultWindow" Name="CombatWindow">
-        <Property Name="RelativeXPosition" Value="0.0"/>
-        <Property Name="RelativeYPosition" Value="0.0"/>
-        <Property Name="RelativeWidth" Value="1.0"/>
-        <Property Name="RelativeHeight" Value="1.0"/>
+    <Window Type="DefaultGUISheet" Name="CombatGui">
+		<Property Name="UnifiedPosition" Value="{{0.0,0},{0.0,0}}" />	
+		<Property Name="UnifiedSize" Value="{{1.0,0.0},{1.0,0}}" />
 
-		<Window Type="RastullahLook/Listbox" Name="CombatWindow/ActionOptions">
-			<Property Name="AbsoluteXPosition" Value="50"/>
-			<Property Name="AbsoluteYPosition" Value="100"/>
-			<Property Name="AbsoluteWidth" Value="200"/>
-			<Property Name="AbsoluteHeight" Value="100"/>
-			<Property Name="DefaultSelectionColour" Value="00E4D243" />
+		<Window Type="RastullahLook/MultiLineEditbox" Name="CombatGui/Info">
+    		<Property Name="UnifiedPosition" Value="{{0.05,0},{0.75,0}}" />	
+	    	<Property Name="UnifiedSize" Value="{{0.9,0},{0.2,0}}" />
+			<Property Name="Font" Value="Vera Serif-10" />
+			<Property Name="Text" Value="Here there be important message." />
 		</Window>
-
-		<Window Type="RastullahLook/Listbox" Name="CombatWindow/AttackTargets">
-			<Property Name="AbsoluteXPosition" Value="50"/>
-			<Property Name="AbsoluteYPosition" Value="210"/>
-			<Property Name="AbsoluteWidth" Value="200"/>
-			<Property Name="AbsoluteHeight" Value="100"/>
-			<Property Name="NormalTextColour" Value="FF000000" />
-			<Property Name="DefaultSelectionColour" Value="00E4D243" />
-		</Window>
-
-		<Window Type="RastullahLook/Listbox" Name="CombatWindow/PareeTargets">
-			<Property Name="AbsoluteXPosition" Value="50"/>
-			<Property Name="AbsoluteYPosition" Value="330"/>
-			<Property Name="AbsoluteWidth" Value="200"/>
-			<Property Name="AbsoluteHeight" Value="100"/>
-			<Property Name="NormalTextColour" Value="FF000000" />
-			<Property Name="DefaultSelectionColour" Value="00E4D243" />
-		</Window>
-
-		<Window Type="RastullahLook/Button" Name="CombatWindow/Confirm">
-			<Property Name="Text" Value="Ausf?hren"/>
-			<Property Name="AbsoluteXPosition" Value="50"/>
-			<Property Name="AbsoluteYPosition" Value="450"/>
-			<Property Name="AbsoluteWidth" Value="150"/>
-			<Property Name="AbsoluteHeight" Value="30"/>
-			<Property Name="NormalTextColour" Value="FF000000" />
-		</Window>
-
-		<Window Type="RastullahLook/StaticText" Name="CombatWindow/DebugMessage">
-	        <Property Name="RelativeXPosition" Value="0.5"/>
-		    <Property Name="RelativeYPosition" Value="0.0"/>
-			<Property Name="RelativeWidth" Value="0.45"/>
-			<Property Name="RelativeHeight" Value="0.5"/>
-		</Window>
-
-    </Window>
-</GUILayout>
\ No newline at end of file
+	</Window>
+</GUILayout>



From timm at mail.berlios.de  Sun Jun 10 13:04:55 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 10 Jun 2007 13:04:55 +0200
Subject: [Dsa-hl-svn] r3527 - in rl/trunk/engine/ui: include src
Message-ID: <200706101104.l5AB4thb025149@sheep.berlios.de>

Author: timm
Date: 2007-06-10 13:04:50 +0200 (Sun, 10 Jun 2007)
New Revision: 3527

Modified:
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
added combatwindow to linux makefiles

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-06-08 22:50:20 UTC (rev 3526)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-06-10 11:04:50 UTC (rev 3527)
@@ -8,6 +8,7 @@
     CharacterStateWindow.h \
     CloseConfirmationWindow.h \
     CombatCharacterController.h \
+	CombatWindow.h \
     CommandMapper.h \
     ConfigComponent.h \
     Console.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-06-08 22:50:20 UTC (rev 3526)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-06-10 11:04:50 UTC (rev 3527)
@@ -16,6 +16,7 @@
     CharacterStateWindow.cpp \
     CloseConfirmationWindow.cpp \
     CombatCharacterController.cpp \
+	CombatWindow.cpp \
     CommandMapper.cpp \
     ConfigComponent.cpp \
     ContainerContentWindow.cpp \



From chrber at mail.berlios.de  Sun Jun 10 16:06:03 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Sun, 10 Jun 2007 16:06:03 +0200
Subject: [Dsa-hl-svn] r3528 - in rl/trunk/engine: startup/src ui/include
Message-ID: <200706101406.l5AE63av003500@sheep.berlios.de>

Author: chrber
Date: 2007-06-10 16:06:01 +0200 (Sun, 10 Jun 2007)
New Revision: 3528

Modified:
   rl/trunk/engine/startup/src/Makefile.am
   rl/trunk/engine/ui/include/CharacterController.h
Log:
Added OIS Paths to Makefile
Removed class name from class method


Modified: rl/trunk/engine/startup/src/Makefile.am
===================================================================
--- rl/trunk/engine/startup/src/Makefile.am	2007-06-10 11:04:50 UTC (rev 3527)
+++ rl/trunk/engine/startup/src/Makefile.am	2007-06-10 14:06:01 UTC (rev 3528)
@@ -1,4 +1,4 @@
-INCLUDES = $(CEGUI_CFLAGS) $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(STLPORT_CFLAGS) \
+INCLUDES = $(CEGUI_CFLAGS) $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(OIS_CFLAGS) $(STLPORT_CFLAGS) \
 	-I../../common/include -I../../core/include -I../../rules/include \
 	-I../../ui/include -I../../dialog/include -I../../script/include -I../../ai/include
 

Modified: rl/trunk/engine/ui/include/CharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterController.h	2007-06-10 11:04:50 UTC (rev 3527)
+++ rl/trunk/engine/ui/include/CharacterController.h	2007-06-10 14:06:01 UTC (rev 3528)
@@ -68,7 +68,7 @@
         /// Returns true, if the key event should be injected into CEGUI
         /// This is the case, if an open window requests key input and it is
         /// an input or navigation key.
-        bool CharacterController::sendKeyToCeGui(const OIS::KeyEvent& evt) const;
+        bool sendKeyToCeGui(const OIS::KeyEvent& evt) const;
 
         Person* mCharacter;
 



From melven at mail.berlios.de  Tue Jun 12 00:14:32 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 12 Jun 2007 00:14:32 +0200
Subject: [Dsa-hl-svn] r3529 - in rl/trunk/engine/rules: include src
Message-ID: <200706112214.l5BMEWcZ032139@sheep.berlios.de>

Author: melven
Date: 2007-06-12 00:14:21 +0200 (Tue, 12 Jun 2007)
New Revision: 3529

Modified:
   rl/trunk/engine/rules/include/MovingCreature.h
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
- setting torque to mass*acc*40 due to bug setting the inertia of a game-object
- implemented crossfading for animation "Walk" from "Run" and from "Idle"

Modified: rl/trunk/engine/rules/include/MovingCreature.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreature.h	2007-06-10 14:06:01 UTC (rev 3528)
+++ rl/trunk/engine/rules/include/MovingCreature.h	2007-06-11 22:14:21 UTC (rev 3529)
@@ -31,6 +31,7 @@
 {
     class AbstractMovement;
     class MovingCreatureManager;
+    class MeshAnimation;
 
     /** 
      * This class provides an interface to control the movement of a creature.
@@ -132,15 +133,19 @@
         int getCurrentGS() const;
         Ogre::Vector3 getVelocity() const; // in local axes
         Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &name, 
+        MeshAnimation *setAnimation(const Ogre::String &name, 
                           Ogre::Real speed = 1, 
                           unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = "" // the name of the animation the collision is based on
+                          const Ogre::String &collisionName = "", // the name of the animation the collision is based on
+                          Ogre::Real weight = 1 // the weight of the animation, the weight of the last animation is set to 1-weight
                           );
 
 
         /// this method will return the yaw, the creature tries to turn to, if a rotation-movement is activated. if not, it will return the current yaw
         Ogre::Radian getYaw();
+        Ogre::Real getLastMovementChange() const { return mLastMovementChange; }
+        MovementType getLastMovementType() const { return mLastMovementType; }
+        Ogre::Real getAnimationTimePlayed() const; // this is a relative value between 0 and 1
 
 
     protected:
@@ -148,6 +153,8 @@
         AbstractLocation mAbstractLocation;
         
         AbstractMovement *mMovement;
+        MovementType mLastMovementType;
+        Ogre::Real mLastMovementChange;
         Ogre::Vector3 mDirection;
         Ogre::Vector3 mRotation;
 
@@ -162,6 +169,7 @@
         Ogre::String mLastAnimationName;
         Ogre::String mLastCollisionName;
         Ogre::Real mLastAnimationSpeed;
+        Ogre::String mStillWeightedAnimationName;
 
         // only used in userProcess
         Ogre::Real mLastFloorContact;

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-10 14:06:01 UTC (rev 3528)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-11 22:14:21 UTC (rev 3529)
@@ -189,14 +189,23 @@
             Vector3 omega = body->getOmega();
             omega.x = omega.z = 0;
             Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-            torque = mass * springAcc;
+
+            /// @ todo change this
+            //torque = springAcc * inertia; // this would be correct
+            torque = springAcc * mass * 40;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
             mYaw += Radian(rotation.y);
             while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
             while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-            return rotation.y != 0.0f;
+            
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            Quaternion orientation;
+            Vector3 position;
+            body->getPositionOrientation(position, orientation);
+
+            return orientation.getYaw() != mYaw;
         }
         virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
         {
@@ -207,8 +216,8 @@
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
         {
             Vector3 oldRotation(rotation);
-            rotation.x = rotation.y = 0;
-            return oldRotation.x == 0 && oldRotation.y == 0;
+            rotation.x = rotation.z = 0;
+            return oldRotation.x == 0 && oldRotation.z == 0;
         }
     protected:
         Ogre::Radian mYaw;
@@ -258,7 +267,35 @@
             //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
             //Real length = charMesh->getAnimation("Run")->getLength();
             Real length = 5./3.;
-            mMovingCreature->setAnimation("Walk", -mMovingCreature->getVelocity().z / (step / length) );
+            Real weight = 1;
+            Real relTimeOffset = 0;
+            
+            switch( mMovingCreature->getLastMovementType() )
+            {
+            case MovingCreature::MT_NONE:
+                break;
+            case MovingCreature::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case MovingCreature::MT_JOGGEN:
+            case MovingCreature::MT_LAUFEN:
+            case MovingCreature::MT_RENNEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 1.0f )
+                    weight = mMovingCreature->getLastMovementChange() / 1.0f;
+                break;
+            default:
+                break;
+            }
+
+
+            // apply relTimeOffset only once
+            if( mMovingCreature->getLastMovementChange() > elapsedTime )
+                relTimeOffset = 0;
+
+            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Walk", -mMovingCreature->getVelocity().z / (step / length), 0, "Walk", weight );
+            if( meshAnim != NULL )
+                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
         }
     };
 
@@ -953,11 +990,14 @@
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),
         mMovement(NULL),
+        mLastMovementType(MT_NONE),
+        mLastMovementChange(0),
         mDirection(Vector3::ZERO),
         mRotation(Vector3::ZERO),
         mLastAnimationName(""),
         mLastCollisionName(""),
         mLastAnimationSpeed(1),
+        mStillWeightedAnimationName(""),
         mLastFloorContact(0)
     {
         MovingCreatureManager::getSingleton().add(this);
@@ -1038,10 +1078,11 @@
         return max(act_gs,1);
     }
 
-    void MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName)
+    MeshAnimation *MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName, Real weight)
     {
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
         PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
+        MeshAnimation *meshAnim(NULL);
         
         if( mLastAnimationName != name)
         {
@@ -1054,23 +1095,78 @@
                 pt->fitToPose(*pCollisionName);
                 mLastCollisionName = *pCollisionName;
             }
-            mesh->stopAllAnimations();
 
-            mesh->startAnimation(name, speed, timesToPlay);
-            mLastAnimationName = name;
-            mLastAnimationSpeed = speed;
+
+            if ( mStillWeightedAnimationName != "" )
+            {
+                mesh->stopAnimation(mStillWeightedAnimationName);
+                mStillWeightedAnimationName = "";
+            }
+
+
+            if( mesh->hasAnimation(mLastAnimationName) )
+            {
+                if ( weight == 1 )
+                    mesh->stopAnimation(mLastAnimationName);
+                else
+                {
+                    MeshAnimation *lastAnimation = mesh->getAnimation(mLastAnimationName);
+                    if( lastAnimation != NULL )
+                    {
+                        mStillWeightedAnimationName = mLastAnimationName;
+                        lastAnimation->setWeight(1-weight);
+                    }
+                }
+            }
+
+            meshAnim = mesh->startAnimation(name, speed, timesToPlay);
+            if( meshAnim )
+            {
+                meshAnim->setWeight(weight);
+                mLastAnimationName = name;
+                mLastAnimationSpeed = speed;
+            }
         }
         else
         {
+            meshAnim = mesh->getAnimation(name);
             if( mLastAnimationSpeed != speed )
             {
-                MeshAnimation *meshAnim = mesh->getAnimation(name);
                 meshAnim->setSpeed(speed);
                 mLastAnimationSpeed = speed;
+                meshAnim->setWeight(weight);
             }
+            if( mStillWeightedAnimationName != "" )
+            {
+                MeshAnimation *lastAnimation = mesh->getAnimation(mStillWeightedAnimationName);
+                if( lastAnimation !=  NULL )
+                {
+                    lastAnimation->setWeight(1-weight);
+                    if( weight == 1 )
+                    {
+                        mesh->stopAnimation(mStillWeightedAnimationName);
+                        mStillWeightedAnimationName = "";
+                    }
+                }
+                else
+                {
+                    mStillWeightedAnimationName = "";
+                }
+            }
         }
+
+        return meshAnim;
     }
 
+    Ogre::Real MovingCreature::getAnimationTimePlayed() const
+    {
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
+        MeshAnimation *meshAnim = mesh->getAnimation(mLastAnimationName);
+        if( meshAnim != NULL )
+            return meshAnim->getTimePlayed()/meshAnim->getLength();
+        return 0;
+    }
+
     Ogre::Vector3 MovingCreature::getVelocity() const
     {
         return 
@@ -1087,6 +1183,7 @@
     {
         if(mMovement != NULL)
         {
+            mLastMovementChange += elapsedTime;
             if( !mMovement->isPossible() )
             {
                 setMovement(mMovement->getFallBackMovement(), mDirection, mRotation);
@@ -1221,12 +1318,20 @@
             if(movement->isPossible())
             {
                 MovingCreatureManager::getSingleton().setActive(this); // runs the old movement if idle!
-                if(mMovement != NULL)
+                if(mMovement == NULL)
+                {
+                    mLastMovementType = MT_NONE;
+                }
+                else
+                {
+                    mLastMovementType = mMovement->getId();
                     mMovement->deactivate();
+                }
                 mMovement = movement;
                 mMovement->activate();
                 mDirection = direction;
                 mRotation = rotation;
+                mLastMovementChange = 0;
                 return true;
             }
 



From melven at mail.berlios.de  Tue Jun 12 00:16:38 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 12 Jun 2007 00:16:38 +0200
Subject: [Dsa-hl-svn] r3530 - rl/trunk/engine/ui/src
Message-ID: <200706112216.l5BMGcZh032250@sheep.berlios.de>

Author: melven
Date: 2007-06-12 00:16:22 +0200 (Tue, 12 Jun 2007)
New Revision: 3530

Modified:
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
-implemention of new animation names
- removed unnecessary code (animations and physics, which is already done by MovingCreature)

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-06-11 22:14:21 UTC (rev 3529)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-06-11 22:16:22 UTC (rev 3530)
@@ -98,13 +98,6 @@
         PhysicsManager::getSingleton().getMaterialPair(
             PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
-
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        if( mesh != NULL )
-        {
-		    mesh->stopAllAnimations();
-		    mesh->startAnimation("idle");
-        }
     }
 
 	void FreeFlightCharacterController::run(Real elapsedTime)

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-06-11 22:14:21 UTC (rev 3529)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-06-11 22:16:22 UTC (rev 3530)
@@ -192,11 +192,8 @@
         mCombatSelector.track(mCharacter);
         mCombatSelector.setRadius(10.0);
 
-        // The actor should be controlled manually,
-        // so let the PM prepare it accordingly
-        //mCharacterActor->getPhysicalThing()->setMaterialID(
-        //    PhysicsManager::getSingleton().getMaterialID("character"));
-        //mCharacterActor->getPhysicalThing()->setPhysicsController(this);
+
+        // control camera
         mCameraActor->getPhysicalThing()->setMaterialID(
             PhysicsManager::getSingleton().createMaterialID("camera"));
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
@@ -212,13 +209,6 @@
             PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
 
-        // Fit Collision proxy to idle anim
-        mCharacterActor->getPhysicalThing()->fitToPose("idle");
-
-        //MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        //mesh->stopAllAnimations();
-        //mesh->startAnimation("idle");
-
         setViewMode(VM_THIRD_PERSON);
     }
 
@@ -390,7 +380,7 @@
             else if (movement & MOVE_BACKWARD )
             {
                 MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
-                if( movement & MOVE_RUN )
+                if( !(movement & MOVE_RUN) )
                     type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
                 mMovingCreature->setMovement(
                     type,
@@ -517,6 +507,7 @@
     int MovementCharacterController::userProcess()
     {
         // only camera collision
+        return 0;
     
         if( mViewMode == VM_FIRST_PERSON )
             return 0;
@@ -1032,7 +1023,15 @@
         mViewMode = mode;
 
         MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
+        AxisAlignedBox aabb;
+        try
+        {
+            aabb = charMesh->getPoseSize("Idle");
+        }
+        catch(...)
+        {
+            aabb = charMesh->getDefaultSize();
+        }
         if (mode == VM_FIRST_PERSON)
         {
             mLookAtOffset = Vector3(



From melven at mail.berlios.de  Tue Jun 12 00:19:53 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 12 Jun 2007 00:19:53 +0200
Subject: [Dsa-hl-svn] r3531 - in rl/trunk/engine/ai: include src
Message-ID: <200706112219.l5BMJr8w032455@sheep.berlios.de>

Author: melven
Date: 2007-06-12 00:19:43 +0200 (Tue, 12 Jun 2007)
New Revision: 3531

Modified:
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/FuzzyState.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
Log:
using DebugVisualisable to debug NewtonWorldAsObstacle and steering behavior

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-06-11 22:16:22 UTC (rev 3530)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-06-11 22:19:43 UTC (rev 3531)
@@ -17,6 +17,7 @@
 #define __RlAI_World_H__
 
 #include "OpenSteer/Obstacle.h"
+#include "DebugVisualisable.h"
 #include <OgreNewt.h>
 #include <vector>
 
@@ -51,7 +52,8 @@
 
     /** Wrapper f?r Newton-World
 	 */
-    class NewtonWorldAsObstacle : public OpenSteer::Obstacle
+    class NewtonWorldAsObstacle : public OpenSteer::Obstacle,
+        public DebugVisualisable
     {
     public:
 		/** default constructor.
@@ -63,6 +65,16 @@
 		 */
         virtual void findIntersectionWithVehiclePath (const OpenSteer::AbstractVehicle& vehicle,
                                               PathIntersection& pi) const;
+        
+        // derived from debugvisualisable
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+    protected:
+        // derived from debugvisualisable
+        virtual void doCreatePrimitive();
+        typedef std::pair<Ogre::Vector3,Ogre::Vector3> Vector3Pair;
+        mutable std::vector< Vector3Pair > mDebugRaycasts;
+
     private:
 		//! different types of raycasting directions
         enum RaycastType

Modified: rl/trunk/engine/ai/include/FuzzyState.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyState.h	2007-06-11 22:16:22 UTC (rev 3530)
+++ rl/trunk/engine/ai/include/FuzzyState.h	2007-06-11 22:19:43 UTC (rev 3531)
@@ -37,7 +37,7 @@
 		 * @param controller sets the controller object
 		 */
 		FuzzyState<Controller>(FuzzyState* parent, Controller* controller)
-			: mActivationLevel(), mParent(parent), mController(controller) {}
+			: mActivationLevel(1.0), mParent(parent), mController(controller) {}
 
 		/** explicit virtual destructor
 		 */

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-11 22:16:22 UTC (rev 3530)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-06-11 22:19:43 UTC (rev 3531)
@@ -18,6 +18,8 @@
 
 #include "AiPrerequisites.h"
 #include "AgentManager.h"
+#include "DebugVisualisable.h"
+#include "LineSetPrimitive.h"
 #include "OgreVector3.h"
 #include "OpenSteer/SteerLibrary.h"
 
@@ -51,7 +53,8 @@
 	 *
 	 * Maybe this should be used as interface instead of AbstractVehicle
 	 */
-	class _RlAiExport SteeringVehicle : public SimpleVehicle_2
+        class _RlAiExport SteeringVehicle : public SimpleVehicle_2,
+                                            public DebugVisualisable
 	{
 	public:
 		/** Constructor.
@@ -320,6 +323,11 @@
 		 * @returns Actor that is controlled by the SteeringVehicle
 		 */
         const Actor* getActor(void) const;
+
+
+        // derived from debugvisualisable
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
 	protected:
 		/** initializes
 		 */
@@ -385,6 +393,14 @@
 
         // measure path curvature (1/turning-radius), maintain smoothed version
       //  void measurePathCurvature (const float elapsedTime);
-	};
+
+
+        // derived from debugvisualisable
+        virtual void doCreatePrimitive();
+
+        Ogre::Vector3 mDebugSteer;
+        Ogre::Vector3 mDebugWander;
+        Ogre::Vector3 mDebugAvoidObstacles;
+    };
 }
 #endif

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-06-11 22:16:22 UTC (rev 3530)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-06-11 22:19:43 UTC (rev 3531)
@@ -15,12 +15,15 @@
  */
 #include "AiWorld.h"
 #include "PhysicsManager.h"
+#include "LineSetPrimitive.h"
+#include "CoreSubsystem.h"
 #include <OgreNewt.h>
 #include "SteeringVehicle.h"
 #include "Actor.h"
 #include "PhysicalThing.h"
 #include "OgreVector3.h"
 #include "PhysicsMaterialRaycast.h"
+#include "World.h"
 
 using namespace OpenSteer;
 using namespace Ogre;
@@ -86,12 +89,13 @@
 
     pi.intersect = false;
     RaycastInfo info;
+    RaycastInfo infoNearest;
     // versuche bis zu 5 raycasts mit der Mitte und den "Ecken:" oben, unten, links, rechts!
     // Dadurch ist ungefaehr der Umriss gesichert!
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
     Vec3 _pos = vehicle.position();
-    Vec3 _futPos = vehicle.forward() * 5 + _pos;
+    Vec3 _futPos = vehicle.forward() * vehicle.speed() * 3 + _pos;
 
 
     if( _pos == _futPos )
@@ -109,8 +113,15 @@
     const SteeringVehicle *steerVec = static_cast<const SteeringVehicle *> (&vehicle);
     // falls nich geklappt, ist das Ergebnis NULL, das wird spaeter abgefragt!
 
+    if( steerVec != NULL )
+    {
+        pos = pos + Ogre::Vector3::UNIT_Y*steerVec->height()/2.0;
+        futPos = futPos + Ogre::Vector3::UNIT_Y*steerVec->height()/2.0;
+    }
 
-    bool foundObstacle(false);
+
+    RaycastType nearestRayCast(NONE);
+    infoNearest.mDistance = 2;
     for( int i = 0; i < 5; i++ )
     {
         Ogre::Vector3 castPos, castFutPos;  // die Koordinaten, die zum Casten verwendet werden
@@ -129,20 +140,18 @@
             // so wir ham ne normale und machen uns nen Y
             if( vehicle.radius() == 0 )
                 continue;
-            Ogre::Vector3 offset(velocityNorm.crossProduct(Ogre::Vector3::UNIT_Y));
-            offset = offset.normalise() * vehicle.radius();
-            castPos = pos + offset;
-            castFutPos = futPos + offset;
+            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
+            castPos = pos + Vector3(offset.x, offset.y, offset.z);
+            castFutPos = futPos + Vector3(offset.x, offset.y, offset.z);
         }
         else if( raycastType == LEFT )
         {
             // wie bei right ...
             if( vehicle.radius() == 0 )
                 continue;
-            Ogre::Vector3 offset(velocityNorm.crossProduct(Ogre::Vector3::UNIT_Y));
-            offset = offset.normalise() * vehicle.radius();
-            castPos = pos - offset;
-            castFutPos = futPos - offset;
+            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
+            castPos = pos - Vector3(offset.x, offset.y, offset.z);
+            castFutPos = futPos - Vector3(offset.x, offset.y, offset.z);
         }
         else
         {
@@ -154,19 +163,23 @@
             if( raycastType == TOP )
             {
                 castPos = pos;
-                pos.y += height;
+                castPos.y += height*0.5;
                 castFutPos = futPos;
-                futPos.y += height;
+                castFutPos.y += height*0.5;
             }
             else if( raycastType == BOTTOM )
             {
                 castPos = pos;
-                pos.y -= height;
+                castPos.y -= height*0.5-0.4;
                 castFutPos = futPos;
-                futPos.y -= height;
+                castFutPos.y -= height*0.5-0.4;
             }
         }
 
+        if( DebugVisualisable::isShown() )
+            mDebugRaycasts.push_back(std::make_pair(castPos,castFutPos));
+
+
         // so alles richtig gesetzt!
         info = materialRaycast.execute(
             mNewtonWorld,
@@ -177,40 +190,71 @@
 
         if( info.mBody )
         {
-            if( !info.mNormal.directionEquals(Ogre::Vector3::UNIT_Y, Degree(20)) )
+            if( !info.mNormal.directionEquals(Ogre::Vector3::UNIT_Y, Degree(5)) )
             {
-                foundObstacle = true;
-                break;
+                nearestRayCast = raycastType;
+                if( info.mDistance < infoNearest.mDistance )
+                    infoNearest = info;
             }
         }
     }
 
-    if( !foundObstacle )
-        return;
 
 
-    switch(raycastType)
+    switch(nearestRayCast)
     {
     case NONE:
         return;
     default:
         pi.intersect = true;
         pi.obstacle = this;
-        pi.distance = info.mDistance * (futPos - pos).length();
-        pi.surfacePoint = _pos + (vehicle.forward() * pi.distance);
+        pi.distance = infoNearest.mDistance * (futPos - pos).length();
+        pi.surfacePoint =
+        vehicle.position() + (vehicle.forward() * pi.distance);
 
         // Die normale muss zu uns zeigen! koennte aber auch in die entgegengesetzte Richtung sein!
-        pi.surfaceNormal = Vec3(info.mNormal.x, info.mNormal.y, info.mNormal.z);
-        pi.surfaceNormal.normalize();
+        pi.surfaceNormal = Vec3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
+/*        pi.surfaceNormal.normalize();
         // jedenfalls gilt dafuer, dass der abstand zwischen surfacePoint+surfaceNormal und _pos minimal sein muss
         if( ((pi.surfacePoint + pi.surfaceNormal) - _pos).length() > 
             ((pi.surfacePoint - pi.surfaceNormal) - _pos).length() )
             pi.surfaceNormal = -pi.surfaceNormal;
-        pi.vehicleOutside = true; // egal?
+*/        pi.vehicleOutside = true; // egal?
+
+        // do we need different handling for right and left?
         pi.steerHint = pi.surfaceNormal;
-        //pi.steerHint.normalize();
         return;
     }
 }
 
+
+
+// methods from debugvisualisable
+DebugVisualisableFlag NewtonWorldAsObstacle::getFlag() const
+{
+    return DVF_BOT;
 }
+
+void NewtonWorldAsObstacle::updatePrimitive()
+{
+    if( mSceneNode->getParent() == NULL )
+    {
+        SceneManager* mgr = 
+            CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager();
+        mgr->getRootSceneNode()->addChild(mSceneNode);
+    }
+
+    LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+    lineSet->clear();
+    for( size_t i = 0; i < mDebugRaycasts.size(); i++)
+        lineSet->addLine(mDebugRaycasts[i].first, mDebugRaycasts[i].second, Ogre::ColourValue::Blue);
+    mDebugRaycasts.clear();
+}
+
+void NewtonWorldAsObstacle::doCreatePrimitive()
+{
+    mPrimitive = new LineSetPrimitive();
+}
+
+
+}

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-11 22:16:22 UTC (rev 3530)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-06-11 22:19:43 UTC (rev 3531)
@@ -40,7 +40,10 @@
       //mYaw(115),
 	  mParent(parent),
 	  mCreature(character),
-      mMovingCreature(NULL)
+      mMovingCreature(NULL),
+      mDebugSteer(Vector3::ZERO),
+      mDebugWander(Vector3::ZERO),
+      mDebugAvoidObstacles(Vector3::ZERO)
       //mHeight(0)
 {
 	initialize();
@@ -145,7 +148,10 @@
 
     //  regenerate local space (by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
-	if (speed() > 0) regenerateOrthonormalBasisUF (newVelocity / speed());
+    // use future orientation or not??
+    orientation = Quaternion(mMovingCreature->getYaw(), Ogre::Vector3::UNIT_Y);
+    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
+    regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
 
 // end of inserting from playervehicle
 
@@ -161,6 +167,8 @@
 // calculate the result of the force    
     Vector3 result = mCurrentForce;// + mCurrentVelocity;
 
+     mDebugSteer = mCurrentForce;
+
 // @todo remove this
 if( mCreature->getAu() <= 6 )
     mCreature->modifyAu(20,true);
@@ -204,55 +212,47 @@
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
 	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
-	rVal += steerForWander(elapsedTime).setYtoZero();
-	return Vector3(rVal.x, rVal.y, rVal.z);
+	
+    rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
+
+    Vector3 steering(rVal.x, rVal.y, rVal.z);
+    mDebugWander = steering;
+	return steering;
 }
 
 Vector3 SteeringVehicle::calcSeek(const Vector3& target)
 {
 	Vec3 rVal = steerForSeek(Vec3(target.x, target.y, target.z)).setYtoZero();
-	rVal = rVal.normalize();
-	//rVal *= -0.1; //adjustment for newton
-	//rVal.z=0;
-	return Vector3(rVal.x, rVal.y, rVal.z);
+    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	return steering;
 }
 
 Vector3 SteeringVehicle::calcFlee(const Vector3& target)
 {
 	Vec3 rVal = steerForFlee(Vec3(target.x, target.y, target.z)).setYtoZero();
-	rVal *= -0.1;
-	return Vector3(rVal.x, rVal.y, rVal.z);
+    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	return steering;
 }
 
 Vector3 SteeringVehicle::calcPursuit(Agent* agent)
 {
 	Vec3 rVal = steerForPursuit(*(agent->getVehicle())).setYtoZero();
-	rVal = rVal.normalize();
-	rVal.z = 0;
-	return Vector3(rVal.x, rVal.y, rVal.z);
+    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	return steering;
 }
 
 Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
 {
     ObstacleGroup obstacles = getObstacles();
 	Vec3 rVal = steerToAvoidObstacles(minTimeToCollision, obstacles).setYtoZero();
-	if(rVal.x != 0.0f || rVal.z != 0.0f)
-	{
-		rVal = rVal;
-	}
-	rVal = rVal.normalize();
-	//rVal *= 0.0001;
-	return Vector3(rVal.x, rVal.y, rVal.z);
+    Vector3 steering(rVal.x, rVal.y, rVal.z);
+    mDebugAvoidObstacles = steering;
+	return steering;
 }
 
 Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
 {
 	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
-	if(rVal.x != 0.0f || rVal.z != 0.0f)
-	{
-		rVal = rVal;
-	}
-//	rVal *= -1;
 	return Vector3(rVal.x, rVal.y, rVal.z);
 }
 		
@@ -444,4 +444,44 @@
 }
 */
 
+
+
+
+// methods from debugvisualisable
+DebugVisualisableFlag SteeringVehicle::getFlag() const
+{
+    return DVF_BOT;
 }
+
+void SteeringVehicle::updatePrimitive()
+{
+    if (mSceneNode->getParent() == NULL)
+    {
+        mCreature->getActor()->_getSceneNode()->addChild(mSceneNode);
+    }
+
+    LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+    lineSet->clear();
+    
+    if(mDebugSteer != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
+        mDebugSteer = Vector3::ZERO;
+    }
+    if(mDebugWander != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
+        mDebugWander = Vector3::ZERO;
+    }
+    if(mDebugAvoidObstacles != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
+        mDebugAvoidObstacles = Vector3::ZERO;
+    }
+}
+
+void SteeringVehicle::doCreatePrimitive()
+{
+    mPrimitive = new LineSetPrimitive();
+}
+}



From melven at mail.berlios.de  Tue Jun 12 19:27:38 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 12 Jun 2007 19:27:38 +0200
Subject: [Dsa-hl-svn] r3532 - in rl/trunk/engine: core/src rules/src
Message-ID: <200706121727.l5CHRcsx013508@sheep.berlios.de>

Author: melven
Date: 2007-06-12 19:27:18 +0200 (Tue, 12 Jun 2007)
New Revision: 3532

Modified:
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
Repaired Bug: wrong massmatrix of game-objects.

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-06-11 22:19:43 UTC (rev 3531)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-06-12 17:27:18 UTC (rev 3532)
@@ -411,6 +411,55 @@
             } else {
                 // found it
                 rval = usedcol.colPtr;
+                
+
+                if( inertia )
+                {
+                    // we must set inertia here, the calling function doesn't know we are not creating a new collision
+                    Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
+                    Vector3 size( aabb.getSize() );
+                    switch(usedcol.geomType)
+                    {
+                    case GT_BOX: // from createBox
+                        *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
+                        break;
+                    case GT_CAPSULE: // from createCapsule
+                        {
+                            double radius = std::max(size.x, size.z) / 2.0;
+                            double sradius = radius*radius;
+                            *inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
+                        }
+                        break;
+                    case GT_CONVEXHULL: // from createCollisionFromEntity
+				        *inertia = Vector3(
+				        size.x*size.x/6.0f,
+				        size.y*size.y/6.0f,
+			            size.z*size.z/6.0f) * mass;
+                        break;
+                    case GT_ELLIPSOID: // from createEllipsoid
+                        {
+                            Vector3 s(size/2.0);
+                            s.x = std::max(s.x, s.z);
+                            s.z = s.x;
+                            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
+                        }
+                        break;
+                    case GT_MESH:
+                    case GT_NONE:
+                        *inertia = Ogre::Vector3::ZERO;
+                        break;
+                    case GT_PYRAMID: // createPyramid
+                        *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
+                        break;
+                    case GT_SPHERE:
+                        {
+                            double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
+                            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
+                            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
+                        }
+                        break;
+                    }
+                }
             }
         }
         

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-11 22:19:43 UTC (rev 3531)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-12 17:27:18 UTC (rev 3532)
@@ -191,8 +191,8 @@
             Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
 
             /// @ todo change this
-            //torque = springAcc * inertia; // this would be correct
-            torque = springAcc * mass * 40;
+            torque = springAcc * inertia; // this would be correct
+            //torque = springAcc * mass * 40;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {



From tanis at mail.berlios.de  Wed Jun 13 22:47:34 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 13 Jun 2007 22:47:34 +0200
Subject: [Dsa-hl-svn] r3533 - in rl/trunk/engine: rules/include rules/src
	ui/include ui/src
Message-ID: <200706132047.l5DKlXdp005209@sheep.berlios.de>

Author: tanis
Date: 2007-06-13 22:47:08 +0200 (Wed, 13 Jun 2007)
New Revision: 3533

Modified:
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/ui/include/CombatCharacterController.h
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
Log:
Not yet working changes to CombatController. Starting litte HUD display, but for some reasons nothing is shown yet. Oh well...

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2007-06-12 17:27:18 UTC (rev 3532)
+++ rl/trunk/engine/rules/include/Combat.h	2007-06-13 20:47:08 UTC (rev 3533)
@@ -28,6 +28,8 @@
     class _RlRulesExport Combat
     {
     public:
+        typedef std::set<Creature*> CreatureSet;
+
         Combat(Creature* character);
         ~Combat();
 
@@ -37,8 +39,10 @@
         void addAlly(Creature*);
         void removeAlly(Creature*);
 
+        const CreatureSet& getAllOpponents() const;
+        const CreatureSet& getAllAllies() const;
+
     private:
-        typedef std::set<Creature*> CreatureSet;
         Creature* mCharacter;
         CreatureSet mOpponents;
         CreatureSet mAllies;

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2007-06-12 17:27:18 UTC (rev 3532)
+++ rl/trunk/engine/rules/src/Combat.cpp	2007-06-13 20:47:08 UTC (rev 3533)
@@ -45,4 +45,14 @@
     {
         mAllies.erase(creature);
     }
+
+    const Combat::CreatureSet& Combat::getAllOpponents() const
+    {
+        return mOpponents;
+    }
+
+    const Combat::CreatureSet& Combat::getAllAllies() const
+    {
+        return mAllies;
+    }
 }

Modified: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-12 17:27:18 UTC (rev 3532)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-13 20:47:08 UTC (rev 3533)
@@ -22,6 +22,8 @@
 #include "CharacterController.h"
 #include "Selector.h"
 
+#include <OgreRectangle.h>
+
 namespace rl {
 
     class Combat;
@@ -48,6 +50,13 @@
         Combat* mCombat;
         CombatWindow* mCombatWindow;
         HalfSphereSelector mEnemySelector;
+
+        Ogre::Camera* mCamera;
+
+        /// Little Helper-MO for visualisation for everything that is difficult with cegui.
+        Ogre::ManualObject* mHud;
+
+        Ogre::Rectangle getScreenRectFromWorldAABB(const Ogre::AxisAlignedBox& aabb) const;
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-12 17:27:18 UTC (rev 3532)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-13 20:47:08 UTC (rev 3533)
@@ -30,6 +30,9 @@
 #include "WindowFactory.h"
 #include "World.h"
 
+#include <OgreManualObject.h>
+using namespace Ogre;
+
 namespace rl {
     CombatCharacterController::CombatCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
@@ -38,13 +41,26 @@
           mCombat(NULL),
           mCombatWindow(NULL),
           mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE)
+            QUERYFLAG_CREATURE),
+          mCamera(NULL)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
         mEnemySelector.setFilter(filter);
 
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
+        mCamera = static_cast<Ogre::Camera*>(mCameraActor->_getMovableObject());
+
+        // Initialise HUD-MO. Put it into 2D mode and make sure it is always rendered.
+        SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
+        mHud = sceneMgr->createManualObject("__COMBAT_HUD__");
+        mHud->setUseIdentityProjection(true);
+        mHud->setUseIdentityView(true);
+        AxisAlignedBox infiniteAabb;
+        infiniteAabb.setInfinite();
+        mHud->setBoundingBox(infiniteAabb);
+        mHud->setRenderQueueGroup(RENDER_QUEUE_OVERLAY);
+        sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
     }
 
 	CombatCharacterController::~CombatCharacterController()
@@ -111,5 +127,54 @@
 
 	void CombatCharacterController::run(Ogre::Real elapsedTime)
     {
+        // HUD aktualisieren.
+        mHud->clear();
+        
+        mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_TRIANGLE_LIST);
+        const Combat::CreatureSet& opponents = mCombat->getAllOpponents();
+        for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();
+            it != end; ++it)
+        {
+            MeshObject* mesh = dynamic_cast<MeshObject*>((*it)->getActor()->getControlledObject());
+            Ogre::Rectangle rec = getScreenRectFromWorldAABB(mesh->getDefaultSize());
+            mHud->position(rec.left,  rec.top,    0.0f);
+            mHud->position(rec.left,  rec.bottom, 0.0f);
+            mHud->position(rec.right, rec.top,    0.0f);
+
+            mHud->position(rec.right, rec.top,    0.0f);
+            mHud->position(rec.left,  rec.bottom, 0.0f);
+            mHud->position(rec.right, rec.bottom, 0.0f);
+        }
+        mHud->end();
     }
+
+    Ogre::Rectangle CombatCharacterController::getScreenRectFromWorldAABB(
+        const AxisAlignedBox& aabb) const
+    {
+        // Initialise each to the value of the opposite side, so that min/max work smoothly.
+        Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
+
+        const Matrix4& viewMatrix = mCamera->getViewMatrix(true);
+        const Matrix4& projMatrix = mCamera->getProjectionMatrix();
+
+        // Determine screen pos of all corners and widen the rect if needed
+        const Vector3* corners = aabb.getAllCorners();
+        for (size_t i = 0; i < 8; ++i)
+        {
+            Vector3 eyeSpacePos = viewMatrix.transformAffine(corners[i]);
+
+            // ignore point, if it is behind the cam.
+            if (eyeSpacePos.z > 0) continue;
+
+            Vector3 screenSpacePos =  projMatrix * eyeSpacePos;
+
+            left   = std::min(left,   screenSpacePos.x);
+            right  = std::max(right,  screenSpacePos.x);
+            bottom = std::min(bottom, screenSpacePos.y);
+            top    = std::max(top,    screenSpacePos.y);
+        }
+
+        Ogre::Rectangle rval = {left,top, right, bottom};
+        return rval;
+    }
 }



From tanis at mail.berlios.de  Wed Jun 13 23:34:02 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 13 Jun 2007 23:34:02 +0200
Subject: [Dsa-hl-svn] r3534 - rl/trunk/engine/ui/src
Message-ID: <200706132134.l5DLY2wo009054@sheep.berlios.de>

Author: tanis
Date: 2007-06-13 23:33:56 +0200 (Wed, 13 Jun 2007)
New Revision: 3534

Modified:
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
Log:
Fixed previously mentioned bug.

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-13 20:47:08 UTC (rev 3533)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-13 21:33:56 UTC (rev 3534)
@@ -130,20 +130,23 @@
         // HUD aktualisieren.
         mHud->clear();
         
-        mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_TRIANGLE_LIST);
+        mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_LINE_STRIP);
         const Combat::CreatureSet& opponents = mCombat->getAllOpponents();
         for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
-            MeshObject* mesh = dynamic_cast<MeshObject*>((*it)->getActor()->getControlledObject());
-            Ogre::Rectangle rec = getScreenRectFromWorldAABB(mesh->getDefaultSize());
+            Ogre::Rectangle rec = getScreenRectFromWorldAABB(
+                (*it)->getActor()->_getSceneNode()->_getWorldAABB());
             mHud->position(rec.left,  rec.top,    0.0f);
             mHud->position(rec.left,  rec.bottom, 0.0f);
             mHud->position(rec.right, rec.top,    0.0f);
+            mHud->position(rec.right, rec.bottom, 0.0f);
 
-            mHud->position(rec.right, rec.top,    0.0f);
-            mHud->position(rec.left,  rec.bottom, 0.0f);
-            mHud->position(rec.right, rec.bottom, 0.0f);
+            mHud->index(0);
+            mHud->index(1);
+            mHud->index(3);
+            mHud->index(2);
+            mHud->index(0);
         }
         mHud->end();
     }



From melven at mail.berlios.de  Sun Jun 17 17:49:06 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 17 Jun 2007 17:49:06 +0200
Subject: [Dsa-hl-svn] r3535 - rl/trunk/engine/rules/src
Message-ID: <200706171549.l5HFn6XC027678@sheep.berlios.de>

Author: melven
Date: 2007-06-17 17:48:55 +0200 (Sun, 17 Jun 2007)
New Revision: 3535

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
-changed formula for long jump
-added animation-transitions for joggen, laufen, and rennen

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-13 21:33:56 UTC (rev 3534)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-06-17 15:48:55 UTC (rev 3535)
@@ -325,7 +325,33 @@
             //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
             //Real length = charMesh->getAnimation("Run")->getLength();
             Real length = 5./3.;
-            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
+            Real weight = 1;
+            Real relTimeOffset = 0;
+
+
+            switch( mMovingCreature->getLastMovementType() )
+            {
+            case MovingCreature::MT_NONE:
+                break;
+            case MovingCreature::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case MovingCreature::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+            }
+
+            // apply relTimeOffset only once
+            if( mMovingCreature->getLastMovementChange() > elapsedTime )
+                relTimeOffset = 0;
+
+            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
+            if( meshAnim != NULL )
+                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
         }
     };
 
@@ -367,7 +393,33 @@
             //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
             //Real length = charMesh->getAnimation("Run")->getLength();
             Real length = 5./3.;
-            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
+            Real weight = 1;
+            Real relTimeOffset = 0;
+
+
+            switch( mMovingCreature->getLastMovementType() )
+            {
+            case MovingCreature::MT_NONE:
+                break;
+            case MovingCreature::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case MovingCreature::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+            }
+
+            // apply relTimeOffset only once
+            if( mMovingCreature->getLastMovementChange() > elapsedTime )
+                relTimeOffset = 0;
+
+            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
+            if( meshAnim != NULL )
+                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
         }
         virtual void activate()
         {
@@ -451,7 +503,33 @@
             //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
             //Real length = charMesh->getAnimation("Run")->getLength();
             Real length = 5./3.;
-            mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length) );
+            Real weight = 1;
+            Real relTimeOffset = 0;
+
+
+            switch( mMovingCreature->getLastMovementType() )
+            {
+            case MovingCreature::MT_NONE:
+                break;
+            case MovingCreature::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case MovingCreature::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+            }
+
+            // apply relTimeOffset only once
+            if( mMovingCreature->getLastMovementChange() > elapsedTime )
+                relTimeOffset = 0;
+
+            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
+            if( meshAnim != NULL )
+                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
         }
         virtual void activate()
         {
@@ -803,7 +881,11 @@
     class Weitsprung : public AbstractMovement
     {
     public:
-        Weitsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mWidth(0), mJumpNow(false), mTimer(0) {}
+        Weitsprung(MovingCreature *creature) : 
+          AbstractMovement(creature), mState(DOWN), mWidth(0),
+              mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
+              mApplyForceTimer(0), mLastForce(Vector3::ZERO),
+              mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17))) {}
         virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_WEITSPRUNG;}
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
         virtual void activate()
@@ -816,6 +898,20 @@
 
             try
             {
+                // the person will only achieve this width if it is running
+                // retrieve run movement
+                AbstractMovement *run = mMovingCreature->getMovementFromId(MovingCreature::MT_RENNEN);
+                if( run != NULL )
+                {
+                    Real vel(0);
+                    run->calculateBaseVelocity(vel);
+                    Real factor = -mMovingCreature->getVelocity().z / vel;
+                    factor = std::max(Real(0),factor);
+                    // without moving before, the width will be 1/3
+                    mWidth = mWidth/3. + mWidth * 2./3. * factor; 
+                }
+
+
                 int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
                 if( taw > 0 )
                 {
@@ -879,25 +975,67 @@
             OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
             body->getMassMatrix(mass, inertia);
 
-            if( mJumpNow )
+
+            if( mJumpNow && timestep != 0 )
             {
-                mJumpNow = false;
+                mApplyForceTimer += timestep;
 
-                Real m = mass;
-                Real g = PhysicsManager::getSingleton().getGravity().length();
-                Real v0 = mMovingCreature->getVelocity().length();
-                Real t = timestep;
-                Real s = mWidth;
-                Real jumpForcezy = 
-                    m*g/4 - v0*m /2 /t + 
-                    Math::Sqrt( 
-                        v0*v0 * m*m  -
-                        v0 * m*m *g *t +
-                        m*m * g*g * t*t /4 +
-                        2 * s * m*m *g
-                               )/2/t;
-                force += Vector3(0,jumpForcezy,-jumpForcezy);
-                mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                if( mApplyForceTimer == timestep // first time
+                    && mApplyForceTimer < mApplyForceTime )// this is handled below
+                {
+                    Real t1 = mApplyForceTime;
+                    Real sx = mWidth;
+                    Real g = -PhysicsManager::getSingleton().getGravity().y;
+                    Real v0 = mVelocityBeforeJump;
+                    Real ax = 0;
+                    Real ay = 0;
+
+                    if( t1 != 0 || 2 * sx >= v0 * t1 )
+                    {
+                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                        Real v1y = mTanJumpAngle * v1x;
+                        ax =  (v1x - v0) / t1;
+                        ay = v1y/t1 + g;
+                    }
+                    
+                    mLastForce.x = 0;
+                    mLastForce.y = ay * mass;
+                    mLastForce.z = -ax * mass;
+                }
+
+                if( mApplyForceTimer < mApplyForceTime )
+                {
+                    force = mLastForce;
+                }
+                else
+                {
+                    mJumpNow = false;
+                    // adoption of the formula to our real jump time
+                    Real t1 = mApplyForceTimer;
+                    Real sx = mWidth;
+                    Real g = -PhysicsManager::getSingleton().getGravity().y;
+                    Real v0 = mVelocityBeforeJump;
+                    Real ax = 0;
+                    Real ay = 0;
+
+                    if( t1 != 0 || 2 * sx >= v0 * t1 )
+                    {
+                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                        Real v1y = mTanJumpAngle * v1x;
+
+std::ostringstream oss;
+oss << "v0: " << v0 << "    v1x: " << v1x << "    timediff: " << mApplyForceTimer - mApplyForceTime;
+LOG_MESSAGE(Logger::RULES, oss.str());
+
+                        Vector3 v_now = mMovingCreature->getVelocity();
+                        ax =  (v1x - -v_now.z) / timestep;
+                        ay = (v1y- v_now.y)/timestep + g;
+                    }
+                    
+                    force.x = 0;
+                    force.y = ay * mass;
+                    force.z = -ax * mass;
+                }
             }
 
             Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
@@ -912,7 +1050,7 @@
             if( mState == UPTODOWN )
             {
                 mTimer += elapsedTime;
-                if( mTimer >= 0.5f )
+                if( mTimer >= 0.2f )
                 {
                     mState = DOWN;
                 }
@@ -940,6 +1078,8 @@
                     mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
                     //mMovingCreature->setAnimation("rennen_sprung");
                     mJumpNow = true;
+                    mApplyForceTimer = 0;
+                    mVelocityBeforeJump = -mMovingCreature->getVelocity().z;
                     mTimer = 0;
                 }
             }
@@ -967,6 +1107,11 @@
         Ogre::Real mWidth;
         bool mJumpNow;
         Ogre::Real mTimer;
+        Ogre::Real mApplyForceTime;
+        Ogre::Real mApplyForceTimer;
+        Ogre::Vector3 mLastForce;
+        Ogre::Real mVelocityBeforeJump;
+        Ogre::Real mTanJumpAngle;
     };
 
 



From josch at mail.berlios.de  Tue Jun 19 00:20:24 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Tue, 19 Jun 2007 00:20:24 +0200
Subject: [Dsa-hl-svn] r3536 - modules/common/scripts
	modules/regressiontest/dsa modules/regressiontest/scripts
	modules/regressiontest/scripts/maps
	rl/trunk/engine/core/include rl/trunk/engine/core/src
	rl/trunk/engine/script/swig
Message-ID: <200706182220.l5IMKO32013790@sheep.berlios.de>

Author: josch
Date: 2007-06-19 00:20:14 +0200 (Tue, 19 Jun 2007)
New Revision: 3536

Modified:
   modules/common/scripts/torch.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/SoundTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   rl/trunk/engine/core/include/LinearSoundFadeFunctor.h
   rl/trunk/engine/core/include/SoundFadeFunctor.h
   rl/trunk/engine/core/include/SoundFadeJob.h
   rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
   rl/trunk/engine/core/src/SoundFadeFunctor.cpp
   rl/trunk/engine/core/src/SoundFadeJob.cpp
   rl/trunk/engine/script/swig/RlCore.swig
Log:
- Changed Sound fades
- Added to Soundtest

Modified: modules/common/scripts/torch.rb
===================================================================
--- modules/common/scripts/torch.rb	2007-06-17 15:48:55 UTC (rev 3535)
+++ modules/common/scripts/torch.rb	2007-06-18 22:20:14 UTC (rev 3536)
@@ -12,7 +12,7 @@
 # Die Aktion f?r das Anz?nden der Fackel.
 class LightTorchAction < Action
     def initialize()
-        super("lighttorch", "Die Fackel anz?nden f?r mehr Licht und so.");
+        super("lighttorch", "Die Fackel anz?nden f?r mehr Licht und so.")
     end
     
     # Die Methode pr?ft, ob die Aktion ?berhaupt angeboten wird.
@@ -22,7 +22,6 @@
     end
     
     def doAction(torch, user, target)
-        p torch.lit?
         return if torch.lit?
         # Fackel hat ein Licht am Slot SLOT_FAR_END
         # Man k?nnte es auch so machen, dass dieses Licht jetzt
@@ -54,7 +53,7 @@
 # Die Aktion f?r das L?schen der Fackel.
 class PutoutTorchAction < Action
     def initialize
-        super("putouttorch", "Die Fackel l?schen f?r Verstecken und so.");
+        super("putouttorch", "Die Fackel l?schen f?r Verstecken und so.")
     end
     
     # Die Methode pr?ft, ob die Aktion ?berhaupt angeboten wird.

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-17 15:48:55 UTC (rev 3535)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-18 22:20:14 UTC (rev 3536)
@@ -94,6 +94,13 @@
         <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
     </gameobjectclass>
 
+    <!-- SoundTest -->
+    <gameobjectclass classid="SoundFadeTest" baseclass="GameObject">
+        <property name="name" type="STRING" data="SoundFadeTest"/>
+        <property name="description" type="STRING" data="The Sound Fading TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
     <!-- JobSequenceTest -->
     <gameobjectclass classid="JobSequenceTestChest" baseclass="GameObject">
         <property name="name" type="STRING" data="JobSequence-Truhe"/>

Modified: modules/regressiontest/scripts/SoundTest.rb
===================================================================
--- modules/regressiontest/scripts/SoundTest.rb	2007-06-17 15:48:55 UTC (rev 3535)
+++ modules/regressiontest/scripts/SoundTest.rb	2007-06-18 22:20:14 UTC (rev 3536)
@@ -2,35 +2,59 @@
 require 'testcase.rb'
 require 'torch.rb'
 
-class SoundTest < TestCase
-    include Math
 
-    @@torchcount = 10
-    @@height = 0.50
-    @@radius = 5
-    
-    def initialize(center)
-        super(center)
+class SoundFadeAction < Action
+  def initialize
+    super("SoundFadeAction", "Tests fading code.")
+  end
   
-        min_base = [-@@radius, 0.05, -@@radius]
-        max_base = [@@radius, 0.3, @@radius]
-        base = $AM.createBoxPrimitiveActor("SoundTestBase",
-                                           min_base, max_base, "alpha_blue")
-        base.placeIntoScene(center);
+  def canDo(go, user)
+    true
+  end
+  
+  def doAction(go, user, target)
+    p "SoundFadeAction"
+    sound = $SM.createSound("ruchin001.ogg")
+    @sound = SoundObject.new(sound, "SoundFadeTest")
+    @functor = LinearSoundFadeFunctor.new(120, false)
+    @job = SoundFadeJob.new (@sound, @functor, true)
+  end
+  
+end
 
-        step = 2 * PI / @@torchcount
-        0.step(2 * PI, step) do |radian|
-            x = cos(radian) * @@radius
-            y = sin(radian) * @@radius
-            fackel = $GOM.createGameObject("torch")
-            fackel.setDescription("Fackel" + radian.to_s)
-            fackel.setPosition(rel_pos([x, @@height, y]))
-            fackel.setLit(true)
-            fackel.placeIntoScene()
-        end
-        
-        $SCRIPT.log("SoundTest initialisiert");
-        
+class SoundTest < TestCase
+  include Math
+  
+  @@torchcount = 10
+  @@height = 0.30
+  @@radius = 5
+  
+  def initialize(center)
+    super(center)
+    
+    min_base = [-@@radius, 0.05, -@@radius]
+    max_base = [@@radius, @@height, @@radius]
+    base = $AM.createBoxPrimitiveActor("SoundTestBase", min_base, max_base, "alpha_blue")
+    base.placeIntoScene(center)
+    
+    eh = $GOM.createGameObject("SoundFadeTest")
+    eh.addAction(SoundFadeAction.new())
+    eh.placeIntoScene()
+    eh.setPosition(rel_pos([0.0, @@height, 0.0]))
+    
+    step = 2 * PI / @@torchcount
+    0.step(2 * PI, step) do |radian|
+      x = cos(radian) * @@radius
+      y = sin(radian) * @@radius
+      fackel = $GOM.createGameObject("torch")
+      fackel.setDescription("Fackel" + radian.to_s)
+      fackel.setPosition(rel_pos([x, @@height, y]))
+      fackel.setLit(true)
+      fackel.placeIntoScene()
     end
+    
+    $SCRIPT.log("SoundTest initialisiert")
+    
+  end
   
 end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-17 15:48:55 UTC (rev 3535)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-18 22:20:14 UTC (rev 3536)
@@ -34,17 +34,17 @@
 
 $SCRIPT.log("begin tests.");
 
-#         DoorTest.new([0, 0, -5])
-#          NpcTest.new([-5, 0, 5])
-#   NpcCapsuleTest.new([0, 0, 5])
-#         TimeTest.new([-5, 0, -5])
-#ErrorHandlingTest.new([-10, 0, 5])
-#    InventoryTest.new([0, 0, 10])
-#  JobSequenceTest.new([5, 0, -5])
-#       EffectTest.new([5, 0, 5])
-#        SoundTest.new([10, 0, 10])
-#    LightzoneTest.new([-10, 0, -5])
-#   MapLoadingTest.new([-5, 0, -10])
+         DoorTest.new([0, 0, -5])
+          NpcTest.new([-5, 0, 5])
+   NpcCapsuleTest.new([0, 0, 5])
+         TimeTest.new([-5, 0, -5])
+ErrorHandlingTest.new([-10, 0, 5])
+    InventoryTest.new([0, 0, 10])
+  JobSequenceTest.new([5, 0, -5])
+       EffectTest.new([5, 0, 5])
+        SoundTest.new([10, 0, 10])
+    LightzoneTest.new([-10, 0, -5])
+   MapLoadingTest.new([-5, 0, -10])
 MergeableMeshTest.new([10, 0, 0])
 
 

Modified: rl/trunk/engine/core/include/LinearSoundFadeFunctor.h
===================================================================
--- rl/trunk/engine/core/include/LinearSoundFadeFunctor.h	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/include/LinearSoundFadeFunctor.h	2007-06-18 22:20:14 UTC (rev 3536)
@@ -26,10 +26,13 @@
     class _RlCoreExport LinearSoundFadeFunctor : public SoundFadeFunctor
     {
     public:
-        LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+        LinearSoundFadeFunctor(Ogre::Real duration, bool up);
 
-        virtual int operator()(Ogre::Real time, SoundObject* sound);
+        virtual Ogre::Real operator()(Ogre::Real time);
 
+    private:
+        // Curve goes up?
+        bool mUp;
     };
 }
 

Modified: rl/trunk/engine/core/include/SoundFadeFunctor.h
===================================================================
--- rl/trunk/engine/core/include/SoundFadeFunctor.h	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/include/SoundFadeFunctor.h	2007-06-18 22:20:14 UTC (rev 3536)
@@ -26,14 +26,11 @@
     class _RlCoreExport SoundFadeFunctor
     {
     public:
-        SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+        SoundFadeFunctor(Ogre::Real duration);
 
-        virtual int operator()(Ogre::Real time, SoundObject* sound) = 0;
+        virtual Ogre::Real operator()(Ogre::Real time) = 0;
 
     protected:
-        int mStartVolume;
-        int mEndVolume;
-        int mDiff;
         Ogre::Real mDuration;
     };
 }

Modified: rl/trunk/engine/core/include/SoundFadeJob.h
===================================================================
--- rl/trunk/engine/core/include/SoundFadeJob.h	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/include/SoundFadeJob.h	2007-06-18 22:20:14 UTC (rev 3536)
@@ -40,6 +40,8 @@
         SoundObject* mSoundObject;
         /// The time passed since job start.
         Ogre::Real mTime;
+        /// The starting volume for this job.
+        Ogre::Real mStartVolume;
         /// Functor which calculates the fading curve.
         SoundFadeFunctor* mSoundFadeFunctor;
     };

Modified: rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-06-18 22:20:14 UTC (rev 3536)
@@ -19,19 +19,20 @@
 
 namespace rl
 {
-    LinearSoundFadeFunctor::LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration) :
-        SoundFadeFunctor(startvolume, endvolume, duration)
+    LinearSoundFadeFunctor::LinearSoundFadeFunctor(Ogre::Real duration, bool up) :
+        SoundFadeFunctor(duration),
+        mUp(up)
     {
     }
 
-    int LinearSoundFadeFunctor::operator()(Ogre::Real time, SoundObject* sound)
+    Ogre::Real LinearSoundFadeFunctor::operator()(Ogre::Real time)
     {
         Ogre::Real factor = time / mDuration;
         if (factor > 1.0)
         {
             return -1; // Done
         } else {
-            return floor(mStartVolume + factor * mDiff);
+            return factor * (mUp ? 1.0 : -1.0);
         }
     }  
     

Modified: rl/trunk/engine/core/src/SoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-06-18 22:20:14 UTC (rev 3536)
@@ -19,12 +19,9 @@
 
 namespace rl
 {
-    SoundFadeFunctor::SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration) :
-        mDuration(duration),
-        mEndVolume(endvolume),
-        mStartVolume(startvolume)
+    SoundFadeFunctor::SoundFadeFunctor(Ogre::Real duration) :
+        mDuration(duration)
     {
-        mDiff = mEndVolume - mStartVolume;
     }
 
 

Modified: rl/trunk/engine/core/src/SoundFadeJob.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-06-18 22:20:14 UTC (rev 3536)
@@ -17,6 +17,7 @@
 #include "SoundFadeJob.h"
 #include "SoundFadeFunctor.h"
 #include "SoundObject.h"
+#include "Sound.h"
 
 namespace rl
 {
@@ -26,11 +27,12 @@
         mSoundFadeFunctor(fadeFunctor),
         mTime(0)
     {
+        mStartVolume = mSoundObject->getSound()->getVolume();
     }
 
     bool SoundFadeJob::execute(Ogre::Real time)
     {
-        // Precondition: mLightObject != NULL
+        // Precondition: mSoundObject != NULL
         if (mSoundObject == NULL)
         {
             discard();
@@ -39,10 +41,10 @@
 
         // add passed time to total time
         mTime += time;
-        int volume = (*mSoundFadeFunctor)(mTime, mSoundObject);
+        Ogre::Real volume = (*mSoundFadeFunctor)(mTime) * mStartVolume;
 
         // Are we done now?
-        if (volume < 0)
+        if (volume <= 0.0)
         {
             discard();
             return true;
@@ -54,7 +56,7 @@
 
     void SoundFadeJob::discard()
     {
-        mSoundObject->setVolume(0);
+        mSoundObject->setVolume(0.0);
         mSoundObject->stop();
     }
 

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-06-17 15:48:55 UTC (rev 3535)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-06-18 22:20:14 UTC (rev 3536)
@@ -934,20 +934,22 @@
     virtual void discard();
 };
 
+%rename(getVolume) rl::SoundFadeFunctor::operator();
 class SoundFadeFunctor
 {
 public:
-    SoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+    SoundFadeFunctor(Ogre::Real duration);
 
-    virtual int operator()(Ogre::Real time, rl::SoundObject* sound) = 0;
+    virtual Ogre::Real operator()(Ogre::Real time) = 0;
 };
 
+%rename(getVolume) rl::LinearSoundFadeFunctor::operator();
 class LinearSoundFadeFunctor : public rl::SoundFadeFunctor
 {
 public:
-    LinearSoundFadeFunctor(int startvolume, int endvolume, Ogre::Real duration);
+    LinearSoundFadeFunctor(Ogre::Real duration, bool up);
 
-    virtual int operator()(Ogre::Real time, rl::SoundObject* sound);
+    virtual Ogre::Real operator()(Ogre::Real time);
 };
 
 



From blakharaz at mail.berlios.de  Wed Jun 20 10:55:27 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 20 Jun 2007 10:55:27 +0200
Subject: [Dsa-hl-svn] r3537 - rl/trunk/engine/rules/src
Message-ID: <200706200855.l5K8tRl2021074@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-20 10:55:26 +0200 (Wed, 20 Jun 2007)
New Revision: 3537

Modified:
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/Item.cpp
Log:
Call onStateChange on every GameObject state change

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-06-18 22:20:14 UTC (rev 3536)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-06-20 08:55:26 UTC (rev 3537)
@@ -697,15 +697,19 @@
             return;
         }
 
+        GameObjectState oldState = mState;
+
         if (targetstate == GOS_LOADED && mState == GOS_IN_SCENE)
         {
             // Statechange event is triggered in this function
             doRemoveFromScene();
+            onStateChange(oldState, targetstate);
         }
         else if (targetstate == GOS_IN_SCENE && mState == GOS_LOADED)
         {
             //Statechange event is triggered in this function
             doPlaceIntoScene();
+            onStateChange(oldState, targetstate);
         }
         else
         {

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-06-18 22:20:14 UTC (rev 3536)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-06-20 08:55:26 UTC (rev 3537)
@@ -106,6 +106,7 @@
         }
 
         bool stateChanged = false;
+        GameObjectState oldState = mState;
 
         if (targetstate == GOS_IN_POSSESSION)
         {
@@ -179,8 +180,12 @@
             ///@todo
         }
 
-        if (!stateChanged)
+        if (stateChanged)
         {
+            onStateChange(oldState, targetstate);
+        }
+        else
+        {
             GameObject::setState(targetstate);
         }
     }



From blakharaz at mail.berlios.de  Wed Jun 20 10:57:20 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 20 Jun 2007 10:57:20 +0200
Subject: [Dsa-hl-svn] r3538 - modules/common/gui/windows
	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
Message-ID: <200706200857.l5K8vKi5021140@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-20 10:57:17 +0200 (Wed, 20 Jun 2007)
New Revision: 3538

Modified:
   modules/common/gui/windows/inventory_human.xml
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Drop item if dragged from inventory window to "world"

Modified: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-06-20 08:55:26 UTC (rev 3537)
+++ modules/common/gui/windows/inventory_human.xml	2007-06-20 08:57:17 UTC (rev 3538)
@@ -1,101 +1,105 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
-		<Property Name="VerticalAlignment" Value="Centre" />
-		<Property Name="HorizontalAlignment" Value="Centre" />
-		<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
-		<Property Name="Text" Value="Inventar" />
+	<Window Type="DefaultWindow" Name="InventoryWindow/Background">
+		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}" />
+		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
 		
-		<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">
-			<Property Name="UnifiedPosition" Value="{{0,5},{0,5}}" />
-			<Property Name="UnifiedSize" Value="{{0,400},{0,540}}" />
+	    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
+			<Property Name="VerticalAlignment" Value="Centre" />
+			<Property Name="HorizontalAlignment" Value="Centre" />
+			<Property Name="UnifiedSize" Value="{{0,420},{0,560}}" />
+			<Property Name="Text" Value="Inventar" />
 			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Head">
-				<Property Name="UnifiedPosition" Value="{{0.0,150},{0,40}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
+			<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">
+				<Property Name="UnifiedPosition" Value="{{0,5},{0,5}}" />
+				<Property Name="UnifiedSize" Value="{{0,400},{0,540}}" />
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Head">
+					<Property Name="UnifiedPosition" Value="{{0.0,150},{0,40}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Back">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,450}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Back">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,450}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Ring">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Ring">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Ring">
-				<Property Name="UnifiedPosition" Value="{{0,300},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Ring">
+					<Property Name="UnifiedPosition" Value="{{0,300},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>				
 
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Hand">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,80}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
-			</Window>
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Hand">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,80}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Hand">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,80}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Armor">
+					<Property Name="UnifiedPosition" Value="{{0,135},{0,110}}" />
+					<Property Name="UnifiedSize" Value="{{0,90},{0,120}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Belt">
+					<Property Name="UnifiedPosition" Value="{{0,135},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,90},{0,30}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Trousers">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,90}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Boots">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,450}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Shinbone">
+					<Property Name="UnifiedPosition" Value="{{0,150},{0,380}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Necklace">
+					<Property Name="UnifiedPosition" Value="{{0,225},{0,70}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
+				
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletRight">
+					<Property Name="UnifiedPosition" Value="{{0,70},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
 			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Hand">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,80}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletLeft">
+					<Property Name="UnifiedPosition" Value="{{0,260},{0,240}}" />
+					<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Gloves">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,350}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Bracers">
+					<Property Name="UnifiedPosition" Value="{{0,30},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
+					<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
+					<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
+				</Window>
+					
 			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Armor">
-				<Property Name="UnifiedPosition" Value="{{0,135},{0,110}}" />
-				<Property Name="UnifiedSize" Value="{{0,90},{0,120}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Belt">
-				<Property Name="UnifiedPosition" Value="{{0,135},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,90},{0,30}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Trousers">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,90}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Boots">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,450}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Shinbone">
-				<Property Name="UnifiedPosition" Value="{{0,150},{0,380}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Necklace">
-				<Property Name="UnifiedPosition" Value="{{0,225},{0,70}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-			
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletRight">
-				<Property Name="UnifiedPosition" Value="{{0,70},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-		
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletLeft">
-				<Property Name="UnifiedPosition" Value="{{0,260},{0,240}}" />
-				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Gloves">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,350}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Bracers">
-				<Property Name="UnifiedPosition" Value="{{0,30},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
-			</Window>
-			
-			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
-				<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
-				<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
-			</Window>
-
-				
 		</Window>
 	</Window>
 </GUILayout>

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-06-20 08:55:26 UTC (rev 3537)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-06-20 08:57:17 UTC (rev 3538)
@@ -26,17 +26,6 @@
 
     class Inventory;
 
-	//class _RlUiExport InventoryArrangeTask : public GameTask
-	//{
-	//public:
-	//	InventoryArrangeTask();
-	//	~InventoryArrangeTask();
-	//	
-	//	void run(Ogre::Real elapsedTime);
-
- //       virtual const Ogre::String& getName() const;
-	//};
-
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
@@ -49,12 +38,14 @@
     private:
         Inventory* mInventory;
         std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
+		CEGUI::Window* mWorldBackground;
 
         void createSlotWindows(Inventory* inventory);
         void initInventoryWindow(Inventory* inventory);
 
 		CEGUI::Window* createItemWindow(const CeGuiString& containerName, Item* item);
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
+		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
 		bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
     };

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-20 08:55:26 UTC (rev 3537)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-20 08:57:17 UTC (rev 3538)
@@ -20,6 +20,7 @@
 #include <CEGUIImagesetManager.h>
 #include <CEGUIWindowManager.h>
 
+#include "Creature.h"
 #include "ItemDragContainer.h"
 #include "WindowFactory.h"
 
@@ -37,6 +38,7 @@
         mInventory = inventory;
 
         //mSquareSize = ...;
+		mWorldBackground = getWindow("InventoryWindow/Background");
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);
@@ -115,6 +117,9 @@
 				}
             }
         }
+		mWorldBackground->setDragDropTarget(true);
+		mWorldBackground->subscribeEvent(Window::EventDragDropItemDropped, 
+			boost::bind(&InventoryWindow::handleItemDroppedOnWorld, this, _1));
     }
 
 	Window* InventoryWindow::createItemWindow(const CeGuiString& slotName, Item* item)
@@ -201,6 +206,49 @@
 		return false;
 	}
 
+	bool InventoryWindow::handleItemDroppedOnWorld(const EventArgs& evt)
+	{
+		const DragDropEventArgs& evtArgs = static_cast<const DragDropEventArgs&>(evt);
+		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
+		{
+			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+				evtArgs.dragDropItem);
+			Item* item = dragcont->getItem();
+			Vector2 targetPosWindow = dragcont->getPosition().asRelative(
+				getRoot()->getPixelSize());
+
+			if (dragcont->getItemParentContainer() != NULL)
+			{
+				dragcont->getItemParentContainer()->removeItem(item);
+				dragcont->getParent()->removeChildWindow(dragcont);
+				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+
+			}
+			else if (dragcont->getItemParentSlot() != "")
+			{
+				dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
+
+				dragcont->getParent()->removeChildWindow(dragcont);
+				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+			}
+
+			Ogre::Vector3 targetPosWorldSpace = 
+				mInventory->getOwner()->getPosition() 
+				+ mInventory->getOwner()->getOrientation()
+				* Ogre::Vector3(1-targetPosWindow.d_x, 1-targetPosWindow.d_y, -1); ///@todo check why coordinates are negative
+			item->placeIntoScene();
+			item->setPosition(targetPosWorldSpace);
+
+			LOG_DEBUG(Logger::UI,
+				"Dropped item "+item->getName()
+				+" to position "+Ogre::StringConverter::toString(targetPosWorldSpace));
+			
+			return true;
+
+		}
+		return false;
+	}
+
 	bool InventoryWindow::handleItemMouseClick(const EventArgs& evt, Item* item)
 	{
 		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);



From blakharaz at mail.berlios.de  Wed Jun 20 10:58:45 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 20 Jun 2007 10:58:45 +0200
Subject: [Dsa-hl-svn] r3539 - modules/regressiontest/scripts
Message-ID: <200706200858.l5K8wjuX021238@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-20 10:58:44 +0200 (Wed, 20 Jun 2007)
New Revision: 3539

Modified:
   modules/regressiontest/scripts/InventoryTest.rb
   modules/regressiontest/scripts/mckhero.rb
Log:
temporary fix for backpack in inventory test

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2007-06-20 08:57:17 UTC (rev 3538)
+++ modules/regressiontest/scripts/InventoryTest.rb	2007-06-20 08:58:44 UTC (rev 3539)
@@ -5,7 +5,7 @@
   def initialize(center)
     super(center)
 
-    hero = $GOM.getGameObject(1);
+    hero = $UI.getActiveCharacter();
     backpack = $GOM.createGameObject("leather backpack");
     #backpack.addAction(ShowContainerContentAction.new());
     #backpack.setPosition(center);

Modified: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-06-20 08:57:17 UTC (rev 3538)
+++ modules/regressiontest/scripts/mckhero.rb	2007-06-20 08:58:44 UTC (rev 3539)
@@ -36,7 +36,8 @@
 	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, false);
-	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
+	#inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
+	inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
     inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, false);
 
 	#addSounds()



From blakharaz at mail.berlios.de  Wed Jun 20 23:05:23 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 20 Jun 2007 23:05:23 +0200
Subject: [Dsa-hl-svn] r3540 - in rl/trunk/engine: core/include core/src
	ui/include ui/src
Message-ID: <200706202105.l5KL5Ne4016196@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-20 23:05:16 +0200 (Wed, 20 Jun 2007)
New Revision: 3540

Modified:
   rl/trunk/engine/core/include/CameraObject.h
   rl/trunk/engine/core/src/CameraObject.cpp
   rl/trunk/engine/ui/include/CombatCharacterController.h
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
Log:
Moved world space -> screen space transformation to CameraObject for reuse

Modified: rl/trunk/engine/core/include/CameraObject.h
===================================================================
--- rl/trunk/engine/core/include/CameraObject.h	2007-06-20 08:58:44 UTC (rev 3539)
+++ rl/trunk/engine/core/include/CameraObject.h	2007-06-20 21:05:16 UTC (rev 3540)
@@ -30,12 +30,29 @@
         CameraObject(const Ogre::String& name);
         ~CameraObject();
 
-        /// Wie ActorControlledObject::getMovableObject, nur schon gebrauchsfertig gecastet.
+        /** 
+		 * Returns the Ogre camera
+		 * @return the camera
+		 */
         Ogre::Camera* getCamera() const;
 
+		/**
+		 * Returns the size of the bounding box
+		 * Note: an Ogre camera has no size, this method returns the size of
+		 * the physics proxy to prevent camera vs wall/object collisions
+		 */
 		Ogre::AxisAlignedBox getDefaultSize() const;
 
         virtual Ogre::String getObjectType() const;
+
+		/** 
+		 * Transforms a point in world space into the (2D) screen space
+		 * @param worldCoords point in world space
+		 * @return the corresponding position on the screen. x,y are in [0,1].
+		 * The z component is the z value from the eye space, this allows checking
+		 * whether a point was behind the camera (z>0 in this case)
+		 */
+		Ogre::Vector3 getPointOnScreen(const Ogre::Vector3& worldCoords) const;
     };
 }
 #endif

Modified: rl/trunk/engine/core/src/CameraObject.cpp
===================================================================
--- rl/trunk/engine/core/src/CameraObject.cpp	2007-06-20 08:58:44 UTC (rev 3539)
+++ rl/trunk/engine/core/src/CameraObject.cpp	2007-06-20 21:05:16 UTC (rev 3540)
@@ -55,4 +55,17 @@
         Real r = getCamera()->getNearClipDistance();
         return AxisAlignedBox(2.0*Vector3(-r, -r, -r), 2.0*Vector3(r, r, r));
     }
+
+	Vector3 CameraObject::getPointOnScreen(const Ogre::Vector3& worldCoords) const
+	{
+		const Camera* camera = getCamera();
+        const Matrix4& viewMatrix = camera->getViewMatrix(true);
+        const Matrix4& projMatrix = camera->getProjectionMatrix();
+
+        Vector3 eyeSpacePos = viewMatrix.transformAffine(worldCoords);
+        Vector3 screenSpacePos =  projMatrix * eyeSpacePos;
+		screenSpacePos.z = eyeSpacePos.z;
+
+        return screenSpacePos;
+	}
 }

Modified: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-20 08:58:44 UTC (rev 3539)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-06-20 21:05:16 UTC (rev 3540)
@@ -26,6 +26,7 @@
 
 namespace rl {
 
+	class CameraObject;
     class Combat;
     class CombatManager;
     class CombatWindow;
@@ -51,7 +52,7 @@
         CombatWindow* mCombatWindow;
         HalfSphereSelector mEnemySelector;
 
-        Ogre::Camera* mCamera;
+        CameraObject* mCamera;
 
         /// Little Helper-MO for visualisation for everything that is difficult with cegui.
         Ogre::ManualObject* mHud;

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-20 08:58:44 UTC (rev 3539)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-06-20 21:05:16 UTC (rev 3540)
@@ -17,6 +17,7 @@
 #include "CombatCharacterController.h"
 
 #include "Actor.h"
+#include "CameraObject.h"
 #include "Combat.h"
 #include "CombatManager.h"
 #include "CombatWindow.h"
@@ -49,7 +50,7 @@
         mEnemySelector.setFilter(filter);
 
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
-        mCamera = static_cast<Ogre::Camera*>(mCameraActor->_getMovableObject());
+        mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
 
         // Initialise HUD-MO. Put it into 2D mode and make sure it is always rendered.
         SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
@@ -157,20 +158,13 @@
         // Initialise each to the value of the opposite side, so that min/max work smoothly.
         Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
 
-        const Matrix4& viewMatrix = mCamera->getViewMatrix(true);
-        const Matrix4& projMatrix = mCamera->getProjectionMatrix();
-
         // Determine screen pos of all corners and widen the rect if needed
         const Vector3* corners = aabb.getAllCorners();
         for (size_t i = 0; i < 8; ++i)
         {
-            Vector3 eyeSpacePos = viewMatrix.transformAffine(corners[i]);
+			Vector3 screenSpacePos = mCamera->getPointOnScreen(corners[i]);
+            if (screenSpacePos.z > 0) continue; // Behind camera
 
-            // ignore point, if it is behind the cam.
-            if (eyeSpacePos.z > 0) continue;
-
-            Vector3 screenSpacePos =  projMatrix * eyeSpacePos;
-
             left   = std::min(left,   screenSpacePos.x);
             right  = std::max(right,  screenSpacePos.x);
             bottom = std::min(bottom, screenSpacePos.y);



From blakharaz at mail.berlios.de  Mon Jun 25 19:50:15 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 25 Jun 2007 19:50:15 +0200
Subject: [Dsa-hl-svn] r3541 - rl/trunk/engine/core/src
Message-ID: <200706251750.l5PHoFUI002503@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-25 19:50:11 +0200 (Mon, 25 Jun 2007)
New Revision: 3541

Modified:
   rl/trunk/engine/core/src/CoreSubsystem.cpp
Log:
Delete AnimationManager before ActorManager


Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-06-20 21:05:16 UTC (rev 3540)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-06-25 17:50:11 UTC (rev 3541)
@@ -90,8 +90,8 @@
 		delete mWorld;
         delete mGameLoop;
         delete mJobScheduler;
+        delete mAnimationManager;
         delete mActorManager;
-        delete mAnimationManager;
         delete mDebugVisualsManager;
         delete mPhysicsManager;
         delete mXmlResourceManager;



From blakharaz at mail.berlios.de  Tue Jun 26 09:18:39 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 26 Jun 2007 09:18:39 +0200
Subject: [Dsa-hl-svn] r3542 - in modules/regressiontest/scripts: . maps
Message-ID: <200706260718.l5Q7IdHm023772@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-26 09:18:25 +0200 (Tue, 26 Jun 2007)
New Revision: 3542

Added:
   modules/regressiontest/scripts/SelectorTest.rb
Modified:
   modules/regressiontest/scripts/ErrorHandlingTest.rb
   modules/regressiontest/scripts/GameObjectCreationTest.rb
   modules/regressiontest/scripts/GameObjectStatesTest.rb
   modules/regressiontest/scripts/InventoryTest.rb
   modules/regressiontest/scripts/JobSequenceTest.rb
   modules/regressiontest/scripts/LightzoneTest.rb
   modules/regressiontest/scripts/MapLoadingTest.rb
   modules/regressiontest/scripts/MergeableMeshTest.rb
   modules/regressiontest/scripts/NpcCapsuleTest.rb
   modules/regressiontest/scripts/NpcTest.rb
   modules/regressiontest/scripts/SoundTest.rb
   modules/regressiontest/scripts/TimeTest.rb
   modules/regressiontest/scripts/doortest.rb
   modules/regressiontest/scripts/effecttest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/regressiontest/scripts/testcase.rb
Log:
* Added assert methods in regressiontest
* interface change on TestCase

Modified: modules/regressiontest/scripts/ErrorHandlingTest.rb
===================================================================
--- modules/regressiontest/scripts/ErrorHandlingTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/ErrorHandlingTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -17,16 +17,14 @@
 end
 
 class ErrorHandlingTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         # Define a base box to place everything else on.
         height = 0.3
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
         base = $AM.createBoxPrimitiveActor("ErrorHandling", min_base, max_base,
                                           "alpha_orange")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         eh = $GOM.createGameObject("ErrorHandling");
         eh.addAction(DirectorErrorAction.new());

Modified: modules/regressiontest/scripts/GameObjectCreationTest.rb
===================================================================
--- modules/regressiontest/scripts/GameObjectCreationTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/GameObjectCreationTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -1,13 +1,11 @@
 require 'testcase.rb'
 
 class GameObjectCreationTest < TestCase
-  def initialize(center)
-    super(center)
-
+  def execure()
     appl = $GOM.createGameObject("apple");
-    appl.setPosition([0,0,0]);
+    appl.setPosition(rel_pos[0,0,0]);
 
     appl2 = $GOM.createGameObject("apple", 15);
-    appl2.setPosition([0,1,0]);
+    appl2.setPosition(rel_pos[0,1,0]);
   end
 end
\ No newline at end of file

Modified: modules/regressiontest/scripts/GameObjectStatesTest.rb
===================================================================
--- modules/regressiontest/scripts/GameObjectStatesTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/GameObjectStatesTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -1,9 +1,7 @@
 require 'testcase.rb'
 
 class GameObjectStatesTest < TestCase
-  def initialize(center)
-    super(center)
-
+  def execute()
     appl2 = $GOM.createGameObject("apple", 15);
     p "appl2 created"
     appl2.placeIntoScene();

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/InventoryTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -2,9 +2,7 @@
 require 'npc.rb'
 
 class InventoryTest < TestCase
-  def initialize(center)
-    super(center)
-
+  def execute()
     hero = $UI.getActiveCharacter();
     backpack = $GOM.createGameObject("leather backpack");
     #backpack.addAction(ShowContainerContentAction.new());

Modified: modules/regressiontest/scripts/JobSequenceTest.rb
===================================================================
--- modules/regressiontest/scripts/JobSequenceTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/JobSequenceTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -27,16 +27,14 @@
 end
 
 class JobSequenceTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         # Define a base box to place everything else on.
         height = 0.3
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
         base = $AM.createBoxPrimitiveActor("JobSequenceTestBase",
                                            min_base, max_base, "alpha_green")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         chest = $GOM.createGameObject(
             "JobSequenceTestChest");

Modified: modules/regressiontest/scripts/LightzoneTest.rb
===================================================================
--- modules/regressiontest/scripts/LightzoneTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/LightzoneTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -1,16 +1,14 @@
 require 'testcase.rb'
 
 class LightzoneTest < TestCase
-  def initialize(center)
-    super(center)
-
+  def execute()
     	# Define a base box to place everything else on.
       height = 0.1
       min_base = [-3, 0.05, -3]
       max_base = [3, height, 3]
       base = $AM.createBoxPrimitiveActor("LightzoneTestBase",
                                          min_base, max_base, "alpha_gray")
-      base.placeIntoScene(center);
+      base.placeIntoScene(getCenter());
 	  
 	  MapLoader.new("regressiontest").loadMap("regressiontest_lights.rlmap.xml")
 

Modified: modules/regressiontest/scripts/MapLoadingTest.rb
===================================================================
--- modules/regressiontest/scripts/MapLoadingTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/MapLoadingTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -4,10 +4,8 @@
 end
 
 class MapLoadingTest < TestCase
-    def initialize(center)
-        super(center)
-
-		loader = MapLoader.new("regressiontest");
+    def execute()
+        loader = MapLoader.new("regressiontest");
         loader.loadMap("regressiontest_maploadingtest.rlmap.xml");
         
 		p "--- Built-in GO class, created by MapLoader ---"

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -1,9 +1,7 @@
 require 'globals.rb'
 
 class MergeableMeshTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         $SCRIPT.log(">MergeableMeshTest Start");
 
         $SCRIPT.log(">>MergeableMeshTest Actor Start");

Modified: modules/regressiontest/scripts/NpcCapsuleTest.rb
===================================================================
--- modules/regressiontest/scripts/NpcCapsuleTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/NpcCapsuleTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -2,15 +2,13 @@
 require 'npc.rb'
 
 class NpcCapsuleTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         height = 0.3
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
         base = $AM.createBoxPrimitiveActor("capsuleTestBase",
                                            min_base, max_base, "alpha_red")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         npc1proxy = $GOM.createGameObject("TestPersonCapsule");
         npc1 = npc1proxy;

Modified: modules/regressiontest/scripts/NpcTest.rb
===================================================================
--- modules/regressiontest/scripts/NpcTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/NpcTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -2,15 +2,14 @@
 require 'npc.rb'
 
 class NpcTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
+        
         height = 0.3
         min_base = [-3.0, 0.05, -3.0]
         max_base = [3.0, height, 3.0]
         base = $AM.createBoxPrimitiveActor("DialogTestBase",
                                            min_base, max_base, "alpha_blue")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         npc1proxy = $GOM.createGameObject("TestPerson");
         npc1 = npc1proxy;

Added: modules/regressiontest/scripts/SelectorTest.rb
===================================================================
--- modules/regressiontest/scripts/SelectorTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/SelectorTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -0,0 +1,55 @@
+require 'util/vector_util.rb'
+require 'testcase.rb'
+
+class SelectorTest < TestCase
+    include Math
+
+    @@radius = 5
+    
+    def execute()
+        min_base = [-@@radius, 0.05, -@@radius]
+        max_base = [@@radius, 0.3, @@radius]
+        base = $AM.createBoxPrimitiveActor("SelectorTestBase",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(getCenter());
+
+		go1 = $GOM.createGameObject("SelectorTest")
+		go1.setPosition(rel_pos([0.0, 0.4, 0.0]))
+		go1.placeIntoScene()
+		go2 = $GOM.createGameObject("SelectorTest")
+		go2.setPosition(rel_pos([2.0, 0.4, 0.0]))
+		go2.placeIntoScene()
+
+		testRaySelector()
+		#testHalfSphereSelector()
+        
+        $SCRIPT.log("SelectorTest initialisiert");
+        
+    end
+	
+	def testRaySelector()
+		testObj = RaySelector.new(QUERYFLAG_ITEM)
+		testObj.setRay(rel_pos([-0.5, 0.5, 0.0]), rel_pos([1.0, 0.5, 0.0]))
+		testObj.updateSelection()
+		assertEquals(1, testObj.getSelectionCount(), "One element ray selection")
+		
+		testObj2 = RaySelector.new(QUERYFLAG_ITEM)
+		testObj2.setRay(rel_pos([-0.5, 0.5, 0.0]), rel_pos([2.5, 0.5, 0.0]))
+		testObj2.updateSelection()
+		assertEquals(2, testObj2.getSelectionCount(), "Two element ray selection")
+	end
+  
+	def testHalfSphereSelector()
+		testObj = HalfSphereSelector.new(QUERYFLAG_ITEM)
+		testObj.setPosition(rel_pos([0.0, 0.5, 0.0]))
+		testObj.setRadius(1)
+		testObj.updateSelection(QUERYFLAG_ITEM)
+		assertEquals(1, testObj.getSelectionCount(), "One element sphere selection")
+		
+		testObj2.setPosition(rel_pos([0.0, 0.5, 0.0]))
+		testObj2.setRadius(3)
+		testObj2.updateSelection()
+		assertEquals(2, testObj2.getSelectionCount(), "Two element sphere selection")
+	end
+  
+end

Modified: modules/regressiontest/scripts/SoundTest.rb
===================================================================
--- modules/regressiontest/scripts/SoundTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/SoundTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -29,13 +29,11 @@
   @@height = 0.30
   @@radius = 5
   
-  def initialize(center)
-    super(center)
-    
+  def execute()
     min_base = [-@@radius, 0.05, -@@radius]
     max_base = [@@radius, @@height, @@radius]
     base = $AM.createBoxPrimitiveActor("SoundTestBase", min_base, max_base, "alpha_blue")
-    base.placeIntoScene(center)
+    base.placeIntoScene(getCenter())
     
     eh = $GOM.createGameObject("SoundFadeTest")
     eh.addAction(SoundFadeAction.new())

Modified: modules/regressiontest/scripts/TimeTest.rb
===================================================================
--- modules/regressiontest/scripts/TimeTest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/TimeTest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -20,16 +20,14 @@
 end
 
 class TimeTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         # Define a base box to place everything else on.
         height = 0.3
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
         base = $AM.createBoxPrimitiveActor("TimeTestBase", min_base, max_base,
                                           "alpha_orange")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         scheit = $GOM.createGameObject("Holzscheit");
         scheit.addAction(TimeCheckAction.new());

Modified: modules/regressiontest/scripts/doortest.rb
===================================================================
--- modules/regressiontest/scripts/doortest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/doortest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -27,15 +27,13 @@
 # Test case for Doors. Tests basic GameObject interaction,
 # ObjectStateChange event handling and physical collision updates.
 class DoorTest < TestCase
-    def initialize(center)
-        super(center)
-
+    def execute()
         # Define a base box to place everything else on.
         height = 0.3
         min_base = [-3.0, 0.05, -3.0]
         max_base = [3.0, height, 3.0]
         base = $AM.createBoxPrimitiveActor("DoorTestBase", min_base, max_base)
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         # The door with the door knob
         door1 = $GOM.createGameObject("door");

Modified: modules/regressiontest/scripts/effecttest.rb
===================================================================
--- modules/regressiontest/scripts/effecttest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/effecttest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -46,17 +46,17 @@
 
 # Test case for weffects. 
 class EffectTest < TestCase
-    def initialize(center)
-        super(center)
-	# Define a pointer to the hero
-	$h = $UI.getActiveCharacter()
+    def execute()
+	
+		# Define a pointer to the hero
+		$h = $UI.getActiveCharacter()
         # Define a base box to place everything else on.
         height = 0.1
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
         base = $AM.createBoxPrimitiveActor("EffectTestBase", min_base, max_base,
                                           "alpha_yellow")
-        base.placeIntoScene(center);
+        base.placeIntoScene(getCenter());
 
         bottich = $GOM.createGameObject("EffectTest");
         bottich.addAction(ParaluesAction.new());

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -16,6 +16,7 @@
 require 'LightzoneTest.rb'
 require 'MapLoadingTest.rb'
 require 'MergeableMeshTest.rb'
+require 'SelectorTest.rb'
 
 # Physik aktivieren
 $PM.setEnabled(true)
@@ -34,20 +35,20 @@
 
 $SCRIPT.log("begin tests.");
 
-         DoorTest.new([0, 0, -5])
-          NpcTest.new([-5, 0, 5])
-   NpcCapsuleTest.new([0, 0, 5])
-         TimeTest.new([-5, 0, -5])
-ErrorHandlingTest.new([-10, 0, 5])
-    InventoryTest.new([0, 0, 10])
-  JobSequenceTest.new([5, 0, -5])
-       EffectTest.new([5, 0, 5])
-        SoundTest.new([10, 0, 10])
-    LightzoneTest.new([-10, 0, -5])
-   MapLoadingTest.new([-5, 0, -10])
-MergeableMeshTest.new([10, 0, 0])
+         DoorTest.new([0, 0, -5]).run()
+          NpcTest.new([-5, 0, 5]).run()
+   NpcCapsuleTest.new([0, 0, 5]).run()
+         TimeTest.new([-5, 0, -5]).run()
+ErrorHandlingTest.new([-10, 0, 5]).run()
+    InventoryTest.new([0, 0, 10]).run()
+  JobSequenceTest.new([5, 0, -5]).run()
+       EffectTest.new([5, 0, 5]).run()
+        SoundTest.new([10, 0, 10]).run()
+    LightzoneTest.new([-10, 0, -5]).run()
+   MapLoadingTest.new([-5, 0, -10]).run()
+MergeableMeshTest.new([10, 0, 0]).run()
+     SelectorTest.new([5, 0, 0]).run()
 
-
 $SCRIPT.log("tests initialisiert.");
 
 $SCRIPT.log("map 'regressiontest' initialisiert.");

Modified: modules/regressiontest/scripts/testcase.rb
===================================================================
--- modules/regressiontest/scripts/testcase.rb	2007-06-25 17:50:11 UTC (rev 3541)
+++ modules/regressiontest/scripts/testcase.rb	2007-06-26 07:18:25 UTC (rev 3542)
@@ -1,3 +1,6 @@
+class AssertionException < RuntimeError
+end
+
 class TestCase
     def initialize(center)
         @center = center
@@ -2,5 +5,32 @@
     end
+	
     def rel_pos(position)
         vector_add(@center, position)
     end
+	
+	def assert(condition, text)
+	  if not condition then
+	    raise AssertionException, text
+	  end
+	end
+
+	def assertEquals(target, current, text)
+	  if target != current then
+	    raise AssertionException, "Value should be '" + target.to_s + "' but is '"+current.to_s+"'. "+text
+      end
+	end
+	
+	def run()
+	  execute()
+	  rescue AssertionException => ae
+	    p ae
+	end
+	
+	def getCenter()
+	  return @center
+	end
+	
+	# Override this method in test cases
+	def execute()
+	end
 end



From blakharaz at mail.berlios.de  Tue Jun 26 11:28:01 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 26 Jun 2007 11:28:01 +0200
Subject: [Dsa-hl-svn] r3543 - modules/common/gui/windows
	rl/trunk/engine/script/swig rl/trunk/engine/ui
	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
Message-ID: <200706260928.l5Q9S1kB001757@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-26 11:27:53 +0200 (Tue, 26 Jun 2007)
New Revision: 3543

Added:
   modules/common/gui/windows/propertieswindow.xml
   rl/trunk/engine/ui/include/PropertiesWindow.h
   rl/trunk/engine/ui/src/PropertiesWindow.cpp
Removed:
   modules/common/gui/windows/gameobjectpropswindow.xml
   rl/trunk/engine/ui/include/GameObjectPropsWindow.h
   rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
Modified:
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Changed GameObjectPropsWindow to a more general PropertiesWindow which can show all properties of a PropertyHolder

Deleted: modules/common/gui/windows/gameobjectpropswindow.xml
===================================================================
--- modules/common/gui/windows/gameobjectpropswindow.xml	2007-06-26 07:18:25 UTC (rev 3542)
+++ modules/common/gui/windows/gameobjectpropswindow.xml	2007-06-26 09:27:53 UTC (rev 3543)
@@ -1,81 +0,0 @@
-<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-  	<Window Type="RastullahLook/FrameWindow" Name="GameObjectPropsWindow">
-		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
-        <Property Name="UnifiedSize" Value="{{0,400},{0,500}}"/>
-		<Property Name="Text" Value="Spielobjekt Eigenschaften"/>
-		<Property Name="SizingEnabled" Value="false"/>
-
-		<!-- Headersheet for the name and description -->
-		
-		<Window Type="DefaultGUISheet" Name="GameObjectPropsWindow/HeaderSheet">
-      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,30}}"/>
-       	 	<Property Name="UnifiedSize" Value="{{0,350},{0,100}}"/>
-       	
-       	 	<!-- Name of the object -->
-       	 	 	
-			<Window Type="RastullahLook/StaticText" Name="GameObjectPropsWindow/HeaderSheet/Name">
-      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
-       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
-       	 		<Property Name="Text" Value="Name:"/>
-        		<Property Name="FrameEnabled" Value="False"/>
-       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
-    		</Window>
-    		
-    		<Window Type="RastullahLook/StaticText" Name="GameObjectPropsWindow/HeaderSheet/ObjectName">
-      	 		<Property Name="UnifiedPosition" Value="{{0,90},{0,0}}"/>
-       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,25}}"/>
-       	 		<Property Name="Text" Value="n/a"/>
-        		<Property Name="FrameEnabled" Value="True"/>
-       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
-    		</Window>
-    		
-    		<!-- Description of the object -->
-    	
-			<Window Type="RastullahLook/StaticText" Name="GameObjectPropsWindow/HeaderSheet/Description">
-      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,30}}"/>
-       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
-       	 		<Property Name="Text" Value="Description:"/>
-        		<Property Name="FrameEnabled" Value="False"/>
-       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
-    		</Window>
-    		
-    		<Window Type="RastullahLook/MultiLineEditbox" Name="GameObjectPropsWindow/HeaderSheet/ObjectDescription">
-      	 		<Property Name="ReadOnly" Value="true"/>
-            	<Property Name="Disabled" Value="true"/>
-    			<Property Name="UnifiedPosition" Value="{{0,90},{0,30}}"/>
-       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,60}}"/>
-        		<Property Name="FrameEnabled" Value="False"/>
-    		</Window>
-    		
-    	</Window>
-    	
-    	<!-- Properties sheet for the properties of the object -->
-    	
-		<Window Type="RastullahLook/TabControl" Name="GameObjectPropsWindow/PropertiesTabPane">
-      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,140}}"/>
-       	 	<Property Name="UnifiedSize" Value="{{0,340},{0,300}}"/>
-       	 	<Property Name="FrameEnabled" Value="False"/>
-       	 	
-       		<!-- Table with two columns for the key/value pair -->
-       	 	
-       		<Window Type="RastullahLook/MultiColumnList" Name="GameObjectPropsWindow/PropertiesTabControl/MainTable">
-      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
-       	 		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
-       	 		<Property Name="Text" Value="Eigenschaften"/>
-       	 		<Property Name="SortSettingEnabled" Value="False"/>
-       	 		<Property Name="Font" Value="Vera Serif-8"/>
-       	 		<Property Name="FrameEnabled" Value="False"/>
-    		</Window>   	
-       	 	 	
-       	</Window>
-		
-       	<!-- The Close button -->
-		<Window Type="RastullahLook/Button" Name="GameObjectPropsWindow/CloseButton">
-           	<Property Name="UnifiedPosition" Value="{{0.3,0},{0.9,0}}"/>
-           	<Property Name="UnifiedSize" Value="{{0,125},{0,28}}"/>
-			<Property Name="Font" Value="Vera Serif-10"/>
-			<Property Name="Text" Value="Close"/>
-		</Window>
-		
-	</Window>
-</GUILayout>
\ No newline at end of file

Copied: modules/common/gui/windows/propertieswindow.xml (from rev 3533, modules/common/gui/windows/gameobjectpropswindow.xml)
===================================================================
--- modules/common/gui/windows/gameobjectpropswindow.xml	2007-06-13 20:47:08 UTC (rev 3533)
+++ modules/common/gui/windows/propertieswindow.xml	2007-06-26 09:27:53 UTC (rev 3543)
@@ -0,0 +1,81 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+  	<Window Type="RastullahLook/FrameWindow" Name="PropertiesWindow">
+		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+        <Property Name="UnifiedSize" Value="{{0,400},{0,500}}"/>
+		<Property Name="Text" Value="Spielobjekt Eigenschaften"/>
+		<Property Name="SizingEnabled" Value="false"/>
+
+		<!-- Headersheet for the name and description -->
+		
+		<Window Type="DefaultGUISheet" Name="PropertiesWindow/HeaderSheet">
+      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,30}}"/>
+       	 	<Property Name="UnifiedSize" Value="{{0,350},{0,100}}"/>
+       	
+       	 	<!-- Name of the object -->
+       	 	 	
+			<Window Type="RastullahLook/StaticText" Name="PropertiesWindow/HeaderSheet/Name">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
+       	 		<Property Name="Text" Value="Name:"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<Window Type="RastullahLook/StaticText" Name="PropertiesWindow/HeaderSheet/ObjectName">
+      	 		<Property Name="UnifiedPosition" Value="{{0,90},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,25}}"/>
+       	 		<Property Name="Text" Value="n/a"/>
+        		<Property Name="FrameEnabled" Value="True"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<!-- Description of the object -->
+    	
+			<Window Type="RastullahLook/StaticText" Name="PropertiesWindow/HeaderSheet/Description">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,30}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
+       	 		<Property Name="Text" Value="Description:"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<Window Type="RastullahLook/MultiLineEditbox" Name="PropertiesWindow/HeaderSheet/ObjectDescription">
+      	 		<Property Name="ReadOnly" Value="true"/>
+            	<Property Name="Disabled" Value="true"/>
+    			<Property Name="UnifiedPosition" Value="{{0,90},{0,30}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,60}}"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+    		</Window>
+    		
+    	</Window>
+    	
+    	<!-- Properties sheet for the properties of the object -->
+    	
+		<Window Type="RastullahLook/TabControl" Name="PropertiesWindow/PropertiesTabPane">
+      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,140}}"/>
+       	 	<Property Name="UnifiedSize" Value="{{0,340},{0,300}}"/>
+       	 	<Property Name="FrameEnabled" Value="False"/>
+       	 	
+       		<!-- Table with two columns for the key/value pair -->
+       	 	
+       		<Window Type="RastullahLook/MultiColumnList" Name="PropertiesWindow/PropertiesTabControl/MainTable">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
+       	 		<Property Name="Text" Value="Eigenschaften"/>
+       	 		<Property Name="SortSettingEnabled" Value="False"/>
+       	 		<Property Name="Font" Value="Vera Serif-8"/>
+       	 		<Property Name="FrameEnabled" Value="False"/>
+    		</Window>   	
+       	 	 	
+       	</Window>
+		
+       	<!-- The Close button -->
+		<Window Type="RastullahLook/Button" Name="PropertiesWindow/CloseButton">
+           	<Property Name="UnifiedPosition" Value="{{0.3,0},{0.9,0}}"/>
+           	<Property Name="UnifiedSize" Value="{{0,125},{0,28}}"/>
+			<Property Name="Font" Value="Vera Serif-10"/>
+			<Property Name="Text" Value="Close"/>
+		</Window>
+		
+	</Window>
+</GUILayout>
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-06-26 09:27:53 UTC (rev 3543)
@@ -101,7 +101,7 @@
     void showCharacterSheet(rl::Person* chara);
     void showContainerContent(rl::Container* container);
     void showDescriptionWindow(rl::GameObject* obj);
-    void showGameObjectPropsWindow(rl::GameObject* obj);
+    void showPropertiesWindow(rl::GameObject* obj);
     void showSaveLoadWindow();
     void showExitConfirmation();
     void showJournalWindow();

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-06-26 09:27:53 UTC (rev 3543)
@@ -457,10 +457,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\include\GameObjectPropsWindow.h"
-					>
-				</File>
-				<File
 					RelativePath=".\include\InfoPopup.h"
 					>
 				</File>
@@ -513,6 +509,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\PropertiesWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\RenderSystemConfigComponent.h"
 					>
 				</File>
@@ -650,10 +650,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\src\GameObjectPropsWindow.cpp"
-					>
-				</File>
-				<File
 					RelativePath=".\src\InfoPopup.cpp"
 					>
 				</File>
@@ -706,6 +702,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\PropertiesWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\RenderSystemConfigComponent.cpp"
 					>
 				</File>

Deleted: rl/trunk/engine/ui/include/GameObjectPropsWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameObjectPropsWindow.h	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/ui/include/GameObjectPropsWindow.h	2007-06-26 09:27:53 UTC (rev 3543)
@@ -1,159 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/**
- * \file GameObjectPropsWindow.h
- *
- * Declaration of the GameObject window
- */
-
-#ifndef __GameObjectPropsWindow_H__
-#define __GameObjectPropsWindow_H__
-
-#include "UiPrerequisites.h"
-#include "AbstractWindow.h"
-
-namespace rl {
-
-	class GameObject;
-    class Property;
-
-    /**
-     * The GameObject window class
-     *
-     * This window displays all properties of a game object by looping
-     * through the property set of the given object.
-     */
-    class _RlUiExport GameObjectPropsWindow : public AbstractWindow
-	{
-	public:
-
-        /**
-         * Constructor of the GameObject window
-         */
-		GameObjectPropsWindow();
-		
-        /**
-         * Destructor of the GameObject window
-         */
-        virtual ~GameObjectPropsWindow();
-
-        /**
-         * Initializes the window with the specified game object and
-         * fills the window with the properties of the GameObject.
-         *
-         * @param object The GameObject to be displayed
-         */
-		virtual void initialize(GameObject* object);
-	
-	private:
-
-        /**
-         * Fills the header part of the window with the Name and Description
-         * property of the GameObject.
-         *
-         * @param object The GameObject to be displayed
-         */
-        virtual void fillHeader(GameObject* object);
- 
-        /**
-         * Adds an Int value to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyInt(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds the IntPair values to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyIntPair(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds the IntTriple values to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyIntTriple(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds a String value to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyString(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds a Bool value to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyBool(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds a Real value to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyReal(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds the Vector3 values to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyVector3(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds the Quaternion values to the property table.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyQuaternion(const Property& prop, 
-            CEGUI::MultiColumnList* table,
-            const Ogre::String& key = "");
-
-        /**
-         * Adds a new tab to the tabpane and lists
-         * the array values.
-         *
-         * @param key The property to add.
-         */
-        virtual void addPropertyArray(const Property& prop,
-            const Ogre::String& key = "");
-
-        
-        CEGUI::TabControl *mTabPane;        //!< TabControl for the property tabs
-        CEGUI::MultiColumnList *mMainTable; //!< Main table for the GameObject properties 
-	};
-}
-
-#endif

Copied: rl/trunk/engine/ui/include/PropertiesWindow.h (from rev 3534, rl/trunk/engine/ui/include/GameObjectPropsWindow.h)
===================================================================
--- rl/trunk/engine/ui/include/GameObjectPropsWindow.h	2007-06-13 21:33:56 UTC (rev 3534)
+++ rl/trunk/engine/ui/include/PropertiesWindow.h	2007-06-26 09:27:53 UTC (rev 3543)
@@ -0,0 +1,165 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/**
+ * \file PropertiesWindow.h
+ *
+ * Declaration of the Property window
+ */
+
+#ifndef __PropertiesWindow_H__
+#define __PropertiesWindow_H__
+
+#include "UiPrerequisites.h"
+#include "AbstractWindow.h"
+
+namespace rl {
+
+    class Property;
+	class PropertyHolder;
+
+    /**
+     * The Property window class
+     *
+     * This window displays all properties of a game object by looping
+     * through the property set of the given object.
+     */
+    class _RlUiExport PropertiesWindow : public AbstractWindow
+	{
+	public:
+
+        /**
+         * Constructor of the Property window
+         */
+		PropertiesWindow(PropertyHolder* ph);
+		
+        /**
+         * Destructor of the Property window
+         */
+        virtual ~PropertiesWindow();
+
+		/**
+		 * Refreshes the shown data
+		 */
+		void update();
+	
+	private:
+
+        /**
+         * Initializes the window with the specified game object and
+         * fills the window with the properties of the PropertyHolder.
+         *
+         * @param object The PropertyHolder to be displayed
+         */
+		void initialize(PropertyHolder* object);
+
+		/**
+         * Fills the header part of the window with the Name and Description
+         * property of the PropertyHolder.
+         *
+         * @param object The PropertyHolder to be displayed
+         */
+        void fillHeader(PropertyHolder* object);
+ 
+        /**
+         * Adds an Int value to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyInt(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds the IntPair values to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyIntPair(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds the IntTriple values to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyIntTriple(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds a String value to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyString(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds a Bool value to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyBool(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds a Real value to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyReal(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds the Vector3 values to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyVector3(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds the Quaternion values to the property table.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyQuaternion(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const Ogre::String& key = "");
+
+        /**
+         * Adds a new tab to the tabpane and lists
+         * the array values.
+         *
+         * @param key The property to add.
+         */
+        void addPropertyArray(const Property& prop,
+            const Ogre::String& key = "");
+
+        
+        CEGUI::TabControl *mTabPane;        //!< TabControl for the property tabs
+        CEGUI::MultiColumnList *mMainTable; //!< Main table for the PropertyHolder properties 
+		PropertyHolder* mObject;
+	};
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-06-26 09:27:53 UTC (rev 3543)
@@ -45,7 +45,7 @@
     class DialogWindow;
     class GameLoggerWindow;
     class GameObject;
-    class GameObjectPropsWindow;
+    class PropertiesWindow;
     class GameSettings;
     class InfoPopup;
     class InGameMenuWindow;
@@ -82,7 +82,7 @@
         void showCharacterSheet(Person* chara);
         void showContainerContent(Container* container);
         void showDescriptionWindow(GameObject* obj);
-        void showGameObjectPropsWindow(GameObject* obj);
+        void showPropertiesWindow(GameObject* obj);
         void showExitConfirmation();
         void showJournalWindow();
         void showLogfiles();

Deleted: rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-06-26 09:27:53 UTC (rev 3543)
@@ -1,576 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/**
- * \file GameObjectPropsWindow.cpp
- *
- * Implementation of the GameObject window
- */
-
-#include <boost/bind.hpp>
-#include <CEGUIPropertyHelper.h>
-#include <CEGUIWindowManager.h>
-#include <elements/CEGUIListboxTextItem.h>
-
-#include "GameObjectPropsWindow.h"
-#include "GameObject.h"
-
-using namespace CEGUI;
-
-namespace rl {
-
-    //------------------------------------------------------- Constructor
-
-	GameObjectPropsWindow::GameObjectPropsWindow() :
-        AbstractWindow("gameobjectpropswindow.xml", WIT_MOUSE_INPUT)
-	{
-        // Get access to the tab control
-        mTabPane = getTabControl("GameObjectPropsWindow/PropertiesTabPane");
-        RlAssert(mTabPane != NULL, "GameObjectPropsWindow/PropertiesTabPane is null");
-
-        // Get a access to the main Property table
-        mMainTable = getMultiColumnList("GameObjectPropsWindow/PropertiesTabControl/MainTable");
-        RlAssert(mMainTable != NULL, "GameObjectPropsWindow/PropertiesTabPane is null");
-
-        mMainTable->addColumn( (utf8*)"Key", 0, cegui_reldim(0.3));
-        mMainTable->addColumn( (utf8*)"Type", 1, cegui_reldim(0.3));
-        mMainTable->addColumn( (utf8*)"Value", 2, cegui_reldim(0.4));
-        
-        centerWindow();
-
-        bindDestroyWindowToXButton();
-        bindDestroyWindowToClick(getWindow("GameObjectPropsWindow/CloseButton"));
-	    
-	}
-
-    //------------------------------------------------------- Destructor
-
-	GameObjectPropsWindow::~GameObjectPropsWindow() 
-	{        
-	}
-
-    //------------------------------------------------------- initialize
-
-	void GameObjectPropsWindow::initialize( GameObject* object )
-	{
-        // Fill header text fields with name and description
-        fillHeader(object);    
-
-        // Get the property set of the object
-        PropertySet* props = object->getAllProperties();
-
-        int row = 0;
-        //  Iterate through all properties and add a row for
-        //  every Entry
-        for( PropertySetMap::const_iterator propIter = props->begin();
-            propIter != props->end(); propIter++ )
-        {
-            Ogre::String key = propIter->first;
-            
-            if( key == "description" || key == "name" )
-                continue;
-
-            // Check for Int
-            if( propIter->second.isInt() )
-            {
-                addPropertyInt(propIter->second, mMainTable, key );
-            }
-            // Check for IntPair
-            else if( propIter->second.isIntPair() )
-            {
-                addPropertyIntPair(propIter->second, mMainTable, key);
-                int rowCount = mMainTable->getRowCount();
-                mMainTable->addRow(rowCount);
-                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for IntTriple
-            else if( propIter->second.isIntTriple() )
-            {
-                addPropertyIntTriple(propIter->second, mMainTable, key);
-                int rowCount = mMainTable->getRowCount();
-                mMainTable->addRow(rowCount);
-                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for String
-            else if( propIter->second.isString() )
-            {
-                addPropertyString(propIter->second, mMainTable, key);
-            }
-            // Check for Bool
-            else if( propIter->second.isBool() )
-            {
-                addPropertyBool(propIter->second, mMainTable, key);
-            }
-            // Check for Real
-            else if( propIter->second.isReal() )
-            {
-                addPropertyReal(propIter->second, mMainTable, key);
-            }
-            // Check for Vector3
-            else if( propIter->second.isVector3() )
-            {
-                addPropertyVector3(propIter->second, mMainTable, key);
-                int rowCount = mMainTable->getRowCount();
-                mMainTable->addRow(rowCount);
-                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for Quaternion
-            else if( propIter->second.isQuaternion() )
-            {
-                addPropertyQuaternion(propIter->second, mMainTable, key);
-                int rowCount = mMainTable->getRowCount();
-                mMainTable->addRow(rowCount);
-                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for Array
-            else if( propIter->second.isArray() )
-            {
-                addPropertyArray(propIter->second, key);
-            }
-        }
-
-        mMainTable->autoSizeColumnHeader(0);
-        mMainTable->autoSizeColumnHeader(1);
-        mMainTable->autoSizeColumnHeader(2);
-	}
-
-    //------------------------------------------------------- fillHeader
-
-    void GameObjectPropsWindow::fillHeader(GameObject* object)
-    {
-        getWindow("GameObjectPropsWindow/HeaderSheet/ObjectName")->setText(object->getName());
-        getWindow("GameObjectPropsWindow/HeaderSheet/ObjectDescription")->setText(object->getDescription());
-    }
-
-    //------------------------------------------------------- addPropertyInt
-
-    void GameObjectPropsWindow::addPropertyInt(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Int  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("Int  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
-                1, 
-                rowCount);
-        }
-    }
-
-    //------------------------------------------------------- addPropertyIntPair
-
-    void GameObjectPropsWindow::addPropertyIntPair(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        IntPair intPair = prop.toIntPair();
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            // Add row for the first IntPair value
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
-            table->setItem(new ListboxTextItem( "( " + 
-                PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second) + " )"), 
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("( " + 
-                PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second) + " )"), 
-                1, 
-                rowCount);
-        }
-    }
-
-    //------------------------------------------------------- addPropertyIntTriple
-
-    void GameObjectPropsWindow::addPropertyIntTriple(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        Tripel<int> intTriple = prop.toIntTriple();
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            // Add row for the first IntTriple value
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("IntTriple  "), 1, rowCount);
-            table->setItem(new ListboxTextItem("( " +
-                PropertyHelper::intToString(intTriple.first) + ", " +
-                PropertyHelper::intToString(intTriple.second) + ", " +
-                PropertyHelper::intToString(intTriple.third) + " )"),
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("IntTriple  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("( " +
-                PropertyHelper::intToString(intTriple.first) + ", " +
-                PropertyHelper::intToString(intTriple.second) + ", " +
-                PropertyHelper::intToString(intTriple.third) + " )"), 
-                1, 
-                rowCount);
-        } 
-    }
-
-    //------------------------------------------------------- addPropertyString
-
-    void GameObjectPropsWindow::addPropertyString(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("String    "), 1, rowCount);
-            table->setItem(new ListboxTextItem(prop.toString()), 
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("String    "), 0, rowCount);
-            table->setItem(new ListboxTextItem(prop.toString()), 
-                1, 
-                rowCount);
-        }
-    }
-
-    //------------------------------------------------------- addPropertyBool
-
-    void GameObjectPropsWindow::addPropertyBool(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Bool  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("Bool  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
-                1, 
-                rowCount);
-        }
-    }
-
-    //------------------------------------------------------- addPropertyReal
-
-    void GameObjectPropsWindow::addPropertyReal(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-       // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        char buf [50];
-        sprintf(buf, "%1.2f", prop.toReal());
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Real  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
-                2, 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
-                1, 
-                rowCount);
-        }
-    }
-
-    //------------------------------------------------------- addPropertyVector3
-
-    void GameObjectPropsWindow::addPropertyVector3(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        Ogre::Vector3 vec = prop.toVector3();
-
-        char buf1 [50];
-        sprintf(buf1, "%1.2f", vec.x);
-        char buf2 [50];
-        sprintf(buf2, "%1.2f", vec.y);
-        char buf3 [50];
-        sprintf(buf3, "%1.2f", vec.z);
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            // Add row for the first IntTriple value
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Vector3  "), 1, rowCount);
-            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
-                CEGUI::String(buf2) + ", " +
-                CEGUI::String(buf3) + " )"), 
-                2 , 
-                rowCount);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
-                CEGUI::String(buf2) + ", " +
-                CEGUI::String(buf3) + " )"), 
-                1 , 
-                rowCount);
-        } 
-    }
-
-    //------------------------------------------------------- addPropertyQuaternion
-
-    void GameObjectPropsWindow::addPropertyQuaternion(const Property& prop, 
-        CEGUI::MultiColumnList* table, const Ogre::String& key)
-    {
-        // Check column count
-        // if count = 3 | MainTable
-        // if count = 2 | Array table
-        int colCount = table->getColumnCount();
-        int rowCount = table->getRowCount();
-
-        Ogre::Quaternion quat = prop.toQuaternion();
-        Ogre::Degree angle;
-        Ogre::Vector3 axis;
-
-        quat.ToAngleAxis( angle, axis );
-
-        char buf_angle [50];
-        sprintf(buf_angle, "%1.2f", angle.valueDegrees());
-        char buf_v1 [50];
-        sprintf(buf_v1, "%1.2f", axis.x);
-        char buf_v2 [50];
-        sprintf(buf_v2, "%1.2f", axis.y);
-        char buf_v3 [50];
-        sprintf(buf_v3, "%1.2f", axis.z);
-
-        // Table has the three columns Key, Type, Value
-        if ( colCount == 3 )
-        {
-            // Add row for the first IntTriple value
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Quaternion  "), 1, rowCount);
-            table->setItem(new ListboxTextItem("Axis:   ( " +
-                CEGUI::String(buf_v1) + ", " +
-                CEGUI::String(buf_v2) + ", " +
-                CEGUI::String(buf_v3) + " )"), 
-                2, 
-                rowCount);
-
-            // Add second for the second IntTriple value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Degree: " + 
-                CEGUI::String(buf_angle)), 
-                2, 
-                rowCount + 1);
-        }
-        // Table has the two columns Type, Value
-        else if ( colCount == 2 )
-        {
-            table->addRow(rowCount);
-            table->setItem(new ListboxTextItem("Quaternion  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Axis:   ( " +
-                CEGUI::String(buf_v1) + ", " +
-                CEGUI::String(buf_v2) + ", " +
-                CEGUI::String(buf_v3) + " )"), 
-                2, 
-                rowCount);
-
-            // Add second for the second IntTriple value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Degree " + 
-                CEGUI::String(buf_angle)), 
-                2, 
-                rowCount + 1);
-        } 
-
-    }
-
-    //------------------------------------------------------- addPropertyArray
-
-    void GameObjectPropsWindow::addPropertyArray(const Property& prop, const Ogre::String& key)
-    {
-        // Create the new MultiColumnList with two columns
-        // Type and Value and set tab text to key
-        int tabCount = mTabPane->getTabCount();
-        CEGUI::MultiColumnList* newTable = static_cast<CEGUI::MultiColumnList*>
-            (CEGUI::WindowManager::getSingleton().createWindow("RastullahLook/MultiColumnList", 
-            "GameObjectPropsWindow/PropertiesTabControl/" + key));
-
-        // Set table properties
-        newTable->setText(key);
-        newTable->setPosition(CEGUI::UVector2( 
-            CEGUI::UDim(0,0), 
-            CEGUI::UDim(0,0)));
-        newTable->setSize(CEGUI::UVector2(
-            CEGUI::UDim(1,0), 
-            CEGUI::UDim(1,0)));
-        newTable->setUserSortControlEnabled(false);
-        newTable->setFont("Vera Serif-8");
-
-        newTable->addColumn("Type", 0, cegui_reldim(0.3));
-        newTable->addColumn("Value", 1, cegui_reldim(0.7));
-
-        // Add the MultiColumnList to the tab pane
-        mTabPane->addTab(newTable);
-
-        // Get access to the vector
-        PropertyVector vProp = prop.toArray();
-        
-        // Iterate through the vector entries and add them
-        // to the table
-        for(PropertyVector::const_iterator it = vProp.begin(); it != vProp.end(); it++)
-        {
-            // Check for Int
-            if( it->isInt() )
-            {
-                addPropertyInt(*it, newTable);
-            }
-            // Check for IntPair
-            else if( it->isIntPair() )
-            {
-                addPropertyIntPair(*it, newTable);
-                int rowCount = newTable->getRowCount();
-                newTable->addRow(rowCount);
-                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for IntTriple
-            else if( it->isIntTriple() )
-            {
-                addPropertyIntTriple(*it, newTable);
-                int rowCount = newTable->getRowCount();
-                newTable->addRow(rowCount);
-                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for String
-            else if( it->isString() )
-            {
-                addPropertyString(*it, newTable);
-            }
-            // Check for Bool
-            else if( it->isBool() )
-            {
-                addPropertyBool(*it, newTable);
-            }
-            // Check for Real
-            else if( it->isReal() )
-            {
-                addPropertyReal(*it, newTable);
-            }
-            // Check for Vector3
-            else if( it->isVector3() )
-            {
-                addPropertyVector3(*it, newTable);
-                int rowCount = newTable->getRowCount();
-                newTable->addRow(rowCount);
-                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-            // Check for Quaternion
-            else if( it->isQuaternion() )
-            {
-                addPropertyQuaternion(*it, newTable);
-                int rowCount = newTable->getRowCount();
-                newTable->addRow(rowCount);
-                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
-            }
-        }
-        newTable->autoSizeColumnHeader(0);
-        newTable->autoSizeColumnHeader(1);
-    }
-
-} // namespace rl

Copied: rl/trunk/engine/ui/src/PropertiesWindow.cpp (from rev 3534, rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp)
===================================================================
--- rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-06-13 21:33:56 UTC (rev 3534)
+++ rl/trunk/engine/ui/src/PropertiesWindow.cpp	2007-06-26 09:27:53 UTC (rev 3543)
@@ -0,0 +1,600 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/**
+ * \file PropertiesWindow.cpp
+ *
+ * Implementation of the PropertyHolder window
+ */
+
+#include <boost/bind.hpp>
+#include <CEGUIPropertyHelper.h>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIListboxTextItem.h>
+
+#include "GameObject.h"
+#include "Properties.h"
+#include "PropertiesWindow.h"
+
+using namespace CEGUI;
+
+namespace rl {
+
+    //------------------------------------------------------- Constructor
+
+	PropertiesWindow::PropertiesWindow(PropertyHolder* object) :
+        AbstractWindow("propertieswindow.xml", WIT_MOUSE_INPUT),
+		mObject(object)
+	{
+        // Get access to the tab control
+        mTabPane = getTabControl("PropertiesWindow/PropertiesTabPane");
+        RlAssert(mTabPane != NULL, "PropertiesWindow/PropertiesTabPane is null");
+
+        // Get a access to the main Property table
+        mMainTable = getMultiColumnList("PropertiesWindow/PropertiesTabControl/MainTable");
+        RlAssert(mMainTable != NULL, "PropertiesWindow/PropertiesTabPane is null");
+
+        mMainTable->addColumn( (utf8*)"Key", 0, cegui_reldim(0.3));
+        mMainTable->addColumn( (utf8*)"Type", 1, cegui_reldim(0.3));
+        mMainTable->addColumn( (utf8*)"Value", 2, cegui_reldim(0.4));
+        
+        centerWindow();
+
+        bindDestroyWindowToXButton();
+        bindDestroyWindowToClick(getWindow("PropertiesWindow/CloseButton"));
+	    
+		initialize(mObject);
+	}
+
+    //------------------------------------------------------- Destructor
+
+	PropertiesWindow::~PropertiesWindow() 
+	{        
+	}
+
+    //------------------------------------------------------- initialize
+
+	void PropertiesWindow::initialize( PropertyHolder* object )
+	{
+        // Fill header text fields with name and description
+        fillHeader(object);    
+
+        // Get the property set of the object
+        PropertySet* props = object->getAllProperties();
+
+        int row = 0;
+        //  Iterate through all properties and add a row for
+        //  every Entry
+        for( PropertySetMap::const_iterator propIter = props->begin();
+            propIter != props->end(); propIter++ )
+        {
+            Ogre::String key = propIter->first;
+            
+            if( key == "description" || key == "name" )
+                continue;
+
+            // Check for Int
+            if( propIter->second.isInt() )
+            {
+                addPropertyInt(propIter->second, mMainTable, key );
+            }
+            // Check for IntPair
+            else if( propIter->second.isIntPair() )
+            {
+                addPropertyIntPair(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for IntTriple
+            else if( propIter->second.isIntTriple() )
+            {
+                addPropertyIntTriple(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for String
+            else if( propIter->second.isString() )
+            {
+                addPropertyString(propIter->second, mMainTable, key);
+            }
+            // Check for Bool
+            else if( propIter->second.isBool() )
+            {
+                addPropertyBool(propIter->second, mMainTable, key);
+            }
+            // Check for Real
+            else if( propIter->second.isReal() )
+            {
+                addPropertyReal(propIter->second, mMainTable, key);
+            }
+            // Check for Vector3
+            else if( propIter->second.isVector3() )
+            {
+                addPropertyVector3(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Quaternion
+            else if( propIter->second.isQuaternion() )
+            {
+                addPropertyQuaternion(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Array
+            else if( propIter->second.isArray() )
+            {
+                addPropertyArray(propIter->second, key);
+            }
+        }
+
+        mMainTable->autoSizeColumnHeader(0);
+        mMainTable->autoSizeColumnHeader(1);
+        mMainTable->autoSizeColumnHeader(2);
+
+		delete props;
+	}
+
+	void PropertiesWindow::update()
+	{
+		while (mTabPane->getTabCount() > 1)
+		{
+			mTabPane->removeTab(mTabPane->getTabContentsAtIndex(1)->getName());
+		}
+
+		while (mMainTable->getRowCount() > 0)
+		{
+			mMainTable->removeRow(0);
+		}
+
+		initialize(mObject);
+	}
+
+    //------------------------------------------------------- fillHeader
+
+    void PropertiesWindow::fillHeader(PropertyHolder* object)
+    {
+		GameObject* go = dynamic_cast<GameObject*>(object);
+		if (go)
+		{
+			getWindow("PropertiesWindow/HeaderSheet/ObjectName")->setText(go->getName());
+			getWindow("PropertiesWindow/HeaderSheet/ObjectDescription")->setText(go->getDescription());
+		}
+    }
+
+    //------------------------------------------------------- addPropertyInt
+
+    void PropertiesWindow::addPropertyInt(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Int  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("Int  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyIntPair
+
+    void PropertiesWindow::addPropertyIntPair(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        IntPair intPair = prop.toIntPair();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntPair value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
+            table->setItem(new ListboxTextItem( "( " + 
+                PropertyHelper::intToString(intPair.first) + ", " +
+                PropertyHelper::intToString(intPair.second) + " )"), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("( " + 
+                PropertyHelper::intToString(intPair.first) + ", " +
+                PropertyHelper::intToString(intPair.second) + " )"), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyIntTriple
+
+    void PropertiesWindow::addPropertyIntTriple(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Tripel<int> intTriple = prop.toIntTriple();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("IntTriple  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("( " +
+                PropertyHelper::intToString(intTriple.first) + ", " +
+                PropertyHelper::intToString(intTriple.second) + ", " +
+                PropertyHelper::intToString(intTriple.third) + " )"),
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("IntTriple  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("( " +
+                PropertyHelper::intToString(intTriple.first) + ", " +
+                PropertyHelper::intToString(intTriple.second) + ", " +
+                PropertyHelper::intToString(intTriple.third) + " )"), 
+                1, 
+                rowCount);
+        } 
+    }
+
+    //------------------------------------------------------- addPropertyString
+
+    void PropertiesWindow::addPropertyString(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("String    "), 1, rowCount);
+            table->setItem(new ListboxTextItem(prop.toString()), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("String    "), 0, rowCount);
+            table->setItem(new ListboxTextItem(prop.toString()), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyBool
+
+    void PropertiesWindow::addPropertyBool(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Bool  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("Bool  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyReal
+
+    void PropertiesWindow::addPropertyReal(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+       // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        char buf [50];
+        sprintf(buf, "%1.2f", prop.toReal());
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Real  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyVector3
+
+    void PropertiesWindow::addPropertyVector3(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Ogre::Vector3 vec = prop.toVector3();
+
+        char buf1 [50];
+        sprintf(buf1, "%1.2f", vec.x);
+        char buf2 [50];
+        sprintf(buf2, "%1.2f", vec.y);
+        char buf3 [50];
+        sprintf(buf3, "%1.2f", vec.z);
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Vector3  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
+                CEGUI::String(buf2) + ", " +
+                CEGUI::String(buf3) + " )"), 
+                2 , 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
+                CEGUI::String(buf2) + ", " +
+                CEGUI::String(buf3) + " )"), 
+                1 , 
+                rowCount);
+        } 
+    }
+
+    //------------------------------------------------------- addPropertyQuaternion
+
+    void PropertiesWindow::addPropertyQuaternion(const Property& prop, 
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Ogre::Quaternion quat = prop.toQuaternion();
+        Ogre::Degree angle;
+        Ogre::Vector3 axis;
+
+        quat.ToAngleAxis( angle, axis );
+
+        char buf_angle [50];
+        sprintf(buf_angle, "%1.2f", angle.valueDegrees());
+        char buf_v1 [50];
+        sprintf(buf_v1, "%1.2f", axis.x);
+        char buf_v2 [50];
+        sprintf(buf_v2, "%1.2f", axis.y);
+        char buf_v3 [50];
+        sprintf(buf_v3, "%1.2f", axis.z);
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Quaternion  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("Axis:   ( " +
+                CEGUI::String(buf_v1) + ", " +
+                CEGUI::String(buf_v2) + ", " +
+                CEGUI::String(buf_v3) + " )"), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Degree: " + 
+                CEGUI::String(buf_angle)), 
+                2, 
+                rowCount + 1);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("Quaternion  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Axis:   ( " +
+                CEGUI::String(buf_v1) + ", " +
+                CEGUI::String(buf_v2) + ", " +
+                CEGUI::String(buf_v3) + " )"), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Degree " + 
+                CEGUI::String(buf_angle)), 
+                2, 
+                rowCount + 1);
+        } 
+
+    }
+
+    //------------------------------------------------------- addPropertyArray
+
+    void PropertiesWindow::addPropertyArray(const Property& prop, const Ogre::String& key)
+    {
+        // Create the new MultiColumnList with two columns
+        // Type and Value and set tab text to key
+        int tabCount = mTabPane->getTabCount();
+        CEGUI::MultiColumnList* newTable = static_cast<CEGUI::MultiColumnList*>
+            (CEGUI::WindowManager::getSingleton().createWindow("RastullahLook/MultiColumnList", 
+            "PropertiesWindow/PropertiesTabControl/" + key));
+
+        // Set table properties
+        newTable->setText(key);
+        newTable->setPosition(CEGUI::UVector2( 
+            CEGUI::UDim(0,0), 
+            CEGUI::UDim(0,0)));
+        newTable->setSize(CEGUI::UVector2(
+            CEGUI::UDim(1,0), 
+            CEGUI::UDim(1,0)));
+        newTable->setUserSortControlEnabled(false);
+        newTable->setFont("Vera Serif-8");
+
+        newTable->addColumn("Type", 0, cegui_reldim(0.3));
+        newTable->addColumn("Value", 1, cegui_reldim(0.7));
+
+        // Add the MultiColumnList to the tab pane
+        mTabPane->addTab(newTable);
+
+        // Get access to the vector
+        PropertyVector vProp = prop.toArray();
+        
+        // Iterate through the vector entries and add them
+        // to the table
+        for(PropertyVector::const_iterator it = vProp.begin(); it != vProp.end(); it++)
+        {
+            // Check for Int
+            if( it->isInt() )
+            {
+                addPropertyInt(*it, newTable);
+            }
+            // Check for IntPair
+            else if( it->isIntPair() )
+            {
+                addPropertyIntPair(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for IntTriple
+            else if( it->isIntTriple() )
+            {
+                addPropertyIntTriple(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for String
+            else if( it->isString() )
+            {
+                addPropertyString(*it, newTable);
+            }
+            // Check for Bool
+            else if( it->isBool() )
+            {
+                addPropertyBool(*it, newTable);
+            }
+            // Check for Real
+            else if( it->isReal() )
+            {
+                addPropertyReal(*it, newTable);
+            }
+            // Check for Vector3
+            else if( it->isVector3() )
+            {
+                addPropertyVector3(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Quaternion
+            else if( it->isQuaternion() )
+            {
+                addPropertyQuaternion(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+        }
+        newTable->autoSizeColumnHeader(0);
+        newTable->autoSizeColumnHeader(1);
+    }
+
+} // namespace rl

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-06-26 07:18:25 UTC (rev 3542)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-06-26 09:27:53 UTC (rev 3543)
@@ -33,7 +33,7 @@
 #include "GameLoggerWindow.h"
 #include "GameObject.h"
 #include "GameObjectInfoWindow.h"
-#include "GameObjectPropsWindow.h"
+#include "PropertiesWindow.h"
 #include "SaveLoadWindow.h"
 #include "GameSettings.h"
 #include "InfoPopup.h"
@@ -166,10 +166,9 @@
         mDebugWindow->setVisible(!mDebugWindow->isVisible());
     }
 
-    void WindowFactory::showGameObjectPropsWindow(GameObject* obj)
+    void WindowFactory::showPropertiesWindow(GameObject* obj)
     {
-        GameObjectPropsWindow* wnd = new GameObjectPropsWindow();
-        wnd->initialize(obj);
+        PropertiesWindow* wnd = new PropertiesWindow(obj);
         wnd->setVisible(true);
     }
     



From blakharaz at mail.berlios.de  Tue Jun 26 11:30:49 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 26 Jun 2007 11:30:49 +0200
Subject: [Dsa-hl-svn] r3544 - in rl/trunk/engine: core/include core/src
	rules/include rules/src script/swig
Message-ID: <200706260930.l5Q9Un4C002012@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-26 11:30:43 +0200 (Tue, 26 Jun 2007)
New Revision: 3544

Modified:
   rl/trunk/engine/core/include/SceneQuery.h
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/rules/include/Selector.h
   rl/trunk/engine/rules/src/Selector.cpp
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Added Ogre ray query to Selectors

Modified: rl/trunk/engine/core/include/SceneQuery.h
===================================================================
--- rl/trunk/engine/core/include/SceneQuery.h	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/core/include/SceneQuery.h	2007-06-26 09:30:43 UTC (rev 3544)
@@ -22,6 +22,7 @@
 #include "Actor.h"
 
 #include <OgreNewt_RayCast.h>
+#include <OgreSceneQuery.h>
 
 namespace rl
 {
@@ -95,6 +96,18 @@
         bool mLevelOcclusion;
     };
 
+    /// This query uses Ogre's AABB based approach.
+    class _RlCoreExport OgreRaySceneQuery : public RaySceneQuery, public Ogre::RaySceneQueryListener
+    {
+    public:
+        OgreRaySceneQuery(unsigned long mask = 0xffffffff);
+
+        virtual const ActorVector& execute();
+
+		virtual bool queryResult(Ogre::MovableObject* obj, Ogre::Real distance);
+		virtual bool queryResult(Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance);
+    };
+
     /// This query queries for objects within a sphere.
     class _RlCoreExport SphereSceneQuery : public SceneQuery
     {

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2007-06-26 09:30:43 UTC (rev 3544)
@@ -17,6 +17,9 @@
 #include "SceneQuery.h"
 
 #include "PhysicsManager.h"
+#include "CoreSubsystem.h"
+#include "World.h"
+#include <OgreSceneManager.h>
 
 using namespace Ogre;
 
@@ -254,4 +257,41 @@
     {
         return mRadius;
     }
+
+    OgreRaySceneQuery::OgreRaySceneQuery(unsigned long mask)
+        : RaySceneQuery(mask)
+    {
+    }
+
+    const ActorVector& OgreRaySceneQuery::execute()
+    {
+        // Clear last results
+        mResult.clear();
+
+		Ray ray(getRayStart(), (getRayEnd() - getRayStart()).normalisedCopy());
+		
+		Ogre::RaySceneQuery* query = CoreSubsystem::getSingleton().getWorld()->getSceneManager()
+			->createRayQuery(ray, getQueryMask());
+
+		query->execute(this);
+
+        return mResult;
+    }
+
+	bool OgreRaySceneQuery::queryResult(
+		Ogre::MovableObject* obj, Ogre::Real distance)
+	{
+        Actor* actor = dynamic_cast<Actor*>(obj->getUserObject());
+        if (actor != NULL)
+		{
+			mResult.push_back(actor);
+		}
+		return true;
+	}
+	
+	bool OgreRaySceneQuery::queryResult(
+		Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance)
+	{
+		return true;
+	}
 }

Modified: rl/trunk/engine/rules/include/Selector.h
===================================================================
--- rl/trunk/engine/rules/include/Selector.h	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/rules/include/Selector.h	2007-06-26 09:30:43 UTC (rev 3544)
@@ -78,6 +78,7 @@
 
         GameObject* getFirstSelectedObject() const;
         const GameObjectVector& getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
 
     protected:
         GameObjectVector mSelection;
@@ -94,7 +95,8 @@
     class _RlRulesExport RaySelector : public Selector
     {
     public:
-        RaySelector(unsigned long mask = 0xffffffff);
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+		~RaySelector();
 
         void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
 
@@ -104,7 +106,7 @@
         virtual void updatePrimitive();
 
     protected:
-        RaySceneQuery mQuery;
+        RaySceneQuery* mQuery;
 
         virtual const ActorVector& doExecuteQuery();
         virtual void doCreatePrimitive();
@@ -116,6 +118,7 @@
     {
     public:
         HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+		HalfSphereSelector(unsigned long mask = 0xffffffff);
 
         virtual void updateSelection();
 

Modified: rl/trunk/engine/rules/src/Selector.cpp
===================================================================
--- rl/trunk/engine/rules/src/Selector.cpp	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/rules/src/Selector.cpp	2007-06-26 09:30:43 UTC (rev 3544)
@@ -16,7 +16,9 @@
 #include "Selector.h"
 #include "SelectionHelper.h"
 
+#include "CoreSubsystem.h"
 #include "PhysicsManager.h"
+#include "World.h"
 
 using namespace Ogre;
 
@@ -57,7 +59,8 @@
         return false;
     }
 
-    Selector::Selector(unsigned long mask) : mSelection(), mSelectionMask(mask), mFilter(NULL)
+    Selector::Selector(unsigned long mask) 
+		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
     {
     }
 
@@ -95,6 +98,11 @@
         return mSelection;
     }
 
+	unsigned int Selector::getSelectionCount() const
+	{
+		return mSelection.size();
+	}
+
     void Selector::updateSelection()
     {
         // Remove old selection
@@ -123,14 +131,22 @@
 
     //------------------------------------------------------------------------
 
-    RaySelector::RaySelector(unsigned long mask)
-        : Selector(mask), mQuery(mask)
+    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
+        : Selector(mask)
     {
+		if (useOgreQuery)
+		{
+			mQuery = new OgreRaySceneQuery(mask);
+		}
+		else
+		{
+			mQuery = new RaySceneQuery(mask);
+		}
     }
 
     void RaySelector::setRay(const Ogre::Vector3& start, const Ogre::Vector3& end)
     {
-        mQuery.setRay(start, end);
+        mQuery->setRay(start, end);
     }
 
     // Overrides from DebugVisualisable
@@ -143,12 +159,12 @@
     {
         LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
         lineSet->clear();
-        lineSet->addLine(mQuery.getRayStart(), mQuery.getRayEnd(), ColourValue::Red);
+        lineSet->addLine(mQuery->getRayStart(), mQuery->getRayEnd(), ColourValue::Red);
     }
 
     const ActorVector& RaySelector::doExecuteQuery()
     {
-        return mQuery.execute();
+        return mQuery->execute();
     }
 
     void RaySelector::doCreatePrimitive()
@@ -156,6 +172,11 @@
         mPrimitive = new LineSetPrimitive();
     }
 
+	RaySelector::~RaySelector()
+	{
+		delete mQuery;
+	}
+
     //////////////////////////////////////////////////////////////////////////
 
     HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
@@ -163,10 +184,20 @@
         : Selector(mask),
           mQuery(smgr, mask),
           mCheckVisibility(false),
-          mLoSReferenceGo(NULL)
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
     {
     }
 
+    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()->getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
     void HalfSphereSelector::updateSelection()
     {
         // Remove old selection

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-06-26 09:30:43 UTC (rev 3544)
@@ -42,6 +42,7 @@
 #include "QuestEvent.h"
 #include "QuestListener.h"
 #include "RulesSubsystem.h"
+#include "Selector.h"
 #include "SonderfertigkeitenStateSet.h"
 #include "StateSet.h"
 #include "Talent.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-06-26 09:27:53 UTC (rev 3543)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-06-26 09:30:43 UTC (rev 3544)
@@ -14,11 +14,13 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+// %template(GameObjectVector) std::vector< rl::GameObject* >;         
+
 namespace rl {
 
     // Before first use of GameObject or subclasses!
     %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-        
+
                     
    template<typename T>
    class Tripel {
@@ -579,9 +581,9 @@
         virtual Status getStatus();
         virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
 
-        virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
-        virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
-        virtual rl::PropertySet* getAllProperties() const = 0;
+        virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
+        virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
+        virtual rl::PropertySet* getAllProperties() const = 0;
     };
 
     class EffectFactory
@@ -786,9 +788,68 @@
                           unsigned int timesToPlay = 0, 
                           const Ogre::String &collisionName = "");
     };
+
+	// Before first use of Selector or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
+
+	class Selector : public DebugVisualisable
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        GameObject* getFirstSelectedObject() const;
+		const std::vector<GameObject*>& getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+		virtual void updatePrimitive() = 0;
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
+		virtual void updatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3& pos);
+        void setOrientation(const Ogre::Quaternion& ori);
+		virtual void updatePrimitive();
+	};
+
 } // Namespace
 
 %{
+static swig_type_info *Selector_dynamic_cast(void **ptr)
+{
+	rl::Selector **ppSelector = reinterpret_cast<rl::Selector**>(ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(*ppSelector);
+	if (pHalfSphereSel)
+	{
+		*ptr = pHalfSphereSel;
+		return SWIGTYPE_p_rl__HalfSphereSelector;
+	}
+	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(*ppSelector);
+	if (pRaySel)
+	{
+		*ptr = pRaySel;
+		return SWIGTYPE_p_rl__RaySelector;
+	}
+}
+	
 static swig_type_info *GameObject_dynamic_cast(void **ptr)
 {
     rl::GameObject **ppGameObject = reinterpret_cast<rl::GameObject**>(ptr);



From pnyx at mail.berlios.de  Tue Jun 26 12:05:54 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 26 Jun 2007 12:05:54 +0200
Subject: [Dsa-hl-svn] r3545 - modules/common/models
Message-ID: <200706261005.l5QA5s0C004559@sheep.berlios.de>

Author: pnyx
Date: 2007-06-26 12:05:48 +0200 (Tue, 26 Jun 2007)
New Revision: 3545

Modified:
   modules/common/models/men_human_female.skeleton
Log:
Slot bone positions fixed in run and idle animations

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)



From timm at mail.berlios.de  Tue Jun 26 14:01:13 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 26 Jun 2007 14:01:13 +0200
Subject: [Dsa-hl-svn] r3546 - in modules/regressiontest: dsa scripts/maps
Message-ID: <200706261201.l5QC1DYK026583@sheep.berlios.de>

Author: timm
Date: 2007-06-26 14:01:09 +0200 (Tue, 26 Jun 2007)
New Revision: 3546

Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
added a test for the CreatureWalkPathJob into regressiontest

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-26 10:05:48 UTC (rev 3545)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-26 12:01:09 UTC (rev 3546)
@@ -42,6 +42,20 @@
             <property type="STRING" data="DefaultIdleBehaviour"/>
             <property type="STRING" data="DialogBehaviour"/>
         </property>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
+<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
+		</property>
     </gameobjectclass>
 
     <gameobjectclass classid="TestPersonCapsule" baseclass="NPC">

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-26 10:05:48 UTC (rev 3545)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-26 12:01:09 UTC (rev 3546)
@@ -16,8 +16,10 @@
 require 'LightzoneTest.rb'
 require 'MapLoadingTest.rb'
 require 'MergeableMeshTest.rb'
+require 'WalkJobTest.rb'
 require 'SelectorTest.rb'
 
+
 # Physik aktivieren
 $PM.setEnabled(true)
 
@@ -48,6 +50,7 @@
    MapLoadingTest.new([-5, 0, -10]).run()
 MergeableMeshTest.new([10, 0, 0]).run()
      SelectorTest.new([5, 0, 0]).run()
+	  WalkJobTest.new().run()
 
 $SCRIPT.log("tests initialisiert.");
 



From timm at mail.berlios.de  Tue Jun 26 14:02:19 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 26 Jun 2007 14:02:19 +0200
Subject: [Dsa-hl-svn] r3547 - modules/regressiontest/scripts/maps
Message-ID: <200706261202.l5QC2Jrs026656@sheep.berlios.de>

Author: timm
Date: 2007-06-26 14:02:17 +0200 (Tue, 26 Jun 2007)
New Revision: 3547

Modified:
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
fix

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-26 12:01:09 UTC (rev 3546)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-06-26 12:02:17 UTC (rev 3547)
@@ -50,7 +50,7 @@
    MapLoadingTest.new([-5, 0, -10]).run()
 MergeableMeshTest.new([10, 0, 0]).run()
      SelectorTest.new([5, 0, 0]).run()
-	  WalkJobTest.new().run()
+	  WalkJobTest.new([0.0,0.0,-3.0]).run()
 
 $SCRIPT.log("tests initialisiert.");
 



From timm at mail.berlios.de  Tue Jun 26 14:04:21 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 26 Jun 2007 14:04:21 +0200
Subject: [Dsa-hl-svn] r3548 - modules/regressiontest/scripts
Message-ID: <200706261204.l5QC4Lnk026775@sheep.berlios.de>

Author: timm
Date: 2007-06-26 14:04:16 +0200 (Tue, 26 Jun 2007)
New Revision: 3548

Added:
   modules/regressiontest/scripts/WalkJobTest.rb
Log:
forgot to add WalkJobTest.rb to svn

Added: modules/regressiontest/scripts/WalkJobTest.rb
===================================================================
--- modules/regressiontest/scripts/WalkJobTest.rb	2007-06-26 12:02:17 UTC (rev 3547)
+++ modules/regressiontest/scripts/WalkJobTest.rb	2007-06-26 12:04:16 UTC (rev 3548)
@@ -0,0 +1,17 @@
+require 'testcase.rb'
+
+class WalkJobTest < TestCase
+  def execute()
+    walkingCreature = $GOM.createGameObject("TestPerson")
+	walkingCreature.placeIntoScene
+	walkingCreature.setPosition(getCenter())
+	walkingCreature.modifyAu(1000)
+
+    movingCreature = MovingCreature.new(walkingCreature)
+
+    job = CreatureWalkPathJob.new("WalkJobTest", movingCreature, Landmark.new("point", [5.0, 0.0, -10.0]))
+    job.addLandmark("1",[5.0,0.0,-20.0])
+    job.addLandmark("2",[5.0,0.0,-15.0])
+	$JS.addJob(job);
+  end
+end
\ No newline at end of file



From blakharaz at mail.berlios.de  Tue Jun 26 15:47:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 26 Jun 2007 15:47:18 +0200
Subject: [Dsa-hl-svn] r3549 - modules/regressiontest/dsa
Message-ID: <200706261347.l5QDlISg004283@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-26 15:47:17 +0200 (Tue, 26 Jun 2007)
New Revision: 3549

Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
Log:
Oops, forgot this change

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-26 12:04:16 UTC (rev 3548)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-06-26 13:47:17 UTC (rev 3549)
@@ -85,6 +85,7 @@
         <property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
         <property name="mass" type="REAL" data="3.0"/>
         <property name="size" type="INTPAIR" data="2,4"/>
+		<property name="geometrytype" type="STRING" data="box"/>
     </gameobjectclass>
 
     <gameobjectclass classid="leather backpack" baseclass="Container">
@@ -131,4 +132,13 @@
         <property name="geometrytype" type="STRING" data="box"/>
     </gameobjectclass>
 
+	<!-- SelectorTest -->
+    <gameobjectclass classid="SelectorTest" baseclass="Item">
+        <property name="name" type="STRING" data="Bottich der Auswahl"/>
+        <property name="description" type="STRING" data="Der Essigbottich des Auswahltests, harmlos :)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+
 </GameObjectDefinitions>



From blakharaz at mail.berlios.de  Tue Jun 26 16:40:52 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 26 Jun 2007 16:40:52 +0200
Subject: [Dsa-hl-svn] r3550 - in rl/trunk/engine/core: include src
Message-ID: <200706261440.l5QEeqNh009587@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-26 16:40:46 +0200 (Tue, 26 Jun 2007)
New Revision: 3550

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
* destroy physics proxy when removing objects from scene
* avoid null pointer when setting position on objects not in scene

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-06-26 13:47:17 UTC (rev 3549)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-06-26 14:40:46 UTC (rev 3550)
@@ -127,6 +127,7 @@
 
 		void createPhysicsProxy(Ogre::SceneNode* node);
         void updatePhysicsProxy();
+		void destroyPhysicsProxy();
 
         /** Called to update the collision of the physical thing, in order to adapt
          *  to a new animation state.

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-06-26 13:47:17 UTC (rev 3549)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-06-26 14:40:46 UTC (rev 3550)
@@ -108,6 +108,12 @@
 		 */
 		void createPhysicsProxy(PhysicalThing* pt, Ogre::SceneNode* node);
 
+		/**
+		 * Removes the physics proxy
+		 * @param pt the physics proxy wrapper; is not deleted
+		 */
+		void destroyPhysicsProxy(PhysicalThing* pt);
+
         //PhysicalThing* createConvexHullPhysicalThing(Ogre::Entity*, Ogre::Real mass = 0.0f,
         //    const Ogre::Vector3& inertiaCoefficients = Ogre::Vector3(1.0f, 1.0f, 1.0f));
 

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2007-06-26 13:47:17 UTC (rev 3549)
+++ rl/trunk/engine/core/src/Actor.cpp	2007-06-26 14:40:46 UTC (rev 3550)
@@ -403,8 +403,16 @@
             Throw(IllegalStateException,
             "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
 
-        if( mActorControlledObject && mSceneNode && mActorControlledObject->getMovableObject())
+		if (mPhysicalThing)
         {
+			PhysicsManager::getSingleton().destroyPhysicsProxy(
+				mPhysicalThing);
+		}
+
+        if( mActorControlledObject 
+			&& mSceneNode 
+			&& mActorControlledObject->getMovableObject())
+        {
             mSceneNode->detachObject(
                 mActorControlledObject->getMovableObject());
         }
@@ -688,13 +696,13 @@
         }
 
         // Falls ein noch nicht befestigtes MovableObject vorhanden, dieses attachen
-        if( mActorControlledObject != NULL && !mActorControlledObject->isAttached() )
+        if (mActorControlledObject != NULL && !mActorControlledObject->isAttached() )
         {
             mActorControlledObject->_attachSceneNode(mSceneNode);
         }
 
         // Physikverkn?pfung anpassen
-        if( mPhysicalThing != NULL && mActorControlledObject != NULL )
+        if (mPhysicalThing && mActorControlledObject)
         {
             PhysicsManager::getSingleton().createPhysicsProxy(mPhysicalThing, mSceneNode);
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-26 13:47:17 UTC (rev 3549)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-26 14:40:46 UTC (rev 3550)
@@ -52,7 +52,7 @@
 
     PhysicalThing::~PhysicalThing()
 	{
-		// missing removal of list of collision objects here ...
+		//@todo missing removal of list of collision objects here ...
 		delete mBody;
 		mBody = NULL;
     }
@@ -122,10 +122,13 @@
 
     void PhysicalThing::_update()
     {
-        mBody->setPositionOrientation(
-			mActor->_getSceneNode()->getWorldPosition(),
-			mActor->_getSceneNode()->getWorldOrientation());
-		mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
+		if (mBody && mActor)
+		{
+			mBody->setPositionOrientation(
+				mActor->_getSceneNode()->getWorldPosition(),
+				mActor->_getSceneNode()->getWorldOrientation());
+			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
+		}
     }
 
     void PhysicalThing::_setActor(Actor* actor)
@@ -373,9 +376,15 @@
         }
     }
 
+	void PhysicalThing::destroyPhysicsProxy()
+	{
+		delete mBody;
+		mBody = NULL;
+	}
+
     void PhysicalThing::createPhysicsProxy(SceneNode* node)
 	{
-		if (mBody == NULL) 
+		if (!mBody) 
 		{
             Vector3 inertia;
             OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-06-26 13:47:17 UTC (rev 3549)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-06-26 14:40:46 UTC (rev 3550)
@@ -273,6 +273,17 @@
 		mPhysicalThings.push_back(pt);
 	}
 
+	void PhysicsManager::destroyPhysicsProxy(PhysicalThing* pt)
+	{
+        vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
+            mPhysicalThings.end(), pt);
+		if (it != mPhysicalThings.end())
+		{
+			mPhysicalThings.erase(it);
+		}
+		pt->destroyPhysicsProxy();
+	}
+
     void PhysicsManager::clearLevelGeometry(  )
     {
 		mLevelBodiesQuadTree.removeAll();



From blakharaz at mail.berlios.de  Wed Jun 27 00:50:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 27 Jun 2007 00:50:18 +0200
Subject: [Dsa-hl-svn] r3551 - rl/trunk/engine/core/src
Message-ID: <200706262250.l5QMoIvd006629@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-27 00:50:09 +0200 (Wed, 27 Jun 2007)
New Revision: 3551

Modified:
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
Log:
Stop all animations before switching meshes


Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-06-26 14:40:46 UTC (rev 3550)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-06-26 22:50:09 UTC (rev 3551)
@@ -111,6 +111,9 @@
 
 	void MergeableMeshObject::switchTo(const MeshPtr& newMesh)
 	{
+		//@todo reactivate running animations?
+		stopAllAnimations();
+
 		Entity* oldEnt = getEntity();
 		Entity* newEnt = CoreSubsystem::getSingletonPtr()->getWorld()
 			->getSceneManager()->createEntity(oldEnt->getName()+"_", newMesh->getName());



From timm at mail.berlios.de  Wed Jun 27 12:24:44 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 27 Jun 2007 12:24:44 +0200
Subject: [Dsa-hl-svn] r3552 - rl/trunk/engine/ai/src
Message-ID: <200706271024.l5RAOij7024666@sheep.berlios.de>

Author: timm
Date: 2007-06-27 12:24:38 +0200 (Wed, 27 Jun 2007)
New Revision: 3552

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
correction of the rotation that the creature can't fail its target

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-26 22:50:09 UTC (rev 3551)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-27 10:24:38 UTC (rev 3552)
@@ -45,7 +45,6 @@
             else
             {
                 mCurrentLandmark = mNextLandmark;
-                //@todo
             }
         }
 
@@ -72,7 +71,10 @@
     void CreatureWalkPathJob::updateCreature(Ogre::Real time)
     {
         static bool updatedDirection(false);
+        static Ogre::Real timeSinceLastRotation = 0;
 
+        timeSinceLastRotation += time;
+
         Ogre::Vector3 direction = mNextLandmark->getPosition() - mMovingCreature->getCreature()->getActor()->getPosition();
         direction.y = 0;
         if( direction.squaredLength() < 0.04 )
@@ -89,10 +91,12 @@
         Ogre::Radian yaw = rotation.getYaw();
         Ogre::Vector3 usedRotation(Ogre::Vector3::ZERO);
         
-        if(!updatedDirection)
+        if(!updatedDirection || (direction.squaredLength() > 0.04 && timeSinceLastRotation > 1 &&
+            direction.normalisedCopy().dotProduct(creatureViewVector.normalisedCopy()) < 0.9))
         {
             usedRotation.y = yaw.valueRadians();
             updatedDirection = true;
+            timeSinceLastRotation = 0;
         }
 
         mMovingCreature->setMovement(MovingCreature::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);



From blakharaz at mail.berlios.de  Wed Jun 27 23:58:45 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 27 Jun 2007 23:58:45 +0200
Subject: [Dsa-hl-svn] r3553 - modules/common/models
Message-ID: <200706272158.l5RLwjtt007495@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-27 23:58:01 +0200 (Wed, 27 Jun 2007)
New Revision: 3553

Modified:
   modules/common/models/men_alrike_mesh.skeleton
Log:
Renamed gehen animation to Walk

Modified: modules/common/models/men_alrike_mesh.skeleton
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Thu Jun 28 00:01:26 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 28 Jun 2007 00:01:26 +0200
Subject: [Dsa-hl-svn] r3554 - in rl/trunk/engine/core: include src
Message-ID: <200706272201.l5RM1Qvi007744@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-28 00:01:20 +0200 (Thu, 28 Jun 2007)
New Revision: 3554

Modified:
   rl/trunk/engine/core/include/CameraObject.h
   rl/trunk/engine/core/src/CameraObject.cpp
Log:
Methods for getting CEGUI coordinates from world coordinates

Modified: rl/trunk/engine/core/include/CameraObject.h
===================================================================
--- rl/trunk/engine/core/include/CameraObject.h	2007-06-27 21:58:01 UTC (rev 3553)
+++ rl/trunk/engine/core/include/CameraObject.h	2007-06-27 22:01:20 UTC (rev 3554)
@@ -48,11 +48,33 @@
 		/** 
 		 * Transforms a point in world space into the (2D) screen space
 		 * @param worldCoords point in world space
-		 * @return the corresponding position on the screen. x,y are in [0,1].
+		 * @return the corresponding position on the screen in Ogre screen coordinates; x,y are in [-1,1].
 		 * The z component is the z value from the eye space, this allows checking
 		 * whether a point was behind the camera (z>0 in this case)
 		 */
 		Ogre::Vector3 getPointOnScreen(const Ogre::Vector3& worldCoords) const;
-    };
+	
+		/** 
+		 * Transforms a point in world space into the (2D) screen space
+		 * @param worldCoords point in world space
+		 * @return the corresponding position on the screen in CEGUI screen coordinates. x,y are in [0,1].
+		 * The z component is the z value from the eye space, this allows checking
+		 * whether a point was behind the camera (z>0 in this case)
+		 */
+		Ogre::Vector3 getPointOnCeGuiScreen(const Ogre::Vector3& worldCoords) const;
+
+		/**
+		 * Calculates the direction of the ray originating at the camera and 
+		 * directing at a point on the screen
+		 * @param x x coordinate on screen
+		 * @param y y coordinate on screen
+		 * @return the ray direction
+		 */
+		Ogre::Vector3 CameraObject::getDirectionFromScreenPosition(
+			const Ogre::Real& x, const Ogre::Real& y) const;
+
+		Ogre::Ray getCameraToViewportRay(
+			const Ogre::Real& x, const Ogre::Real& y) const;
+	};
 }
 #endif

Modified: rl/trunk/engine/core/src/CameraObject.cpp
===================================================================
--- rl/trunk/engine/core/src/CameraObject.cpp	2007-06-27 21:58:01 UTC (rev 3553)
+++ rl/trunk/engine/core/src/CameraObject.cpp	2007-06-27 22:01:20 UTC (rev 3554)
@@ -15,6 +15,9 @@
 */
 
 #include "CameraObject.h"
+
+#include <OgreRay.h>
+
 #include "Actor.h"
 #include "CoreSubsystem.h"
 #include "World.h"
@@ -68,4 +71,31 @@
 
         return screenSpacePos;
 	}
+
+	Vector3 CameraObject::getPointOnCeGuiScreen(const Ogre::Vector3& worldCoords) const
+	{
+		//see Ogre::Camera::getCameraToViewportRay(Real, Real)
+		//		Real nx = (2.0f * screenX) - 1.0f;
+		//		Real ny = 1.0f - (2.0f * screenY);
+		// -> screenX = (nx + 1.0f) / 2.0f
+		// -> screenY = (1.0f - ny) / 2.0f
+
+		Vector3 screenSpacePos = getPointOnScreen(worldCoords);
+		screenSpacePos.x = (screenSpacePos.x + 1.0f) / 2.0f;
+		screenSpacePos.y = (1.0f - screenSpacePos.y) / 2.0f;
+		return screenSpacePos;
+	}
+
+	Vector3 CameraObject::getDirectionFromScreenPosition(
+		const Real& x, const Real& y) const
+	{
+		Ray ray = getCamera()->getCameraToViewportRay(x, y);
+		return ray.getDirection();
+	}
+
+	Ray CameraObject::getCameraToViewportRay(
+		const Real& x, const Real& y) const
+	{
+		return getCamera()->getCameraToViewportRay(x, y);
+	}
 }



From blakharaz at mail.berlios.de  Thu Jun 28 00:04:27 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 28 Jun 2007 00:04:27 +0200
Subject: [Dsa-hl-svn] r3555 - in rl/trunk/engine/ui: include src
Message-ID: <200706272204.l5RM4RaA008023@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-28 00:04:20 +0200 (Thu, 28 Jun 2007)
New Revision: 3555

Modified:
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
Log:
Create DragContainer object when moving the mouse pointer over an object in the world while inventory is open

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-06-27 22:01:20 UTC (rev 3554)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-06-27 22:04:20 UTC (rev 3555)
@@ -18,36 +18,43 @@
 #define __InventoryWindow_H__
 
 #include "UiPrerequisites.h"
+
 #include "AbstractWindow.h"
-#include "Inventory.h"
-#include "GameTask.h"
 
 namespace rl {
 
     class Inventory;
+	class Item;
+	class ItemDragContainer;
 
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
+		static const Ogre::String ICON_UNKNOWN_ITEM;
+		static const Ogre::String SLOTNAME;
+
 		InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory);
 		~InventoryWindow();
 
-		static const Ogre::String ICON_UNKNOWN_ITEM;
-		static const Ogre::String SLOTNAME;
+    private:
+		typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
 
-    private:
-        Inventory* mInventory;
+		Inventory* mInventory;
         std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
 		CEGUI::Window* mWorldBackground;
+		DndContainerMap mDragContainers;
 
-        void createSlotWindows(Inventory* inventory);
+		void createSlotWindows(Inventory* inventory);
         void initInventoryWindow(Inventory* inventory);
 
-		CEGUI::Window* createItemWindow(const CeGuiString& containerName, Item* item);
+		ItemDragContainer* createItemDragContainer(Item* item, const CeGuiString& containerName = "");
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
 		bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
+		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
+		bool handleKeys(const CEGUI::EventArgs& evt, bool down);
+		bool destroyDragContainer(ItemDragContainer* cont);
     };
 }
 

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2007-06-27 22:01:20 UTC (rev 3554)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2007-06-27 22:04:20 UTC (rev 3555)
@@ -38,6 +38,8 @@
 		const CeGuiString& getItemParentSlot() const;
 		Inventory* getItemParentInventory() const;
 		Item* getItem() const;
+		CEGUI::Window* getContentWindow() const;
+		void setContentWindow(CEGUI::Window* window);
 
 	protected:
 		virtual bool testClassName_impl(const CEGUI::String& class_name) const;
@@ -47,6 +49,7 @@
 		Container* mParentContainer;
 		CeGuiString mParentSlot;
 		Inventory* mInventory;
+		CEGUI::Window* mContentWindow;
 	};
 
 } // namespace rl

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-06-27 22:01:20 UTC (rev 3554)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-06-27 22:04:20 UTC (rev 3555)
@@ -22,6 +22,7 @@
 #include <CEGUIWindowManager.h>
 
 #include "Container.h"
+#include "Inventory.h"
 #include "InventoryWindow.h"
 #include "ItemDragContainer.h"
 #include "WindowFactory.h"

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-27 22:01:20 UTC (rev 3554)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-27 22:04:20 UTC (rev 3555)
@@ -20,8 +20,14 @@
 #include <CEGUIImagesetManager.h>
 #include <CEGUIWindowManager.h>
 
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
 #include "Creature.h"
+#include "Inventory.h"
+#include "Item.h"
 #include "ItemDragContainer.h"
+#include "Selector.h"
 #include "WindowFactory.h"
 
 using namespace CEGUI;
@@ -110,19 +116,26 @@
             if (item != NULL)
             {
                 LOG_MESSAGE(Logger::UI, slotName + " - " + item->getDescription());
-				Window* itemWindow = createItemWindow(slotName, item);
+				Window* itemWindow = createItemDragContainer(item, slotName);
 				if (itemWindow != NULL)
 				{
 					slotWindow->addChildWindow(itemWindow);
 				}
             }
         }
+
 		mWorldBackground->setDragDropTarget(true);
 		mWorldBackground->subscribeEvent(Window::EventDragDropItemDropped, 
 			boost::bind(&InventoryWindow::handleItemDroppedOnWorld, this, _1));
+		mWorldBackground->subscribeEvent(Window::EventMouseMove, 
+			boost::bind(&InventoryWindow::handleMouseMovedInWorld, this, _1));
+		mWorldBackground->subscribeEvent(Window::EventKeyDown, 
+			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
+		mWorldBackground->subscribeEvent(Window::EventKeyUp, 
+			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
     }
 
-	Window* InventoryWindow::createItemWindow(const CeGuiString& slotName, Item* item)
+	ItemDragContainer* InventoryWindow::createItemDragContainer(Item* item, const CeGuiString& slotName)
 	{
         CeGuiString icon = item->getImageName();
 
@@ -131,37 +144,49 @@
 			icon = ICON_UNKNOWN_ITEM;
 		}
 
-        LOG_MESSAGE("IW", icon);
-        Window* itemWindow = 
-	        CEGUI::WindowManager::getSingletonPtr()->createWindow(
-		    "RastullahLook/StaticImage", 
-            mWindow->getName() + "/" + slotName + "/" + icon);
-        itemWindow->setProperty("Image", icon);
-        itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-        itemWindow->setSize(
-            UVector2(cegui_absdim(item->getSize().first*30),
-                     cegui_absdim(item->getSize().second*30)));
+		CeGuiString itemWindowName = mWindow->getName() + "/" + slotName + "/" + icon + item->getId();
+		CeGuiString dragContainerName = itemWindowName+"_DragContainer";
+		ItemDragContainer* itemhandler = NULL;
 
-		itemWindow->subscribeEvent(
-			Window::EventMouseClick,
-			boost::bind(&InventoryWindow::handleItemMouseClick, this, _1, item));
+		DndContainerMap::iterator it = mDragContainers.find(dragContainerName);
+		if (it != mDragContainers.end())
+		{
+			itemhandler = it->second;
+			return NULL; ///@todo just a test
+		}
+		else
+		{
+	        Window* itemWindow = CEGUI::WindowManager::getSingletonPtr()->createWindow(
+				"RastullahLook/StaticImage", 
+				itemWindowName);
+			itemWindow->setProperty("Image", icon);
 
-		itemWindow->subscribeEvent(
-			Window::EventMouseDoubleClick,
-			boost::bind(&InventoryWindow::handleItemDoubleClick, this, _1, item));
-		
-		ItemDragContainer* itemhandler = new ItemDragContainer(item, "DragContainer_"+itemWindow->getName());
-		itemhandler->setItemParent(mInventory, slotName);
+			itemWindow->subscribeEvent(
+				Window::EventMouseClick,
+				boost::bind(&InventoryWindow::handleItemMouseClick, this, _1, item));
 
-		itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-		itemhandler->setSize(
-			UVector2(cegui_absdim(item->getSize().first*30),
-					 cegui_absdim(item->getSize().second*30))); 
-		itemhandler->setTooltipText(item->getName());
-		itemhandler->addChildWindow(itemWindow);
+			itemWindow->subscribeEvent(
+				Window::EventMouseDoubleClick,
+				boost::bind(&InventoryWindow::handleItemDoubleClick, this, _1, item));
+			
+			itemhandler = new ItemDragContainer(item, dragContainerName);
+			if (slotName != "")
+			{
+				itemhandler->setItemParent(mInventory, slotName);
+			}
 
-		itemhandler->setTooltipText(item->getName());
-		
+			itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+			itemhandler->setSize(
+				UVector2(cegui_absdim(item->getSize().first*30),
+						 cegui_absdim(item->getSize().second*30))); 
+			itemhandler->setTooltipText(item->getName());
+			itemhandler->setContentWindow(itemWindow);
+
+			itemhandler->setTooltipText(item->getName());
+
+			mDragContainers[dragContainerName] = itemhandler;
+		}
+
 		return itemhandler;
 	}
 
@@ -188,6 +213,11 @@
 					dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
 					///@todo Swap with old content (if there is some)
 				}
+				else
+				{
+					dragcont->removeEvent(Window::EventMouseLeaves);
+					mDragContainers.erase(dragcont->getName());
+				}
 
 				mInventory->hold(item, targetSlot);
 				dragcont->getParent()->removeChildWindow(dragcont);
@@ -249,6 +279,60 @@
 		return false;
 	}
 
+	bool InventoryWindow::handleMouseMovedInWorld(const EventArgs& evt)
+	{
+		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
+
+		Actor* cameraActor = ActorManager::getSingleton().getActor("DefaultCamera");
+		CameraObject* camera = static_cast<CameraObject*>(cameraActor->getControlledObject());
+
+		CEGUI::Point mousePos = mevt.position;
+		mousePos.d_x /= getRoot()->getPixelSize().d_width;
+		mousePos.d_y /= getRoot()->getPixelSize().d_height;
+		static RaySelector sel(QUERYFLAG_ITEM, true);
+		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
+			mousePos.d_x, mousePos.d_y); 
+		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
+		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
+			mousePos.d_x, mousePos.d_y); 
+		sel.setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
+
+		sel.updateSelection();
+		Selector::GameObjectVector objs = sel.getAllSelectedObjects();
+		
+		///@todo select, ...
+		if (!objs.empty())
+		{
+			LOG_MESSAGE(Logger::UI, 
+				"Selected "+Ogre::StringConverter::toString(objs.size())+" items.");
+			for (Selector::GameObjectVector::const_iterator it = objs.begin();
+				it != objs.end(); ++it)
+			{
+				LOG_MESSAGE(Logger::UI, 
+					"Selected " + (*it)->getDescription());
+
+				ItemDragContainer* cont = 
+					createItemDragContainer(static_cast<Item*>(*it));
+				if (cont)
+				{
+					mWorldBackground->addChildWindow(cont);
+					cont->setVisible(true);
+					
+					Ogre::Vector3 pos = camera->getPointOnCeGuiScreen((*it)->getPosition());
+					cont->setPosition(UVector2(UDim(pos.x, 0), UDim(pos.y, 0)));
+
+					cont->subscribeEvent(
+						Window::EventMouseLeaves,
+						boost::bind(&InventoryWindow::destroyDragContainer, this, cont));
+				}
+			}
+		}
+
+		//camera->getPointOnScreen(
+
+		return true;
+	}
+
 	bool InventoryWindow::handleItemMouseClick(const EventArgs& evt, Item* item)
 	{
 		const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
@@ -277,4 +361,65 @@
 		}
 	}
 
+	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &evt, bool down)
+	{
+		const KeyEventArgs& kevt = static_cast<const KeyEventArgs&>(evt);
+		if (kevt.scancode == CEGUI::Key::Tab)
+		{
+			if (down)
+			{
+				Actor* cameraActor = ActorManager::getSingleton().getActor("DefaultCamera");
+				CameraObject* camera = static_cast<CameraObject*>(cameraActor->getControlledObject());
+
+				HalfSphereSelector sel(QUERYFLAG_ITEM);
+				sel.setPosition(cameraActor->getWorldPosition());
+				sel.setOrientation(cameraActor->getWorldOrientation());
+				sel.setRadius(2.0);
+				
+				sel.updateSelection();
+				Selector::GameObjectVector v = sel.getAllSelectedObjects();
+				for (Selector::GameObjectVector::iterator 
+					it = v.begin(); it != v.end(); ++it)
+				{
+					ItemDragContainer* cont = 
+						createItemDragContainer(static_cast<Item*>(*it));
+
+					if (cont)
+					{
+						mWorldBackground->addChildWindow(cont);
+						
+						Ogre::Vector3 pos = camera->getPointOnCeGuiScreen((*it)->getPosition());
+						UVector2 posCont = UVector2(UDim(pos.x, 0), UDim(pos.y, 0));
+						posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
+						cont->setPosition(posCont);
+
+						cont->subscribeEvent(
+							Window::EventMouseLeaves,
+							boost::bind(&InventoryWindow::destroyDragContainer, this, cont));
+					}
+				}
+			}
+			else
+			{
+				while (!mDragContainers.empty())
+				{
+					destroyDragContainer(mDragContainers.begin()->second);
+				}
+			}
+
+			return true;
+		}
+
+		return false;
+	}
+
+	bool InventoryWindow::destroyDragContainer(rl::ItemDragContainer* cont)
+	{
+		mWorldBackground->removeChildWindow(cont);
+		CEGUI::WindowManager::getSingleton().destroyWindow(cont->getContentWindow());
+		mDragContainers.erase(cont->getName());
+		delete cont;
+
+		return true;
+	}
 }

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-06-27 22:01:20 UTC (rev 3554)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-06-27 22:04:20 UTC (rev 3555)
@@ -64,4 +64,20 @@
 	{
 		return mItem;
 	}
+
+	CEGUI::Window* ItemDragContainer::getContentWindow() const
+	{
+		return mContentWindow;
+	}
+
+	void ItemDragContainer::setContentWindow(CEGUI::Window* window)
+	{
+		if (window)
+		{
+			window->setPosition(CEGUI::UVector2(cegui_reldim(0), cegui_reldim(0)));
+			window->setSize(CEGUI::UVector2(cegui_reldim(1), cegui_reldim(1)));
+			addChildWindow(window);
+		}
+		mContentWindow = window;
+	}
 }



From blakharaz at mail.berlios.de  Thu Jun 28 00:06:32 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 28 Jun 2007 00:06:32 +0200
Subject: [Dsa-hl-svn] r3556 - in rl/trunk/engine: ai/src core/include
	core/src rules/src ui/include ui/src
Message-ID: <200706272206.l5RM6Wmr008204@sheep.berlios.de>

Author: blakharaz
Date: 2007-06-28 00:06:24 +0200 (Thu, 28 Jun 2007)
New Revision: 3556

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/core/include/SceneQuery.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
Log:
Changed //@todo to ///@todo (Doxygen comments)



Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -45,6 +45,7 @@
             else
             {
                 mCurrentLandmark = mNextLandmark;
+                ///@todo
             }
         }
 

Modified: rl/trunk/engine/core/include/SceneQuery.h
===================================================================
--- rl/trunk/engine/core/include/SceneQuery.h	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/include/SceneQuery.h	2007-06-27 22:06:24 UTC (rev 3556)
@@ -104,8 +104,8 @@
 
         virtual const ActorVector& execute();
 
-		virtual bool queryResult(Ogre::MovableObject* obj, Ogre::Real distance);
-		virtual bool queryResult(Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance);
+		virtual bool queryResult(Ogre::MovableObject* obj, Ogre::Real distance);
+		virtual bool queryResult(Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance);
     };
 
     /// This query queries for objects within a sphere.

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/Actor.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -743,7 +743,7 @@
     {
         if (highlight != mHighlighted)
         {
-            //@todo: blue ring or something signifies the highlighted object
+            ///@todo: blue ring or something signifies the highlighted object
             //getControlledObject()->setHighlighted(highlight);
             mHighlighted = highlight;
         }

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -119,7 +119,7 @@
             addSearchPath(moduleDir + "/models/"+*it, resourceGroup);
         }
 
-        addSearchPath(moduleDir + "/sound", resourceGroup); //@todo ueber Verzeichnisnamen nachdenken
+        addSearchPath(moduleDir + "/sound", resourceGroup); ///@todo ueber Verzeichnisnamen nachdenken
         StringVector soundLoc = getSoundLocations();
         for (StringVector::iterator it = soundLoc.begin(); it != soundLoc.end(); ++it)
         {

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -92,11 +92,11 @@
         delete mJobScheduler;
         delete mAnimationManager;
         delete mActorManager;
-        delete mDebugVisualsManager;
         delete mPhysicsManager;
         delete mXmlResourceManager;
         delete mScriptWrapper;
-        delete ConfigurationManager::getSingletonPtr();
+        delete mDebugVisualsManager;
+		delete ConfigurationManager::getSingletonPtr();
         delete mSoundManager;
         delete mOgreRoot;
         delete mRubyInterpreter;

Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -111,7 +111,7 @@
 
 	void MergeableMeshObject::switchTo(const MeshPtr& newMesh)
 	{
-		//@todo reactivate running animations?
+		///@todo reactivate running animations?
 		stopAllAnimations();
 
 		Entity* oldEnt = getEntity();

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -52,7 +52,7 @@
 
     PhysicalThing::~PhysicalThing()
 	{
-		//@todo missing removal of list of collision objects here ...
+		///@todo missing removal of list of collision objects here ...
 		delete mBody;
 		mBody = NULL;
     }

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -278,20 +278,20 @@
         return mResult;
     }
 
-	bool OgreRaySceneQuery::queryResult(
-		Ogre::MovableObject* obj, Ogre::Real distance)
-	{
+	bool OgreRaySceneQuery::queryResult(
+		Ogre::MovableObject* obj, Ogre::Real distance)
+	{
         Actor* actor = dynamic_cast<Actor*>(obj->getUserObject());
         if (actor != NULL)
 		{
 			mResult.push_back(actor);
 		}
 		return true;
-	}
-	
-	bool OgreRaySceneQuery::queryResult(
-		Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance)
-	{
-		return true;
-	}
+	}
+	
+	bool OgreRaySceneQuery::queryResult(
+		Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance)
+	{
+		return true;
+	}
 }

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -142,7 +142,7 @@
 			{
 				if (activeSounds.find(*itSounds) == activeSounds.end())
 				{
-					//@todo switch sound off
+					///@todo switch sound off
 				}
 			}
 		}
@@ -152,7 +152,7 @@
 		{
 			if (activeSounds.find(*itSounds) == activeSounds.end())
 			{
-				//@todo switch sound off
+				///@todo switch sound off
 			}
 		}
 	}

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -48,7 +48,7 @@
 
     GameObjectManager::~GameObjectManager()
     {
-        ///@TODO: Delete all game objects, delete all class properties
+        ///@todo: Delete all game objects, delete all class properties
     }
 
     const Ogre::StringVector& GameObjectManager::getScriptPatterns() const

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -94,7 +94,7 @@
 		if (mActor != NULL)
 		{
 			mActor->detachFromParent();
-			//@todo is mState = GOS_IN_SCENE; after detaching?
+			///@todo is mState = GOS_IN_SCENE; after detaching?
 		}
 	}
 

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-06-27 22:06:24 UTC (rev 3556)
@@ -39,6 +39,9 @@
 
 	class WindowUpdateTask;
 
+	/**
+	 * This is the base class for all UI windows
+	 */
 	class _RlUiExport AbstractWindow
 	{
 	public:
@@ -52,6 +55,13 @@
 
 		virtual ~AbstractWindow();	
 
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
+		
+		/// gets the CEGUI root
+		static CEGUI::Window* getRoot();
+
+		/// gets the wrapped CEGUI window
 		CEGUI::Window* getWindow();
 
 		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
@@ -69,9 +79,6 @@
 		CEGUI::Slider* getSlider(const char* name);
 		CEGUI::TabControl* getTabControl(const char* name);
 
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-		static CEGUI::Window* getRoot();
-
 		int getWindowInputType();
 
         virtual bool isVisible();

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-06-27 22:04:20 UTC (rev 3555)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-06-27 22:06:24 UTC (rev 3556)
@@ -86,7 +86,7 @@
 
 void CharacterSheetWindow::update()
 {
-	///@TODO: Daten updaten
+	///@todo: Daten updaten
 	updateTalents();
 	/*if (mCharacter->isMagic())
 		updateMagic();*/



