From natoka at mail.berlios.de  Thu Mar  1 00:38:33 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Thu, 1 Mar 2007 00:38:33 +0100
Subject: [Dsa-hl-svn] r3101 - in rl/trunk/engine/core: include src
Message-ID: <200702282338.l1SNcXKJ022383@sheep.berlios.de>

Author: natoka
Date: 2007-03-01 00:38:25 +0100 (Thu, 01 Mar 2007)
New Revision: 3101

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
Log:
adding documentation to PhysicalThing
cleaning up the rest of deprecated offset/orientation code

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-02-28 21:50:18 UTC (rev 3100)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-02-28 23:38:25 UTC (rev 3101)
@@ -28,24 +28,69 @@
 	class Actor;
 	class MeshObject;
 
+	/** PhysicalThing contains the physical representation of an ActorControlledObject.
+	 * It utilizes a default collision primitiv derived from the default mesh, but it
+	 * can also handle keyframe animation states of the ActorControlledObject.
+	 */
     class _RlCoreExport PhysicalThing
     {
     public:
+		/** Constructor storing all passed values.
+		 * It simply initializes all internal variables to meaningful values
+		 * and stores the values passed by the parameters.
+		 * @param geomType PhysicsManager::GeometryType defining collision primitiv type
+		 *				   (box, sphere, etc.)
+		 * @param po PhysicalObject that utilizes this PhysicalThing object
+		 * @param mass Real containing the mass of the physical object in kg
+		 * 
+		 */
 		PhysicalThing(
 			PhysicsManager::GeometryType geomType,
 			PhysicalObject* po, 
 			Ogre::Real mass, 
 			bool hullModifier = false);
 
-        /// Klasse Polymorph machen, damit SWIG gl?cklich ist.
+        /** default virtual destructor
+		 * It is needed otherwise SWIG is not happy. It frees up the allocated 
+		 * OgreNewt::Body and unregisteres the object from PhysicsManager.
+		 */
         virtual ~PhysicalThing();
 
+		/** returns the position of the OgreNewt::Body object
+		 */
         Ogre::Vector3 getPosition() const;
+		/** sets the position of the OgreNewt::Body object
+		 * Since the physic engine alters position, using this function is bad.
+		 * Use addForce to manipulate the body instead.
+		 * @param pos Ogre::Vector3 containing new position in physic world space
+		 */
         void setPosition(const Ogre::Vector3& pos);
+		/** sets the position of the OgreNewt::Body object
+		 * Since the physic engine alters position, using this function is bad.
+		 * Use addForce to manipulate the body instead.
+		 * @param x Ogre::Real containing new x position in physic world space
+		 * @param y Ogre::Real containing new y position in physic world space
+		 * @param z Ogre::Real containing new z position in physic world space
+		 */
         void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
 
+		/** returns the orientation of the OgreNewt::Body object
+		 */
         Ogre::Quaternion getOrientation() const;
+		/** sets the position of the OgreNewt::Body object
+		 * Since the physic engine alters position, using this function is bad.
+		 * Use addForce to manipulate the body instead.
+		 * @param orientation Ogre::Quaternion containing new orientation in physic world space
+		 */
         void setOrientation(const Ogre::Quaternion& orienation);
+		/** sets the position of the OgreNewt::Body object
+		 * Since the physic engine alters position, using this function is bad.
+		 * Use addForce to manipulate the body instead.
+		 * @param w Ogre::Real containing new w orientation in physic world space
+		 * @param x Ogre::Real containing new x orientation in physic world space
+		 * @param y Ogre::Real containing new y orientation in physic world space
+		 * @param z Ogre::Real containing new z orientation in physic world space
+		 */
         void setOrientation(Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z);
 
         void setVelocity(const Ogre::Vector3& velocity);
@@ -70,6 +115,7 @@
 		void _attachToBone(MeshObject* object, const std::string& boneName);
         void _detachFromSceneNode(Ogre::SceneNode* node);
 
+		/** ForceCallback for mBody (OgreNewt::Body). */
         void onApplyForceAndTorque();
         void addForce(const Ogre::Vector3& force);
 
@@ -88,8 +134,11 @@
          */
         void updateCollisionHull();
 
-        /** Called to update the collision of the physical thing, in order to adapt
-         *  to a new animation state.
+        /** Called to update the collision primitiv to a new animation state.
+		 * Meshes can have different keyframe animations, which can vary in size and orientation.
+		 * To update the collision primitiv from one such keyframe to another, this function can
+		 * be used.
+		 * @param name String containing name of animation pose to update to.
          */
         void fitToPose(const Ogre::String& name);
 
@@ -101,25 +150,40 @@
 
     private:
         Actor* mActor;
+		//! The newton body object this physical thing works with
         OgreNewt::Body* mBody;
+		//! an upjoint to keep the body from falling over
         OgreNewt::BasicJoints::UpVector* mUpVectorJoint;
-        Ogre::Vector3 mOffset;
-        Ogre::Quaternion mOrientationBias;
+		//! the pending force to apply at the body
         Ogre::Vector3 mPendingForce;
+		/** whether we override gravity or not
+		 question: is this really necessary ?
+		 */
         bool mOverrideGravity;
+		/** gravity vector ?
+		 question: is this really necessary ?
+		 */
         Ogre::Vector3 mGravity;
+		//! a contact listener called on collision with other objects
         PhysicsContactListener* mContactListener;
 
+		//! typedefinition for easing variable declaration
         typedef std::map<Ogre::String, OgreNewt::CollisionPtr> CollisionMap;
+		//! ??
         CollisionMap mPoseCollisions;
 
+		//! the objects mass
 		Ogre::Real mMass;
+		//! the collision primitivs type (box, sphere, ellipsoid, etc.)
 		PhysicsManager::GeometryType mGeometryType;
+		//! the associated tangible object ?
 		PhysicalObject* mPhysicalObject;
 		bool mHullModifier;
 
-		//void setOffset(const Ogre::Vector3& offset);
-		//void setOrientationBias(const Ogre::Quaternion& orientation);
+		/** returns the geometrytype of the collision primitiv.
+		 * That is normally box, sphere, ellipsoid, capsule, convexhull or mesh.
+		 * question: is mesh also userdefined ?
+		 */
 		PhysicsManager::GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
 
@@ -130,16 +194,18 @@
 		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
 		 * calculated according to the size and type of collision primitiv.
 		 * @param aabb AxisAlignedBox that contains the extents of mesh whose coll. primitiv is to be created
-		 * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
 		 * @param inertiaCoefficients Vector3 returns the inertia coefficients for the created coll. primitiv
 		 * @param animName String specifies the name of the animation of the mesh whose coll. primitiv should be created,
 		 *        when "", then the basic mesh is used as a basis.
+		 * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
 		*/
 		OgreNewt::CollisionPtr createCollision(
-			const Ogre::AxisAlignedBox& aabb, Ogre::Vector3* offset = NULL, 
-			Ogre::Quaternion* orientation = NULL, Ogre::Vector3* inertiaCoefficients = NULL, 
-			const Ogre::String animName = "") const;
+			const Ogre::AxisAlignedBox& aabb,
+			Ogre::Vector3* inertiaCoefficients = NULL,
+			const Ogre::String animName = "",
+			Ogre::Vector3* offset = NULL, 
+			Ogre::Quaternion* orientation = NULL) const;
 	};
 }
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-02-28 21:50:18 UTC (rev 3100)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-02-28 23:38:25 UTC (rev 3101)
@@ -34,8 +34,6 @@
 		mActor(NULL),
         mBody(NULL),
         mUpVectorJoint(NULL),
-        mOffset(Vector3::ZERO),
-		mOrientationBias(Quaternion::IDENTITY),
         mPendingForce(Vector3::ZERO),
         mOverrideGravity(false),
         mGravity(Vector3::ZERO),
@@ -51,8 +49,10 @@
     PhysicalThing::~PhysicalThing()
 	{
         PhysicsManager::getSingleton().setPhysicsController( this, NULL );
+		// missing removal of list of collision objects here ...
 		delete mBody;
 		mBody = NULL;
+
     }
 
     Ogre::Vector3 PhysicalThing::getPosition() const
@@ -102,13 +102,6 @@
         mBody->setVelocity(vel);
     }
 
-/*	void PhysicalThing::setOffset(const Vector3& offset)
-	{
-		mOffset = offset;
-        //mBody->setOffset(offset);
-	}
-	*/
-
     Actor *PhysicalThing::getActor(void) const
     {
         return mActor;
@@ -128,8 +121,8 @@
     void PhysicalThing::_update()
     {
         mBody->setPositionOrientation(
-            mActor->_getSceneNode()->getWorldPosition(), // + mBody->getOffset(),
-            mOrientationBias.Inverse() * mActor->_getSceneNode()->getWorldOrientation());
+			mActor->_getSceneNode()->getWorldPosition(),
+			mActor->_getSceneNode()->getWorldOrientation());
 		mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
     }
 
@@ -142,7 +135,7 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody->attachToNode(node); //, mOffset, mOrientationBias);
+        mBody->attachToNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string& boneName )
@@ -281,7 +274,7 @@
 						Vector3 v = Vector3(vpos[0], vpos[1], vpos[2]);
 						//Positions in world space. So we need to transform them back.
 						vertices.push_back(transform * v);
-						offset++;
+						offset++;		// question: do we really need this here?
 					}
 
 					vbuffer->unlock();
@@ -323,8 +316,6 @@
 
     void PhysicalThing::fitToPose(const Ogre::String& name)
     {
-		Vector3 offset = Vector3::ZERO;
-		Quaternion orientationBias = Quaternion::IDENTITY;;
 		CollisionPtr coll;
         
         if (mPhysicalObject->isMeshObject())
@@ -337,7 +328,7 @@
             if (it == mPoseCollisions.end())
             {
                 // No, so create it and put it into the map
-                coll = createCollision(size, &offset, &orientationBias, NULL, name);
+                coll = createCollision(size, NULL, name);
                 mPoseCollisions.insert(make_pair(name, coll));
             }
             else
@@ -345,13 +336,11 @@
                 // collision primitiv is cached, retrieve it
                 coll = it->second;
             }
-            //setOffset(offset);
             mBody->setCollision(coll);
-            mOrientationBias = orientationBias;
 
             // Set body-position so, that node-position is invariant.
-            setPosition(mActor->_getSceneNode()->_getDerivedPosition() +
-                mActor->_getSceneNode()->_getDerivedOrientation() * offset);
+            setPosition(mActor->_getSceneNode()->_getDerivedPosition());
+			setOrientation(mActor->_getSceneNode()->_getDerivedOrientation());
         }
         else
         {
@@ -360,11 +349,10 @@
     }
 
 	OgreNewt::CollisionPtr PhysicalThing::createCollision(
-		const AxisAlignedBox& aabb, Vector3* offset, 
-		Quaternion* orientation, Vector3* inertiaCoefficients, const String animName) const
+		const AxisAlignedBox& aabb, Vector3* inertiaCoefficients,
+		const String animName, Vector3* offset, Quaternion* orientation ) const
     {
-		const Vector3 size = aabb.getMaximum() - aabb.getMinimum();
-
+		const Vector3 size( aabb.getSize() );
 		OgreNewt::World* physWorld = PhysicsManager::getSingleton()._getNewtonWorld();
 
         CollisionPtr rval;
@@ -542,11 +530,8 @@
 		{
             const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
                         
-			Quaternion orientationBias;
             Vector3 inertiaCoefficients;
-			Vector3 offset;
-			OgreNewt::CollisionPtr coll = createCollision(aabb, &offset,
-                &orientationBias, &inertiaCoefficients);
+			OgreNewt::CollisionPtr coll = createCollision(aabb, &inertiaCoefficients);
 
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
@@ -560,8 +545,6 @@
 			body->setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
 
             setBody(body);
-            //setOffset(offset);
-			mOrientationBias = orientationBias;
         }
 	}
 



From natoka at mail.berlios.de  Thu Mar  1 01:33:34 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Thu, 1 Mar 2007 01:33:34 +0100
Subject: [Dsa-hl-svn] r3102 - in modules/regressiontest: dsa scripts
	scripts/maps
Message-ID: <200703010033.l210XY2U021096@sheep.berlios.de>

Author: natoka
Date: 2007-03-01 01:33:27 +0100 (Thu, 01 Mar 2007)
New Revision: 3102

Added:
   modules/regressiontest/scripts/NpcCapsuleTest.rb
Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
adding a capsule person to the regression test

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-02-28 23:38:25 UTC (rev 3101)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-01 00:33:27 UTC (rev 3102)
@@ -33,6 +33,21 @@
     </gameobjectclass>
 
     <gameobjectclass>
+        <property name="classid" type="STRING" data="TestPersonCapsule"/>
+        <property name="baseclass" type="STRING" data="NPC"/>
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialogfile" type="STRING" data="testperson.xml"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="default_idle_behaviour"/>
+            <property type="STRING" data="dialog_behaviour"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass>
         <property name="classid" type="STRING" data="switch3way"/>
         <property name="baseclass" type="STRING" data="Switch3Way"/>
         <property name="description" type="STRING" data="Ein Hebel"/>

Added: modules/regressiontest/scripts/NpcCapsuleTest.rb
===================================================================
--- modules/regressiontest/scripts/NpcCapsuleTest.rb	2007-02-28 23:38:25 UTC (rev 3101)
+++ modules/regressiontest/scripts/NpcCapsuleTest.rb	2007-03-01 00:33:27 UTC (rev 3102)
@@ -0,0 +1,21 @@
+require 'testcase.rb'
+require 'npc.rb'
+
+class NpcCapsuleTest < TestCase
+    def initialize(center)
+        super(center)
+
+        height = 0.3
+        min_base = [-2.0, 0.05, -2.0]
+        max_base = [2.0, height, 2.0]
+        base = $AM.createBoxPrimitiveActor("capsuleTestBase",
+                                           min_base, max_base, "alpha_red")
+        base.placeIntoScene(center);
+
+        npc1proxy = $GOM.createGameObjectProxy("TestPersonCapsule");
+        npc1 = npc1proxy.getGameObject();
+        npc1.setPosition(rel_pos([0.0, height, 0.0]));
+
+        npc1.placeIntoScene();
+    end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-02-28 23:38:25 UTC (rev 3101)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-03-01 00:33:27 UTC (rev 3102)
@@ -6,6 +6,7 @@
 require 'GameObjectCreationTest.rb'
 require 'GameObjectStatesTest.rb'
 require 'NpcTest.rb'
+require 'NpcCapsuleTest.rb'
 require 'TimeTest.rb'
 require 'InventoryTest.rb'
 require 'ErrorHandlingTest.rb'
@@ -20,8 +21,10 @@
 $hero = $GOM.createGameObjectProxy("hero", 1);
 
 $SCRIPT.log("Place hero into scene")
+#$hero.getGameObject().setPosition([0.0, 1.0, 0.0]);
 $hero.getGameObject().placeIntoScene()
 
+
 $SCRIPT.log("Prepare hero for being the active character")
 PlayerSettings.preparePlayer($hero.getGameObject())
 
@@ -36,6 +39,7 @@
 #GameObjectCreationTest.new([5, 0, 0])
 #GameObjectStatesTest.new([0, 0, 5])
 NpcTest.new([-5, 0, 5])
+NpcCapsuleTest.new([0, 0, 5])
 TimeTest.new([-5, 0, -5])
 ErrorHandlingTest.new([-10, 0, 5])
 InventoryTest.new([0, 0, 10])



From natoka at mail.berlios.de  Thu Mar  1 01:34:51 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Thu, 1 Mar 2007 01:34:51 +0100
Subject: [Dsa-hl-svn] r3103 - in rl/trunk/engine/core: include src
Message-ID: <200703010034.l210YpwM021151@sheep.berlios.de>

Author: natoka
Date: 2007-03-01 01:34:48 +0100 (Thu, 01 Mar 2007)
New Revision: 3103

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
Log:
corrected offset/orientation code for createCollision()

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-03-01 00:33:27 UTC (rev 3102)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-03-01 00:34:48 UTC (rev 3103)
@@ -188,8 +188,6 @@
 		void setBody(OgreNewt::Body* body);
 
 		/** creates a collision primitive for OgreNewt.
-		 * Currently this is Work In Progress - so it's changing 
-		 *    and the offset/orientation is not working accordling at the moment ...
 		 * The collision primitive created has got a basic orientation which can be influenced by
 		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
 		 * calculated according to the size and type of collision primitiv.

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-01 00:33:27 UTC (rev 3102)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-01 00:34:48 UTC (rev 3103)
@@ -354,6 +354,8 @@
     {
 		const Vector3 size( aabb.getSize() );
 		OgreNewt::World* physWorld = PhysicsManager::getSingleton()._getNewtonWorld();
+		Ogre::Vector3 object_offset = Ogre::Vector3::ZERO;
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
 
         CollisionPtr rval;
 
@@ -369,12 +371,20 @@
 	    */
 		if (mGeometryType == PhysicsManager::GT_BOX)
         {
+			// set offset/orientation when they are null
+			if (! offset) {
+				offset = &object_offset;
+				*offset = aabb.getCenter();
+			}
+			if (! orientation)
+				orientation = &object_orientation;
+
 			// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-			rval = CollisionPtr(new CollisionPrimitives::Box(
+			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
 				physWorld,
 				size,
-				Ogre::Quaternion::IDENTITY,
-				aabb.getCenter())
+				*orientation,
+				*offset)
 				);
 
 			if (inertiaCoefficients != NULL)
@@ -388,12 +398,21 @@
         else if (mGeometryType == PhysicsManager::GT_SPHERE)
         {
 			double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
+
+			// set offset/orientation when they are null
+			if (! offset) {
+				offset = &object_offset;
+				*offset = Vector3(0,radius,0);
+			}
+			if (! orientation)
+				orientation = &object_orientation;
+
 			// a sphere primitiv has got its coordinate system at its center, so shift it with radius
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
 				physWorld,
 				Vector3(radius, radius, radius),
-				Ogre::Quaternion::IDENTITY,
-				Vector3(0,radius,0))
+				*orientation,
+				*offset)
 				);
             
 			if (inertiaCoefficients != NULL)
@@ -408,12 +427,21 @@
             s.x = std::max(s.x, s.z);
             s.z = s.x;
 
+			// set offset/orientation when they are null
+			if (! offset) {
+				offset = &object_offset;
+				*offset = Vector3(0,s.y,0);
+			}
+			if (! orientation)
+				orientation = &object_orientation;
+
 			// an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
 				physWorld, 
 				s,
-				Ogre::Quaternion::IDENTITY,
-				Vector3(0,s.y,0)));
+				*orientation,
+				*offset)
+				);
 
             if (inertiaCoefficients != NULL)
 			{
@@ -424,20 +452,26 @@
 		{
 			double radius = std::max(size.x, size.z) / 2.0;
 			double height = size.y;
-			
-			Quaternion orientCaps;
-			orientCaps.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
 
-			Vector3 offsetCaps (0, size.y/2, 0);
+			// set offset/orientation when they are null
+			if (! offset) {
+				offset = &object_offset;
+				*offset = Vector3(0, size.y/2, 0);
+			}
+			if (! orientation) {
+				orientation = &object_orientation;
+				orientation->FromAngleAxis(Degree(90), Vector3::UNIT_Z);
+			}
 
 			// an capsule primitiv has got its coordinate system at its center, so shift it with radius
 			// additionally it is x axis aligned, so rotate it 90 degrees around z axis
 			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-						physWorld, 
-						radius, 
-						height,
-						orientCaps,
-						offsetCaps));
+				physWorld, 
+				radius, 
+				height,
+				*orientation,
+				*offset)
+				);
 			
 			if (inertiaCoefficients != NULL)
 			{
@@ -458,10 +492,30 @@
 				{
 					// Objekt zu klein!
 					LOG_MESSAGE(Logger::CORE, " PhyiscalThing too small to create a convexhull, using 'box' instead! ");
-					rval = CollisionPtr(new CollisionPrimitives::Box(physWorld, size));
+
+					// set offset/orientation when they are null
+					if (! offset) {
+						offset = &object_offset;
+						*offset = aabb.getCenter();
+					}
+					if (! orientation)
+						orientation = &object_orientation;
+					
+					rval = CollisionPtr(new CollisionPrimitives::Box(
+						physWorld, 
+						size, 
+						*orientation,
+						*offset)
+						);
 				}
 				else
 				{
+					// set offset/orientation when they are null
+					if (! offset)
+						offset = &object_offset;
+					if (! orientation)
+						orientation = &object_orientation;
+
 					// the problem fixed and it's source:
 					// entity is a MeshObject containing the basic state of the Mesh, but
 					// this function should create the physical bounding convex hull for one of the
@@ -479,7 +533,7 @@
 
 					// calculate the convex hull of the animated mesh
 					rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(physWorld,
-						entity, true));
+						entity, true, *orientation, *offset));
 
 					// cleanup the temporary mesh
 					delete tempMesh;



From blakharaz at mail.berlios.de  Thu Mar  1 02:21:34 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 1 Mar 2007 02:21:34 +0100
Subject: [Dsa-hl-svn] r3104 - rl/trunk/docs
Message-ID: <200703010121.l211LYXA025112@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-01 02:21:32 +0100 (Thu, 01 Mar 2007)
New Revision: 3104

Removed:
   rl/trunk/docs/api/
Log:
Removed empty api docs directory, doxygen creates them anyway




From zero-gravity at mail.berlios.de  Thu Mar  1 21:13:10 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Thu, 1 Mar 2007 21:13:10 +0100
Subject: [Dsa-hl-svn] r3105 - in rl/trunk/engine: common common/include
	common/src core/include core/src rules/src script/swig ui/src
Message-ID: <200703012013.l21KDAcN026149@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-01 21:12:51 +0100 (Thu, 01 Mar 2007)
New Revision: 3105

Removed:
   rl/trunk/engine/common/include/LinkedPlaylist.h
   rl/trunk/engine/common/include/Playlist.h
   rl/trunk/engine/common/include/PlaylistEvent.h
   rl/trunk/engine/common/include/PlaylistObject.h
   rl/trunk/engine/common/include/SimplePlaylist.h
   rl/trunk/engine/common/src/LinkedPlaylist.cpp
   rl/trunk/engine/common/src/Playlist.cpp
   rl/trunk/engine/common/src/PlaylistEvent.cpp
   rl/trunk/engine/common/src/PlaylistObject.cpp
   rl/trunk/engine/common/src/SimplePlaylist.cpp
Modified:
   rl/trunk/engine/common/RlCommon2005.vcproj
   rl/trunk/engine/common/include/Exception.h
   rl/trunk/engine/core/include/BaseAnimation.h
   rl/trunk/engine/core/include/SoundObject.h
   rl/trunk/engine/core/src/AnimationListener.cpp
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/GameAreaListener.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp
   rl/trunk/engine/rules/src/QuestListener.cpp
   rl/trunk/engine/rules/src/TimerListener.cpp
   rl/trunk/engine/script/swig/RlCommon.head.swig
   rl/trunk/engine/script/swig/RlCommon.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
   rl/trunk/engine/ui/src/CharacterController.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
Log:
Removed Playlists they are no longer needed because of the Job-System
Removed all ScriptInvocationFailedExceptions
Cleaned up RlExports.i a bit

Modified: rl/trunk/engine/common/RlCommon2005.vcproj
===================================================================
--- rl/trunk/engine/common/RlCommon2005.vcproj	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/RlCommon2005.vcproj	2007-03-01 20:12:51 UTC (rev 3105)
@@ -301,10 +301,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\LinkedPlaylist.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\Logger.cpp"
 				>
 			</File>
@@ -317,18 +313,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\Playlist.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\PlaylistEvent.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\PlaylistObject.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\Properties.cpp"
 				>
 			</File>
@@ -345,10 +329,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\SimplePlaylist.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\XmlErrorHandler.cpp"
 				>
 			</File>
@@ -413,10 +393,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\LinkedPlaylist.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\Logger.h"
 				>
 			</File>
@@ -429,18 +405,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\Playlist.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\PlaylistEvent.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\PlaylistObject.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\Properties.h"
 				>
 			</File>
@@ -461,10 +425,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\SimplePlaylist.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\Sleep.h"
 				>
 			</File>

Modified: rl/trunk/engine/common/include/Exception.h
===================================================================
--- rl/trunk/engine/common/include/Exception.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/Exception.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -241,18 +241,6 @@
 
    };
 
-   class ScriptInvocationFailedException : public RuntimeException {
-   public:
-       ScriptInvocationFailedException(const std::string& message,
-           const std::string& file, const std::string& function, int line)
-           : RuntimeException(message, file, function, line) {}
-
-       ScriptInvocationFailedException(const ScriptInvocationFailedException& rhs)
-               : RuntimeException(rhs) {}
-
-       virtual std::string getType() { return "ScriptInvocationFailedException"; }
-   };
-
    class OutOfRangeException : public RuntimeException {
    public:
       OutOfRangeException(const std::string& message,

Deleted: rl/trunk/engine/common/include/LinkedPlaylist.h
===================================================================
--- rl/trunk/engine/common/include/LinkedPlaylist.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/LinkedPlaylist.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,67 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef _LINKEDPLAYLIST_H_
-#define _LINKEDPLAYLIST_H_
-
-#include "CommonPrerequisites.h"
-#include "EventListener.h"
-#include "Playlist.h"
-#include <list>
-
-namespace rl
-{
-class PlaylistObject;
-class LinkItem;
-typedef std::list<LinkItem*> LinkedList;
-class _RlCommonExport LinkItem : public EventListener<PlaylistEvent>
-{
-private:
-	LinkedList mChildren;
-	PlaylistObject *mItem;
-
-public:
-	LinkItem(PlaylistObject *item);
-	virtual ~LinkItem();
-	PlaylistObject* getItem() const;
-	void start();
-	void stop();
-	void add(PlaylistObject *child);
-	void remove(PlaylistObject *child);
-	virtual bool eventRaised(PlaylistEvent *anEvent);
-};
-
-
-class _RlCommonExport LinkedPlaylist : public Playlist
-{
-private:
-	LinkItem *mList;
-	LinkItem *mPlaying;
-
-public:
-	LinkedPlaylist();
-	virtual ~LinkedPlaylist();
-    void add(PlaylistObject *object, LinkItem *parent);
-	void remove(PlaylistObject *object, LinkItem *parent);
-    virtual void stop();
-	virtual void start();
-	virtual bool eventRaised(PlaylistEvent *anEvent);
-	LinkItem* getList() const;
-};
-
-}
-
-#endif /* LinkedPlaylist_H_*/

Deleted: rl/trunk/engine/common/include/Playlist.h
===================================================================
--- rl/trunk/engine/common/include/Playlist.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/Playlist.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,40 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef _PLAYLIST_H_
-#define _PLAYLIST_H_
-
-#include "CommonPrerequisites.h"
-#include "EventListener.h"
-#include "PlaylistObject.h"
-
-namespace rl
-{
-
-
-class _RlCommonExport Playlist : public EventListener<PlaylistEvent>
-{
-    
-public:
-	Playlist();
-	virtual ~Playlist();
-    virtual void stop() = 0;
-	virtual void start() = 0;
-};
-
-}
-
-#endif /*Playlist_H_*/

Deleted: rl/trunk/engine/common/include/PlaylistEvent.h
===================================================================
--- rl/trunk/engine/common/include/PlaylistEvent.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/PlaylistEvent.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,42 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
- 
-#ifndef PLAYLISTEVENT_H
-#define PLAYLISTEVENT_H
-
-#include "CommonPrerequisites.h"
-#include "EventObject.h"
-
-namespace rl {
-
-class _RlCommonExport PlaylistEvent : public EventObject
-{
-
-public:
-	PlaylistEvent(EventSource *source);
-    PlaylistEvent(EventSource *source, const unsigned int reason);
-	virtual ~PlaylistEvent();
-
-	static const unsigned int NOPEVENT = 0;
-	static const unsigned int STARTEVENT = 1;
-    static const unsigned int STOPEVENT = 2;
-    static const unsigned int PAUSEEVENT = 3;
-	static const unsigned int LOADEVENT = 4;
-	static const unsigned int UNLOADEVENT = 5;
-};
-
-}
-#endif // PLAYLISTEVENT_H

Deleted: rl/trunk/engine/common/include/PlaylistObject.h
===================================================================
--- rl/trunk/engine/common/include/PlaylistObject.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/PlaylistObject.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,49 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef _PLAYLISTOBJECT_H_
-#define _PLAYLISTOBJECT_H_
-
-#include "CommonPrerequisites.h"
-#include "EventCaster.h"
-#include "PlaylistEvent.h"
-#include "EventSource.h"
-
-namespace rl {
-
-class _RlCommonExport PlaylistObject : 
-			public EventCaster<PlaylistEvent>, public virtual EventSource
-{
-public:
-	/// Konstruktor
-	PlaylistObject();
-	/// Destruktor
-	virtual ~PlaylistObject();
-	/// Objekt laden, einrichten etc.
-	virtual void load();
-	/// Objekt entladen, abbauen etc.
-	virtual void unload();
-	/// Objektaktion starten
-	virtual void start();
-	/// Objectaktion stoppen
-	virtual void stop();
-	/// Objektaktion pausieren
-	virtual void pause();
-};
-
-}
-
-#endif

Deleted: rl/trunk/engine/common/include/SimplePlaylist.h
===================================================================
--- rl/trunk/engine/common/include/SimplePlaylist.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/include/SimplePlaylist.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,51 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef _SIMPLEPLAYLIST_H_
-#define _SIMPLEPLAYLIST_H_
-
-#include "CommonPrerequisites.h"
-#include "EventListener.h"
-#include "Playlist.h"
-#include <list>
-
-namespace rl
-{
-
-typedef std::list<PlaylistObject*> ObjectList;
-
-class _RlCommonExport SimplePlaylist : public Playlist
-{
-private:
-    ObjectList mQueue;
-	ObjectList::iterator mItem;
-	bool mLooping;
-    
-public:
-	SimplePlaylist();
-	virtual ~SimplePlaylist();
-    void add(PlaylistObject *object);
-	void remove(PlaylistObject *object);
-    virtual void stop();
-	virtual void start();
-	virtual bool eventRaised(PlaylistEvent *anEvent);
-	void setLooping(bool looping);
-	bool isLooping() const;
-};
-
-}
-
-#endif /* SimplePlaylist_H_*/

Deleted: rl/trunk/engine/common/src/LinkedPlaylist.cpp
===================================================================
--- rl/trunk/engine/common/src/LinkedPlaylist.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/src/LinkedPlaylist.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,170 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "LinkedPlaylist.h"
-
-namespace rl
-{
-
-LinkItem::LinkItem(PlaylistObject *object)
-	: mItem(object)
-{
-	mItem->addEventListener(this);
-}
-
-LinkItem::~LinkItem()
-{
-	mItem->stop();
-	mItem->removeEventListener(this);
-
-	LinkedList::iterator it;
-	for(it = mChildren.begin(); it != mChildren.end();)
-	{
-		delete *(it++);
-	} 
-}
-
-void LinkItem::add(PlaylistObject *child)
-{
-	if (child != 0)
-	{
-		LinkItem *item = new LinkItem(child);
-		mChildren.push_back(item);
-	}
-}
-
-bool LinkItem::eventRaised(PlaylistEvent *anEvent)
-{
-	switch(anEvent->getReason())
-	{
-/*	case PlaylistEvent::STARTEVENT:
-		break;
-	case PlaylistEvent::NOPEVENT:
-		break;
-	case PlaylistEvent::PAUSEEVENT:
-		break; */
-	case PlaylistEvent::STOPEVENT:
-		{
-			LinkedList::iterator it;
-			for(it = mChildren.begin(); it != mChildren.end();it++)
-			{
-				(*it)->start();
-			}
-		}
-		break;
-	default:
-		break;
-	}
-	return true;
-}
-
-PlaylistObject *LinkItem::getItem() const
-{
-	return mItem;
-}
-
-void LinkItem::remove(PlaylistObject *child)
-{
-	LinkedList::iterator it;
-	for(it = mChildren.begin(); it != mChildren.end();)
-	{
-		if ((*it)->getItem() == child)
-		{
-			mChildren.erase(it++);
-		} else {
-			++it;
-		}
-	}
-}
-
-void LinkItem::start()
-{
-
-	mItem->start();
-}
-
-void LinkItem::stop()
-{
-}
-
-LinkedPlaylist::LinkedPlaylist() : Playlist(),
-	mList(0)
-{
-}
-
-LinkedPlaylist::~LinkedPlaylist()
-{
-	stop();
-	delete mList;
-}
-
-
-void LinkedPlaylist::add(PlaylistObject *object, LinkItem *parent)
-{
-	if (object)
-	{
-		if (parent == 0)
-		{
-			LinkItem *item = new LinkItem(object);
-			mList = item;
-		} else {
-			parent->add(object);
-		}
-		object->load();
-		object->addEventListener(this);
-	}
-}
-
-void LinkedPlaylist::remove(PlaylistObject *object, LinkItem *parent)
-{
-	if (object && parent)
-	{
-		object->removeEventListener(this);
-		object->unload();
-		parent->remove(object);
-	}
-}
-
-void LinkedPlaylist::start()
-{
-	stop();
-	if (mList != 0)
-	{
-		mPlaying = mList;
-		mPlaying->start();
-	}
-}
-
-void LinkedPlaylist::stop()
-{
-	if (mList != 0)
-	{
-		mList->stop();
-	}
-}
-
-bool LinkedPlaylist::eventRaised(PlaylistEvent *anEvent)
-{
-	mPlaying->stop();
-	return true;
-}
-
-LinkItem *LinkedPlaylist::getList() const
-{
-	return mList;
-}
-
-}

Deleted: rl/trunk/engine/common/src/Playlist.cpp
===================================================================
--- rl/trunk/engine/common/src/Playlist.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/src/Playlist.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,32 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "Playlist.h"
-#include "PlaylistObject.h"
-
-namespace rl
-{
-
-Playlist::Playlist() : EventListener<PlaylistEvent>()
-{
-}
-
-Playlist::~Playlist()
-{
-}
-
-
-}

Deleted: rl/trunk/engine/common/src/PlaylistEvent.cpp
===================================================================
--- rl/trunk/engine/common/src/PlaylistEvent.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/src/PlaylistEvent.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,34 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "PlaylistEvent.h"
-
-namespace rl {
-
-PlaylistEvent::PlaylistEvent(EventSource *source) :
-    EventObject(source)
-{}
-
-PlaylistEvent::PlaylistEvent(EventSource *source, const unsigned int reason):
-    EventObject(source, reason)
-{
-}
-
-PlaylistEvent::~PlaylistEvent()
-{}
-
-
-}

Deleted: rl/trunk/engine/common/src/PlaylistObject.cpp
===================================================================
--- rl/trunk/engine/common/src/PlaylistObject.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/src/PlaylistObject.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,68 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "PlaylistObject.h"
-
-namespace rl {
-/**
- * @author JoSch
- * @date 12-04-2006
- * @version 1.0
- */
-PlaylistObject::PlaylistObject(): EventCaster<PlaylistEvent>(), EventSource()
-{
-}
-
-/**
- * @author JoSch
- * @date 12-04-2006
- * @version 1.0
- */
-PlaylistObject::~PlaylistObject()
-{
-}
-
-void PlaylistObject::start()
-{
-	PlaylistEvent event = PlaylistEvent(this, PlaylistEvent::STARTEVENT);
-	dispatchEvent(&event);
-}
-
-void PlaylistObject::stop()
-{
-	PlaylistEvent event = PlaylistEvent(this, PlaylistEvent::STOPEVENT);
-	dispatchEvent(&event);
-}
-
-void PlaylistObject::pause()
-{
-	PlaylistEvent event = PlaylistEvent(this, PlaylistEvent::PAUSEEVENT);
-	dispatchEvent(&event);
-}
-
-void PlaylistObject::load()
-{
-	PlaylistEvent event = PlaylistEvent(this, PlaylistEvent::LOADEVENT);
-	dispatchEvent(&event);
-}
-
-void PlaylistObject::unload()
-{
-	PlaylistEvent event = PlaylistEvent(this, PlaylistEvent::UNLOADEVENT);
-	dispatchEvent(&event);
-}
-
-}

Deleted: rl/trunk/engine/common/src/SimplePlaylist.cpp
===================================================================
--- rl/trunk/engine/common/src/SimplePlaylist.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/common/src/SimplePlaylist.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -1,106 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "SimplePlaylist.h"
-
-namespace rl
-{
-
-SimplePlaylist::SimplePlaylist() : Playlist(),
-	mLooping(false)
-{
-}
-
-SimplePlaylist::~SimplePlaylist()
-{
-	stop();
-/*	for(mItem = mQueue.begin(); mItem != mQueue.end(); mItem++)
-	{
-		remove(*mItem);
-	} */
-}
-
-
-void SimplePlaylist::add(PlaylistObject *object)
-{
-	if (object)
-	{
-		mQueue.push_back(object);
-		object->load();
-		object->addEventListener(this);
-	}
-}
-
-void SimplePlaylist::remove(PlaylistObject *object)
-{
-	if (object)
-	{
-		object->removeEventListener(this);
-		object->unload();
-		if (*mItem == object)
-		{
-			mItem++;
-		}
-		mQueue.remove(object);
-	}
-}
-
-void SimplePlaylist::start()
-{
-	stop();
-	mItem = mQueue.begin();
-	(*mItem)->start();
-}
-
-void SimplePlaylist::stop()
-{
-	ObjectList::iterator it;
-	for(it = mQueue.begin(); it != mQueue.end(); it++)
-	{
-		(*it)->stop();
-	}
-}
-
-bool SimplePlaylist::eventRaised(PlaylistEvent *anEvent)
-{
-	(*mItem)->stop();
-	if (mItem != mQueue.end())
-	{
-		mItem++;
-	} else {
-		if (mLooping)
-		{
-			mItem = mQueue.begin();
-		}
-	}
-	if (mItem != mQueue.end())
-	{
-		(*mItem)->start();
-	}
-	return true;
-}
-
-void SimplePlaylist::setLooping(bool looping)
-{
-	mLooping = looping;
-}
-
-bool SimplePlaylist::isLooping() const
-{
-	return mLooping;
-}
-
-}

Modified: rl/trunk/engine/core/include/BaseAnimation.h
===================================================================
--- rl/trunk/engine/core/include/BaseAnimation.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/include/BaseAnimation.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -22,7 +22,6 @@
 #include <set>
 #include <map>
 #include "AnimationListener.h"
-#include "PlaylistObject.h"
 
 
 namespace rl {
@@ -33,7 +32,7 @@
 	@remarks Instanzen werden ?ber den AnimationManager erzeugt
 	@see AnimationManager
 */
-class _RlCoreExport BaseAnimation : public virtual PlaylistObject
+class _RlCoreExport BaseAnimation : public virtual EventSource
 {
     public:
 		/**

Modified: rl/trunk/engine/core/include/SoundObject.h
===================================================================
--- rl/trunk/engine/core/include/SoundObject.h	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/include/SoundObject.h	2007-03-01 20:12:51 UTC (rev 3105)
@@ -19,7 +19,6 @@
 
 #include "CorePrerequisites.h"
 #include "ActorControlledObject.h"
-#include "PlaylistObject.h"
 #include "SoundEvents.h"
 #include "EventListener.h"
 
@@ -33,8 +32,7 @@
      *  heften kann. Zwischen Actor und ActorControlledObject
      *  besteht eine 1:1-Beziehung.
      */
-    class _RlCoreExport SoundObject : public ActorControlledObject, public PlaylistObject,
-        public EventListener<SoundEvent>
+    class _RlCoreExport SoundObject : public ActorControlledObject
     {
     public:
         SoundObject(Sound *sound, const Ogre::String &name);
@@ -84,9 +82,6 @@
         void start();
         /// Pausieren den Sound
         void pause();
-        
-        /// Ein SoundEreignis ist passiert.
-        virtual bool eventRaised(SoundEvent *event);
 
 		virtual bool isMeshObject();
     };

Modified: rl/trunk/engine/core/src/AnimationListener.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationListener.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/src/AnimationListener.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -38,25 +38,18 @@
 
 bool AnimationListener::eventRaised( AnimationEvent* anEvent ) 
 {
-    try
+    switch( anEvent->getReason() )
     {
-	    switch( anEvent->getReason() )
-	    {
-	    case AnimationEvent::ANIMATION_FINISHED:
-		    this->animationFinished( anEvent );
-		    break;
-	    case AnimationEvent::ANIMATION_UNPAUSED:
-		    this->animationUnpaused( anEvent );
-		    break;
-	    case AnimationEvent::ANIMATION_PAUSED:
-		    this->animationPaused( anEvent );
-		    break;
-	    }
+    case AnimationEvent::ANIMATION_FINISHED:
+        this->animationFinished( anEvent );
+        break;
+    case AnimationEvent::ANIMATION_UNPAUSED:
+        this->animationUnpaused( anEvent );
+        break;
+    case AnimationEvent::ANIMATION_PAUSED:
+        this->animationPaused( anEvent );
+        break;
     }
-    catch( ScriptInvocationFailedException& sife )
-    {
-        LOG_ERROR(Logger::CORE, sife.toString() );
-    }
 
 	// consumed or not ;)
 	return false;
@@ -64,16 +57,8 @@
 
  bool AnimationFrameListener::eventRaised(AnimationFrameEvent *anEvent)
 {
-    try
-    {
-        this->animationFrameReached( anEvent );
-    }
-    catch( ScriptInvocationFailedException& sife )
-    {
-        LOG_ERROR(Logger::CORE, sife.toString() );
-    }
+    this->animationFrameReached( anEvent );
 
-
     // consumed or not ;)
     return false;
 }

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -28,7 +28,7 @@
 
 BaseAnimation::BaseAnimation( Ogre::Real length, Ogre::Real speed, 
     unsigned int timesToPlay, bool paused ) :
-    PlaylistObject(),
+    EventSource(),
     mLength(length),
 	mAnimationFrameListener(),
 	mAnimationCaster(),
@@ -427,19 +427,16 @@
 
 void BaseAnimation::start()
 {
-	PlaylistObject::start();
     setPaused(false);
 }
 
 void BaseAnimation::stop()
 {
-	PlaylistObject::stop();
     setPaused(true);
 }
 
 void BaseAnimation::pause()
 {
-	PlaylistObject::pause();
     setPaused(true);
 }
 

Modified: rl/trunk/engine/core/src/GameAreaListener.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaListener.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/src/GameAreaListener.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -30,22 +30,15 @@
 
     bool GameAreaListener::eventRaised( GameAreaEvent* anEvent )
     {
-        try
+        switch( anEvent->getReason() )
         {
-            switch( anEvent->getReason() )
-            {
-            case GameAreaEvent::AREA_ENTERED:
-                this->areaEntered( anEvent );
-                break;
-            case GameAreaEvent::AREA_LEFT:
-                this->areaLeft( anEvent );
-                break;
-            }
+        case GameAreaEvent::AREA_ENTERED:
+            this->areaEntered( anEvent );
+            break;
+        case GameAreaEvent::AREA_LEFT:
+            this->areaLeft( anEvent );
+            break;
         }
-        catch( ScriptInvocationFailedException& sife )
-        {
-            LOG_ERROR(Logger::CORE, sife.toString() );
-        }
 
 
         // consumed or not ;)

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -35,11 +35,8 @@
  * @date 03-11-2005
  */   
 SoundObject::SoundObject(Sound *sound, const Ogre::String &name)
-    : ActorControlledObject(sound),
-	PlaylistObject(),
-	EventListener<SoundEvent>()
+    : ActorControlledObject(sound)
 {
-    sound->addEventListener(this);
     // The movable has to be registered with the Ogre scene manager, since it is not
     // created by it.
     CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->injectMovableObject(sound);
@@ -53,7 +50,6 @@
 {
     if (mMovableObject != NULL)
     {
-        getSound()->removeEventListener(this);
 		SoundManager::getSingleton().getActiveDriver()->destroySound(getSound());
         mMovableObject = NULL;
     }
@@ -121,7 +117,6 @@
 
 void SoundObject::stop()
 {
-	PlaylistObject::stop();
     getSound()->stop();
 }
 
@@ -153,13 +148,11 @@
 
 void SoundObject::load()
 {
-	PlaylistObject::load();
 	getSound()->load();
 }
 
 void SoundObject::unload()
 {
-	PlaylistObject::unload();
     getSound()->unload();
 }
 
@@ -183,37 +176,14 @@
     return "SoundObject";
 }
 
-bool SoundObject::eventRaised(SoundEvent *event)
-{
-	int newReason = PlaylistEvent::NOPEVENT;
-	switch(event->getReason())
-	{
-		case SoundPlayEvent::PAUSEEVENT:
-			newReason = PlaylistEvent::PAUSEEVENT;
-			break;
-		case SoundPlayEvent::STARTEVENT:
-			newReason = PlaylistEvent::STARTEVENT;
-			break;
-		case SoundPlayEvent::STOPEVENT:
-			newReason = PlaylistEvent::STOPEVENT;
-			break;
-		default:
-			break;
-	}
-	PlaylistEvent newEvent = PlaylistEvent(event->getSource(), newReason);
-    dispatchEvent(&newEvent);
-    return true;
-}
 
 void SoundObject::pause()
 {
-	PlaylistObject::pause();
     pause(true);
 }
 
 void SoundObject::start()
 {
-	PlaylistObject::start();
     pause(false);
 }
 

Modified: rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -26,14 +26,7 @@
 
 	bool ObjectStateChangeListener::eventRaised(ObjectStateChangeEvent* evt)
 	{
-        try
-        {
-            objectStateChanged(evt);
-        }
-		catch( ScriptInvocationFailedException& sife )
-        {
-			LOG_ERROR(Logger::RULES, sife.toString() );
-        }
+        objectStateChanged(evt);
 
         // consumed or not
 		return false;

Modified: rl/trunk/engine/rules/src/QuestListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestListener.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/rules/src/QuestListener.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -26,21 +26,14 @@
 
     bool QuestListener::eventRaised(QuestEvent* evt)
     {
-        try
-        {
-            if( evt->getReason() == QuestEvent::QUEST_STATE )
-                questStateChanged(evt);
-            else if( evt->getReason() == QuestEvent::QUEST_PARTSDONE )
-                questPartsDoneChanged(evt);
-            else if( evt->getReason() == QuestEvent::QUEST_KNOWN )
-                questKnownChanged(evt);
-            else if( evt->getReason() == QuestEvent::QUEST_SUBQUEST )
-                questSubquestAdded(evt);
-        }
-        catch( ScriptInvocationFailedException& sife )
-        {
-            LOG_ERROR(Logger::RULES, sife.toString() );
-        }
+        if( evt->getReason() == QuestEvent::QUEST_STATE )
+            questStateChanged(evt);
+        else if( evt->getReason() == QuestEvent::QUEST_PARTSDONE )
+            questPartsDoneChanged(evt);
+        else if( evt->getReason() == QuestEvent::QUEST_KNOWN )
+            questKnownChanged(evt);
+        else if( evt->getReason() == QuestEvent::QUEST_SUBQUEST )
+            questSubquestAdded(evt);
 
         // consumed or not
         return false;
@@ -48,17 +41,10 @@
 
     bool QuestListener::eventRaised(JournalEvent* evt)
     {
-        try
+        if (evt->getReason() == JournalEvent::JOURNAL_ENTRY_ADDED)
         {
-            if (evt->getReason() == JournalEvent::JOURNAL_ENTRY_ADDED)
-            {
-                journalEntryAdded(evt);
-            }
+            journalEntryAdded(evt);
         }
-        catch (ScriptInvocationFailedException& sife)
-        {
-            LOG_ERROR(Logger::RULES, sife.toString());
-        }
 
         // consumed or not
         return false;

Modified: rl/trunk/engine/rules/src/TimerListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerListener.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/rules/src/TimerListener.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -27,14 +27,7 @@
 
 	bool TimerListener::eventRaised(TimerEvent* evt)
 	{
-        try
-        {
-            timerFired(evt);
-        }
-		catch( ScriptInvocationFailedException& sife )
-        {
-			LOG_ERROR(Logger::CORE, sife.toString() );
-        }
+        timerFired(evt);
 
         // consumed or not
 		return false;

Modified: rl/trunk/engine/script/swig/RlCommon.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.head.swig	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/script/swig/RlCommon.head.swig	2007-03-01 20:12:51 UTC (rev 3105)
@@ -23,10 +23,5 @@
 #include "EventListener.h"
 #include "EventObject.h"
 #include "EventCaster.h"
-#include "PlaylistObject.h"
-#include "Playlist.h"
-#include "PlaylistEvent.h"
 #include "Property.h"
-#include "SimplePlaylist.h"
-#include "LinkedPlaylist.h"
 %}

Modified: rl/trunk/engine/script/swig/RlCommon.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.swig	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/script/swig/RlCommon.swig	2007-03-01 20:12:51 UTC (rev 3105)
@@ -97,79 +97,5 @@
    void setReason(const unsigned int reason);
 };
 
-%template(EventObjectEventCaster) EventCaster<rl::EventObject>;
-class PlaylistObject : public rl::EventCaster<rl::EventObject>
-{
-public:
-	/// Konstruktor
-	PlaylistObject();
-	/// Destruktor
-	~PlaylistObject();
-	/// Objekt laden, einrichten etc.
-	virtual void load() = 0;
-	/// Objekt entladen, abbauen etc.
-	virtual void unload() = 0;
-	/// Objektaktion starten
-	virtual void start() = 0;
-	/// Objectaktion stoppen
-	virtual void stop() = 0;
-	/// Objektaktion pausieren
-	virtual void pause() = 0;
-};
-
-class PlaylistEvent : public rl::EventObject
-{
-};
-
-%template(EventObjectEventListener) EventListener<rl::PlaylistEvent>;
-class Playlist : public rl::EventListener<rl::PlaylistEvent>
-{
-public:
-	Playlist();
-	virtual ~Playlist();
-    virtual void start() = 0;
-    virtual void stop() = 0;
-};
-
-class SimplePlaylist : public rl::Playlist
-{
-public:
-	SimplePlaylist();
-	virtual ~SimplePlaylist();
-    virtual void add(rl::PlaylistObject *object);
-    virtual void remove(rl::PlaylistObject *object);
-    virtual void start();
-    virtual void stop();
-    void setLooping(bool looping);
-    bool isLooping() const;
-    virtual bool eventRaised(rl::PlaylistEvent *eventRaised);
-};
-
-class rl::LinkItem;
-typedef std::list<rl::LinkItem*> LinkedList;
-class LinkItem {
-public:
-	LinkItem(rl::PlaylistObject *item);
-	virtual ~LinkItem();
-	rl::PlaylistObject* getItem() const;
-	void start();
-	void stop();
-	void add(rl::PlaylistObject *child);
-	void remove(rl::PlaylistObject *child);
-};
-
-
-class LinkedPlaylist : public rl::Playlist
-{
-public:
-	LinkedPlaylist();
-	virtual ~LinkedPlaylist();
-    void add(rl::PlaylistObject *object, LinkItem *parent);
-	void remove(rl::PlaylistObject *object, LinkItem *parent);
-    virtual void stop();
-	virtual void start();
-	LinkItem* getList() const;
-};
-
 }
 

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-01 20:12:51 UTC (rev 3105)
@@ -14,6 +14,7 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+// Activate Directors and name the module RlScript
 %module(directors="1") RlScript
 /* Tell SWIG to keep track of mappings between C/C++ structs/classes. */
 %trackobjects;
@@ -28,20 +29,25 @@
 #	endif
 #endif
 
-#include <xercesc/util/XMemory.hpp>	// Muss vor Ogre stehen (zumindest fuer VS)
+// Has to be included before Ogre, MemoryManager issues...
+#include <xercesc/util/XMemory.hpp>	
 
-// Exportieren der Ruby Instanz R?ckgabe
+// Exporting the function for getting ruby instances
 VALUE RL_RubyInstanceFor(void* ptr) 
 {
 	return SWIG_RubyInstanceFor(ptr);
 }
+// Exporting the function for removing ruby instances
 void RL_RubyRemoveTracking(void* ptr) 
 {
 	return SWIG_RubyRemoveTracking(ptr);
 }
+
+#include "FixRubyHeaders.h"
+
 %}
 
-
+// Header includes
 %include "RlCommon.head.swig"
 %include "RlUi.head.swig"
 %include "RlCore.head.swig"
@@ -50,13 +56,14 @@
 %include "RlAi.head.swig"
 %include "RlScript.head.swig"
 
-
-
 %include "TypeMaps.i"
 %include "stl.i"
 %include "std_string.i"
 %include "std_pair.i"
 
+
+
+
 // Kopie. Falls das nochmal irgendwohin kopiert werden muss,
 // In separate Datei auslagen.
 #if !defined(RL_LONGLONG)
@@ -67,19 +74,31 @@
 #   endif
 #endif
 
-%feature("director:except") {
+
+
+
+// Handling of errors in director methods
+
+%feature("director:except") 
+{
+	RL_handleRubyError( error );
+	return Qnil;
+}
+
+%{
+// Error Handling for Ruby
+void RL_handleRubyError( VALUE error )
+{
 	stringstream stream;	
-	VALUE lasterr = rb_gv_get("$!");
-
-    // class
-    VALUE klass = rb_class_path(CLASS_OF(lasterr));
+	// get error class
+    VALUE klass = rb_class_path(CLASS_OF(error));
     stream << RSTRING(klass)->ptr << " ("; 
 
-    // message
-    VALUE message = rb_obj_as_string(lasterr);
+    // get error message
+    VALUE message = rb_obj_as_string(error);
     stream << RSTRING(message)->ptr << ") " << endl;
 
-    // backtrace
+    // get backtrace
     if(!NIL_P(ruby_errinfo)) 
     {
 		stream << "Callstack: [ ";
@@ -93,11 +112,18 @@
         }
         stream << "]";
     }
+    else
+		stream << "Kein Stacktrace vorhanden...";
         
-    rl::WindowFactory::getSingleton().writeToConsole( stream.str() );        
-	Throw(rl::ScriptInvocationFailedException, stream.str() );
+    rl::ScriptSubsystem::getSingleton().log( stream.str() );
+    rl::WindowFactory::getSingleton().writeToConsole( stream.str() );  
 }
+%}
 
+
+
+// Converting C++ Exceptions to Ruby Exceptions
+
 namespace Swig {
 	class DirectorException;
 }
@@ -119,8 +145,7 @@
     rb_raise(ogreException, oe.getFullDescription().c_str());
   }
   catch (Swig::DirectorException&) {
-    static VALUE directorException = rb_define_class("DirectorException", rb_eRuntimeError);
-    rb_raise(directorException, "Eine Director Exception ist aufgetreten");
+    SWIG_fail; 
   } 
   catch (std::exception& se) {
     static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
@@ -132,11 +157,21 @@
   }
 }
 
+
+
+
+// deaktiviere Warnung ueber unreferenzierte lokale Variable, 
+// da dies in allen erzeugten Exceptionhandlern auftritt
 %{
-#pragma warning( disable : 4101 )	// deaktiviere Warnung ueber unreferenzierte lokale Variable, 
-									// da dies in allen erzeugten Exceptionhandlern auftritt
+#pragma warning( disable : 4101 )	
+									
 %}
 
+
+
+
+// These functions will ensure no C++ will have to different Ruby links
+
 // doWithActor( Actor* ) oder andere Director-Methoden Parameter
 %typemap(directorin) SWIGTYPE*
 {
@@ -146,12 +181,11 @@
     if (resultdirector) {
         $input = resultdirector->swig_get_self();
     }
-    else
-	{
+    else {
 		VALUE val = SWIG_RubyInstanceFor( $1 );
 		
 		// Es gab das SkriptObjekt noch nicht
-		if( val == Qnil )
+		if (NIL_P(val))
 		{
 			$input = SWIG_NewPointerObj((void *) $1, $1_descriptor, NULL);		
 		}
@@ -166,8 +200,7 @@
 	VALUE val = SWIG_RubyInstanceFor( $1 );
 	
 	// Es gab das SkriptObjekt noch nicht
-	if( val == Qnil )
-	{
+	if (NIL_P(val)) {
 		$result = SWIG_NewPointerObj((void *) $1, $1_descriptor, NULL);			
 	}
 	else	
@@ -180,7 +213,7 @@
 	VALUE val = SWIG_RubyInstanceFor( $1 );
 	
 	// Es gab das SkriptObjekt noch nicht
-	if( val == Qnil )
+	if (NIL_P(val))
 	{
 		// Dynamic Cast ausf?hren
 		swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &$1);
@@ -204,8 +237,7 @@
 		VALUE val = SWIG_RubyInstanceFor( $1 );
 		
 		// Es gab das SkriptObjekt noch nicht
-		if( val == Qnil )
-		{
+		if (NIL_P(val)) {
 			// Dynamic Cast ausf?hren
 			swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &$1);
 			$input = SWIG_NewPointerObj((void *) $1, ty, 0);		
@@ -215,6 +247,9 @@
 	}
 } 
 
+
+// Include bodies
+
 %include "RlCommon.swig"
 %include "RlCore.swig"
 %include "RlRules.swig"

Modified: rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -197,17 +197,9 @@
 		LOG_DEBUG2(Logger::UI, 
 			action->getName().c_str(), "ActionChoiceWindow::activateAction");
 			
+		//TODO: Ask for target
+        action->doAction(mObject, mActor, NULL); 
 		
-        try
-        {
-            //TODO: Ask for target
-            action->doAction(mObject, mActor, NULL); 
-        }
-        catch( ScriptInvocationFailedException& sife )
-        {
-            LOG_ERROR(Logger::UI,  sife.toString() );
-        }
-		
 		LOG_DEBUG2(Logger::UI, 
 			"Ende", "ActionChoiceWindow::activateAction");
 

Modified: rl/trunk/engine/ui/src/CharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterController.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/ui/src/CharacterController.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -94,23 +94,16 @@
 			return false;
 		}
 
-		try
+        Action* action = ActionManager::getSingleton().getInGameGlobalAction(actionName);
+        if (action != NULL)
+        {
+            action->doAction(NULL, NULL, NULL);
+        }
+        else if (character != NULL)
 		{
-            Action* action = ActionManager::getSingleton().getInGameGlobalAction(actionName);
-            if (action != NULL)
-            {
-                action->doAction(NULL, NULL, NULL);
-            }
-            else if (character != NULL)
-			{
-				character->doAction(actionName, character, character);
-			}
-			return true;
+			character->doAction(actionName, character, character);
 		}
-		catch( ScriptInvocationFailedException& sife )
-		{
-			LOG_ERROR(Logger::UI, sife.toString() );
-		}
+		return true;
 
 		return false;
 	}

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-03-01 01:21:32 UTC (rev 3104)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-03-01 20:12:51 UTC (rev 3105)
@@ -320,15 +320,8 @@
                 mCommandMapper->getAction(code, CMDMAP_KEYMAP_GLOBAL));
             if (action != NULL)
             {
-                try
-                {
-                    action->doAction(NULL, NULL, NULL);
-                    LOG_MESSAGE2(Logger::UI, "    invoked action " + action->getName(), "InputManager::keyReleased");
-                }
-                catch( ScriptInvocationFailedException& sife )
-                {
-                    LOG_ERROR(Logger::UI, sife.toString() );
-                }
+                action->doAction(NULL, NULL, NULL);
+                LOG_MESSAGE2(Logger::UI, "    invoked action " + action->getName(), "InputManager::keyReleased");
             }
 
             if (mCharacterController != NULL)



From natoka at mail.berlios.de  Fri Mar  2 00:47:18 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Fri, 2 Mar 2007 00:47:18 +0100
Subject: [Dsa-hl-svn] r3106 - in rl/trunk/engine: ai/include ai/src
	core/include
Message-ID: <200703012347.l21NlIDH008869@sheep.berlios.de>

Author: natoka
Date: 2007-03-02 00:47:06 +0100 (Fri, 02 Mar 2007)
New Revision: 3106

Modified:
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/core/include/PhysicsController.h
Log:
removed 'using namespace OpenSteer' from header
fixed issues from the removal by adding the statement to the .cpp files
added comments to PhysicsController - to make it's use a bit clearer

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-03-01 23:47:06 UTC (rev 3106)
@@ -28,6 +28,8 @@
 	class SteeringVehicle;
 	class DialogCharacter;
 
+	/** Executes AI during game as a RL::GameTask
+	 */
 	class _RlAiExport AgentManager
 		: protected Ogre::Singleton<AgentManager>,
 		  public GameTask

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-01 23:47:06 UTC (rev 3106)
@@ -26,6 +26,8 @@
 	class AgentManager;
 	class AiWorld;
 
+	/** Central core of AI
+	 */
 	class _RlAiExport AiSubsystem 
 		: public Ogre::Singleton<AiSubsystem>,
 		  public SceneChangeListener

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-03-01 23:47:06 UTC (rev 3106)
@@ -20,7 +20,6 @@
 #include <OgreNewt.h>
 #include "PhysicsManager.h"
 
-using namespace OpenSteer;
 namespace rl
 {
 	/**
@@ -32,11 +31,11 @@
 		AiWorld(void);
 		~AiWorld(void);
 
-		ObstacleGroup getSteeringObstacles();
-		void addObstacle(Obstacle* obstacle);
+		OpenSteer::ObstacleGroup getSteeringObstacles();
+		void addObstacle(OpenSteer::Obstacle* obstacle);
 		void removeAllObstacles();
 	private:
-		ObstacleGroup mObstacles;
+		OpenSteer::ObstacleGroup mObstacles;
 	};
 
 
@@ -52,7 +51,7 @@
             mLevelMaterial = PhysicsManager::getSingleton()._getLevelMaterialID();
             mNewtonWorld = PhysicsManager::getSingleton()._getNewtonWorld();
         }
-        virtual void findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
+        virtual void findIntersectionWithVehiclePath (const OpenSteer::AbstractVehicle& vehicle,
                                               PathIntersection& pi) const;
     private:
         enum RaycastType

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-03-01 23:47:06 UTC (rev 3106)
@@ -91,6 +91,7 @@
 void AgentManager::run( Ogre::Real elapsedTime ) 
 {
 //	update agents
+	//if the loop below is reactivated, then remove this ...
 	if(mPlayer != NULL)
 	{
 		mPlayer->update(elapsedTime);

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-01 23:47:06 UTC (rev 3106)
@@ -22,6 +22,7 @@
 #include "World.h"
 
 using namespace Ogre;
+using namespace OpenSteer;
 
 template<> rl::AiSubsystem* Singleton<rl::AiSubsystem>::ms_Singleton = 0;
 

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-01 23:47:06 UTC (rev 3106)
@@ -23,6 +23,7 @@
 #include "PhysicsMaterialRaycast.h"
 
 using namespace rl;
+using namespace OpenSteer;
 
 AiWorld::AiWorld(void) : mObstacles()
 {

Modified: rl/trunk/engine/core/include/PhysicsController.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsController.h	2007-03-01 20:12:51 UTC (rev 3105)
+++ rl/trunk/engine/core/include/PhysicsController.h	2007-03-01 23:47:06 UTC (rev 3106)
@@ -6,10 +6,25 @@
 
 namespace rl
 {
+	/** abstract baseclass for PhysicalObject with an external force/torque control.
+	 * Derived objects register with PhysicalManager. Whenever force/torque is
+	 * going to be applied to the an object controlled by a PhysicsController, the
+	 * associated PhysicsControllers OnApplyForceAndTorque gets executed.
+	 * So the applied force/torque can be modified before it is applied to the
+	 * associated PhysicalThing.
+	 */
     class PhysicsController
     {     
     public:
+		/** explicit destructor.
+		 */
         virtual ~PhysicsController() {};
+
+		/* abstract function for applying force and torque to a PhysicalThing object.
+		 * This function is called from the PhysicsManager whenever force/torque is
+		 * to be applied to the associated PhysicalThing object.
+		 * @param thing PhysicalThing to apply force and torque to.
+		 */
         virtual void OnApplyForceAndTorque(PhysicalThing* thing) = 0;
     };
 }



From blakharaz at mail.berlios.de  Fri Mar  2 10:23:53 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 2 Mar 2007 10:23:53 +0100
Subject: [Dsa-hl-svn] r3107 - in rl/trunk/engine/common: include src
Message-ID: <200703020923.l229NrHs025417@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-02 10:23:48 +0100 (Fri, 02 Mar 2007)
New Revision: 3107

Modified:
   rl/trunk/engine/common/include/Makefile.am
   rl/trunk/engine/common/src/Makefile.am
Log:
Removed deleted play list classes from makefiles


Modified: rl/trunk/engine/common/include/Makefile.am
===================================================================
--- rl/trunk/engine/common/include/Makefile.am	2007-03-01 23:47:06 UTC (rev 3106)
+++ rl/trunk/engine/common/include/Makefile.am	2007-03-02 09:23:48 UTC (rev 3107)
@@ -10,13 +10,10 @@
 	FixRubyHeaders.h \
 	GameTask.h \
 	Logger.h \
-	LinkedPlaylist.h \
 	MathUtil.h \
 	OgreXercesInput.h \
 	Playlist.h \
 	SimplePlaylist.h \
-	PlaylistEvent.h \
-	PlaylistObject.h \
         Properties.cpp \
         Property.cpp \
         RastullahPrerequisites.h \

Modified: rl/trunk/engine/common/src/Makefile.am
===================================================================
--- rl/trunk/engine/common/src/Makefile.am	2007-03-01 23:47:06 UTC (rev 3106)
+++ rl/trunk/engine/common/src/Makefile.am	2007-03-02 09:23:48 UTC (rev 3107)
@@ -8,12 +8,8 @@
   EventSource.cpp \
   GameTask.cpp \
   Logger.cpp \
-  LinkedPlaylist.cpp \
   MathUtil.cpp \
   OgreXercesInput.cpp \
-  Playlist.cpp \
-  PlaylistEvent.cpp \
-  PlaylistObject.cpp \
   Properties.cpp \
   Property.cpp \
   PropertyReader.cpp \



From blakharaz at mail.berlios.de  Fri Mar  2 10:27:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 2 Mar 2007 10:27:18 +0100
Subject: [Dsa-hl-svn] r3108 - rl/trunk/engine/common/src
Message-ID: <200703020927.l229RIaY025744@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-02 10:27:15 +0100 (Fri, 02 Mar 2007)
New Revision: 3108

Modified:
   rl/trunk/engine/common/src/Makefile.am
Log:
..and SimplePlaylist too


Modified: rl/trunk/engine/common/src/Makefile.am
===================================================================
--- rl/trunk/engine/common/src/Makefile.am	2007-03-02 09:23:48 UTC (rev 3107)
+++ rl/trunk/engine/common/src/Makefile.am	2007-03-02 09:27:15 UTC (rev 3108)
@@ -14,7 +14,6 @@
   Property.cpp \
   PropertyReader.cpp \
   ScriptWrapper.cpp \
-  SimplePlaylist.cpp \
   XmlErrorHandler.cpp \
   XmlHelper.cpp \
   XmlResource.cpp \



From blakharaz at mail.berlios.de  Fri Mar  2 14:59:39 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 2 Mar 2007 14:59:39 +0100
Subject: [Dsa-hl-svn] r3109 - in rl/trunk/engine: ai/include ai/src
	common/include core/src rules/include rules/src script/swig
	ui/include ui/src
Message-ID: <200703021359.l22Dxdwt016136@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-02 14:59:13 +0100 (Fri, 02 Mar 2007)
New Revision: 3109

Removed:
   rl/trunk/engine/ui/include/CommandExecutor.h
   rl/trunk/engine/ui/src/CommandExecutor.cpp
Modified:
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/common/include/CommonPrerequisites.h
   rl/trunk/engine/common/include/EventCaster.h
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/BoxPrimitive.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/GameAreaEventSource.cpp
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/include/Weapon.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
   rl/trunk/engine/script/swig/TypeRlProperty.swig
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/Makefile.am
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
A small cleanup operation
- removed some #using namespace from header files (causing a lot of 
changes in other files)
- removed unused CommandExecutor class
- removed some unneccessary #include from Creature.h



Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -22,13 +22,10 @@
 #include "OpenSteer/SteerLibrary.h"
 
 
-using namespace Ogre;
-using namespace OpenSteer;
-
 namespace rl
 {
 //	SimpleVehicle_1 adds concrete LocalSpace methods to AbstractVehicle
-	typedef OpenSteer::LocalSpaceMixin<AbstractVehicle> SimpleVehicle_1;
+	typedef OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle> SimpleVehicle_1;
 //	SimpleVehicle_2 adds concrete steering methods to SimpleVehicle_1
 	typedef OpenSteer::SteerLibraryMixin<SimpleVehicle_1> SimpleVehicle_2;
 	
@@ -63,7 +60,7 @@
 		 * @param  elapsedTime The time step value allows wander rate to be consistent when frame times vary
 		 * @return a steering force for wandering behavior. 
 		 */
-		Vector3 calcWander(const float elapsedTime);
+		Ogre::Vector3 calcWander(const float elapsedTime);
 
 		/**
 		 * Causes the vehicle to turn toward a target and move to it. 
@@ -73,23 +70,23 @@
 		 * @param  target target position to seek for
 		 * @return a steering force to seek the given target location. 
 		 */
-		Vector3 calcSeek(const Vector3& target);
+		Ogre::Vector3 calcSeek(const Ogre::Vector3& target);
 
 		/**
 		 * Causes the vehicle to turn away from a target and move away from it.
 		 * @param  target target position to flee for
 		 * @return a steering force to flee from the given target location. 
 		 */
-		Vector3 calcFlee(const Vector3& target);
+		Ogre::Vector3 calcFlee(const Ogre::Vector3& target);
 
-		Vector3 calcPursuit(Agent* agent);
+		Ogre::Vector3 calcPursuit(Agent* agent);
 		/**
 		 * Causes the vehicle to turn away from obstacles in space. 
 		 * The vehicle will consider all close-by obstacles automatically
 		 * @param  minTimeToCollision distance to the obstacle in time at the vehicle's current velocity
 		 * @return a steering force to avoid obstacles. 
 		 */
-		Vector3 calcAvoidObstacles(const float minTimeToCollision);
+		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
 
 		/**
 		 * Causes the vehicle to turn away from neighbor vehicles.
@@ -97,12 +94,12 @@
 		 * @param  minTimeToCollision distance to the neighbour in time at the vehicle's current velocity
 		 * @return a steering force to avoid neighbours. 
 		 */
-		Vector3 calcAvoidNeighbors(const float minTimeToCollision);
+		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
 			
 		/**
 		 * @returns a steering force to maintain a given target speed. 
 		 */
-		Vector3 calcSteerTargetSpeed(const float targetSpeed);
+		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
 
 		bool isAhead(Agent* agent, const float threshold);
 		bool needAvoidance(const float minTimeToCollision);
@@ -123,9 +120,9 @@
 
 		bool isDialogActive();
 
-		float calcDistance(const Vector3& vec1, const Vector3& vec2);
+		float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2);
 
-		Vector3 getPosition();
+		Ogre::Vector3 getPosition();
 
 		// inherited from AbstractVehicle
 
@@ -137,7 +134,7 @@
 		 * predict position of this vehicle at some time in the future
 		 * (assumes velocity remains constant)
 		 */
-		Vec3 predictFuturePosition (const float predictionTime) const;
+		OpenSteer::Vec3 predictFuturePosition (const float predictionTime) const;
 
 		void resetLocalSpace();
 		// get/set mass
@@ -145,7 +142,7 @@
 		float setMass (float m) {return 1;} // don't set mass here TODO: throw exception
 
 		// get velocity of vehicle
-		Vec3 velocity (void) const {return Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
+		OpenSteer::Vec3 velocity (void) const {return OpenSteer::Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
 
 		// get/set speed of vehicle  (may be faster than taking mag of velocity)
 		float speed (void) const {return mSpeed;}
@@ -173,14 +170,14 @@
          * allows a specific vehicle class to redefine this adjustment.
          * default is to disallow backward-facing steering at low speed.
 		 */
-		virtual Vec3 adjustRawSteeringForce (const Vec3& force);
+		virtual OpenSteer::Vec3 adjustRawSteeringForce (const OpenSteer::Vec3& force);
                                             // const float elapsedTime);
 
 		/**
 		 * apply a given steering force to our momentum,
 		 * adjusting our orientation to maintain velocity-alignment.
 		 */
-	//	void applySteeringForce(const Vec3& force, const float elapsedTime);
+	//	void applySteeringForce(const OpenSteer::Vec3& force, const float elapsedTime);
 	//	void applySteeringForce(const Ogre::Vector3& force, const float elapsedTime);
 		
 		
@@ -189,7 +186,7 @@
 		 * the default version: keep FORWARD parallel to velocity, change
          * UP as little as possible.
 		 */
-  /*      virtual void regenerateLocalSpace (const Vec3& newVelocity,
+  /*      virtual void regenerateLocalSpace (const OpenSteer::Vec3& newVelocity,
                                            const float elapsedTime);
 		*/
 		
@@ -201,21 +198,21 @@
 		
 		float resetSmoothedCurvature (float value = 0)
 		{
-			_lastForward = Vec3::zero;
-			_lastPosition = Vec3::zero;
+			_lastForward = OpenSteer::Vec3::zero;
+			_lastPosition = OpenSteer::Vec3::zero;
 			return _smoothedCurvature = _curvature = value;
 		}
 		
-		Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
+		OpenSteer::Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
 		
-		Vec3 resetSmoothedAcceleration (const Vec3& value = Vec3::zero)
+		OpenSteer::Vec3 resetSmoothedAcceleration (const OpenSteer::Vec3& value = OpenSteer::Vec3::zero)
 		{
 			return _smoothedAcceleration = value;
 		}
 		
-		Vec3 smoothedPosition (void) {return _smoothedPosition;}
+		OpenSteer::Vec3 smoothedPosition (void) {return _smoothedPosition;}
 		
-		Vec3 resetSmoothedPosition (const Vec3& value = Vec3::zero)
+		OpenSteer::Vec3 resetSmoothedPosition (const OpenSteer::Vec3& value = OpenSteer::Vec3::zero)
 		{
 			return _smoothedPosition = value;
 		}
@@ -224,7 +221,7 @@
 		// rotate about it by a random angle (pick random forward, derive side).
 		void randomizeHeadingOnXZPlane (void)
 		{
-			setUp (Vec3::up);
+			setUp (OpenSteer::Vec3::up);
 			setForward (RandomUnitVectorOnXZPlane ());
 			setSide (localRotateForwardToSide (forward()));
 		}
@@ -234,8 +231,8 @@
         const Actor* getActor(void) const  { return mActor; }
 	protected:
 		void initialize();
-		AVGroup getNeighbors();
-		ObstacleGroup getObstacles();
+		OpenSteer::AVGroup getNeighbors();
+		OpenSteer::ObstacleGroup getObstacles();
 	//    float _mass;       // mass (defaults to unity so acceleration=force)
     //   float _radius;     // size of bounding sphere, for obstacle avoidance, etc.
     //    float _speed;      // speed along Forward direction.  Because local space

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -24,6 +24,8 @@
 #include "SteeringMachine.h"
 //#include "PerceptionPool.h"
 
+using namespace Ogre;
+using namespace OpenSteer;
 using namespace rl;
 
 Agent::Agent(Creature* character)

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -24,6 +24,7 @@
 
 using namespace rl;
 using namespace OpenSteer;
+using namespace Ogre;
 
 AiWorld::AiWorld(void) : mObstacles()
 {

Modified: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,8 @@
 #include "PhysicalThing.h"
 
 using namespace rl;
+using namespace OpenSteer;
+using namespace Ogre;
 
 PlayerVehicle::PlayerVehicle(Actor* character)
 	: SteeringVehicle(NULL, character)

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -22,6 +22,8 @@
 #include "PhysicalThing.h"
 
 using namespace rl;
+using namespace Ogre;
+using namespace OpenSteer;
 
 SteeringVehicle::SteeringVehicle(Agent* parent, Actor* character)
 	: _maxForce(1.0f),

Modified: rl/trunk/engine/common/include/CommonPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/CommonPrerequisites.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/common/include/CommonPrerequisites.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -33,6 +33,7 @@
 
 #undef _assert
 
+#undef max
 #undef min
 #pragma warning( disable : 4267 ) // Konvertierungswarnung in CEGUIString
 #include <CEGUIString.h>

Modified: rl/trunk/engine/common/include/EventCaster.h
===================================================================
--- rl/trunk/engine/common/include/EventCaster.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/common/include/EventCaster.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -20,8 +20,6 @@
 #include <set>
 #include "EventListener.h"
 
-using namespace std;
-
 namespace rl {
 /**
  * Diese Klasse ist die Basisklasse fuer Objekte, die Ereignisse verschicken.
@@ -34,7 +32,7 @@
 class EventCaster {
 public:
     typedef EventListener<Event> ListenerToEvent;
-    typedef set<ListenerToEvent*> EventSet;
+    typedef std::set<ListenerToEvent*> EventSet;
     typedef typename EventSet::iterator EventSetIterator;
 
     /// Der Konstruktor
@@ -168,7 +166,7 @@
 }
     
 template <typename Event>
-set< EventListener<Event>* > EventCaster<Event>::getEventSet() const
+std::set< EventListener<Event>* > EventCaster<Event>::getEventSet() const
 {
     return mListeners;
 }

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -176,7 +176,7 @@
     }
 }
 
-// @todo - Existenz ?berpr?fen
+// @todo - Existenz berprfen
 void BaseAnimation::addAnimationFrameListener( 
 	AnimationFrameListener *listener, Ogre::Real frameNumber)
 {
@@ -185,7 +185,7 @@
     ScriptWrapper::getSingleton().owned( listener );
 }
 
-// @todo - Existenz ?berpr?fen
+// @todo - Existenz berprfen
 void BaseAnimation::removeAnimationFrameListener( AnimationFrameListener *listener )
 {
     AnimationFrameListenerMap::iterator iter = mAnimationFrameListener.begin();
@@ -252,7 +252,7 @@
     mAnimationCaster.removeEventListeners();
 }
 
-// Zeit hinzuf?gen // wird vom AnimationManager aufgerufen
+// Zeit hinzufgen // wird vom AnimationManager aufgerufen
 void BaseAnimation::addTime( Ogre::Real timePassed )
 {
 	if( !mPaused )
@@ -304,8 +304,8 @@
 
 	Erfolgt in drei Schritten 
 	 * Aktueller Durchlauf
-	 * Wenn ?berlauf, dann wird die Anzahl weiterer Durchl?ufe bestimmt
-	 * F?r den Rest im letzten Durchlauf wird erneut gepr?ft
+	 * Wenn ???erlauf, dann wird die Anzahl weiterer Durchl???fe bestimmt
+	 * Fr den Rest im letzten Durchlauf wird erneut geprft
 */
 void BaseAnimation::checkAnimationFrameListeners( Ogre::Real timePassed )
 {
@@ -329,25 +329,25 @@
 
     Ogre::Real elapsedTime = (mTimePlayed/mLength)*mLength;
 
-	// Vorw?rts laufen
+	// Vorw???ts laufen
 	if( mSpeed > 0 )		
 	{
-        lower = max(elapsedTime, 0.0f);
-		upper = min(elapsedTime, mLength );
+        lower = std::max(elapsedTime, 0.0f);
+		upper = std::min(elapsedTime, mLength );
 	}
-	// Das ganze r?ckw?rts
+	// Das ganze rckw???ts
 	else
 	{
-		// FIXME f?r die erste Runde beim R?ckw?rtsspielen, beginnt leider bei 0, nicht Length
+		// FIXME fr die erste Runde beim Rckw???tsspielen, beginnt leider bei 0, nicht Length
 		Ogre::Real timePos = elapsedTime;
 		if( timePos == 0.0f )
 			timePos = mLength;
 
-		lower = max(timePos-timePassed, 0.0f);
-		upper = min(timePos, mLength );
+		lower = std::max(timePos-timePassed, 0.0f);
+		upper = std::min(timePos, mLength );
 	}
 
-	// Iteratoren f?r die Grenzen holen
+	// Iteratoren fr die Grenzen holen
 	lowerBorder = mAnimationFrameListener.lower_bound(
 		lower);
 	upperBorder = mAnimationFrameListener.upper_bound(
@@ -362,21 +362,21 @@
 
 	// Einmal abspielen abziehen
 	timePassed -= mLength;
-	// Ums Wrapping k?mmern - wenn Looping - und AbspielZeit
+	// Ums Wrapping kmmern - wenn Looping - und AbspielZeit
 	if( timePassed > 0 && isLoop() && 
-		// Falls begrenzte Wiederholungen, m?ssen mindestens 2(1+die oben abgearbeitete) fehlen
+		// Falls begrenzte Wiederholungen, mssen mindestens 2(1+die oben abgearbeitete) fehlen
 		( ( mTimesToPlay > 0 && getTimesToPlayLeft() > 1 ) || ( mTimesToPlay == 0 ) )
 	   )
 	{
-		// Wie oft passt die L?nge in die gesamte fortgeschrittene Zeit		
+		// Wie oft passt die L???ge in die gesamte fortgeschrittene Zeit		
 		unsigned int timesSkipped = floor( timePassed/mLength );
 		Ogre::Real timeLeft = timePassed - timesSkipped*mLength;
 
-		// Falls die Abspielanzahlbegrenzt ist, nicht h?ufiger als verbliebene Anzahl abspielen
+		// Falls die Abspielanzahlbegrenzt ist, nicht h???figer als verbliebene Anzahl abspielen
 		if( mTimesToPlay > 0 && timesSkipped >= getTimesToPlayLeft()-1)
 		{
 			timesSkipped = getTimesToPlayLeft()-1;
-			// Restzeit unwichtig, letzen Abspielvorg?nge waren komplette
+			// Restzeit unwichtig, letzen Abspielvorg???ge waren komplette
 			timeLeft = 0;
 		}
 
@@ -393,7 +393,7 @@
 			}
 		}		
 
-		// F?r letzten Event pr?fen, wenn noch Restzeit vorhanden ist
+		// Fr letzten Event prfen, wenn noch Restzeit vorhanden ist
 		if( timeLeft > 0 )
 		{
 			// Wrapping nach oben

Modified: rl/trunk/engine/core/src/BoxPrimitive.cpp
===================================================================
--- rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,7 @@
 #include "CoreSubsystem.h"
 
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -25,6 +25,8 @@
 
 template<> rl::ConfigurationManager* Ogre::Singleton<rl::ConfigurationManager>::ms_Singleton = 0;
 
+using namespace std;
+
 namespace rl
 {
     ConfigurationManager* ConfigurationManager::getSingletonPtr()
@@ -173,7 +175,7 @@
     {
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        fs::path rastullahCfgDirectory(string(::getenv("HOME")) + "/.rastullah",
+        fs::path rastullahCfgDirectory(Ogre::String(::getenv("HOME")) + "/.rastullah",
             fs::portable_posix_name);
 
         if (!fs::exists(rastullahCfgDirectory))
@@ -300,7 +302,7 @@
         if (mRastullahLogDirectory.empty())
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            mRastullahLogDirectory = string(::getenv("HOME")) + "/.rastullah/logs";
+            mRastullahLogDirectory = Ogre::String(::getenv("HOME")) + "/.rastullah/logs";
 #           else
             mRastullahLogDirectory = "./logs";
 #           endif
@@ -375,7 +377,7 @@
         cfgfile->addSection("Input", mInputSettings);
 
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        cfgfile->save(fs::path("./modules/config/" + mRastullahCfgFile).native_file_string());
+        cfgfile->save(fs::path("./modules/config/" + mRastullahCfgFile).native_file_Ogre::String());
 #       else
         cfgfile->save(Ogre::String(::getenv("HOME")) + "/.rastullah/" + mRastullahCfgFile);
 #       endif
@@ -518,7 +520,7 @@
 #       endif
     }
 
-    void ConfigurationManager::addToCfgPath(const std::string& path)
+    void ConfigurationManager::addToCfgPath(const Ogre::String& path)
     {
         std::cout << "Checking for " << mRastullahCfgFile << " in " << path << std::endl;
 
@@ -538,7 +540,7 @@
         }
     }
 
-    bool ConfigurationManager::checkForFile(const std::string& filename)
+    bool ConfigurationManager::checkForFile(const Ogre::String& filename)
     {
         try {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32

Modified: rl/trunk/engine/core/src/GameAreaEventSource.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,7 +17,7 @@
 #include "GameAreaEventSource.h"
 #include "ScriptWrapper.h"
 
-// F?r Intersection und so :)
+// Fr Intersection und so :)
 #include <algorithm>
 
 namespace rl {
@@ -44,27 +44,27 @@
 		if( !mAreaEventCaster.hasEventListeners() )
 			return;
 
-        // Position ?bertragen
+        // Position bertragen
         mAreaType->setQueryPosition( mActor->getWorldPosition() );       
         ActorMap currInside = mAreaType->performQuery();
         // Der Actor um den herum die Quelle ist, wird vermutlich auch gefunden :)
-        // Also rausl?schen
+        // Also rausl???chen
         currInside.erase( mActor->getName() );
 
         ActorMap enteredMap, leftMap;
         // EinfuegeIteratoren erstellen        
-        insert_iterator<ActorMap> enteredInsert(enteredMap, enteredMap.begin());
-        insert_iterator<ActorMap> leftInsert(leftMap, leftMap.begin());
+        std::insert_iterator<ActorMap> enteredInsert(enteredMap, enteredMap.begin());
+        std::insert_iterator<ActorMap> leftInsert(leftMap, leftMap.begin());
 
         // Alle feststellen die rausgefallen sind
-        set_difference( mInsideAreaList.begin(), mInsideAreaList.end(),
+        std::set_difference( mInsideAreaList.begin(), mInsideAreaList.end(),
                         currInside.begin(), currInside.end(), leftInsert );
         
         // Alle feststellen die neu hinzugekommen sind
-        set_difference( currInside.begin(), currInside.end(),
+        std::set_difference( currInside.begin(), currInside.end(),
             mInsideAreaList.begin(), mInsideAreaList.end(), enteredInsert );
 
-        // Die ?briggebliebenen in mInsideAreaList speichern
+        // Die ???riggebliebenen in mInsideAreaList speichern
         mInsideAreaList = currInside;
 
         // Die Neuen und die Rausgefallenen an die Listener dispatchen
@@ -78,7 +78,7 @@
         Actor* actor;
 
         GameAreaEvent* event = new GameAreaEvent( this, GameAreaEvent::AREA_LEFT );
-        // Erst werden alle Listener f?r jedes verlassende Object einmal benachrichtigt
+        // Erst werden alle Listener fr jedes verlassende Object einmal benachrichtigt
         for( it = leavingActors.begin(); it != leavingActors.end();++it) 
         {
             actor = it->second;
@@ -87,7 +87,7 @@
         }
 
         event->setReason( GameAreaEvent::AREA_ENTERED );
-        // Dann werden alle Listener f?r jedes betretende Object einmal benachrichtigt
+        // Dann werden alle Listener fr jedes betretende Object einmal benachrichtigt
         for( it = enteringActors.begin(); it != enteringActors.end();++it) 
         {
             actor = it->second;

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Container.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -23,9 +23,9 @@
 
 namespace rl
 {
-    typedef set<Item*> ItemSet;
+    typedef std::set<Item*> ItemSet;
 
-    /// Behaelter f?r Items.
+    /// Behaelter fr Items.
     class _RlRulesExport Container : public Item
     {
     public:
@@ -44,9 +44,9 @@
         /// Fassungsvermoegen in Unzen
         void setCapacity(Ogre::Real capacity);
 
-		// Volumen in x (breite) * y (hoehe)
-		void setVolume(unsigned int x, unsigned int y);
-        pair<unsigned int, unsigned int> getVolume() const;
+	// Volumen in x (breite) * y (hoehe)
+	void setVolume(unsigned int x, unsigned int y);
+        std::pair<unsigned int, unsigned int> getVolume() const;
 
         /// ist dieser Gegenstand ein Container
         virtual bool isContainer() const;
@@ -60,7 +60,7 @@
 
         ItemSet getItems() const;
 
-		int getItemCount() const;
+	int getItemCount() const;
 
         bool isFree(unsigned int x, unsigned int y) const;
         Item* getItemAt(unsigned int x, unsigned int y) const;
@@ -74,11 +74,11 @@
 
     private:
         Ogre::Real mCapacity;
-		pair<unsigned int,unsigned int> mVolume;
+	std::pair<unsigned int,unsigned int> mVolume;
 		
 		// Speichert, wo die Items sich im Container befinden.
 		// Speichert also die IDs der Objekte in die einzelnen Volumenfelder
-		int objIDMap [1][1];
+	int objIDMap [1][1];
 
         ItemSet mItems;
 

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -20,9 +20,6 @@
 
 #include "GameObject.h"
 #include "Eigenschaft.h"
-#include "Inventory.h"
-#include "Container.h"
-#include "Weapon.h"
 #include "EigenschaftenStateSet.h"
 #include "TalentStateSet.h"
 #include "ZauberStateSet.h"
@@ -31,12 +28,13 @@
 
 //#include "CompositeEffect.h"
 
-using namespace std;
-
 namespace rl
 {
-	class Effect;
+    class Container;
+    class Effect;
+    class Inventory;
     class Item;
+    class Weapon;
 
 ///////////////////////////////////////////////////////////////////////////////
 // Konstanten
@@ -109,7 +107,7 @@
 		 *  Liste der Talente. Besteht aus den Namen der Talente (z.B. Athletik)
          *  als Schluessel und ihrem Wert.
 		 **/
-		typedef map<const CeGuiString, TalentStateSet*> TalentMap;
+		typedef std::map<const CeGuiString, TalentStateSet*> TalentMap;
 
         static const Ogre::String CLASS_NAME;
 
@@ -272,7 +270,7 @@
          **/
         int getAp();
         /**
-         *  Ver?ndert die verbrauchten @ref abbdea "AP", wird beim Steigern
+         *  Ver???dert die verbrauchten @ref abbdea "AP", wird beim Steigern
          *  aufgerufen.
          *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
          **/
@@ -402,16 +400,16 @@
 		 *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
          *  @ingroup CreatureRubyExports
 		 **/
-		void addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value = make_pair(0,0));
+		void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int,int>& value = std::make_pair(0,0));
 		/** 
          *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
          *  bestimmten Kampftechnik zurueck.
 		 *  @param kampftechnikName Beszeichnet die Kampftechnik.
-		 *  @return Ein pair<AT, PA>.
+		 *  @return Ein std::pair<AT, PA>.
 		 *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
 		 *   \c mKampftechniken gefunden werden.
 		 **/
-        virtual pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
+        virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
 		/** 
          *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
          *  Kampftechnik.
@@ -420,7 +418,7 @@
 		 *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
 		 *    konnte nicht in \c mKampftechniken gefunden werden.
 		 **/
-        virtual void setKampftechnik(const CeGuiString kampftechnikName, const pair<int, int>& value);
+        virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Vorteile
@@ -844,13 +842,13 @@
          *  Liste der Werte.
          *  @see Wert
          **/
-		typedef map<const Wert, StateSet*> WertMap;
+		typedef std::map<const Wert, StateSet*> WertMap;
 		/** 
          *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
          *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
          *  und einem Zeiger auf ihr StateSet.
 		 **/
-		typedef map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
+		typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
 		/**
 		 *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
 		 *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
@@ -860,22 +858,22 @@
 		 *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
 		 *  Kampftalent entsprechen.
 		 **/
-        typedef map<const CeGuiString, pair<int, int> > KampftechnikMap;
+        typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
         /**
          *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
          *  den Vorteilen, verhalten sich aber wie Talente.
          **/
-        typedef map<const CeGuiString, TalentStateSet*> VorteilMap;
+        typedef std::map<const CeGuiString, TalentStateSet*> VorteilMap;
         /**
          *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
          *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
          **/
-        typedef map<const CeGuiString, EigenschaftenStateSet*> NachteilMap;
+        typedef std::map<const CeGuiString, EigenschaftenStateSet*> NachteilMap;
 		/** 
          *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
          *  Sonderfertigkeit als Schluessel und ihrem Status.
 		 */
-		typedef map<const CeGuiString ,SonderfertigkeitenStateSet*> SonderfertigkeitMap;
+		typedef std::map<const CeGuiString ,SonderfertigkeitenStateSet*> SonderfertigkeitMap;
 
         struct Ap
         {

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -50,7 +50,7 @@
 	/**
 	* Liefert alle Items im Inventar inm einer Liste
 	* Wichtig:
-	* NUR die erste Hierarchieebene der Items wird zur?ckgegeben
+	* NUR die erste Hierarchieebene der Items wird zurckgegeben
 	* Was in den Items drinnen ist, ist vernachlaessigt
 	*/
 	ItemList getAllItems();
@@ -64,10 +64,10 @@
 	/**
 	 * @return Die errechnete Behinderung
 	 **/
-	pair<int,int> getOverallBe();
+	std::pair<int,int> getOverallBe();
 
 	/**
-	* @return die gesamte R?stung des Chars
+	* @return die gesamte Rstung des Chars
 	*/
 	int getOverallRs();
 
@@ -94,12 +94,12 @@
 	Creature* mOwner;
 
 	/**
-	* Setzt Flag, dass die Werte neu berechnet werden m?ssen
+	* Setzt Flag, dass die Werte neu berechnet werden mssen
 	*/
 	void markDirty();
 
 	/**
-	* Update der Werte f?r Gewicht, Rs und Behinderung
+	* Update der Werte fr Gewicht, Rs und Behinderung
 	*/
 	void updateStats();
 

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Item.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -23,8 +23,8 @@
 {
 	class _RlRulesExport Item;
 
-	typedef vector<Item*> ContainerColumn;
-	typedef vector<ContainerColumn> ContainerLayout;
+	typedef std::vector<Item*> ContainerColumn;
+	typedef std::vector<ContainerColumn> ContainerLayout;
 
 
     /// Aufnehmbare Objekte in der Spielwelt.
@@ -79,7 +79,7 @@
 
 		/**
 		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden k?nnen
+		 * in dem andere gespeichert werden k???nen
 		 */
         virtual bool isContainer() const;
 		
@@ -107,9 +107,9 @@
 
 
 		/**
-		* Generiert einen Text mit Zeilenumbr?chen, aus dem String.
+		* Generiert einen Text mit Zeilenumbrchen, aus dem String.
 		* @param unformattedText Der zu formatierende Text
-		* @return CeGuiString der Text mit eingef?gten Enter-symbolen
+		* @return CeGuiString der Text mit eingefgten Enter-symbolen
 		*/
 		static CeGuiString getFormattedText(const CeGuiString &unformattedText);
     };

Modified: rl/trunk/engine/rules/include/Weapon.h
===================================================================
--- rl/trunk/engine/rules/include/Weapon.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Weapon.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -44,13 +44,13 @@
 		void setTp(int d6, int d20, int mod);
 		const Tripel<int>& getTp() const;
 		void setTpKk(int base, int step);
-		const pair<int, int>& getTpKk() const;
+		const std::pair<int, int>& getTpKk() const;
 		void setBf(int newBf);
 		int getBf();
 		void setIni(int newIni);
 		int getIni();
-		void setWm(pair<int, int>& newWm);
-		const pair<int,int>& getWm() const;
+		void setWm(std::pair<int, int>& newWm);
+		const std::pair<int,int>& getWm() const;
 		void setDk(Distanzklasse newDk);
 		Distanzklasse getDk();
 		void setKampftechnik(const CeGuiString newKampftechnik);
@@ -62,10 +62,10 @@
 
 	private:
 		Tripel<int> mTp;
-		pair<int, int> mTpKk;
+		std::pair<int, int> mTpKk;
 		int mBf;
 		int mIni;
-		pair<int, int> mWm;
+		std::pair<int, int> mWm;
 		Distanzklasse mDk;
 		CeGuiString mKampftechnik;
 	};

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,17 +16,23 @@
 #include "Creature.h"
 
 #include "Actor.h"
+#include "Container.h"
 #include "DsaManager.h"
 #include "Eigenschaft.h"
 #include "Exception.h"
+#include "Inventory.h"
 #include "Kampftechnik.h"
 #include "MeshObject.h"
 #include "StateSet.h"
 #include "Talent.h"
-#include "Inventory.h"
+#include "Weapon.h"
+
+///@todo Just for debugging, remove when not needed anymore
 #include "CoreSubsystem.h"
 #include "RubyInterpreter.h"
 
+using namespace std;
+
 namespace rl
 {
     const Ogre::String Creature::CLASS_NAME = "Creature";
@@ -36,7 +42,7 @@
 		mCurrentLe(0),
         mCurrentAu(0),
         mCurrentAe(0),
-		mActiveWeapon(NULL),
+	mActiveWeapon(NULL),
 		mInventory(NULL),
 		mEigenschaften(),
 		mWerte(),

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -136,7 +136,7 @@
         return t;
     }
 
-	int XdimlLoader::getEBeFromString(const string& eBeString)
+	int XdimlLoader::getEBeFromString(const Ogre::String& eBeString)
 	{
 		if (eBeString.length() == 0)
 			return EBE_KEINE_BE;
@@ -144,7 +144,7 @@
 		if (!(eBeString.substr(0, 2).compare("BE")) == 0)
 			Throw(IllegalArgumentException, "Ungueltige EBE-Angabe.");
 
-		string ebe = eBeString.substr(2);
+		Ogre::String ebe = eBeString.substr(2);
 		if (ebe.compare("x2") == 0)
 			return EBE_BEx2;
 		if (ebe.compare("") == 0)
@@ -234,7 +234,7 @@
 		DOMNodeList* eigensch = 
 			XmlHelper::getChildNamed(personXml, "Eigenschaften")->
 				getElementsByTagName(EIGENSCHAFT.data());
-		// Die Eigenschaftsnamen m?ssen durch ihre Abk?rzung ersetzt werden.
+		// Die Eigenschaftsnamen mssen durch ihre Abkrzung ersetzt werden.
 		for (unsigned int idx = 0; idx < eigensch->getLength(); idx++)
 		{
 			DOMElement* eigenschXml = static_cast<DOMElement*>(eigensch->item(idx));

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,6 +17,7 @@
 
 #include "Armor.h"
 #include "CoreSubsystem.h"
+#include "Container.h"
 #include "Creature.h"
 #include "Exception.h"
 #include "GameObject.h"

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,8 @@
 #include "Exception.h"
 #include "ScriptWrapper.h"
 
+using namespace std;
+
 namespace rl {
 
 QuestBook::QuestBook()

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-02 13:59:13 UTC (rev 3109)
@@ -89,14 +89,14 @@
 // Error Handling for Ruby
 void RL_handleRubyError( VALUE error )
 {
-	stringstream stream;	
+	std::stringstream stream;	
 	// get error class
     VALUE klass = rb_class_path(CLASS_OF(error));
     stream << RSTRING(klass)->ptr << " ("; 
 
     // get error message
     VALUE message = rb_obj_as_string(error);
-    stream << RSTRING(message)->ptr << ") " << endl;
+    stream << RSTRING(message)->ptr << ") " << std::endl;
 
     // get backtrace
     if(!NIL_P(ruby_errinfo)) 
@@ -207,7 +207,7 @@
 		$result = val;
 } 
 
-// Animation* getActor oder andere OUTPUT Parameter f?r DYNAMICs
+// Animation* getActor oder andere OUTPUT Parameter fr DYNAMICs
 %typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
 {
 	VALUE val = SWIG_RubyInstanceFor( $1 );
@@ -215,7 +215,7 @@
 	// Es gab das SkriptObjekt noch nicht
 	if (NIL_P(val))
 	{
-		// Dynamic Cast ausf?hren
+		// Dynamic Cast ausfhren
 		swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &$1);
 		$result = SWIG_NewPointerObj((void *) $1, ty, 0);		
 	}
@@ -223,7 +223,7 @@
 		$result = val;
 } 
 
-// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter f?r DYNAMICs
+// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
 %typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
 {
 	// Auf Director testen
@@ -238,7 +238,7 @@
 		
 		// Es gab das SkriptObjekt noch nicht
 		if (NIL_P(val)) {
-			// Dynamic Cast ausf?hren
+			// Dynamic Cast ausfhren
 			swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &$1);
 			$input = SWIG_NewPointerObj((void *) $1, ty, 0);		
 		}

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -430,13 +430,13 @@
 		void setTp(int d6, int d20, int mod);
 		const Tripel<int>& getTp() const;
 		void setTpKk(int base, int step);
-		const pair<int, int>& getTpKk() const;
+		const std::pair<int, int>& getTpKk() const;
 		void setBf(int newBf);
 		int getBf();
 		void setIni(int newIni);
 		int getIni();
-		void setWm(pair<int, int>& newWm);
-		const pair<int,int>& getWm() const;
+		void setWm(std::pair<int, int>& newWm);
+		const std::pair<int,int>& getWm() const;
 		void setDk(Weapon::Distanzklasse newDk);
 		Weapon::Distanzklasse getDk();
 		void setKampftechnik(const rl::CeGuiString newKampftechnik);

Modified: rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,7 +16,7 @@
 
 /* Typemaps fuer Quaternion.
  * Ein Quaternion wird auf ein Array aus einem 3-elementigen Array 
- * f?r die Rotationsachse und einem Wert f?r den Winkel abgebildet
+ * fr die Rotationsachse und einem Wert fr den Winkel abgebildet
  * 
  */
 
@@ -82,7 +82,7 @@
    }
    else if (RARRAY($input)->len == 3)
    {
-	   Quaternion rotX, rotY, rotZ;
+	   Ogre::Quaternion rotX, rotY, rotZ;
         rotX.FromAngleAxis(
 			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
 			Ogre::Vector3::UNIT_X);
@@ -124,7 +124,7 @@
    }
    else if (RARRAY($input)->len == 3)
    {
-	   Quaternion rotX, rotY, rotZ;
+	   Ogre::Quaternion rotX, rotY, rotZ;
         rotX.FromAngleAxis(
 			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
 			Ogre::Vector3::UNIT_X);
@@ -155,8 +155,8 @@
 
 
 %typemap(out) Ogre::Quaternion, const Ogre::Quaternion {
-   Degree angle;
-   Vector3 axis;
+   Ogre::Degree angle;
+   Ogre::Vector3 axis;
    
    $1.ToAngleAxis(angle, axis);
    
@@ -172,8 +172,8 @@
 }
 
 %typemap(out) Ogre::Quaternion*, const Ogre::Quaternion*, const Ogre::Quaternion&, Ogre::Quaternion& {
-   Degree angle;
-   Vector3 axis;
+   Ogre::Degree angle;
+   Ogre::Vector3 axis;
    
    $1->ToAngleAxis(angle, axis);
    

Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,9 +17,9 @@
 %{
 namespace rl {
 
-Property convertValueToProperty(VALUE input)
+rl::Property convertValueToProperty(VALUE input)
 {
-	Property rval;
+	rl::Property rval;
 	if (TYPE(input) == T_FLOAT)
     {
 	    rval.setValue(Ogre::Real(NUM2DBL(input)));
@@ -71,7 +71,7 @@
 			}
 			else // Array of Properties
 			{
-				std::vector<Property> vec;
+				std::vector<rl::Property> vec;
 				for (int idx = 0; idx < length; idx++)
 				{
 					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, 0)));
@@ -84,7 +84,7 @@
     return rval;
 }
 
-VALUE convertPropertyToValue(Property input)
+VALUE convertPropertyToValue(rl::Property input)
 {
 	if (input.isString())
     {
@@ -131,9 +131,9 @@
     }
     else if (input.isArray())
     {
-		std::vector<Property> vec = input.toArray();
+		std::vector<rl::Property> vec = input.toArray();
 		VALUE rval = rb_ary_new();
-		for (std::vector<Property>::const_iterator it = vec.begin();
+		for (std::vector<rl::Property>::const_iterator it = vec.begin();
 			it != vec.end(); it++)
 		{
 			rb_ary_push(rval, rl::convertPropertyToValue(*it));

Deleted: rl/trunk/engine/ui/include/CommandExecutor.h
===================================================================
--- rl/trunk/engine/ui/include/CommandExecutor.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/CommandExecutor.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -1,27 +0,0 @@
-#ifndef __CommandExecutor_h__
-#define __CommandExecutor_h__
-
-#include "UiPrerequisites.h"
-#include <vector>
-
-namespace rl {
-
-	/**
-	* Diese Klasse enth?lt die ausf?hrbaren Spieleraktionen, welche mit einer Taste verbunden werden
-	* k?nnen
-	* 
-	* pure virtual - von dieser Klasse muss in Ruby geerbt werden, hier ist nur das Interface definiert
-	*/
-	class _RlUiExport CommandExecutor
-	{
-	public:
-		virtual ~CommandExecutor();
-
-		virtual CeGuiStringVector getCommandsInBattle();
-		virtual CeGuiStringVector getCommandsOffBattle();
-		virtual void executeCommand(CeGuiString command);
-	};
-
-}
-
-#endif

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -41,9 +41,9 @@
 
 		void getResponse(const CeGuiString& msg);
 		unsigned int count();
-		void setCallback(std::string function);
-		void setName(std::string name);
-		void setImage(std::string imageset, std::string image);
+		void setCallback(Ogre::String function);
+		void setName(Ogre::String name);
+		void setImage(Ogre::String imageset, Ogre::String image);
 		int getSelectedOption();
 
 		void textFinished();

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -44,7 +44,7 @@
 		InventoryWindow();
 		~InventoryWindow();
 
-		// Flag f?r den ArrangeTask - FIXME nach private umziehen, wenn 
+		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
 		CEGUI::DragContainer* mDroppedItem;
 
 		/**
@@ -53,17 +53,17 @@
 		void setInventory(Inventory* inventory);
 
 		/**
-		* Methode f?r das OnMouseOver Event
+		* Methode fr das OnMouseOver Event
 		*/
 		bool handleMouseEnters(const CEGUI::EventArgs &args);
 		
 		/**
-		* Methode f?r das OnMouseLeaves Event
+		* Methode fr das OnMouseLeaves Event
 		*/
 		bool handleMouseLeaves(const CEGUI::EventArgs &args);
 
 		/**
-		* Methode f?r das OnMouseClick Event
+		* Methode fr das OnMouseClick Event
 		*/
 		bool handleMouseClicked(const CEGUI::EventArgs &args);
 
@@ -73,13 +73,13 @@
 		void update();
 
 		/**
-		* ?bergibt ?nderungen ans Inventar
+		* ???ergibt ???derungen ans Inventar
 		*/
 		void updateInventory();
 
 		/**
 		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
-		* daf?r ne externe Methode
+		* dafr ne externe Methode
 		*/
 		void updateItemPosition();
 
@@ -88,7 +88,7 @@
 		/**
 		* Schaut nach, ob das Item an der Position gedroppt werden kann.
 		*/
-		bool isFreeInContainer(Item* item, pair<int,int> kaestechenPos, Container* container);
+		bool isFreeInContainer(Item* item, std::pair<int,int> kaestechenPos, Container* container);
 
 
 		Item* getGroundItem();
@@ -96,7 +96,7 @@
 	private:
 		Inventory* mInventory;
 
-		// Farbschema f?r die Fenster und Itemhintergr?nde
+		// Farbschema fr die Fenster und Itemhintergrnde
 		const CeGuiString mColorAccept;
 		const CeGuiString mColorReject;
 		const CeGuiString mColorNormal;
@@ -110,7 +110,7 @@
 		Ogre::SceneNode* mInventoryItemNode;
 		// Entity des jeweils zu rendernden Items
 		Ogre::Entity* mRenderItemEntity;
-		// 128*128 Textur f?r das Item-view Fenster
+		// 128*128 Textur fr das Item-view Fenster
 		Ogre::RenderTexture* mRenderTexture;
 		// Viewport des RenderToTexture Features
 		Ogre::Viewport* mRenderViewport;
@@ -126,7 +126,7 @@
 		CEGUI::Window* mItemRenderImage;
 
 
-		// Das R?stungs- und Behinderungswert Fenster
+		// Das Rstungs- und Behinderungswert Fenster
 		CEGUI::Window* mArmorValueWindow;
 		CEGUI::Window* mArmorValue;
 		CEGUI::Window* mHandicapValue;
@@ -139,7 +139,7 @@
 		// Das Item-Beschreibungsfenster
 		CEGUI::ScrollablePane* mDescription;
 
-		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew?hlt ist
+		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew???lt ist
 		CEGUI::Window* mActiveItemWindow;
 
 		// Das Fenster, in das der Rucksackcontainer soll
@@ -188,7 +188,7 @@
 		void initRenderToTexture();
 
 		/**
-		* L?dt die Rtt-Camera
+		* L???t die Rtt-Camera
 		*/
 		void loadCamera();
 		void unloadCamera();
@@ -204,12 +204,12 @@
 		void initSlots();
 
 		/**
-		* F?llt die Slots im InventarFenster mit den Items aus dem Inventar
+		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
 		*/
 		void fillSlots();
 
 		/**
-		* Erzeugt ein Tab f?r den Container, und befuellt ihn nach Inhalt des container - Items
+		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
 		*/
 		void createAndFillContainer(Container* container);
 
@@ -227,7 +227,7 @@
 		void refreshTabs();
 
 		/**
-		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh?rt
+		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh???t
 		*/
 		CEGUI::Window* findContainer(Container* container);
 
@@ -237,25 +237,25 @@
 		*/
 		void emptySlot(CEGUI::Window* slot);
 		/** 
-		* Gibt dem Slot die F?higkeit Dragcontainer zu akzeptieren
+		* Gibt dem Slot die F???igkeit Dragcontainer zu akzeptieren
 		*/
 		void addDropListener(CEGUI::Window* slot);
 
 		/*!
-		* f?gt dem Inventar den Container f?r den Rucksack zu,
-		* gibt ihm die n?tige Funktionalit?t f?r drag&drop
+		* fgt dem Inventar den Container fr den Rucksack zu,
+		* gibt ihm die n???ige Funktionalit??? fr drag&drop
 		*/
 		void initBackpack(std::pair<int,int> dim);
 
 
 		/**
-		* erzeugt f?r alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
+		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
 		* im Inventar
 		*/
 		void createContainerWindows();
 
 		/**
-		* ?berpr?ft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
+		* ???erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
 		* @return true: Item wird akzeptiert
 		*         false: Item wird nicht akzeptiert
 		*/ 
@@ -263,7 +263,7 @@
 
 
 		/**
-		* Errechnet die K?stchenposition, an der das Item im Container gedroppt wurde
+		* Errechnet die K???tchenposition, an der das Item im Container gedroppt wurde
 		*/
 		std::pair<int,int> calculateNewPosition(const CEGUI::DragDropEventArgs& ddea);
 

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-03-02 13:59:13 UTC (rev 3109)
@@ -6,7 +6,6 @@
 	CharacterSheetWindow.h \
 	CharacterStateWindow.h \
 	CloseConfirmationWindow.h \
-	CommandExecutor.h \
 	CommandMapper.h \
 	CommandMapperWindow.h \
 	ConfigComponent.h \

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -84,7 +84,7 @@
 
 void CharacterSheetWindow::update()
 {
-	    //TODO: Daten updaten
+	///@TODO: Daten updaten
 	updateTalents();
 	/*if (mCharacter->isMagic())
 		updateMagic();*/
@@ -94,8 +94,8 @@
 void CharacterSheetWindow::updateValues()
 {
 	mName->setText("Name: "+mCharacter->getName());
-	mRasse->setText(string("Rasse: "));
-	mProfession->setText(string("Profession: "));
+	mRasse->setText("Rasse: ");
+	mProfession->setText("Profession: ");
 
 	mLE->setText("LeP: "+
 		StringConverter::toString(mCharacter->getLe())+"/"+
@@ -161,18 +161,18 @@
 		mTalentTable->setItem(new ListboxTextItem(probe), 1, talentNum);
 		CeGuiString eBe;
 		if (talent->getEbe() == EBE_KEINE_BE)
-			eBe = (utf8*)"-";
+			eBe = "-";
 		else if (talent->getEbe() == EBE_BEx2)
-			eBe = (utf8*)"BEx2";
+			eBe = "BEx2";
 		else if (talent->getEbe() == 0)
-			eBe = (utf8*)"BE";
+			eBe = "BE";
 		else if (talent->getEbe() > 0)
-			eBe = (utf8*)"BE+" + CeGuiString(StringConverter::toString(talent->getEbe()));
+			eBe = "BE+" + CEGUI::PropertyHelper::intToString(talent->getEbe());
 		else
-			eBe = (utf8*)"BE" + CeGuiString(StringConverter::toString(talent->getEbe()));
+			eBe = "BE" + CEGUI::PropertyHelper::intToString(talent->getEbe());
 
 		mTalentTable->setItem(new ListboxTextItem(eBe), 2, talentNum);
-		mTalentTable->setItem(new ListboxTextItem((utf8*)""), 3, talentNum);
+		mTalentTable->setItem(new ListboxTextItem(""), 3, talentNum);
 
 		talentNum++;
 	}

Deleted: rl/trunk/engine/ui/src/CommandExecutor.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandExecutor.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/CommandExecutor.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -1,24 +0,0 @@
-#include "CommandExecutor.h"
-
-namespace rl {
-
-	CommandExecutor::~CommandExecutor()
-	{
-	}
-
-	CeGuiStringVector CommandExecutor::getCommandsInBattle()
-	{
-		static CeGuiStringVector emptyvec;
-		return emptyvec;
-	}
-	
-	CeGuiStringVector CommandExecutor::getCommandsOffBattle()
-	{
-		static CeGuiStringVector emptyvec;
-		return emptyvec;
-	}
-	
-	void CommandExecutor::executeCommand(CeGuiString command)
-	{
-	}
-}

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -256,7 +256,7 @@
 	return mDialogOptions->getItemCount();
 }
 
-void DialogWindow::setCallback(string function)
+void DialogWindow::setCallback(Ogre::String function)
 {
 	// TO DO: DialogWindow::setCallback(string function)
 }
@@ -314,12 +314,12 @@
 	return true;
 }
 
-void DialogWindow::setImage(string imageset, string image)
+void DialogWindow::setImage(Ogre::String imageset, Ogre::String image)
 {
     mImage->setProperty("Image", "set:" + imageset + " image:" + image);
 }
 
-void DialogWindow::setName(string name)
+void DialogWindow::setName(Ogre::String name)
 {
 	mName->setProperty("Text", name);
 }

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -46,11 +46,12 @@
 #include "WindowFactory.h"
 
 using namespace Ogre;
-
-template<> rl::InputManager* Singleton<rl::InputManager>::ms_Singleton = 0;
 using namespace OIS;
 using CEGUI::System;
+using namespace std;
 
+template<> rl::InputManager* Singleton<rl::InputManager>::ms_Singleton = 0;
+
 namespace rl {
 
     InputManager::InputManager(Ogre::RenderWindow* win) :

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -40,6 +40,7 @@
 
 using namespace CEGUI;
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 
@@ -172,7 +173,7 @@
 	{
 		// Aktualisiere Werte
 
-		// R?stung
+		// Rstung
 		mArmorValue->setText(Ogre::StringConverter::toString(mInventory->getOverallRs()));
 
 		// Behinderung
@@ -180,11 +181,11 @@
 		mHandicapValue->setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
 		if (behinderung.second > 0)
 		{
-			mArmorValueWindow->setTooltipText("R?stung / Behinderung\r\n           / +"+Ogre::StringConverter::toString(behinderung.second)+" ?berladen");
+			mArmorValueWindow->setTooltipText("Rstung / Behinderung\r\n           / +"+Ogre::StringConverter::toString(behinderung.second)+" berladen");
 		} 
 		else
 		{
-			mArmorValueWindow->setTooltipText("R?stung / Behinderung");
+			mArmorValueWindow->setTooltipText("Rstung / Behinderung");
 		}
 
 		// Gewicht in Unzen
@@ -220,7 +221,7 @@
 		// Gegenstand vom Boden entfernen
 		//mInventory->removeItemFromContainer(item, mGroundItem);
 
-		// Welchem Item wird das Item hinzugef?gt? -> speichere das in die Variable container
+		// Welchem Item wird das Item hinzugefgt? -> speichere das in die Variable container
 		Item* container = static_cast<Item*>(mContainerDraggedTo->getUserData());
 
 		// Extra Behandlung, falls Item auf den Boden gelegt wird
@@ -232,7 +233,7 @@
 			//	(int)(mPosDraggedTo.d_y/30),
 			//	container);
 
-			// Zus?tzlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
+			// Zus???zlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
 			if (item->isContainer())
 			{
 				removeContainerAndContent(dynamic_cast<Container*>(item));
@@ -259,7 +260,7 @@
 
 		if (item->isContainer())
 		{
-			// ContainerTab hinzuf?gen, wenn nicht schon vorhanden
+			// ContainerTab hinzufgen, wenn nicht schon vorhanden
 			createAndFillContainer(dynamic_cast<Container*>(item));
 			refreshTabs();
 
@@ -267,10 +268,10 @@
 		
 
 		bool itemSwitched = false;
-		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zur?ck in den Rucksack setzen
+		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
 		//if (mContainerDraggedTo == mArmor){
 		//	if (mInventory->getArmor() != NULL){
-		//		//Pack die alte R?stung ins Inventar
+		//		//Pack die alte Rstung ins Inventar
 		//		mInventory->addItemToContainer(mInventory->removeArmor(), mInventory->getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -278,7 +279,7 @@
 		//}
 		//if (mContainerDraggedTo == mCape){
 		//	if (mInventory->getCape() != NULL){
-		//		//Pack die alte R?stung ins Inventar
+		//		//Pack die alte Rstung ins Inventar
 		//		mInventory->addItemToContainer(mInventory->removeCape(), mInventory->getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -294,7 +295,7 @@
 		//}
 		//if (mContainerDraggedTo == mBelt) {
 		//	if (mInventory->getBelt() != NULL){
-		//		//Pack den alten G?rtel ins Inventar
+		//		//Pack den alten Grtel ins Inventar
 		//		mInventory->addItemToContainer(mInventory->removeBelt(), mInventory->getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -412,7 +413,7 @@
 
 				//// Container Fenster suchen
 				//CEGUI::Window* win = findContainer(posInContainer.second);
-				//// Dem Fenster hinzuf?gen
+				//// Dem Fenster hinzufgen
 				//win->addChildWindow(mOldItemInSlot);
 				//// Positionieren		
 				//mOldItemInSlot->setPosition( CEGUI::Absolute,
@@ -426,7 +427,7 @@
 		}
 
 
-		// Update am Inventar durchgef?hrt, jetzt sollen noch die Werte aktualisiert werden
+		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
 		update();
 	}
 
@@ -441,7 +442,7 @@
 			mContainerTabs->removeTab(mContainerTabs->getTabContents(0)->getName());
 		}
 
-		// f?ge sie in richtiger Reihenfolge wieder hinzu
+		// fge sie in richtiger Reihenfolge wieder hinzu
 		while (it != mContainers.end())
 		{
 			mContainerTabs->addTab(*it++);
@@ -465,8 +466,8 @@
 	{
 		mArmorValueWindow = getWindow("InventoryWindow/ArmorValueWindow");
         mArmorValueWindow->setProperty("Image", "set:InventorySymbols image:Shield");
-		mArmorValueWindow->setTooltipText("R?stung / Behinderung");
-		//TODO: An Tooltip anh?ngen: woraus setzt sich die R?stung zusammen?
+		mArmorValueWindow->setTooltipText("Rstung / Behinderung");
+		//TODO: An Tooltip anh???gen: woraus setzt sich die Rstung zusammen?
 		mArmorValue = getWindow("InventoryWindow/ArmorValue");
 		mArmorValue->setText(" 3");
 		//mArmorValue->setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
@@ -482,7 +483,7 @@
 
 		mTotalWeight = getWindow("InventoryWindow/TotalWeight");
 		mTotalWeight->setText("");
-		// Schwarzer Text (wird rot, wenn ?berladen)
+		// Schwarzer Text (wird rot, wenn berladen)
 		//mTotalWeight->setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
 		mTotalWeight->disable();
 				
@@ -491,7 +492,7 @@
 		mDescription = getScrollablePane("InventoryWindow/Description");
 
 		// Das "BodenItem" initiieren
-		mGroundItem = new Item(1/*"Boden", "Dieses Item repr?sentiert den Boden"*/);
+		mGroundItem = new Item(1/*"Boden", "Dieses Item repr???entiert den Boden"*/);
 		mGroundItem->setImageName("Trank");
 		mGroundItem->setItemType(Item::ITEMTYPE_OTHER);
 		mGroundItem->setSize(1,1);
@@ -552,7 +553,7 @@
 		mBoots = getWindow("InventoryWindow/Boots");
 		mBoots->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
 
-		// gib ihnen die Funktionalit?t Items aufzunehmen
+		// gib ihnen die Funktionalit??? Items aufzunehmen
 		addDropListener(mHelmet);
 		addDropListener(mRingLeft);
 		addDropListener(mRingRight);
@@ -593,7 +594,7 @@
 		//createItem(mInventory->getBoots(), mBoots);
 
 
-		// Fenster f?r ContainerItems erstellen
+		// Fenster fr ContainerItems erstellen
 		createContainerWindows();
 	}
 
@@ -609,7 +610,7 @@
 			Item* currentItem = *itemIterator++;
 
 			if (currentItem->isContainer()){
-				// Tab f?r Item erzeugen, da es als Container funktioniert
+				// Tab fr Item erzeugen, da es als Container funktioniert
 				createAndFillContainer(dynamic_cast<Container*>(currentItem));
 			}
 		}
@@ -622,7 +623,7 @@
 
 		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
 		bool found = false;
-		// ?berpr?fe, ob schon vorhanden
+		// berprfe, ob schon vorhanden
 		while (it != mContainerContents.end())
 		{
 			if (container == static_cast<Item*>((*it)->getUserData()))
@@ -637,9 +638,9 @@
 		if (!found)
 		{
 
-			// Erzeuge Tab im Inventar f?r den Container
+			// Erzeuge Tab im Inventar fr den Container
 			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow("DefaultGUISheet", "InventoryWindow/Tabs/"+container->getName());
-			// Name f?r das Tab
+			// Name fr das Tab
 			containerWindow->setText(container->getName());
 
 
@@ -655,8 +656,8 @@
 			containerWindow->addChildWindow(containerSpace);
 
 
-			// Inhalt in die Liste Einf?gen
-						// Boden an das Ende der Liste einf?gen
+			// Inhalt in die Liste Einfgen
+						// Boden an das Ende der Liste einfgen
 			if (container == mGroundItem)
 			{
 				mContainers.push_back(containerWindow);
@@ -762,7 +763,7 @@
 		emptySlot(mShinbone);
 		emptySlot(mBoots);
 
-		// Zus?tzlich alle Container durchgehen und entleeren
+		// Zus???zlich alle Container durchgehen und entleeren
 		
 		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
 		
@@ -817,10 +818,10 @@
 
 	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
 	{
-		// Pr?fe, ob ein Item da ist
+		// Prfe, ob ein Item da ist
 		if (item != NULL) {
 
-			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gef?llt werden)
+			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
 			// Waffe:
 			if (parent == mHandRight || parent == mHandLeft) 
 			{
@@ -830,7 +831,7 @@
 			static int itemCnt = 0;
 			itemCnt++;
 
-			// Erzeuge einen Handler f?r Drag and Drop
+			// Erzeuge einen Handler fr Drag and Drop
 			DragContainer* itemhandler = static_cast<DragContainer*>(
 				CEGUI::WindowManager::getSingletonPtr()->createWindow("DragContainer", Ogre::StringConverter::toString(itemCnt) + item->getName()));
 			itemhandler->setPosition(position);
@@ -886,7 +887,7 @@
 
 	bool InventoryWindow::handleMouseClicked(const EventArgs &args) 
 	{
-		// Hole das ausgew?hlte Item
+		// Hole das ausgew???lte Item
 		const CEGUI::MouseEventArgs& mea = static_cast<const MouseEventArgs&>(args);
 
 		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
@@ -903,7 +904,7 @@
 			
 			assert(mea.window->getChildCount() > 0);
 			
-			// aktiviere das angew?hlte Item...
+			// aktiviere das angew???lte Item...
 			mActiveItemWindow = mea.window->getChildAtIdx(0);
 			mActiveItemWindow->setProperty("BackgroundColour", mColorItemSelected);
 			mActiveItemWindow->setProperty("FrameEnabled", "True");
@@ -984,7 +985,7 @@
 		SceneManager* tempManager = CoreSubsystem::getSingleton().
 					getWorld()->getSceneManager();
 
-		// F?r einen Aufh?ngeknoten Sorgen
+		// Fr einen Aufh???geknoten Sorgen
 		if (mInventoryItemNode == NULL){
 			mInventoryItemNode = tempManager->getRootSceneNode()->createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
 			//mInventoryItemNode->setPosition(0,-100,-0.2);
@@ -999,7 +1000,7 @@
 		}
 		if (item->getActor())
 		{
-			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k?nnte
+			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k???nte
 			unloadCamera();
 			loadCamera();
 
@@ -1056,7 +1057,7 @@
 
 	void InventoryWindow::unloadCamera()
 	{
-		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst?rt werden
+		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst???t werden
 		if (mRenderViewport)
 		{
 			mRenderTexture->removeViewport(0);
@@ -1065,7 +1066,7 @@
 	}
 
 	/*!
-	*		?berpr?ft, ob das Item von dem Slot akzeptiert wird
+	*		???erprft, ob das Item von dem Slot akzeptiert wird
 	*/
 	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
 	{
@@ -1084,7 +1085,7 @@
 	*/
 	std::pair<int,int> InventoryWindow::calculateNewPosition(const DragDropEventArgs& ddea)
 	{
-		// Errechnung der Koordinaten, in welchem K?stchen denn nun gedroppt wird
+		// Errechnung der Koordinaten, in welchem K???tchen denn nun gedroppt wird
 		Point absMouse = MouseCursor::getSingleton().getPosition();
         Point scrnPt = ddea.window->getPixelRect().getPosition();
 		Point relMouse = absMouse - ddea.dragDropItem->getPixelRect().getPosition();
@@ -1104,7 +1105,7 @@
 		Point pointInBackpack = absMouse-scrnPt;
 		pointInBackpack -= relMouse;
 
-		// Position des n?chsten K?stchens bestimmen		
+		// Position des n???hsten K???tchens bestimmen		
 		if (pointInBackpack.d_x < 0)
         {
 			pointInBackpack.d_x = 0;
@@ -1143,8 +1144,8 @@
 
 
 	/*!
-	* Behandlung f?r Mouse-over mit Item in der Maus
-	* ?berpr?ft, ob das Item passt, und f?rbt dementsprechend den Beh?lter ein
+	* Behandlung fr Mouse-over mit Item in der Maus
+	* ???erprft, ob das Item passt, und f???bt dementsprechend den Beh???ter ein
 	*/
 	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs& args)
 	{
@@ -1175,8 +1176,8 @@
 				}
 			}
 			else {
-				// Beliebiger anderer Container am K?rper
-				// TODO: Beschr?nkung auf Itemtypen... 
+				// Beliebiger anderer Container am K???per
+				// TODO: Beschr???kung auf Itemtypen... 
 
 				ddea.window->setProperty("ContainerColour", mColorAccept);
 				return true;
@@ -1206,7 +1207,7 @@
 	{
 		// Event zu einem DragDropEvent machen
 		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
-		// Farbe zur?cksetzen
+		// Farbe zurcksetzen
 		ddea.window->setProperty("ContainerColour", mColorNormal);
 
 
@@ -1219,15 +1220,15 @@
 			} 
 			else if (container->getItemType() == Item::ITEMTYPE_BACKPACK)
 			{
-				// Rucksack (nimmt alles au?er dem Rucksack selbst)
+				// Rucksack (nimmt alles au???r dem Rucksack selbst)
 				if (!(ddea.dragDropItem->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
 				{
 					return false;
 				}
 			}
 			else {
-				// Beliebiger anderer Container am K?rper
-				// TODO: Beschr?nkung auf Itemtypen... 
+				// Beliebiger anderer Container am K???per
+				// TODO: Beschr???kung auf Itemtypen... 
 			}
 
 			std::pair<int,int> newPos = calculateNewPosition(ddea);
@@ -1252,9 +1253,9 @@
 
 
 		} else {
-			// Es handelt sich um einen Slot am K?rper
+			// Es handelt sich um einen Slot am K???per
 			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
-				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k?nnen
+				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k???nen
 
 				if (ddea.window->getChildCount() > 0)
 				{
@@ -1277,7 +1278,7 @@
 					Item* item = static_cast<Item*>(ddea.dragDropItem->getUserData());
 					mPosDraggedTo= CEGUI::Point(30-(item->getSize().first * 15),75-(item->getSize().second *15));
 				}
-				// Rest kommt in die linke obere Ecke (weil ausf?llend)
+				// Rest kommt in die linke obere Ecke (weil ausfllend)
 				else {
 					mPosDraggedTo=CEGUI::Point(0.0,0.0);
 				}

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,7 +16,6 @@
 	CharacterSheetWindow.cpp \
 	CharacterStateWindow.cpp \
 	CloseConfirmationWindow.cpp \
-	CommandExecutor.cpp \
 	CommandMapper.cpp \
 	CommandMapperWindow.cpp \
 	ConfigComponent.cpp \

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -121,7 +121,7 @@
             mCharacterActor->getControlledObject());
         AxisAlignedBox aabb = charMesh->getDefaultSize();
 
-        // wird sp?ter neu berechnet in calculateOptimalCameraPosition
+        // wird sp???er neu berechnet in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
         // The actor should be controlled manually,
@@ -262,12 +262,12 @@
 
         if (mCharacterState.mPose == CharacterState::Stand)
         {
-            // Spr?nge werden von updateAnimationStat geregelt
+            // Sprnge werden von updateAnimationStat geregelt
 
-            // R?ckw?rts gehen oder laufen
+            // Rckw???ts gehen oder laufen
             if ( movement & MOVE_BACKWARD && !(movement & MOVE_FORWARD) )
             {
-                if( movement & MOVE_RUN_LOCK ) // R?ckw?rts joggen
+                if( movement & MOVE_RUN_LOCK ) // Rckw???ts joggen
                 {
                     mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 2.0;
                 }
@@ -276,7 +276,7 @@
                     mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 3.6;
                 }
             }
-            else if ( movement & MOVE_FORWARD ) // Vorw?rtsbewegung
+            else if ( movement & MOVE_FORWARD ) // Vorw???tsbewegung
             {
                 if( movement & MOVE_RUN && movement & MOVE_RUN_LOCK ) // sprinten
                 {
@@ -321,8 +321,8 @@
         }
 
 /*
-// soll daf?r sorgen, dass er auf dem
-// Boden bleibt und ?ber kleine Hindernisse kommt
+// soll dafr sorgen, dass er auf dem
+// Boden bleibt und ber kleine Hindernisse kommt
 
 Quaternion orientation = mCharacterActor->getWorldOrientation();
 Vector3 position = mCharacterActor->getWorldPosition();
@@ -352,7 +352,7 @@
 }
 while( dirVector.y > -stepHeight );
 
-// kann das Hindernis ?berwunden werden:
+// kann das Hindernis berwunden werden:
 dirVector = relCollPos;
 while( dirVector.y <= stepHeight )
 {
@@ -461,7 +461,7 @@
         }
         else if( mViewMode == VM_THIRD_PERSON )
         {
-            // Kamera-Gr??e beziehen
+            // Kamera-Gr???e beziehen
             CameraObject* ogreCam = static_cast<CameraObject*>(
                 mCameraActor->getControlledObject());
             AxisAlignedBox aabb = ogreCam->getDefaultSize();
@@ -541,7 +541,7 @@
             getContactPositionAndNormal(point, normal);
 
             // determine if this contact is with the floor.
-            // Meaning the contact normal has an angle to UNIT_Y of 20? or less.
+            // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
             Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
 
             Vector3 charPos;
@@ -575,10 +575,10 @@
             }
 
 
-            // beinflusst die Sprungh?he!
-            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef?hr um
-            // die angegebene Zahl h?her (eher 2*die angegebene Zahl oder so,
-            // vermutlich wieder framedauer abh?ngig!)
+            // beinflusst die Sprungh???e!
+            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef???r um
+            // die angegebene Zahl h???er (eher 2*die angegebene Zahl oder so,
+            // vermutlich wieder framedauer abh???gig!)
             setContactElasticity(0.3f); // was 0.3f
             setContactSoftness(0.01f);
 
@@ -609,7 +609,7 @@
         else
         {
             mCharacterState.mJumpTimer += timestep;
-            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum "Sprung f?hren"
+            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum "Sprung fhren"
             if( !mCharacterState.mHasFloorContact )
                 timeSinceLastFloorContact += timestep;
             else
@@ -654,7 +654,7 @@
                 {
                     mCharacterState.mJumpTimer = 0.0f;
                     mCharacterState.mIsAirBorne = true;
-                    Real height = 0.75f; // beim zweiten gehts seltsamerweise was h?her /doppelsprung physik?)
+                    Real height = 0.75f; // beim zweiten gehts seltsamerweise was h???er /doppelsprung physik?)
                     Real gravity = 9.81f;
                     Real jumpForce = 0.5f*gravity*mass * (Math::Sqrt(1 + 8*height/(gravity * timestep * timestep)) - 1);
                     force += Vector3(0,
@@ -662,7 +662,7 @@
                         0);
                 }
 
-                Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh?ngig von der framerate!
+                Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh???gig von der framerate!
                 force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
             }
             mCharacterState.mStartJump = false;
@@ -715,18 +715,18 @@
         if( playpos.y > maxHeight )
             maxHeight = playpos.y;
         ss
-            << "scene node : " << playpos << endl
+            << "scene node : " << playpos << std::endl
 //            << "player max Height : " << maxHeight << endl
             << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << endl
+                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
 //                << "camera pos : " << static_cast<Camera*>(
-//                    mCameraActor->_getMovableObject())->getPosition() << endl
-            << "camera actor orientation : " << mCameraActor->getWorldOrientation() << endl
-            << "camera actor : " << mCameraActor->getWorldPosition() << endl
-            << "camera body pos : " << bodpos << endl
-            << "is airborne: " << (mCharacterState.mIsAirBorne ? "true" : "false") << endl
-            << "start jump : " << (mCharacterState.mStartJump ? "true" : "false")  << endl
-            << "jump timer : " << mCharacterState.mJumpTimer << endl;
+//                    mCameraActor->_getMovableObject())->getPosition() << std::endl
+            << "camera actor orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
+            << "camera body pos : " << bodpos << std::endl
+            << "is airborne: " << (mCharacterState.mIsAirBorne ? "true" : "false") << std::endl
+            << "start jump : " << (mCharacterState.mStartJump ? "true" : "false")  << std::endl
+            << "jump timer : " << mCharacterState.mJumpTimer << std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
@@ -775,7 +775,7 @@
 
 
 
-        // Kamera-Gr??e beziehen
+        // Kamera-Gr???e beziehen
         CameraObject* ogreCam = static_cast<CameraObject*>(
             mCameraActor->getControlledObject());
         AxisAlignedBox camAabb = ogreCam->getDefaultSize();
@@ -804,9 +804,9 @@
             RaycastInfo infoCastOptPos = mRaycast->execute(
                 world,
                 materialId,
-                camPos + camRadius * normToOptCamPos, // Gr??e der Kamera einbeziehen
+                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr??e der Kamera einbeziehen
+                true); // Gr???e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast->execute(
                 world,
@@ -843,17 +843,17 @@
                     RaycastInfo infoCastNewPos;
                     Real delta = lenToOptCamPos/2.0f;
                     Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann?herung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    // Ann???erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
                     while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
                     {
                         infoCastNewPos = mRaycast->execute(
                             world,
                             materialId,
-                            camPos + camRadius * normToOptCamPos, // Gr??e der Kamera!
+                            camPos + camRadius * normToOptCamPos, // Gr???e der Kamera!
                             temp,
                             true);
                         delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n?her an Char ran
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n???er an Char ran
                         {
                             temp = temp - delta * normToOptCamPos;
                         }
@@ -863,9 +863,9 @@
                         }
                     }
 
-                    // Jetzt k?nnen wir sicher sein, dass diese Stelle erreichbar ist:
+                    // Jetzt k???nen wir sicher sein, dass diese Stelle erreichbar ist:
                     temp = temp - 0.05 * normToOptCamPos;
-                    // Gr??e der Kamera einbeziehen
+                    // Gr???e der Kamera einbeziehen
                     optimalCamPos = temp - camRadius * normToOptCamPos;
                     // so ab hier kann ganz normal weiter gerechnet werden!
                 }
@@ -874,7 +874,7 @@
 
             static bool isPathfinding (false);
             static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten f?r den
+            // gibt an, ob schon gebufferte Daten fr den
             // neuen Weg existieren und dort weitergemacht werden kann,
             // oder ob neu nach einem Weg gesucht werden muss!
             if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
@@ -882,8 +882,8 @@
                 // anderen Weg finden
                 // hier werden erstmal nur alte Player-Positionen betrachtet
                 // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden k?nnen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fl?ssig
+                // und durch "Geraden" miteinander verbunden werden k???nen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
                 // und weich (keine scharfen Kurven) erscheinen
 
                 size_t buffSize = charPositionsBuffer.size();
@@ -924,12 +924,12 @@
                 }
                 else
                 {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergef?hrt werden!");
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
 
 
                     // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
                     unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht ?berpr?ft zu werden, wurde oben schon ausgeschlossen!
+                    while ( delta > 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast->execute(
                             world,
@@ -947,7 +947,7 @@
                     // auf zu der ermittelten Position!
                     optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
                 }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Pr?fung gleicher sachen)
+                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
             }
             else
             {
@@ -1012,7 +1012,7 @@
             }
 
 
-            // Kamera-Gr??e beziehen
+            // Kamera-Gr???e beziehen
             CameraObject* ogreCam = static_cast<CameraObject*>(
                 mCameraActor->getControlledObject());
             AxisAlignedBox aabb = ogreCam->getDefaultSize();
@@ -1033,7 +1033,7 @@
             endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
                                       // dadurch kann aber sichergestellt
                                       // werden, dass kein Objekt direkt
-                                      // hinter dem Helden ?bersehen wird
+                                      // hinter dem Helden bersehen wird
             startRay[1] = charPos + radiusOffset;
             endRay[1] = targetCamPos + radiusOffset;
             radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
@@ -1432,7 +1432,7 @@
 
         if (newAnimation != "")
         {
-            // nur schneller nicht langsamer ausf?hren!
+            // nur schneller nicht langsamer ausfhren!
             if (animSpeed < 1) animSpeed = 1;
 
             if (lastAnimation != newAnimation)
@@ -1449,7 +1449,7 @@
             }
             else
             {
-                if ( lastSpeed != animSpeed ) // Geschwindigkeits?nderung
+                if ( lastSpeed != animSpeed ) // Geschwindigkeits???derung
                 {
                     MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
                     meshAnim->setSpeed(animSpeed);
@@ -1516,7 +1516,7 @@
         Vector3 interpolatedSize;
 
 
-        // Die Gr??e der beiden Animationen abfragen
+        // Die Gr???e der beiden Animationen abfragen
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
         aab = mesh->getPoseSize(actAnim);
         size[0] = aab.getMaximum() - aab.getMinimum();
@@ -1524,7 +1524,7 @@
         aab = mesh->getPoseSize(newAnim);
         size[1] = aab.getMaximum() - aab.getMinimum();
 
-        // interpolierte Gr??e (linear) berechnen
+        // interpolierte Gr???e (linear) berechnen
         interpolatedSize = size[0] + factor*(size[1] - size[0]);
 
         // LookAtOffset berechnen!



From blakharaz at mail.berlios.de  Fri Mar  2 15:55:30 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 2 Mar 2007 15:55:30 +0100
Subject: [Dsa-hl-svn] r3110 - rl/trunk/engine/core/src
Message-ID: <200703021455.l22EtUEi030185@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-02 15:55:26 +0100 (Fri, 02 Mar 2007)
New Revision: 3110

Modified:
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
Log:
Search&Replace artefacts

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 13:59:13 UTC (rev 3109)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 14:55:26 UTC (rev 3110)
@@ -135,7 +135,7 @@
 {
 	// Nicht unsigned :)
 	int left = mTimesToPlay - getTimesPlayed();
-	return max( left ,0);
+    return std::max(left, 0);
 }
 
 void BaseAnimation::setDelay( Ogre::Real delay )

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 14:55:26 UTC (rev 3110)
@@ -377,7 +377,7 @@
         cfgfile->addSection("Input", mInputSettings);
 
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        cfgfile->save(fs::path("./modules/config/" + mRastullahCfgFile).native_file_Ogre::String());
+        cfgfile->save(fs::path("./modules/config/" + mRastullahCfgFile).native_file_string());
 #       else
         cfgfile->save(Ogre::String(::getenv("HOME")) + "/.rastullah/" + mRastullahCfgFile);
 #       endif
@@ -470,19 +470,18 @@
         {
             case CS_GENERAL:
                 addList = &mGeneralSettings;
-            break;
+                break;
             case CS_GRAPHICS:
                 addList = &mGraphicSettings;
-            break;
+                break;
             case CS_SOUND:
                 addList = &mSoundSettings;
-            break;
+                break;
             case CS_INPUT:
                 addList = &mInputSettings;
-            break;
+                break;
             default:
-
-            break;
+                break;
         }
 
         // Find out, if key exist



From zero-gravity at mail.berlios.de  Fri Mar  2 15:57:46 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Fri, 2 Mar 2007 15:57:46 +0100
Subject: [Dsa-hl-svn] r3111 - in rl/trunk: engine/core/src
	engine/script/swig engine/ui/include engine/ui/src
	plugins/fmod4driver/include
Message-ID: <200703021457.l22EvkLr030618@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-02 15:57:36 +0100 (Fri, 02 Mar 2007)
New Revision: 3111

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/FadeAnimation.cpp
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/src/SoundConfig.cpp
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
Log:
Fixed missing namespaces
Corrected search/replace errors
Added some more verbosity to director exceptions

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 14:57:36 UTC (rev 3111)
@@ -233,7 +233,7 @@
                         addSetting(CS_GENERAL, it.peekNextKey(), it.peekNextValue());
                     }
                 }
-                catch (Ogre::Exception& oe)
+                catch (Ogre::Exception&)
                 {
                     // Log it as information
                     LOG_WARNING(Logger::CORE, "Configuration File " + cfg_paths[i] +
@@ -251,7 +251,7 @@
                         addSetting(CS_GRAPHICS, it.peekNextKey(), it.peekNextValue());
                     }
                 }
-                catch (Ogre::Exception& oe)
+                catch (Ogre::Exception&)
                 {
                     // Log it as information
                     LOG_WARNING(Logger::CORE, "Configuration File " + cfg_paths[i] +
@@ -269,7 +269,7 @@
                         addSetting(CS_SOUND, it.peekNextKey(), it.peekNextValue());
                     }
                 }
-                catch (Ogre::Exception& oe)
+                catch (Ogre::Exception&)
                 {
                     // Log it as information
                     LOG_WARNING(Logger::CORE, "Configuration File " + cfg_paths[i] +
@@ -287,7 +287,7 @@
                         addSetting(CS_INPUT, it.peekNextKey(), it.peekNextValue());
                     }
                 }
-                catch (Ogre::Exception& oe)
+                catch (Ogre::Exception&)
                 {
                     // Log it as information
                     LOG_WARNING(Logger::CORE, "Configuration File " + cfg_paths[i] +
@@ -551,7 +551,7 @@
                 return true;
             }
         }
-        catch (fs::filesystem_error& fe) {
+        catch (fs::filesystem_error&) {
             return false;
         }
 

Modified: rl/trunk/engine/core/src/FadeAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/FadeAnimation.cpp	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/engine/core/src/FadeAnimation.cpp	2007-03-02 14:57:36 UTC (rev 3111)
@@ -76,7 +76,7 @@
     else
         anim->setWeight(0.0);
 
-    mLength = max(timeEnd,mLength);
+    mLength = std::max(timeEnd,mLength);
 }
 
 void FadeAnimation::removeAnimation( MeshAnimation* anim )

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-02 14:57:36 UTC (rev 3111)
@@ -92,11 +92,11 @@
 	std::stringstream stream;	
 	// get error class
     VALUE klass = rb_class_path(CLASS_OF(error));
-    stream << RSTRING(klass)->ptr << " ("; 
+    stream << RSTRING(klass)->ptr << " (\""; 
 
     // get error message
     VALUE message = rb_obj_as_string(error);
-    stream << RSTRING(message)->ptr << ") " << std::endl;
+    stream << RSTRING(message)->ptr << "\"), ";
 
     // get backtrace
     if(!NIL_P(ruby_errinfo)) 
@@ -113,9 +113,9 @@
         stream << "]";
     }
     else
-		stream << "Kein Stacktrace vorhanden...";
-        
-    rl::ScriptSubsystem::getSingleton().log( stream.str() );
+		stream << "[ No Callstack found ]";
+     
+    LOG_ERROR(rl::Logger::SCRIPT, stream.str() );
     rl::WindowFactory::getSingleton().writeToConsole( stream.str() );  
 }
 %}

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-02 14:57:36 UTC (rev 3111)
@@ -156,7 +156,7 @@
         void updateCameraLookAt(Ogre::Real elapsedTime);
         void updateAnimationState(int &movement); // this can also modify movement, if needed
 
-void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
+        void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
 
 
         /** Does all camera-stuff, moves the camera to the right position 

Modified: rl/trunk/engine/ui/src/SoundConfig.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundConfig.cpp	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/engine/ui/src/SoundConfig.cpp	2007-03-02 14:57:36 UTC (rev 3111)
@@ -185,7 +185,7 @@
 
     void SoundConfig::setDriverPage(const CeGuiString& drivername)
     {
-        for (list<SoundDriverConfigComponent*>::iterator it = mDriverConfigs.begin();
+        for ( std::list<SoundDriverConfigComponent*>::iterator it = mDriverConfigs.begin();
 				it != mDriverConfigs.end(); it++)
 		{
 			SoundDriverConfigComponent* curr = *it;

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-02 14:55:26 UTC (rev 3110)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-02 14:57:36 UTC (rev 3111)
@@ -31,7 +31,7 @@
 namespace rl
 {
 
-    typedef map<Ogre::String, StringList> DriverMap;
+    typedef std::map<Ogre::String, StringList> DriverMap;
 
     #define CHECK_FMOD4_ERRORS(fmod4_errorcode)\
     {\



From melven at mail.berlios.de  Fri Mar  2 22:22:25 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 2 Mar 2007 22:22:25 +0100
Subject: [Dsa-hl-svn] r3112 - rl/trunk/engine/core/src
Message-ID: <200703022122.l22LMP9s016518@sheep.berlios.de>

Author: melven
Date: 2007-03-02 22:22:14 +0100 (Fri, 02 Mar 2007)
New Revision: 3112

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
run-key "Feststelltaste" in config, this should be changed later, comments in PhysicsManager::run

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 14:57:36 UTC (rev 3111)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 21:22:14 UTC (rev 3112)
@@ -92,7 +92,7 @@
         mInputSettings.insert(make_pair("mov_jump", "Leertaste"));
         mInputSettings.insert(make_pair("mov_run", "Umschalt links"));
         mInputSettings.insert(make_pair("mov_sneak", "Strg links"));
-        //mInputSettings.insert(make_pair("act_run_lock", "<,|,>"));
+        mInputSettings.insert(make_pair("mov_run_lock", "Feststelltaste"));
         mInputSettings.insert(make_pair("act_quitgame", "Ctrl+X"));
         mInputSettings.insert(make_pair("act_closecurrentwindow", "Escape"));
         mInputSettings.insert(make_pair("act_toggleconsole", "Tabulator"));

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-02 14:57:36 UTC (rev 3111)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-02 21:22:14 UTC (rev 3112)
@@ -57,7 +57,7 @@
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
         mElapsed(0.0f),
         mMinTimestep(1.0f/600.0f),
-        mMaxTimestep(1.0f/60.0f),
+        mMaxTimestep(1.0f/30.0f),
         mLevelID(),
         mCharacterID(),
         mDefaultPair(),
@@ -109,8 +109,12 @@
         if (!mEnabled) 
 			return;
 
+        // does not need to be executed each frame!
+        // this is only here for testing
+        //NewtonSetMinimumFrameRate(mWorld->getNewtonWorld(), 1./mMaxTimestep);
 
-        // Newton kann timesteps zwischen 1/60 und 1/600!
+
+        // Newton kann timesteps zwischen 1/20 und 1/600!
         mElapsed += elapsedTime;
         while( mElapsed >= mMaxTimestep)
         {



From natoka at mail.berlios.de  Sat Mar  3 02:10:42 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Sat, 3 Mar 2007 02:10:42 +0100
Subject: [Dsa-hl-svn] r3113 - in rl/trunk/engine: ai/include ai/src
	common/include
Message-ID: <200703030110.l231AgqU009853@sheep.berlios.de>

Author: natoka
Date: 2007-03-03 02:10:20 +0100 (Sat, 03 Mar 2007)
New Revision: 3113

Modified:
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/FuzzyState.h
   rl/trunk/engine/ai/include/FuzzyStateMachine.h
   rl/trunk/engine/ai/include/PhysicalObstacle.h
   rl/trunk/engine/ai/include/PlayerVehicle.h
   rl/trunk/engine/ai/include/SteeringMachine.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/common/include/GameTask.h
Log:
added a hopefully complete bunch of comments for the RlAi library.
cleaned up the ai headers a bit by moving get/set functionality from the header file to the .cpp file.

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/Agent.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -31,35 +31,88 @@
 	class Actor;
 //	class PerceptionPool;
 
+	/** Represents a single entity that has got AI.
+	 * Instantiated objects are normally registered with AgentManager.
+	 * This class creates the connection between actively involved
+	 * Creatures (rl::Creature), steering (pathfinding, movement - OpenSteer)
+	 * and decission making (behaviours)
+	 */
 	class _RlAiExport Agent 
 		: public PhysicsController
 	{
 	public:
+		/** Constructor by Creature object.
+		 * @param character Creature object
+		 */
 		Agent(Creature* character);
+		/** Constructor by Creature object.
+		 * @param character Creature object
+		 * @param vehicle SteeringVehicle object for the specified creature
+		 */
 		Agent(Creature* character, SteeringVehicle* vehicle);
+
+		// deprecated
 		Agent(DialogCharacter* character);
+		/** explicit virtual destructor
+		 */
 		virtual ~Agent(void);
 
+		/** Initializes class and registeres with parts exterior to AI system.
+		 * Creates a standard Vehicle object for the creature when none was
+		 * supplied on object creation. Creates a behaviour state machine and
+		 * registers itself as a PhysicsController with PhysicalManager for the
+		 * stored creature object.
+		 */
 		void initialize();
 
+		/** Returns the agent type (Player, NPC, ...).
+		 */
 		AgentManager::AgentType getType();
+		/** Sets the agent type (Player, NPC, ...).
+		 * @param type AgentType sets the type to the given one.
+		 */
 		void setType(AgentManager::AgentType type);
 
+		/** Function invoked by AgentManager to let Agents advance their AI.
+		 * Is invoked with time since last invocation. Here the behaviour and
+		 * the vehicle are updated.
+		 */
 		void update(const float elapsedTime);
+		/** Adds a steering behaviour to the internal steering machine.
+		 * @param behaviour SteeringBehaviour is initialized and registered to mBehaviour.
+		 */
 		void addSteeringBehaviour(SteeringBehaviour* behaviour);
+		/** Removes all steering behaviours.
+		 */
         void clearSteeringBehaviours();
 
+		/** Retrieves the stored SteeringVehicle.
+		 */
 		SteeringVehicle* getVehicle();
+
 //		PerceptionPool* getPerceptionPool();
+
+		// deprecated - for DialogBot
 		bool isDialogActive();
+
+		/** Function invoked by PhysicsManager whenever force/torque is to be
+		 * applied to the creature stored.
+		 * @param thing PhysicalThing that is responsible for the creature.
+		 */
 		virtual void OnApplyForceAndTorque(PhysicalThing* thing);
 
 	protected:
+		//! stores the type of the agent (Player, NPC, ...)
 		AgentManager::AgentType mType;
+		//! stores the behaviour FuzzyStateMachine for behaviour
 		SteeringMachine* mBehaviour;
+		//! stores the vehicle representation of the creature
 		SteeringVehicle* mVehicle;
+		//! stores the creature whose AI is simulated
+		Creature* mCreature;
+
+		// deprecated
 		DialogCharacter* mDialogBot;
-		Creature* mCreature;
 //		PerceptionPool* mPerceptionPool;
 	};
 

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -28,7 +28,9 @@
 	class SteeringVehicle;
 	class DialogCharacter;
 
-	/** Executes AI during game as a RL::GameTask
+	/** Executes AI during game as a RL::GameTask.
+	 * Each registered Agent gets executed once per gametask in order
+	 * to do its ai stuff (path finding, movement, decission making).
 	 */
 	class _RlAiExport AgentManager
 		: protected Ogre::Singleton<AgentManager>,
@@ -37,37 +39,71 @@
 		  
 	{
 	public:
+		// Different types of agents
 		enum AgentType
 		{
-			AGENT_NONE = -1,
-			AGENT_PLAYER = 0,
-			AGENT_STD_NPC = 1,
-			AGENT_FLOCKING = 2
+			AGENT_NONE = -1,	//!< when the type is unknown/unset
+			AGENT_PLAYER = 0,	//!< when the agent represents a player
+			AGENT_STD_NPC = 1,	//!< when the agent is a nonplayercharacter
+			AGENT_FLOCKING = 2	//!< hmm, possibly for groups behaviour of NPCs
 		};
+
+		//! returns the agentmanager object
 		static AgentManager& getSingleton(void);
+		//! returns a pointer to the agentmanager object
         static AgentManager* getSingletonPtr(void);
+
+		//! defines a std::vector list of Vehicle objects for OpenSteer
 		typedef std::vector<SteeringVehicle*> VehicleList;
 
+		// default constructor
 		AgentManager(void);
+		// explicit virtual destructor
 		virtual ~AgentManager(void);
-		/**
-		 * Create an AI agent with an assigned Rl-Actor
+
+		/** Creates an AI agent with an assigned rl::Actor.
 		 * AiSubsystems is responsible for memory management of the Agent
 		 */
 		Agent* createAgent(AgentType type, Creature* character);
+
+		// ok, this is something that should be removed in the long run
+		// Hint: it's deprecated
 		Agent* createAgent(DialogCharacter* character);
 
+		// ??? purpose ??? needed for opensteer ?
+
 		VehicleList getNeighbors(Agent* agent);
-	//	void OnApplyForceAndTorque(PhysicalThing* thing);
+
+		/** Interface executed as a GameTask by GameLoop.
+		 * is responsible for advancing the ai logik about the time specified.
+		 * Each registered Agent is executed can advance the specified time.
+		 * @param elapsedTime Ogre::Real specifying 
+		 */
 		void run( Ogre::Real elapsedTime );
+		/** Removes all registered Agents and deletes their objects.
+		 * Clears all internal lists and the playercharacter object is also
+		 * deallocated.
+		 */
 		void removeAllAgents();
+
+		/** Returns the name of this class - AgentManager for debugging purposes.
+		 */
         virtual const Ogre::String& getName() const;
 	private:
+		/** Used to register an agent internally.
+		 * Adds the given Agent to AgentList and its vehicle to mAllNeighbors.
+		 * @param agent Agent to be added
+		 */
 		void addAgent(Agent* agent);
-		typedef std::list<Agent*> AgentList;
+
+		//! defines a std::list of Agents
+		typedef std::vector<Agent*> AgentList;
 		
+		//! List of Vehicle objects from the Agents in mAgents (might be needed for opensteer)
 		VehicleList mAllNeighbors;
+		//! List of registered agents (includes mPlayer)
 		AgentList mAgents;
+		//! Agent representing the player
 		Agent* mPlayer;
 	};
 }

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -33,19 +33,40 @@
 		  public SceneChangeListener
 	{
 	public:
+		//! returns the aisubsystem object.
 		static AiSubsystem & getSingleton(void);
+		//! returns a pointer to the aisubsystem object.
         static AiSubsystem * getSingletonPtr(void);
 
+		//! default constructor
 		AiSubsystem(void);
+		/** explicit virtual destructor.
+		 * Unregisters Scene listener, makes AgentManager drop all Agents,
+		 * unregisters AgentManager from GameLoop,
+		 * deletes AgentManager and AiWorld
+		 */
 		virtual ~AiSubsystem(void);
 		
+		/** Returns the stored world object representing storing obstacles.
+		 */
 		AiWorld* getWorld();
 
+		/** Trigger function triggered after scene load.
+		 */
 		void onAfterSceneLoaded();
+		/** Trigger function triggered before scene load.
+		 */
         void onBeforeClearScene();
 	private:
+		/** Initializes the AI subsystem.
+		 * Creates AiWorld and AgentManager, registers a scene listener,
+		 * adds the AgentManager to the GameLoop as a task.
+		 */
 		void initialize();
+
+		//! single AgentManager object
 		AgentManager* mAgentManager;
+		//! AiWorld representation - WIP!!! (object to changes)
 		AiWorld* mWorld;
 	};
 

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -22,38 +22,49 @@
 
 namespace rl
 {
-	/**
-	 * Representation of the GameWorld for Steering and Pathing
+	/** Representation of the GameWorld for Steering and Pathing.
+	 * Is a container for obstacles that have to be avoided when
+	 * creating a path.
 	 */
 	class AiWorld
 	{
 	public:
+		//! default constructor
 		AiWorld(void);
+		//! default destructor
 		~AiWorld(void);
 
+		/** Returns a list of obstacles for OpenSteer.
+		 */
 		OpenSteer::ObstacleGroup getSteeringObstacles();
+		/** Adds an obstacle to the internal list of obstacles
+		 */
 		void addObstacle(OpenSteer::Obstacle* obstacle);
+		/** Removes and deletes all internally stored obstacle objects.
+		 */
 		void removeAllObstacles();
 	private:
+		//! list of obstacles
 		OpenSteer::ObstacleGroup mObstacles;
 	};
 
 
-
-
-
-    // Wrapper f?r Newton-World
+    /** Wrapper f?r Newton-World
+	 */
     class NewtonWorldAsObstacle : public OpenSteer::Obstacle
     {
     public:
-        NewtonWorldAsObstacle(void)
-        {
-            mLevelMaterial = PhysicsManager::getSingleton()._getLevelMaterialID();
-            mNewtonWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-        }
+		/** default constructor.
+		 * Retrieves Material of newton level and the newton world.
+		 */
+        NewtonWorldAsObstacle(void);
+		/** Searchs for pathintersections by ray casting.
+		 * natoka: should be thought over
+		 */
         virtual void findIntersectionWithVehiclePath (const OpenSteer::AbstractVehicle& vehicle,
                                               PathIntersection& pi) const;
     private:
+		//! different types of raycasting directions
         enum RaycastType
         {
             NONE = -1,
@@ -63,7 +74,9 @@
             TOP,
             BOTTOM
         };
+		//! newton material id
         OgreNewt::MaterialID *mLevelMaterial;
+		//! newton world
         OgreNewt::World *mNewtonWorld;
     };
 }

Modified: rl/trunk/engine/ai/include/FuzzyState.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyState.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/FuzzyState.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -20,43 +20,98 @@
 
 namespace rl
 {
+	/* Represents a single fuzzy state for the FuzzyStateMachine
+	 */
 	template <class Controller> class FuzzyState
 	{
 	public:
+		/** default constructor
+		 * initializes internal variables only
+		 */
 		FuzzyState(void)
 			: mActivationLevel(), mParent(NULL), mController(NULL) {}
 
+		/** Constructor assigning parent FuzzyState and controller object.
+		 * The Controller object is normally influenced by FuzzyState
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
 		FuzzyState<Controller>(FuzzyState* parent, Controller* controller)
 			: mActivationLevel(), mParent(parent), mController(controller) {}
 
+		/** explicit virtual destructor
+		 */
 		virtual ~FuzzyState(void){};
 
+		/** returns a string describing the type of fuzzy state.
+		 * function is abstract.
+		 * @returns type name string for fuzzy state.
+		 */
 		virtual CeGuiString getType()=0;
+		/** should initialize the fuzzy state.
+		 * function is abstract.
+		 */
 		virtual void init()=0;
+		/** should activate the fuzzy state.
+		 * function is abstract.
+		 */
 		virtual void activate()=0;
+		/** deactivates fuzzy state.
+		 * function is abstract.
+		 */
 		virtual void deactivate()=0;
+		/** tells the fuzzy state to update for the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
 		virtual void update(const float elapsedTime)=0;
 
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
 		virtual float calculateActivation()=0;
 
+		/** checks if the activation value exceeds the boundary constraints.
+		 * If this happens, the value is reset to an according boundary value.
+		 */
 		virtual void checkBounds(float lowerBound = 0.0f, float upperBound = 1.0f)
 		{
 			mActivationLevel = std::max(mActivationLevel, lowerBound);
 			mActivationLevel = std::min(mActivationLevel, upperBound);
 		}
 
+		/** retrieve the current activation level.
+		 * @returns float the current activation level.
+		 */
 		float getActivationLevel() { return mActivationLevel; }
+		/** sets the current activation level.
+		 * @param activationLevel the new activation level.
+		 */
 		void setActivationLevel(float activationLevel)  { mActivationLevel = activationLevel; }
 
+		/** retrieve the controller object
+		 * @returns the stored controller
+		 */
 		Controller* getController() { return mController; }
+		/** sets the controller object
+		 * @param controller new controller pointer
+		 */
 		void setController(Controller* controller) { mController = controller; }
 
+		/** retrieve the parent fuzzy state
+		 * @returns FuzzyState the parent of the fuzzy state
+		 */
 		FuzzyState* getParent() { return mParent; }
+		/** sets the parent fuzzy state
+		 * @param parent of the fuzzy state
+		 */
 		void setParent(FuzzyState* parent) { mParent = parent; }
 		
 	protected:
+		//! stores the current activation level
 		float mActivationLevel;
+		//! stores the parent fuzzy state
 		FuzzyState* mParent;
+		//! stores the controller assigned to the fuzzy state
 		Controller* mController;
 	};
 }

Modified: rl/trunk/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -22,24 +22,41 @@
 
 namespace rl
 {
+	/** manages a set of FuzzyState objects 
+	 */
 	template <class Controller> class FuzzyStateMachine :
 		public FuzzyState<Controller>
 	{
 	public:
+		//! typedefinition for pointer to a FuzzyState
 		typedef FuzzyState<Controller>* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
 		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
 			: FuzzyState<Controller>(parent, controller), mMaxActiveStates(), mStates() {}
 
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
 		virtual ~FuzzyStateMachine(void)
 		{
 			clearStates();
 		}
 
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
 		virtual void addState(FuzzyStatePtr state)
 		{
 			mStates.push_back(State(false, state));
             ScriptWrapper::getSingleton().owned( state );
 		}
+		/** removes all stored FuzzyState objects
+		 */
         virtual void clearStates()
 		{
 			typename StateList::iterator itr = mStates.begin();
@@ -51,20 +68,47 @@
 			mStates.clear();
 		}
 
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
 		virtual bool isActive(FuzzyStatePtr state)
 		{
 			return false; 
 		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
 		virtual void reset(){}
 
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
 		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
 		virtual int getMaxActivity() { return mMaxActiveStates; }
 
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
 		float calculateActivation(void){ return 0.0f; }
 
+		/** initializes the fuzzy state.
+		 */
 		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
 		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
 		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
 		virtual void update(const float elapsedTime)
 		{
 			if(mStates.empty())
@@ -102,9 +146,15 @@
 
 
 	protected:
+		//! maximum number of active states
 		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
 		typedef std::pair<bool, FuzzyStatePtr> State;
+		//! defines a double linked list of states
 		typedef std::list<State> StateList;
+		//! the double linked list of stored FuzzyState objects
 		StateList mStates;
 	};
 

Modified: rl/trunk/engine/ai/include/PhysicalObstacle.h
===================================================================
--- rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -25,24 +25,47 @@
 namespace rl {
     class PhysicalThing;
     
+	/** Class connecting OpenSteer::Obstacle and rl::PhysicalThing.
+	 */
     class _RlAiExport PhysicalObstacle {
         
         public:
+			/** Constructor
+			 * @param thing PhysicalThing object to be connected with a OpenSteer::Obstacle
+			 */
             PhysicalObstacle(PhysicalThing *thing);
+			/** explicit default destructor
+			 */
             virtual ~PhysicalObstacle();
-            
+            /** returns the associated OpenSteer::Obstacle.
+			 */
             OpenSteer::Obstacle *getObstacle() const;
             
+			/** returns the associated PhysicalThing.
+			 */
             PhysicalThing *getPhysicalThing() const;
+			/** stores an other PhysicalThing internally.
+			 * @param thing PhysicalThing object to be connected with a OpenSteer::Obstacle
+			 */
             void setPhysicalThing(PhysicalThing *thing);
             
         protected:
+			/** Initializes the opensteer obstacle by utilizing the PhysicalThing
+			 * Creates a Box Obstacle representing the PhysicalThings Collision primitiv
+			 * for OpenSteer.
+			 */
             void _update();
             
         private:
+			/** Sets the obstacle
+			 * @param obstacle OpenSteer::Obstacle representing the internally stored
+			 * PhysicalThing.
+			 */
             void setObstacle(OpenSteer::Obstacle *obstacle);
 
+			//! collision object for OpenSteer
             OpenSteer::Obstacle *mObstacle;
+			//! object used for the collision object for opensteer
             PhysicalThing *mPhysicalThing;
     };
 }

Modified: rl/trunk/engine/ai/include/PlayerVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/PlayerVehicle.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/PlayerVehicle.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -22,18 +22,27 @@
 {
 	class Agent;
 	class Actor;
-	/**
-     * Represents the player as a vehicle
+	/** Represents the player as a vehicle.
 	 */
 	class PlayerVehicle :
 		public SteeringVehicle
 	{
 	public:
+		/** Constructor
+		 * @param Actor gives the Actor representing the Player
+		 */
 		PlayerVehicle(Actor* character);
+		/** explicit destructor
+		 */
 		virtual ~PlayerVehicle(void);
 
-		/**
-		 * update the steering of the vehicle
+		/** Updates the steering of the vehicle.
+		 * Update is done by fetching position and orientation from the
+		 * attached PhysicalThing object representing the player. Those
+		 * are then used to set the state of the OpenSteer Obstacle
+		 * accordingly.
+		 * @param currentTime const float current time
+		 * @param elapsedTime const float elapsed time since last call
 		 */
 		virtual void update(const float currentTime, const float elapsedTime);
 	};

Modified: rl/trunk/engine/ai/include/SteeringMachine.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringMachine.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/SteeringMachine.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -22,14 +22,25 @@
 namespace rl
 {
 	class SteeringVehicle;
+	//! typedefinition for ruby interface
 	typedef FuzzyState<SteeringVehicle> SteeringBehaviour;
 //	typedef FuzzyStateMachine<Agent> SteeringMachine;
+	/** SteeringMachine responsible for steering a Vehicle.
+	 */
 	class SteeringMachine : public FuzzyStateMachine<SteeringVehicle>
 	{
 	public:
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
 		SteeringMachine(SteeringBehaviour* parent, SteeringVehicle* controller)
 			: FuzzyStateMachine<SteeringVehicle>(parent, controller) {}
 
+		/** returns the type 
+		 * @returns CeGuiString containing SteeringMachine as a typestring
+		 */
 		virtual CeGuiString getType() { return "SteeringMachine"; }
 	};
 	

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -44,7 +44,13 @@
 	class _RlAiExport SteeringVehicle : protected SimpleVehicle_2
 	{
 	public:
+		/** Constructor.
+		 * @param parent Agent owning this vehicle
+		 * @param character Actor controlled by Agent
+		 */
 		SteeringVehicle(Agent* parent, Actor* character);
+		/** explicit virtual destructor.
+		 */
 		virtual ~SteeringVehicle(void);
 
 		/**
@@ -101,8 +107,19 @@
 		 */
 		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
 
+		/** tests if the specified Agent is within the threshold.
+		 * @param agent Agent to test against
+		 * @param threshold specifies maximum distance
+		 */
 		bool isAhead(Agent* agent, const float threshold);
+
+		/** tests if collision will happen within specified timeframe
+		 * @param minTimeToCollision minimum time to next collision
+		 */
 		bool needAvoidance(const float minTimeToCollision);
+		/** Sets the animation of the actors mesh to a new keyframe.
+		 * @param name of the animation to set the mesh of the actor to.
+		 */
 		void setAnimation(const CeGuiString& name);
 	
 		/* TODO:
@@ -118,10 +135,19 @@
 				
 //		PerceptionPool* getPerceptionPool();
 
+		/** tests if a dialog is active with the creature
+		 * @returns true when dialog is active, otherwise false
+		 */
 		bool isDialogActive();
 
+		/** calculates euklidian distance between two vectors
+		 * @param vec1 first vector
+		 * @param vec2 second vector
+		 */
 		float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2);
 
+		/** returns the position of ?
+		 */
 		Ogre::Vector3 getPosition();
 
 		// inherited from AbstractVehicle
@@ -137,32 +163,78 @@
 		OpenSteer::Vec3 predictFuturePosition (const float predictionTime) const;
 
 		void resetLocalSpace();
-		// get/set mass
-		float mass (void) const {return mMass;}
-		float setMass (float m) {return 1;} // don't set mass here TODO: throw exception
 
-		// get velocity of vehicle
+		/** get mass
+		 * @returns mass of physical object
+		 */
+		float mass (void) const;
+		/** does not set mass but is necessary for AbstractVehicle.
+		 * throws an exception on invocation.
+		 * @param m mass
+		 */
+		float setMass (float m);
+
+		/** retrieve velocity of vehicle
+		 * @returns velocity of the vehicle
+		 */
 		OpenSteer::Vec3 velocity (void) const {return OpenSteer::Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
 
-		// get/set speed of vehicle  (may be faster than taking mag of velocity)
-		float speed (void) const {return mSpeed;}
-		float setSpeed (float s) {return mSpeed = s;}
+		/** retrieves speed of vehicle.
+		 * may be faster than taking mag of velocity
+		 */
+		float speed (void) const;
+		/** sets speed of vehicle.
+		 * may be faster than taking mag of velocity
+		 * @param s new speed to set
+		 * @returns float new speed set.
+		 */
+		float setSpeed (float s);
 
-		// size of bounding sphere, for obstacle avoidance, etc.
-		// TODO: this should be handled by size of NewtonBody
-		float radius (void) const {return mRadius;}
-		float setRadius (float m) {return mRadius = m;}
+		/** radius for size of bounding sphere.
+		 * used for obstacle avoidance, etc.
+		 * TODO: this should be handled by size of NewtonBody
+		 * @returns float the radius
+	    */
+		float radius (void) const;
+		/** sets radius for size of bounding sphere.
+		 * used for obstacle avoidance, etc.
+		 * TODO: this should be handled by size of NewtonBody
+		 * @returns float the radius
+	    */
+		float setRadius (float m);
 
-        float height (void) const {return mHeight;}
-        float setHeight (float h) {return mHeight = h;}
+		/** height for size of bounding sphere.
+		 * used for obstacle avoidance, etc.
+		 * TODO: this should be handled by height of NewtonBody
+		 * @returns float the height
+	    */
+        float height (void) const;
+		/** height for size of bounding sphere.
+		 * used for obstacle avoidance, etc.
+		 * TODO: this should be handled by height of NewtonBody
+		 * @returns float the height
+	    */
+        float setHeight (float h);
 
-		// get/set maxForce
-		float maxForce (void) const {return 10000.0f;} 
-		float setMaxForce (float mf) {return _maxForce = mf;}// TODO: should not be set here, throw excpetion or so
+		/** retrieves maximum force.
+		 * @returns float containing maximum force.
+		 */
+		float maxForce (void) const; 
+		/** sets maximum force.
+		 * TODO: should not be set here, throw excpetion or so
+		 * @returns float containing maximum force set.
+		 */
+		float setMaxForce (float mf);
 
-		// get/set maxSpeed
-		float maxSpeed (void) const {return 100000; }
-		float setMaxSpeed (float ms) {return _maxSpeed = ms;} // TODO: should not be set here, throw excpetion or so
+		/** retrieves maximum speed.
+		 * @returns float containing maximum speed
+		 */
+		float maxSpeed (void) const;
+		/** retrieves maximum speed.
+		 * TODO: should not be set here, throw excpetion or so
+		 * @returns float containing maximum speed
+		 */
+		float setMaxSpeed (float ms);
 
 
 		/**
@@ -227,20 +299,35 @@
 		}
 		*/
 
-
-        const Actor* getActor(void) const  { return mActor; }
+		/** retrieve the controlled Actor
+		 * @returns Actor that is controlled by the SteeringVehicle
+		 */
+        const Actor* getActor(void) const;
 	protected:
+		/** initializes
+		 */
 		void initialize();
+
+		/** retrieves the neighbours of this SteeringVehicle
+		 */
 		OpenSteer::AVGroup getNeighbors();
+		/** retrieves the obstacles
+		 */
 		OpenSteer::ObstacleGroup getObstacles();
+
 	//    float _mass;       // mass (defaults to unity so acceleration=force)
     //   float _radius;     // size of bounding sphere, for obstacle avoidance, etc.
     //    float _speed;      // speed along Forward direction.  Because local space
                            // is velocity-aligned, velocity = Forward * Speed
-        float _maxForce;   // the maximum steering force this vehicle can apply
-                           // (steering force is clipped to this magnitude)
-        float _maxSpeed;   // the maximum speed this vehicle is allowed to move
-                           // (velocity is clipped to this magnitude)
+		
+		/** the maximum steering force this vehicle can apply.
+         * steering force is clipped to this magnitude.
+		 */
+        float _maxForce;
+		/** the maximum speed this vehicle is allowed to move.
+         * velocity is clipped to this magnitude.
+		 */
+        float _maxSpeed;
 
      /*   float _curvature;
 		float _smoothedCurvature;
@@ -250,18 +337,28 @@
         OpenSteer::Vec3 _smoothedPosition;
         OpenSteer::Vec3 _smoothedAcceleration;
 	*/	
+		//! mass of the steering vehicle retrieved from Newton body (is this really necessary ?)
 		Ogre::Real mMass;
+		//! radius of for the bounding sphere (use newton to get this from)
 		Ogre::Real mRadius;
+		//! speed of the vehicle
 		Ogre::Real mSpeed;	
 
+		//! height of the vehicle ? (use newton to get this)
         float mHeight;
 
+		//! current force 
 		Ogre::Vector3 mCurrentForce;
+		//! current velocity
 		Ogre::Vector3 mCurrentVelocity;
+		//! direction vector
 		Ogre::Vector3 mForwardVector;
+		//! the yaw angle in radians
 		Ogre::Radian mYaw;
 
+		//! Agent using this vehicle
 		Agent* mParent;
+		//! Actor object steered by this vehicle (and controlled by Agent).
 		Actor* mActor;
 
         // measure path curvature (1/turning-radius), maintain smoothed version

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-03 01:10:20 UTC (rev 3113)
@@ -51,6 +51,7 @@
 AiSubsystem::~AiSubsystem(void)
 {
     CoreSubsystem::getSingletonPtr()->getWorld()->removeSceneChangeListener(this);
+	GameLoop::getSingleton().removeTask(AgentManager::getSingletonPtr());
     AgentManager::getSingleton().removeAllAgents();
     mWorld->removeAllObstacles();
     delete mAgentManager;

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-03 01:10:20 UTC (rev 3113)
@@ -70,8 +70,12 @@
 	mObstacles.clear();
 }
 
+NewtonWorldAsObstacle::NewtonWorldAsObstacle(void)
+{
+    mLevelMaterial = PhysicsManager::getSingleton()._getLevelMaterialID();
+    mNewtonWorld = PhysicsManager::getSingleton()._getNewtonWorld();
+}
 
-
 void NewtonWorldAsObstacle::findIntersectionWithVehiclePath (
     const AbstractVehicle& vehicle,
     PathIntersection& pi) const

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-03-03 01:10:20 UTC (rev 3113)
@@ -51,7 +51,7 @@
     void PhysicalObstacle::setPhysicalThing(PhysicalThing *thing)
     {
         mPhysicalThing = thing;
-        mObstacle = NULL;
+        mObstacle = NULL;	// question: shouldn't we check before doing this ?
         _update();
     }
     

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-03 01:10:20 UTC (rev 3113)
@@ -285,6 +285,79 @@
 	return Vector3(position().x, position().y, position().z);
 }
 
+float SteeringVehicle::mass (void) const 
+{
+	return mMass;
+}
+
+float SteeringVehicle::setMass (float m) 
+{
+	// don't set mass here TODO: throw exception
+
+	return 1;
+} 
+
+float SteeringVehicle::speed (void) const 
+{
+	return mSpeed;
+}
+
+float SteeringVehicle::setSpeed (float s) 
+{
+	return mSpeed = s;
+}
+
+float SteeringVehicle::radius (void) const 
+{
+	// TODO: this should be handled by size of NewtonBody
+	return mRadius;
+}
+
+float SteeringVehicle::setRadius (float m) 
+{
+	// TODO: this should be handled by size of NewtonBody
+	return mRadius = m;
+}
+
+float SteeringVehicle::height (void) const 
+{
+	// TODO: this should be handled by height of NewtonBody
+	return mHeight;
+}
+
+float SteeringVehicle::setHeight (float h) 
+{
+	// TODO: this should be handled by height of NewtonBody
+	return mHeight = h;
+}
+
+const Actor* SteeringVehicle::getActor(void) const  
+{ 
+	return mActor; 
+}
+
+float SteeringVehicle::maxForce (void) const 
+{
+	return 10000.0f;
+} 
+
+float SteeringVehicle::setMaxForce (float mf) 
+{
+	 // TODO: should not be set here, throw excpetion or so
+	return _maxForce = mf;
+}
+
+float SteeringVehicle::maxSpeed (void) const 
+{
+	return 100000; 
+}
+
+float SteeringVehicle::setMaxSpeed (float ms) 
+{
+	 // TODO: should not be set here, throw excpetion or so
+	return _maxSpeed = ms;
+}
+
 ObstacleGroup SteeringVehicle::getObstacles()
 {
 	return AiSubsystem::getSingleton().getWorld()->getSteeringObstacles();

Modified: rl/trunk/engine/common/include/GameTask.h
===================================================================
--- rl/trunk/engine/common/include/GameTask.h	2007-03-02 21:22:14 UTC (rev 3112)
+++ rl/trunk/engine/common/include/GameTask.h	2007-03-03 01:10:20 UTC (rev 3113)
@@ -38,6 +38,8 @@
 		*/
 		virtual void run( Ogre::Real elapsedTime ) = 0;
 
+		/** Returns the name of the derived class for debugging purposes.
+		 */
         virtual const Ogre::String& getName() const = 0;
         
 		/// Gibt zur?ck ob dieser GameTask pausiert ist



From tanis at mail.berlios.de  Sat Mar  3 21:10:23 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sat, 3 Mar 2007 21:10:23 +0100
Subject: [Dsa-hl-svn] r3114 - in rl/trunk/engine/core: include src
Message-ID: <200703032010.l23KANm9015778@sheep.berlios.de>

Author: tanis
Date: 2007-03-03 21:10:15 +0100 (Sat, 03 Mar 2007)
New Revision: 3114

Modified:
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/GameLoop.cpp
Log:
Fixed bug in GameLoop, that caused deleted tasks to sometimes still being called.

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-03-03 01:10:20 UTC (rev 3113)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-03-03 20:10:15 UTC (rev 3114)
@@ -70,9 +70,33 @@
 	static GameLoop * getSingletonPtr(void);
 
 private:
-    typedef std::list<GameTask*> GameTaskList;
-    typedef std::list<std::pair<TaskGroup, GameTask*> > GroupTaskList;
+    /// Internal struct for storing the tasks in the queue.
+    /// Contains additional meta-information useful for scheduling.
+    struct GameTaskEntry
+    {
+        bool operator==(const GameTaskEntry& rhs) const
+        {
+            return task == rhs.task && valid == rhs.valid;
+        }
 
+        /// The task to be executed
+        GameTask* task;
+        /// Flag whether this task is valid, e.g. removeTask not called for it.
+        bool valid;
+    };
+
+    /// Functor for finding an entry by the task it holds.
+    struct FindEntryByTask : public std::binary_function<GameTaskEntry, GameTask*, bool>
+    {
+        bool operator()(const GameTaskEntry& entry, GameTask* task) const
+        {
+            return entry.task == task;
+        }
+    };
+
+    typedef std::list<GameTaskEntry> GameTaskList;
+    typedef std::list<std::pair<TaskGroup, GameTaskEntry> > GroupTaskList;
+
     std::vector<GameTaskList*> mTaskLists;
     GroupTaskList mAddedTasks;
     GameTaskList mRemovedTasks;

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-03-03 01:10:20 UTC (rev 3113)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-03-03 20:10:15 UTC (rev 3114)
@@ -73,12 +73,27 @@
     void GameLoop::addTask(GameTask* task, TaskGroup group)
     {
         RlAssert1(task != NULL);
-        mAddedTasks.push_back(std::make_pair(group, task));
+        GameTaskEntry entry = {task, true};
+        mAddedTasks.push_back(std::make_pair(group, entry));
     }
 
     void GameLoop::removeTask(GameTask* task)
     {
-        mRemovedTasks.push_back(task);
+        // find the removed task entry, and set it to invalid.
+        for (size_t i = 0; i < mTaskLists.size(); ++i)
+        {
+            GameTaskList* tasks = mTaskLists[i];
+            GameTaskList::iterator find_it = std::find_if(tasks->begin(), tasks->end(),
+                std::bind2nd(FindEntryByTask(), task));
+            if (find_it != tasks->end())
+            {
+                find_it->valid = false;
+                break;
+            }
+        }
+        // Add it to the removed list, so we can find it faster in updateTaskList().
+        GameTaskEntry entry = {task, false};
+        mRemovedTasks.push_back(entry);
     }
 
     void GameLoop::quitGame()
@@ -112,9 +127,9 @@
                 GameTaskList* tasks = mTaskLists[i];
                 for (GameTaskList::iterator it = tasks->begin(); it != tasks->end(); ++it)
                 {
-                    if (!(*it)->isPaused())
+                    if (it->valid && !(it->task->isPaused()))
                     {
-                        (*it)->run(frameTime);
+                        it->task->run(frameTime);
                     }
                 }
             }



From melven at mail.berlios.de  Sun Mar  4 19:41:47 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 4 Mar 2007 19:41:47 +0100
Subject: [Dsa-hl-svn] r3115 - rl/trunk/engine/core/src
Message-ID: <200703041841.l24IflUj008363@sheep.berlios.de>

Author: melven
Date: 2007-03-04 19:41:35 +0100 (Sun, 04 Mar 2007)
New Revision: 3115

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
Log:
Missing "mov_run_lock" ConfigFile default added

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-03 20:10:15 UTC (rev 3114)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-04 18:41:35 UTC (rev 3115)
@@ -92,7 +92,7 @@
         mInputSettings.insert(make_pair("mov_jump", "Leertaste"));
         mInputSettings.insert(make_pair("mov_run", "Umschalt links"));
         mInputSettings.insert(make_pair("mov_sneak", "Strg links"));
-        mInputSettings.insert(make_pair("mov_run_lock", "Feststelltaste"));
+        mInputSettings.insert(make_pair("mov_run_lock", "< | >"));
         mInputSettings.insert(make_pair("act_quitgame", "Ctrl+X"));
         mInputSettings.insert(make_pair("act_closecurrentwindow", "Escape"));
         mInputSettings.insert(make_pair("act_toggleconsole", "Tabulator"));



From melven at mail.berlios.de  Sun Mar  4 19:43:56 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 4 Mar 2007 19:43:56 +0100
Subject: [Dsa-hl-svn] r3116 - in rl/trunk/engine/rules: include src
Message-ID: <200703041843.l24Ihu3w008787@sheep.berlios.de>

Author: melven
Date: 2007-03-04 19:43:42 +0100 (Sun, 04 Mar 2007)
New Revision: 3116

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
Log:
Methods for moving/jumping (Taktische Bewegung etc) added

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-04 18:41:35 UTC (rev 3115)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-04 18:43:42 UTC (rev 3116)
@@ -208,11 +208,11 @@
          *   hinaus erhoeht werden.
          *  @ingroup CreatureRubyExports
          **/
-		virtual void modifyAu(int mod,  bool ignoreMax = false);
+		virtual void modifyAu(float mod,  bool ignoreMax = false);
         /**
          *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
          **/
-        virtual int getAu();
+        virtual float getAu();
         /**
          *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
          **/
@@ -758,7 +758,7 @@
          *  @param damageType Typ des Schadens, um Resistenzen
          *   etc. korrekt zu beruecksichtigen.
 		 **/
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
         static const int AUDAMAGE_NORMAL = 0;
         static const int AUDAMAGE_HEAT = 1;
         static const int AUDAMAGE_COLD = 2;
@@ -783,11 +783,14 @@
         void regenerateAe(int modifier = 0);
         /**
          *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
-         *  einer mind. 5 minuetigen Ruhephase.
+         *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+         *  Parameter time aufgerufen werden.
          *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
          *   selten eingesetzt werden.
+         *  @param time Sollte nur benutzt werden, falls es nicht m?glich ist
+         *   die Funktion wirklich nur alle 5 Minuten aufzurufen
          **/
-        void regenerateAu(int modifier = 0);
+        void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
 
 		/**
 		 * Laesst einen Effekt auf der Kreatur wirken.
@@ -800,6 +803,90 @@
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
+        
+        /**
+         * Berechnet die taktische Geschwindigkeit bei der angegebenen Bewegungsart (siehe Basisbox S.112 ff).
+         * Eventuelle Athletikproben werden hier nicht miteinbezogen!
+         * Die Wirkung der Modifikatoren h?ngt von den Eigenschaften der Kreatur ab!
+         * Eine gezogene Waffe (bedeutet Aufmerksamkeit) m?sste hier auch miteinbezogen werden.
+         * Eigentlich sind die Modifikatoren laut Regelwerk nur f?r strategische Bewegung gedacht,
+         * aber man k?nnte sie auch gut hier einbauen zum Ausspielen von Vorteilen wie Gel?ndekundig
+         * @param movementType Flag f?r die Art der Bewegung
+         * @param modified Gibt an, ob die Behinderung und ?hnliches miteinbezogen werden soll, 
+         *  bei zu geringerer Au gibt dies auch eine geringere Geschwindigkeit zur?ck
+         * @param modifikatoren Flags f?r verschiedene Modifikatoren wie Gel?nde und Wetter
+         * @retval Berechnete Geschwindigkeit, kann diese Bewegung nicht ausgef?hrt werden, ist der Wert 0
+         *  Bei Spr?ngen ist die Angabe die H?he oder die Weite des Sprungs, bei Drehungen die Umdrehungen pro Sekunde
+        **/
+        float getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren = 0);
+        // die Reihenfolger der Definitionen hier ist wichtig!
+        static const int BEWEGUNG_NONE = 0;
+        //static const int BEWEGUNG_FALLEN = -1 ?
+        // schlie?en sich gegenseitig aus
+        static const int BEWEGUNG_GEHEN = 1; // bitte das hier nicht ?ndern, ohne sich der Folgen in MovementCharacterController bewusst zu sein!
+        static const int BEWEGUNG_JOGGEN = 2;
+        static const int BEWEGUNG_LAUFEN = 4;
+        static const int BEWEGUNG_RENNEN = 8;
+        //static const int BEWEGUNG_SCHWIMMEN = 6;
+        //static const int BEWEGUNG_TAUCHEN = 7;
+        // schlie?en sich gegenseitig aus
+        static const int BEWEGUNG_WEITSPRUNG = 16;
+        static const int BEWEGUNG_HOCHSPRUNG = 32;
+        //static const int BEWEGUNG_PRAEZISER_SPRUNG = 24;
+        static const int BEWEGUNG_SCHLEICHEN = 64; //allgemein f?r den Versuch leise zu sein?
+        // k?nnen miteinander kombiniert werden
+        static const int BEWEGUNG_RUECKWAERTS = 128;
+        static const int BEWEGUNG_SEITWAERTS = 256;
+        // k?nnen nicht miteinander kombiniert werden
+        static const int BEWEGUNG_DREHEN = 512;
+        static const int BEWEGUNG_UMDREHEN = 1024;
+        //static const int BEWEGUNG_BALANCIEREN = 1024;
+        //static const int BEWEGUNG_FLUCHT = 2048; //weiterrennen auch bei zu niedriger AU?
+        //...
+        // folgendes sinnvoll? siehe taktische und strategische Bewegung
+        //static const int BEWEGUNG_MOD_NONE = 0;
+        //static const int BEWEGUNG_MOD_REICHSSTRASSE = 1;
+        //static const int BEWEGUNG_MOD_STADT = 2;
+        //static const int BEWEGUNG_MOD_OFFENES_GELAENDE = 4;
+        //static const int BEWEGUNG_MOD_STEILER_ABHANG = 8; // ? ...
+        
+
+        /**
+         * Gibt an, ob die angegebene taktische Bewegungsart im Moment ?berhaupt m?glich ist.
+         * (Ausdauer und Talentwerte hoch genug?)
+        **/
+        bool canUseTaktischeBewegung(int movementType);
+
+
+        /**
+         * F?hrt eine taktische Bewegung aus, das bedeutet, es werden falls n?tig Proben abgelegt
+         * und die Ver?nderungen der AU und LE berechnet; f?r Richtungs?nderungen (Drehung) beim Laufen/etc
+         * muss die Funktion zweimal aufgerufen werden, einmal um die Laufgeschwindigkeit und einmal um die 
+         * Rotationsgeschwindigkeit zu ermitteln 
+         * (das bedeutet auch, dass sobald eine Drehung angegeben wird, nur die Auswirkungen der Drehung, 
+         * nicht der restlichen Bewegung ermittelt werden)
+         * @param movementType Flag f?r die Art der Bewegung
+         * @param modifikator Flags f?r die Umgebung
+         * @param time Die Dauer der Bewegung; hier sind kurze Zeiten vorgesehen (Dauer einer Frame)
+         * @param patzer Falls eine Probe ben?tigt wird, gibt dies die ?briggebliebenen TaW an.
+         *  Ein negativer Wert steht f?r einen Patzer; je kleiner der Wert, desto schlimmer sollten die
+         *  Auswirkungen ausfallen!
+         * @param probenErschwernis Um diesen Wert sind alle ben?tigten Proben erschwert, dient vor allem
+         *  dazu, erschwerte Schleichen-Proben oder ?hnliches zu erm?glichen!
+         * @retval Berechnete Geschwindigkeit (alle Ergebnisse von Talentproben einbezogen)
+        **/
+        float doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis = 0, int modifikatoren = 0);
+
+        /**
+         * Fragt den aktuellen Bewegungstyp ab.
+        **/
+        int getTaktischeBewegung(void) const;
+
+        /**
+         * Setzt den aktuellen Bewegungstyp. Wird ebenfalls in doTaktischeBewegung getan!
+        **/
+        void setTaktischeBewegung(int type);
+
     protected:
         /**
          * Liefert den Eigenschaftswert \a eigenschaftName fuer eine 
@@ -888,7 +975,7 @@
         /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
 		int mCurrentAe;
         /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
-		int mCurrentAu;
+		float mCurrentAu;
         /// Die aktuelle Erschoepfung der Kreatur.
         int mErschoepfung;
         /// Wenn > 0 ist die Kreatur blind.
@@ -911,6 +998,8 @@
         int mSleeping;
         /// Wenn > 0 ist die Kreatur bewusstlos.
         int mUnconscious;
+        /// Zuletzt zugewiesene Bewegungsart
+        int mMovementType;
 
         /// Verwaltet die Effekte die auf die Kreatur wirken.
 		EffectManager mEffectManager;

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-04 18:41:35 UTC (rev 3115)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-04 18:43:42 UTC (rev 3116)
@@ -59,7 +59,8 @@
         mParalyzed(0),
         mSilenced(0),
         mSleeping(0),
-        mUnconscious(0)
+        mUnconscious(0),
+        mMovementType(0)
     {
         mQueryFlags = QUERYFLAG_CREATURE;
 
@@ -286,11 +287,11 @@
 		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
     }
 
-    void Creature::modifyAu(int mod, bool ignoreMax)
+    void Creature::modifyAu(float mod, bool ignoreMax)
     {
-        mCurrentAu = max(mCurrentAu + mod, 0);
+        mCurrentAu = max(mCurrentAu + mod, 0.0f);
 		if (!ignoreMax)
-			mCurrentAu = min(mCurrentAu, getAuMax());
+			mCurrentAu = min(mCurrentAu, float(getAuMax()));
         if (getAu() <= 0)
         {
             setIncapacitated(true);
@@ -298,7 +299,7 @@
 		fireObjectStateChangeEvent();
     }
 
-    int Creature::getAu()
+    float Creature::getAu()
     {
         return mCurrentAu;
     }
@@ -1005,9 +1006,9 @@
         modifyAe(-asp);
     }
 
-    void Creature::damageAu(int aup, int damageType)
+    void Creature::damageAu(float aup, int damageType)
     {
-        if (aup <= 0)
+        if (aup < 0)
         {
          /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
              auf 0 setzen?*/
@@ -1016,6 +1017,9 @@
            mErschoepfung += DsaManager::getSingleton().rollD6();
            setIncapacitated(true);
         }
+        // bei ??beranstrengung, kostet alles doppelte Au!!!!!
+        if( mErschoepfung > getEigenschaft("KO") )
+            aup *= 2;
         modifyAu(-aup);
     }
 
@@ -1051,23 +1055,62 @@
         modifyAe(regeneratedAe);
     }
 
-    void Creature::regenerateAu(int modifier)
+    void Creature::regenerateAu(int modifier, float factor, float time)
     {
-        ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
-        //Grundregeneration von 3W6
-        int regeneratedAu = DsaManager::getSingleton().rollD6()
-            + DsaManager::getSingleton().rollD6() 
-            + DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO", 
-            getWertStateSet(WERT_MOD_REGENERATION_LE)->getProbenModifier()))
+        // das Ganze nur jede Spielrunde machen
+        static float lastSpielrunde = 0;
+        static int regeneratedAu = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6() 
+                + DsaManager::getSingleton().rollD6();
+        lastSpielrunde += time;
+
+
+        if( getAu() == getAuMax() )
         {
-            regeneratedAu += 6;
+            lastSpielrunde = 0;
+            return;
         }
-        //modifiziere die aktuellen AU
-        modifyAu(regeneratedAu);
+
+
+        while( lastSpielrunde >= Date::ONE_SPIELRUNDE )
+        {
+            lastSpielrunde -= Date::ONE_SPIELRUNDE;
+
+
+            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
+            //Grundregeneration von 3W6
+            regeneratedAu = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6() 
+                + DsaManager::getSingleton().rollD6();
+            //Addiere eventuelle Modifikatoren hinzu
+            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
+            //Bei gelungener KO Probe addiere 1
+            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO", 
+                getWertStateSet(WERT_MOD_REGENERATION_LE)->getProbenModifier()))
+            {
+                modifyAu(6*factor);
+            }
+            
+            if( lastSpielrunde >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            {
+                //modifiziere die aktuellen AU
+                time -= Date::ONE_SPIELRUNDE;
+                modifyAu((regeneratedAu-modifier)*factor);
+            }
+
+
+
+
+            if( getAu() == getAuMax() )
+            {
+                lastSpielrunde = 0;
+                return;
+            }
+        }
+
+        // Restbetrag regenerieren:
+        float regeneratedAuPerTime = float(regeneratedAu-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        modifyAu(regeneratedAuPerTime*factor);
     }
 
 	void Creature::addEffect(Effect* effect)
@@ -1118,4 +1161,508 @@
 
         return ps;
     }
+
+    int Creature::getTaktischeBewegung(void) const
+    {
+        return mMovementType;
+    }
+
+    void Creature::setTaktischeBewegung(int type)
+    {
+        mMovementType = type;
+    }
+
+
+    bool Creature::canUseTaktischeBewegung(int movementType)
+    {
+        if( movementType == BEWEGUNG_NONE )
+        {
+            return true;
+        }
+
+        // kann sich die Kreatur ueberhaupt bewegen?
+        if( isImmovable() )
+            return false;
+
+        if( getAu() <= 1 )
+            return false;
+
+
+
+        if( movementType & BEWEGUNG_SCHLEICHEN )
+        {
+            // if( getragenes Gewicht > 2*KK ) return false
+            if( movementType & 
+                (BEWEGUNG_RENNEN | BEWEGUNG_LAUFEN | BEWEGUNG_JOGGEN |
+                BEWEGUNG_HOCHSPRUNG | BEWEGUNG_WEITSPRUNG | BEWEGUNG_UMDREHEN) 
+                )
+            {
+                return false;
+            }
+
+        }
+        else if( movementType & BEWEGUNG_SEITWAERTS )
+        {
+            if( movementType & 
+                (BEWEGUNG_RENNEN | BEWEGUNG_JOGGEN |
+                BEWEGUNG_HOCHSPRUNG | BEWEGUNG_WEITSPRUNG | BEWEGUNG_UMDREHEN)
+                )
+            {
+                return false;
+            }
+        }
+        else if( movementType & BEWEGUNG_HOCHSPRUNG || movementType & BEWEGUNG_WEITSPRUNG )
+        {
+            // if( getragenes Gewicht > KK ) return false
+        }
+
+
+
+        if( movementType & BEWEGUNG_DREHEN ||
+            movementType & BEWEGUNG_UMDREHEN)
+        {
+        }
+        else if( movementType & BEWEGUNG_RENNEN )
+        {
+            // if( getragenes Gewicht > KK ) return false
+            // getCurrentBE() > ?
+            if( getAu() < 6.0 || getAu() < getAuBasis()/3.0 )
+                return false;
+        }
+        else if( movementType & BEWEGUNG_LAUFEN )
+        {
+            // if( getragenes Gewicht > 1.5*KK ) return false
+            if( getAu() < 6.0 )
+                return false;
+        }
+        else if( movementType & BEWEGUNG_JOGGEN )
+        {
+            // if( getragenes Gewicht > 2*KK ) return false
+            if( getAu() < 6.0 )
+                return false;
+        }
+        else if( movementType & BEWEGUNG_GEHEN )
+        {
+        }    
+
+        return true;
+    }
+
+
+
+
+    float Creature::getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren)
+    {
+        static float factorJoggen = 2.0;
+        // Bewegung nicht m??glich!
+        if( !canUseTaktischeBewegung(movementType) )
+            return 0;
+
+
+        int act_gs = getWert(Creature::WERT_GS);
+        if( modified )
+            act_gs -= getCurrentBe();
+        if( act_gs < 1 )
+            act_gs = 1;
+
+        float velocity = 0;
+
+
+        // drehen ist ein sonderfall! angabe der Rotationsgeschwindigkeit in Umdrehungen pro Sekunde
+        if( movementType & BEWEGUNG_DREHEN ||
+            movementType & BEWEGUNG_UMDREHEN )
+        {
+            if( movementType & BEWEGUNG_UMDREHEN )
+                velocity = 0.5;
+            else
+                velocity = 0.3;
+            //if( modified )
+            //    velocity -= getCurrentBe()/getEigenschaft("GE");
+            if( movementType & BEWEGUNG_SCHLEICHEN )
+                velocity *= 0.5;
+            return velocity;
+        }
+
+
+
+
+        if( movementType & BEWEGUNG_SCHLEICHEN )
+        {
+            if( !(movementType & BEWEGUNG_GEHEN) && !(movementType & BEWEGUNG_JOGGEN) &&
+                !(movementType & BEWEGUNG_RENNEN) && !(movementType & BEWEGUNG_LAUFEN) )
+            {
+                return 0;
+            }
+            if( movementType & BEWEGUNG_RUECKWAERTS || movementType & BEWEGUNG_SEITWAERTS )
+                return 1;
+            if( modified && getCurrentBe() > 1 )
+                return 1;
+            
+            return 2;
+        }
+        else if( movementType & BEWEGUNG_WEITSPRUNG )
+        {
+            float mod;
+            if( movementType & BEWEGUNG_RENNEN )
+                mod = 1;
+            else if( movementType & BEWEGUNG_LAUFEN )
+                mod = 0.6;
+            else if( movementType & BEWEGUNG_JOGGEN )
+                mod = 0.5;
+            else
+                mod = 0.3;
+            velocity = mod*(getEigenschaft("GE") + getEigenschaft("KK")) / 5.0;
+
+            if( modified )
+            {
+                // steht nicht in den Regeln aber finde ich sinnvoll
+                // velocityBase *= (1 - getrageneLast/KK);
+                // steht in den Regeln: pro Ersch??pfung ein KK abziehen
+                if( mErschoepfung > getEigenschaft("KO") )
+                    velocity -= mod*(mErschoepfung - getEigenschaft("KO")) / 5.0;
+                // steht nicht in den Regeln, aber finde ich sinnvoll
+                if( getAu() < getAuBasis() / 3.0 )
+                    velocity -= mod*(getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
+            }
+            if( movementType & BEWEGUNG_SCHLEICHEN )
+            {
+                velocity *= 0.3;
+            }
+            return velocity;
+        }
+        else if( movementType & BEWEGUNG_HOCHSPRUNG )
+        {
+            velocity = (getEigenschaft("GE") + getEigenschaft("KK")) / 4.0 / 5.0;
+            
+            if( modified )
+            {
+                // steht nicht in den Regeln aber finde ich sinnvoll
+                // velocityBase *= (1 - getrageneLast/KK);
+                // steht in den Regeln: pro Ersch??pfung ein KK abziehen
+                if( mErschoepfung > getEigenschaft("KO") )
+                    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
+                // steht nicht in den Regeln, aber finde ich sinnvoll
+                if( getAu() < getAuBasis() / 3.0 )
+                    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
+            }
+            if( movementType & BEWEGUNG_SCHLEICHEN )
+            {
+                velocity *= 0.3;
+            }
+            return velocity;
+        }
+
+
+        if( movementType & BEWEGUNG_RUECKWAERTS )
+        {
+            if( movementType & BEWEGUNG_RENNEN ||
+                movementType & BEWEGUNG_LAUFEN ||
+                movementType & BEWEGUNG_JOGGEN )
+            {
+                velocity = 0.6 * act_gs / factorJoggen;
+            }
+            else if( movementType & BEWEGUNG_GEHEN )
+            {
+                velocity = 0.6 * act_gs / 3.6;
+            }
+
+            if( movementType & BEWEGUNG_SCHLEICHEN )
+            {
+                velocity = 0.3 * act_gs / 3.6;
+            }
+            return velocity;
+        }
+        else if( movementType & BEWEGUNG_SEITWAERTS )
+        {
+            if( movementType & BEWEGUNG_RENNEN || 
+                movementType & BEWEGUNG_LAUFEN ||
+                movementType & BEWEGUNG_JOGGEN )
+            {
+                velocity = 0.8 * act_gs / factorJoggen;
+            }
+            else if( movementType & BEWEGUNG_GEHEN )
+            {
+                velocity = 0.8 * act_gs / 3.6;
+            }
+            
+            if( movementType & BEWEGUNG_SCHLEICHEN )
+            {
+                velocity = 0.4 * act_gs / 3.6;
+            }            
+            return velocity;
+        }
+
+
+
+        if( movementType & BEWEGUNG_SCHLEICHEN )
+        {
+            if( !(movementType & BEWEGUNG_GEHEN) && !(movementType & BEWEGUNG_JOGGEN) &&
+                !(movementType & BEWEGUNG_RENNEN) && !(movementType & BEWEGUNG_LAUFEN) )
+            {
+                return 0;
+            }
+            if( modified && getCurrentBe() > 1 )
+                return 1;
+            
+            return 2;
+        }
+
+
+        if( movementType & BEWEGUNG_RENNEN )
+        {
+            velocity = act_gs;
+        }
+        else if( movementType & BEWEGUNG_LAUFEN )
+        {
+            velocity = act_gs / 2.5;
+        }
+        else if( movementType & BEWEGUNG_JOGGEN )
+        {
+            velocity = act_gs / 2.0;
+        }
+        else if( movementType & BEWEGUNG_GEHEN )
+        {
+            velocity = act_gs / 3.6;
+        }
+        else
+        {
+            velocity = 0;
+        }
+        return velocity;
+    }
+
+
+
+    float Creature::doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis, int modifikatoren)
+    {
+        // damit bei einem Sprint immer nur eine Probe gemacht wird!
+        static float lastProbeTaW = 0;
+        static int lastProbeTime = 0;
+        static int lastMovementType = 0;
+        lastProbeTaW -= time;
+        bool movementTypeChanged = false;
+        if( movementType != lastMovementType ) // das System l??sst sich durch Zwischendurch nicht rennen austricksen!!!!
+            movementTypeChanged = true;
+        lastMovementType = movementType;
+        
+        const int regenerateAuModifier_Gehen = 2;
+        const float regenerateAuFactor_Gehen = 0.5;
+        const int regenerateAuModifier_Stehen = 1;
+        const float regenerateAuFactor_Stehen = 0.75;
+
+
+
+
+        float velocity = getTaktischeGeschwindigkeitsBasis(movementType, true, modifikatoren);
+
+
+        setTaktischeBewegung(movementType);
+
+        
+
+
+        if( movementType & BEWEGUNG_DREHEN )
+        {
+            return velocity;
+        }
+
+
+
+        if( movementType & BEWEGUNG_SCHLEICHEN )
+        {
+//
+/*
+            try // schleichen wirklich hier machen?
+            {
+                patzer = doTalentprobe("Schleichen", probenErschwernis);
+            }
+            catch(OutOfRangeException err)
+            {
+                patzer = RESULT_MISSERFOLG;
+            }
+*/
+            return velocity;
+        }
+        else if( movementType & BEWEGUNG_WEITSPRUNG )
+        {
+            try
+            {
+                patzer = doTalentprobe("Athletik", probenErschwernis);
+                if( patzer > 0 )
+                {
+                    if( patzer == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") / 25.0;
+                    }
+                    else if( patzer == RESULT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") / 50.0;
+                    }
+                    else
+                    {
+                        velocity += patzer / 50.0;
+                    }
+                }
+            }
+            catch(OutOfRangeException err)
+            {
+                patzer = 0;
+            }
+            // Ausdauerverbrauch: eigentlich 1, aber ich denke das ist zu hoch
+            damageAu(1./3);
+            return velocity;
+        }
+        else if( movementType & BEWEGUNG_HOCHSPRUNG )
+        {
+            try
+            {
+                patzer = doTalentprobe("Athletik", probenErschwernis);
+                if( patzer > 0 )
+                {
+                    if( patzer == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") / 12.5;
+                    }
+                    else if( patzer == RESULT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") / 25.0;
+                    }
+                    else
+                    {
+                        velocity += patzer / 25.0;
+                    }
+                }
+            }
+            catch(OutOfRangeException err)
+            {
+                patzer = 0;
+            }
+            // Ausdauerverbrauch:
+            damageAu(2./3);
+            return velocity;
+        }
+
+
+        if( movementType & BEWEGUNG_RUECKWAERTS )
+        {
+            if( movementType & BEWEGUNG_RENNEN || 
+                movementType & BEWEGUNG_LAUFEN ||
+                movementType & BEWEGUNG_JOGGEN )
+            {
+            }
+            else if( movementType & BEWEGUNG_GEHEN )
+            {
+            }
+            return velocity;
+        }
+        else if( movementType & BEWEGUNG_SEITWAERTS )
+        {
+            if( movementType & BEWEGUNG_RENNEN || 
+                movementType & BEWEGUNG_LAUFEN ||
+                movementType & BEWEGUNG_JOGGEN )
+            {
+            }
+            else if( movementType & BEWEGUNG_GEHEN )
+            {
+            }
+            
+            return velocity;
+        }
+
+
+
+        if( movementType & BEWEGUNG_RENNEN )
+        {
+            // f??r Rennen Athletik-probe -> h??here Geschwindigkeit
+            try
+            {
+                if( lastProbeTime <= 0 || movementTypeChanged)
+                {
+                    lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
+                    patzer = lastProbeTaW;
+                    lastProbeTime = getAuMax();
+                }
+                else
+                {
+                    // wird nur einmal angerechnet ?
+                    patzer = 0;
+                }
+                if( lastProbeTaW > 0 )
+                {
+                    if( lastProbeTaW == RESULT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") * 0.2;
+                    }
+                    else if( lastProbeTaW == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        velocity += getTalent("Athletik") * 0.3;
+                    }
+                    else
+                    {
+                        velocity += lastProbeTaW;
+                    }
+                }
+                damageAu(time/1.5);
+            }
+            catch(OutOfRangeException err)
+            {
+                patzer = 0;
+            }
+        }
+        else if( movementType & BEWEGUNG_LAUFEN )
+        {
+            // f??r Laufen, Athletik-Probe weniger Ausdauer-Verbrauch
+            float timePerAu = 180;
+            try
+            {
+                if( lastProbeTime <= 0 || movementTypeChanged )
+                {
+                    lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
+                    patzer = lastProbeTime;
+                    lastProbeTime = Date::ONE_SPIELRUNDE;
+                }
+                else
+                {
+                    // wird nur einmal angerechnet ?
+                    patzer = 0;
+                }
+                if( lastProbeTaW > 0 )
+                {
+                    if( lastProbeTaW == RESULT_AUTOERFOLG )
+                    {
+                        timePerAu += getTalent("Athletik") * 5;
+                    }
+                    else if( lastProbeTime == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        timePerAu += getTalent("Athletik") * 10;
+                    }
+                    else
+                    {
+                        timePerAu += lastProbeTaW * 5;
+                    }
+                }
+                damageAu(time/timePerAu);
+            }
+            catch(OutOfRangeException err)
+            {
+                patzer = 0;
+            }
+        }
+        else if( movementType & BEWEGUNG_JOGGEN )
+        {
+        }
+        else if( movementType & BEWEGUNG_GEHEN )
+        {
+            regenerateAu(regenerateAuModifier_Gehen, regenerateAuFactor_Gehen, time);
+        }
+        else
+        {
+            // rumstehen
+            regenerateAu(regenerateAuModifier_Stehen, regenerateAuFactor_Stehen, time);
+        }
+
+        return velocity;
+    }
+
+
 }



From melven at mail.berlios.de  Sun Mar  4 19:53:00 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 4 Mar 2007 19:53:00 +0100
Subject: [Dsa-hl-svn] r3117 - in rl/trunk/engine/ui: include src
Message-ID: <200703041853.l24Ir0BF009491@sheep.berlios.de>

Author: melven
Date: 2007-03-04 19:52:38 +0100 (Sun, 04 Mar 2007)
New Revision: 3117

Modified:
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
New features in FreeFlightCharacterController: collisions can be enabled, the char can be put at the camera position

New features in MovementCharacterController:
strafing+forward/backward, 
uses now the methods of creature to determine the movement-velocity etc,
jumping-length is correct
aup works


Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-03-04 18:43:42 UTC (rev 3116)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-03-04 18:52:38 UTC (rev 3117)
@@ -19,6 +19,8 @@
 
 #include "UiPrerequisites.h"
 #include "CharacterController.h"
+#include "PhysicsController.h"
+#include "PhysicsGenericContactCallback.h"
 #include <OgreNewt.h>
 
 namespace rl {
@@ -26,7 +28,10 @@
 	/**
 	* This class provides a no-clip free fly controller.
 	*/
-	class _RlUiExport FreeFlightCharacterController : public CharacterController
+	class _RlUiExport FreeFlightCharacterController : 
+        public CharacterController,
+        public PhysicsController,
+        public PhysicsGenericContactCallback
 	{
 	public:
 		/**
@@ -43,8 +48,15 @@
 		void resetCamera();
 
 		bool injectKeyDown(int keycode);
-		bool injectKeyUp(int keycode);		
+		bool injectKeyUp(int keycode);
 
+        /// This is the OgreNewt contact process callback for the combination
+        /// Character <-> Level
+        int userProcess();
+
+        /// Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing* thing);
+
 	private:		
 		int mCurrentMovementState;
 
@@ -52,8 +64,13 @@
 		std::pair<Ogre::Real, Ogre::Real> mSpeedRange;
 		Ogre::Real mSpeedIncrement;
 		Ogre::Real mRotationSpeed;
-
-		Ogre::Camera* mOgreCam;
+        Ogre::Vector3 mDesiredVelocity;
+        Ogre::Degree mPitch;
+        Ogre::Degree mYaw;
+        bool mCollisionsEnabled;
+        Ogre::Real mMouseSensitivity;
+        bool mInvertedMouse;
+        std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-04 18:43:42 UTC (rev 3116)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-04 18:52:38 UTC (rev 3117)
@@ -89,12 +89,15 @@
 		/// private struct for holding state info of the controller
 		struct CharacterState
 		{
-            typedef enum {Stand, Crouch, StandToCrouch, CrouchToStand, Falling, Jumping, StartJump, EndJump} Pose;
+            //typedef enum {Stand, Crouch, StandToCrouch, CrouchToStand, Falling, Jumping, StartJump, EndJump} Pose;
 			CharacterState();
-            Pose mPose;
+            //Pose mPose;
 			bool mIsAirBorne;
             bool mHasFloorContact;
-			bool mStartJump;
+			//bool mStartJumpLong;
+            //bool mStartJumpHigh;
+            bool mStartJump;
+            Ogre::Real mJumpWidthHeight;
 
 			Ogre::Real mJumpTimer;
 
@@ -115,7 +118,9 @@
         std::pair<Ogre::Real, Ogre::Real> mDistanceRange;
         Ogre::Degree mYaw;
         Ogre::Degree mCamYaw; // f?r VM_FREE_CAMERA
+        Ogre::Degree mCamVirtualYaw; // helps to simulate strafe+forward/backward movement
         Ogre::Degree mPitch;
+        Ogre::Degree mRoll;
         std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
 
         Ogre::Vector3 mLookAtOffset;
@@ -152,9 +157,10 @@
         Ogre::Radian mCamMoveAwayRange;
 
         void updateSelection();
-        void updateCharacterState(int movement, Ogre::Real elapsedTime);
+        //void updateCharacterState(int movement, Ogre::Real elapsedTime);
+        void updateCharacterState(Ogre::Real elapsedTime);
         void updateCameraLookAt(Ogre::Real elapsedTime);
-        void updateAnimationState(int &movement); // this can also modify movement, if needed
+        //void updateAnimationState(int &movement); // this can also modify movement, if needed
 
         void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
 

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-04 18:43:42 UTC (rev 3116)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-04 18:52:38 UTC (rev 3117)
@@ -16,6 +16,7 @@
 
 #include "FreeFlightCharacterController.h"
 #include "CoreSubsystem.h"
+#include "ConfigurationManager.h"
 #include "Exception.h"
 #include "Actor.h"
 #include "PhysicalThing.h"
@@ -33,22 +34,34 @@
 
 	FreeFlightCharacterController::FreeFlightCharacterController(Actor* camera, Actor* character)
 		: CharacterController(camera, character),
-		mMovementSpeed(30.0f),
+		mMovementSpeed(5.0f),
 		mSpeedRange(0.03f, 90.0f),
 		mSpeedIncrement(0.02f),
 		mRotationSpeed(4.0f),
-		mOgreCam(0),
-		mCurrentMovementState(0)
+		mCurrentMovementState(0),
+        mDesiredVelocity(Vector3::ZERO),
+        mCollisionsEnabled(false),
+        mPitch(Degree(0)),
+        mYaw(Degree(0)),
+        mPitchRange(Degree(-89), Degree(89))
 	{
-		mCameraActor->getPhysicalThing()->freeze();
+		//mCameraActor->getPhysicalThing()->freeze();
 		mCharacterActor->getPhysicalThing()->freeze();
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(ConfigurationManager::CS_INPUT, "Mouse Sensitivity");
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(ConfigurationManager::CS_INPUT, "Mouse Invert");
 
+
 		resetCamera();
-		mOgreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
-        mOgreCam->setPosition(Vector3::ZERO);
-		mOgreCam->setOrientation(Quaternion::IDENTITY);
-		mOgreCam->setFixedYawAxis(true);
 
+
+        // The actor should be controlled manually,
+        // so let the PM prepare it accordingly
+        PhysicsManager::getSingleton().setPhysicsController(
+            mCameraActor->getPhysicalThing(), this);
+        // We also handle char<->level, char<->default collision from now on (camera=char!)
+        PhysicsManager::getSingleton().setCharLevelContactCallback(this);
+        PhysicsManager::getSingleton().setCharDefaultContactCallback(this);
+
 		MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
         if( mesh != NULL )
         {
@@ -59,7 +72,7 @@
 
 	FreeFlightCharacterController::~FreeFlightCharacterController()
 	{
-		mCameraActor->getPhysicalThing()->unfreeze();
+		//mCameraActor->getPhysicalThing()->unfreeze();
 		mCharacterActor->getPhysicalThing()->unfreeze();
 	}
 
@@ -73,36 +86,48 @@
 		InputManager* im = InputManager::getSingletonPtr();
 
 		// Fetch current movement state
-		Vector3 translation = Vector3::ZERO;
+		mDesiredVelocity = Vector3::ZERO;
 
 		int movement = mCurrentMovementState;
 
 		// Determine character's control state based on user input
 		if (movement & MOVE_FORWARD)
         {
-			translation.z = -mMovementSpeed;
+			mDesiredVelocity.z = -mMovementSpeed;
         }
 
 		if (movement & MOVE_BACKWARD)
         {
-            translation.z = mMovementSpeed;
+            mDesiredVelocity.z = mMovementSpeed;
         }
 
 		if (movement & MOVE_RIGHT)
         {
-			translation.x = mMovementSpeed;
+			mDesiredVelocity.x = mMovementSpeed;
         }
 
 		if (movement & MOVE_LEFT)
         {
-			translation.x = -mMovementSpeed;
+			mDesiredVelocity.x = -mMovementSpeed;
         }
 
 		if (movement & MOVE_RUN)
         {
-			translation *= 4.0;
+			mDesiredVelocity *= 10.0;
         }
 
+        if (movement & MOVE_JUMP)
+        {
+            // put character here
+            if( mCharacterActor != NULL )
+            {
+                mCharacterActor->setPosition(
+                    mCameraActor->getPosition()
+                    + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2 
+                    - 1.5 * Vector3::UNIT_Y);
+            }
+        }
+
 		mMovementSpeed += im->getMouseRelativeZ() * mSpeedIncrement;
 		if (mMovementSpeed < mSpeedRange.first)
 		{
@@ -113,25 +138,50 @@
 			mMovementSpeed = mSpeedRange.second;
 		}
 
-		Radian pitch = Degree(-im->getMouseRelativeY() * 30.0 * elapsedTime);
-		Radian yaw = Degree(-im->getMouseRelativeX() * 30.0 * elapsedTime);
 
-		mOgreCam->yaw(yaw);
-		mOgreCam->pitch(pitch);
-		mOgreCam->moveRelative(translation*elapsedTime);
-	}
+        if (movement & TURN_LEFT)
+            mYaw += elapsedTime * Degree(120.0f);
+        if (movement & TURN_RIGHT)
+            mYaw -= elapsedTime * Degree(120.0f);
 
+        // mouse
+        if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+        {
+            Degree rotation = mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
+
+            mYaw -= rotation;
+
+            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
+            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
+        }
+
+
+        if (mInvertedMouse)
+            mPitch += mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+        else
+            mPitch -= mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+
+        while (mPitch.valueDegrees() > 360.0f) mPitch -= Degree(360.0f);
+        while (mPitch.valueDegrees() < -360.0f) mPitch += Degree(360.0f);
+        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+    }
+
 	void FreeFlightCharacterController::toggleViewMode()
 	{
-		// Gibbet keine.
+		// with or without collision?
+        // be careful to enable collision if beeing in another collision
+        mCollisionsEnabled = !mCollisionsEnabled;
 	}
 
 	void FreeFlightCharacterController::resetCamera()
 	{
+        mYaw = Degree(0);
+        mPitch = Degree(0);
 		// Position camera at char position
         if( mCharacterActor != NULL )
         {
-            mCameraActor->_getSceneNode()->setOrientation( mCharacterActor->getWorldOrientation() );
+            mCameraActor->setOrientation(Quaternion::IDENTITY);
             Vector3 newPos = mCharacterActor->getWorldPosition();
             if( mCharacterActor->getControlledObject()->isMeshObject() )
             {
@@ -142,15 +192,18 @@
         }
         else
         {
-		    mCameraActor->_getSceneNode()->setOrientation( Quaternion::IDENTITY );
-            mCameraActor->_getSceneNode()->setPosition( Vector3::ZERO );
+		    mCameraActor->setOrientation( Quaternion::IDENTITY );
+            mCameraActor->setPosition( Vector3::ZERO );
         }
 	}
 
 	bool FreeFlightCharacterController::injectKeyDown(int keycode)
 	{
-		int movement = mCommandMapper->getMovement(keycode);
+        int scancode;
+        mCommandMapper->decodeKey(keycode, &scancode, NULL);
+        int movement = mCommandMapper->getMovement(scancode);
 
+
 		if (movement != MOVE_NONE)
 		{
 			mCurrentMovementState |= movement;
@@ -161,7 +214,9 @@
 
 	bool FreeFlightCharacterController::injectKeyUp(int keycode)
 	{
-		int movement = mCommandMapper->getMovement(keycode);
+        int scancode;
+        mCommandMapper->decodeKey(keycode, &scancode, NULL);
+        int movement = mCommandMapper->getMovement(scancode);
 
 		if (movement != MOVE_NONE)
 		{
@@ -175,4 +230,62 @@
 			
 		return false;
 	}
+
+
+    int FreeFlightCharacterController::userProcess()
+    {
+        if (m_body0 == mCamBody || m_body1 == mCamBody)
+        {
+            // this is camera collision
+
+            if( !mCollisionsEnabled )
+                return 0;
+
+            setContactSoftness(1.0f);  // "weiche" Collision
+            setContactElasticity(0.0f);
+
+            return 1;
+        }
+
+        // return one to tell Newton we want to accept this contact
+        return 1;
+    }
+
+
+
+    void FreeFlightCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+        OgreNewt::Body* body = thing->_getBody();
+
+        // Get the current world timestep
+        Real timestep = world->getTimeStep();
+
+        if (body == mCamBody)
+        {
+            // apply camera force
+            Vector3 position;
+            Quaternion orientation;
+            body->getPositionOrientation(position, orientation);
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            body->getMassMatrix(mass, inertia);
+
+
+            // Get the velocity vector
+            Vector3 currentVel = body->getVelocity();
+            Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
+            Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
+
+            body->setForce(force);
+
+
+            mCameraActor->setOrientation(Quaternion::IDENTITY);
+            mCameraActor->yaw(mYaw.valueDegrees());
+            mCameraActor->pitch(mPitch.valueDegrees());
+        }
+    }
+
 }

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-04 18:43:42 UTC (rev 3116)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-04 18:52:38 UTC (rev 3117)
@@ -59,11 +59,11 @@
         : mIsAirBorne(false),
         mHasFloorContact(false),
         mStartJump(false),
+        mJumpWidthHeight(0),
         mJumpTimer(0.0),
         mDesiredVel(Vector3::ZERO),
         mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE),
-        mPose(Stand)
+        mLastMovementState(MOVE_NONE)
     {
 
     }
@@ -76,7 +76,9 @@
         mDistanceRange(0.60, 7.00),
         mYaw(0),
         mCamYaw(0),
+        mCamVirtualYaw(0),
         mPitch(20),
+        mRoll(0),
         mPitchRange(Degree(-75), Degree(85)),
         mLinearSpringK(400.0f),
         mLinearDampingK(Math::NEG_INFINITY),
@@ -121,7 +123,7 @@
             mCharacterActor->getControlledObject());
         AxisAlignedBox aabb = charMesh->getDefaultSize();
 
-        // wird sp???er neu berechnet in calculateOptimalCameraPosition
+        // wird sp?ter neu berechnet in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
         // The actor should be controlled manually,
@@ -188,25 +190,14 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::run(Real elapsedTime)
     {
-        int movement = mCharacterState.mCurrentMovementState;
-        updateAnimationState(movement);
-        updateCharacterState(movement, elapsedTime);
+        //int movement = mCharacterState.mCurrentMovementState;
+        //updateAnimationState(movement); // lasse updateAnimationState das ?ndern
+        //updateCharacterState(movement, elapsedTime);
+        updateCharacterState(elapsedTime);
         updateCameraLookAt(elapsedTime);
         updateSelection();
 
 
-        // Do we need to reset the character?
-        static Real charAnimationOccTime = 0;
-        charAnimationOccTime += elapsedTime;
-        if( mCharacterState.mPose != CharacterState::Stand &&
-            mCharacterState.mPose != CharacterState::Crouch )
-        {
-            if( charAnimationOccTime > 10.0f ) // mehr als ... sekunden!
-                mCharacterState.mPose = CharacterState::Stand;
-        }
-        else
-            charAnimationOccTime = 0;
-
         // Do we need to reset the Camera?
         Vector3 charPos = mCharacterActor->getWorldPosition();
         Quaternion charOri = mCharacterActor->getWorldOrientation();
@@ -245,166 +236,509 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::updateCharacterState(int movement, Ogre::Real elapsedTime)
+    void MovementCharacterController::updateCharacterState(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
+        mCharacterState.mDesiredVel = Vector3::ZERO;
+        int patzer = 0;
+        int movement = mCharacterState.mCurrentMovementState;
+        int creatureMovement = mCharacter->getTaktischeBewegung();
+        bool blockMovement (false);
+
+
+
+
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        PhysicalThing* pt = mCharacterActor->getPhysicalThing();
+        static std::string lastAnimation("");
+        std::string newAnimation("idle");
+        Real animSpeed = 1;
+        static Real lastSpeed = 1;
+        unsigned int animTimesToPlay = 0;
         Real gs = mCharacter->getWert(Creature::WERT_GS);
-        Real auPerSecond = 0.0; // Standard - Ausdauer-verbrauch/Regeneration pro Sekunde
-        bool canRun = mCharacter->getAu() > 6.0f;
-        Radian rotationSpeed = mRotationSpeed * gs / 6.0f; // <-- arme Zwerge? aber wenn gs sinkt sollte das auch sinken!
+        static String lastCollisionPose = "";
+        String collisionPose = "idle";
 
-        if (mCharacterState.mPose == CharacterState::StartJump ||
-            mCharacterState.mPose == CharacterState::Jumping ||
-            mCharacterState.mPose == CharacterState::EndJump)
-            ; // do nothing, old mDesiredVel!!
-        else
-            mCharacterState.mDesiredVel = Vector3::ZERO;
+        // the different factors used to calculate the animation-speed from the character-speed
+        const Real factor_hocke_gehen = 0.7;
+        const Real factor_drehen_idle = 0.6;
+        const Real factor_gehen = 0.5;
+        const Real factor_gehen_rueckwaerts = 0.7;
+        const Real factor_rennen = 0.25;
+        const Real factor_rennen_absprung = 0.25;
+        const Real factor_rennen_sprung_landung = 0.6;
+        const Real factor_rennen_sprung = 0.25;
+        const Real factor_gehen_seitwaerts = 0.9;
 
-        if (mCharacterState.mPose == CharacterState::Stand)
+
+
+
+        Vector3 charVelocity, charOmega;
+        charOmega = mCharBody->getOmega();
+        charVelocity = mCharBody->getVelocity();
+        Real vel = charVelocity.length();
+
+
+
+
+        //  --------------------------- sneaking-behaviour ----------------------------
         {
-            // Sprnge werden von updateAnimationStat geregelt
+            static bool beginSneak (false);
+            static bool endSneak (false);
+            
+            if( (!(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
+                movement & MOVE_SNEAK) || 
+                beginSneak )
+            {
+                beginSneak = true;
+            }
+            if( (!(movement & MOVE_SNEAK) && 
+                creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) || 
+                endSneak)
+            {
+                endSneak = true;
+            }
 
-            // Rckw???ts gehen oder laufen
-            if ( movement & MOVE_BACKWARD && !(movement & MOVE_FORWARD) )
+            if( beginSneak )
             {
-                if( movement & MOVE_RUN_LOCK ) // Rckw???ts joggen
+                newAnimation = "idle_zu_hocke";
+
+                MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
+                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 2.0;
+                    creatureMovement |= Creature::BEWEGUNG_SCHLEICHEN;
+                    mCharacter->setTaktischeBewegung(creatureMovement);
+                    beginSneak = false;
                 }
                 else
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 3.6;
+                    collisionPose = "idle";
+                    animTimesToPlay = 1;
+                    blockMovement = true;
+
+                    mCharacter->doTaktischeBewegung(Creature::BEWEGUNG_NONE, elapsedTime, patzer);
                 }
+
+                // interpolate camera offset
+                Real factor = meshAnim->getTimePlayed() / meshAnim->getLength();
+                interpolateAnimationLookAtOffset("idle", "hocke_idle", factor);
             }
-            else if ( movement & MOVE_FORWARD ) // Vorw???tsbewegung
+
+            if( creatureMovement & Creature::BEWEGUNG_SCHLEICHEN )
             {
-                if( movement & MOVE_RUN && movement & MOVE_RUN_LOCK ) // sprinten
+                newAnimation = "hocke_idle";
+                collisionPose = newAnimation;
+            }
+
+            if( endSneak )
+            {
+                creatureMovement &= ~Creature::BEWEGUNG_SCHLEICHEN;
+                mCharacter->setTaktischeBewegung(creatureMovement);
+                newAnimation = "hocke_zu_stehen";
+
+
+                MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
+                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,-1) * gs;
+                    newAnimation = "idle";
+                    endSneak = false;
                 }
-                else if( movement & MOVE_RUN && !(movement & MOVE_RUN_LOCK) ) // gehen
+                else
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,-1) * gs / 3.6f;
+                    collisionPose = "idle";
+                    animTimesToPlay = 1;
+                    blockMovement = true;
+
+                    mCharacter->doTaktischeBewegung(Creature::BEWEGUNG_NONE, elapsedTime, patzer);
                 }
-                else if( movement & MOVE_RUN_LOCK ) // laufen
+
+                // interpolate camera-offset
+                Real factor = meshAnim->getTimePlayed() / meshAnim->getLength();
+                interpolateAnimationLookAtOffset("hocke_idle", "idle", factor);
+            }
+        }
+        //  --------------------------- sneaking-behaviour -------------------------
+
+
+
+
+
+        // ------------------ walking, jogging, running etc ------------------------
+        if( !blockMovement )
+        {
+
+            int newCreatureMovement = 
+                creatureMovement & ~
+                    (Creature::BEWEGUNG_RENNEN |
+                    Creature::BEWEGUNG_LAUFEN | 
+                    Creature::BEWEGUNG_JOGGEN |
+                    Creature::BEWEGUNG_GEHEN | 
+                    Creature::BEWEGUNG_RUECKWAERTS |
+                    Creature::BEWEGUNG_SEITWAERTS |
+                    Creature::BEWEGUNG_DREHEN |
+                    Creature::BEWEGUNG_UMDREHEN
+                    );
+
+            if( movement & MOVE_RUN && movement & MOVE_RUN_LOCK )
+                newCreatureMovement |= Creature::BEWEGUNG_RENNEN;
+            else if( movement & MOVE_RUN_LOCK )
+                newCreatureMovement |= Creature::BEWEGUNG_LAUFEN;
+            else if( !(movement & MOVE_RUN) )
+                newCreatureMovement |= Creature::BEWEGUNG_JOGGEN;
+            else
+                newCreatureMovement |= Creature::BEWEGUNG_GEHEN;
+
+            if( movement & MOVE_FORWARD )
+                ;
+            else if( movement & MOVE_BACKWARD )
+                newCreatureMovement |= Creature::BEWEGUNG_RUECKWAERTS;
+            else if( movement & MOVE_RIGHT || movement & MOVE_LEFT )
+                newCreatureMovement |= Creature::BEWEGUNG_SEITWAERTS;
+
+
+            // check if new Movement is possible
+            if( newCreatureMovement & Creature::BEWEGUNG_RENNEN )
+            {
+                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,-1) * gs / 2.0f;
+                    newCreatureMovement &= ~Creature::BEWEGUNG_RENNEN;
+                    newCreatureMovement |= Creature::BEWEGUNG_LAUFEN;
                 }
-                else // joggen
+            }
+
+            if( newCreatureMovement & Creature::BEWEGUNG_LAUFEN )
+            {
+                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
                 {
-                    mCharacterState.mDesiredVel = Vector3(0,0,-1) * gs / 2.5f;
+                    newCreatureMovement &= ~Creature::BEWEGUNG_LAUFEN;
+                    newCreatureMovement |= Creature::BEWEGUNG_JOGGEN;
                 }
             }
-            else if( movement & MOVE_LEFT )
+            
+            if( newCreatureMovement & Creature::BEWEGUNG_JOGGEN )
             {
-                mCharacterState.mDesiredVel = Vector3(-1,0,0) * gs / 3.6;
+                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
+                {
+                    newCreatureMovement &= ~Creature::BEWEGUNG_JOGGEN;
+                    newCreatureMovement |= Creature::BEWEGUNG_GEHEN;
+                }
             }
-            else if( movement & MOVE_RIGHT )
+            
+            if( newCreatureMovement & Creature::BEWEGUNG_GEHEN )
             {
-                mCharacterState.mDesiredVel = Vector3(1,0,0) * gs / 3.6;
+                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
+                {
+                    // character exhausted?
+                    blockMovement = true;
+                    newAnimation = "idle";
+                    newCreatureMovement &= ~Creature::BEWEGUNG_GEHEN;
+                    newCreatureMovement |= Creature::BEWEGUNG_NONE;
+                    mCharacter->doTaktischeBewegung(newCreatureMovement, elapsedTime, patzer);
+                }
             }
 
-            if (movement & TURN_LEFT)  mYaw += rotationSpeed*elapsedTime;
-            if (movement & TURN_RIGHT) mYaw -= rotationSpeed*elapsedTime;
+            if( !blockMovement )
+            {
+                mCharacterState.mDesiredVel = Vector3::ZERO;
 
+                // not handled movements:
+                if( movement & MOVE_FORWARD && movement & MOVE_BACKWARD ||
+                    movement & MOVE_LEFT && movement & MOVE_RIGHT )
+                {
+                }
+                else if( (movement & MOVE_FORWARD || movement & MOVE_BACKWARD) && // this also handles strafe+forward/backward
+                         (newCreatureMovement & Creature::BEWEGUNG_LAUFEN ||
+                          newCreatureMovement & Creature::BEWEGUNG_JOGGEN ||
+                          newCreatureMovement & Creature::BEWEGUNG_RENNEN ) )
+                {
+                    newAnimation = "rennen";
+                    if( movement & MOVE_FORWARD )
+                    {
+                        mCharacterState.mDesiredVel.z = -1;
+                        animSpeed = factor_rennen;
+                    }
+                    else
+                    {
+                        mCharacterState.mDesiredVel.z = 1;
+                        animSpeed = -factor_rennen;
+                    }
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    newAnimation = "gehen";
+                    animSpeed = factor_gehen;
+                    mCharacterState.mDesiredVel.z = -1;
+                }
+                else if( movement & MOVE_BACKWARD )
+                {
+                    newAnimation = "gehen_rueckwaerts";
+                    animSpeed = factor_gehen_rueckwaerts;
+                    mCharacterState.mDesiredVel.z = 1;
+                }
+                else if( movement & MOVE_LEFT )
+                {
+                    newAnimation = "seitwaerts_links";
+                    animSpeed = factor_gehen_seitwaerts;
+                    mCharacterState.mDesiredVel.x = -1;
+                }
+                else if( movement & MOVE_RIGHT )
+                {
+                    newAnimation = "seitwaerts_rechts";
+                    animSpeed = factor_gehen_seitwaerts;
+                    mCharacterState.mDesiredVel.x = 1;
+                }
 
-        }
-        else if (mCharacterState.mPose == CharacterState::Crouch)
-        {
-            if (movement & MOVE_FORWARD)
-                mCharacterState.mDesiredVel.z = -0.5 * gs / 3.6;
-            rotationSpeed *= 0.6;
 
-            if (movement & TURN_LEFT)  mYaw += rotationSpeed*elapsedTime;
-            if (movement & TURN_RIGHT) mYaw -= rotationSpeed*elapsedTime;
 
-        }
 
-/*
-// soll dafr sorgen, dass er auf dem
-// Boden bleibt und ber kleine Hindernisse kommt
+                // ---------- jumping-behaviour (and falling?) ---------
+                {
 
-Quaternion orientation = mCharacterActor->getWorldOrientation();
-Vector3 position = mCharacterActor->getWorldPosition();
-Vector3 delta(0,0.05,0);
-position += delta;
-Real stepHeight = 0.5;
-Real stepWidth = 0.3;
-Vector3 dirVector = stepWidth*mCharacterState.mDesiredVel;
-dirVector.y = stepHeight;
-RaycastInfo info;
-Vector3 relCollPos;
-do
-{
-    // Raycast in Bewegungsrichtung
-    info = mRaycast->execute(
-        PhysicsManager::getSingleton()._getNewtonWorld(),
-        mCharBody->getMaterialGroupID(),
-        position, position + orientation * dirVector,
-        true);
-    if( info.mBody )
-    {
-        relCollPos = (info.mDistance * 1.1) * dirVector.normalisedCopy();
-        dirVector.y += 0.1;
-        break;
-    }
-    dirVector.y -= 0.2;
-}
-while( dirVector.y > -stepHeight );
+                    static bool beginJump (false);
+                    static bool endJump (false);
+                    static enum {HOCHSPRUNG, WEITSPRUNG /*, PRAEZISER_SPRUNG*/}
+                        jumpType;
 
-// kann das Hindernis berwunden werden:
-dirVector = relCollPos;
-while( dirVector.y <= stepHeight )
-{
-    info = mRaycast->execute(
-        PhysicsManager::getSingleton()._getNewtonWorld(),
-        mCharBody->getMaterialGroupID(),
-        position, position + orientation * dirVector,
-        true);
-    if( info.mBody )
-    {
-        break;
-    }
-    dirVector.y += 0.1;
-}
 
-// linie an der angegebenen Stelle anzeigen
-LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-if(lineSet != NULL)
-{
-    lineSet->clear();
-    lineSet->addLine(delta, delta+dirVector, ColourValue::Blue);
-    lineSet->addLine(delta+dirVector, delta+2*dirVector, ColourValue::Red);
-    lineSet->addLine(delta, delta-dirVector, ColourValue::Red);
-    lineSet->addLine(delta, delta+relCollPos, ColourValue::White);
-}
+                    if( !(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
+                        !blockMovement && !beginJump &&
+                        !(creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG) &&
+                        !(creatureMovement & Creature::BEWEGUNG_WEITSPRUNG) &&
+                        movement & MOVE_JUMP)
+                    {
+                        if( mCharacterState.mDesiredVel.squaredLength() > 0 )
+                        {
+                            jumpType = WEITSPRUNG;
+                            if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG) )
+                            {
+                                beginJump = true;
+                                Real jumpWidth = 
+                                    mCharacter->doTaktischeBewegung(
+                                            newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG,
+                                            elapsedTime,
+                                            patzer);
 
-if( dirVector.y < stepHeight && dirVector.y > -stepHeight )
-{
-    mCharacterState.mDesiredVel.y = dirVector.y;
-    // Bremsen wenn bergab:
-    if (dirVector.y < 0)
-    {
-        mCharacterState.mDesiredVel *= (1 + dirVector.y/stepHeight * 0.5);
-    }
-}
-*/
+                                mCharacterState.mJumpWidthHeight = jumpWidth;
+                            }
+                        }
+                        else
+                        {
+                            jumpType = HOCHSPRUNG;
+                            if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG) )
+                            {
+                                beginJump = true;
+                                Real jumpHeight = 
+                                    mCharacter->doTaktischeBewegung(
+                                            newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG,
+                                            elapsedTime,
+                                            patzer);
 
+                                mCharacterState.mJumpWidthHeight = jumpHeight;
+                            }
+                        }
+                    }
 
 
+                    if( (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
+                        creatureMovement & Creature::BEWEGUNG_WEITSPRUNG  ) &&
+                        !beginJump )
+                    {
+                        if( !mCharacterState.mIsAirBorne )
+                            endJump = true;
+                    }
 
 
 
+                    
+                    Real timeJumpKeyPressed (0.0);
+                    if( !beginJump )
+                        timeJumpKeyPressed = 0;
+                    else if( movement & MOVE_JUMP && 
+                        (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
+                        creatureMovement & Creature::BEWEGUNG_WEITSPRUNG ) )
+                        timeJumpKeyPressed += elapsedTime;
 
 
-        mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-        if (mDesiredDistance < mDistanceRange.first)
-        {
-            mDesiredDistance = mDistanceRange.first;
+
+                    if( beginJump )
+                    {
+                        blockMovement = true;
+                        if( jumpType == WEITSPRUNG )
+                        {
+                            newAnimation = "rennen_absprung";
+                            animSpeed = factor_rennen_sprung * vel;
+                        }
+                        else // HOCHSPRUNG
+                        {
+                            newAnimation = "idle_absprung";
+                        }
+                        animTimesToPlay = 1;
+                        
+
+                        MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
+                        if (meshAnim->getTimePlayed() >= meshAnim->getLength())
+                        {
+                            mCharacterState.mStartJump = true;
+                            if( timeJumpKeyPressed > 0.5 )
+                            mCharacterState.mJumpWidthHeight *= timeJumpKeyPressed / meshAnim->getLength();
+                            beginJump = false;
+                        }
+                    }
+                    else // !beginJump
+                    {
+                        if( creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG )
+                        {
+                            blockMovement = true;
+                            newAnimation = "idle_sprung";
+                        }
+                        else
+                        if( creatureMovement & Creature::BEWEGUNG_WEITSPRUNG )
+                        {
+                            blockMovement = true;
+                            newAnimation = "rennen_sprung";
+                            animSpeed = vel * factor_rennen_sprung;
+                        }
+                    }
+
+                    if( endJump )
+                    {
+                        blockMovement = true;
+                        if( creatureMovement & Creature::BEWEGUNG_WEITSPRUNG )
+                        {
+                            newAnimation = "rennen_sprung_landung";
+                            animSpeed = factor_rennen_sprung * vel;
+                        }
+                        else // HOCHSPRUNG
+                        {
+                            newAnimation = "idle_sprung_landung";
+                        }
+                        animTimesToPlay = 1;
+                        
+
+                        MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
+                        if (meshAnim->getTimePlayed() >= meshAnim->getLength())
+                        {
+                            endJump = false;
+                            creatureMovement &= ~Creature::BEWEGUNG_HOCHSPRUNG & ~Creature::BEWEGUNG_WEITSPRUNG;
+                            mCharacter->setTaktischeBewegung(creatureMovement);
+                        }
+                    }
+
+
+                }
+                // ------ jumping-behaviour ----------
+
+
+
+                // only do something, if the char does not jump
+                if( !blockMovement )
+                {
+                    Real vel;
+                    if( mCharacterState.mDesiredVel.squaredLength() == 0 )
+                    {
+                        newCreatureMovement &= ~(
+                                Creature::BEWEGUNG_RENNEN |
+                                Creature::BEWEGUNG_LAUFEN | 
+                                Creature::BEWEGUNG_JOGGEN |
+                                Creature::BEWEGUNG_GEHEN | 
+                                Creature::BEWEGUNG_RUECKWAERTS |
+                                Creature::BEWEGUNG_SEITWAERTS |
+                                Creature::BEWEGUNG_DREHEN |
+                                Creature::BEWEGUNG_UMDREHEN
+                                );
+                    }
+                    vel = mCharacter->doTaktischeBewegung(newCreatureMovement, elapsedTime, patzer);
+                    creatureMovement = newCreatureMovement;
+                    
+                    mCharacterState.mDesiredVel *= vel;
+                    animSpeed *= vel;
+
+                    // some special cases:
+                    if( newCreatureMovement & Creature::BEWEGUNG_SCHLEICHEN &&
+                        vel > 0 )
+                    {
+                        newAnimation = "hocke_gehen";
+                        animSpeed = vel*factor_hocke_gehen;
+                    }
+                }
+
+
+
+
+                // this simulates going right-forward or left-forward or right/left - backward
+                Degree newCharVirtualYaw (0); 
+                if( (movement & MOVE_FORWARD && movement & MOVE_LEFT) ||
+                    (movement & MOVE_BACKWARD && movement & MOVE_RIGHT) )
+                {
+                    newCharVirtualYaw = Degree(45);
+                }
+                else if( (movement & MOVE_FORWARD && movement & MOVE_RIGHT) ||
+                         (movement & MOVE_BACKWARD && movement & MOVE_LEFT) )
+                {
+                    newCharVirtualYaw = Degree(-45);
+                }
+                else // no strafing
+                {
+                    newCharVirtualYaw = Degree(0);
+                }
+
+                if( newCharVirtualYaw != -mCamVirtualYaw )
+                {
+                    mYaw += mCamVirtualYaw;
+                    mYaw += newCharVirtualYaw;
+                    mCamVirtualYaw = -newCharVirtualYaw;
+                }
+            }
         }
-        if (mDesiredDistance > mDistanceRange.second)
+        // ------------------ walking, jogging, running etc ------------------------
+
+
+
+
+        // ---------------------------- turning + direction changing ---------------
+
+        if( !blockMovement )
         {
-            mDesiredDistance = mDistanceRange.second;
+
+            Degree rotation;
+            // keyboard
+            if (movement & TURN_LEFT)
+                rotation = -elapsedTime * Degree(360.0f) * mCharacter->doTaktischeBewegung(
+                    creatureMovement | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
+            if (movement & TURN_RIGHT)
+                rotation = elapsedTime * Degree(360.0f) * mCharacter->doTaktischeBewegung(
+                    mCharacter->getTaktischeBewegung() | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
+
+            // mouse
+            if( !im->isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+            {
+                if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                {
+                    rotation = mMouseSensitivity/3.0 * Degree(im->getMouseRelativeX());
+
+
+                    if( rotation != Degree(0) || mCharBody->getOmega().squaredLength() > 0.1 )
+                        rotation = rotation * mCharacter->doTaktischeBewegung( 
+                                        mCharacter->getTaktischeBewegung() | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
+                }
+            }
+
+
+            if( mCharacter->getTaktischeBewegung() == Creature::BEWEGUNG_DREHEN &&
+                charOmega.y != 0 )
+            {
+                if( charOmega.y > 0 )
+                    newAnimation = "drehen_links";
+                else
+                    newAnimation = "drehen_rechts";
+                
+                animSpeed = factor_drehen_idle * charOmega.y;
+            }
+
+
+            mYaw -= rotation;
+            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
+            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
         }
 
         if (mInvertedMouse)
@@ -414,24 +748,70 @@
         if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
+        // ---------------------------- turning + direction changing ---------------
 
-        if( !im->isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+
+
+
+
+        // ---------------------------- show animation -----------------------------
+        if (newAnimation != "")
         {
-            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+            // nur schneller nicht langsamer ausf?hren!
+            if (animSpeed < 1) animSpeed = 1;
+
+            if (lastAnimation != newAnimation)
             {
-                mYaw -= mMouseSensitivity / 6.0 * rotationSpeed * Degree(im->getMouseRelativeX() / 15);
+                if (collisionPose != lastCollisionPose)
+                {
+                    pt->fitToPose(collisionPose);
+                    lastCollisionPose = collisionPose;
+                }
+                mesh->stopAllAnimations();
 
-                while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-                while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
+
+                // animations with zero-length can't be played
+                if( newAnimation == "idle_sprung" ||
+                    newAnimation == "rennen_sprung" )
+                {
+                    newAnimation = "idle";
+                    animSpeed = 1;
+                }
+
+
+
+                mesh->startAnimation(newAnimation, animSpeed, animTimesToPlay);
+                lastAnimation = newAnimation;
+                lastSpeed = animSpeed;
             }
+            else
+            {
+                if ( lastSpeed != animSpeed ) // Geschwindigkeits?nderung
+                {
+                    MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
+                    meshAnim->setSpeed(animSpeed);
+                    lastSpeed = animSpeed;
+                }
+            }
         }
+
     }
 
-    //------------------------------------------------------------------------
+
     void MovementCharacterController::updateCameraLookAt(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
 
+        // camera position (distance)
+        mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
+        if (mDesiredDistance < mDistanceRange.first)
+        {
+            mDesiredDistance = mDistanceRange.first;
+        }
+        if (mDesiredDistance > mDistanceRange.second)
+        {
+            mDesiredDistance = mDistanceRange.second;
+        }
 
         if( !im->isCeguiActive() && mViewMode == VM_FREE_CAMERA )
         {
@@ -444,24 +824,25 @@
         SceneNode* cameraNode = mCameraActor->_getSceneNode();
 
         Vector3 charPos;
-        Quaternion charOri;
-        //mCharBody->getPositionOrientation(charPos, charOri);
+        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
         charPos = mCharacterActor->getWorldPosition();
-        charOri = mCharacterActor->getWorldOrientation();
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
+
         if( mViewMode == VM_FIRST_PERSON)
         {
             Quaternion camOri;
             camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
             cameraNode->lookAt(
                 charPos
-                + charOri * mLookAtOffset
-                + charOri * camOri * (-Vector3::UNIT_Z),
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
                 Node::TS_WORLD);
         }
         else if( mViewMode == VM_THIRD_PERSON )
         {
-            // Kamera-Gr???e beziehen
+            // Kamera-Gr??e beziehen
             CameraObject* ogreCam = static_cast<CameraObject*>(
                 mCameraActor->getControlledObject());
             AxisAlignedBox aabb = ogreCam->getDefaultSize();
@@ -469,15 +850,16 @@
             Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
 
             cameraNode->lookAt(
-                charPos    + mLookAtOffset
-                + charOri * (-Vector3::UNIT_Z*radius),
+                charPos
+                + charOri * virtualCamOri *  mLookAtOffset
+                + charOri * virtualCamOri * (-Vector3::UNIT_Z*radius),
                 Node::TS_WORLD);
 
         }
         else if( mViewMode == VM_FREE_CAMERA )
         {
             cameraNode->lookAt(
-                charPos    + mLookAtOffset,
+                charPos + charOri * virtualCamOri * mLookAtOffset,
                 Node::TS_WORLD);
         }
 
@@ -485,6 +867,7 @@
         // Character ausblenden, wenn Kamera zu nah.
         if( mViewMode != VM_FIRST_PERSON )
         {
+            // here the real charOri of the object is needed
             Vector3 charPos;
             Quaternion charOri;
             mCharBody->getPositionOrientation(charPos, charOri);
@@ -541,7 +924,7 @@
             getContactPositionAndNormal(point, normal);
 
             // determine if this contact is with the floor.
-            // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
+            // Meaning the contact normal has an angle to UNIT_Y of 20? or less.
             Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
 
             Vector3 charPos;
@@ -552,7 +935,7 @@
             //if( charPos.y > point.y && angle < Degree(50.0f)  )
             AxisAlignedBox CharAab = mCharBody->getCollision()->getAABB();
             Real CharHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
-            Real stepHeight = point.y - charPos.y; //+ CharHeight / 2.0f;
+            Real stepHeight = point.y - charPos.y;
             if( stepHeight < 0.4f && mCharacterState.mHasFloorContact ||
                 stepHeight < 0.1f )
                 isFloorCollision = true;
@@ -575,10 +958,10 @@
             }
 
 
-            // beinflusst die Sprungh???e!
-            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef???r um
-            // die angegebene Zahl h???er (eher 2*die angegebene Zahl oder so,
-            // vermutlich wieder framedauer abh???gig!)
+            // beinflusst die Sprungh?he!
+            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef?hr um
+            // die angegebene Zahl h?her (eher 2*die angegebene Zahl oder so,
+            // vermutlich wieder framedauer abh?ngig!)
             setContactElasticity(0.3f); // was 0.3f
             setContactSoftness(0.01f);
 
@@ -598,6 +981,11 @@
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing->_getBody();
+        //static Vector3 lastDirVector = Vector3::ZERO;
+        static Vector3 lastForce = Vector3::ZERO;
+        //static bool doCollisionStep = false;
+        //static Vector3 collisionStepPos;
+        //static int curCollisionStep;
 
         // Get the current world timestep
         Real timestep = world->getTimeStep();
@@ -609,7 +997,7 @@
         else
         {
             mCharacterState.mJumpTimer += timestep;
-            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum "Sprung fhren"
+            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum "Sprung f?hren"
             if( !mCharacterState.mHasFloorContact )
                 timeSinceLastFloorContact += timestep;
             else
@@ -641,7 +1029,7 @@
             currentVel.y = 0.0f;
 
             if( (mCharacterState.mHasFloorContact && mCharacterState.mJumpTimer > 0.1f) ||
-                ( timeSinceLastFloorContact < 0.2f && !mCharacterState.mIsAirBorne ) )
+                ( timeSinceLastFloorContact < 2.2f && !mCharacterState.mIsAirBorne ) )
                 mCharacterState.mIsAirBorne = false;
             else
                 mCharacterState.mIsAirBorne = true;
@@ -649,25 +1037,71 @@
 
             if( !mCharacterState.mIsAirBorne )
             {
-                // apply the jump
-                if ( mCharacterState.mStartJump )
+
+                if( mCharacterState.mStartJump )
                 {
-                    mCharacterState.mJumpTimer = 0.0f;
+                    int creatureMovement = mCharacter->getTaktischeBewegung();
+
+                    if( creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG )
+                    {
+                        Real height = mCharacterState.mJumpWidthHeight;
+                        Real m = mass;
+                        Real g = mGravitation.length();
+                        Real t = timestep;
+                        Real h = height;
+                        std::ostringstream os;
+                        os << "Sprungh?he: " << height;
+                        LOG_MESSAGE(Logger::UI, os.str());
+                        Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
+                        force += Vector3(0,
+                            jumpForce,
+                            0);
+                    }
+                    else // weitsprung
+                    {
+                        Real width = mCharacterState.mJumpWidthHeight;
+                        Real m = mass;
+                        Real g = mGravitation.length();
+                        Real v0 = currentVel.x;
+                        Real t = timestep;
+                        Real s = width;
+                        std::ostringstream os;
+                        os << "Sprungweite: " << width;
+                        LOG_MESSAGE(Logger::UI, os.str());
+                        Real jumpForcezy = 
+                            m*g/4 - v0*m /2 /t + 
+                            Math::Sqrt( 
+                                v0*v0 * m*m  -
+                                v0 * m*m *g *t +
+                                m*m * g*g * t*t /4 +
+                                2 * s * m*m *g
+                                       )/2/t;
+                        force += Vector3(0,jumpForcezy,0);
+                        // in the direction of mDesiredVel
+                        if( mCharacterState.mDesiredVel.squaredLength() == 0 )
+                        {
+                            // this shouldn't happen...
+                            mCharacterState.mDesiredVel.z = -1;                            
+                        }
+                        mCharacterState.mDesiredVel.y = 0;
+                        mCharacterState.mDesiredVel.normalise();
+                        force += orientation * mCharacterState.mDesiredVel * jumpForcezy;
+                    }
+
+                    mCharacterState.mStartJump = false;
                     mCharacterState.mIsAirBorne = true;
-                    Real height = 0.75f; // beim zweiten gehts seltsamerweise was h???er /doppelsprung physik?)
-                    Real gravity = 9.81f;
-                    Real jumpForce = 0.5f*gravity*mass * (Math::Sqrt(1 + 8*height/(gravity * timestep * timestep)) - 1);
-                    force += Vector3(0,
-                        jumpForce,
-                        0);
+                    mCharacterState.mJumpTimer = 0;
                 }
-
-                Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh???gig von der framerate!
-                force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
+                else
+                {
+                    Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh?ngig von der framerate!
+                    force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
+                }
             }
-            mCharacterState.mStartJump = false;
 
+
             body->setForce(force);
+            lastForce = force;
             // Assume we are air borne.
             // Might be set to true in the collision callback
             mCharacterState.mHasFloorContact = false;
@@ -716,17 +1150,18 @@
             maxHeight = playpos.y;
         ss
             << "scene node : " << playpos << std::endl
-//            << "player max Height : " << maxHeight << endl
+            << "player max Height : " << maxHeight << std::endl
             << "camera posder : " << static_cast<Camera*>(
                 mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-//                << "camera pos : " << static_cast<Camera*>(
-//                    mCameraActor->_getMovableObject())->getPosition() << std::endl
+                << "camera pos : " << static_cast<Camera*>(
+                    mCameraActor->_getMovableObject())->getPosition() << std::endl
             << "camera actor orientation : " << mCameraActor->getWorldOrientation() << std::endl
             << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
             << "camera body pos : " << bodpos << std::endl
             << "is airborne: " << (mCharacterState.mIsAirBorne ? "true" : "false") << std::endl
             << "start jump : " << (mCharacterState.mStartJump ? "true" : "false")  << std::endl
-            << "jump timer : " << mCharacterState.mJumpTimer << std::endl;
+            << "jump timer : " << mCharacterState.mJumpTimer << std::endl
+            << "force : " << lastForce << std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
@@ -736,11 +1171,12 @@
     void MovementCharacterController::calculateCamera(const Ogre::Real& timestep)
     {
         Vector3 charPos;
-        Quaternion charOri;
-        //mCharBody->getPositionOrientation(charPos, charOri);
+        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
         charPos = mCharacterActor->getWorldPosition();
-        charOri = mCharacterActor->getWorldOrientation();
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
+
         Vector3 camPos;
         Quaternion camOri;
         mCamBody->getPositionOrientation(camPos, camOri);
@@ -759,7 +1195,7 @@
         camOptPositionsBufferIdx = (camOptPositionsBufferIdx + 1) % camOptPositionsBuffer.size();
 */
         Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * mLookAtOffset;
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
 //        camOptPositionsBuffer[camOptPositionsBufferIdx] = optimalCamPos;
 
 
@@ -775,7 +1211,7 @@
 
 
 
-        // Kamera-Gr???e beziehen
+        // Kamera-Gr??e beziehen
         CameraObject* ogreCam = static_cast<CameraObject*>(
             mCameraActor->getControlledObject());
         AxisAlignedBox camAabb = ogreCam->getDefaultSize();
@@ -804,9 +1240,9 @@
             RaycastInfo infoCastOptPos = mRaycast->execute(
                 world,
                 materialId,
-                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
+                camPos + camRadius * normToOptCamPos, // Gr??e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr???e der Kamera einbeziehen
+                true); // Gr??e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast->execute(
                 world,
@@ -843,17 +1279,17 @@
                     RaycastInfo infoCastNewPos;
                     Real delta = lenToOptCamPos/2.0f;
                     Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann???erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    // Ann?herung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
                     while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
                     {
                         infoCastNewPos = mRaycast->execute(
                             world,
                             materialId,
-                            camPos + camRadius * normToOptCamPos, // Gr???e der Kamera!
+                            camPos + camRadius * normToOptCamPos, // Gr??e der Kamera!
                             temp,
                             true);
                         delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n???er an Char ran
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n?her an Char ran
                         {
                             temp = temp - delta * normToOptCamPos;
                         }
@@ -863,9 +1299,9 @@
                         }
                     }
 
-                    // Jetzt k???nen wir sicher sein, dass diese Stelle erreichbar ist:
+                    // Jetzt k?nnen wir sicher sein, dass diese Stelle erreichbar ist:
                     temp = temp - 0.05 * normToOptCamPos;
-                    // Gr???e der Kamera einbeziehen
+                    // Gr??e der Kamera einbeziehen
                     optimalCamPos = temp - camRadius * normToOptCamPos;
                     // so ab hier kann ganz normal weiter gerechnet werden!
                 }
@@ -874,7 +1310,7 @@
 
             static bool isPathfinding (false);
             static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten fr den
+            // gibt an, ob schon gebufferte Daten f?r den
             // neuen Weg existieren und dort weitergemacht werden kann,
             // oder ob neu nach einem Weg gesucht werden muss!
             if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
@@ -882,8 +1318,8 @@
                 // anderen Weg finden
                 // hier werden erstmal nur alte Player-Positionen betrachtet
                 // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden k???nen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
+                // und durch "Geraden" miteinander verbunden werden k?nnen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fl?ssig
                 // und weich (keine scharfen Kurven) erscheinen
 
                 size_t buffSize = charPositionsBuffer.size();
@@ -924,12 +1360,12 @@
                 }
                 else
                 {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergef?hrt werden!");
 
 
                     // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
                     unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
+                    while ( delta > 0 ) // delta = 0 braucht nicht ?berpr?ft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast->execute(
                             world,
@@ -947,7 +1383,7 @@
                     // auf zu der ermittelten Position!
                     optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
                 }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Pr?fung gleicher sachen)
             }
             else
             {
@@ -981,20 +1417,22 @@
     {
         Vector3 targetCamPos;
 
+        Vector3 charPos;
+        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        charPos = mCharacterActor->getWorldPosition();
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
+
+
         if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
         {
-            Vector3 charPos;
-            Quaternion charOri;
-            charPos = mCharacterActor->getWorldPosition();
-            charOri = mCharacterActor->getWorldOrientation();
-            //mCharBody->getPositionOrientation(charPos, charOri);
             charPos = charPos + charOri * mLookAtOffset;
             if(mViewMode == VM_THIRD_PERSON)
             {
                 targetCamPos =
                     charPos
-                    + charOri * Vector3(
+                    + charOri * virtualCamOri * Vector3(
                                     0,
                                     Math::Sin(mPitch) * mDesiredDistance,
                                     Math::Cos(mPitch) * mDesiredDistance);
@@ -1005,14 +1443,14 @@
                 camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
                 targetCamPos =
                     charPos
-                    + charOri * camOri * Vector3(
+                    + charOri * camOri * virtualCamOri * Vector3(
                                                 0,
                                                 Math::Sin(mPitch) * mDesiredDistance,
                                                 Math::Cos(mPitch) * mDesiredDistance);
             }
 
 
-            // Kamera-Gr???e beziehen
+            // Kamera-Gr??e beziehen
             CameraObject* ogreCam = static_cast<CameraObject*>(
                 mCameraActor->getControlledObject());
             AxisAlignedBox aabb = ogreCam->getDefaultSize();
@@ -1033,7 +1471,7 @@
             endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
                                       // dadurch kann aber sichergestellt
                                       // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
+                                      // hinter dem Helden ?bersehen wird
             startRay[1] = charPos + radiusOffset;
             endRay[1] = targetCamPos + radiusOffset;
             radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
@@ -1122,18 +1560,13 @@
 
             targetCamPos = charPos + diff;
         }
-        else
+        else  // FIRST_PERSON
         {
-            Vector3 charPos;
-            Quaternion charOri;
-            //mCharBody->getPositionOrientation(charPos, charOri);
-            charPos = mCharacterActor->getWorldPosition();
-            charOri = mCharacterActor->getWorldOrientation();
             // determine the optimal target position of the camera
             targetCamPos =
                 charPos
-                + charOri * mLookAtOffset
-                + charOri * Vector3(
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
                                 0,
                                 Math::Sin(mPitch) * mDesiredDistance,
                                 Math::Cos(mPitch) * mDesiredDistance);
@@ -1180,286 +1613,7 @@
         }
     }
 
-    //------------------------------------------------------------------------
-    void MovementCharacterController::updateAnimationState(int &movement)
-    {
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        PhysicalThing* pt = mCharacterActor->getPhysicalThing();
-        static std::string lastAnimation("");
-        std::string newAnimation("");
-        Real animSpeed = 1;
-        static Real lastSpeed = 1;
-        static bool jumpNextFrame(false);
-        unsigned int animTimesToPlay = 0;
-        Real gs = mCharacter->getWert(Creature::WERT_GS);
-        static String lastCollisionPose = "";
-        String collisionPose = "idle";
 
-        // the different factors used to calculate the animation-speed from the character-speed
-        const Real factor_hocke_gehen = 0.7;
-        const Real factor_drehen_idle = 0.6;
-        const Real factor_gehen = 0.5;
-        const Real factor_gehen_rueckwaerts = 0.7;
-        const Real factor_rennen = 0.25;
-        const Real factor_rennen_absprung = 0.25;
-        const Real factor_rennen_sprung_landung = 0.6;
-        const Real factor_rennen_sprung = 0.25;
-        const Real factor_seitwaerts = 0.9;
-
-
-        Vector3 charVelocity, charOmega;
-        charOmega = mCharBody->getOmega();
-        charVelocity = mCharBody->getVelocity();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        if( charOri != Quaternion::ZERO )
-        {
-            charVelocity = charOri.Inverse() * charVelocity;
-        }
-        Real vel = charVelocity.length();
-
-        if (jumpNextFrame)
-            movement |= MOVE_JUMP;
-
-        if (mCharacterState.mPose == CharacterState::Falling) // noch nicht implementiert!
-            mCharacterState.mPose = CharacterState::Stand;
-
-
-        if (mCharacterState.mPose == CharacterState::Stand && movement & MOVE_SNEAK)
-        {
-            newAnimation = "idle_zu_hocke";
-            mCharacterState.mPose = CharacterState::StandToCrouch;
-            animTimesToPlay = 1;
-        }
-        else if(mCharacterState.mPose == CharacterState::StandToCrouch)
-        {
-            MeshAnimation *meshAnim = mesh->getAnimation("idle_zu_hocke");
-            if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-            {
-                newAnimation = "hocke_idle";
-                collisionPose = "hocke_idle";
-                mCharacterState.mPose = CharacterState::Crouch;
-            }
-            // kamera-offset interpolieren grrr
-            Real factor;
-            factor = meshAnim->getTimePlayed() / meshAnim->getLength();
-            interpolateAnimationLookAtOffset("idle", "hocke_idle", factor);
-        }
-        else if(mCharacterState.mPose == CharacterState::Crouch && movement & MOVE_SNEAK)
-        {
-            if (vel > 0.1 && movement & MOVE_FORWARD)
-            {
-                newAnimation = "hocke_gehen";
-                collisionPose = "hocke_idle";
-                animSpeed = charVelocity.length() * factor_hocke_gehen;
-            }
-            else
-            {
-                newAnimation = "hocke_idle";
-                collisionPose = "hocke_idle";
-            }
-        }
-        else if (mCharacterState.mPose == CharacterState::Crouch)
-        {
-            // Achtung, nur wenn nach oben hin genug Platz ist aufstehen!!
-            newAnimation = "hocke_zu_stehen";
-            mCharacterState.mPose = CharacterState::CrouchToStand;
-            animTimesToPlay = 1;
-        }
-        else if(mCharacterState.mPose == CharacterState::CrouchToStand)
-        {
-            MeshAnimation *meshAnim = mesh->getAnimation("hocke_zu_stehen");
-            if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-            {
-                newAnimation = "idle";
-                mCharacterState.mPose = CharacterState::Stand;
-            }
-            // kamera-offset interpolieren grrr
-            Real factor;
-            factor = meshAnim->getTimePlayed() / meshAnim->getLength();
-            interpolateAnimationLookAtOffset("hocke_idle", "idle", factor);
-        }
-        else if(mCharacterState.mPose == CharacterState::StartJump)
-        {
-            if( lastAnimation == "rennen_absprung" )
-            {
-                MeshAnimation *meshAnim = mesh->getAnimation("rennen_absprung");
-                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-                {
-                    ///\todo Animation "rennen_sprung" has length of 0.0f. Substitute for Idle, till this is resolved.
-                    //newAnimation = "rennen_sprung";
-                    newAnimation = "idle";
-
-                    animSpeed = factor_rennen_sprung * vel;
-                    animTimesToPlay = 1;
-                    mCharacterState.mPose = CharacterState::Jumping;
-                    mCharacterState.mStartJump = true;
-                }
-            }
-            else // "idle_absprung"
-            {
-                MeshAnimation *meshAnim = mesh->getAnimation("idle_absprung");
-                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-                {
-                    ///\todo Animation "idle_sprung" has length of 0.0f. Substitute for Idle, till this is resolved.
-                    //newAnimation = "idle_sprung";
-                    newAnimation = "idle";
-
-                    animTimesToPlay = 1;
-                    mCharacterState.mPose = CharacterState::Jumping;
-                    mCharacterState.mStartJump = true;
-                }
-            }
-        }
-        else if(mCharacterState.mPose == CharacterState::Jumping)
-        {
-            if( lastAnimation == "rennen_sprung" )
-            {
-                if (!mCharacterState.mIsAirBorne)
-                {
-                    newAnimation = "rennen_sprung_landung";
-                    animSpeed = factor_rennen_sprung_landung * vel;
-                    animTimesToPlay = 1;
-                    mCharacterState.mPose = CharacterState::EndJump;
-                }
-            }
-            else // "idle_sprung"
-            {
-                if (!mCharacterState.mIsAirBorne)
-                {
-                    newAnimation = "idle_sprung_landung";
-                    animTimesToPlay = 1;
-                    mCharacterState.mPose = CharacterState::EndJump;
-                }
-            }
-        }
-        else if(mCharacterState.mPose == CharacterState::EndJump)
-        {
-            MeshAnimation *meshAnim = mesh->getAnimation(lastAnimation);
-
-            if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-                mCharacterState.mPose = CharacterState::Stand;
-        }
-
-
-
-
-        // absichtlich kein else!
-        if( mCharacterState.mPose == CharacterState::Stand && !(movement & MOVE_SNEAK) )
-        {
-            newAnimation = "idle";
-
-            // Nur im Stehen Drehen:
-            if( vel < 0.1)
-            {
-                if( charOmega.squaredLength() < 0.1)
-                {
-                    newAnimation = "idle";
-                }
-                else if( charOmega.y > 0 )
-                {
-                    newAnimation = "drehen_links";
-                    animSpeed = factor_drehen_idle * charOmega.y * (1);
-                }
-                else if( charOmega.y < 0 )
-                {
-                    newAnimation = "drehen_rechts";
-                    animSpeed = factor_drehen_idle * charOmega.y * (-1);
-                }
-            }
-            else if( vel <= gs / 3.55f)
-            {
-                if( charVelocity.z > 0 && movement & MOVE_BACKWARD)
-                {
-                    newAnimation = "gehen_rueckwaerts";
-                    animSpeed = factor_gehen_rueckwaerts * vel;
-                }
-                else if( movement & MOVE_FORWARD )
-                {
-                    newAnimation = "gehen";
-                    animSpeed = factor_gehen * vel;
-                }
-                else if( movement & MOVE_LEFT )
-                {
-                    newAnimation = "seitwaerts_links";
-                    animSpeed = factor_seitwaerts * vel;
-                }
-                else if( movement & MOVE_RIGHT )
-                {
-                    newAnimation = "seitwaerts_rechts";
-                    animSpeed = factor_seitwaerts * vel;
-                }
-            }
-            else if( movement & MOVE_FORWARD )
-            {
-                newAnimation = "rennen";
-                animSpeed = factor_rennen * vel;
-            }
-
-
-            if( movement & MOVE_JUMP )
-            {
-                // Beginn eines Sprunges
-                if( newAnimation == "rennen" )
-                {
-                    newAnimation = "rennen_absprung";
-                    animTimesToPlay = 1;
-                    animSpeed = factor_rennen_absprung * vel;
-                    mCharacterState.mPose = CharacterState::StartJump;
-                }
-                else
-                {
-                    if ( vel > 0.1 )
-                    {
-                        // erstmal anhalten!
-                        movement = MOVE_NONE;
-                        jumpNextFrame = true;
-                    }
-                    else
-                    {
-                        newAnimation = "idle_absprung";
-                        animTimesToPlay = 1;
-                        mCharacterState.mPose = CharacterState::StartJump;
-                    }
-                }
-            }
-        }
-
-        if( mCharacterState.mPose == CharacterState::StartJump )
-            jumpNextFrame = false;
-
-
-
-
-        if (newAnimation != "")
-        {
-            // nur schneller nicht langsamer ausfhren!
-            if (animSpeed < 1) animSpeed = 1;
-
-            if (lastAnimation != newAnimation)
-            {
-                if (collisionPose != lastCollisionPose)
-                {
-                    pt->fitToPose(collisionPose);
-                    lastCollisionPose = collisionPose;
-                }
-                mesh->stopAllAnimations();
-                mesh->startAnimation(newAnimation, animSpeed, animTimesToPlay);
-                lastAnimation = newAnimation;
-                lastSpeed = animSpeed;
-            }
-            else
-            {
-                if ( lastSpeed != animSpeed ) // Geschwindigkeits???derung
-                {
-                    MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                    meshAnim->setSpeed(animSpeed);
-                    lastSpeed = animSpeed;
-                }
-            }
-        }
-    }
-
-    //------------------------------------------------------------------------
     void MovementCharacterController::setViewMode(ViewMode mode)
     {
         mViewMode = mode;
@@ -1516,7 +1670,7 @@
         Vector3 interpolatedSize;
 
 
-        // Die Gr???e der beiden Animationen abfragen
+        // Die Gr??e der beiden Animationen abfragen
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
         aab = mesh->getPoseSize(actAnim);
         size[0] = aab.getMaximum() - aab.getMinimum();
@@ -1524,7 +1678,7 @@
         aab = mesh->getPoseSize(newAnim);
         size[1] = aab.getMaximum() - aab.getMinimum();
 
-        // interpolierte Gr???e (linear) berechnen
+        // interpolierte Gr??e (linear) berechnen
         interpolatedSize = size[0] + factor*(size[1] - size[0]);
 
         // LookAtOffset berechnen!
@@ -1570,6 +1724,15 @@
             mCharacterActor->setVisible(false);
         else
             mCharacterActor->setVisible(true);
+
+        // also reset the char
+        mCharacterState.mCurrentMovementState = 0;
+        mCharacterState.mDesiredVel = Vector3::ZERO;
+        mCharacterState.mHasFloorContact = true;
+        mCharacterState.mIsAirBorne = true;
+        mCharacterState.mStartJump = false;
+        mCharacterState.mJumpTimer = 0;
+        mCharacter->setTaktischeBewegung(Creature::BEWEGUNG_NONE);
     }
 
     //------------------------------------------------------------------------
@@ -1659,9 +1822,9 @@
         }
 
         LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        //lineSet->clear();
-        //lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-        //lineSet->addLine(Vector3::ZERO, mGravitation * 0.1, ColourValue::Green);
+        lineSet->clear();
+        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+        lineSet->addLine(Vector3::ZERO, mGravitation * 0.1, ColourValue::Green);
     }
 
     //------------------------------------------------------------------------



From melven at mail.berlios.de  Sun Mar  4 20:04:25 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 4 Mar 2007 20:04:25 +0100
Subject: [Dsa-hl-svn] r3118 - in rl/trunk/engine/ui: include src
Message-ID: <200703041904.l24J4Ptb010006@sheep.berlios.de>

Author: melven
Date: 2007-03-04 20:04:01 +0100 (Sun, 04 Mar 2007)
New Revision: 3118

Modified:
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
resetCamera does now also reset the char correctly

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-04 18:52:38 UTC (rev 3117)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-03-04 19:04:01 UTC (rev 3118)
@@ -105,6 +105,12 @@
 
 			int mCurrentMovementState;
 			int mLastMovementState;
+            bool beginSneak;
+            bool endSneak;
+            bool beginJump;
+            bool endJump;
+            enum {HOCHSPRUNG, WEITSPRUNG /*, PRAEZISER_SPRUNG*/}
+                        jumpType;
 		};
 
         static Ogre::String msDebugWindowPageName;

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-04 18:52:38 UTC (rev 3117)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-04 19:04:01 UTC (rev 3118)
@@ -63,7 +63,11 @@
         mJumpTimer(0.0),
         mDesiredVel(Vector3::ZERO),
         mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
+        mLastMovementState(MOVE_NONE),
+        beginSneak(false),
+        endSneak(false),
+        beginJump(false),
+        endJump(false)
     {
 
     }
@@ -283,23 +287,20 @@
 
         //  --------------------------- sneaking-behaviour ----------------------------
         {
-            static bool beginSneak (false);
-            static bool endSneak (false);
-            
             if( (!(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
                 movement & MOVE_SNEAK) || 
-                beginSneak )
+                mCharacterState.beginSneak )
             {
-                beginSneak = true;
+                mCharacterState.beginSneak = true;
             }
             if( (!(movement & MOVE_SNEAK) && 
                 creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) || 
-                endSneak)
+                mCharacterState.endSneak)
             {
-                endSneak = true;
+                mCharacterState.endSneak = true;
             }
 
-            if( beginSneak )
+            if( mCharacterState.beginSneak )
             {
                 newAnimation = "idle_zu_hocke";
 
@@ -308,7 +309,7 @@
                 {
                     creatureMovement |= Creature::BEWEGUNG_SCHLEICHEN;
                     mCharacter->setTaktischeBewegung(creatureMovement);
-                    beginSneak = false;
+                    mCharacterState.beginSneak = false;
                 }
                 else
                 {
@@ -330,7 +331,7 @@
                 collisionPose = newAnimation;
             }
 
-            if( endSneak )
+            if( mCharacterState.endSneak )
             {
                 creatureMovement &= ~Creature::BEWEGUNG_SCHLEICHEN;
                 mCharacter->setTaktischeBewegung(creatureMovement);
@@ -341,7 +342,7 @@
                 if (meshAnim->getTimePlayed() >= meshAnim->getLength())
                 {
                     newAnimation = "idle";
-                    endSneak = false;
+                    mCharacterState.endSneak = false;
                 }
                 else
                 {
@@ -493,25 +494,18 @@
 
                 // ---------- jumping-behaviour (and falling?) ---------
                 {
-
-                    static bool beginJump (false);
-                    static bool endJump (false);
-                    static enum {HOCHSPRUNG, WEITSPRUNG /*, PRAEZISER_SPRUNG*/}
-                        jumpType;
-
-
                     if( !(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
-                        !blockMovement && !beginJump &&
+                        !blockMovement && !mCharacterState.beginJump &&
                         !(creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG) &&
                         !(creatureMovement & Creature::BEWEGUNG_WEITSPRUNG) &&
                         movement & MOVE_JUMP)
                     {
                         if( mCharacterState.mDesiredVel.squaredLength() > 0 )
                         {
-                            jumpType = WEITSPRUNG;
+                            mCharacterState.jumpType = CharacterState::WEITSPRUNG;
                             if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG) )
                             {
-                                beginJump = true;
+                                mCharacterState.beginJump = true;
                                 Real jumpWidth = 
                                     mCharacter->doTaktischeBewegung(
                                             newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG,
@@ -523,10 +517,10 @@
                         }
                         else
                         {
-                            jumpType = HOCHSPRUNG;
+                            mCharacterState.jumpType = CharacterState::HOCHSPRUNG;
                             if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG) )
                             {
-                                beginJump = true;
+                                mCharacterState.beginJump = true;
                                 Real jumpHeight = 
                                     mCharacter->doTaktischeBewegung(
                                             newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG,
@@ -541,17 +535,17 @@
 
                     if( (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
                         creatureMovement & Creature::BEWEGUNG_WEITSPRUNG  ) &&
-                        !beginJump )
+                        !mCharacterState.beginJump )
                     {
                         if( !mCharacterState.mIsAirBorne )
-                            endJump = true;
+                            mCharacterState.endJump = true;
                     }
 
 
 
                     
                     Real timeJumpKeyPressed (0.0);
-                    if( !beginJump )
+                    if( !mCharacterState.beginJump )
                         timeJumpKeyPressed = 0;
                     else if( movement & MOVE_JUMP && 
                         (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
@@ -560,10 +554,10 @@
 
 
 
-                    if( beginJump )
+                    if( mCharacterState.beginJump )
                     {
                         blockMovement = true;
-                        if( jumpType == WEITSPRUNG )
+                        if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
                         {
                             newAnimation = "rennen_absprung";
                             animSpeed = factor_rennen_sprung * vel;
@@ -581,7 +575,7 @@
                             mCharacterState.mStartJump = true;
                             if( timeJumpKeyPressed > 0.5 )
                             mCharacterState.mJumpWidthHeight *= timeJumpKeyPressed / meshAnim->getLength();
-                            beginJump = false;
+                            mCharacterState.beginJump = false;
                         }
                     }
                     else // !beginJump
@@ -600,7 +594,7 @@
                         }
                     }
 
-                    if( endJump )
+                    if( mCharacterState.endJump )
                     {
                         blockMovement = true;
                         if( creatureMovement & Creature::BEWEGUNG_WEITSPRUNG )
@@ -618,7 +612,7 @@
                         MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
                         if (meshAnim->getTimePlayed() >= meshAnim->getLength())
                         {
-                            endJump = false;
+                            mCharacterState.endJump = false;
                             creatureMovement &= ~Creature::BEWEGUNG_HOCHSPRUNG & ~Creature::BEWEGUNG_WEITSPRUNG;
                             mCharacter->setTaktischeBewegung(creatureMovement);
                         }
@@ -1733,6 +1727,10 @@
         mCharacterState.mStartJump = false;
         mCharacterState.mJumpTimer = 0;
         mCharacter->setTaktischeBewegung(Creature::BEWEGUNG_NONE);
+        mCharacterState.beginJump = false;
+        mCharacterState.endJump = false;
+        mCharacterState.beginSneak = false;
+        mCharacterState.endSneak = false;
     }
 
     //------------------------------------------------------------------------



From natoka at mail.berlios.de  Mon Mar  5 12:18:23 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 5 Mar 2007 12:18:23 +0100
Subject: [Dsa-hl-svn] r3119 - in rl/trunk/engine: ai ai/include ai/src
	core/include script/swig
Message-ID: <200703051118.l25BINqT001551@sheep.berlios.de>

Author: natoka
Date: 2007-03-05 12:18:09 +0100 (Mon, 05 Mar 2007)
New Revision: 3119

Added:
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/ai/src/WayPointGraphManager.cpp
   rl/trunk/engine/ai/src/WayPointNode.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/core/include/DebugVisualisable.h
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
Log:
adding WayPointGraph system to rl
corrected some comments in AiSubSystem and SteeringVehicle
added WayPointGraphManager to AiSubsystem
added swig definitions for exporting added functionality to ruby scripts

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-05 11:18:09 UTC (rev 3119)
@@ -316,6 +316,18 @@
 				RelativePath=".\src\SteeringVehicle.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\src\WayPointGraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\WayPointGraphManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\WayPointNode.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Headerdateien"
@@ -366,6 +378,18 @@
 				RelativePath=".\include\SteeringVehicle.h"
 				>
 			</File>
+			<File
+				RelativePath=".\include\WayPointGraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\WayPointGraphManager.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\WayPointNode.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Ressourcendateien"

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -62,7 +62,9 @@
 		virtual ~AgentManager(void);
 
 		/** Creates an AI agent with an assigned rl::Actor.
-		 * AiSubsystems is responsible for memory management of the Agent
+		 * AgentManager is responsible for memory management of the Agent
+		 * @param type defines the type of the agent \see AgentType
+		 * @param character the associated creature
 		 */
 		Agent* createAgent(AgentType type, Creature* character);
 

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -24,6 +24,7 @@
 {
 	class Agent;
 	class AgentManager;
+	class WayPointGraphManager;
 	class AiWorld;
 
 	/** Central core of AI
@@ -66,6 +67,8 @@
 
 		//! single AgentManager object
 		AgentManager* mAgentManager;
+		//! single WayPointGraphManager object
+		WayPointGraphManager *mWayPointGraphManager;
 		//! AiWorld representation - WIP!!! (object to changes)
 		AiWorld* mWorld;
 	};

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-03-05 11:18:09 UTC (rev 3119)
@@ -7,4 +7,7 @@
 	FuzzyStateMachine.h \
 	PhysicalObstacle.h \
 	SteeringMachine.h \
-	SteeringVehicle.h
+	SteeringVehicle.h \
+	WayPointNode.h \
+	WayPointGraph.h \
+	WayPointGraphManager.h

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -24,9 +24,18 @@
 
 namespace rl
 {
-//	SimpleVehicle_1 adds concrete LocalSpace methods to AbstractVehicle
+	/*	SimpleVehicle_1 adds concrete LocalSpace methods to AbstractVehicle.
+	 * OpenSteer::LocalSpaceMixin contains functionality to convert from one
+	 * coordinate system to an other.
+	 */
 	typedef OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle> SimpleVehicle_1;
-//	SimpleVehicle_2 adds concrete steering methods to SimpleVehicle_1
+	/*	SimpleVehicle_2 adds concrete steering methods to SimpleVehicle_1.
+	 * OpenSteer::SteerLibraryMixin adds the "steering library"
+	 * functionality to a given base class.  SteerLibraryMixin assumes its base
+     * class supports the AbstractVehicle interface.
+	 * The "steering library" itself presents methods to calculate movements
+	 * according to behaviours.
+	 */
 	typedef OpenSteer::SteerLibraryMixin<SimpleVehicle_1> SimpleVehicle_2;
 	
 	class Actor;

Added: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,162 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_WayPointGraph_H__
+#define __RlAI_WayPointGraph_H__
+
+#include "AiPrerequisites.h"
+#include "WayPointNode.h"
+#include "DebugVisualisable.h"
+#include "OgreVector3.h"
+
+
+namespace rl
+{
+
+	//template <class Data>
+	/** Stores a waypointgraph and is capable of loading and saving it.
+	 */
+	class _RlAiExport WayPointGraph 
+		: public DebugVisualisable
+	{
+	public:
+		//! defines a list of waypoint nodes
+		typedef std::vector<WayPointNode*> WayPointNodeList;
+
+		/* default constructor
+		 */
+		WayPointGraph();
+		/* explicit virtual destructor.
+		 * deletes all stored WayPointNodes
+		 */
+		virtual ~WayPointGraph();
+
+		/** adds a new waypoint at the given position to the graph.
+		 * Prohibits adding waypoints more than once by ignoring add 
+		 * requests for them and simply returning NULL for them.
+		 * @param pos Position of the Waypoint
+		 * @param type terrain type of Waypoint \see WayPointNodeType
+		 * @returns WayPointNode that was newly added (if it wasn't added, returns NULL)
+		 */
+		WayPointNode* addWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type);
+
+
+		/** adds a connection from one Waypoint to an other.
+		 * The added connection is bidirectional.
+		 * @param wp1 Waypoint edge first waypoint
+		 * @param wp2 Waypoint edge second waypoint
+		 */
+		void addConnection(WayPointNode* wp1, WayPointNode* wp2);
+
+		/** adds a directed connection from one WayPoint to an other.
+		 * The added connection is only one direction.
+		 * @param wp1 Waypoint edge origin
+		 * @param wp2 Waypoint edge destination
+		 */
+		void addDirectedConnection(WayPointNode* wp1, const WayPointNode* wp2);
+
+
+		/** loads the Waypoints from a file.
+		 * @param filename of the file to load.
+		 */
+		void load (const Ogre::String& filename);
+		/** saves the Waypoints to a file.
+		 * Structure of the file is as follows:
+		 * Header\n
+		 * numberOfWaypoints\n
+		 * waypoint1.x waypoint1.y waypoint1.z waypoint2.x ...\n
+		 * 4 1 2 3 4\n
+		 * ...
+		 * \n
+		 * \n
+		 * 
+		 * As you can see the waypoint coordinates are written consecutivily on one line
+		 * and the connections of one waypoint to the others are written per waypoint on one line.
+		 * The first number gives the number of connections and the rest are the indices of the
+		 * waypoints the connections have to be made to.
+		 * If the line is empty that means that the waypoint has got not other waypoints to connect to
+		 * (very unlikely)
+		 * the file is terminated either with end of file or two newlines.
+		 *
+		 * @param filename of the file to save to.
+		 */
+		void save (const Ogre::String& filename) const;
+
+		/** retrieves the nearest WayPoint for the given position
+		 * @param position in world space whose nearest waypoint has to be found.
+		 * @returns WayPointNode pointer to a waypoint object
+		 */
+		const WayPointNode* getNearestWayPoint(const Ogre::Vector3 position) const;
+
+		/** retrieves the WayPoint at the specified index from the list
+		 * @param index of the waypoint to fetch.
+		 */
+		const WayPointNode* getWayPointAt(unsigned int index) const;
+
+		/** fetches all stored WayPoints
+		 * @returns a const iterator for the list of the stored waypoints
+		 */
+		const WayPointNodeList& getWayPointList() const;
+
+		// Overrides from DebugVisualisable
+		/** Provides the flag of the kind of visualisation done in the class.
+		 * \see DebugVisualisable::DebugVisualisableFlag for further information
+		 */
+		virtual DebugVisualisableFlag getFlag() const;
+		/** Called to update the debug primitive. Redrawing is done in here.
+		 */
+        virtual void updatePrimitive();
+
+	protected:
+		// Overrides from DebugVisualisable
+		/** actualy creates the debug primitive.
+		 * \see DebugVisualisable for further information
+		 */
+        virtual void doCreatePrimitive();
+
+		// End of Overrides from DebugVisualisable
+	
+		/** adds a new waypoint at the given position to the graph.
+		 * Doesn't test if there is already a Waypoint for the specified position
+		 * @param pos Position of the Waypoint
+		 * @param type terrain type of Waypoint \see WayPointNodeType
+		 */
+		WayPointNode* rawAddWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type);
+
+		/** root node of the waypoint graph.
+		 * Note that there is no up or down in this graph, because it is a 
+		 * cyclic, directed graph.
+		 */
+		WayPointNode* mRoot;
+
+		//! to ease handling of the WayPointTree we also store a list of nodes
+		WayPointNodeList mNodeList;
+	};
+
+	/*
+	class WayPointGraphDebugger
+	{
+		WayPointGraphDebugger();
+		~WayPointGraphDebugger();
+
+		void init( Ogre::SceneManager* smgr );
+		void deInit();
+		void showLines( WayPointGraph* graph );
+		void hideLines();
+	};
+	*/
+};
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,64 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_WayPointGraphManager_H__
+#define __RlAI_WayPointGraphManager_H__
+
+#include "AiPrerequisites.h"
+#include <OgreSingleton.h>
+
+namespace rl
+{
+	class WayPointGraph;
+
+	class _RlAiExport WayPointGraphManager 
+		: protected Ogre::Singleton<WayPointGraphManager>
+	{
+
+	public:
+		//! returns the agentmanager object
+		static WayPointGraphManager& getSingleton(void);
+		//! returns a pointer to the agentmanager object
+        static WayPointGraphManager* getSingletonPtr(void);
+
+		/** Constructor
+		 */
+		WayPointGraphManager();
+		/** explicit virtual destructor
+		 */
+		virtual ~WayPointGraphManager();
+
+		/** Creates an WayPointGraph.
+		 * WayPointGraphManager is responsible for memory management of
+		 * the WayPointGraph
+		 */
+		WayPointGraph* createWayPointGraph();
+
+		/** Removes all registered WayPointGraphs and deletes their objects.
+		 * Clears all internal lists and deallocates the memory of the 
+		 * stored objects.
+		 */
+		void removeAllWayPointGraphs();
+
+	protected:
+		//! defines a std::list of Graphs
+		typedef std::vector<WayPointGraph*> WayPointGraphList;
+
+		//! list of stored graphs
+		WayPointGraphList mGraphs;
+	};
+};
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,91 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_WayPointNode_H__
+#define __RlAI_WayPointNode_H__
+
+#include "AiPrerequisites.h"
+#include "OgreVector3.h"
+
+namespace rl
+{
+
+	/* class storing a single WayPoint.
+	 * It contains the position of the waypoint and connections to its
+	 * neighbours along with the real cost of travel.
+	 */
+	class _RlAiExport WayPointNode
+	{
+	public:
+		//! defines the different types of terrain
+		enum WayPointNodeType 
+		{
+			WP_UNKNOWN = 0,
+			WP_EXTERIOR = 1,
+			WP_INTERIOR = 1 << 1,
+		};
+		//! defines a weighted edge
+		typedef std::pair<Ogre::Real, const WayPointNode*> WayPointWeightEdge;
+		//! defines a list of weighted 'edges' connecting to other nodes
+		typedef std::list<WayPointWeightEdge> WayPointWeightNodeList;
+
+		/** Creates a new waypoint at the given position.
+		 * @param pos Position of the Waypoint
+		 * @param type terrain type of Waypoint \see WayPointNodeType
+		 */
+		WayPointNode(const Ogre::Vector3& pos, const WayPointNodeType type);
+		/** explicit virtual destructor
+		 */
+		virtual ~WayPointNode();
+
+		/** adds other WayPointNodes as neighbours
+		 * @param neighbour WayPointNode to add as a neighbour
+		 */
+		void addNeighbour(const WayPointNode* neighbour);
+
+		/** fetches the list of neighbour nodes
+		 * 
+		 */
+		const WayPointWeightNodeList& getNeighbours() const;
+
+		/** retrieve the position of the WayPointNode
+		 * @returns the position of the WayPoint in world space coordinates
+		 */
+		Ogre::Vector3 getPosition() const;
+
+		/** retrieve the type of the WayPointNode
+		 * @returns the type of the WayPoint \see WayPointNodeType
+		 */
+		WayPointNodeType getType() const;
+
+	protected:
+		/** calculates the real cost to the neighbour.
+		 * Is used internally when adding a node and calculates the euclidean
+		 * distance. Terrain types etc. are ignored here.
+		 * @param neighbour WayPointNode to calculate the movement cost to.
+		 */
+		Ogre::Real calcCost(WayPointNode* neighbour);
+
+		//! list of neighbour WayPointNodes
+		WayPointWeightNodeList mNeighbours;
+		//! 3D position of this WayPointNode in world coordinates
+		Ogre::Vector3 mPosition;
+		//! defines the type of the Waypoint \see WayPointNodeType.
+		WayPointNodeType mType;
+	};
+
+};
+
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-05 11:18:09 UTC (rev 3119)
@@ -16,6 +16,7 @@
 #include "AiSubsystem.h"
 #include "AiWorld.h"
 #include "AgentManager.h"
+#include "WayPointGraphManager.h"
 #include "Logger.h"
 #include "GameLoop.h"
 #include "CoreSubsystem.h"
@@ -41,6 +42,7 @@
 
 AiSubsystem::AiSubsystem(void)
     : mAgentManager(NULL),
+	  mWayPointGraphManager(NULL),
       mWorld(NULL)
 {
     LOG_MESSAGE(Logger::AI, "Init Start");
@@ -55,12 +57,14 @@
     AgentManager::getSingleton().removeAllAgents();
     mWorld->removeAllObstacles();
     delete mAgentManager;
+	delete mWayPointGraphManager;
     delete mWorld;
 }
 
 void AiSubsystem::initialize()
 {
     mAgentManager = new AgentManager();
+	mWayPointGraphManager = new WayPointGraphManager();
     mWorld = new AiWorld();
 
     CoreSubsystem::getSingletonPtr()->getWorld()->addSceneChangeListener(this);

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-03-05 11:18:09 UTC (rev 3119)
@@ -12,4 +12,7 @@
 	FuzzyStateMachine.cpp \
 	PhysicalObstacle.cpp \
 	PlayerVehicle.cpp \
-	SteeringVehicle.cpp 
+	SteeringVehicle.cpp \
+        WayPointNode.cpp \
+	WayPointGraph.cpp \
+	WayPointGraphManager.cpp

Added: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,334 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "WayPointGraph.h"
+#include "WayPointNode.h"
+#include <algorithm>
+#include <Ogre.h>
+#include "CoreSubsystem.h"
+#include "World.h"
+#include "Exception.h"
+#include "LineSetPrimitive.h"
+
+using namespace std;
+
+namespace rl {
+
+WayPointGraph::WayPointGraph()
+: mRoot(NULL)
+{
+}
+
+WayPointGraph::~WayPointGraph()
+{
+	WayPointNodeList::iterator it;
+
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
+	{
+		delete *it;
+	}
+	// the scenenode seems
+	// already deleted when this destructor gets called.
+
+	// Remove debug scene node from root scene note, if debugview was used.
+    if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
+	{
+		CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->
+			getRootSceneNode()->removeChild(mSceneNode);
+    }
+}
+
+WayPointNode* WayPointGraph::addWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type)
+{
+	WayPointNodeList::iterator it;
+
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	{
+		// equal to some waypoint already added ...
+		if ( (*it)->getPosition() == position )
+			return NULL;
+	}
+
+	return rawAddWayPoint(position, type);
+	
+}
+
+WayPointNode* WayPointGraph::rawAddWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type)
+{
+	WayPointNode* newWayPoint = new WayPointNode(position, type);
+	mNodeList.push_back(newWayPoint);
+
+	return newWayPoint;
+}
+
+void WayPointGraph::addConnection(WayPointNode* wp1, WayPointNode* wp2)
+{
+	wp1->addNeighbour(wp2);
+	wp2->addNeighbour(wp1);
+}
+
+void WayPointGraph::addDirectedConnection(WayPointNode* wp1, const WayPointNode* wp2)
+{
+	wp1->addNeighbour(wp2);
+}
+
+void WayPointGraph::load (const Ogre::String& filename)
+{
+	//if (! boost::filesystem::exists(boost::filesystem::path(filename)) )
+	//	Throw(FileNotFoundException, filename);
+
+	std::ifstream input(filename.c_str(), ios::binary);
+	
+	if (input.fail())
+		Throw(Error, filename+": couldn't open");
+	if (input.eof())
+		Throw(Error, filename+": premature end of file");
+
+	std::string MagicHeader;
+	input >> MagicHeader;
+	if (MagicHeader != "RLWayPointGraph")
+		Throw(WrongFormatException, filename);
+
+	if (input.eof())
+		Throw(Error, filename+": premature end of file");
+
+	char line[20];
+	input.getline(line, sizeof(line));
+
+	WayPointNodeList::size_type numberOfNodes;
+	input.read((char *) &numberOfNodes, sizeof(numberOfNodes));
+
+	//read the rest of the line (lineend)
+	input.getline(line, sizeof(line));
+
+	// read in the points
+	Ogre::Vector3 Position;
+	WayPointNode::WayPointNodeType type;
+	unsigned int count = 0;
+	while (!input.eof() && count < numberOfNodes) 
+	{
+		input.read((char *) &Position, sizeof(Position));
+		if (input.eof())
+			Throw(Error, filename+": fileend while reading waypoints");
+		input.read((char *) &type, sizeof(type));
+		if (input.eof())
+			Throw(Error, filename+": fileend while reading waypoints");
+		rawAddWayPoint(Position, type);
+		count++;
+	}
+	if (count != numberOfNodes)
+		Throw(Error, filename+": didn't find as many WayPoints as expected.");
+
+	// should be needed to read newline at end of waypoint line, but actually it's
+	// not necessary (enabling it breaks the loading of the connections)
+	//input.getline(line, sizeof(line));
+
+	WayPointNode* FromNode;
+	WayPointNode* ToNode;
+	WayPointNode::WayPointWeightNodeList::size_type nrOfConnections;
+	unsigned int index;
+
+	// read in the connections
+	count=0;
+	while (!input.eof() && count < numberOfNodes) 
+	{
+		input.read((char *) &nrOfConnections, sizeof(nrOfConnections));
+		if (input.eof())
+			Throw(Error, filename+": fileend while reading connections");
+
+		for (unsigned int concount = 0; concount < nrOfConnections; concount++) {
+			input.read((char *) &index, sizeof(index));
+			FromNode = mNodeList[count];
+			ToNode = mNodeList[index];
+			FromNode->addNeighbour(ToNode);
+		}
+		count++;
+		input.getline(line, sizeof(line));
+	}
+	if (count != numberOfNodes) 
+		Throw(Error, filename+": couldn't read expeced number of connections");
+
+	input.close();
+}
+
+void WayPointGraph::save (const Ogre::String& filename) const
+{
+	unsigned int count;
+	WayPointNodeList::const_iterator it;
+	std::map<const WayPointNode*, unsigned int> IndexList;
+	std::ofstream output(filename.c_str(), std::ios::binary);
+
+	// opening file for write failed
+	if (output.fail())
+		Throw (Error,filename + "couldn't open for writing");
+
+	// write file magic header
+	output << "RLWayPointGraph" << endl;
+	// write number of waypoints
+	WayPointNodeList::size_type numberOfNodes = mNodeList.size();
+	output.write((char *) &numberOfNodes, sizeof(numberOfNodes));
+	output << endl;
+
+	// save the full list of points
+	// and construct an index map for the nodes
+	count = 0;
+	Ogre::Vector3 Position;
+	WayPointNode::WayPointNodeType type;
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	{
+		// write waypoint to file
+		Position = (*it)->getPosition();
+		type = (*it)->getType();
+		output.write((char *) &Position, sizeof(Position));
+		output.write((char *) &type, sizeof(type));
+		// add waypoint pointer to the list with it's index
+		IndexList.insert(pair<WayPointNode*, unsigned int>((*it),count));
+		count++;
+	}
+	// additionally terminate list with newline
+	cout << endl;
+
+	// save the index-index pairs for the connections between the nodes
+	count = 0;
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	{
+		const WayPointNode::WayPointWeightNodeList subnodes = (*it)->getNeighbours();
+		WayPointNode::WayPointWeightNodeList::size_type subnodessize = subnodes.size();
+		WayPointNode::WayPointWeightNodeList::const_iterator nit;
+		std::map<const WayPointNode*, unsigned int>::iterator itIndex;
+		
+		output.write((char *) &(subnodessize), sizeof(subnodessize));
+		// iteratte through the neighbours
+		for (nit = subnodes.begin(); nit != subnodes.end(); nit++) 
+		{
+			itIndex = IndexList.find( (*nit).second );
+			output.write((char *) &((*itIndex).second), sizeof((*itIndex).second));
+		}
+		// terminate connection list for one node
+		output << endl;
+
+		count++;
+	}
+	output.close();
+}
+
+const WayPointNode* WayPointGraph::getNearestWayPoint(const Ogre::Vector3 position) const
+{
+	WayPointNodeList::const_iterator it;
+	WayPointNode* nearestWayPoint = NULL;
+	Ogre::Vector3 nearestVec;
+	Ogre::Real nearestDistance;
+
+	// if list is empty simply return no waypoint
+	if (mNodeList.begin() == mNodeList.end())
+		return NULL;
+
+	// first waypoint is the nearest at the beginning
+	it = mNodeList.begin();
+	nearestVec = position - (*it)->getPosition();
+	nearestDistance = nearestVec.length();
+	nearestWayPoint = (*it);
+	
+	// search the full list for points that are nearer
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	{
+		// calculate distance
+		nearestVec = position - (*it)->getPosition();
+		
+		// test if distance is smaller than the smallest seen until now
+		if ( nearestDistance > nearestVec.length() )
+		{
+			nearestDistance = nearestVec.length();
+			nearestWayPoint = (*it);
+		}
+	}
+
+	return nearestWayPoint;
+}
+
+const WayPointGraph::WayPointNodeList& WayPointGraph::getWayPointList() const
+{
+	return mNodeList;
+}
+
+const WayPointNode* WayPointGraph::getWayPointAt(unsigned int index) const
+{
+	if (index >= mNodeList.size())
+		Throw(OutOfRangeException,"no data at specified index");
+
+	return mNodeList[index];
+}
+
+
+DebugVisualisableFlag WayPointGraph::getFlag() const
+{
+	return DVF_WAYPOINT;
+}
+
+void WayPointGraph::updatePrimitive()
+{
+	if (mSceneNode->getParent() == NULL)
+    {
+		CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->
+			getRootSceneNode()->addChild(mSceneNode);
+		//mCharacterActor->_getSceneNode()->addChild(mSceneNode);
+    }
+
+	LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+
+	lineSet->clear();
+
+	// list storing added lines (for avoiding drawing bidirectional lines twice)
+	std::multimap<const WayPointNode*,const WayPointNode*> edgeList;
+	std::multimap<const WayPointNode*,const WayPointNode*>::iterator edgeListIt;
+
+	WayPointNodeList::const_iterator it;
+	Ogre::Vector3 wp1Vec;
+	Ogre::Vector3 wp2Vec;
+
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
+	{
+		wp1Vec = (*it)->getPosition();
+		// draw the waypoint itself
+		lineSet->addLine(wp1Vec, wp1Vec + Ogre::Vector3(0,1,0), Ogre::ColourValue::Red);
+
+		const WayPointNode::WayPointWeightNodeList subnodes = (*it)->getNeighbours();
+		WayPointNode::WayPointWeightNodeList::const_iterator nit;
+
+		for (nit = subnodes.begin(); nit != subnodes.end(); nit++) 
+		{
+			/*bool found = false;
+			while ( (edgeListIt = edgeList.find( (*nit).second )) != edgeList.end() )
+			{
+				if ( (*edgeListIt).second == (*it) )
+					found = true;
+			}
+			if (found)	// already 'drawn'
+				continue;
+				*/
+
+			lineSet->addLine(wp1Vec, (*nit).second->getPosition(), Ogre::ColourValue::Blue);
+			edgeList.insert(pair<const WayPointNode*,const WayPointNode*>((*nit).second, (*it)) );
+		}
+	}
+	edgeList.clear();
+}
+
+void WayPointGraph::doCreatePrimitive()
+{
+	mPrimitive = new LineSetPrimitive();
+}
+
+};
\ No newline at end of file

Added: rl/trunk/engine/ai/src/WayPointGraphManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,61 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "WayPointNode.h"
+#include "WayPointGraph.h"
+#include "WayPointGraphManager.h"
+
+using namespace std;
+using namespace Ogre;
+
+template<> rl::WayPointGraphManager* Singleton<rl::WayPointGraphManager>::ms_Singleton = 0;
+
+namespace rl {
+
+WayPointGraphManager& WayPointGraphManager::getSingleton(void)
+{
+	return Singleton<WayPointGraphManager>::getSingleton();
+}
+
+WayPointGraphManager* WayPointGraphManager::getSingletonPtr(void)
+{
+	return Singleton<WayPointGraphManager>::getSingletonPtr();
+}
+
+WayPointGraphManager::WayPointGraphManager()
+{
+}
+WayPointGraphManager::~WayPointGraphManager()
+{
+	removeAllWayPointGraphs();
+}
+
+WayPointGraph* WayPointGraphManager::createWayPointGraph()
+{
+	WayPointGraph* Graph = new WayPointGraph();
+	mGraphs.push_back(Graph);
+	return Graph;
+}
+
+void WayPointGraphManager::removeAllWayPointGraphs()
+{
+	for(WayPointGraphList::iterator it = mGraphs.begin(); it != mGraphs.end(); it++)
+	{
+		delete (*it);
+	}
+	mGraphs.clear();
+}
+
+};
\ No newline at end of file

Added: rl/trunk/engine/ai/src/WayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointNode.cpp	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/ai/src/WayPointNode.cpp	2007-03-05 11:18:09 UTC (rev 3119)
@@ -0,0 +1,68 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "WayPointNode.h"
+
+using namespace std;
+
+namespace rl {
+
+WayPointNode::WayPointNode(const Ogre::Vector3& pos, const WayPointNodeType type)
+: mPosition(pos),
+mType(type)
+{
+}
+
+WayPointNode::~WayPointNode()
+{
+	mNeighbours.clear();
+}
+
+void WayPointNode::addNeighbour(const WayPointNode* neighbour) 
+{
+	WayPointWeightNodeList::iterator it;
+
+	// test if neighbour not already added
+	for (it = mNeighbours.begin(); it != mNeighbours.end(); it++) {
+		// already added
+		if ( (*it).second == neighbour ) 
+			return;
+		
+	}
+
+	// calculate cost to neighbour
+	Ogre::Vector3 distanceVector = getPosition() - neighbour->getPosition();
+	Ogre::Real distance = distanceVector.length();
+
+	// add neighbour
+	mNeighbours.push_back(WayPointWeightEdge(distance, neighbour));
+}
+
+const WayPointNode::WayPointWeightNodeList& WayPointNode::getNeighbours() const
+{
+	return mNeighbours;
+}
+
+Ogre::Vector3 WayPointNode::getPosition() const
+{
+	return mPosition;
+}
+
+WayPointNode::WayPointNodeType WayPointNode::getType() const
+{
+	return mType;
+}
+
+};
\ No newline at end of file

Modified: rl/trunk/engine/core/include/DebugVisualisable.h
===================================================================
--- rl/trunk/engine/core/include/DebugVisualisable.h	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/core/include/DebugVisualisable.h	2007-03-05 11:18:09 UTC (rev 3119)
@@ -27,7 +27,8 @@
     /// To only display the debug graphics for classes of visualisables.
     typedef enum { DVF_AREA    = 1, ///< Flag used for all kinds of game area types
                    DVF_BOT     = 2, ///< Flag used for bot(-thinking) visualisation
-                   DVF_CONTROL = 4  ///< Flag for visualisation of user control
+                   DVF_CONTROL = 4, ///< Flag for visualisation of user control
+				   DVF_WAYPOINT = 8, ///< Flag for visualisation of way points
                  } DebugVisualisableFlag;
 
     /// Abstract base class for classes that provide visual debug helpers.

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-05 11:18:09 UTC (rev 3119)
@@ -24,4 +24,7 @@
 #include "AgentManager.h"
 #include "Agent.h"
 #include "PhysicalObstacle.h"
+#include "WayPointNode.h"
+#include "WayPointGraph.h"
+#include "WayPointGraphManager.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-04 19:04:01 UTC (rev 3118)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-05 11:18:09 UTC (rev 3119)
@@ -113,5 +113,40 @@
             rl::PhysicalThing *getPhysicalThing() const;
             void setPhysicalThing(rl::PhysicalThing *thing);
     };
+    
+    class WayPointNode
+	{
+	public:
+		enum WayPointNodeType 
+		{
+			WP_UNKNOWN = 0,
+			WP_EXTERIOR = 1,
+			WP_INTERIOR = 2
+		};
+		
+		WayPointNode(const Ogre::Vector3& pos, const rl::WayPointNode::WayPointNodeType type);
+		Ogre::Vector3 getPosition() const;
+	};
 	
-}
+	class WayPointGraph 
+	{
+	public:
+		WayPointNode* addWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type);
+		void addConnection(rl::WayPointNode* wp1, rl::WayPointNode* wp2);
+		void addDirectedConnection(rl::WayPointNode* wp1, const rl::WayPointNode* wp2);
+		void load (const Ogre::String& filename);
+		void save (const Ogre::String& filename) const;
+		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3 position) const;
+		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
+	};
+	
+	class WayPointGraphManager 
+	{
+	public:
+		static WayPointGraphManager& getSingleton(void);
+		rl::WayPointGraph* createWayPointGraph();
+	};
+	
+} // Namespace
+
+



From blakharaz at mail.berlios.de  Mon Mar  5 19:23:04 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 5 Mar 2007 19:23:04 +0100
Subject: [Dsa-hl-svn] r3120 - in rl/trunk/engine: ai/src common/src
	dialog/src dialog/src/predicates
Message-ID: <200703051823.l25IN4i3003478@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-05 19:22:38 +0100 (Mon, 05 Mar 2007)
New Revision: 3120

Modified:
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/common/src/XmlErrorHandler.cpp
   rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
   rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
   rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
   rl/trunk/engine/dialog/src/ContextInterpreter.cpp
   rl/trunk/engine/dialog/src/DialogOption.cpp
   rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
   rl/trunk/engine/dialog/src/DialogSubsystem.cpp
   rl/trunk/engine/dialog/src/ScriptProcessor.cpp
   rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
Log:
Removed using namespace rl

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -26,8 +26,9 @@
 
 using namespace Ogre;
 using namespace OpenSteer;
-using namespace rl;
 
+namespace rl {
+
 Agent::Agent(Creature* character)
 	: mType(AgentManager::AGENT_NONE), mBehaviour(NULL), mVehicle(NULL), mDialogBot(NULL), 
 	  mCreature(character)
@@ -140,3 +141,5 @@
 	}
 	return mDialogBot->isActive();
 }
+
+}

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -27,9 +27,8 @@
 
 template<> rl::AiSubsystem* Singleton<rl::AiSubsystem>::ms_Singleton = 0;
 
-using namespace rl;
+namespace rl {
 
-
 AiSubsystem& AiSubsystem::getSingleton(void)
 {
     return Singleton<AiSubsystem>::getSingleton();
@@ -105,3 +104,5 @@
     addObstacle(o);
 */
 }
+
+}

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -22,10 +22,11 @@
 #include <Ogre.h>
 #include "PhysicsMaterialRaycast.h"
 
-using namespace rl;
 using namespace OpenSteer;
 using namespace Ogre;
 
+namespace rl {
+
 AiWorld::AiWorld(void) : mObstacles()
 {
 //  create an obstacle as bounding box of the walkarea for npcs
@@ -201,3 +202,5 @@
         return;
     }
 }
+
+}

Modified: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -18,10 +18,11 @@
 #include "MeshObject.h"
 #include "PhysicalThing.h"
 
-using namespace rl;
 using namespace OpenSteer;
 using namespace Ogre;
 
+namespace rl {
+
 PlayerVehicle::PlayerVehicle(Actor* character)
 	: SteeringVehicle(NULL, character)
 {
@@ -61,3 +62,4 @@
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
 
+}

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -21,10 +21,11 @@
 #include "MeshObject.h"
 #include "PhysicalThing.h"
 
-using namespace rl;
 using namespace Ogre;
 using namespace OpenSteer;
 
+namespace rl {
+
 SteeringVehicle::SteeringVehicle(Agent* parent, Actor* character)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
@@ -408,3 +409,4 @@
 }
 */
 
+}

Modified: rl/trunk/engine/common/src/XmlErrorHandler.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -19,7 +19,7 @@
 #include "XmlHelper.h"
 
 
-using namespace rl;
+namespace rl {
 
 XmlErrorHandler::XmlErrorHandler(void)
     : mFileName("")
@@ -67,3 +67,5 @@
 void XmlErrorHandler::resetErrors()
 {
 }
+
+}

Modified: rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -21,7 +21,7 @@
 
 #include "XmlHelper.h"
 
-using namespace rl;
+namespace rl {
 
 AimlNodeImplRl::AimlNodeImplRl(DOMNode* pNode)
 {
@@ -97,3 +97,5 @@
 AimlNodeImplRl::~AimlNodeImplRl(void)
 {
 }
+
+}

Modified: rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -11,10 +11,12 @@
 #include "CoreSubsystem.h"
 #include "ContentModule.h"
 
-using namespace rl;
 using namespace Ogre;
 using namespace XERCES_CPP_NAMESPACE;
 
+namespace rl {
+
+
 AimlParserImplRl::~AimlParserImplRl(void)
 {
 }
@@ -60,3 +62,5 @@
     }
     return res;
 }
+
+}

Modified: rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -18,7 +18,7 @@
 #include "Exception.h"
 #include "Logger.h"
 
-using namespace rl;
+namespace rl {
 
 ContextConditionProcessor::ContextConditionProcessor(void)
 	: XmlNodeProcessor<Response, AimlBot, CeGuiString, false>("contextCondition")
@@ -102,3 +102,5 @@
 void ContextConditionProcessor::postprocessStep()
 {
 }
+
+}
\ No newline at end of file

Modified: rl/trunk/engine/dialog/src/ContextInterpreter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -20,9 +20,10 @@
 #include "DialogOption.h"
 #include "AimlBot.h"
 
-using namespace rl;
 using namespace std;
 
+namespace rl {
+
 CeGuiString ContextInterpreter::INTERPRETER_NAME = "contextInterpreter";
 CeGuiString ContextInterpreter::RL_TYPE = "rldialog:type";
 CeGuiString ContextInterpreter::RL_LI_ID = "rldialog:id";
@@ -184,3 +185,5 @@
 	addProcessor(new ContextConditionProcessor());
 	addProcessor(new ScriptProcessor());
 }
+
+}

Modified: rl/trunk/engine/dialog/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogOption.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/DialogOption.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -19,7 +19,7 @@
 #include "ContextInterpreter.h"
 #include "Response.h"
 
-using namespace rl;
+namespace rl {
 
 DialogOption::DialogOption(const Response<CeGuiString>& pData, AimlBot<CeGuiString>* pBot)
 	: mBot(pBot), mData(new Response<CeGuiString>(pData))
@@ -58,3 +58,5 @@
 		}
 	}
 }
+
+}

Modified: rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -17,7 +17,7 @@
 #include "CoreSubsystem.h"
 #include "RubyInterpreter.h"
 
-using namespace rl;
+namespace rl {
 
 DialogScriptProcessor::DialogScriptProcessor()
 	: XmlNodeProcessor<AimlBot, AimlCore, CeGuiString>("script")
@@ -51,3 +51,5 @@
 					->execute(newDialogScriptObject.str());
 	}
 }
+
+}

Modified: rl/trunk/engine/dialog/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -35,7 +35,7 @@
 
 template<> rl::DialogSubsystem* Singleton<rl::DialogSubsystem>::ms_Singleton = 0;
 
-using namespace rl;
+namespace rl {
 
 DialogSubsystem& DialogSubsystem::getSingleton(void)
 {
@@ -144,3 +144,5 @@
 {
 	mCurrentBot = bot;
 }
+
+}

Modified: rl/trunk/engine/dialog/src/ScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -18,7 +18,7 @@
 #include "RubyInterpreter.h"
 #include "Exception.h"
 
-using namespace rl;
+namespace rl {
 
 ScriptProcessor::ScriptProcessor(void)
 	: XmlNodeProcessor<Response, AimlBot, CeGuiString, false>("script")
@@ -53,3 +53,5 @@
 		->execute(mCurrentNode->getFirstChild()->getNodeValue().c_str());
 
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "CreaturePredicates.h"
 #include "Creature.h"
 
-using namespace rl;
+namespace rl {
 
 CreaturePredicates::CreaturePredicates(Creature* pCharacter)
 	: mCharacter(pCharacter)
@@ -34,3 +34,5 @@
 		mModifier = Ogre::StringConverter::parseInt(pValue.c_str());
 	}
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "EigenschaftsProbePredicates.h"
 #include "Creature.h"
 
-using namespace rl;
+namespace rl {
 
 EigenschaftsProbePredicates::EigenschaftsProbePredicates(Creature* pCharacter)
 	: CreaturePredicates(pCharacter)
@@ -51,3 +51,5 @@
 {
 	return "eigenschaftsprobe";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -17,7 +17,7 @@
 #include "Creature.h"
 
 
-using namespace rl;
+namespace rl {
 
 EigenschaftsWertPredicates::EigenschaftsWertPredicates(Creature* pCharacter)
 	: CreaturePredicates(pCharacter)
@@ -49,3 +49,5 @@
 {
 	return "eigenschaftswert";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "GrundWertPredicates.h"
 #include "Creature.h"
 
-using namespace rl;
+namespace rl {
 
 GrundWertPredicates::GrundWertPredicates(Creature* pCharacter)
 	: CreaturePredicates(pCharacter) 
@@ -80,3 +80,5 @@
 {
 	return "grundwert";
 }
+
+}
\ No newline at end of file

Modified: rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -20,7 +20,7 @@
 #include "Quest.h"
 #include "RulesSubsystem.h"
 
-using namespace rl;
+namespace rl {
 
 QuestKnownPredicates::QuestKnownPredicates()
 {
@@ -68,3 +68,5 @@
 {
 	return "questknown";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -22,9 +22,10 @@
 #include "Quest.h"
 #include "RulesSubsystem.h"
 
-using namespace rl;
 using CEGUI::PropertyHelper;
 
+namespace rl {
+
 QuestPartsPredicates::QuestPartsPredicates()
 {
 }
@@ -96,3 +97,5 @@
 {
 	return "questparts";
 }
+
+}
\ No newline at end of file

Modified: rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -20,7 +20,7 @@
 #include "Quest.h"
 #include "RulesSubsystem.h"
 
-using namespace rl;
+namespace rl {
 
 QuestStatePredicates::QuestStatePredicates()
 {
@@ -68,3 +68,5 @@
 {
 	return "queststate";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "DialogCharacter.h"
 #include "ScriptPredicates.h"
 
-using namespace rl;
+namespace rl {
 
 ScriptPredicates::ScriptPredicates(DialogCharacter* pCharacter)
 	: mCharacter(pCharacter)
@@ -55,3 +55,5 @@
 {
 	return "script";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "TalentProbePredicates.h"
 #include "Creature.h"
 
-using namespace rl;
+namespace rl {
 
 TalentProbePredicates::TalentProbePredicates(Creature* pCharacter)
 	: CreaturePredicates(pCharacter)
@@ -44,3 +44,5 @@
 {
 	return "talentprobe";
 }
+
+}

Modified: rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-03-05 11:18:09 UTC (rev 3119)
+++ rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-03-05 18:22:38 UTC (rev 3120)
@@ -16,7 +16,7 @@
 #include "TalentWertPredicates.h"
 #include "Creature.h"
 
-using namespace rl;
+namespace rl {
 
 TalentWertPredicates::TalentWertPredicates(Creature* pCharacter)
 	: CreaturePredicates(pCharacter)
@@ -48,3 +48,5 @@
 {
 	return "talentwert";
 }
+
+}



From natoka at mail.berlios.de  Mon Mar  5 21:08:55 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 5 Mar 2007 21:08:55 +0100
Subject: [Dsa-hl-svn] r3121 - in modules: . aitest aitest/dsa aitest/gui
	aitest/gui/windows aitest/maps aitest/materials
	aitest/materials/textures aitest/scripts aitest/scripts/maps
	common/scripts
Message-ID: <200703052008.l25K8t4q010640@sheep.berlios.de>

Author: natoka
Date: 2007-03-05 21:08:20 +0100 (Mon, 05 Mar 2007)
New Revision: 3121

Added:
   modules/aitest/
   modules/aitest/dialogs/
   modules/aitest/dsa/
   modules/aitest/dsa/gameobjectdefinitions.gof
   modules/aitest/gui/
   modules/aitest/gui/fonts/
   modules/aitest/gui/imagesets/
   modules/aitest/gui/schemes/
   modules/aitest/gui/windows/
   modules/aitest/gui/windows/buttons/
   modules/aitest/maps/
   modules/aitest/maps/aitest.scene
   modules/aitest/maps/aitest_floorplane.mesh
   modules/aitest/materials/
   modules/aitest/materials/nx.grid.material
   modules/aitest/materials/textures/
   modules/aitest/materials/textures/nx.grid.axis.png
   modules/aitest/materials/textures/nx.grid.floor.png
   modules/aitest/materials/textures/nx.static.wall.png
   modules/aitest/materials/textures/nx.trafficcone.png
   modules/aitest/materials/textures/nx.zone.blue.png
   modules/aitest/materials/textures/nx.zone.green.png
   modules/aitest/materials/textures/nx.zone.nogravity.png
   modules/aitest/materials/textures/nx.zone.orange.png
   modules/aitest/materials/textures/nx.zone.pink.png
   modules/aitest/models/
   modules/aitest/scripts/
   modules/aitest/scripts/DebugKeys.rb
   modules/aitest/scripts/NpcCapsuleTest.rb
   modules/aitest/scripts/NpcTest.rb
   modules/aitest/scripts/WallSet1.rb
   modules/aitest/scripts/WallSet2.rb
   modules/aitest/scripts/WayPointTest.rb
   modules/aitest/scripts/WayPointTest2.rb
   modules/aitest/scripts/doortest.rb
   modules/aitest/scripts/maps/
   modules/aitest/scripts/maps/aitest.rb
   modules/aitest/scripts/maps/aitest2.rb
   modules/aitest/scripts/maps/aitestold.rb
   modules/aitest/scripts/moduleconfig.rb
   modules/aitest/scripts/testcase.rb
   modules/aitest/sound/
Modified:
   modules/common/scripts/globals.rb
   modules/modules.cfg
Log:
enable Waypoints in scripts (in common)
added aitest module for ai testing


Added: modules/aitest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="Holzscheit"/>
+        <property name="baseclass" type="STRING" data="GameObject" />
+        <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>
+        <property name="meshfile" type="STRING" data="ver_holzscheit_01.mesh"/>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="apple"/>
+        <property name="baseclass" type="STRING" data="GameObject" />
+        <property name="description" type="STRING" data="Ein Apfel?"/>
+        <property name="meshfile" type="STRING" data="sphere.1m.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="mass" type="REAL" data="65"/>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="TestPerson"/>
+        <property name="baseclass" type="STRING" data="NPC"/>
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialogfile" type="STRING" data="testperson.xml"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="default_idle_behaviour"/>
+            <property type="STRING" data="dialog_behaviour"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="TestPersonCapsule"/>
+        <property name="baseclass" type="STRING" data="NPC"/>
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialogfile" type="STRING" data="testperson.xml"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="default_idle_behaviour"/>
+            <property type="STRING" data="dialog_behaviour"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="switch3way"/>
+        <property name="baseclass" type="STRING" data="Switch3Way"/>
+        <property name="description" type="STRING" data="Ein Hebel"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="sphere"/>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="shortsword"/>
+        <property name="baseclass" type="STRING" data="Weapon" />
+        <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
+        <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="leather backpack"/>
+        <property name="baseclass" type="STRING" data="Container"/> 
+        <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
+        <property name="meshfile" type="STRING" data="ins_rucksack.mesh"/>
+    </gameobjectclass>
+
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="ErrorHandling"/>
+        <property name="baseclass" type="STRING" data="GameObject" />
+        <property name="description" type="STRING" data="The ErrorHandling TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
+    <!-- JobSequenceTest -->
+    <gameobjectclass>
+        <property name="classid" type="STRING" data="JobSequenceTestChest"/>
+        <property name="baseclass" type="STRING" data="GameObject" />
+        <property name="description" type="STRING" data="Eine Truhe zum Test der JobSequence"/>
+        <property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+</GameObjectDefinitions>

Added: modules/aitest/maps/aitest.scene
===================================================================
--- modules/aitest/maps/aitest.scene	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/maps/aitest.scene	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,14 @@
+<scene formatVersion="0.2.0">
+    <nodes>
+        <node>
+            <position x="0.0" y="0.0" z="0.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+            <entity meshFile="aitest_floorplane.mesh"/>
+        </node>
+        <node>
+            <position x="10.0" y="0.0" z="0.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+            <entity meshFile="held.mesh"/>
+        </node>
+    </nodes>
+</scene>

Added: modules/aitest/maps/aitest_floorplane.mesh
===================================================================
(Binary files differ)


Property changes on: modules/aitest/maps/aitest_floorplane.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/nx.grid.material
===================================================================
--- modules/aitest/materials/nx.grid.material	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/materials/nx.grid.material	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,34 @@
+material nx.grid
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            
+            texture_unit
+            {
+                max_anisotropy 8
+                filtering anisotropic
+                texture nx.grid.floor.png
+            }
+        }
+    }
+}
+
+material nx.axis
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            scene_blend alpha_blend
+            
+            texture_unit
+            {
+                texture nx.grid.axis.png
+            }
+        }
+    }
+}

Added: modules/aitest/materials/textures/nx.grid.axis.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.grid.axis.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.grid.floor.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.grid.floor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.static.wall.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.static.wall.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.trafficcone.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.trafficcone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.zone.blue.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.zone.blue.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.zone.green.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.zone.green.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.zone.nogravity.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.zone.nogravity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.zone.orange.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.zone.orange.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/nx.zone.pink.png
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/nx.zone.pink.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/scripts/DebugKeys.rb
===================================================================
--- modules/aitest/scripts/DebugKeys.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/DebugKeys.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,15 @@
+class DebugKeys
+    def initialize()
+        @isWPShown = false
+    end
+
+    def toggleWP()
+      if @isWPShown:
+	$DVM.hide(8)
+      else
+	$DVM.show(8)
+      end
+      @isWPShown = (@isWPShown == false)
+    end
+end
+

Added: modules/aitest/scripts/NpcCapsuleTest.rb
===================================================================
--- modules/aitest/scripts/NpcCapsuleTest.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/NpcCapsuleTest.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,21 @@
+require 'testcase.rb'
+require 'npc.rb'
+
+class NpcCapsuleTest < TestCase
+    def initialize(center)
+        super(center)
+
+        height = 0.05
+        #min_base = [-2.0, 0.05, -2.0]
+        #max_base = [2.0, height, 2.0]
+        #base = $AM.createBoxPrimitiveActor("capsuleTestBase",
+        #                                   min_base, max_base, "alpha_red")
+        #base.placeIntoScene(center);
+
+        npc1proxy = $GOM.createGameObjectProxy("TestPersonCapsule");
+        npc1 = npc1proxy.getGameObject();
+        npc1.setPosition(rel_pos([0.0, height, 0.0]));
+
+        npc1.placeIntoScene();
+    end
+end

Added: modules/aitest/scripts/NpcTest.rb
===================================================================
--- modules/aitest/scripts/NpcTest.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/NpcTest.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,21 @@
+require 'testcase.rb'
+require 'npc.rb'
+
+class NpcTest < TestCase
+    def initialize(center)
+        super(center)
+
+        height = 0.3
+        min_base = [-3.0, 0.05, -3.0]
+        max_base = [3.0, height, 3.0]
+        base = $AM.createBoxPrimitiveActor("DialogTestBase",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+        npc1proxy = $GOM.createGameObjectProxy("TestPerson");
+        npc1 = npc1proxy.getGameObject();
+        npc1.setPosition(rel_pos([0.0, height, 0.0]));
+
+        npc1.placeIntoScene();
+    end
+end

Added: modules/aitest/scripts/WallSet1.rb
===================================================================
--- modules/aitest/scripts/WallSet1.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/WallSet1.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,53 @@
+require 'testcase.rb'
+
+class WallSet1 < TestCase
+    def initialize(center)
+        super(center)
+
+        height = 1.0
+        min_base = [-3.0, 0.05, 0]
+        max_base = [3.0, height, 0.3]
+        base = $AM.createBoxPrimitiveActor("WallSet1_1",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+	min_base = [-10.0, 0.05, 0]
+	max_base = [-4, height, 0.3]
+	base = $AM.createBoxPrimitiveActor("WallSet1_2",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+	min_base = [4.0, 0.05, 0]
+	max_base = [10.0, height, 0.3]
+	base = $AM.createBoxPrimitiveActor("WallSet1_3",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+	min_base = [10.0, 0.05, 2]
+	max_base = [4, height, 2.3]
+	base = $AM.createBoxPrimitiveActor("WallSet1_4",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+	min_base = [-10.0, 0.05, 2]
+	max_base = [3, height, 2.3]
+	base = $AM.createBoxPrimitiveActor("WallSet1_5",
+                                           min_base, max_base, "alpha_blue")
+
+
+        base.placeIntoScene(center);
+
+	min_base = [4.0, 0.05, 0.0]
+	max_base = [4.3, height, -7.0]
+	base = $AM.createBoxPrimitiveActor("WallSet1_6",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+	min_base = [4.0, 0.05, -8.0]
+	max_base = [4.3, height, -10.0]
+	base = $AM.createBoxPrimitiveActor("WallSet1_7",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
+    end
+end

Added: modules/aitest/scripts/WallSet2.rb
===================================================================
--- modules/aitest/scripts/WallSet2.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/WallSet2.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,35 @@
+require 'testcase.rb'
+
+class WallSet2 < TestCase
+    def initialize(center)
+        super(center)
+
+        height = 1.0
+        min_base = [-10.0, 0.05, -10.0]
+        max_base = [10.0, height, -10.3]
+        base = $AM.createBoxPrimitiveActor("WallSet2_1",
+                                           min_base, max_base, "white")
+        base.placeIntoScene(center);
+
+	min_base = [-10.0, 0.05, 10.0]
+	max_base = [10.0, height, 10.3]
+	base = $AM.createBoxPrimitiveActor("WallSet2_2",
+                                           min_base, max_base, "white")
+        base.placeIntoScene(center);
+
+	min_base = [-10.0, 0.05, -10.0]
+	max_base = [-10.3, height, 10.0]
+	base = $AM.createBoxPrimitiveActor("WallSet2_3",
+                                           min_base, max_base, "white")
+        base.placeIntoScene(center);
+
+	min_base = [10.0, 0.05, -10.0]
+	max_base = [10.3, height, 10.0]
+	base = $AM.createBoxPrimitiveActor("WallSet2_4",
+                                           min_base, max_base, "white")
+
+
+        base.placeIntoScene(center);
+
+    end
+end

Added: modules/aitest/scripts/WayPointTest.rb
===================================================================
--- modules/aitest/scripts/WayPointTest.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/WayPointTest.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,82 @@
+
+
+class WayPointTest 
+    def initialize(center)
+	
+	height = 0.5;
+
+	@WPGraph = $WPGM.createWayPointGraph();
+	@WPGraph.addWayPoint([3, height, -8.5], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([3, height, -4], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([3, height, 0], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([3, height, 1], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([3, height, 5], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([3, height, 9.5], WayPointNode::WP_EXTERIOR);
+
+	@WPGraph.addWayPoint([4, height, -10], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([4, height, -7], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([4, height, -1], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([4, height, 2], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([4, height, 4], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([4, height, 7], WayPointNode::WP_EXTERIOR);
+
+	@WPGraph.addWayPoint([5, height, -6], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([5, height, -3], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([5, height, 1], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([5, height, 5], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([5, height, 6], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([5, height, 9.5], WayPointNode::WP_EXTERIOR);
+
+	@WPGraph.addWayPoint([6, height, -9], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([6, height, -2], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([6, height, -1], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([6, height, 4], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([6, height, 8], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([6, height, 9.5], WayPointNode::WP_EXTERIOR);
+
+	@WPGraph.addWayPoint([7, height, -8], WayPointNode::WP_EXTERIOR);
+	@WPGraph.addWayPoint([7, height, -4], WayPointNode::WP_EXTERIOR);
+
+	number = 4
+	inner = 5
+	count = 0
+	outercount = 0
+
+	number.times do
+		count = outercount * 6
+		inner.times do
+			wp2 = count + 1
+			@WPGraph.addConnection(@WPGraph.getWayPointAt(count),
+					       @WPGraph.getWayPointAt(wp2));
+			count += 1
+		end
+		outercount += 1
+	end
+
+	number -= 1
+	count = 0
+	outercount = 0
+	outer = 6
+	
+	outer.times do
+		count = outercount
+		number.times do
+			wp2 = count + outer
+			@WPGraph.addConnection(@WPGraph.getWayPointAt(count),
+					       @WPGraph.getWayPointAt(wp2));
+			count += outer
+		end
+		outercount += 1
+	end
+
+    end
+    def save()
+	@WPGraph.save("graphtest.wpg")
+    end
+    def load()
+	@WPGraph.load("graphtest.wpg")
+    end
+#def clear()
+#	@WPGraph.
+end
+

Added: modules/aitest/scripts/WayPointTest2.rb
===================================================================
--- modules/aitest/scripts/WayPointTest2.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/WayPointTest2.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,14 @@
+
+
+class WayPointTest2 
+    def initialize(center)
+	@WPGraph = $WPGM.createWayPointGraph();
+    end
+    def save()
+	@WPGraph.save("graphtest.wpg")
+    end
+    def load()
+	@WPGraph.load("graphtest.wpg")
+    end
+end
+

Added: modules/aitest/scripts/doortest.rb
===================================================================
--- modules/aitest/scripts/doortest.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/doortest.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,64 @@
+require 'util/vector_util.rb'
+require 'testcase.rb'
+require 'door.rb'
+require 'switch.rb'
+
+class DoorOpener < ObjectStateChangeListener
+
+  def initialize(door, switch)
+    super()
+    @door = door
+    @switch = switch
+    @switch.addObjectStateChangeListener(self)
+  end
+
+  def objectStateChanged(event)
+      doorOpen = @switch.getState() == Switch3Way::STATE_OBEN
+      if (@door.isOpen() != doorOpen)
+        if (doorOpen)
+          @door.doAction("opendoor")
+        else
+          @door.doAction("closedoor")
+        end
+      end
+  end
+end
+
+# Test case for Doors. Tests basic GameObject interaction,
+# ObjectStateChange event handling and physical collision updates.
+class DoorTest < TestCase
+    def initialize(center)
+        super(center)
+
+        # Define a base box to place everything else on.
+        height = 0.3
+        min_base = [-3.0, 0.05, -3.0]
+        max_base = [3.0, height, 3.0]
+        base = $AM.createBoxPrimitiveActor("DoorTestBase", min_base, max_base)
+        base.placeIntoScene(center);
+
+        # The door with the door knob
+        door1 = $GOM.createGameObjectProxy("door").getGameObject();
+	door1.setDescription("Eine Holztuer");
+	door1.setPosition(rel_pos([1.5, height, 0.0]));
+        # Place door and add door actions. Initially the door is not open but can be opened.
+        door1.placeIntoScene()
+
+        # The door without a working door knob, to be opened with
+        door2 = $GOM.createGameObjectProxy("door").getGameObject();
+	door2.setDescription("Eine Holztuer.\nDiese Tuer hat weder Klinke noch Schloesser");
+	door2.setPosition(rel_pos([-1.5, height, 0.0]));
+        # Place door and add door actions. Initially door is not open and cannot be opened.
+        door2.placeIntoScene()
+
+        # The switch to open the second door
+        switch = $GOM.createGameObjectProxy("switch3way").getGameObject();
+        switch.setPosition(rel_pos([2.25, height, 2.0]));
+	switch.placeIntoScene();
+
+        doorprocessor = DoorOpener.new(door2, switch);
+
+        $SCRIPT.log("doortest initialisiert");
+    end
+end
+

Added: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,59 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+require 'debugkeys.rb'
+
+require 'doortest.rb'
+
+require 'WallSet1.rb'
+require 'WallSet2.rb'
+
+require 'NpcTest.rb'
+require 'NpcCapsuleTest.rb'
+
+require 'WayPointTest.rb'
+require 'WayPointTest2.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'regressiontest'...")
+
+$SCRIPT.log("Create hero")
+$hero = $GOM.createGameObjectProxy("hero", 1);
+
+$SCRIPT.log("Place hero into scene")
+#$hero.getGameObject().setPosition([0.0, 1.0, 0.0]);
+$hero.getGameObject().placeIntoScene()
+
+
+$SCRIPT.log("Prepare hero for being the active character")
+PlayerSettings.preparePlayer($hero.getGameObject())
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero.getGameObject())
+
+$SCRIPT.log("Hero ready")
+
+$SCRIPT.log("map 'regressiontest' initialisiert.");
+
+$debugkeys = DebugKeys.new();
+$UI.linkKeyToRubyCommand('G',"$debugkeys.toggleWP()");
+
+$SCRIPT.log("debug keys are set up");
+
+#DoorTest.new([0.0, 0.0, -5.0])
+
+#WallSet1.new([0, 0, 0])
+WallSet2.new([0, 0, 0])
+
+NpcTest.new([-5, 0, 5])
+NpcCapsuleTest.new([0, 0, 5])
+
+#$MyWPT = WayPointTest.new([0, 0, 0])
+#$MyWPT.save()
+$MyWPT = WayPointTest2.new([0, 0, 0])
+$MyWPT.load()
+
+$SCRIPT.log("tests initialisiert.");

Added: modules/aitest/scripts/maps/aitest2.rb
===================================================================
--- modules/aitest/scripts/maps/aitest2.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/maps/aitest2.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,65 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+require 'debugkeys.rb'
+
+#require 'doortest.rb'
+
+require 'WallSet1.rb'
+require 'WallSet2.rb'
+
+require 'NpcTest.rb'
+require 'NpcCapsuleTest.rb'
+
+require 'WayPointTest.rb'
+#require 'TimeTest.rb'
+#require 'InventoryTest.rb'
+#require 'ErrorHandlingTest.rb'
+#require 'JobSequenceTest.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'aitest'...")
+
+$SCRIPT.log("Create hero")
+$hero = $GOM.createGameObjectProxy("hero", 1);
+
+$SCRIPT.log("Place hero into scene")
+#$hero.getGameObject().setPosition([1.0, 0.0, 0.0]);
+$hero.getGameObject().placeIntoScene()
+
+
+$SCRIPT.log("Prepare hero for being the active character")
+PlayerSettings.preparePlayer($hero.getGameObject())
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero.getGameObject())
+
+$SCRIPT.log("Hero ready")
+
+$SCRIPT.log("map 'aitest' initialisiert.");
+
+$debugkeys = DebugKeys.new();
+$UI.linkKeyToRubyCommand('G',"$debugkeys.toggleWP()");
+
+$SCRIPT.log("debug keys are set up");
+
+#DoorTest.new([0.0, 0.0, -5.0])
+
+#WallSet1.new([0, 0, 0])
+#WallSet2.new([0, 0, 0])
+
+WayPointTest.new([0, 0, 0])
+
+NpcTest.new([-5, 0, 5])
+NpcCapsuleTest.new([0, 0, 5])
+
+#TimeTest.new([-5, 0, -5])
+#ErrorHandlingTest.new([-10, 0, 5])
+#InventoryTest.new([0, 0, 10])
+#JobSequenceTest.new([5, 0, -5])
+$SCRIPT.log("tests initialisiert.");
+
+

Added: modules/aitest/scripts/maps/aitestold.rb
===================================================================
--- modules/aitest/scripts/maps/aitestold.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/maps/aitestold.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,65 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+require 'debugkeys.rb'
+
+#require 'doortest.rb'
+
+require 'WallSet1.rb'
+require 'WallSet2.rb'
+
+require 'NpcTest.rb'
+require 'NpcCapsuleTest.rb'
+
+require 'WayPointTest.rb'
+#require 'TimeTest.rb'
+#require 'InventoryTest.rb'
+#require 'ErrorHandlingTest.rb'
+#require 'JobSequenceTest.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'aitest'...")
+
+$SCRIPT.log("Create hero")
+$hero = $GOM.createGameObjectProxy("hero", 1);
+
+$SCRIPT.log("Place hero into scene")
+#$hero.getGameObject().setPosition([1.0, 0.0, 0.0]);
+$hero.getGameObject().placeIntoScene()
+
+
+$SCRIPT.log("Prepare hero for being the active character")
+PlayerSettings.preparePlayer($hero.getGameObject())
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero.getGameObject())
+
+$SCRIPT.log("Hero ready")
+
+$SCRIPT.log("map 'aitest' initialisiert.");
+
+$debugkeys = DebugKeys.new();
+$UI.linkKeyToRubyCommand('G',"$debugkeys.toggleWP()");
+
+$SCRIPT.log("debug keys are set up");
+
+#DoorTest.new([0.0, 0.0, -5.0])
+
+#WallSet1.new([0, 0, 0])
+#WallSet2.new([0, 0, 0])
+
+WayPointTest.new([0, 0, 0])
+
+NpcTest.new([-5, 0, 5])
+NpcCapsuleTest.new([0, 0, 5])
+
+#TimeTest.new([-5, 0, -5])
+#ErrorHandlingTest.new([-10, 0, 5])
+#InventoryTest.new([0, 0, 10])
+#JobSequenceTest.new([5, 0, -5])
+$SCRIPT.log("tests initialisiert.");
+
+

Added: modules/aitest/scripts/moduleconfig.rb
===================================================================
--- modules/aitest/scripts/moduleconfig.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/moduleconfig.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,30 @@
+include RlScript
+
+class AITestModule < ContentModule
+    def initialize()
+        super("aitest", "aitest", false, 20070303)
+    end
+
+    def getDependencies()
+        return ["common"]
+    end
+
+    def getTextureLocations()
+        return ["textures"]
+    end
+
+    def getModelLocations()
+        return []
+    end
+
+    def getSoundLocations()
+        return []
+    end
+
+    def start()
+        $CORE.loadMap("Octree", "aitest.scene", "aitest", "aitest.rb")
+        $World = $CORE.getWorld();
+    end
+end
+
+CoreSubsystem.getSingleton().registerModule(AITestModule.new())

Added: modules/aitest/scripts/testcase.rb
===================================================================
--- modules/aitest/scripts/testcase.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/aitest/scripts/testcase.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -0,0 +1,9 @@
+class TestCase
+    def initialize(center)
+        @center = center
+    end
+    def rel_pos(position)
+        vector_add(@center, position)
+    end
+end
+

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/common/scripts/globals.rb	2007-03-05 20:08:20 UTC (rev 3121)
@@ -16,6 +16,7 @@
 $DS = DialogSubsystem.getSingleton();
 $WF = WindowFactory.getSingleton();
 $AI = AgentManager.getSingleton();
+$WPGM = WayPointGraphManager.getSingleton();
 $DVM = DebugVisualsManager.getSingleton();
 $SCRIPT = ScriptSubsystem.getSingleton();
 

Modified: modules/modules.cfg
===================================================================
--- modules/modules.cfg	2007-03-05 18:22:38 UTC (rev 3120)
+++ modules/modules.cfg	2007-03-05 20:08:20 UTC (rev 3121)
@@ -4,6 +4,8 @@
 module=intro
 
 module=regressiontest
+module=aitest
+
 module=techdemo
 module=techdemo2
 



From natoka at mail.berlios.de  Mon Mar  5 21:12:09 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 5 Mar 2007 21:12:09 +0100
Subject: [Dsa-hl-svn] r3122 - in modules/aitest: maps scripts
Message-ID: <200703052012.l25KC97l010854@sheep.berlios.de>

Author: natoka
Date: 2007-03-05 21:12:07 +0100 (Mon, 05 Mar 2007)
New Revision: 3122

Added:
   modules/aitest/maps/graphtest.wpg
Modified:
   modules/aitest/scripts/WayPointTest.rb
   modules/aitest/scripts/WayPointTest2.rb
Log:
adding missing waypoint file
and fixing file paths

Added: modules/aitest/maps/graphtest.wpg
===================================================================
(Binary files differ)


Property changes on: modules/aitest/maps/graphtest.wpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/aitest/scripts/WayPointTest.rb
===================================================================
--- modules/aitest/scripts/WayPointTest.rb	2007-03-05 20:08:20 UTC (rev 3121)
+++ modules/aitest/scripts/WayPointTest.rb	2007-03-05 20:12:07 UTC (rev 3122)
@@ -71,10 +71,10 @@
 
     end
     def save()
-	@WPGraph.save("graphtest.wpg")
+	@WPGraph.save("modules/aitest/maps/graphtest.wpg")
     end
     def load()
-	@WPGraph.load("graphtest.wpg")
+	@WPGraph.load("modules/aitest/maps/graphtest.wpg")
     end
 #def clear()
 #	@WPGraph.

Modified: modules/aitest/scripts/WayPointTest2.rb
===================================================================
--- modules/aitest/scripts/WayPointTest2.rb	2007-03-05 20:08:20 UTC (rev 3121)
+++ modules/aitest/scripts/WayPointTest2.rb	2007-03-05 20:12:07 UTC (rev 3122)
@@ -5,10 +5,10 @@
 	@WPGraph = $WPGM.createWayPointGraph();
     end
     def save()
-	@WPGraph.save("graphtest.wpg")
+	@WPGraph.save("modules/aitest/maps/graphtest.wpg")
     end
     def load()
-	@WPGraph.load("graphtest.wpg")
+	@WPGraph.load("modules/aitest/maps/graphtest.wpg")
     end
 end
 



From natoka at mail.berlios.de  Mon Mar  5 21:19:06 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 5 Mar 2007 21:19:06 +0100
Subject: [Dsa-hl-svn] r3123 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200703052019.l25KJ64V011361@sheep.berlios.de>

Author: natoka
Date: 2007-03-05 21:19:01 +0100 (Mon, 05 Mar 2007)
New Revision: 3123

Modified:
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
fixed some param bug (missing &)
extended some comments in the WayPoint files

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-05 20:12:07 UTC (rev 3122)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-05 20:19:01 UTC (rev 3123)
@@ -25,15 +25,15 @@
 namespace rl
 {
 
-	//template <class Data>
 	/** Stores a waypointgraph and is capable of loading and saving it.
 	 */
+	//template <class NodeType>
 	class _RlAiExport WayPointGraph 
 		: public DebugVisualisable
 	{
 	public:
 		//! defines a list of waypoint nodes
-		typedef std::vector<WayPointNode*> WayPointNodeList;
+		typedef std::vector< WayPointNode* > WayPointNodeList;
 
 		/* default constructor
 		 */
@@ -98,7 +98,7 @@
 		 * @param position in world space whose nearest waypoint has to be found.
 		 * @returns WayPointNode pointer to a waypoint object
 		 */
-		const WayPointNode* getNearestWayPoint(const Ogre::Vector3 position) const;
+		const WayPointNode* getNearestWayPoint(const Ogre::Vector3& position) const;
 
 		/** retrieves the WayPoint at the specified index from the list
 		 * @param index of the waypoint to fetch.

Modified: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-05 20:12:07 UTC (rev 3122)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-05 20:19:01 UTC (rev 3123)
@@ -23,6 +23,14 @@
 {
 	class WayPointGraph;
 
+	/** Manager for WayPointGraphs.
+	 * Organizes the management of WayPointGraphs.
+	 * The really sexy thing here is that enhancing the whole
+	 * waypoint finding can be done right in this class by extending it
+	 * with a grid like algorithm storage for waypointgraphs. That would
+	 * most likely reduce searching for a waypoint drastically - _if_ there
+	 * are many waypoints. At the moment this not something to consider.
+	 */
 	class _RlAiExport WayPointGraphManager 
 		: protected Ogre::Singleton<WayPointGraphManager>
 	{

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-05 20:12:07 UTC (rev 3122)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-05 20:19:01 UTC (rev 3123)
@@ -224,7 +224,7 @@
 	output.close();
 }
 
-const WayPointNode* WayPointGraph::getNearestWayPoint(const Ogre::Vector3 position) const
+const WayPointNode* WayPointGraph::getNearestWayPoint(const Ogre::Vector3& position) const
 {
 	WayPointNodeList::const_iterator it;
 	WayPointNode* nearestWayPoint = NULL;

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-05 20:12:07 UTC (rev 3122)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-05 20:19:01 UTC (rev 3123)
@@ -136,7 +136,7 @@
 		void addDirectedConnection(rl::WayPointNode* wp1, const rl::WayPointNode* wp2);
 		void load (const Ogre::String& filename);
 		void save (const Ogre::String& filename) const;
-		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3 position) const;
+		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3& position) const;
 		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
 	};
 	



From natoka at mail.berlios.de  Mon Mar  5 22:36:43 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 5 Mar 2007 22:36:43 +0100
Subject: [Dsa-hl-svn] r3124 - modules/aitest/scripts/maps
Message-ID: <200703052136.l25Lahjw016394@sheep.berlios.de>

Author: natoka
Date: 2007-03-05 22:36:42 +0100 (Mon, 05 Mar 2007)
New Revision: 3124

Modified:
   modules/aitest/scripts/maps/aitest.rb
Log:
fixed uppercase bug

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-05 20:19:01 UTC (rev 3123)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-05 21:36:42 UTC (rev 3124)
@@ -2,7 +2,7 @@
 
 require 'player.rb'
 require 'hero.rb'
-require 'debugkeys.rb'
+require 'DebugKeys.rb'
 
 require 'doortest.rb'
 



From tanis at mail.berlios.de  Mon Mar  5 23:56:11 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 5 Mar 2007 23:56:11 +0100
Subject: [Dsa-hl-svn] r3125 - in rl/trunk/engine: ai/include ai/src
	core/include core/src rules rules/include rules/src script/swig
Message-ID: <200703052256.l25MuBMa021179@sheep.berlios.de>

Author: tanis
Date: 2007-03-05 23:55:49 +0100 (Mon, 05 Mar 2007)
New Revision: 3125

Modified:
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/include/GameObjectState.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Behaviours in the gof-file are now respected. If a Creature or subclass of it defines one or more behaviors, an Agent is created with said behaviours defined.
Sadly enough they Wander-Behaviors don't seem to work atm...

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/ai/include/Agent.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -23,8 +23,6 @@
 namespace rl
 {
 	class SteeringVehicle;
-	typedef FuzzyState<SteeringVehicle> SteeringBehaviour;
-
 	class SteeringMachine;
 	class DialogCharacter;
 	class Creature;
@@ -90,6 +88,8 @@
 		 */
 		SteeringVehicle* getVehicle();
 
+        Creature* getControlledCreature() const;
+
 //		PerceptionPool* getPerceptionPool();
 
 		// deprecated - for DialogBot

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -20,21 +20,35 @@
 #include "AiPrerequisites.h"
 //#include "PhysicsController.h"
 #include "GameTask.h"
+#include "GameObjectStateListener.h"
+#include "FuzzyState.h"
 
 namespace rl
 {
-	class Agent;
 	class Creature;
 	class SteeringVehicle;
 	class DialogCharacter;
+    class Agent;
 
+    typedef FuzzyState<SteeringVehicle> SteeringBehaviour;
+
+    class _RlAiExport BehaviourFactory
+    {
+    public:
+        BehaviourFactory() {}
+        virtual ~BehaviourFactory() {}
+
+        virtual SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
+    };
+
 	/** Executes AI during game as a RL::GameTask.
 	 * Each registered Agent gets executed once per gametask in order
 	 * to do its ai stuff (path finding, movement, decission making).
 	 */
 	class _RlAiExport AgentManager
 		: protected Ogre::Singleton<AgentManager>,
-		  public GameTask
+		  public GameTask,
+          public GameObjectStateListener
   	//	  public PhysicsController,
 		  
 	{
@@ -72,6 +86,9 @@
 		// Hint: it's deprecated
 		Agent* createAgent(DialogCharacter* character);
 
+        // Destroys an Agent and all its behaviours. (if any)
+        void destroyAgent(Agent*);
+
 		// ??? purpose ??? needed for opensteer ?
 
 		VehicleList getNeighbors(Agent* agent);
@@ -88,10 +105,19 @@
 		 */
 		void removeAllAgents();
 
-		/** Returns the name of this class - AgentManager for debugging purposes.
-		 */
+		/// Override from GameTask
+		/// Returns the name of this class - AgentManager for debugging purposes.
         virtual const Ogre::String& getName() const;
+
+        /// Override from GameObjectStateListener.
+        /// Used to create/destroy Agents
+        virtual void gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+            GameObjectState newState);
+
+        /// Set the factory to be used to create behaviours.
+        virtual void setBehaviourFactory(BehaviourFactory*);
 	private:
+
 		/** Used to register an agent internally.
 		 * Adds the given Agent to AgentList and its vehicle to mAllNeighbors.
 		 * @param agent Agent to be added
@@ -100,6 +126,9 @@
 
 		//! defines a std::list of Agents
 		typedef std::vector<Agent*> AgentList;
+
+        /// Factory to create behaviours with.
+        BehaviourFactory* mBehaviourFactory;
 		
 		//! List of Vehicle objects from the Agents in mAgents (might be needed for opensteer)
 		VehicleList mAllNeighbors;

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -142,4 +142,9 @@
 	return mDialogBot->isActive();
 }
 
+Creature* Agent::getControlledCreature() const
+{
+    return mCreature;
 }
+
+}

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -17,6 +17,7 @@
 #include "Agent.h"
 #include "PlayerVehicle.h"
 #include "Creature.h"
+#include "GameObjectManager.h"
 
 using namespace Ogre;
 
@@ -24,6 +25,14 @@
 
 namespace rl {
 
+struct FindAgentByControlledCreature : public std::binary_function<Agent*, Creature*, bool>
+{
+    bool operator()(Agent* agent, Creature* creature) const
+    {
+        return agent->getControlledCreature() == creature;
+    }
+};
+
 AgentManager& AgentManager::getSingleton(void)
 {
     return Singleton<AgentManager>::getSingleton();
@@ -34,13 +43,17 @@
     return Singleton<AgentManager>::getSingletonPtr();
 }
 
-AgentManager::AgentManager(void) : mAllNeighbors(), mAgents(), mPlayer(NULL)
+AgentManager::AgentManager(void)
+    : mBehaviourFactory(NULL), mAllNeighbors(), mAgents(), mPlayer(NULL)
 {
-
+    // Subscribe as listener to the GameObjectManager, in order to attach Agents to
+    // Creatures that are placed into the scene.
+    GameObjectManager::getSingleton().registerGameObjectStateListener(this);
 }
 
 AgentManager::~AgentManager(void)
 {
+    GameObjectManager::getSingleton().unregisterGameObjectStateListener(this);
 	removeAllAgents();
 }
 
@@ -69,6 +82,16 @@
 	return agent;
 }
 
+void AgentManager::destroyAgent(Agent* agent)
+{
+    AgentList::iterator it = std::find(mAgents.begin(), mAgents.end(), agent);
+    if (it != mAgents.end())
+    {
+        delete *it;
+        mAgents.erase(it);
+    }
+}
+
 void AgentManager::addAgent(Agent* agent)
 {
 	mAgents.push_back(agent);
@@ -90,22 +113,11 @@
 
 void AgentManager::run( Ogre::Real elapsedTime ) 
 {
-//	update agents
-	//if the loop below is reactivated, then remove this ...
-	if(mPlayer != NULL)
-	{
-		mPlayer->update(elapsedTime);
-	}
-
-  /*  for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
+    //	update agents
+    for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
     {
-	//  update agents of type "player" only
-		if((*itr)->getType() == AGENT_PLAYER)
-		{
-			(*itr)->update(elapsedTime);
-			break;
-		}
-    }*/
+	    (*itr)->update(elapsedTime);
+    }
 }
 
 void AgentManager::removeAllAgents()
@@ -126,4 +138,51 @@
     return NAME;
 }
 
+void AgentManager::gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+                                          GameObjectState newState)
+{
+    // if the GameObject is not a Creature, we can ignore it
+    Creature* creature = dynamic_cast<Creature*>(go);
+    if (creature == NULL) return;
+
+    if (oldState == GOS_IN_SCENE && newState != GOS_IN_SCENE)
+    {
+        // Remove the Agent and destroy it. Later we should pool them...
+        AgentList::iterator it = std::find_if(mAgents.begin(), mAgents.end(),
+            std::bind2nd(FindAgentByControlledCreature(), creature));
+        if (it != mAgents.end())
+        {
+            destroyAgent(*it);
+        }
+    }
+    else if (newState == GOS_IN_SCENE)
+    {
+        // Create an Agent and add the behaviours of the creature to it.
+        Property behaviorProperty = creature->getProperty(Creature::PROPERTY_BEHAVIOURS);
+        if (behaviorProperty.isArray())
+        {
+            std::vector<Property> behaviors = behaviorProperty.toArray();
+            if (!behaviors.empty())
+            {
+                Agent* agent = createAgent(AGENT_STD_NPC, creature);
+                for (std::vector<Property>::const_iterator it = behaviors.begin(),
+                    end = behaviors.end(); it != end; ++it)
+                {
+                    if (it->isString())
+                    {
+                        SteeringBehaviour* behavior =
+                            mBehaviourFactory->createBehaviour(it->toString().c_str());
+                        agent->addSteeringBehaviour(behavior);
+                    }
+                }
+            }
+        }
+    }
 }
+
+void AgentManager::setBehaviourFactory(BehaviourFactory* factory)
+{
+    mBehaviourFactory = factory;
+}
+
+}

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -61,7 +61,7 @@
 	void quitGame();
 
     /// Returns time since game started in Milliseconds.
-    unsigned long getClock();
+    unsigned long getClock() const;
 
     /// Main loop of RL.
     void loop();

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -189,7 +189,7 @@
             / std::max(mLastTimes.size(), (size_t)1);
     }
 
-    unsigned long GameLoop::getClock()
+    unsigned long GameLoop::getClock() const
     {
         return mGameTime;
     }

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-03-05 22:55:49 UTC (rev 3125)
@@ -519,6 +519,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\GameObjectStateListener.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Inventory.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -110,6 +110,7 @@
 		typedef std::map<const CeGuiString, TalentStateSet*> TalentMap;
 
         static const Ogre::String CLASS_NAME;
+        static const Ogre::String PROPERTY_BEHAVIOURS; 
 
         Creature(unsigned int id);
 		        
@@ -1017,6 +1018,8 @@
         /// Zeigt auf das Inventar der Kreatur.
 		Inventory* mInventory;
 
+        Property mBehaviours;
+
         /**
          *  Sets a the status \a statusVariable. It uses a reference counting
          *  System to do this, so if for example severeal effects put the creature

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -18,6 +18,8 @@
 #define __GAMEOBJECTMANAGER_H__
 
 #include "RulesPrerequisites.h"
+#include "GameObjectStateListener.h"
+
 #include <OgreScriptLoader.h>
 #include <OgreSingleton.h>
 #include <map>
@@ -38,7 +40,9 @@
     };
 
     class _RlRulesExport GameObjectManager : 
-        public Ogre::Singleton<GameObjectManager>, public Ogre::ScriptLoader
+        public Ogre::Singleton<GameObjectManager>,
+        public GameObjectStateListener,
+        public Ogre::ScriptLoader
     {
     public:
         GameObjectManager();
@@ -54,8 +58,17 @@
         virtual Ogre::Real getLoadingOrder() const;
         virtual void parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName);
 
+        /// Override from GameObjectStateListener.
+        /// Used to propagate to global GameObjectStateListeners.
+        virtual void gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+            GameObjectState newState);
+
+        void registerGameObjectStateListener(GameObjectStateListener* listener);
+        void unregisterGameObjectStateListener(GameObjectStateListener* listener);
+
     private:
         typedef std::map<const Ogre::String, PropertySet*> ClassPropertyMap;
+        typedef std::set<GameObjectStateListener*> GameObjectStateListenerSet;
 
         Ogre::StringVector mScriptPatterns;
 
@@ -64,6 +77,7 @@
         ClassPropertyMap mClassProperties;
         unsigned int mGeneratedId;
         GameObjectFactory* mGameObjectFactory;
+        GameObjectStateListenerSet mGameObjectStateListeners;
 
         unsigned int generateId();
         PropertySet* getClassProperties(const Ogre::String& classId);

Modified: rl/trunk/engine/rules/include/GameObjectState.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectState.h	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/include/GameObjectState.h	2007-03-05 22:55:49 UTC (rev 3125)
@@ -19,15 +19,17 @@
 
 namespace rl {
 
+    /// Basic states, a GameObject can have.
+    /// Values are chosen so, that they are maskable.
     enum GameObjectState
     {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
+        GOS_UNDEFINED     =  0, ///!< Nothing known about such a GO.
+        GOS_UNLOADED      =  1, ///!< GO is known, but its actual properties are not loaded yet.
+        GOS_LOADED        =  2, ///!< GO is loaded, unused.
+        GOS_IN_POSSESSION =  4, ///!< GO is owned by another GO. (e.g. inside a chest)
+        GOS_IN_SCENE      =  8, ///!< GO is placed openly in the scene.
+        GOS_HELD          = 16, ///!< GO is held openly by another GO. (e.g. apple in NPC's hand)
+        GOS_READY         = 32  ///!< GO is ready for usage by another GO. (sword in NPC's hand)
     };
 }
 

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -36,6 +36,7 @@
 namespace rl
 {
     const Ogre::String Creature::CLASS_NAME = "Creature";
+    const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
 
     Creature::Creature(unsigned int id)
         : GameObject(id), 
@@ -1127,30 +1128,30 @@
 
     void Creature::setProperty(const Ogre::String &key, const rl::Property &value)
     {
-        //if (key == Creature::PROPERTY_)
-        //{
-        //    mImageName = value.toString();
-        //}
-        //else
-        //{
+        if (key == Creature::PROPERTY_BEHAVIOURS)
+        {
+            mBehaviours = value;
+        }
+        else
+        {
             GameObject::setProperty(key, value);
-        //}
+        }
     }
 
     const Property Creature::getProperty(const Ogre::String &key) const
     {
-        //if (key == Item::PROPERTY_IMAGENAME)
-        //{
-        //    return Property(mImageName);
-        //}
+        if (key == Creature::PROPERTY_BEHAVIOURS)
+        {
+            return mBehaviours;
+        }
         //else if (key == Item::PROPERTY_SIZE)
         //{
         //    return Property(mSize);
         //}
-        //else
-        //{
+        else
+        {
             return GameObject::getProperty(key);
-        //}
+        }
     }
 
     PropertySet* Creature::getAllProperties() const

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -23,6 +23,7 @@
 #include "ObjectStateChangeEventSource.h"
 #include "Property.h"
 #include "RulesSubsystem.h"
+#include "GameObjectManager.h"
 
 using namespace std;
 
@@ -56,7 +57,9 @@
         // Standardactions registrieren
 		Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
 		if (defaultAction != NULL)
-			addAction(defaultAction);
+        {
+            addAction(defaultAction);
+        }
 
 		// Eventsource erzeugen
 		setObject(this);
@@ -505,25 +508,35 @@
 
     void GameObject::placeIntoScene()
     {
-        Actor* actor = createActor();
+        if (mState != GOS_IN_SCENE)
+        {
+            Actor* actor = createActor();
 
-        actor->placeIntoScene();
-        setActor(actor);
+            actor->placeIntoScene();
+            setActor(actor);
 
-        mState = GOS_IN_SCENE;
+            GameObjectState tmpState = mState;
+            mState = GOS_IN_SCENE;
+            GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+        }
     }
 
     void GameObject::removeFromScene()
     {
-        Actor* actor = mActor;
-        mOrientation = actor->getWorldOrientation();
-        mPosition = actor->getWorldPosition();
+        if (mState != GOS_IN_SCENE)
+        {
+            Actor* actor = mActor;
+            mOrientation = actor->getWorldOrientation();
+            mPosition = actor->getWorldPosition();
 
-        setActor(NULL);
-        actor->removeFromScene();
-        ActorManager::getSingleton().destroyActor(actor);
+            setActor(NULL);
+            actor->removeFromScene();
+            ActorManager::getSingleton().destroyActor(actor);
 
-        mState = GOS_LOADED;
+            GameObjectState tmpState = mState;
+            mState = GOS_LOADED;
+            GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+        }
     }
 
     void GameObject::setState(GameObjectState targetstate)
@@ -533,29 +546,16 @@
             return;
         }
 
-        bool stateChange = false;
-
-        if (targetstate == GOS_LOADED)
+        if (targetstate == GOS_LOADED && mState == GOS_IN_SCENE)
         {
-            if (mState == GOS_IN_SCENE)
-            {
-                removeFromScene();
-                stateChange = true;
-            }
+            //Statechange-Event is triggered in this function
+            removeFromScene();
         }
-        else if (targetstate == GOS_IN_SCENE)
+        else if (targetstate == GOS_IN_SCENE && mState == GOS_LOADED)
         {
-            if (mState == GOS_LOADED)
-            {
-                placeIntoScene();
-                stateChange = true;
-            }
+            //Statechange-Event is triggered in this function
+            placeIntoScene();
         }
-
-        if (stateChange)
-        {
-            mState = targetstate;
-        }
     }
 
     GameObjectState GameObject::getState() const

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-05 22:55:49 UTC (rev 3125)
@@ -155,6 +155,26 @@
         mGameObjectFactory = gof;
     }
 
+    void GameObjectManager::gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+        GameObjectState newState)
+    {
+        for (GameObjectStateListenerSet::iterator it = mGameObjectStateListeners.begin();
+            it != mGameObjectStateListeners.end(); ++it)
+        {
+            (*it)->gameObjectStateChanged(go, oldState, newState);
+        }
+    }
+
+    void GameObjectManager::registerGameObjectStateListener(GameObjectStateListener* listener)
+    {
+        mGameObjectStateListeners.insert(listener);
+    }
+
+    void GameObjectManager::unregisterGameObjectStateListener(GameObjectStateListener* listener)
+    {
+        mGameObjectStateListeners.erase(listener);
+    }
+
     GameObjectFactory::GameObjectFactory()
     {
     }

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-05 21:36:42 UTC (rev 3124)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-05 22:55:49 UTC (rev 3125)
@@ -86,6 +86,16 @@
 		static AiSubsystem& getSingleton(void);
 	};
 	
+	%feature("director") BehaviourFactory;
+    class BehaviourFactory
+    {
+    public:
+        BehaviourFactory();
+        virtual ~BehaviourFactory();
+
+        virtual SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
+    };
+    
 	class AgentManager
 	{
 	public:
@@ -100,6 +110,8 @@
 		static AgentManager& getSingleton(void);
 		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
 		rl::Agent* createAgent(rl::DialogCharacter* character);
+		
+        virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
 	
     class PhysicalObstacle {



From tanis at mail.berlios.de  Tue Mar  6 00:00:46 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 6 Mar 2007 00:00:46 +0100
Subject: [Dsa-hl-svn] r3126 - in modules: . combattest combattest/dsa
	combattest/maps combattest/materials
	combattest/materials/textures combattest/models
	combattest/scripts combattest/scripts/maps
Message-ID: <200703052300.l25N0kDO021734@sheep.berlios.de>

Author: tanis
Date: 2007-03-05 23:56:36 +0100 (Mon, 05 Mar 2007)
New Revision: 3126

Added:
   modules/combattest/
   modules/combattest/dsa/
   modules/combattest/dsa/gameobjectdefinitions.gof
   modules/combattest/maps/
   modules/combattest/maps/combattest.scene
   modules/combattest/maps/combattest_floorplane.mesh
   modules/combattest/materials/
   modules/combattest/materials/nx.grid.material
   modules/combattest/materials/nx.particles.material
   modules/combattest/materials/nx.shapes.material
   modules/combattest/materials/nx.stairs.material
   modules/combattest/materials/nx.track.material
   modules/combattest/materials/nx.zones.material
   modules/combattest/materials/textures/
   modules/combattest/materials/textures/nx.grid.axis.png
   modules/combattest/materials/textures/nx.grid.floor.png
   modules/combattest/materials/textures/nx.particle.smoke.png
   modules/combattest/materials/textures/nx.particle.steam.png
   modules/combattest/materials/textures/nx.static.wall.png
   modules/combattest/materials/textures/nx.trafficcone.png
   modules/combattest/materials/textures/nx.zone.blue.png
   modules/combattest/materials/textures/nx.zone.green.png
   modules/combattest/materials/textures/nx.zone.nogravity.png
   modules/combattest/materials/textures/nx.zone.orange.png
   modules/combattest/materials/textures/nx.zone.pink.png
   modules/combattest/materials/textures/wolf1.dds
   modules/combattest/materials/tie_wolf_01.material
   modules/combattest/medianotes.txt
   modules/combattest/models/
   modules/combattest/models/cube.1m-2m-1m.mesh
   modules/combattest/models/cube.1m.mesh
   modules/combattest/models/nx.chair.mesh
   modules/combattest/models/nx.convex1.mesh
   modules/combattest/models/nx.crosshair.mesh
   modules/combattest/models/nx.raycaster.mesh
   modules/combattest/models/nx.stairs1.mesh
   modules/combattest/models/nx.trafficcone.mesh
   modules/combattest/models/sphere.1m.mesh
   modules/combattest/models/tie_wolf_01.mesh
   modules/combattest/models/tie_wolf_01_mesh.skeleton
   modules/combattest/scripts/
   modules/combattest/scripts/maps/
   modules/combattest/scripts/maps/combattest.rb
   modules/combattest/scripts/moduleconfig.rb
   modules/combattest/sound/
Log:
Added new combattest module. Doesn't do much yet.

Added: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+  <gameobjectclass classid="Wolf" baseclass="Creature">
+    <property name="classid" type="STRING" data="Wolf"/>
+    <property name="baseclass" type="STRING" data="Creature"/>
+    <property name="name" type="STRING" data="Wolf"/>
+    <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
+    <property name="description_dead" type="STRING" data="Ein sehr toter Wolf"/>
+    <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
+    <property name="mass" type="REAL" data="0"/>
+    <property name="geometrytype" type="STRING" data="sphere"/>
+    <property name="behaviours" type="ARRAY">
+    	<property type="STRING" data="DefaultWanderBehaviour"/>
+    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
+    </property>
+  </gameobjectclass>
+</GameObjectDefinitions>

Added: modules/combattest/maps/combattest.scene
===================================================================
--- modules/combattest/maps/combattest.scene	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/maps/combattest.scene	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,9 @@
+<scene formatVersion="0.2.0">
+    <nodes>
+        <node>
+            <position x="0.0" y="0.0" z="0.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+            <entity meshFile="combattest_floorplane.mesh"/>
+        </node>
+    </nodes>
+</scene>

Added: modules/combattest/maps/combattest_floorplane.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/maps/combattest_floorplane.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/nx.grid.material
===================================================================
--- modules/combattest/materials/nx.grid.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.grid.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,34 @@
+material nx.grid
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            
+            texture_unit
+            {
+                max_anisotropy 8
+                filtering anisotropic
+                texture nx.grid.floor.png
+            }
+        }
+    }
+}
+
+material nx.axis
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            scene_blend alpha_blend
+            
+            texture_unit
+            {
+                texture nx.grid.axis.png
+            }
+        }
+    }
+}

Added: modules/combattest/materials/nx.particles.material
===================================================================
--- modules/combattest/materials/nx.particles.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.particles.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,59 @@
+material nx.fx-mat.magic
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend add
+			depth_write off
+
+			point_sprites on
+			point_size 2
+			point_size_attenuation on
+
+			texture_unit
+			{
+				texture flare.png
+			}
+		}
+	}
+}
+
+material nx.smoke
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.smoke.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
+
+material nx.steam
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.steam.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/combattest/materials/nx.shapes.material
===================================================================
--- modules/combattest/materials/nx.shapes.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.shapes.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,137 @@
+material nx.cube
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.5 0.000000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.cube.alt
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.sphere
+{
+
+	technique
+	{
+		pass
+		{
+			shading phong
+			ambient 0 1.0 0.8
+			diffuse 0 1.0 0.0.77
+			specular 0 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.convex1
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.6 1.0 0.8
+			diffuse 0.6 1.0 0.77
+			specular 0.6 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.chair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.4 1.0 0.8
+			diffuse 0.4 1.0 0.77
+			specular 0.4 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.a
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.5 0.5 0.5
+			diffuse 0.5 0.5 0.5
+			specular 0.5 0.5 0.5 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.b
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.raycaster
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.1 0.1 0.1
+			diffuse 0.1 0.1 0.1
+			specular 0.1 0.1 0.1
+			shading phong
+		}
+	}
+}
+
+material nx.crosshair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.0 1.0 1.0
+			diffuse 1.0 1.0 1.0
+			specular 1.0 1.0 1.0
+			shading phong
+		}
+	}
+}
+
+

Added: modules/combattest/materials/nx.stairs.material
===================================================================
--- modules/combattest/materials/nx.stairs.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.stairs.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,14 @@
+material nx.wall
+{
+	technique
+	{
+		pass
+		{
+			diffuse 0.800000 0.800000 0.800000
+			texture_unit
+			{
+				texture nx.static.wall.png
+			}
+		}
+	}
+}

Added: modules/combattest/materials/nx.track.material
===================================================================
--- modules/combattest/materials/nx.track.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.track.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1 @@
+

Added: modules/combattest/materials/nx.zones.material
===================================================================
--- modules/combattest/materials/nx.zones.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/nx.zones.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,64 @@
+material nx.zone.green
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.green.png
+			}
+		}
+	}
+}
+
+material nx.zone.orange
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.orange.png
+			}
+		}
+	}
+}
+
+material nx.zone.blue
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.blue.png
+			}
+		}
+	}
+}
+
+material nx.zone.marker.nogravity
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend
+			
+			texture_unit
+			{
+				texture nx.zone.nogravity.png
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/combattest/materials/textures/nx.grid.axis.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.grid.axis.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.grid.floor.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.grid.floor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.particle.smoke.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.particle.smoke.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.particle.steam.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.particle.steam.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.static.wall.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.static.wall.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.trafficcone.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.trafficcone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.zone.blue.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.zone.blue.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.zone.green.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.zone.green.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.zone.nogravity.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.zone.nogravity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.zone.orange.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.zone.orange.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/nx.zone.pink.png
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/nx.zone.pink.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/textures/wolf1.dds
===================================================================
(Binary files differ)


Property changes on: modules/combattest/materials/textures/wolf1.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/materials/tie_wolf_01.material
===================================================================
--- modules/combattest/materials/tie_wolf_01.material	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/materials/tie_wolf_01.material	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,15 @@
+material 02_-_Default
+{
+	technique
+	{
+		pass
+		{
+			alpha_rejection greater 128
+
+			texture_unit
+			{
+				texture wolf1.dds
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/combattest/medianotes.txt
===================================================================
--- modules/combattest/medianotes.txt	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/medianotes.txt	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,5 @@
+All media files starting with nx. are taken from NxOgre.
+
+		(C) Robin Southern <betajaen at ihoed.com>
+
+They don't fall under our media distribution restrictions. They are free to use for other projects as long as his name is shown in the credits.

Added: modules/combattest/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/cube.1m-2m-1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/cube.1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/cube.1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.chair.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.chair.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.convex1.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.convex1.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.crosshair.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.crosshair.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.raycaster.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.raycaster.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.stairs1.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.stairs1.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/nx.trafficcone.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/nx.trafficcone.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/sphere.1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/sphere.1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/tie_wolf_01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/models/tie_wolf_01_mesh.skeleton
===================================================================
(Binary files differ)


Property changes on: modules/combattest/models/tie_wolf_01_mesh.skeleton
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/scripts/maps/combattest.rb	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,27 @@
+require 'player.rb'
+require 'hero.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'regressiontest'...")
+
+$SCRIPT.log("Create hero")
+$hero = $GOM.createGameObjectProxy("hero", 1);
+
+$SCRIPT.log("Place hero into scene")
+$hero.getGameObject().placeIntoScene()
+
+$SCRIPT.log("Prepare hero for being the active character")
+PlayerSettings.preparePlayer($hero.getGameObject())
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero.getGameObject())
+$SCRIPT.log("Hero ready")
+
+wolf = $GOM.createGameObjectProxy("Wolf").getGameObject()
+wolf.placeIntoScene
+wolf.setPosition [0.0,0.0,-5.0]
+
+$SCRIPT.log("map 'combattest' initialisiert.")
+

Added: modules/combattest/scripts/moduleconfig.rb
===================================================================
--- modules/combattest/scripts/moduleconfig.rb	2007-03-05 22:55:49 UTC (rev 3125)
+++ modules/combattest/scripts/moduleconfig.rb	2007-03-05 22:56:36 UTC (rev 3126)
@@ -0,0 +1,31 @@
+include RlScript
+
+class CombatTestModule < ContentModule
+    def initialize()
+        super("combattest", "combattest", false, 200108026)
+    end
+
+    def getDependencies()
+        return ["common"]
+    end
+
+    def getTextureLocations()
+        return ["textures"]
+    end
+
+    def getModelLocations()
+        return []
+    end
+
+    def getSoundLocations()
+        return []
+    end
+
+    def start()
+        $CORE.loadMap("Octree", "combattest.scene",
+            "combattest", "combattest.rb")
+        $World = $CORE.getWorld();
+    end
+end
+
+CoreSubsystem.getSingleton().registerModule(CombatTestModule.new())



From tanis at mail.berlios.de  Tue Mar  6 00:03:29 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 6 Mar 2007 00:03:29 +0100
Subject: [Dsa-hl-svn] r3127 - in modules: . aitest/dsa common/scripts
	regressiontest/dsa techdemo2/dsa
Message-ID: <200703052303.l25N3T6s021933@sheep.berlios.de>

Author: tanis
Date: 2007-03-06 00:03:10 +0100 (Tue, 06 Mar 2007)
New Revision: 3127

Modified:
   modules/aitest/dsa/gameobjectdefinitions.gof
   modules/common/scripts/globals.rb
   modules/modules.cfg
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/techdemo2/dsa/td2objects.gof
Log:
changed behaviours in gof files to actual behaviour class names. Created RubyBehaviourFactory.

Modified: modules/aitest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-05 22:56:36 UTC (rev 3126)
+++ modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-05 23:03:10 UTC (rev 3127)
@@ -27,8 +27,8 @@
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
         <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="default_idle_behaviour"/>
-            <property type="STRING" data="dialog_behaviour"/>
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
         </property>
     </gameobjectclass>
 
@@ -42,8 +42,8 @@
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
         <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="default_idle_behaviour"/>
-            <property type="STRING" data="dialog_behaviour"/>
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
         </property>
     </gameobjectclass>
 

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-03-05 22:56:36 UTC (rev 3126)
+++ modules/common/scripts/globals.rb	2007-03-05 23:03:10 UTC (rev 3127)
@@ -1,5 +1,3 @@
-load "embed.rb"
-
 print( "\n- Registering Globals" );
 
 include RlScript
@@ -51,4 +49,19 @@
 rgof = RubyGameObjectFactory.new();
 $GOM.setGameObjectFactory(rgof);
 
+require 'steering.rb'
+
+class RubyBehaviourFactory < BehaviourFactory
+  def initialize()
+    super();
+  end
+
+  def createBehaviour(classname)
+    return Module.const_get(classname).new();
+  end
+end
+
+rbf = RubyBehaviourFactory.new();
+$AI.setBehaviourFactory(rbf);
+
 require( "questsound.rb" );

Modified: modules/modules.cfg
===================================================================
--- modules/modules.cfg	2007-03-05 22:56:36 UTC (rev 3126)
+++ modules/modules.cfg	2007-03-05 23:03:10 UTC (rev 3127)
@@ -3,6 +3,7 @@
 module=common
 module=intro
 
+module=combattest
 module=regressiontest
 module=aitest
 

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-05 22:56:36 UTC (rev 3126)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-05 23:03:10 UTC (rev 3127)
@@ -27,8 +27,8 @@
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
         <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="default_idle_behaviour"/>
-            <property type="STRING" data="dialog_behaviour"/>
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
         </property>
     </gameobjectclass>
 
@@ -42,8 +42,8 @@
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
         <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="default_idle_behaviour"/>
-            <property type="STRING" data="dialog_behaviour"/>
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
         </property>
     </gameobjectclass>
 

Modified: modules/techdemo2/dsa/td2objects.gof
===================================================================
--- modules/techdemo2/dsa/td2objects.gof	2007-03-05 22:56:36 UTC (rev 3126)
+++ modules/techdemo2/dsa/td2objects.gof	2007-03-05 23:03:10 UTC (rev 3127)
@@ -16,7 +16,7 @@
     <property name="orientation" type="QUATERNION" data="0.0, 180.0, 0.0"/>
     <property name="dialogfile" type="STRING" data="wolfram.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
     	<property type="STRING" data="dialog_behaviour"/>
     </property>
   </gameobjectclass>
@@ -33,8 +33,8 @@
     <property name="orientation" type="QUATERNION" data="0.0, 120.94, 0.0"/>
     <property name="dialogfile" type="STRING" data="sonja.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="dialog_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="DialogBehaviour"/>
     </property>
   </gameobjectclass>
   
@@ -50,8 +50,8 @@
     <property name="orientation" type="QUATERNION" data="0.0, 120.94, 0.0"/>
     <property name="dialogfile" type="STRING" data="sonja2.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="dialog_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="DialogBehaviour"/>
     </property>
   </gameobjectclass>
   
@@ -67,8 +67,8 @@
     <property name="orientation" type="QUATERNION" data="0.0, -23.40, 0.0"/>
     <property name="dialogfile" type="STRING" data="jarn.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="dialog_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="DialogBehaviour"/>
     </property>
   </gameobjectclass>
   
@@ -84,8 +84,8 @@
     <property name="orientation" type="QUATERNION" data="0.0, 50.0, 0.0"/>
     <property name="dialogfile" type="STRING" data="wolfram.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="dialog_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="DialogBehaviour"/>
     </property>
   </gameobjectclass>
   
@@ -100,9 +100,9 @@
     <property name="position" type="VECTOR3" data="-20.83, -6.70, 19.46"/>
     <property name="dialogfile" type="STRING" data="forrest.xml"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="avoid_obstacles_behaviour"/>
-    	<property type="STRING" data="dialog_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
+    	<property type="STRING" data="DialogBehaviour"/>
     </property>
   </gameobjectclass>
   
@@ -142,8 +142,8 @@
     <property name="mass" type="REAL" data="0"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
     <property name="behaviours" type="ARRAY">
-    	<property type="STRING" data="default_idle_behaviour"/>
-    	<property type="STRING" data="avoid_obstacles_behaviour"/>
+    	<property type="STRING" data="DefaultIdleBehaviour"/>
+    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
     </property>
   </gameobjectclass>
   



From tanis at mail.berlios.de  Tue Mar  6 17:01:50 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 6 Mar 2007 17:01:50 +0100
Subject: [Dsa-hl-svn] r3128 - rl/trunk/engine/rules/include
Message-ID: <200703061601.l26G1oPO028410@sheep.berlios.de>

Author: tanis
Date: 2007-03-06 17:01:45 +0100 (Tue, 06 Mar 2007)
New Revision: 3128

Added:
   rl/trunk/engine/rules/include/GameObjectStateListener.h
Log:
File missed in my last commit.

Added: rl/trunk/engine/rules/include/GameObjectStateListener.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectStateListener.h	2007-03-05 23:03:10 UTC (rev 3127)
+++ rl/trunk/engine/rules/include/GameObjectStateListener.h	2007-03-06 16:01:45 UTC (rev 3128)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_GAMEOBJECTSTATELISTENER_H__
+#define __RL_GAMEOBJECTSTATELISTENER_H__
+
+#include "GameObjectState.h"
+
+namespace rl {
+
+    class GameObject;
+
+    class GameObjectStateListener
+    {
+    public:
+        virtual void gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+            GameObjectState newState)=0;
+    };
+}
+
+#endif



From natoka at mail.berlios.de  Tue Mar  6 18:44:14 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 18:44:14 +0100
Subject: [Dsa-hl-svn] r3129 - in rl/trunk/engine/ai: include src
Message-ID: <200703061744.l26HiEO8031556@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 18:43:52 +0100 (Tue, 06 Mar 2007)
New Revision: 3129

Modified:
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/src/WayPointGraph.cpp
Log:
adding additional comments, corrected some comments

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/Agent.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -49,8 +49,10 @@
 		 */
 		Agent(Creature* character, SteeringVehicle* vehicle);
 
-		// deprecated
+		/** deprecated
+		 */
 		Agent(DialogCharacter* character);
+
 		/** explicit virtual destructor
 		 */
 		virtual ~Agent(void);
@@ -63,10 +65,10 @@
 		 */
 		void initialize();
 
-		/** Returns the agent type (Player, NPC, ...).
+		/** Returns the agent type (Player, NPC, etc.).
 		 */
 		AgentManager::AgentType getType();
-		/** Sets the agent type (Player, NPC, ...).
+		/** Sets the agent type (Player, NPC, etc. ).
 		 * @param type AgentType sets the type to the given one.
 		 */
 		void setType(AgentManager::AgentType type);
@@ -88,11 +90,14 @@
 		 */
 		SteeringVehicle* getVehicle();
 
+		/** Retrieves the Creature object controlled by this agent
+		 * @returns Creature object controlled
+		 */
         Creature* getControlledCreature() const;
 
 //		PerceptionPool* getPerceptionPool();
 
-		// deprecated - for DialogBot
+		//! deprecated - for DialogBot
 		bool isDialogActive();
 
 		/** Function invoked by PhysicsManager whenever force/torque is to be
@@ -111,7 +116,7 @@
 		//! stores the creature whose AI is simulated
 		Creature* mCreature;
 
-		// deprecated
+		//! deprecated - for DialogBot
 		DialogCharacter* mDialogBot;
 //		PerceptionPool* mPerceptionPool;
 	};

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -53,7 +53,10 @@
 		  
 	{
 	public:
-		// Different types of agents
+		/** Different types of agents.
+		 * Implemented in order to recognise different types of agents, because
+		 * the AI needs to handle them differently.
+		 */
 		enum AgentType
 		{
 			AGENT_NONE = -1,	//!< when the type is unknown/unset
@@ -70,9 +73,9 @@
 		//! defines a std::vector list of Vehicle objects for OpenSteer
 		typedef std::vector<SteeringVehicle*> VehicleList;
 
-		// default constructor
+		//! default constructor
 		AgentManager(void);
-		// explicit virtual destructor
+		//! explicit virtual destructor
 		virtual ~AgentManager(void);
 
 		/** Creates an AI agent with an assigned rl::Actor.
@@ -82,15 +85,14 @@
 		 */
 		Agent* createAgent(AgentType type, Creature* character);
 
-		// ok, this is something that should be removed in the long run
-		// Hint: it's deprecated
+		//! deprecated - should be removed in the long run.
+		//! Hint: it's deprecated
 		Agent* createAgent(DialogCharacter* character);
 
-        // Destroys an Agent and all its behaviours. (if any)
+        //! Destroys an Agent and all its behaviours. (if any)
         void destroyAgent(Agent*);
 
-		// ??? purpose ??? needed for opensteer ?
-
+		//! ??? purpose ??? needed for opensteer ?
 		VehicleList getNeighbors(Agent* agent);
 
 		/** Interface executed as a GameTask by GameLoop.
@@ -124,10 +126,10 @@
 		 */
 		void addAgent(Agent* agent);
 
-		//! defines a std::list of Agents
+		//! defines a std::vector of Agents to ease understanding
 		typedef std::vector<Agent*> AgentList;
 
-        /// Factory to create behaviours with.
+        //! Factory to create behaviours with.
         BehaviourFactory* mBehaviourFactory;
 		
 		//! List of Vehicle objects from the Agents in mAgents (might be needed for opensteer)

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -28,6 +28,7 @@
 	class AiWorld;
 
 	/** Central core of AI
+	 * Handles creation of all AI related object Managers.
 	 */
 	class _RlAiExport AiSubsystem 
 		: public Ogre::Singleton<AiSubsystem>,
@@ -44,7 +45,7 @@
 		/** explicit virtual destructor.
 		 * Unregisters Scene listener, makes AgentManager drop all Agents,
 		 * unregisters AgentManager from GameLoop,
-		 * deletes AgentManager and AiWorld
+		 * deletes AgentManager, WayPointGraphManager and AiWorld
 		 */
 		virtual ~AiSubsystem(void);
 		

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -94,7 +94,13 @@
 		 */
 		Ogre::Vector3 calcFlee(const Ogre::Vector3& target);
 
+		/**
+		 * Causes the vehicle to turn to a target and move to it.
+		 * @param agent to persue
+		 * @return a steering force for persuing the given agent
+		 */
 		Ogre::Vector3 calcPursuit(Agent* agent);
+
 		/**
 		 * Causes the vehicle to turn away from obstacles in space. 
 		 * The vehicle will consider all close-by obstacles automatically

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -25,7 +25,10 @@
 namespace rl
 {
 
-	/** Stores a waypointgraph and is capable of loading and saving it.
+	/** Stores a waypointgraph containing a map of waypoints.
+	 * It is capable of loading and saving it the map of waypoints and
+	 * manipulating it.
+	 * Debugging the graph by visualising it is also possible.
 	 */
 	//template <class NodeType>
 	class _RlAiExport WayPointGraph 
@@ -35,7 +38,8 @@
 		//! defines a list of waypoint nodes
 		typedef std::vector< WayPointNode* > WayPointNodeList;
 
-		/* default constructor
+		/* default constructor.
+		 * initialises internal variables.
 		 */
 		WayPointGraph();
 		/* explicit virtual destructor.
@@ -69,6 +73,8 @@
 
 
 		/** loads the Waypoints from a file.
+		 * The Load functionality uses the module path querying of the
+		 * configuration module in oder to fetch the module directory path.
 		 * @param filename of the file to load.
 		 */
 		void load (const Ogre::String& filename);
@@ -76,8 +82,8 @@
 		 * Structure of the file is as follows:
 		 * Header\n
 		 * numberOfWaypoints\n
-		 * waypoint1.x waypoint1.y waypoint1.z waypoint2.x ...\n
-		 * 4 1 2 3 4\n
+		 * waypoint0.x waypoint0.y waypoint0.z waypoint0.type waypoint1.x ...\n
+		 * numberOfConnections connectionindex1 connectionindex2 ...\n
 		 * ...
 		 * \n
 		 * \n
@@ -85,10 +91,11 @@
 		 * As you can see the waypoint coordinates are written consecutivily on one line
 		 * and the connections of one waypoint to the others are written per waypoint on one line.
 		 * The first number gives the number of connections and the rest are the indices of the
-		 * waypoints the connections have to be made to.
-		 * If the line is empty that means that the waypoint has got not other waypoints to connect to
-		 * (very unlikely)
-		 * the file is terminated either with end of file or two newlines.
+		 * waypoints the connections have to be made to. That index given by the order of the
+		 * the list of WayPoints in the file. It starts with 0.
+		 * If the line is just contains a 0 for numberOfConnections that means that the
+		 * waypoint has got not other waypoints to connect to (very unlikely).
+		 * The file is terminated either with end of file or two newlines.
 		 *
 		 * @param filename of the file to save to.
 		 */
@@ -145,18 +152,6 @@
 		WayPointNodeList mNodeList;
 	};
 
-	/*
-	class WayPointGraphDebugger
-	{
-		WayPointGraphDebugger();
-		~WayPointGraphDebugger();
-
-		void init( Ogre::SceneManager* smgr );
-		void deInit();
-		void showLines( WayPointGraph* graph );
-		void hideLines();
-	};
-	*/
 };
 
 #endif
\ No newline at end of file

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-03-06 17:43:52 UTC (rev 3129)
@@ -32,11 +32,11 @@
 		//! defines the different types of terrain
 		enum WayPointNodeType 
 		{
-			WP_UNKNOWN = 0,
-			WP_EXTERIOR = 1,
-			WP_INTERIOR = 1 << 1,
+			WP_UNKNOWN = 0,			//!< initial type - shouldn't be used
+			WP_EXTERIOR = 1,		//!< when the node is 'outdoors'
+			WP_INTERIOR = 1 << 1,	//!< when the node is inside (a building)
 		};
-		//! defines a weighted edge
+		//! defines a weighted edge with a distance weigth
 		typedef std::pair<Ogre::Real, const WayPointNode*> WayPointWeightEdge;
 		//! defines a list of weighted 'edges' connecting to other nodes
 		typedef std::list<WayPointWeightEdge> WayPointWeightNodeList;
@@ -71,9 +71,11 @@
 		WayPointNodeType getType() const;
 
 	protected:
-		/** calculates the real cost to the neighbour.
+		/** calculates the distance to the neighbour in 3D world space.
 		 * Is used internally when adding a node and calculates the euclidean
-		 * distance. Terrain types etc. are ignored here.
+		 * distance. 
+		 * At the moment terrain types etc. are ignored here.
+		 * But this would be the place 
 		 * @param neighbour WayPointNode to calculate the movement cost to.
 		 */
 		Ogre::Real calcCost(WayPointNode* neighbour);

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 16:01:45 UTC (rev 3128)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 17:43:52 UTC (rev 3129)
@@ -21,6 +21,7 @@
 #include "World.h"
 #include "Exception.h"
 #include "LineSetPrimitive.h"
+#include "ConfigurationManager.h"
 
 using namespace std;
 
@@ -86,10 +87,16 @@
 
 void WayPointGraph::load (const Ogre::String& filename)
 {
-	//if (! boost::filesystem::exists(boost::filesystem::path(filename)) )
-	//	Throw(FileNotFoundException, filename);
+	// fetch modules directory
+	Ogre::String modulespath( 
+		ConfigurationManager::getSingleton().getModulesRootDirectory());
+	Ogre::String fullfilename(modulespath + "/" + filename);
+	
+	// check if the file exists
+	if (! boost::filesystem::exists(boost::filesystem::path(fullfilename)) )
+		Throw(FileNotFoundException, fullfilename);
 
-	std::ifstream input(filename.c_str(), ios::binary);
+	std::ifstream input(fullfilename.c_str(), ios::binary);
 	
 	if (input.fail())
 		Throw(Error, filename+": couldn't open");
@@ -168,8 +175,13 @@
 	unsigned int count;
 	WayPointNodeList::const_iterator it;
 	std::map<const WayPointNode*, unsigned int> IndexList;
-	std::ofstream output(filename.c_str(), std::ios::binary);
+	
+	// fetch modules directory
+	Ogre::String modulespath( 
+		ConfigurationManager::getSingleton().getModulesRootDirectory());
+	Ogre::String fullfilename(modulespath + "/" + filename);
 
+	std::ofstream output(fullfilename.c_str(), std::ios::binary);
 	// opening file for write failed
 	if (output.fail())
 		Throw (Error,filename + "couldn't open for writing");



From natoka at mail.berlios.de  Tue Mar  6 18:46:05 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 18:46:05 +0100
Subject: [Dsa-hl-svn] r3130 - modules/aitest/scripts
Message-ID: <200703061746.l26Hk5QL001077@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 18:45:42 +0100 (Tue, 06 Mar 2007)
New Revision: 3130

Modified:
   modules/aitest/scripts/WayPointTest.rb
   modules/aitest/scripts/WayPointTest2.rb
Log:
*) fixed path statements in WayPoint files

Modified: modules/aitest/scripts/WayPointTest.rb
===================================================================
--- modules/aitest/scripts/WayPointTest.rb	2007-03-06 17:43:52 UTC (rev 3129)
+++ modules/aitest/scripts/WayPointTest.rb	2007-03-06 17:45:42 UTC (rev 3130)
@@ -71,10 +71,10 @@
 
     end
     def save()
-	@WPGraph.save("modules/aitest/maps/graphtest.wpg")
+	@WPGraph.save("aitest/maps/graphtest.wpg")
     end
     def load()
-	@WPGraph.load("modules/aitest/maps/graphtest.wpg")
+	@WPGraph.load("aitest/maps/graphtest.wpg")
     end
 #def clear()
 #	@WPGraph.

Modified: modules/aitest/scripts/WayPointTest2.rb
===================================================================
--- modules/aitest/scripts/WayPointTest2.rb	2007-03-06 17:43:52 UTC (rev 3129)
+++ modules/aitest/scripts/WayPointTest2.rb	2007-03-06 17:45:42 UTC (rev 3130)
@@ -5,10 +5,10 @@
 	@WPGraph = $WPGM.createWayPointGraph();
     end
     def save()
-	@WPGraph.save("modules/aitest/maps/graphtest.wpg")
+	@WPGraph.save("aitest/maps/graphtest.wpg")
     end
     def load()
-	@WPGraph.load("modules/aitest/maps/graphtest.wpg")
+	@WPGraph.load("aitest/maps/graphtest.wpg")
     end
 end
 



From natoka at mail.berlios.de  Tue Mar  6 18:52:55 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 18:52:55 +0100
Subject: [Dsa-hl-svn] r3131 - rl/trunk/engine/core/src
Message-ID: <200703061752.l26HqtRx009367@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 18:52:48 +0100 (Tue, 06 Mar 2007)
New Revision: 3131

Modified:
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
removed Memory leak reported by ogre

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-06 17:45:42 UTC (rev 3130)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-06 17:52:48 UTC (rev 3131)
@@ -96,6 +96,7 @@
     {
         delete mGenericCallback;
         delete mCharCharPair;
+		delete mCharDefaultPair;
         delete mCharLevelPair;
         delete mCharacterID;
         delete mLevelID;



From tanis at mail.berlios.de  Tue Mar  6 19:03:25 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 6 Mar 2007 19:03:25 +0100
Subject: [Dsa-hl-svn] r3132 - rl/trunk/engine/ui/src
Message-ID: <200703061803.l26I3PGq024328@sheep.berlios.de>

Author: tanis
Date: 2007-03-06 19:03:15 +0100 (Tue, 06 Mar 2007)
New Revision: 3132

Modified:
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
mGameSettings was not initialised.

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-06 17:52:48 UTC (rev 3131)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-06 18:03:15 UTC (rev 3132)
@@ -88,6 +88,7 @@
 		mInfoPopup = new InfoPopup();
 		mObjectDescriptionWindow = new ObjectDescriptionWindow();
         mCloseConfirmationWindow = NULL;
+        mGameSettings = NULL;
 
 		RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
 		RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);



From natoka at mail.berlios.de  Tue Mar  6 22:07:23 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 22:07:23 +0100
Subject: [Dsa-hl-svn] r3133 - in rl/trunk: . engine/ai engine/ai/include
	engine/ai/src engine/script/swig
Message-ID: <200703062107.l26L7NSV004861@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 22:07:05 +0100 (Tue, 06 Mar 2007)
New Revision: 3133

Added:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/include/AStarNodePool.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarCosts.cpp
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/AStarNodePool.cpp
   rl/trunk/engine/ai/src/AStarWayPointNode.cpp
Modified:
   rl/trunk/Rastullah2005.sln
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
Log:
adding AStar algorithm to rlai
fixed the slow down bug of WayPointGraph by introducing a flag that prevents recreation of the lines when nothing has changed.



Modified: rl/trunk/Rastullah2005.sln
===================================================================
--- rl/trunk/Rastullah2005.sln	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/Rastullah2005.sln	2007-03-06 21:07:05 UTC (rev 3133)
@@ -9,70 +9,71 @@
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlDialog", "engine\dialog\RlDialog2005.vcproj", "{6361481B-A6D5-4BC2-826C-C26A49C631A8}"
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlRules", "engine\rules\RlRules2005.vcproj", "{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}"
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlScript", "engine\script\RlScript2005.vcproj", "{9A41EAE4-302A-4823-8F20-FA1AD58189A1}"
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlStartup", "engine\startup\RlStartup2005.vcproj", "{B78AEF70-E618-4E9D-BD67-E17995ECF714}"
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{9A41EAE4-302A-4823-8F20-FA1AD58189A1} = {9A41EAE4-302A-4823-8F20-FA1AD58189A1}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{9A41EAE4-302A-4823-8F20-FA1AD58189A1} = {9A41EAE4-302A-4823-8F20-FA1AD58189A1}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlUI", "engine\ui\RlUI2005.vcproj", "{53FE20F3-E726-44FE-BBEC-D29CAE210D25}"
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlUIComponents", "engine\uicomponents\RlUIComponents2005.vcproj", "{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlAI", "engine\ai\RlAI2005.vcproj", "{C3E78B89-587B-499A-BE7D-4FE8564F0CD7}"
 	ProjectSection(ProjectDependencies) = postProject
+		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlFmod4Driver", "plugins\fmod4driver\RlFmod4Driver.vcproj", "{A2DD1E40-4D80-44C5-B04E-1B1C4B07131C}"
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RlOpenALDriver", "plugins\openaldriver\RlOpenALDriver.vcproj", "{173A345C-D7B1-46F9-974F-53661D7C8AF6}"
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Global

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-06 21:07:05 UTC (rev 3133)
@@ -305,6 +305,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\AStar.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\AStarCosts.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\AStarHeuristic.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\AStarNodePool.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\AStarWayPointNode.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\PhysicalObstacle.cpp"
 				>
 			</File>
@@ -355,6 +375,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\AStar.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AStarCosts.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AStarHeuristic.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AStarNodePool.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\AStarWayPointNode.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\FuzzyState.h"
 				>
 			</File>

Added: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AStar_H__
+#define __RlAI_AStar_H__
+
+#include "AiPrerequisites.h"
+#include "AStarWayPointNode.h"
+#include "DebugVisualisable.h"
+#include "OgreVector3.h"
+
+namespace rl
+{
+
+	class WayPointGraph;
+	class AStarCosts;
+
+	/* Just some short notes to the ideas of amit:
+	 * we're using heaps here for the open/close sets
+	 * once we get beyond 800 waypoints, we can have a look at HOT buckets ...
+	 */
+
+	/** A class to get some statistical output about the AStar search.
+	 */
+	class AStarStatistics
+	{
+	public:
+	};
+
+	/** Stores a waypointgraph and is capable of loading and saving it.
+	 */
+	class _RlAiExport AStar 
+		: public DebugVisualisable	
+	{
+	public:
+		//! defines the type of the open/closed sets
+		typedef std::vector< AStarWayPointNode* > AStarSet;
+		//! defines the resultpath as a list of points in world space
+		typedef std::vector< Ogre::Vector3 > AStarPath;
+
+		/** The constructor of AStar
+		 * AStar needs several things to find a path: 
+		 * a heuristic to calculate the cost for the still not travelled part of the path.
+		 * some sort of map to travel in.
+		 * A start and and end point.
+		 * @param Costs encapsulates cost and heuristic for distance calculations.
+		 * @param WPGraph contains the map of WayPoints to examine for a path.
+		 * @param StartPos is the start point in world space.
+		 * @param StartPos is the end point in world space.
+		 */
+		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
+		/** explicit virtual destructor
+		 */
+		~AStar();
+
+		/** starts the search.
+		 */
+		void search(AStarPath& resultPath);
+
+		/** starts the search for the given start and end positions
+		 * @param StartPos gives the startpoint for the search
+		 * @param EndPos gives the endposition for the search
+		 */
+		void searchFromTo(AStarPath& resultPath, const Ogre::Vector3& StartPos,
+			const Ogre::Vector3& EndPos );
+
+		/* retrieve a list of WayPoints (=the solution)
+		 * This generates a path from the solution created by search
+		 */
+		//const AStarPath& getResultPointList() const;
+
+		/** Resets the AStar to do an other search.
+		 * Before searching can be done again all temporary data has to be
+		 * deallocated.
+		 */
+		void reset();
+
+		// Overrides from DebugVisualisable
+		/** Provides the flag of the kind of visualisation done in the class.
+		 * \see DebugVisualisable::DebugVisualisableFlag for further information
+		 */
+		virtual DebugVisualisableFlag getFlag() const;
+		/** Called to update the debug primitive. Redrawing is done in here.
+		 */
+        virtual void updatePrimitive();
+
+	protected:
+		// Overrides from DebugVisualisable
+		/** actualy creates the debug primitive.
+		 * \see DebugVisualisable for further information
+		 */
+        virtual void doCreatePrimitive();
+
+		// End of Overrides from DebugVisualisable
+
+		/** sets up everyting needed for the search.
+		 */
+		void initialise();
+
+		/** search for a AStarWayPointNode in the specified set
+		 * @param Set to search through
+		 * @param Node to search for
+		 */
+		AStarSet::iterator AStar::searchSet(AStarSet& Set, AStarWayPointNode* Node);
+
+		// static data
+		//! heuristic function
+		const AStarCosts* mCosts;
+		//! map (which is a waypoint graph)
+		const WayPointGraph* mWPGraph;
+		//! start position
+		Ogre::Vector3 mStartPos;
+		//! end position (to reach)
+		Ogre::Vector3 mEndPos;
+		//! the nearest waypoint to the start position
+		AStarWayPointNode* mANStart;
+		//! the nearest waypoint ot the end position
+		AStarWayPointNode* mANEnd;
+
+		typedef std::greater<AStarWayPointNode* > AStarNodeComp;
+
+		// dynamic data (changed while searching)
+		//! contains the OPEN set
+		AStarSet mOpen;
+		//! contains the CLOSED set
+		AStarSet mClosed;
+
+	};
+	
+}; // namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,96 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AStarCosts_H__
+#define __RlAI_AStarCosts_H__
+
+#include "AiPrerequisites.h"
+#include "AStarHeuristic.h"
+
+namespace rl {
+
+	class WayPointGraph;
+	class AStarWayPointNode;
+
+	/** Abstract cost class definining an interface for AStar to access.
+	 * Contains the heuristic to calculate the distance cost to the goal and
+	 * the calculation of the real costs from one node to an other.
+	 */
+	class _RlAiExport AStarCosts
+	{
+	public:
+		/** default constructor
+		 * @param Heuristic to use for calculating heuritic values
+		 */
+		AStarCosts(const AStarHeuristic* Heuristic);
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarCosts();
+
+		/** calculates the (remaining) distance between wp1 and wp2.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the heuristic distance calculation
+		 */
+		virtual float calcHeuristic(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const;
+
+		/** calculates the real cost between wp1 and wp2.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the real cost calculation
+		 */
+		virtual float calcCost(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const = 0;
+
+	protected:
+		const AStarHeuristic* mHeuristic;
+	};
+	
+	/* An implementation of the abstract interface of AStarCosts.
+	 * currently utilises euklidean distance as a method for calculating
+	 * the real costs.
+	 * Of course there is a lot of tuning that can be done here.
+	 */
+	class _RlAiExport AStarCostsDefault
+		: public AStarCosts
+	{
+		/** default constructor
+		 * @param Heuristic to use for calculating heuritic values
+		 */
+		AStarCostsDefault(const AStarHeuristic* Heuristic);
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarCostsDefault();
+		/** calculates the real cost between wp1 and wp2.
+		 * The calculation in place is planely reporting the euclidean
+		 * distance.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the real cost calculation
+		 */
+		virtual float calcCost(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const;
+
+	protected:
+		EuclideanDistance mEuclid;
+	};
+
+};  //namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,122 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AStarHeuristic_H__
+#define __RlAI_AStarHeuristic_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl {
+
+	
+
+	/** Abstract heuristic class definining an interface for AStar to access.
+	 * Contains the heuristic to calculate the distance cost to the goal
+	 */
+	class _RlAiExport AStarHeuristic
+	{
+	public:
+		/** default constructor
+		 */
+		AStarHeuristic();
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarHeuristic();
+
+		/** calculates the (remaining) distance between wp1 and wp2.
+		 * @param vec1 start position in world space
+		 * @param vec2 goal position in world space
+		 * @returns a float giving the result of the heuristic distance calculation
+		 */
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const = 0;
+	};
+
+	// a set of sample heuristics that can be used
+
+	//! Manhatten distance heuristic
+	class _RlAiExport ManhattenDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		ManhattenDistance();
+		//! explicit virtual destructor
+		virtual ~ManhattenDistance();
+
+		/** calculates the Manhatten distance of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the Manhatten distance of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
+	};
+
+	//! diagonal distance heuristic
+	class _RlAiExport DiagonalDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		DiagonalDistance();
+		//! explicit virtual destructor
+		virtual ~DiagonalDistance();
+
+		/** calculates the of diagonal distance the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the diagonal distance of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
+	};
+
+	//! euclidean distance heuristic
+	class _RlAiExport EuclideanDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		EuclideanDistance();
+		//! explicit virtual destructor
+		virtual ~EuclideanDistance();
+
+		/** calculates the of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
+	};
+
+	//! euclidian distance square heuristic
+	class _RlAiExport EuclideanDistanceSquared
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		EuclideanDistanceSquared();
+		//! explicit virtual destructor
+		virtual ~EuclideanDistanceSquared();
+
+		/** calculates the of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
+	};
+
+}; // namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarNodePool.h
===================================================================
--- rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,89 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AStarNodeManager_H__
+#define __RlAI_AStarNodeManager_H__
+
+#include "AiPrerequisites.h"
+#include "AStarWayPointNode.h"
+
+namespace rl {
+
+	/** A class for the memory management of Nodes for the A Star.
+	 * Internally it keeps a list of nodes and just remembers which
+	 * are used externally and which are not. So alloc/dealloc doesn't
+	 * happen that often when throwing away nodes.
+	 */
+	class _RlAiExport AStarNodePool
+	{
+		//! typedefinition for a list of AStar nodes
+		typedef std::vector<AStarWayPointNode *> AStarNodeList;
+
+		/** default constructor
+		 */
+		AStarNodePool();
+		/** explicit destructor
+		 */
+		~AStarNodePool();
+
+		/** fetches a AStarWayPointNode for use
+		 * @param WP WayPointNode to save in the AStarWayPointNode
+		 */
+		AStarWayPointNode* createAStarWayPointNode( const WayPointNode* WP );
+
+		/** releases a AStarWayPointNode from use
+		 * @param Node the node to release
+		 */
+		void release( AStarWayPointNode* Node );
+
+		/** releases all AStarWayPointNodes from use
+		 */
+		void releaseAll();
+
+		/** removes a single AStarWayPointNode (delete)
+		 */
+		void remove( AStarWayPointNode* Node );
+
+		/** removes all AStarWayPointNodes (delete)
+		 */
+		void removeAll( );
+
+		/** retrieves the AStarWayPointNode at the specified Index.
+		 * Retrieval is conducted on the list of nodes in use. (mUsed)
+		 * @param Index to retrieve AStarWayPointNode at.
+		 */
+		AStarWayPointNode* getAt(unsigned int Index);
+
+		/** retrieves the number of AStarWayPointNodes available for retrieval.
+		 * Is necessary to avoid throwing of an error
+		 * @returns unsigned int giving the number of elements stored in mUsed.
+		 */
+		unsigned int getSize();
+
+	protected:
+		/** helper function to remove all contents of a AStarNodeList
+		 */
+		void removeListContents(AStarNodeList& List);
+
+		//! list of nodes in use
+		AStarNodeList mUsed;
+		//! list of nodes not yet in use
+		AStarNodeList mFree;
+
+	};
+
+};
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,135 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __RlAI_AStarWayPointNode_H__
+#define __RlAI_AStarWayPointNode_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+	
+	class WayPointNode;
+
+	/** This class used as a node for creating the a* search graph.
+	 * It is tightly linked with the real map representation of waypoints which
+	 * is done with WayPointNode - hence its name is AStarWayPointNode to express
+	 * that tight link.
+	 */
+	class _RlAiExport AStarWayPointNode
+	{
+	public:
+
+		/** Constructor for an AStar Node
+		 * AStarWayPointNode is not derived from WayPointNode, because doubling
+		 * information that present at some other place is not necessary and 
+		 * just makes it difficult to the if it's accurate at the moment.
+		 * Therefore only a pointer to the waypoint, this Astar node is linked
+		 * to, is stored.
+		 * @param WP is a WayPointNode object storing, position and neigbours.
+		 */
+		AStarWayPointNode(const WayPointNode* WP);
+
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarWayPointNode();
+
+		/** 2 nodes are compared by comparing their f value.
+		 * The f value of a node is the sum of g and h value. (really needed?)
+		 */
+		inline bool operator < ( const AStarWayPointNode& wp2 ) //, const AStarWayPointNode& wp2 )
+		{
+			return (mG+mH) < (wp2.mG+wp2.mH);
+		    //return (wp1->mG+wp1->mH) < (wp2->mG+wp2->mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?)
+		 */
+		inline bool operator == ( const AStarWayPointNode& wp2 ) //, const AStarWayPointNode* wp2 )
+		{
+			return (mWP == wp2.mWP) && (mG == wp2.mG) && (mH == wp2.mH);
+			//return (wp1->mWP == wp2->mWP) && (wp1->mG == wp2->mG) && (wp1->mH == wp2->mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?)
+		 */
+		inline bool operator == (const AStarWayPointNode* wp2 )
+		{
+			return (mWP == wp2->mWP) && (mG == wp2->mG) && (mH == wp2->mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?) 
+		 */
+		static inline bool Equal ( const AStarWayPointNode* wp1 , const AStarWayPointNode* wp2 )
+		{
+			
+			return (wp1->mWP == wp2->mWP) && (wp1->mG == wp2->mG) && (wp1->mH == wp2->mH);
+		}
+
+		/** 2 nodes compared by comparing their f value.
+		 * The f value of a node is the sum of g and h value.
+		 * This function is used when sorting a stl::vector.
+		 */
+		static bool SortMethod(const AStarWayPointNode* wp1, const AStarWayPointNode* wp2)
+		{
+			return (wp1->mG+wp1->mH) < (wp2->mG+wp2->mH);
+		}
+
+		/** fetches the G value (cost til now)
+		 * @returns the cost value up to this waypoint
+		 */
+		inline float getG() const {return mG;}
+		/** fetches the H value (cost heuristic from now to goal)
+		 * @returns the cost value from this waypoint to the goal
+		 */
+		inline float getH() const {return mH;}
+		/** fetches the Parent of this node
+		 * @returns the parent of this node in the search path
+		 */
+		inline AStarWayPointNode* getParent() const {return mParent;}
+		/** returns the attached Waypoint node
+		 * Is necessary to generate the connection to the graph of nodepoints
+		 */
+		inline const WayPointNode* getWP() const {return mWP;}
+
+		/** fetches the G value (cost til now)
+		 * @returns the cost value up to this waypoint
+		 */
+		inline void setG(float G) {mG=G;}
+		/** fetches the H value (cost heuristic from now to goal)
+		 * @returns the cost value from this waypoint to the goal
+		 */
+		inline void setH(float H) {mH=H;}
+		/** fetches the Parent of this node
+		 * @returns the parent of this node in the search path
+		 */
+		inline void setParent(AStarWayPointNode* Parent) {mParent=Parent;}
+
+	protected:
+		//! the positional WayPoint
+		const WayPointNode* mWP;
+		//! the real costs up to this node
+		float mG;
+		//! the estimated costs to the goal
+		float mH;
+		//! the parent of this node in the search
+		AStarWayPointNode* mParent;
+	};
+
+
+
+}; // namespace
+
+#endif

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -150,6 +150,9 @@
 
 		//! to ease handling of the WayPointTree we also store a list of nodes
 		WayPointNodeList mNodeList;
+
+		//! remembers changes
+		bool mChanged;
 	};
 
 };

Added: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,243 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "AStar.h"
+#include "AStarWayPointNode.h"
+#include "AStarHeuristic.h"
+#include "AStarCosts.h"
+#include "AStarNodePool.h"
+#include "WayPointGraph.h"
+#include "WayPointNode.h"
+#include "CoreSubsystem.h"
+#include "World.h"
+#include "LineSetPrimitive.h"
+#include <algorithm>
+
+using namespace std;
+
+namespace rl {
+
+AStar::AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos )
+	: mCosts(Costs),
+	mWPGraph(WPGraph),
+	mStartPos(StartPos),
+	mEndPos(EndPos),
+	mANStart(NULL),
+	mANEnd(NULL)
+{
+}
+
+AStar::~AStar()
+{
+	reset();
+}
+
+void AStar::reset()
+{
+	//mAStarNodePool.clearall();
+	mANStart = NULL;
+	mANEnd = NULL;
+
+	AStarSet::iterator it;
+	for (it = mOpen.begin(); it != mOpen.end(); it++)
+	{
+		delete (*it);
+	}
+	for (it = mClosed.begin(); it != mClosed.end(); it++)
+	{
+		delete (*it);
+	}
+}
+
+void AStar::initialise()
+{
+	// drop everything already allocated
+	// perhaps it's wise to first have a look where we're going to head ?
+	// and decide it then depending on the destionation ?
+	reset();
+
+	// first find 'real' start and end positions by searching for the corresponding waypoints
+	mANStart = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mStartPos) );
+	mANEnd = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mEndPos) );
+}
+
+void AStar::searchFromTo(AStarPath& resultPath, const Ogre::Vector3& StartPos,
+						 const Ogre::Vector3& EndPos )
+{
+	mStartPos = StartPos;
+	mEndPos = EndPos;
+	search(resultPath);
+}
+
+/*
+The A* algorithm, stripped of all the code, is fairly simple. 
+There are two sets, OPEN and CLOSED. The OPEN set contains those nodes that are candidates for examining.
+Initially, the OPEN set contains just one element: the starting position.
+The CLOSED set contains those nodes that have already been examined.
+Initially, the CLOSED set is empty. Graphically, the OPEN set is the "frontier"
+and the CLOSED set is the "interior" of the visited areas. Each node also keeps
+a pointer to its parent node so that we can determine how it was found.
+
+There is a main loop that repeatedly pulls out the best node n in OPEN
+(the node with the lowest f value) and examines it. If n is the goal, then we're done.
+Otherwise, node n is removed from OPEN and added to CLOSED. 
+Then, its neighbors n' are examined. A neighbor that is in CLOSED has already
+been seen, so we don't need to look at it (*). A neighbor that is in OPEN is
+scheduled to be looked at, so we don't need to look at it now (*). Otherwise,
+we add it to OPEN, with its parent set to n. The path cost to n', g(n'), will
+be set to g(n) + movementcost(n, n').
+
+(*) I'm skipping a small detail here. You do need to check to see if the
+node's g value can be lowered, and if so, you re-open it.
+*/
+
+void AStar::search(AStarPath& resultPath)
+{
+	initialise();
+	mOpen.push_back(mANStart);
+	mANStart->setH(mCosts->calcHeuristic(mWPGraph,mANStart,mANEnd));
+
+	AStarWayPointNode* Node;
+
+	// While there are still unvisited nodes
+    while( !mOpen.empty() )
+	{
+		Node = mOpen.front();
+		pop_heap(mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod);
+		mOpen.pop_back();
+		mClosed.push_back(Node);
+
+		// check if goal reached
+		if ( (*Node) == (*mANEnd) ) {
+			// create result
+			for (; Node->getParent(); Node = Node->getParent())
+			{
+				resultPath.push_back(Node->getWP()->getPosition());
+			}
+			// terminate search
+			break;
+		}
+
+		// now look through the neighbours
+		WayPointNode::WayPointWeightNodeList WPList = Node->getWP()->getNeighbours();
+		WayPointNode::WayPointWeightNodeList::iterator it;
+
+		for (it = WPList.begin(); it != WPList.end(); it++)
+		{
+			AStarWayPointNode* ASubNode = new AStarWayPointNode((*it).second);
+			float cost = mCosts->calcCost(mWPGraph,mANStart,mANEnd);
+
+			ASubNode->setG( Node->getG() + cost );
+			ASubNode->setH( mCosts->calcHeuristic(mWPGraph,ASubNode,mANEnd) );
+
+			AStarSet::iterator ASit;
+			// now check if the node is already in Open
+			
+			if ( (ASit = searchSet(mOpen, ASubNode)) != mOpen.end() ) 
+			{
+				AStarWayPointNode* ASfound = (*ASit);
+				// check if current g is better
+				if (ASfound->getG() > ASubNode->getG()) {
+					ASfound->setG(ASubNode->getG());
+					ASfound->setH(ASubNode->getH());
+					ASfound->setParent(Node);
+					// dark magic ... for resorting the heap from the top
+					// down to the changed element
+					push_heap( mOpen.begin(), ASit+1, AStarWayPointNode::SortMethod );
+				}
+				// anyway the newly created node isn't needed
+				delete ASubNode;
+			
+			}  // now check if the node is already in Closed
+			else if ( (ASit = searchSet(mClosed, ASubNode)) != mClosed.end()) 
+			{
+				AStarWayPointNode* ASfound = (*ASit);
+				// (check if current g is better, then reopen)
+				if (ASfound->getG() > ASubNode->getG()) {
+					ASfound->setG(ASubNode->getG());
+					ASfound->setH(ASubNode->getH());
+					ASfound->setParent(Node);
+					// remove the node from the closed list
+					mClosed.erase(ASit);
+
+					// dark magic ... for resorting the heap from the top
+					// down to the changed element
+					push_heap( mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod );
+				}
+				// anyway the newly created node isn't needed
+				delete ASubNode;
+			} 
+			else 
+			{
+				// neither in Open nor Closed, so add it to Open
+				mOpen.push_back( ASubNode );
+                push_heap( mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod );
+				ASubNode->setParent(Node);
+			}
+		}
+	}
+
+}
+
+AStar::AStarSet::iterator AStar::searchSet(AStarSet& Set, AStarWayPointNode* Node)
+{
+	AStarSet::iterator it;
+
+	it = find(Set.begin(), Set.end(), Node);
+	AStarWayPointNode* help = (*it);
+	for (it = Set.begin(); it != Set.end(); it++) 
+	{
+		if ( (*it) == Node )
+			return it;
+	}
+
+	return it;
+}
+
+/*		
+const AStarSet& AStar::getWayPointList()
+{
+	// search must be finished ? or just invoke it here then ?
+}
+*/
+
+DebugVisualisableFlag AStar::getFlag() const
+{
+	return DVF_WAYPOINT;
+}
+
+void AStar::updatePrimitive()
+{
+	if (mSceneNode->getParent() == NULL)
+    {
+		//mActor = ActorManager::createEmptyActor("__Astar_Debugger__");
+		CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->
+			getRootSceneNode()->addChild(mSceneNode);
+    }
+
+	LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+
+	lineSet->clear();
+
+	//lineSet->addLine(wp1Vec, (*nit).second->getPosition(), Ogre::ColourValue::Blue);
+}
+
+void AStar::doCreatePrimitive()
+{
+	mPrimitive = new LineSetPrimitive();
+}
+
+};
\ No newline at end of file

Added: rl/trunk/engine/ai/src/AStarCosts.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,53 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "AStarCosts.h"
+#include "AStarWayPointNode.h"
+#include "WayPointNode.h"
+
+namespace rl {
+
+AStarCosts::AStarCosts(const AStarHeuristic* Heuristic)
+: mHeuristic(Heuristic)
+{
+}
+
+AStarCosts::~AStarCosts()
+{
+}
+
+float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const
+{
+	return mHeuristic->calcDistance(wp1->getWP()->getPosition(), wp2->getWP()->getPosition());
+}
+
+AStarCostsDefault::AStarCostsDefault(const AStarHeuristic* Heuristic)
+: AStarCosts(Heuristic)
+{
+}
+
+AStarCostsDefault::~AStarCostsDefault()
+{
+}
+
+float AStarCostsDefault::calcCost(const WayPointGraph* WPGraph,
+										  const AStarWayPointNode* wp1,
+										  const AStarWayPointNode* wp2) const
+{
+	return mEuclid.calcDistance(wp1->getWP()->getPosition(), wp2->getWP()->getPosition());
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,71 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "AStarHeuristic.h"
+#include "AStarWayPointNode.h"
+#include "WayPointNode.h"
+
+namespace rl {
+
+AStarHeuristic::AStarHeuristic()
+{
+}
+
+AStarHeuristic::~AStarHeuristic()
+{
+}
+
+ManhattenDistance::ManhattenDistance()
+{
+}
+ManhattenDistance::~ManhattenDistance()
+{
+}
+float ManhattenDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
+{
+	return (abs(vec1.x - vec2.x) + abs(vec1.y - vec2.y) + abs(vec1.z - vec2.z));
+}
+DiagonalDistance::DiagonalDistance()
+{
+}
+DiagonalDistance::~DiagonalDistance()
+{
+}
+float DiagonalDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
+{
+	return std::max( std::max( abs(vec1.x - vec2.x), abs(vec1.y - vec2.y) ), abs(vec1.z - vec2.z) );
+}
+EuclideanDistance::EuclideanDistance()
+{
+}
+EuclideanDistance::~EuclideanDistance()
+{
+}
+float EuclideanDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
+{
+	return vec1.distance( vec2);
+}
+EuclideanDistanceSquared::EuclideanDistanceSquared()
+{
+}
+EuclideanDistanceSquared::~EuclideanDistanceSquared()
+{
+}
+float EuclideanDistanceSquared::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
+{
+	return vec1.squaredDistance( vec2);
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarNodePool.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,110 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "AStarNodePool.h"
+#include "AStarWayPointNode.h"
+
+namespace rl {
+
+AStarNodePool::AStarNodePool()
+{
+}
+
+AStarNodePool::~AStarNodePool()
+{
+	removeAll();
+}
+
+void AStarNodePool::removeAll()
+{
+	removeListContents(mUsed);
+	removeListContents(mFree);
+}
+
+void AStarNodePool::releaseAll()
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		mFree.push_back( (*it) );
+	}
+	mUsed.clear();
+}
+
+void AStarNodePool::release(AStarWayPointNode* Node)
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		if ( (*it) == Node ) 
+		{
+			mUsed.erase(it);
+			mFree.push_back(Node);
+		}
+	}
+}
+
+void AStarNodePool::remove( AStarWayPointNode* Node )
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		if ( (*it) == Node ) 
+		{
+			mUsed.erase(it);
+			delete Node;
+		}
+	}
+}
+
+AStarWayPointNode* AStarNodePool::createAStarWayPointNode(const WayPointNode* WP)
+{
+	AStarWayPointNode* Node;
+	
+	if ( mFree.empty())
+		Node = new AStarWayPointNode(WP);
+	else
+	{
+		Node = mFree.back();
+		mFree.pop_back();
+	}
+
+	mUsed.push_back(Node);
+
+	return Node;
+}
+
+void AStarNodePool::removeListContents(AStarNodeList& List)
+{
+	AStarNodeList::iterator it;
+	for (it = List.begin(); it != List.end(); it++)
+	{
+		delete (*it);
+	}
+	List.clear();
+}
+
+AStarWayPointNode* AStarNodePool::getAt(unsigned int Index)
+{
+	return mUsed[Index];
+}
+
+
+unsigned int AStarNodePool::getSize()
+{
+	return mUsed.size();
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarWayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,29 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "AStarWayPointNode.h"
+
+namespace rl {
+
+AStarWayPointNode::AStarWayPointNode(const WayPointNode* WP)
+: mWP(WP), mG(-1), mH(-1), mParent(NULL)
+{
+}
+
+AStarWayPointNode::~AStarWayPointNode()
+{
+}
+
+};

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -28,7 +28,8 @@
 namespace rl {
 
 WayPointGraph::WayPointGraph()
-: mRoot(NULL)
+: mRoot(NULL),
+  mChanged(false)
 {
 }
 
@@ -70,6 +71,7 @@
 {
 	WayPointNode* newWayPoint = new WayPointNode(position, type);
 	mNodeList.push_back(newWayPoint);
+	mChanged = true;
 
 	return newWayPoint;
 }
@@ -78,11 +80,13 @@
 {
 	wp1->addNeighbour(wp2);
 	wp2->addNeighbour(wp1);
+	mChanged = true;
 }
 
 void WayPointGraph::addDirectedConnection(WayPointNode* wp1, const WayPointNode* wp2)
 {
 	wp1->addNeighbour(wp2);
+	mChanged = true;
 }
 
 void WayPointGraph::load (const Ogre::String& filename)
@@ -168,6 +172,7 @@
 		Throw(Error, filename+": couldn't read expeced number of connections");
 
 	input.close();
+	mChanged = true;
 }
 
 void WayPointGraph::save (const Ogre::String& filename) const
@@ -298,6 +303,10 @@
 		//mCharacterActor->_getSceneNode()->addChild(mSceneNode);
     }
 
+	// avoid building graph again and again
+	if (! mChanged)
+		return;
+
 	LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
 
 	lineSet->clear();
@@ -336,6 +345,8 @@
 		}
 	}
 	edgeList.clear();
+
+	mChanged = false;
 }
 
 void WayPointGraph::doCreatePrimitive()

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-06 21:07:05 UTC (rev 3133)
@@ -23,6 +23,9 @@
 #include "AiSubsystem.h"
 #include "AgentManager.h"
 #include "Agent.h"
+#include "AStar.h"
+#include "AStarHeuristic.h"
+#include "AStarCosts.h"
 #include "PhysicalObstacle.h"
 #include "WayPointNode.h"
 #include "WayPointGraph.h"

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 21:07:05 UTC (rev 3133)
@@ -16,6 +16,10 @@
 
 namespace rl 
 {
+	// Before first use of GameObject or subclasses!
+	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
+	%apply SWIGTYPE *DYNAMIC { rl::AStarCosts * };
+
 	class SteeringVehicle
 	{
 	public:
@@ -114,6 +118,69 @@
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
 	
+	class AStarHeuristic
+	{
+		AStarHeuristic();
+		virtual ~AStarHeuristic();
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const = 0;
+	};
+	
+	class ManhattenDistance
+		: public AStarHeuristic
+	{
+	public:
+		ManhattenDistance();
+		virtual ~ManhattenDistance();
+	};
+
+	class DiagonalDistance
+		: public AStarHeuristic
+	{
+	public:
+		DiagonalDistance();
+		virtual ~DiagonalDistance();
+	};
+
+	class EuclideanDistance
+		: public AStarHeuristic
+	{
+	public:
+		EuclideanDistance();
+		virtual ~EuclideanDistance();
+	};
+
+	class EuclideanDistanceSquared
+		: public AStarHeuristic
+	{
+	public:
+		EuclideanDistanceSquared();
+		virtual ~EuclideanDistanceSquared();
+	}; 
+	
+	class AStarCosts
+	{
+		AStarCosts(const AStarHeuristic* Heuristic);	
+		virtual ~AStarCosts();
+	};
+	
+	class AStarCostsDefault
+	{
+		AStarCostsDefault(const AStarHeuristic* Heuristic);	
+		~AStarCostsDefault();
+	};
+	
+	class AStar
+	{
+		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
+		virtual ~AStar();
+		
+		void search(std::vector<Ogre::Vector3>& resultPath);
+		void searchFromTo(std::vector<Ogre::Vector3>& resultPath,
+			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
+		void reset();
+	};
+	
     class PhysicalObstacle {
         
         public:
@@ -161,4 +228,57 @@
 	
 } // Namespace
 
+%{
+static swig_type_info *AStarHeuristic_dynamic_cast(void **ptr)
+{
+    rl::AStarHeuristic **ppAStarHeuristic = reinterpret_cast<rl::AStarHeuristic**>(ptr);
 
+    rl::ManhattenDistance *pManhattenDistance=dynamic_cast<rl::ManhattenDistance*>(*ppAStarHeuristic);
+    if( pManhattenDistance )
+    {
+        *ptr=reinterpret_cast<void*>(pManhattenDistance);
+        return SWIGTYPE_p_rl__ManhattenDistance;
+    }
+    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast<rl::DiagonalDistance*>(*ppAStarHeuristic);
+    if( pDiagonalDistance )
+    {
+        *ptr=reinterpret_cast<void*>(pDiagonalDistance);
+        return SWIGTYPE_p_rl__DiagonalDistance;
+    }
+    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast<rl::EuclideanDistance*>(*ppAStarHeuristic);
+    if( pEuclideanDistance )
+    {
+        *ptr=reinterpret_cast<void*>(pEuclideanDistance);
+        return SWIGTYPE_p_rl__EuclideanDistance;
+    }
+    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast<rl::EuclideanDistanceSquared*>(*ppAStarHeuristic);
+    if( pEuclideanDistanceSquared )
+    {
+        *ptr=reinterpret_cast<void*>(pEuclideanDistanceSquared);
+        return SWIGTYPE_p_rl__EuclideanDistanceSquared;
+    }
+   
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarHeuristic, AStarHeuristic_dynamic_cast);
+
+
+%{
+static swig_type_info *AStarCosts_dynamic_cast(void **ptr)
+{
+    rl::AStarCosts **ppAStarCosts = reinterpret_cast<rl::AStarCosts**>(ptr);
+
+    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast<rl::AStarCostsDefault*>(*ppAStarCosts);
+    if( pAStarCostsDefault )
+    {
+        *ptr=reinterpret_cast<void*>(pAStarCostsDefault);
+        return SWIGTYPE_p_rl__AStarCostsDefault;
+    }
+   
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarCosts, AStarCosts_dynamic_cast);
+
+



From natoka at mail.berlios.de  Tue Mar  6 22:57:38 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 22:57:38 +0100
Subject: [Dsa-hl-svn] r3134 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200703062157.l26LvciA013561@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 22:57:31 +0100 (Tue, 06 Mar 2007)
New Revision: 3134

Modified:
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
corrected Manhatten to Manhattan
added public: to several classes

Modified: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 21:07:05 UTC (rev 3133)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 21:57:31 UTC (rev 3134)
@@ -46,14 +46,14 @@
 	// a set of sample heuristics that can be used
 
 	//! Manhatten distance heuristic
-	class _RlAiExport ManhattenDistance
+	class _RlAiExport ManhattanDistance
 		: public AStarHeuristic
 	{
 	public:
 		//! default constructor
-		ManhattenDistance();
+		ManhattanDistance();
 		//! explicit virtual destructor
-		virtual ~ManhattenDistance();
+		virtual ~ManhattanDistance();
 
 		/** calculates the Manhatten distance of the given 2 points.
 		 * @param vec1 start point in world space

Modified: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 21:07:05 UTC (rev 3133)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 21:57:31 UTC (rev 3134)
@@ -27,13 +27,13 @@
 {
 }
 
-ManhattenDistance::ManhattenDistance()
+ManhattanDistance::ManhattanDistance()
 {
 }
-ManhattenDistance::~ManhattenDistance()
+ManhattanDistance::~ManhattanDistance()
 {
 }
-float ManhattenDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
+float ManhattanDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
 {
 	return (abs(vec1.x - vec2.x) + abs(vec1.y - vec2.y) + abs(vec1.z - vec2.z));
 }

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 21:07:05 UTC (rev 3133)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 21:57:31 UTC (rev 3134)
@@ -46,7 +46,7 @@
 
 	// Remove debug scene node from root scene note, if debugview was used.
     if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-	{
+    {
 		CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->
 			getRootSceneNode()->removeChild(mSceneNode);
     }

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 21:07:05 UTC (rev 3133)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 21:57:31 UTC (rev 3134)
@@ -120,17 +120,18 @@
 	
 	class AStarHeuristic
 	{
+	public:
 		AStarHeuristic();
 		virtual ~AStarHeuristic();
 		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const = 0;
 	};
 	
-	class ManhattenDistance
+	class ManhattanDistance
 		: public AStarHeuristic
 	{
 	public:
-		ManhattenDistance();
-		virtual ~ManhattenDistance();
+		ManhattanDistance();
+		virtual ~ManhattanDistance();
 	};
 
 	class DiagonalDistance
@@ -159,18 +160,21 @@
 	
 	class AStarCosts
 	{
+	public:
 		AStarCosts(const AStarHeuristic* Heuristic);	
 		virtual ~AStarCosts();
 	};
 	
 	class AStarCostsDefault
 	{
+	public:
 		AStarCostsDefault(const AStarHeuristic* Heuristic);	
 		~AStarCostsDefault();
 	};
 	
 	class AStar
 	{
+	public:
 		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
 			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
 		virtual ~AStar();
@@ -233,11 +237,11 @@
 {
     rl::AStarHeuristic **ppAStarHeuristic = reinterpret_cast<rl::AStarHeuristic**>(ptr);
 
-    rl::ManhattenDistance *pManhattenDistance=dynamic_cast<rl::ManhattenDistance*>(*ppAStarHeuristic);
-    if( pManhattenDistance )
+    rl::ManhattanDistance *pManhattanDistance=dynamic_cast<rl::ManhattanDistance*>(*ppAStarHeuristic);
+    if( pManhattanDistance )
     {
-        *ptr=reinterpret_cast<void*>(pManhattenDistance);
-        return SWIGTYPE_p_rl__ManhattenDistance;
+        *ptr=reinterpret_cast<void*>(pManhattanDistance);
+        return SWIGTYPE_p_rl__ManhattanDistance;
     }
     rl::DiagonalDistance *pDiagonalDistance=dynamic_cast<rl::DiagonalDistance*>(*ppAStarHeuristic);
     if( pDiagonalDistance )



From natoka at mail.berlios.de  Tue Mar  6 23:20:21 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 6 Mar 2007 23:20:21 +0100
Subject: [Dsa-hl-svn] r3135 - in rl/trunk/engine: ai/include script/swig
Message-ID: <200703062220.l26MKL9E015878@sheep.berlios.de>

Author: natoka
Date: 2007-03-06 23:20:18 +0100 (Tue, 06 Mar 2007)
New Revision: 3135

Modified:
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/script/swig/RlAi.swig
Log:
compiler errors corrected
swig export corrected so that abstract functions are defined for access

Modified: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 22:20:18 UTC (rev 3135)
@@ -69,6 +69,7 @@
 	class _RlAiExport AStarCostsDefault
 		: public AStarCosts
 	{
+    public:
 		/** default constructor
 		 * @param Heuristic to use for calculating heuritic values
 		 */

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 22:20:18 UTC (rev 3135)
@@ -127,55 +127,63 @@
 	};
 	
 	class ManhattanDistance
-		: public AStarHeuristic
+		: public rl::AStarHeuristic
 	{
 	public:
 		ManhattanDistance();
 		virtual ~ManhattanDistance();
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
 	};
 
 	class DiagonalDistance
-		: public AStarHeuristic
+		: public rl::AStarHeuristic
 	{
 	public:
 		DiagonalDistance();
 		virtual ~DiagonalDistance();
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
 	};
 
 	class EuclideanDistance
-		: public AStarHeuristic
+		: public rl::AStarHeuristic
 	{
 	public:
 		EuclideanDistance();
 		virtual ~EuclideanDistance();
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
 	};
 
 	class EuclideanDistanceSquared
-		: public AStarHeuristic
+		: public rl::AStarHeuristic
 	{
 	public:
 		EuclideanDistanceSquared();
 		virtual ~EuclideanDistanceSquared();
+		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
 	}; 
 	
 	class AStarCosts
 	{
 	public:
-		AStarCosts(const AStarHeuristic* Heuristic);	
+		AStarCosts(const rl::AStarHeuristic* Heuristic);	
 		virtual ~AStarCosts();
+		virtual float calcHeuristic(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
+			const rl::AStarWayPointNode* wp2) const = 0;
 	};
 	
 	class AStarCostsDefault
 	{
 	public:
-		AStarCostsDefault(const AStarHeuristic* Heuristic);	
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic);	
 		~AStarCostsDefault();
+		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
+			const rl::AStarWayPointNode* wp2) const;
 	};
 	
 	class AStar
 	{
 	public:
-		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+		AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
 			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
 		virtual ~AStar();
 		



From josch at mail.berlios.de  Wed Mar  7 00:46:55 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Wed, 7 Mar 2007 00:46:55 +0100
Subject: [Dsa-hl-svn] r3136 - in rl/trunk: engine/core/include
	engine/core/include/nulldriver engine/core/src
	plugins/fmod4driver/include
Message-ID: <200703062346.l26NkttN023325@sheep.berlios.de>

Author: josch
Date: 2007-03-07 00:46:43 +0100 (Wed, 07 Mar 2007)
New Revision: 3136

Modified:
   rl/trunk/engine/core/include/SoundDriver.h
   rl/trunk/engine/core/include/nulldriver/NullDriver.h
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
Log:
Fixed bug that occurred at application shutdown.

Modified: rl/trunk/engine/core/include/SoundDriver.h
===================================================================
--- rl/trunk/engine/core/include/SoundDriver.h	2007-03-06 22:20:18 UTC (rev 3135)
+++ rl/trunk/engine/core/include/SoundDriver.h	2007-03-06 23:46:43 UTC (rev 3136)
@@ -83,6 +83,12 @@
         const Ogre::Real getMasterVolume() const;
 
         /**
+         * If this driver is a Ogre plugin, it returns TRUE.
+         * @return bool TRUE if Ogre plugin, FALSE otherwise.
+         */
+        virtual bool isDriverPlugin() = 0;
+
+        /**
          * Returns the current sound driver settings as a key-value list
          *
          * @return key-value list of sound options

Modified: rl/trunk/engine/core/include/nulldriver/NullDriver.h
===================================================================
--- rl/trunk/engine/core/include/nulldriver/NullDriver.h	2007-03-06 22:20:18 UTC (rev 3135)
+++ rl/trunk/engine/core/include/nulldriver/NullDriver.h	2007-03-06 23:46:43 UTC (rev 3136)
@@ -44,6 +44,8 @@
     virtual Ogre::String getName() const;
     /// Update-Aufgaben erledigen
     virtual void update();
+    /// Ist kein Ogre plugin
+    virtual bool isDriverPlugin() { return false; }
     /// Einen Soundlistener erzeugen
     virtual ListenerMovable *createListener(const Ogre::String &name);
     /// Set volume attenuation factor f in 1/(f*distance)

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-03-06 22:20:18 UTC (rev 3135)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-03-06 23:46:43 UTC (rev 3136)
@@ -72,7 +72,7 @@
       mListenerActor(NULL),
       mActiveListener(NULL)
     {
-        LOG_MESSAGE(Logger::CORE, "Erzeuge Soundmanager...");
+        LOG_MESSAGE(Logger::MULTIMEDIA, "Erzeuge Soundmanager...");
         NullDriver* nullDriver = new NullDriver(this);
         registerDriver(nullDriver);
         setActiveDriver(nullDriver);
@@ -136,14 +136,14 @@
 
     if (mActiveDriver == driver)
     {
-        LOG_DEBUG(Logger::CORE,
+        LOG_DEBUG(Logger::MULTIMEDIA,
             "No need to change Sound Driver, "
             + mActiveDriver->getName()
             + " is already active.");
         return;
     }
 
-    LOG_MESSAGE(Logger::CORE,
+    LOG_MESSAGE(Logger::MULTIMEDIA,
         "Changing Sound Driver to "
          + driver->getName());
 
@@ -160,7 +160,7 @@
     else
     {
         LOG_ERROR(
-            Logger::CORE,
+            Logger::MULTIMEDIA,
             "Sound driver "
             + driver->getName()
             + " had an error while initializing, keeping old driver.");
@@ -274,14 +274,14 @@
         }
         catch(Ogre::Exception &e)
         {
-            LOG_MESSAGE(Logger::CORE,
+            LOG_MESSAGE(Logger::MULTIMEDIA,
                 CeGuiString("Soundtreiber kann nicht geladen werden: ")
                     + drivername + "\n"
                     + e.getFullDescription());
         }
         catch(...)
         {
-            LOG_MESSAGE(Logger::CORE,
+            LOG_MESSAGE(Logger::MULTIMEDIA,
                  CeGuiString("Soundtreiber kann nicht geladen werden: ")
                     + drivername);
         }
@@ -300,20 +300,11 @@
 
 void SoundManager::unloadAllDrivers()
 {
-       if (mActiveDriver != NULL)
-    {
-        mActiveDriver->shutdown();
-        mActiveDriver = NULL;
-    }
-
     /**
      * @ToDo: This is a hack to avoid the problem with the Null driver.
      *        Don't know yet, why this happens.
      */
-    DriverList::iterator it = mDriverList.begin();
-    if (!mDriverList.empty()) ++it;
-    /** Hack End **/
-    for(/*DriverList::iterator it = mDriverList.begin()*/; it != mDriverList.end(); it++)
+    for(DriverList::iterator it = mDriverList.begin(); it != mDriverList.end(); it++)
     {
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
         Ogre::String driverPlugin = (*it)->getName();
@@ -321,13 +312,23 @@
         Ogre::String driverPlugin = "lib" + (*it)->getName();
 #       endif
 
-        LOG_MESSAGE(Logger::CORE,
+        LOG_MESSAGE(Logger::MULTIMEDIA,
             "Unloading sound driver DLL "
             + driverPlugin);
 
-        Ogre::Root::getSingleton().unloadPlugin(driverPlugin);
+        bool isDriverPlugin = (*it)->isDriverPlugin();
+        if (mActiveDriver != NULL && mActiveDriver == *it)
+        {
+            mActiveDriver->shutdown();
+            delete mActiveDriver;
+            mActiveDriver = NULL;
+        }
+        if (isDriverPlugin)
+        {
+            Ogre::Root::getSingleton().unloadPlugin(driverPlugin);
+        }
 
-        LOG_MESSAGE(Logger::CORE,
+        LOG_MESSAGE(Logger::MULTIMEDIA,
             "Sound driver DLL "
             + driverPlugin
             + " successfully unloaded.");

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-06 22:20:18 UTC (rev 3135)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-06 23:46:43 UTC (rev 3136)
@@ -67,6 +67,8 @@
         virtual void shutdown();
         /// Der Name des Treibers
         virtual Ogre::String getName() const;
+        /// Ist ein Ogre plugin
+        virtual bool isDriverPlugin() { return true; }
         /// Update-Aufgaben erledigen
         virtual void update();
         /// Einen Soundlistener erzeugen



From natoka at mail.berlios.de  Wed Mar  7 13:18:52 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 13:18:52 +0100
Subject: [Dsa-hl-svn] r3137 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200703071218.l27CIq9b010834@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 13:18:40 +0100 (Wed, 07 Mar 2007)
New Revision: 3137

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/include/AStarNodePool.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/ai/src/WayPointGraphManager.cpp
   rl/trunk/engine/ai/src/WayPointNode.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
fixed ruby std::vector export of AStar
started to debug and fix AStar (not finished)
fixed newline issues for gcc

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -142,4 +142,4 @@
 	
 }; // namespace
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -94,4 +94,4 @@
 
 };  //namespace
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -119,4 +119,4 @@
 
 }; // namespace
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/AStarNodePool.h
===================================================================
--- rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -86,4 +86,4 @@
 
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -54,22 +54,18 @@
 			return (mG+mH) < (wp2.mG+wp2.mH);
 		    //return (wp1->mG+wp1->mH) < (wp2->mG+wp2->mH);
 		}
-		/** 2 nodes compared for equilibrium by comparing their values.
-		 * (really needed?)
+		
+        /** 2 nodes compared for equilibrium by comparing their values.
+		 * This is needed, because operator overloading for pointer types
+         * does not work.
+         * @param wp pointer to an AStarWayPointNode
 		 */
-		inline bool operator == ( const AStarWayPointNode& wp2 ) //, const AStarWayPointNode* wp2 )
+		inline bool Equal ( const AStarWayPointNode* wp )
 		{
-			return (mWP == wp2.mWP) && (mG == wp2.mG) && (mH == wp2.mH);
-			//return (wp1->mWP == wp2->mWP) && (wp1->mG == wp2->mG) && (wp1->mH == wp2->mH);
+			return (mWP == wp->mWP) && (mG == wp->mG) && (mH == wp->mH);
 		}
+
 		/** 2 nodes compared for equilibrium by comparing their values.
-		 * (really needed?)
-		 */
-		inline bool operator == (const AStarWayPointNode* wp2 )
-		{
-			return (mWP == wp2->mWP) && (mG == wp2->mG) && (mH == wp2->mH);
-		}
-		/** 2 nodes compared for equilibrium by comparing their values.
 		 * (really needed?) 
 		 */
 		static inline bool Equal ( const AStarWayPointNode* wp1 , const AStarWayPointNode* wp2 )
@@ -81,9 +77,22 @@
 		/** 2 nodes compared by comparing their f value.
 		 * The f value of a node is the sum of g and h value.
 		 * This function is used when sorting a stl::vector.
+         * It can be fine tune extended so that binary_search
+         * will work, by addind functionality so that when wp1->F == wp2->F
+         * a finer sort mechanism kicks in.
+         * sorting for G is not enough then.
+         * a sort for H is not needed then, because H depends on G and
+         * will just be reverse proportional to G. Therefore we just need
+         * to sort either for G or H .
 		 */
 		static bool SortMethod(const AStarWayPointNode* wp1, const AStarWayPointNode* wp2)
 		{
+            //float wp1F = wp1->mG+wp1->mH;
+            //float wp2F = wp2->mG+wp2->mH;
+            //if (wp1F == wp2F)
+            //    return wp1->mG < wp2->mG;
+
+            //return wp1F < wp2F;
 			return (wp1->mG+wp1->mH) < (wp2->mG+wp2->mH);
 		}
 
@@ -128,8 +137,6 @@
 		AStarWayPointNode* mParent;
 	};
 
-
-
 }; // namespace
 
 #endif

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -157,4 +157,4 @@
 
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -69,4 +69,4 @@
 	};
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-03-07 12:18:40 UTC (rev 3137)
@@ -90,4 +90,4 @@
 
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 12:18:40 UTC (rev 3137)
@@ -109,6 +109,7 @@
 	initialise();
 	mOpen.push_back(mANStart);
 	mANStart->setH(mCosts->calcHeuristic(mWPGraph,mANStart,mANEnd));
+    mANStart->setG(0);
 
 	AStarWayPointNode* Node;
 
@@ -121,7 +122,7 @@
 		mClosed.push_back(Node);
 
 		// check if goal reached
-		if ( (*Node) == (*mANEnd) ) {
+        if ( Node->Equal(mANEnd) ) {
 			// create result
 			for (; Node->getParent(); Node = Node->getParent())
 			{
@@ -138,7 +139,7 @@
 		for (it = WPList.begin(); it != WPList.end(); it++)
 		{
 			AStarWayPointNode* ASubNode = new AStarWayPointNode((*it).second);
-			float cost = mCosts->calcCost(mWPGraph,mANStart,mANEnd);
+			float cost = mCosts->calcCost(mWPGraph,ASubNode,Node);
 
 			ASubNode->setG( Node->getG() + cost );
 			ASubNode->setH( mCosts->calcHeuristic(mWPGraph,ASubNode,mANEnd) );
@@ -196,11 +197,24 @@
 {
 	AStarSet::iterator it;
 
-	it = find(Set.begin(), Set.end(), Node);
-	AStarWayPointNode* help = (*it);
+    /* try binary search - but keep in mind this compares the F and not G&H values 
+     * so this is not going to work at the moment with the current sortMethod ...
+     */
+    
+    AStarWayPointNode* help = NULL;
+    bool found = std::binary_search(Set.begin(), Set.end(), Node, AStarWayPointNode::SortMethod);
+    //while (it != Set.end())
+    //{
+    //    if ( (*it)->Equal(Node) ) // if equal, then Node was 'found'
+    //        break;
+        // otherwise continue binary search
+        //it = std::binary_search(it, Set.end(), Node, AStarWayPointNode::SortMethod);
+    //}
+    
+    
 	for (it = Set.begin(); it != Set.end(); it++) 
 	{
-		if ( (*it) == Node )
+        if ( (*it)->Equal(Node) )
 			return it;
 	}
 
@@ -240,4 +254,4 @@
 	mPrimitive = new LineSetPrimitive();
 }
 
-};
\ No newline at end of file
+};

Modified: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-07 12:18:40 UTC (rev 3137)
@@ -55,7 +55,7 @@
 }
 float EuclideanDistance::calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const
 {
-	return vec1.distance( vec2);
+    return vec1.distance( vec2);
 }
 EuclideanDistanceSquared::EuclideanDistanceSquared()
 {

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-07 12:18:40 UTC (rev 3137)
@@ -354,4 +354,4 @@
 	mPrimitive = new LineSetPrimitive();
 }
 
-};
\ No newline at end of file
+};

Modified: rl/trunk/engine/ai/src/WayPointGraphManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-03-07 12:18:40 UTC (rev 3137)
@@ -58,4 +58,4 @@
 	mGraphs.clear();
 }
 
-};
\ No newline at end of file
+};

Modified: rl/trunk/engine/ai/src/WayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointNode.cpp	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/ai/src/WayPointNode.cpp	2007-03-07 12:18:40 UTC (rev 3137)
@@ -65,4 +65,4 @@
 	return mType;
 }
 
-};
\ No newline at end of file
+};

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 23:46:43 UTC (rev 3136)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-07 12:18:40 UTC (rev 3137)
@@ -14,6 +14,12 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+%include std_vector.i
+
+namespace std {
+	%template(Ogrevec3Vector) vector<Ogre::Vector3 >;
+};
+
 namespace rl 
 {
 	// Before first use of GameObject or subclasses!
@@ -167,11 +173,11 @@
 	public:
 		AStarCosts(const rl::AStarHeuristic* Heuristic);	
 		virtual ~AStarCosts();
-		virtual float calcHeuristic(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
+		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const = 0;
 	};
 	
-	class AStarCostsDefault
+	class AStarCostsDefault : public AStarCosts
 	{
 	public:
 		AStarCostsDefault(const rl::AStarHeuristic* Heuristic);	



From chrber at mail.berlios.de  Wed Mar  7 14:42:13 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Wed, 7 Mar 2007 14:42:13 +0100
Subject: [Dsa-hl-svn] r3138 - in rl/trunk/engine/ai: include src
Message-ID: <200703071342.l27DgDML016738@sheep.berlios.de>

Author: chrber
Date: 2007-03-07 14:42:09 +0100 (Wed, 07 Mar 2007)
New Revision: 3138

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/Makefile.am
Log:
Fixed class name in front of function error
Added missing source files to Makefiles


Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-07 12:18:40 UTC (rev 3137)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-07 13:42:09 UTC (rev 3138)
@@ -114,7 +114,7 @@
 		 * @param Set to search through
 		 * @param Node to search for
 		 */
-		AStarSet::iterator AStar::searchSet(AStarSet& Set, AStarWayPointNode* Node);
+		AStarSet::iterator searchSet(AStarSet& Set, AStarWayPointNode* Node);
 
 		// static data
 		//! heuristic function

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-03-07 12:18:40 UTC (rev 3137)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-03-07 13:42:09 UTC (rev 3138)
@@ -3,6 +3,11 @@
 	AgentManager.h \
 	AiPrerequisites.h \
 	AiSubsystem.h \
+	AStarCosts.h \
+	AStar.h \
+	AStarHeuristic.h \
+	AStarNodePool.h \
+	AStarWayPointNode.h \
 	FuzzyState.h \
 	FuzzyStateMachine.h \
 	PhysicalObstacle.h \

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-03-07 12:18:40 UTC (rev 3137)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-03-07 13:42:09 UTC (rev 3138)
@@ -8,6 +8,11 @@
 	AgentManager.cpp \
 	AiSubsystem.cpp \
 	AiWorld.cpp \
+	AStarCosts.cpp \
+	AStar.cpp \
+	AStarHeuristic.cpp \
+	AStarNodePool.cpp \
+	AStarWayPointNode.cpp \
 	FuzzyState.cpp \
 	FuzzyStateMachine.cpp \
 	PhysicalObstacle.cpp \



From blakharaz at mail.berlios.de  Wed Mar  7 15:09:32 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 7 Mar 2007 15:09:32 +0100
Subject: [Dsa-hl-svn] r3139 - in tools/mesh_combiner: . include m4 src
Message-ID: <200703071409.l27E9WdL018618@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-07 15:09:24 +0100 (Wed, 07 Mar 2007)
New Revision: 3139

Added:
   tools/mesh_combiner/Makefile.am
   tools/mesh_combiner/Makefile.in
   tools/mesh_combiner/bootstrap
   tools/mesh_combiner/configure.in
   tools/mesh_combiner/include/Makefile.am
   tools/mesh_combiner/include/Makefile.in
   tools/mesh_combiner/m4/
   tools/mesh_combiner/m4/boost.m4
   tools/mesh_combiner/m4/cppunit.m4
   tools/mesh_combiner/m4/swig.m4
   tools/mesh_combiner/src/Makefile.am
   tools/mesh_combiner/src/Makefile.in
Log:
A nice copy&paste(&adapt) automake build


Added: tools/mesh_combiner/Makefile.am
===================================================================
--- tools/mesh_combiner/Makefile.am	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/Makefile.am	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,2 @@
+SUBDIRS =   src include
+


Property changes on: tools/mesh_combiner/Makefile.am
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/Makefile.in
===================================================================
--- tools/mesh_combiner/Makefile.in	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/Makefile.in	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,602 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = .
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+DIST_COMMON = $(am__configure_deps) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(top_srcdir)/configure config.guess \
+	config.sub depcomp install-sh ltmain.sh missing
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno configure.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/include/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d $(distdir) \
+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr $(distdir); }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+OGRE_CFLAGS = @OGRE_CFLAGS@
+OGRE_LIBS = @OGRE_LIBS@
+OGRE_PLUGINDIR = @OGRE_PLUGINDIR@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+SUBDIRS = src include
+all: all-recursive
+
+.SUFFIXES:
+am--refresh:
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	mkdir $(distdir)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r $(distdir)
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && cd $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e '1{h;s/./=/g;p;x;}' -e '$${p;x;}'
+distuninstallcheck:
+	@cd $(distuninstallcheck_dir) \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \
+	check-am clean clean-generic clean-libtool clean-recursive \
+	ctags ctags-recursive dist dist-all dist-bzip2 dist-gzip \
+	dist-shar dist-tarZ dist-zip distcheck distclean \
+	distclean-generic distclean-libtool distclean-recursive \
+	distclean-tags distcleancheck distdir distuninstallcheck dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:


Property changes on: tools/mesh_combiner/Makefile.in
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/bootstrap
===================================================================
--- tools/mesh_combiner/bootstrap	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/bootstrap	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+# Check for proper versions of autotools
+# We require:
+#  - autoconf 2.50+
+#  - automake 1.6+
+#  - libtool 1.4+
+
+# Deal with some gentoo-specific issues
+export WANT_AUTOMAKE='1.7'
+export WANT_AUTOCONF_2_5=1
+
+## Using prereq in autoconf rather than here, mostly for the debian systems at
+## this point
+if test -z "`autoconf --version 2>&1|head -n 1|egrep '2.[5-6]'`"; then
+	echo "Autoconf 2.50 or above is required. Aborting build...";
+    exit 1;
+fi
+
+if test -z "`automake --version 2>&1|head -n 1|egrep '1.[6-9]'`"; then
+	echo "Automake 1.6 or above is required. Aborting build...";
+	exit 1;
+fi
+
+if test -z "`libtool --version 2>&1|head -n 1|egrep '1.[4-5]'`"; then
+	echo "Libtool 1.4 or above is required. Aborting build...";
+	exit 1;
+fi
+
+echo "Bootstrap..."
+
+# Fire up autotools
+libtoolize --force && aclocal -I m4 $ACLOCAL_FLAGS && autoheader && automake --include-deps --add-missing --foreign && autoconf 
+


Property changes on: tools/mesh_combiner/bootstrap
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/configure.in
===================================================================
--- tools/mesh_combiner/configure.in	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/configure.in	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,52 @@
+AC_PREREQ(2.50)
+
+AC_INIT(RLMeshCombiner, 0.3.0)
+AC_CANONICAL_TARGET
+AM_INIT_AUTOMAKE([1.6.1 foreign no-installinfo no-installman subdir-objects])
+AC_CONFIG_HEADER(include/config.h)
+#AC_CONFIG_MACRO_DIR([m4])
+
+##AC_CANONICAL_TARGET
+
+dnl Check for programs
+AC_LANG([C++])
+AC_PROG_CXX
+AC_PROG_INSTALL
+AM_PROG_LIBTOOL
+
+# ***** DEBUGGING
+AC_ARG_ENABLE(debug,AS_HELP_STRING([--enable-debug],[enable debugging @<:@default=no@:>@]))
+if test "$enable_debug" = "yes"; then
+    CXXFLAGS="$CXXFLAGS -g -O0"
+else
+    CXXFLAGS="$CXXFLAGS -O2"
+fi
+# ***** PROFILING
+AC_ARG_ENABLE([profiling], AS_HELP_STRING([--enable-profiling], [enable profiling @<:@default=no@:>@]))
+if test "$enable_profiling" = "yes"; then
+    CXXFLAGS="$CXXFLAGS -pg -g"
+    LDFLAGS="$LDFLAGS -pg -g"
+fi
+
+# Pthreads
+# Ogre
+PKG_CHECK_MODULES([OGRE], [OGRE >= 1.4.0])
+AC_ARG_WITH([ogre-plugins], [AS_HELP_STRING([--with-ogre-plugins=@<:@=DIR@:>@], [set location of Ogre plugins])] ,[OGRE_PLUGINDIR="$withval"], [OGRE_PLUGINDIR=`pkg-config OGRE --variable=plugindir`])
+AC_SUBST(OGRE_PLUGINDIR)
+
+# XERCES
+AC_CHECK_HEADERS(xercesc/util/XercesVersion.hpp, ,
+    [AC_MSG_ERROR([cannot find libxerces headers]) ])
+AC_CHECK_LIB(xerces-c,main,,
+    [AC_MSG_ERROR([cannot find the libxerces library]) ])
+
+
+dnl Create the makefiles
+AC_CONFIG_FILES([Makefile \
+	include/Makefile \
+        src/Makefile \
+    ])
+
+AC_OUTPUT
+
+


Property changes on: tools/mesh_combiner/configure.in
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/include/Makefile.am
===================================================================
--- tools/mesh_combiner/include/Makefile.am	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/include/Makefile.am	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,8 @@
+noinst_HEADERS =
+	config.h \
+	MergeMesh.h \
+	MergeSkeleton.h \
+	MeshCombiner.h
+	
+	
+	


Property changes on: tools/mesh_combiner/include/Makefile.am
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/include/Makefile.in
===================================================================
--- tools/mesh_combiner/include/Makefile.in	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/include/Makefile.in	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,349 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = include
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(srcdir)/config.h.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+HEADERS = $(noinst_HEADERS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+OGRE_CFLAGS = @OGRE_CFLAGS@
+OGRE_LIBS = @OGRE_LIBS@
+OGRE_PLUGINDIR = @OGRE_PLUGINDIR@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+noinst_HEADERS = 
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  include/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status include/config.h
+$(srcdir)/config.h.in:  $(am__configure_deps) 
+	cd $(top_srcdir) && $(AUTOHEADER)
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS) config.h
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-hdr \
+	distclean-libtool
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-hdr distclean-libtool \
+	distdir dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	uninstall uninstall-am uninstall-info-am
+
+	config.h \
+	MergeMesh.h \
+	MergeSkeleton.h \
+	MeshCombiner.h
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:


Property changes on: tools/mesh_combiner/include/Makefile.in
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/m4/boost.m4
===================================================================
--- tools/mesh_combiner/m4/boost.m4	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/m4/boost.m4	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,267 @@
+dnl @synopsis AX_BOOST([MINIMUM-VERSION])
+dnl
+dnl Test for the Boost C++ libraries of a particular version (or newer)
+dnl
+dnl If no path to the installed boost library is given the macro
+dnl searchs under /usr, /usr/local, and /opt, and evaluates the
+dnl $BOOST_ROOT environment variable. Further documentation is
+dnl available at <http://randspringer.de/boost/index.html>.
+dnl
+dnl This macro calls:
+dnl
+dnl   AC_SUBST(BOOST_CPPFLAGS) / AC_SUBST(BOOST_LDFLAGS)
+dnl
+dnl And sets:
+dnl
+dnl   HAVE_BOOST
+dnl
+dnl @category InstalledPackages
+dnl @category Cxx
+dnl @author Thomas Porschberg <thomas at randspringer.de>
+dnl @version 2006-06-15
+dnl @license AllPermissive
+
+AC_DEFUN([AX_BOOST_BASE],
+[
+AC_ARG_WITH([boost],
+	AS_HELP_STRING([--with-boost@<:@=DIR@:>@],         specify the root directory for boost),
+	[
+    if test "$withval" = "yes"; then
+        ac_boost_path=""
+    else
+        ac_boost_path="$withval"
+    fi
+    ],
+    [want_boost="yes"])
+
+boost_lib_version_req=ifelse([$1], ,1.20.0,$1)
+boost_lib_version_req_shorten=`expr $boost_lib_version_req : '\([[0-9]]*\.[[0-9]]*\)'`
+boost_lib_version_req_major=`expr $boost_lib_version_req : '\([[0-9]]*\)'`
+boost_lib_version_req_minor=`expr $boost_lib_version_req : '[[0-9]]*\.\([[0-9]]*\)'`
+boost_lib_version_req_sub_minor=`expr $boost_lib_version_req : '[[0-9]]*\.[[0-9]]*\.\([[0-9]]*\)'`
+if test "x$boost_lib_version_req_sub_minor" = "x" ; then
+    boost_lib_version_req_sub_minor="0"
+fi
+WANT_BOOST_VERSION=`expr $boost_lib_version_req_major \* 100000 \+  $boost_lib_version_req_minor \* 100 \+ $boost_lib_version_req_sub_minor`
+AC_MSG_CHECKING(for Boost >= $boost_lib_version_req)
+succeeded=no
+
+dnl first we check the system location for boost libraries
+dnl this location ist chosen if boost libraries are installed with the --layout=system option
+dnl or if you install boost with RPM
+if test "$ac_boost_path" != ""; then
+    BOOST_LDFLAGS="-L$ac_boost_path/lib"
+    BOOST_CPPFLAGS="-I$ac_boost_path/include"
+else
+    for ac_boost_path_tmp in /usr /usr/local /opt ; do
+        if test -d "$ac_boost_path_tmp/include/boost" && test -r "$ac_boost_path_tmp/include/boost"; then
+            BOOST_LDFLAGS="-L$ac_boost_path_tmp/lib"
+            BOOST_CPPFLAGS="-I$ac_boost_path_tmp/include"
+            break;
+        fi
+    done
+fi
+
+CPPFLAGS_SAVED="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+export CPPFLAGS
+
+LDFLAGS_SAVED="$LDFLAGS"
+LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
+export LDFLAGS
+
+AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+@%:@include <boost/version.hpp>
+]], [[
+#if BOOST_VERSION >= $WANT_BOOST_VERSION
+// Everything is okay
+#else
+  error Boost version is too old
+#endif
+]])],[
+AC_MSG_RESULT(yes)
+succeeded=yes
+found_system=yes
+],[
+])
+AC_LANG_POP([C++])
+
+dnl if we found no boost with system layout we search for boost libraries
+dnl built and installed without the --layout=system option or for a staged(not installed) version
+if test "x$succeeded" != "xyes"; then
+    _version=0
+    if test "$ac_boost_path" != ""; then
+        BOOST_LDFLAGS="-L$ac_boost_path/lib"
+        if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
+            for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
+                _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
+                V_CHECK=`expr $_version_tmp \> $_version`
+                if test "$V_CHECK" = "1" ; then
+                    _version=$_version_tmp
+                fi
+                VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
+                BOOST_CPPFLAGS="-I$ac_boost_path/include/boost-$VERSION_UNDERSCORE"
+            done
+        fi
+    else
+        for ac_boost_path in /usr /usr/local /opt ; do
+            if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
+                for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
+                    _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
+                    V_CHECK=`expr $_version_tmp \> $_version`
+                    if test "$V_CHECK" = "1" ; then
+                        _version=$_version_tmp
+                        best_path=$ac_boost_path
+                    fi
+                done
+            fi
+        done
+
+        VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
+        BOOST_CPPFLAGS="-I$best_path/include/boost-$VERSION_UNDERSCORE"
+        BOOST_LDFLAGS="-L$best_path/lib"
+
+        if test "x$BOOST_ROOT" != "x"; then
+            if test -d "$BOOST_ROOT" && test -r "$BOOST_ROOT" && test -d "$BOOST_ROOT/stage/lib" && test -r "$BOOST_ROOT/stage/lib"; then
+                version_dir=`expr //$BOOST_ROOT : '.*/\(.*\)'`
+                stage_version=`echo $version_dir | sed 's/boost_//' | sed 's/_/./g'`
+                stage_version_shorten=`expr $stage_version : '\([[0-9]]*\.[[0-9]]*\)'`
+                V_CHECK=`expr $stage_version_shorten \>\= $_version`
+                if test "$V_CHECK" = "1" ; then
+                    AC_MSG_NOTICE(We will use a staged boost library from $BOOST_ROOT)
+                    BOOST_CPPFLAGS="-I$BOOST_ROOT"
+                    BOOST_LDFLAGS="-L$BOOST_ROOT/stage/lib"
+                fi
+            fi
+        fi
+    fi
+
+    CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+    export CPPFLAGS
+    LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
+    export LDFLAGS
+
+    AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+    @%:@include <boost/version.hpp>
+   ]], [[
+   #if BOOST_VERSION >= $WANT_BOOST_VERSION
+   // Everything is okay
+   #else
+   #  error Boost version is too old
+   #endif
+   ]])],[
+   AC_MSG_RESULT(yes)
+   succeeded=yes
+   found_system=yes
+   ],[
+   ])
+   AC_LANG_POP([C++])
+fi
+
+if test "$succeeded" != "yes" ; then
+    if test "$_version" = "0" ; then
+        AC_MSG_ERROR([[We could not detect the boost libraries (version $boost_lib_version_req_shorten or higher). If you have a staged boost library (still not installed) please specify \$BOOST_ROOT in your environment and do not give a PATH to --with-boost option.  If you are sure you have boost installed, then check your version number looking in <boost/version.hpp>. See http://randspringer.de/boost for more documentation.]])
+    else
+        AC_MSG_NOTICE([Your boost libraries seems to old (version $_version).])
+    fi
+else
+    AC_SUBST(BOOST_CPPFLAGS)
+    AC_SUBST(BOOST_LDFLAGS)
+    AC_DEFINE(HAVE_BOOST,,[define if the Boost library is available])
+fi
+
+CPPFLAGS="$CPPFLAGS_SAVED"
+LDFLAGS="$LDFLAGS_SAVED"
+
+])
+
+dnl @synopsis AX_BOOST_FILESYSTEM
+dnl
+dnl Test for Filesystem library from the Boost C++ libraries. The macro
+dnl requires a preceding call to AX_BOOST_BASE. Further documentation
+dnl is available at <http://randspringer.de/boost/index.html>.
+dnl
+dnl This macro calls:
+dnl
+dnl   AC_SUBST(BOOST_FILESYSTEM_LIB)
+dnl
+dnl And sets:
+dnl
+dnl   HAVE_BOOST_FILESYSTEM
+dnl
+dnl @category InstalledPackages
+dnl @category Cxx
+dnl @author Thomas Porschberg <thomas at randspringer.de>
+dnl @author Michael Tindal <mtindal at paradoxpoint.com>
+dnl @version 2006-06-15
+dnl @license AllPermissive
+
+AC_DEFUN([AX_BOOST_FILESYSTEM],
+[
+	AC_ARG_WITH([boost-filesystem],
+	AS_HELP_STRING([--with-boost-filesystem@<:@=special-lib@:>@],
+                   [use the Filesystem library from boost - it is possible to specify a certain library for the linker
+                        e.g. --with-boost-filesystem=boost_filesystem-gcc-mt ]),
+        [
+        if test "$withval" = "yes"; then
+            want_boost="yes"
+            ax_boost_user_filesystem_lib=""
+        else
+		    want_boost="yes"
+        	ax_boost_user_filesystem_lib="$withval"
+		fi
+        ],
+        [want_boost="yes"]
+	)
+
+	if test "x$want_boost" = "xyes"; then
+        AC_REQUIRE([AC_PROG_CC])
+		CPPFLAGS_SAVED="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+		export CPPFLAGS
+
+		LDFLAGS_SAVED="$LDFLAGS"
+		LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
+		export LDFLAGS
+
+        AC_CACHE_CHECK(whether the Boost::Filesystem library is available,
+					   ax_cv_boost_filesystem,
+        [AC_LANG_PUSH([C++])
+         AC_COMPILE_IFELSE(AC_LANG_PROGRAM([[@%:@include <boost/filesystem/path.hpp>]],
+                                   [[using namespace boost::filesystem;
+                                   path my_path( "foo/bar/data.txt" );
+                                   return 0;]]),
+            				       ax_cv_boost_filesystem=yes, ax_cv_boost_filesystem=no)
+         AC_LANG_POP([C++])
+		])
+		if test "x$ax_cv_boost_filesystem" = "xyes"; then
+			AC_DEFINE(HAVE_BOOST_FILESYSTEM,,[define if the Boost::Filesystem library is available])
+			BN=boost_filesystem
+            if test "x$ax_boost_user_filesystem_lib" = "x"; then
+    			for ax_lib in $BN $BN-$CC $BN-$CC-mt $BN-$CC-mt-s $BN-$CC-s \
+                              lib$BN lib$BN-$CC lib$BN-$CC-mt lib$BN-$CC-mt-s lib$BN-$CC-s \
+                              $BN-mgw $BN-mgw $BN-mgw-mt $BN-mgw-mt-s $BN-mgw-s ; do
+				    AC_CHECK_LIB($ax_lib, main,
+                                 [BOOST_FILESYSTEM_LIB="-l$ax_lib" AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes" break],
+                                 [link_filesystem="no"])
+  				done
+            else
+               for ax_lib in $ax_boost_user_filesystem_lib $BN-$ax_boost_user_filesystem_lib; do
+				      AC_CHECK_LIB($ax_lib, main,
+                                   [BOOST_FILESYSTEM_LIB="-l$ax_lib" AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes" break],
+                                   [link_filesystem="no"])
+                  done
+
+            fi
+			if test "x$link_filesystem" = "xno"; then
+				AC_MSG_ERROR(Could not link against $ax_lib !)
+			fi
+		fi
+
+		CPPFLAGS="$CPPFLAGS_SAVED"
+    	LDFLAGS="$LDFLAGS_SAVED"
+	fi
+])
+


Property changes on: tools/mesh_combiner/m4/boost.m4
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/m4/cppunit.m4
===================================================================
--- tools/mesh_combiner/m4/cppunit.m4	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/m4/cppunit.m4	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,89 @@
+dnl
+dnl AM_PATH_CPPUNIT(MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]])
+dnl
+AC_DEFUN([AM_PATH_CPPUNIT],
+[
+
+AC_ARG_WITH(cppunit-prefix,[  --with-cppunit-prefix=PFX   Prefix where CppUnit is installed (optional)],
+            cppunit_config_prefix="$withval", cppunit_config_prefix="")
+AC_ARG_WITH(cppunit-exec-prefix,[  --with-cppunit-exec-prefix=PFX  Exec prefix where CppUnit is installed (optional)],
+            cppunit_config_exec_prefix="$withval", cppunit_config_exec_prefix="")
+
+  if test x$cppunit_config_exec_prefix != x ; then
+     cppunit_config_args="$cppunit_config_args --exec-prefix=$cppunit_config_exec_prefix"
+     if test x${CPPUNIT_CONFIG+set} != xset ; then
+        CPPUNIT_CONFIG=$cppunit_config_exec_prefix/bin/cppunit-config
+     fi
+  fi
+  if test x$cppunit_config_prefix != x ; then
+     cppunit_config_args="$cppunit_config_args --prefix=$cppunit_config_prefix"
+     if test x${CPPUNIT_CONFIG+set} != xset ; then
+        CPPUNIT_CONFIG=$cppunit_config_prefix/bin/cppunit-config
+     fi
+  fi
+
+  AC_PATH_PROG(CPPUNIT_CONFIG, cppunit-config, no)
+  cppunit_version_min=$1
+
+  AC_MSG_CHECKING(for Cppunit - version >= $cppunit_version_min)
+  no_cppunit=""
+  if test "$CPPUNIT_CONFIG" = "no" ; then
+    AC_MSG_RESULT(no)
+    no_cppunit=yes
+  else
+    CPPUNIT_CFLAGS=`$CPPUNIT_CONFIG --cflags`
+    CPPUNIT_LIBS=`$CPPUNIT_CONFIG --libs`
+    cppunit_version=`$CPPUNIT_CONFIG --version`
+
+    cppunit_major_version=`echo $cppunit_version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    cppunit_minor_version=`echo $cppunit_version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    cppunit_micro_version=`echo $cppunit_version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+
+    cppunit_major_min=`echo $cppunit_version_min | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    if test "x${cppunit_major_min}" = "x" ; then
+       cppunit_major_min=0
+    fi
+
+    cppunit_minor_min=`echo $cppunit_version_min | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    if test "x${cppunit_minor_min}" = "x" ; then
+       cppunit_minor_min=0
+    fi
+
+    cppunit_micro_min=`echo $cppunit_version_min | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x${cppunit_micro_min}" = "x" ; then
+       cppunit_micro_min=0
+    fi
+
+    cppunit_version_proper=`expr \
+        $cppunit_major_version \> $cppunit_major_min \| \
+        $cppunit_major_version \= $cppunit_major_min \& \
+        $cppunit_minor_version \> $cppunit_minor_min \| \
+        $cppunit_major_version \= $cppunit_major_min \& \
+        $cppunit_minor_version \= $cppunit_minor_min \& \
+        $cppunit_micro_version \>= $cppunit_micro_min `
+
+    if test "$cppunit_version_proper" = "1" ; then
+      AC_MSG_RESULT([$cppunit_major_version.$cppunit_minor_version.$cppunit_micro_version])
+    else
+      AC_MSG_RESULT(no)
+      no_cppunit=yes
+    fi
+  fi
+
+  if test "x$no_cppunit" = x ; then
+     ifelse([$2], , :, [$2])
+  else
+     CPPUNIT_CFLAGS=""
+     CPPUNIT_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+
+  AC_SUBST(CPPUNIT_CFLAGS)
+  AC_SUBST(CPPUNIT_LIBS)
+])


Property changes on: tools/mesh_combiner/m4/cppunit.m4
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/m4/swig.m4
===================================================================
--- tools/mesh_combiner/m4/swig.m4	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/m4/swig.m4	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,67 @@
+# Contributed by Sebastian Huber
+
+# SWIG_PROG([required-version = N[.N[.N]]])
+#
+# Checks for the SWIG program.  If found you can (and should) call
+# SWIG via $(SWIG).  You can use the optional first argument to check
+# if the version of the available SWIG is greater than or equal to the
+# value of the argument.  It should have the format: N[.N[.N]] (N is a
+# number between 0 and 999.  Only the first N is mandatory.)
+AC_DEFUN([SWIG_PROG],[
+	AC_PATH_PROG([SWIG],[swig-pantheon])
+	if test -z "$SWIG" ; then
+		AC_MSG_ERROR([cannot find 'swig-pantheon' program, you may download it from http://prdownload.berlios.de/dsa-hl/swig-1.3.29-pantheon.7z])
+		SWIG='echo "error: SWIG is not installed, you may download it from http://prdownload.berlios.de/dsa-hl/swig-1.3.29-pantheon.7z" ; false'
+	elif test -n "$1" ; then
+		AC_MSG_CHECKING([for SWIG version])
+		[swig_version=`$SWIG -version 2>&1 | grep 'SWIG Version' | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/g'`]
+		AC_MSG_RESULT([$swig_version])
+		if test -n "$swig_version" ; then
+			# Calculate the required version number
+			[swig_tmp=( `echo $1 | sed 's/[^0-9]\+/ /g'` )]
+			[swig_required_version=$(( 1000000 * ${swig_tmp[0]:-0} + 1000 * ${swig_tmp[1]:-0} + ${swig_tmp[2]:-0} ))]
+
+			# Calculate the available version number
+			[swig_tmp=( `echo $swig_version | sed 's/[^0-9]\+/ /g'` )]
+			[swig_tmp=$(( 1000000 * ${swig_tmp[0]:-0} + 1000 * ${swig_tmp[1]:-0} + ${swig_tmp[2]:-0} ))]
+
+			if test $swig_required_version -gt $swig_tmp ; then
+				AC_MSG_ERROR([SWIG version $1 is required, you have $swig_version])
+			fi
+		else
+			AC_MSG_WARN([cannot determine SWIG version])
+		fi
+		SWIG_RUNTIME_LIBS_DIR="${SWIG%/bin*}/lib"
+		AC_MSG_NOTICE([SWIG runtime library directory is '$SWIG_RUNTIME_LIBS_DIR'])
+	fi
+	AC_SUBST([SWIG_RUNTIME_LIBS_DIR])
+])
+
+# SWIG_ENABLE_CXX()
+#
+# Enable SWIG C++ support.  This effects all invocations of $(SWIG).
+AC_DEFUN([SWIG_ENABLE_CXX],[
+	AC_REQUIRE([SWIG_PROG])
+	AC_REQUIRE([AC_PROG_CXX])
+	SWIG="$SWIG -c++ -minherit -Wall -v"
+])
+
+# SWIG_MULTI_MODULE_SUPPORT()
+#
+# Enable support for multiple modules.  This effects all invocations
+# of $(SWIG).  You have to link all generated modules against the
+# appropriate SWIG runtime library.  If you want to build Python
+# modules for example, use the SWIG_PYTHON() macro and link the
+# modules against $(SWIG_PYTHON_LIBS).
+AC_DEFUN([SWIG_MULTI_MODULE_SUPPORT],[
+	AC_REQUIRE([SWIG_PROG])
+	SWIG="$SWIG -noruntime"
+])
+
+
+AC_DEFUN([SWIG_RUBY],[
+	AC_REQUIRE([SWIG_PROG])
+	AC_SUBST([SWIG_RUBY_OPT],[-ruby$swig_shadow])
+	AC_SUBST([SWIG_RUBY_LIBS],["$SWIG_RUNTIME_LIBS_DIR -lswigrb"])
+])
+


Property changes on: tools/mesh_combiner/m4/swig.m4
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/src/Makefile.am
===================================================================
--- tools/mesh_combiner/src/Makefile.am	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/src/Makefile.am	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,9 @@
+INCLUDES = $(OGRE_CFLAGS) -I../include
+
+bin_PROGRAMS=meshcombiner
+meshcombiner_LDFLAGS = $(OGRE_LIBS) $(LIBS)
+meshcombiner_SOURCES = \
+	MergeMesh.cpp \
+	MergeSkeleton.cpp \
+	MeshCombiner.cpp \
+	MeshCombinerMain.cpp


Property changes on: tools/mesh_combiner/src/Makefile.am
___________________________________________________________________
Name: svn:executable
   + *

Added: tools/mesh_combiner/src/Makefile.in
===================================================================
--- tools/mesh_combiner/src/Makefile.in	2007-03-07 13:42:09 UTC (rev 3138)
+++ tools/mesh_combiner/src/Makefile.in	2007-03-07 14:09:24 UTC (rev 3139)
@@ -0,0 +1,470 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+bin_PROGRAMS = meshcombiner$(EXEEXT)
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/include/config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(bindir)"
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(bin_PROGRAMS)
+am_meshcombiner_OBJECTS = MergeMesh.$(OBJEXT) MergeSkeleton.$(OBJEXT) \
+	MeshCombiner.$(OBJEXT) MeshCombinerMain.$(OBJEXT)
+meshcombiner_OBJECTS = $(am_meshcombiner_OBJECTS)
+meshcombiner_LDADD = $(LDADD)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --tag=CXX --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(meshcombiner_SOURCES)
+DIST_SOURCES = $(meshcombiner_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+OGRE_CFLAGS = @OGRE_CFLAGS@
+OGRE_LIBS = @OGRE_LIBS@
+OGRE_PLUGINDIR = @OGRE_PLUGINDIR@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+INCLUDES = $(OGRE_CFLAGS) -I../include
+meshcombiner_LDFLAGS = $(OGRE_LIBS) $(LIBS)
+meshcombiner_SOURCES = \
+	MergeMesh.cpp \
+	MergeSkeleton.cpp \
+	MeshCombiner.cpp \
+	MeshCombinerMain.cpp
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
+	done
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+meshcombiner$(EXEEXT): $(meshcombiner_OBJECTS) $(meshcombiner_DEPENDENCIES) 
+	@rm -f meshcombiner$(EXEEXT)
+	$(CXXLINK) $(meshcombiner_LDFLAGS) $(meshcombiner_OBJECTS) $(meshcombiner_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MergeMesh.Po at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MergeSkeleton.Po at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MeshCombiner.Po at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MeshCombinerMain.Po at am__quote@
+
+.cpp.o:
+ at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`; \
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ $<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Po"; else rm -f "$$depbase.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+ at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`; \
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+ at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Po"; else rm -f "$$depbase.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cpp.lo:
+ at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`; \
+ at am__fastdepCXX_TRUE@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ $<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Plo"; else rm -f "$$depbase.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS)
+installdirs:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic clean-libtool ctags distclean distclean-compile \
+	distclean-generic distclean-libtool distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-binPROGRAMS install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-binPROGRAMS uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:


Property changes on: tools/mesh_combiner/src/Makefile.in
___________________________________________________________________
Name: svn:executable
   + *



From blakharaz at mail.berlios.de  Wed Mar  7 15:11:20 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 7 Mar 2007 15:11:20 +0100
Subject: [Dsa-hl-svn] r3140 - rl/trunk/engine/script/swig
Message-ID: <200703071411.l27EBK1j018687@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-07 15:11:17 +0100 (Wed, 07 Mar 2007)
New Revision: 3140

Modified:
   rl/trunk/engine/script/swig/RlExports.i
Log:
Removed gcc warnings for using NULL as an int parameter


Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-07 14:09:24 UTC (rev 3139)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-07 14:11:17 UTC (rev 3140)
@@ -187,7 +187,7 @@
 		// Es gab das SkriptObjekt noch nicht
 		if (NIL_P(val))
 		{
-			$input = SWIG_NewPointerObj((void *) $1, $1_descriptor, NULL);		
+			$input = SWIG_NewPointerObj((void *) $1, $1_descriptor, 0);		
 		}
 		else	
 			$input = val;
@@ -201,7 +201,7 @@
 	
 	// Es gab das SkriptObjekt noch nicht
 	if (NIL_P(val)) {
-		$result = SWIG_NewPointerObj((void *) $1, $1_descriptor, NULL);			
+		$result = SWIG_NewPointerObj((void *) $1, $1_descriptor, 0);			
 	}
 	else	
 		$result = val;



From blakharaz at mail.berlios.de  Wed Mar  7 15:25:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 7 Mar 2007 15:25:46 +0100
Subject: [Dsa-hl-svn] r3141 - in tools/mesh_combiner: include src
Message-ID: <200703071425.l27EPkP1021191@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-07 15:25:44 +0100 (Wed, 07 Mar 2007)
New Revision: 3141

Modified:
   tools/mesh_combiner/include/MergeMesh.h
   tools/mesh_combiner/include/MergeSkeleton.h
   tools/mesh_combiner/include/MeshCombiner.h
   tools/mesh_combiner/src/MergeMesh.cpp
   tools/mesh_combiner/src/MergeSkeleton.cpp
   tools/mesh_combiner/src/MeshCombiner.cpp
   tools/mesh_combiner/src/MeshCombinerMain.cpp
Log:
Some minor fixes for gcc


Modified: tools/mesh_combiner/include/MergeMesh.h
===================================================================
--- tools/mesh_combiner/include/MergeMesh.h	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/include/MergeMesh.h	2007-03-07 14:25:44 UTC (rev 3141)
@@ -23,4 +23,5 @@
 	};
 }
 
-#endif
\ No newline at end of file
+#endif
+

Modified: tools/mesh_combiner/include/MergeSkeleton.h
===================================================================
--- tools/mesh_combiner/include/MergeSkeleton.h	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/include/MergeSkeleton.h	2007-03-07 14:25:44 UTC (rev 3141)
@@ -20,4 +20,5 @@
 	};
 }
 
-#endif
\ No newline at end of file
+#endif
+

Modified: tools/mesh_combiner/include/MeshCombiner.h
===================================================================
--- tools/mesh_combiner/include/MeshCombiner.h	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/include/MeshCombiner.h	2007-03-07 14:25:44 UTC (rev 3141)
@@ -34,4 +34,5 @@
 	};
 }
 
-#endif
\ No newline at end of file
+#endif
+

Modified: tools/mesh_combiner/src/MergeMesh.cpp
===================================================================
--- tools/mesh_combiner/src/MergeMesh.cpp	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/src/MergeMesh.cpp	2007-03-07 14:25:44 UTC (rev 3141)
@@ -2,7 +2,7 @@
 
 #include <OgreMeshManager.h>
 #include <OgreHardwareBufferManager.h>
-#include <OgreSubmesh.h>
+#include <OgreSubMesh.h>
 
 #include "MeshCombiner.h"
 
@@ -46,7 +46,7 @@
         m_Meshes.push_back( mesh );
 	}
 
-    const String MergeMesh::findSubmeshName( MeshPtr m, ushort sid ) const
+    const String MergeMesh::findSubmeshName( MeshPtr m, Ogre::ushort sid ) const
     {
         Mesh::SubMeshNameMap map = m->getSubMeshNameMap();
         for( Mesh::SubMeshNameMap::const_iterator it = map.begin();
@@ -76,7 +76,7 @@
                 "Baking: adding submeshes for " + (*it)->getName() );
 
             // insert all submeshes
-            for( ushort sid = 0; sid < (*it)->getNumSubMeshes(); ++sid )
+            for( Ogre::ushort sid = 0; sid < (*it)->getNumSubMeshes(); ++sid )
             {
                 SubMesh* sub = (*it)->getSubMesh( sid );
                 const String name = findSubmeshName( (*it), sid );                
@@ -203,3 +203,4 @@
                     VertexBufferBinding* bind = newsub->vertexData->vertexBufferBinding;*/
 
 }
+

Modified: tools/mesh_combiner/src/MergeSkeleton.cpp
===================================================================
--- tools/mesh_combiner/src/MergeSkeleton.cpp	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/src/MergeSkeleton.cpp	2007-03-07 14:25:44 UTC (rev 3141)
@@ -172,3 +172,4 @@
         return sp;
 	}
 }
+

Modified: tools/mesh_combiner/src/MeshCombiner.cpp
===================================================================
--- tools/mesh_combiner/src/MeshCombiner.cpp	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/src/MeshCombiner.cpp	2007-03-07 14:25:44 UTC (rev 3141)
@@ -181,3 +181,4 @@
 		m_Log->logMessage(msg,lvl);
 	}
 }
+

Modified: tools/mesh_combiner/src/MeshCombinerMain.cpp
===================================================================
--- tools/mesh_combiner/src/MeshCombinerMain.cpp	2007-03-07 14:11:17 UTC (rev 3140)
+++ tools/mesh_combiner/src/MeshCombinerMain.cpp	2007-03-07 14:25:44 UTC (rev 3141)
@@ -1,21 +1,17 @@
 #include "MeshCombiner.h"
 
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+/*#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 	#define WIN32_LEAN_AND_MEAN
 	#include "windows.h"
 #else
-	#include "SDL.h"
+	//#include "SDL.h"
 #endif
+*/
 
 
-
 int main(int argc, char **argv)
 {
 	rl::MeshCombiner* meshCombiner = new rl::MeshCombiner();
-
 	delete meshCombiner;
-
-	#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
-		SDL_Quit();
-	#endif
 }
+



From natoka at mail.berlios.de  Wed Mar  7 16:12:46 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 16:12:46 +0100
Subject: [Dsa-hl-svn] r3142 - in rl/trunk/plugins/openaldriver: include src
Message-ID: <200703071512.l27FCk33025259@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 16:12:23 +0100 (Wed, 07 Mar 2007)
New Revision: 3142

Modified:
   rl/trunk/plugins/openaldriver/include/OpenALDriver.h
   rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp
Log:
bugfix for missing abstract function


Modified: rl/trunk/plugins/openaldriver/include/OpenALDriver.h
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-03-07 14:25:44 UTC (rev 3141)
+++ rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-03-07 15:12:23 UTC (rev 3142)
@@ -51,6 +51,12 @@
         virtual void setRolloffFactor(const Ogre::Real& f);
         virtual const Ogre::Real getRolloffFactor();
 
+        /**
+         * If this driver is a Ogre plugin, it returns TRUE.
+         * @return bool TRUE if Ogre plugin, FALSE otherwise.
+         */
+        virtual bool isDriverPlugin();
+
     protected:
         virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type);
 

Modified: rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp	2007-03-07 14:25:44 UTC (rev 3141)
+++ rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp	2007-03-07 15:12:23 UTC (rev 3142)
@@ -171,6 +171,12 @@
         return listener;
     }
 
+
+    bool OpenALDriver::isDriverPlugin()
+    {
+        return true;
+    }
+
     /**
      * Ausdruck einiger Werte des Soundsystems.
      * @author JoSch



From zero-gravity at mail.berlios.de  Wed Mar  7 16:40:21 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Wed, 7 Mar 2007 16:40:21 +0100
Subject: [Dsa-hl-svn] r3143 - in tools/mesh_combiner: . src
Message-ID: <200703071540.l27FeL2j027748@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-07 16:40:14 +0100 (Wed, 07 Mar 2007)
New Revision: 3143

Modified:
   tools/mesh_combiner/meshcombiner.vcproj
   tools/mesh_combiner/src/MergeMesh.cpp
Log:
Corrected buildfiles

Modified: tools/mesh_combiner/meshcombiner.vcproj
===================================================================
--- tools/mesh_combiner/meshcombiner.vcproj	2007-03-07 15:12:23 UTC (rev 3142)
+++ tools/mesh_combiner/meshcombiner.vcproj	2007-03-07 15:40:14 UTC (rev 3143)
@@ -66,7 +66,7 @@
 				OutputFile="$(OutDir)/meshcombiner.exe"
 				Version="0.1d"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\..\dependencies\ogrenew\OgreMain\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib\"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/meshcombiner.pdb"
 				SubSystem="1"
@@ -152,7 +152,7 @@
 				OutputFile="$(OutDir)/meshcombiner.exe"
 				Version="0.1"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\..\dependencies\ogrenew\OgreMain\lib\$(ConfigurationName)\&quot;"
+				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib\"
 				GenerateDebugInformation="false"
 				SubSystem="1"
 				OptimizeReferences="2"

Modified: tools/mesh_combiner/src/MergeMesh.cpp
===================================================================
--- tools/mesh_combiner/src/MergeMesh.cpp	2007-03-07 15:12:23 UTC (rev 3142)
+++ tools/mesh_combiner/src/MergeMesh.cpp	2007-03-07 15:40:14 UTC (rev 3143)
@@ -3,6 +3,7 @@
 #include <OgreMeshManager.h>
 #include <OgreHardwareBufferManager.h>
 #include <OgreSubMesh.h>
+#include <OgreAxisAlignedBox.h>
 
 #include "MeshCombiner.h"
 
@@ -61,7 +62,7 @@
 
     MeshPtr MergeMesh::bake()
     {    
-         MeshCombiner::getSingleton().log( 
+        MeshCombiner::getSingleton().log( 
              "Baking: New Mesh started" );
 
         MeshPtr mp = MeshManager::getSingleton().
@@ -85,7 +86,8 @@
                 SubMesh* newsub;
                 if( name.length() == 0 )
                     newsub = mp->createSubMesh(  );
-                else /// @todo check if a submesh with this name has been created before
+                else 
+                /// @todo check if a submesh with this name has been created before
                     newsub = mp->createSubMesh( name );   
 
                 newsub->useSharedVertices = sub->useSharedVertices;
@@ -113,7 +115,7 @@
                     "Baking: adding submesh '" + name + "'  with material " + sub->getMaterialName() );
             } 
 
-            /// sharedvertices
+            // sharedvertices
             if( (*it)->sharedVertexData != NULL )
             {
                 /// @todo merge with existing sharedVertexData
@@ -131,14 +133,7 @@
                 "Baking: adding bounds for " + (*it)->getName() );
 
             // add bounds
-            Vector3 oldmin = totalBounds.getMinimum();
-            Vector3 newmin = (*it)->getBounds().getMinimum();
-            Vector3 oldmax = totalBounds.getMaximum();
-            Vector3 newmax = (*it)->getBounds().getMaximum();
-            totalBounds = AxisAlignedBox( 
-                std::min( oldmin.x, newmin.x ), std::min( oldmin.y, newmin.y  ), std::min( oldmin.z, newmin.z  ),
-                std::max( oldmax.x, newmax.x ), std::max( oldmax.y, newmax.y  ), std::max( oldmax.z, newmax.z  )
-                );
+            totalBounds.merge( (*it)->getBounds() );
         }           
         mp->_setBounds( totalBounds );
 



From natoka at mail.berlios.de  Wed Mar  7 17:58:09 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 17:58:09 +0100
Subject: [Dsa-hl-svn] r3144 - in modules/aitest/scripts: . maps
Message-ID: <200703071658.l27Gw9j1001501@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 17:58:04 +0100 (Wed, 07 Mar 2007)
New Revision: 3144

Added:
   modules/aitest/scripts/AStarTest1.rb
Modified:
   modules/aitest/scripts/maps/aitest.rb
Log:


Added: modules/aitest/scripts/AStarTest1.rb
===================================================================
--- modules/aitest/scripts/AStarTest1.rb	2007-03-07 15:40:14 UTC (rev 3143)
+++ modules/aitest/scripts/AStarTest1.rb	2007-03-07 16:58:04 UTC (rev 3144)
@@ -0,0 +1,77 @@
+class AStarTest1
+    def initialize(center)
+	@WPGraph = $WPGM.createWayPointGraph();
+    end
+    def save()
+	@WPGraph.save("aitest/maps/graphtest.wpg")
+    end
+    def load()
+	@WPGraph.load("aitest/maps/graphtest.wpg")
+    end
+    def create()
+	# this function defines a waypoint grid
+	height = 0.5;
+	xcoord = -9
+	zcoord = -9
+	xnr = 19
+	znr = 19
+
+	# waypoints
+	xnr.times do
+	    zcoord = -9
+	    znr.times do
+		@WPGraph.addWayPoint([xcoord, height, zcoord],
+				     WayPointNode::WP_EXTERIOR);
+	    	zcoord += 1
+	    end
+	    xcoord += 1
+	end
+
+	# connections (gridlike)
+	
+	znr -= 1
+	xcoord = 0
+	indexx = 0
+	xoffset = 19
+	xnr.times do
+	    znr.times do
+		@WPGraph.addConnection(@WPGraph.getWayPointAt(indexx),
+				       @WPGraph.getWayPointAt(indexx+1));
+		indexx += 1
+	    end
+	    xcoord += 1
+	    indexx = xcoord * xoffset
+	end
+
+	xnr -= 1
+	znr += 1
+	zcoord = 0
+	indexz = 0
+	zoffset = 19
+	znr.times do
+	    xnr.times do
+ 	        @WPGraph.addConnection(@WPGraph.getWayPointAt(indexz),
+		         	       @WPGraph.getWayPointAt(indexz+zoffset));
+		indexz += zoffset
+	    end
+	    zcoord += 1
+	    indexz = zcoord
+	end
+    end
+    def initastar()
+	test = Ogrevec3Vector.new()
+	@astar = AStar.new(AStarCostsDefault.new(ManhattanDistance.new()), @WPGraph, [9.5, 0.5, 9.5], [5, 0.4, -10])
+	@astar.search(test);
+    end
+    def calc()
+	test = Ogrevec3Vector.new()
+	@astar.search(test);
+    end
+    def calcFromTo(p)
+	vec1 = [p[0], 0.5, p[1]]
+	vec2 = [p[2], 0.5, p[3]]
+	test = Ogrevec3Vector.new()
+	@astar.searchFromTo(test, vec1, vec2)
+    end
+end
+

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-07 15:40:14 UTC (rev 3143)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-07 16:58:04 UTC (rev 3144)
@@ -9,12 +9,14 @@
 require 'WallSet1.rb'
 require 'WallSet2.rb'
 
-require 'NpcTest.rb'
-require 'NpcCapsuleTest.rb'
+#require 'NpcTest.rb'
+#require 'NpcCapsuleTest.rb'
 
 require 'WayPointTest.rb'
 require 'WayPointTest2.rb'
 
+require 'AStarTest1.rb'
+
 # Physik aktivieren
 $PM.setEnabled(true)
 
@@ -48,12 +50,15 @@
 #WallSet1.new([0, 0, 0])
 WallSet2.new([0, 0, 0])
 
-NpcTest.new([-5, 0, 5])
-NpcCapsuleTest.new([0, 0, 5])
+#NpcTest.new([-5, 0, 5])
+#NpcCapsuleTest.new([0, 0, 5])
 
 #$MyWPT = WayPointTest.new([0, 0, 0])
 #$MyWPT.save()
-$MyWPT = WayPointTest2.new([0, 0, 0])
-$MyWPT.load()
+#$MyWPT = WayPointTest2.new([0, 0, 0])
+#$MyWPT.load()
+$MyAS = AStarTest1.new([0, 0, 0])
+$MyAS.create()
+$MyAS.calc()
 
 $SCRIPT.log("tests initialisiert.");



From natoka at mail.berlios.de  Wed Mar  7 17:59:10 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 17:59:10 +0100
Subject: [Dsa-hl-svn] r3145 - in rl/trunk/engine/ai: include src
Message-ID: <200703071659.l27GxAkV001595@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 17:59:04 +0100 (Wed, 07 Mar 2007)
New Revision: 3145

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/src/AStar.cpp
Log:
greater than bug eliminated that prevented a* from working properly

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-07 16:58:04 UTC (rev 3144)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-07 16:59:04 UTC (rev 3145)
@@ -104,6 +104,10 @@
 		 */
         virtual void doCreatePrimitive();
 
+        /** creates the primitive from the searchpath
+         */
+        virtual void createPrimitive(const AStarPath& searchPath);
+
 		// End of Overrides from DebugVisualisable
 
 		/** sets up everyting needed for the search.
@@ -138,6 +142,15 @@
 		//! contains the CLOSED set
 		AStarSet mClosed;
 
+        /** debug variable - prevents regenerating the lineprimitive.
+         * When nothing has changed this is set to false and prevents
+         * the regeneration
+         */
+        //bool mChanged;
+
+        //! to be able to turn debug on/off per AStar object
+        bool mDebugAstar;
+
 	};
 	
 }; // namespace

Modified: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-07 16:58:04 UTC (rev 3144)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-07 16:59:04 UTC (rev 3145)
@@ -60,18 +60,17 @@
          * does not work.
          * @param wp pointer to an AStarWayPointNode
 		 */
-		inline bool Equal ( const AStarWayPointNode* wp )
+		inline bool EqualPosition ( const AStarWayPointNode* wp )
 		{
-			return (mWP == wp->mWP) && (mG == wp->mG) && (mH == wp->mH);
+			return (mWP == wp->mWP); //&& (mG == wp->mG) && (mH == wp->mH);
 		}
 
 		/** 2 nodes compared for equilibrium by comparing their values.
 		 * (really needed?) 
 		 */
-		static inline bool Equal ( const AStarWayPointNode* wp1 , const AStarWayPointNode* wp2 )
+		static inline bool EqualPosition ( const AStarWayPointNode* wp1 , const AStarWayPointNode* wp2 )
 		{
-			
-			return (wp1->mWP == wp2->mWP) && (wp1->mG == wp2->mG) && (wp1->mH == wp2->mH);
+			return (wp1->mWP == wp2->mWP);
 		}
 
 		/** 2 nodes compared by comparing their f value.
@@ -90,10 +89,10 @@
             //float wp1F = wp1->mG+wp1->mH;
             //float wp2F = wp2->mG+wp2->mH;
             //if (wp1F == wp2F)
-            //    return wp1->mG < wp2->mG;
+            //    return wp1->mG > wp2->mG;
 
-            //return wp1F < wp2F;
-			return (wp1->mG+wp1->mH) < (wp2->mG+wp2->mH);
+            //return wp1F > wp2F;
+			return (wp1->mG+wp1->mH) > (wp2->mG+wp2->mH);
 		}
 
 		/** fetches the G value (cost til now)

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 16:58:04 UTC (rev 3144)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 16:59:04 UTC (rev 3145)
@@ -36,7 +36,8 @@
 	mStartPos(StartPos),
 	mEndPos(EndPos),
 	mANStart(NULL),
-	mANEnd(NULL)
+	mANEnd(NULL),
+    mDebugAstar(false)
 {
 }
 
@@ -72,6 +73,9 @@
 	// first find 'real' start and end positions by searching for the corresponding waypoints
 	mANStart = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mStartPos) );
 	mANEnd = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mEndPos) );
+
+    mOpen.clear();
+    mClosed.clear();
 }
 
 void AStar::searchFromTo(AStarPath& resultPath, const Ogre::Vector3& StartPos,
@@ -116,18 +120,20 @@
 	// While there are still unvisited nodes
     while( !mOpen.empty() )
 	{
-		Node = mOpen.front();
+        Node = mOpen.front();
 		pop_heap(mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod);
 		mOpen.pop_back();
+
 		mClosed.push_back(Node);
 
 		// check if goal reached
-        if ( Node->Equal(mANEnd) ) {
+        if ( Node->EqualPosition(mANEnd) ) {
 			// create result
-			for (; Node->getParent(); Node = Node->getParent())
+            for (; Node; Node = Node->getParent())
 			{
 				resultPath.push_back(Node->getWP()->getPosition());
 			}
+            createPrimitive(resultPath);
 			// terminate search
 			break;
 		}
@@ -201,8 +207,8 @@
      * so this is not going to work at the moment with the current sortMethod ...
      */
     
-    AStarWayPointNode* help = NULL;
-    bool found = std::binary_search(Set.begin(), Set.end(), Node, AStarWayPointNode::SortMethod);
+    //AStarWayPointNode* help = NULL;
+    //bool found = std::binary_search(Set.begin(), Set.end(), Node, AStarWayPointNode::SortMethod);
     //while (it != Set.end())
     //{
     //    if ( (*it)->Equal(Node) ) // if equal, then Node was 'found'
@@ -214,19 +220,38 @@
     
 	for (it = Set.begin(); it != Set.end(); it++) 
 	{
-        if ( (*it)->Equal(Node) )
+        if ( (*it)->EqualPosition(Node) )
 			return it;
 	}
 
 	return it;
 }
 
-/*		
-const AStarSet& AStar::getWayPointList()
+void AStar::createPrimitive(const AStarPath& searchPath)
 {
-	// search must be finished ? or just invoke it here then ?
+    // if there is no line primitive just skip this here
+    if (!mPrimitive)
+        return;
+
+    AStarPath::const_iterator it = searchPath.begin();
+    AStarPath::const_iterator pit;
+	LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+
+	lineSet->clear();
+    if (it == searchPath.end())
+        return;
+
+    Ogre::Vector3 From;
+    Ogre::Vector3 To;
+    for (it++ ; it != searchPath.end(); it++) 
+    {
+        pit = it - 1;
+        From = (*pit) + Ogre::Vector3(0,0.5,0);
+        To = (*it) + Ogre::Vector3(0,0.5,0);
+
+        lineSet->addLine(From, To, Ogre::ColourValue::Green);
+    }
 }
-*/
 
 DebugVisualisableFlag AStar::getFlag() const
 {
@@ -241,12 +266,8 @@
 		CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager()->
 			getRootSceneNode()->addChild(mSceneNode);
     }
-
-	LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-
-	lineSet->clear();
-
-	//lineSet->addLine(wp1Vec, (*nit).second->getPosition(), Ogre::ColourValue::Blue);
+    // no update here because updates are only necessary when a search
+    // has finished
 }
 
 void AStar::doCreatePrimitive()



From natoka at mail.berlios.de  Wed Mar  7 20:29:24 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 20:29:24 +0100
Subject: [Dsa-hl-svn] r3146 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200703071929.l27JTO2h023929@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 20:29:16 +0100 (Wed, 07 Mar 2007)
New Revision: 3146

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarCosts.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
a* works now properly

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-07 16:59:04 UTC (rev 3145)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-07 19:29:16 UTC (rev 3146)
@@ -37,6 +37,21 @@
 	class AStarStatistics
 	{
 	public:
+        /** default constructor
+         */
+        AStarStatistics();
+
+        /** resets all variables to zero
+         */
+        void reset();
+
+        int mNodesSearched;
+        int mNodesAdded;
+        int mNodesRemoved;
+        int mNodesVisited;
+        int mNodesLeft;
+        int mPathLength;
+        int mPathCost;
 	};
 
 	/** Stores a waypointgraph and is capable of loading and saving it.
@@ -50,6 +65,18 @@
 		//! defines the resultpath as a list of points in world space
 		typedef std::vector< Ogre::Vector3 > AStarPath;
 
+        /** The constructor of AStar
+		 * AStar needs several things to find a path: 
+		 * a heuristic to calculate the cost for the still not travelled part of the path.
+		 * some sort of map to travel in.
+		 * A start and and end point.
+         * This is a convenience constructor so that there is no need to do
+         * a search right from the start, but can be done sometime later.
+		 * @param Costs encapsulates cost and heuristic for distance calculations.
+		 * @param WPGraph contains the map of WayPoints to examine for a path.
+         */
+        AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph );
+
 		/** The constructor of AStar
 		 * AStar needs several things to find a path: 
 		 * a heuristic to calculate the cost for the still not travelled part of the path.

Modified: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-03-07 16:59:04 UTC (rev 3145)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-03-07 19:29:16 UTC (rev 3146)
@@ -34,7 +34,7 @@
 		/** default constructor
 		 * @param Heuristic to use for calculating heuritic values
 		 */
-		AStarCosts(const AStarHeuristic* Heuristic);
+		AStarCosts(const AStarHeuristic* Heuristic, float TieBreakFactor = 1.0f);
 		/** explicit virtual destructor
 		 */
 		virtual ~AStarCosts();
@@ -58,7 +58,10 @@
 			const AStarWayPointNode* wp2) const = 0;
 
 	protected:
+        //! stores the heuristic used to estimate the distance to the goal
 		const AStarHeuristic* mHeuristic;
+        //! a tie break factor that is multiplied with the heuritics result
+        float mTieBreakFactor;
 	};
 	
 	/* An implementation of the abstract interface of AStarCosts.
@@ -73,7 +76,7 @@
 		/** default constructor
 		 * @param Heuristic to use for calculating heuritic values
 		 */
-		AStarCostsDefault(const AStarHeuristic* Heuristic);
+		AStarCostsDefault(const AStarHeuristic* Heuristic, float TieBreakFactor = 1.0f);
 		/** explicit virtual destructor
 		 */
 		virtual ~AStarCostsDefault();

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 16:59:04 UTC (rev 3145)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 19:29:16 UTC (rev 3146)
@@ -29,6 +29,39 @@
 
 namespace rl {
 
+AStarStatistics::AStarStatistics()
+: mNodesSearched(0),
+  mNodesAdded(0),
+  mNodesRemoved(0),
+  mNodesVisited(0),
+  mNodesLeft(0),
+  mPathLength(0),
+  mPathCost(0)
+{
+}
+
+void AStarStatistics::reset()
+{
+  mNodesSearched = 0;
+  mNodesAdded = 0;
+  mNodesRemoved = 0;
+  mNodesVisited = 0;
+  mNodesLeft = 0;
+  mPathLength = 0;
+  mPathCost = 0;
+}
+
+AStar::AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph )
+    : mCosts(Costs),
+	mWPGraph(WPGraph),
+	mStartPos(0,0,0),
+	mEndPos(0,0,0),
+	mANStart(NULL),
+	mANEnd(NULL),
+    mDebugAstar(false)
+{
+}
+
 AStar::AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
 			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos )
 	: mCosts(Costs),
@@ -61,6 +94,8 @@
 	{
 		delete (*it);
 	}
+    mOpen.clear();
+    mClosed.clear();
 }
 
 void AStar::initialise()
@@ -73,9 +108,6 @@
 	// first find 'real' start and end positions by searching for the corresponding waypoints
 	mANStart = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mStartPos) );
 	mANEnd = new AStarWayPointNode( mWPGraph->getNearestWayPoint(mEndPos) );
-
-    mOpen.clear();
-    mClosed.clear();
 }
 
 void AStar::searchFromTo(AStarPath& resultPath, const Ogre::Vector3& StartPos,
@@ -128,7 +160,10 @@
 
 		// check if goal reached
         if ( Node->EqualPosition(mANEnd) ) {
-			// create result
+			// remember new 'end'
+            delete mANEnd;
+            mANEnd = Node;
+            // create result
             for (; Node; Node = Node->getParent())
 			{
 				resultPath.push_back(Node->getWP()->getPosition());

Modified: rl/trunk/engine/ai/src/AStarCosts.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-07 16:59:04 UTC (rev 3145)
+++ rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-07 19:29:16 UTC (rev 3146)
@@ -19,8 +19,9 @@
 
 namespace rl {
 
-AStarCosts::AStarCosts(const AStarHeuristic* Heuristic)
-: mHeuristic(Heuristic)
+AStarCosts::AStarCosts(const AStarHeuristic* Heuristic, float TieBreakFactor)
+: mHeuristic(Heuristic),
+  mTieBreakFactor(TieBreakFactor)
 {
 }
 
@@ -28,14 +29,16 @@
 {
 }
 
-float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
-			const AStarWayPointNode* wp2) const
+float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph, 
+                                const AStarWayPointNode* wp1,
+                                const AStarWayPointNode* wp2) const
 {
-	return mHeuristic->calcDistance(wp1->getWP()->getPosition(), wp2->getWP()->getPosition());
+	return mTieBreakFactor *
+        mHeuristic->calcDistance(wp1->getWP()->getPosition(), wp2->getWP()->getPosition());
 }
 
-AStarCostsDefault::AStarCostsDefault(const AStarHeuristic* Heuristic)
-: AStarCosts(Heuristic)
+AStarCostsDefault::AStarCostsDefault(const AStarHeuristic* Heuristic, float TieBreakFactor)
+: AStarCosts(Heuristic, TieBreakFactor)
 {
 }
 
@@ -44,8 +47,8 @@
 }
 
 float AStarCostsDefault::calcCost(const WayPointGraph* WPGraph,
-										  const AStarWayPointNode* wp1,
-										  const AStarWayPointNode* wp2) const
+                                  const AStarWayPointNode* wp1,
+                                  const AStarWayPointNode* wp2) const
 {
 	return mEuclid.calcDistance(wp1->getWP()->getPosition(), wp2->getWP()->getPosition());
 }

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-07 16:59:04 UTC (rev 3145)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-07 19:29:16 UTC (rev 3146)
@@ -171,7 +171,7 @@
 	class AStarCosts
 	{
 	public:
-		AStarCosts(const rl::AStarHeuristic* Heuristic);	
+		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
 		virtual ~AStarCosts();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const = 0;
@@ -180,7 +180,7 @@
 	class AStarCostsDefault : public AStarCosts
 	{
 	public:
-		AStarCostsDefault(const rl::AStarHeuristic* Heuristic);	
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
 		~AStarCostsDefault();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const;
@@ -189,8 +189,9 @@
 	class AStar
 	{
 	public:
-		AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
-			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
+		AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph);
+		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
+		//	const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
 		virtual ~AStar();
 		
 		void search(std::vector<Ogre::Vector3>& resultPath);



From natoka at mail.berlios.de  Wed Mar  7 20:30:16 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 20:30:16 +0100
Subject: [Dsa-hl-svn] r3147 - in modules/aitest/scripts: . maps
Message-ID: <200703071930.l27JUGxD024067@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 20:30:12 +0100 (Wed, 07 Mar 2007)
New Revision: 3147

Modified:
   modules/aitest/scripts/AStarTest1.rb
   modules/aitest/scripts/maps/aitest.rb
Log:
adapted scripts to work with the changes ...

Modified: modules/aitest/scripts/AStarTest1.rb
===================================================================
--- modules/aitest/scripts/AStarTest1.rb	2007-03-07 19:29:16 UTC (rev 3146)
+++ modules/aitest/scripts/AStarTest1.rb	2007-03-07 19:30:12 UTC (rev 3147)
@@ -3,10 +3,10 @@
 	@WPGraph = $WPGM.createWayPointGraph();
     end
     def save()
-	@WPGraph.save("aitest/maps/graphtest.wpg")
+	@WPGraph.save("aitest/maps/astargrid.wpg")
     end
     def load()
-	@WPGraph.load("aitest/maps/graphtest.wpg")
+	@WPGraph.load("aitest/maps/astargrid.wpg")
     end
     def create()
 	# this function defines a waypoint grid
@@ -60,7 +60,9 @@
     end
     def initastar()
 	test = Ogrevec3Vector.new()
-	@astar = AStar.new(AStarCostsDefault.new(ManhattanDistance.new()), @WPGraph, [9.5, 0.5, 9.5], [5, 0.4, -10])
+	@astarcosts = AStarCostsDefault.new(ManhattanDistance.new(), 1.001)
+	@astar = AStar.new(@astarcosts, @WPGraph)
+	# [9.5, 0.5, 9.5], [5, 0.4, -10])
 	@astar.search(test);
     end
     def calc()

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-07 19:29:16 UTC (rev 3146)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-07 19:30:12 UTC (rev 3147)
@@ -59,6 +59,6 @@
 #$MyWPT.load()
 $MyAS = AStarTest1.new([0, 0, 0])
 $MyAS.create()
-$MyAS.calc()
+$MyAS.initastar()
 
 $SCRIPT.log("tests initialisiert.");



From tanis at mail.berlios.de  Wed Mar  7 21:10:40 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 7 Mar 2007 21:10:40 +0100
Subject: [Dsa-hl-svn] r3148 - rl/trunk/engine/core/src
Message-ID: <200703072010.l27KAeQR026567@sheep.berlios.de>

Author: tanis
Date: 2007-03-07 21:10:37 +0100 (Wed, 07 Mar 2007)
New Revision: 3148

Modified:
   rl/trunk/engine/core/src/SoundManager.cpp
Log:
Don't delete previously active driver after changing. On Shutdown, delete driver only, if it is not a plugin, else let plugin shutdown handle it.

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-03-07 19:30:12 UTC (rev 3147)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-03-07 20:10:37 UTC (rev 3148)
@@ -152,7 +152,6 @@
         if (mActiveDriver != NULL)
         {
             mActiveDriver->shutdown();
-            delete mActiveDriver;
             mActiveDriver = NULL;
         }
         mActiveDriver = driver;
@@ -300,10 +299,6 @@
 
 void SoundManager::unloadAllDrivers()
 {
-    /**
-     * @ToDo: This is a hack to avoid the problem with the Null driver.
-     *        Don't know yet, why this happens.
-     */
     for(DriverList::iterator it = mDriverList.begin(); it != mDriverList.end(); it++)
     {
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
@@ -320,13 +315,16 @@
         if (mActiveDriver != NULL && mActiveDriver == *it)
         {
             mActiveDriver->shutdown();
-            delete mActiveDriver;
             mActiveDriver = NULL;
         }
         if (isDriverPlugin)
         {
             Ogre::Root::getSingleton().unloadPlugin(driverPlugin);
         }
+        else
+        {
+            delete *it;
+        }
 
         LOG_MESSAGE(Logger::MULTIMEDIA,
             "Sound driver DLL "



From tanis at mail.berlios.de  Wed Mar  7 22:02:05 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Wed, 7 Mar 2007 22:02:05 +0100
Subject: [Dsa-hl-svn] r3149 - modules/combattest/dsa
Message-ID: <200703072102.l27L25g6030316@sheep.berlios.de>

Author: tanis
Date: 2007-03-07 22:01:59 +0100 (Wed, 07 Mar 2007)
New Revision: 3149

Modified:
   modules/combattest/dsa/gameobjectdefinitions.gof
Log:
Wolf has a proper mass now, so that its behaviours work.

Modified: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-03-07 20:10:37 UTC (rev 3148)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-03-07 21:01:59 UTC (rev 3149)
@@ -7,7 +7,7 @@
     <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
     <property name="description_dead" type="STRING" data="Ein sehr toter Wolf"/>
     <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
-    <property name="mass" type="REAL" data="0"/>
+    <property name="mass" type="REAL" data="30"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
     <property name="behaviours" type="ARRAY">
     	<property type="STRING" data="DefaultWanderBehaviour"/>



From natoka at mail.berlios.de  Wed Mar  7 22:23:06 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 22:23:06 +0100
Subject: [Dsa-hl-svn] r3150 - in modules/aitest: dsa maps scripts/maps
Message-ID: <200703072123.l27LN6jD031646@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 22:22:46 +0100 (Wed, 07 Mar 2007)
New Revision: 3150

Modified:
   modules/aitest/dsa/gameobjectdefinitions.gof
   modules/aitest/maps/aitest.scene
   modules/aitest/scripts/maps/aitest.rb
Log:
fixed scene so that no dead meshes show up
added a wolf from the compat test

Modified: modules/aitest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-07 21:01:59 UTC (rev 3149)
+++ modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-07 21:22:46 UTC (rev 3150)
@@ -22,12 +22,13 @@
         <property name="baseclass" type="STRING" data="NPC"/>
         <property name="name" type="STRING" data="TestPerson"/>
         <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
-        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
         <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
         <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="DefaultIdleBehaviour"/>
+	    <property type="STRING" data="DefaultWanderBehaviour"/>
+	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
             <property type="STRING" data="DialogBehaviour"/>
         </property>
     </gameobjectclass>
@@ -41,12 +42,27 @@
         <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
         <property name="mass" type="REAL" data="65"/>
         <property name="dialogfile" type="STRING" data="testperson.xml"/>
-        <property name="behaviours" type="ARRAY">
-            <property type="STRING" data="DefaultIdleBehaviour"/>
-            <property type="STRING" data="DialogBehaviour"/>
+	<property name="behaviours" type="ARRAY">
+	    <property type="STRING" data="DefaultWanderBehaviour"/>
+	    <property type="STRING" data="AvoidObstaclesBehaviour"/>
         </property>
     </gameobjectclass>
 
+  <gameobjectclass classid="Wolf" baseclass="Creature">
+     <property name="classid" type="STRING" data="Wolf"/>
+     <property name="baseclass" type="STRING" data="Creature"/>
+     <property name="name" type="STRING" data="Wolf"/>
+     <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
+    <property name="description_dead" type="STRING" data="Ein sehr toter Wolf"/>
+    <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
+    <property name="mass" type="REAL" data="0"/>
+    <property name="geometrytype" type="STRING" data="sphere"/>
+    <property name="behaviours" type="ARRAY">
+    	<property type="STRING" data="DefaultWanderBehaviour"/>
+    	<property type="STRING" data="AvoidObstaclesBehaviour"/>
+    </property>
+  </gameobjectclass>
+
     <gameobjectclass>
         <property name="classid" type="STRING" data="switch3way"/>
         <property name="baseclass" type="STRING" data="Switch3Way"/>

Modified: modules/aitest/maps/aitest.scene
===================================================================
--- modules/aitest/maps/aitest.scene	2007-03-07 21:01:59 UTC (rev 3149)
+++ modules/aitest/maps/aitest.scene	2007-03-07 21:22:46 UTC (rev 3150)
@@ -5,10 +5,5 @@
             <scale x="1.0" y="1.0" z="1.0" />
             <entity meshFile="aitest_floorplane.mesh"/>
         </node>
-        <node>
-            <position x="10.0" y="0.0" z="0.0" />
-            <scale x="1.0" y="1.0" z="1.0" />
-            <entity meshFile="held.mesh"/>
-        </node>
     </nodes>
 </scene>

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-07 21:01:59 UTC (rev 3149)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-07 21:22:46 UTC (rev 3150)
@@ -15,7 +15,7 @@
 require 'WayPointTest.rb'
 require 'WayPointTest2.rb'
 
-require 'AStarTest1.rb'
+#require 'AStarTest1.rb'
 
 # Physik aktivieren
 $PM.setEnabled(true)
@@ -57,8 +57,13 @@
 #$MyWPT.save()
 #$MyWPT = WayPointTest2.new([0, 0, 0])
 #$MyWPT.load()
-$MyAS = AStarTest1.new([0, 0, 0])
-$MyAS.create()
-$MyAS.initastar()
+#$MyAS = AStarTest1.new([0, 0, 0])
+#$MyAS.create()
+#$MyAS.initastar()
+#$UI.linkKeyToRubyCommand('H',"$MyAS.calcFromTo([9.3,8.2,-10,-3])");
 
+wolf = $GOM.createGameObjectProxy("Wolf").getGameObject()
+wolf.placeIntoScene
+wolf.setPosition [0.0,0.0,-5.0]
+
 $SCRIPT.log("tests initialisiert.");



From natoka at mail.berlios.de  Wed Mar  7 22:24:29 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 22:24:29 +0100
Subject: [Dsa-hl-svn] r3151 - in rl/trunk/engine/ai: include src
Message-ID: <200703072124.l27LOTjI031678@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 22:24:24 +0100 (Wed, 07 Mar 2007)
New Revision: 3151

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/src/AStar.cpp
Log:
small fix so that the specified end and start points now are the real end and start points of the reported path

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-07 21:22:46 UTC (rev 3150)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-07 21:24:24 UTC (rev 3151)
@@ -94,10 +94,16 @@
 		~AStar();
 
 		/** starts the search.
+         * The A* utilises AStarCost and searches for a path by building
+         * a A* node graph to the goal. Afterwards the resultpath is
+         * extracted by traversing the graph from the goal to the start.
+         * This actually creates a _reverse_ path to the goal.
+         * @param resultPath contains the researched path in reverse order.
 		 */
 		void search(AStarPath& resultPath);
 
 		/** starts the search for the given start and end positions
+         * @param resultPath contains the researched path in reverse order.
 		 * @param StartPos gives the startpoint for the search
 		 * @param EndPos gives the endposition for the search
 		 */

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 21:22:46 UTC (rev 3150)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-07 21:24:24 UTC (rev 3151)
@@ -163,11 +163,21 @@
 			// remember new 'end'
             delete mANEnd;
             mANEnd = Node;
-            // create result
+            // create result path (start and enpoint might not be on path!)
+            if (Node->getWP()->getPosition() != mEndPos)
+                resultPath.push_back(mEndPos);  // push endpos
+
             for (; Node; Node = Node->getParent())
 			{
 				resultPath.push_back(Node->getWP()->getPosition());
 			}
+
+            // save startpos, if waypoint is not the startpos
+            if (resultPath.back() != mStartPos)
+            {
+                resultPath.push_back(mStartPos);
+            }
+
             createPrimitive(resultPath);
 			// terminate search
 			break;



From natoka at mail.berlios.de  Wed Mar  7 22:52:18 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 22:52:18 +0100
Subject: [Dsa-hl-svn] r3152 - rl/trunk/engine/rules/src
Message-ID: <200703072152.l27LqIPb000888@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 22:52:16 +0100 (Wed, 07 Mar 2007)
New Revision: 3152

Modified:
   rl/trunk/engine/rules/src/GameObject.cpp
Log:
fix bug segfault on missing mesh file


Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-03-07 21:24:24 UTC (rev 3151)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-03-07 21:52:16 UTC (rev 3152)
@@ -512,6 +512,9 @@
         {
             Actor* actor = createActor();
 
+            if (actor == NULL)  // fail silently, because error is already in the log
+                return;
+
             actor->placeIntoScene();
             setActor(actor);
 



From natoka at mail.berlios.de  Wed Mar  7 23:07:38 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 7 Mar 2007 23:07:38 +0100
Subject: [Dsa-hl-svn] r3153 - rl/trunk/engine/rules/src
Message-ID: <200703072207.l27M7cFp001889@sheep.berlios.de>

Author: natoka
Date: 2007-03-07 23:07:24 +0100 (Wed, 07 Mar 2007)
New Revision: 3153

Modified:
   rl/trunk/engine/rules/src/GameObject.cpp
Log:
bugfix for segfault extension so that logging takes place of failed placeIntoScene

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-03-07 21:52:16 UTC (rev 3152)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-03-07 22:07:24 UTC (rev 3153)
@@ -512,15 +512,23 @@
         {
             Actor* actor = createActor();
 
-            if (actor == NULL)  // fail silently, because error is already in the log
-                return;
+            if (actor != NULL)
+            {
+                actor->placeIntoScene();
+                setActor(actor);
 
-            actor->placeIntoScene();
-            setActor(actor);
-
-            GameObjectState tmpState = mState;
-            mState = GOS_IN_SCENE;
-            GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+                GameObjectState tmpState = mState;
+                mState = GOS_IN_SCENE;
+                GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+            }
+            else {
+                LOG_ERROR(
+                    Logger::RULES, 
+                    "Error placing gameobject '"
+                    + Ogre::StringConverter::toString(mId)
+                    + "' into scene "
+                    + mMeshfile);
+            }
         }
     }
 



From blakharaz at mail.berlios.de  Wed Mar  7 23:34:30 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 7 Mar 2007 23:34:30 +0100
Subject: [Dsa-hl-svn] r3154 - rl/trunk/engine/core/src
Message-ID: <200703072234.l27MYUkJ003345@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-07 23:34:26 +0100 (Wed, 07 Mar 2007)
New Revision: 3154

Modified:
   rl/trunk/engine/core/src/SoundManager.cpp
Log:
Shut down the active sound driver before the loop, this is done only once anyway

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-03-07 22:07:24 UTC (rev 3153)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-03-07 22:34:26 UTC (rev 3154)
@@ -299,6 +299,12 @@
 
 void SoundManager::unloadAllDrivers()
 {
+    if (mActiveDriver != NULL)
+    {
+        mActiveDriver->shutdown();
+        mActiveDriver = NULL;
+    }
+
     for(DriverList::iterator it = mDriverList.begin(); it != mDriverList.end(); it++)
     {
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
@@ -312,11 +318,6 @@
             + driverPlugin);
 
         bool isDriverPlugin = (*it)->isDriverPlugin();
-        if (mActiveDriver != NULL && mActiveDriver == *it)
-        {
-            mActiveDriver->shutdown();
-            mActiveDriver = NULL;
-        }
         if (isDriverPlugin)
         {
             Ogre::Root::getSingleton().unloadPlugin(driverPlugin);



From natoka at mail.berlios.de  Thu Mar  8 01:20:38 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Thu, 8 Mar 2007 01:20:38 +0100
Subject: [Dsa-hl-svn] r3155 - in modules/aitest: dsa maps materials
	materials/textures models scripts scripts/maps
Message-ID: <200703080020.l280Kc8e023253@sheep.berlios.de>

Author: natoka
Date: 2007-03-08 01:20:16 +0100 (Thu, 08 Mar 2007)
New Revision: 3155

Added:
   modules/aitest/maps/astargrid.wpg
   modules/aitest/materials/textures/wolf1.dds
   modules/aitest/materials/tie_wolf_01.material
   modules/aitest/models/tie_wolf_01.mesh
   modules/aitest/models/tie_wolf_01_mesh.skeleton
   modules/aitest/scripts/WallSet3.rb
Modified:
   modules/aitest/dsa/gameobjectdefinitions.gof
   modules/aitest/scripts/maps/aitest.rb
Log:
adding wolf mesh and textures for playing around with ai
adding grid definition for waypoint testing of astar
adding a new wallset creation class for a better and more flexible creation of walls
modified gom definitions so that NPC capsule test now moves around in the scene.

Modified: modules/aitest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-07 22:34:26 UTC (rev 3154)
+++ modules/aitest/dsa/gameobjectdefinitions.gof	2007-03-08 00:20:16 UTC (rev 3155)
@@ -33,9 +33,9 @@
         </property>
     </gameobjectclass>
 
-    <gameobjectclass>
+    <gameobjectclass classid="TestPersonCapsule" baseclass="Create">
         <property name="classid" type="STRING" data="TestPersonCapsule"/>
-        <property name="baseclass" type="STRING" data="NPC"/>
+        <property name="baseclass" type="STRING" data="Creature"/>
         <property name="name" type="STRING" data="TestPerson"/>
         <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
         <property name="geometrytype" type="STRING" data="capsule"/>
@@ -55,7 +55,7 @@
      <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
     <property name="description_dead" type="STRING" data="Ein sehr toter Wolf"/>
     <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
-    <property name="mass" type="REAL" data="0"/>
+    <property name="mass" type="REAL" data="40"/>
     <property name="geometrytype" type="STRING" data="sphere"/>
     <property name="behaviours" type="ARRAY">
     	<property type="STRING" data="DefaultWanderBehaviour"/>

Added: modules/aitest/maps/astargrid.wpg
===================================================================
(Binary files differ)


Property changes on: modules/aitest/maps/astargrid.wpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/textures/wolf1.dds
===================================================================
(Binary files differ)


Property changes on: modules/aitest/materials/textures/wolf1.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/materials/tie_wolf_01.material
===================================================================
--- modules/aitest/materials/tie_wolf_01.material	2007-03-07 22:34:26 UTC (rev 3154)
+++ modules/aitest/materials/tie_wolf_01.material	2007-03-08 00:20:16 UTC (rev 3155)
@@ -0,0 +1,15 @@
+material 02_-_Default
+{
+	technique
+	{
+		pass
+		{
+			alpha_rejection greater 128
+
+			texture_unit
+			{
+				texture wolf1.dds
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/aitest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/aitest/models/tie_wolf_01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/models/tie_wolf_01_mesh.skeleton
===================================================================
(Binary files differ)


Property changes on: modules/aitest/models/tie_wolf_01_mesh.skeleton
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/aitest/scripts/WallSet3.rb
===================================================================
--- modules/aitest/scripts/WallSet3.rb	2007-03-07 22:34:26 UTC (rev 3154)
+++ modules/aitest/scripts/WallSet3.rb	2007-03-08 00:20:16 UTC (rev 3155)
@@ -0,0 +1,41 @@
+require 'testcase.rb'
+
+class WallSet3 < TestCase
+  def initialize(center,height,size,wallset)
+    super(center)
+    
+    bname = "WallSet3" + center[0].to_s + center[1].to_s + \
+      center[2].to_s + size.to_s
+    if wallset[0] == 1
+      min_base = [-size, 0.05, -size]
+      max_base = [size, height, -(size + 0.3)]
+      base = $AM.createBoxPrimitiveActor(bname + "_1",
+                                           min_base, max_base, "white")
+      base.placeIntoScene(center);
+    end
+
+    if wallset[1] == 1
+      min_base = [- size, 0.05, size]
+      max_base = [size, height, size + 0.3]
+      base = $AM.createBoxPrimitiveActor(bname + "_2",
+                                           min_base, max_base, "white")
+      base.placeIntoScene(center);
+    end
+
+    if wallset[2] == 1
+      min_base = [- size, 0.05, - size]
+      max_base = [- (size +0.3), height, size]
+      base = $AM.createBoxPrimitiveActor(bname +"_3",
+                                           min_base, max_base, "white")
+      base.placeIntoScene(center);
+    end
+
+    if wallset[3] == 1
+      min_base = [size, 0.05, -size]
+      max_base = [size +0.3, height, size]
+      base = $AM.createBoxPrimitiveActor(bname + "_4",
+                                         min_base, max_base, "white")
+      base.placeIntoScene(center);
+    end
+  end
+end

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2007-03-07 22:34:26 UTC (rev 3154)
+++ modules/aitest/scripts/maps/aitest.rb	2007-03-08 00:20:16 UTC (rev 3155)
@@ -8,14 +8,15 @@
 
 require 'WallSet1.rb'
 require 'WallSet2.rb'
+require 'WallSet3.rb'
 
 #require 'NpcTest.rb'
-#require 'NpcCapsuleTest.rb'
+require 'NpcCapsuleTest.rb'
 
-require 'WayPointTest.rb'
-require 'WayPointTest2.rb'
+#require 'WayPointTest.rb'
+#require 'WayPointTest2.rb'
 
-#require 'AStarTest1.rb'
+require 'AStarTest1.rb'
 
 # Physik aktivieren
 $PM.setEnabled(true)
@@ -26,16 +27,13 @@
 $hero = $GOM.createGameObjectProxy("hero", 1);
 
 $SCRIPT.log("Place hero into scene")
-#$hero.getGameObject().setPosition([0.0, 1.0, 0.0]);
 $hero.getGameObject().placeIntoScene()
 
-
 $SCRIPT.log("Prepare hero for being the active character")
 PlayerSettings.preparePlayer($hero.getGameObject())
 
 $SCRIPT.log("Set hero as active character")
 $UI.setActiveCharacter($hero.getGameObject())
-
 $SCRIPT.log("Hero ready")
 
 $SCRIPT.log("map 'regressiontest' initialisiert.");
@@ -45,13 +43,15 @@
 
 $SCRIPT.log("debug keys are set up");
 
-#DoorTest.new([0.0, 0.0, -5.0])
+DoorTest.new([0.0, 0.0, -5.0])
 
 #WallSet1.new([0, 0, 0])
-WallSet2.new([0, 0, 0])
+#WallSet2.new([0, 0, 0])
+WallSet3.new([0, 0, 0], 0.5, 20, [1,1,1,1])
+WallSet3.new([0, 0, 0], 0.5, 10, [1,1,0,1])
 
 #NpcTest.new([-5, 0, 5])
-#NpcCapsuleTest.new([0, 0, 5])
+NpcCapsuleTest.new([0, 0, 5])
 
 #$MyWPT = WayPointTest.new([0, 0, 0])
 #$MyWPT.save()



From no22 at mail.berlios.de  Thu Mar  8 11:20:06 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Thu, 8 Mar 2007 11:20:06 +0100
Subject: [Dsa-hl-svn] r3156 - in rl/trunk/engine: ai/src rules/include
	rules/src script/swig
Message-ID: <200703081020.l28AK6C0004407@sheep.berlios.de>

Author: no22
Date: 2007-03-08 11:19:28 +0100 (Thu, 08 Mar 2007)
New Revision: 3156

Modified:
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Beginning to change how the effect system works (polling instead 
of apply/rollback mechanism). First change will be a 
creature.getStatus() method instead of isBlind() etc.
Interface already changed (old methods not removed yet) but 
doesn't work yet.


Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-03-08 10:19:28 UTC (rev 3156)
@@ -18,6 +18,6 @@
 	PhysicalObstacle.cpp \
 	PlayerVehicle.cpp \
 	SteeringVehicle.cpp \
-        WayPointNode.cpp \
+    WayPointNode.cpp \
 	WayPointGraph.cpp \
 	WayPointGraphManager.cpp

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-08 10:19:28 UTC (rev 3156)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -55,31 +55,31 @@
     static const int TALENT_MIN_TAW_FOR_BERUF = 0;
 
     /// Eine Doppel-1
-	static const int RESULT_AUTOERFOLG = 100;
+    static const int RESULT_AUTOERFOLG = 100;
     /// Eine Dreifach-1
-	static const int RESULT_SPEKT_AUTOERFOLG = 1000;
+    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
     /// Eine Doppel-20
-	static const int RESULT_AUTOMISSERFOLG = -100;
+    static const int RESULT_AUTOMISSERFOLG = -100;
     /// Eine Dreifach-20
-	static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
-    /** 
+    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
+    /**
      *  Eine bestaetigte 1 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
      *  eine einfache 1 bei einer Eigenschaftsprobe.
      **/
-	static const int RESULT_GLUECKLICH = 100;
+    static const int RESULT_GLUECKLICH = 100;
     /**
      *  Eine bestaetigte 20 bei einer @ref abbdea "AT" oder @ref abbdep "PA",
      *  eine einfache 20 bei einer Eigenschaftsprobe.
      **/
-	static const int RESULT_PATZER = -100;
+    static const int RESULT_PATZER = -100;
     /// Eine normal gelungene Attacke oder Parade
-	static const int RESULT_ERFOLG = 1;
+    static const int RESULT_ERFOLG = 1;
     /// Eine normal misslungene Attacke oder Parade
-	static const int RESULT_MISSERFOLG = -1;
+    static const int RESULT_MISSERFOLG = -1;
 
 
     /// Basistalente
-	/// @todo Passenderen Ort suchen
+    /// @todo Passenderen Ort suchen
     static const CeGuiString TALENT_ART_BASIS = "Basis";
     /// Spezialtalente
     static const CeGuiString TALENT_ART_SPEZIAL = "Spezial";
@@ -100,941 +100,947 @@
     */
     class _RlRulesExport Creature : public GameObject
     {
-    public:
+        public:
 ///////////////////////////////////////////////////////////////////////////////
 // Typedefs
-		/**
-		 *  Liste der Talente. Besteht aus den Namen der Talente (z.B. Athletik)
-         *  als Schluessel und ihrem Wert.
-		 **/
-		typedef std::map<const CeGuiString, TalentStateSet*> TalentMap;
+            /**
+             *  Liste der Talente. Besteht aus den Namen der Talente (z.B. Athletik)
+                   *  als Schluessel und ihrem Wert.
+             **/
+            typedef std::map<const CeGuiString, TalentStateSet*> TalentMap;
 
-        static const Ogre::String CLASS_NAME;
-        static const Ogre::String PROPERTY_BEHAVIOURS; 
+            static const Ogre::String CLASS_NAME;
+            static const Ogre::String PROPERTY_BEHAVIOURS;
 
-        Creature(unsigned int id);
-		        
-        /// Der Standarddestruktor.
-        virtual ~Creature();
+            Creature(unsigned int id);
 
+            /// Der Standarddestruktor.
+            virtual ~Creature();
+
 ///////////////////////////////////////////////////////////////////////////////
 // Enums
-        /// Beschreibt die art des zugefuegten Schadens
-        enum DamageTag
-        {
-            DAMAGETAG_NORMAL = 1,
-            DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
-            DAMAGETAG_FIRE
+            /// Beschreibt die art des zugefuegten Schadens
+            enum DamageTag
+            {
+                DAMAGETAG_NORMAL = 1,
+                DAMAGETAG_PIERCING, ///< Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 < SP
+                DAMAGETAG_FIRE
         };
-        /// Die verschiedenen stati in denen sich eine @ref abbdes "SF" befinden kann.
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
+            /// Die verschiedenen stati in denen sich eine @ref abbdes "SF" befinden kann.
+            enum SfStatus
+            {
+                SFSTATUS_IN_TRAINING = 1,
+                SFSTATUS_OK,
+                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
         };
-  	    /**
-         * Identifiziert welcher Wert angesprochen werden soll.
-         * @warning Bei WERT_MOD_* gibt getValue() Unsinn zurueck, da 
-         * der Multiplikator dann auf 0 + modifier multipliziert wird. 
-         * Stattdessen einzeln auf die Modifikatoren zugreifen!
-         * @ingroup CreatureRubyExports
-         **/
-        enum Wert
-        {
-            WERT_MOD_AE = 1, ///< Astralenergie
-            WERT_MOD_LE, ///< Lebensenergie
-            WERT_MOD_AT, ///< Attacke
-            WERT_MOD_PA, ///< Parade
-            WERT_MOD_FK, ///< Fernkampf
-            WERT_MOD_AU, ///< Ausdauer
-            WERT_MOD_MR, ///< Magieresistenz
-            WERT_MOD_INI, ///< Initiative
-            WERT_MOD_REGENERATION_LE, ///< Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
-            WERT_MOD_REGENERATION_AE, ///< Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
-            WERT_MOD_ERSCHOEPFUNGSSCHWELLE, ///< Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-            WERT_MOD_ALL_EIGENSCHAFTSPROBEN, ///< Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
-            WERT_MOD_ALL_TALENTPROBEN, ///< Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
-            WERT_GS, ///< Geschwindigkeit
-            WERT_SOZIALSTATUS, ///< Sozialstatus
-            WERT_BE, ///< Behinderung
-            WERT_KAMPFUNFAEHIGKEITSSCHWELLE ///< Die Schwelle zur Kampfunfaehigkeit, bei Menschen 5 LE
+            /**
+              * Identifiziert welcher Wert angesprochen werden soll.
+              * @warning Bei WERT_MOD_* gibt getValue() Unsinn zurueck, da 
+              * der Multiplikator dann auf 0 + modifier multipliziert wird. 
+              * Stattdessen einzeln auf die Modifikatoren zugreifen!
+              * @ingroup CreatureRubyExports
+              **/
+            enum Wert
+            {
+                WERT_MOD_AE = 1, ///< Astralenergie
+                WERT_MOD_LE, ///< Lebensenergie
+                WERT_MOD_AT, ///< Attacke
+                WERT_MOD_PA, ///< Parade
+                WERT_MOD_FK, ///< Fernkampf
+                WERT_MOD_AU, ///< Ausdauer
+                WERT_MOD_MR, ///< Magieresistenz
+                WERT_MOD_INI, ///< Initiative
+                WERT_MOD_REGENERATION_LE, ///< Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
+                WERT_MOD_REGENERATION_AE, ///< Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
+                WERT_MOD_ERSCHOEPFUNGSSCHWELLE, ///< Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
+                WERT_MOD_ALL_EIGENSCHAFTSPROBEN, ///< Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
+                WERT_MOD_ALL_TALENTPROBEN, ///< Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
+                WERT_GS, ///< Geschwindigkeit
+                WERT_SOZIALSTATUS, ///< Sozialstatus
+                WERT_BE, ///< Behinderung
+                WERT_KAMPFUNFAEHIGKEITSSCHWELLE ///< Die Schwelle zur Kampfunfaehigkeit, bei Menschen 5 LE
         };
-        
+
 ///////////////////////////////////////////////////////////////////////////////
 // Werte
 
-        /**
-         *  Veraendert die aktuelle @ref abbdel "LE" der Kreatur.
-         *  @param mod Der Wert um den die LE erhoeht (erniedrigt bei 
-         *   negativem Wert) werden soll
-         *  @param ignoreMax Wenn true kann die LE auch ueber das Maximum
-         *   hinaus erhoeht werden.
-         *  @ingroup CreatureRubyExports
-         **/
-        virtual void modifyLe(int mod, bool ignoreMax = false);
-        /**
-         *  Gibt die aktuelle @ref abbdel "LE" der Kreatur zurueck.
-         *  @ingroup CreatureRubyExports
-         **/
-        virtual int getLe();
-        /**
-         *  Gibt die maximale Anzahl an @ref abbdel "LE" zurueck, die die Kreatur haben kann.
-         **/
-        virtual int getLeMax();
+            /**
+             *  Veraendert die aktuelle @ref abbdel "LE" der Kreatur.
+             *  @param mod Der Wert um den die LE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die LE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyLe(int mod, bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdel "LE" der Kreatur zurueck.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual int getLe();
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdel "LE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getLeMax();
 
-        /**
-         *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
-         *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
-         *   negativem Wert) werden soll
-         *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
-         *   hinaus erhoeht werden.
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual void modifyAe(int mod,  bool ignoreMax = false);
-        /**
-         *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
-         **/
-        virtual int getAe();
-        /**
-         *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-         **/
-        virtual int getAeMax();
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AE" der Kreatur.
+             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAe(int mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AE" der Kreatur zurueck.
+             **/
+            virtual int getAe();
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAeMax();
 
-        /**
-         *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
-         *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
-         *   negativem Wert) werden soll
-         *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
-         *   hinaus erhoeht werden.
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual void modifyAu(float mod,  bool ignoreMax = false);
-        /**
-         *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
-         **/
-        virtual float getAu();
-        /**
-         *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
-         **/
-        virtual int getAuMax();
+            /**
+             *  Veraendert die aktuelle @ref abbdea "AU" der Kreatur.
+             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAu(float mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea "AU" der Kreatur zurueck.
+             **/
+            virtual float getAu();
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea "AE" zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAuMax();
 
-        /**
-         *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
-         **/
-		virtual int getAttackeBasis();
-        /**
-         *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
-         **/
-	    virtual int getParadeBasis();
-        /**
-         *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
-         **/
-		virtual int getFernkampfBasis();
-        /**
-         *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
-         **/
-		virtual int getInitiativeBasis();
+            /**
+             *  Berechnet den @ref abbdea "AT"-Basiswert der Kreatur.
+             **/
+            virtual int getAttackeBasis();
+            /**
+             *  Berechnet den @ref abbdep "PA"-Basiswert der Kreatur.
+             **/
+            virtual int getParadeBasis();
+            /**
+             *  Berechnet den @ref abbdef "FK"-Basiswert der Kreatur.
+             **/
+            virtual int getFernkampfBasis();
+            /**
+             *  Berechnet den @ref abbdei "INI"-Basiswert der Kreatur.
+             **/
+            virtual int getInitiativeBasis();
 
-        /**
-         *  Setzt den Basiswert \a wertId auf \a value.
-         *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
-         *  @param value Der neue wert des Basiswerts.
-         *  @see Wert
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual void setWert(Wert wertId, int value);
-		/** 
-         *  Liefert den Basiswert \a wertId zurueck.
-		 *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
-         *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
-         *   zurueckgegeben.
-		 *  @return Der Wert des Basiswerts.
-		 *  @throws InvalidArgumentException wertId konnte in mWerte nicht
-		 *    gefunden werden.
-		 **/
-		virtual int getWert(Wert wertId, bool getUnmodified = false);
-        /**
-         *  Gibt einen Zeiger auf das ganze Stateset des Basiswerts \a wertId zurueck.
-         *  @param wertID Bezeichnet den Basiswert, von dem das StateSet zurueckgegeben
-         *   werden soll.
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual StateSet* getWertStateSet(Wert wertId);
-        /**
-         *  Gibt der Kreatur @ref abbddea "AP".
-         *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-         **/
-        void modifyAp(int modifier);
-        /**
-         *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
-         **/
-        int getAp();
-        /**
-         *  Ver???dert die verbrauchten @ref abbdea "AP", wird beim Steigern
-         *  aufgerufen.
-         *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-         **/
-        void modifyUsedAp(int modifier);
-        /**
-         *  Liefert die verbrauchten @refabbdea "AP" zurueck.
-         **/
-        int getUsedAp();
+            /**
+             *  Setzt den Basiswert \a wertId auf \a value.
+             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
+             *  @param value Der neue wert des Basiswerts.
+             *  @see Wert
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void setWert(Wert wertId, int value);
+            /**
+                   *  Liefert den Basiswert \a wertId zurueck.
+             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
+                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
+                   *   zurueckgegeben.
+             *  @return Der Wert des Basiswerts.
+             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
+             *    gefunden werden.
+             **/
+            virtual int getWert(Wert wertId, bool getUnmodified = false);
+            /**
+             *  Gibt einen Zeiger auf das ganze Stateset des Basiswerts \a wertId zurueck.
+             *  @param wertID Bezeichnet den Basiswert, von dem das StateSet zurueckgegeben
+             *   werden soll.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual StateSet* getWertStateSet(Wert wertId);
+            /**
+             *  Gibt der Kreatur @ref abbddea "AP".
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyAp(int modifier);
+            /**
+             *  Liefert die Gesamtzahl der @ref abbdea "AP" zurueck.
+             **/
+            int getAp();
+            /**
+             *  Ver???dert die verbrauchten @ref abbdea "AP", wird beim Steigern
+             *  aufgerufen.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyUsedAp(int modifier);
+            /**
+             *  Liefert die verbrauchten @refabbdea "AP" zurueck.
+             **/
+            int getUsedAp();
 
 
 ///////////////////////////////////////////////////////////////////////////////
 // Eigenschaften
 
-		/**
-		 *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
-		 *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-         *   @abbdef "FF", etc.).
-		 *  @return Der Wert der Eigenschaft.
-		 *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-		 *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-		 *   Gross/Kleinschreibung beachtet?).
-         *  @ingroup CreatureRubyExports
-		 **/
-        virtual int getEigenschaft(const CeGuiString eigenschaftName);
-		/**
-		 *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
-		 *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-         *   @ref abbdef "FF", etc.).
-		 *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
-		 *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-		 *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-		 *   Gross/Kleinschreibung beachtet?).
-         *  @ingroup CreatureRubyExports
-		 **/
-        virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
-		/** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
-		 *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-         *   @ref abbdef "FF", etc.).
-		 *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
-		 *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-		 *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-		 *   Gross/Kleinschreibung beachtet?).
-         *  @ingroup CreatureRubyExports
-		 **/
-        virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
+            /**
+             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @abbdef "FF", etc.).
+             *  @return Der Wert der Eigenschaft.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual int getEigenschaft(const CeGuiString eigenschaftName);
+            /**
+             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
+            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+                   *   @ref abbdef "FF", etc.).
+             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
 
-        /**
-         *  Liefert einen Zeiger auf das StateSet von \a eigenschaftName zurueck.
-		 *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-         *   @ref abbdef "FF", etc.).
-		 *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-		 *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-		 *   Gross/Kleinschreibung beachtet?).
-         *  @ingroup CreatureRubyExports
-		 **/
-		virtual EigenschaftenStateSet* getEigenschaftenStateSet(const CeGuiString eigenschaftName);
+            /**
+             *  Liefert einen Zeiger auf das StateSet von \a eigenschaftName zurueck.
+            *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
+             *   @ref abbdef "FF", etc.).
+            *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+            *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+            *   Gross/Kleinschreibung beachtet?).
+             *  @ingroup CreatureRubyExports
+            **/
+            virtual EigenschaftenStateSet* getEigenschaftenStateSet(const CeGuiString eigenschaftName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Talente
 
-		/** 
-         *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
-		 *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
-		 *  @param talentName Bezeichnet das Talent.
-         *  @param value Startwert des Talents.
-		 *  @throws InvalidArgumentException Das Talent konnte nicht
-		 *    gefunden werden.
-         *  @ingroup CreatureRubyExports
-		 */
-        void addTalent(const CeGuiString talentName, int value = 0);
-		/** 
-         *  Liefert den Wert des Talents \a talentName zurueck.
-		 *  @param talentName Bezeichnet das Talent.
-		 *  @return @ref abbdet "TaW"
-         *  @ingroup CreatureRubyExports
-		 *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-		 *   nicht gefunden werden.
-		 */
-		virtual int getTalent(const CeGuiString talentName);
-		/** 
-         *  Setzt den Wert des Talents \a talentName.
-		 *  @param talentName Bezeichnet das zu veraendernde Talent.
-		 *  @param value Der neue @ref abbdet TaW.
-		 *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-		 *   nicht gefunden werden.
-         *  @ingroup CreatureRubyExports
-		 */
-        virtual void setTalent(const CeGuiString talentName, int value);
-		/** 
-         *  Erhoeht das Talent \a talentName um \a mod.
-		 *  @param talentName Bezeichnet das zu steigernde Talent.
-		 *  @param mod Der Wert um den das Talent gesteigert werden soll.
-		 *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-		 *   nicht gefunden werden.
-         *  @ingroup CreatureRubyExports
-		 */
-        virtual void modifyTalent(const CeGuiString talentName, int mod);
-        /**
-         * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
-         * Dies wird auch der komplette Talentspiegel genannt.
-         **/
-		virtual const Creature::TalentMap& getAllTalents() const;
-		/** 
-         *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
-         *  Spezielle Erfahrungen, MFF 47.
-		 *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
-         *  @ingroup CreatureRubyExports
-		 */
-		virtual void addSe(const CeGuiString talentName);
-        /**
-         *  Liefert einen Zeiger auf das StateSet des Talents \a talentName zurueck.
-         *  @param talentName Bezeichnet das Talent von dem das StateSet zurueckgegeben
-         *   werden soll.
-         *  @throws IllegalArgumentException Talent nicht gefunden.
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual TalentStateSet* getTalentStateSet(const CeGuiString talentName);
+            /**
+                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
+             *  Das neue Talent wird mit @ref abbdet "TaW" 0 initialisiert.
+             *  @param talentName Bezeichnet das Talent.
+                   *  @param value Startwert des Talents.
+             *  @throws InvalidArgumentException Das Talent konnte nicht
+             *    gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            void addTalent(const CeGuiString talentName, int value = 0);
+            /**
+                   *  Liefert den Wert des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent.
+             *  @return @ref abbdet "TaW"
+                   *  @ingroup CreatureRubyExports
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+             */
+            virtual int getTalent(const CeGuiString talentName);
+            /**
+                   *  Setzt den Wert des Talents \a talentName.
+             *  @param talentName Bezeichnet das zu veraendernde Talent.
+             *  @param value Der neue @ref abbdet TaW.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void setTalent(const CeGuiString talentName, int value);
+            /**
+                   *  Erhoeht das Talent \a talentName um \a mod.
+             *  @param talentName Bezeichnet das zu steigernde Talent.
+             *  @param mod Der Wert um den das Talent gesteigert werden soll.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void modifyTalent(const CeGuiString talentName, int mod);
+            /**
+             * Liefert eine Liste mit allen Talenten und @ref abbdet "TaW"s zurueck.
+             * Dies wird auch der komplette Talentspiegel genannt.
+             **/
+            virtual const Creature::TalentMap& getAllTalents() const;
+            /**
+                   *  Markiert ein Talent mit einer @ref abbdes "SE". Siehe 
+                   *  Spezielle Erfahrungen, MFF 47.
+             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void addSe(const CeGuiString talentName);
+            /**
+             *  Liefert einen Zeiger auf das StateSet des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent von dem das StateSet zurueckgegeben
+             *   werden soll.
+             *  @throws IllegalArgumentException Talent nicht gefunden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual TalentStateSet* getTalentStateSet(const CeGuiString talentName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Kampftechniken
 
-		/**
-		 *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
-		 *  @param kampftechnikName Bezeichnet die Kampftechnik.
-		 *  @param value Initialisiert die Kampftechnik mit value. Standard ist
-		 *  (0,0).
-		 *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
-         *  @ingroup CreatureRubyExports
-		 **/
-		void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int,int>& value = std::make_pair(0,0));
-		/** 
-         *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
-         *  bestimmten Kampftechnik zurueck.
-		 *  @param kampftechnikName Beszeichnet die Kampftechnik.
-		 *  @return Ein std::pair<AT, PA>.
-		 *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
-		 *   \c mKampftechniken gefunden werden.
-		 **/
-        virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
-		/** 
-         *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
-         *  Kampftechnik.
-		 *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
-		 *  @param value Die neuen AT/PA Werte.
-		 *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
-		 *    konnte nicht in \c mKampftechniken gefunden werden.
-		 **/
-        virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
+            /**
+             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
+             *  @param kampftechnikName Bezeichnet die Kampftechnik.
+             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
+             *  (0,0).
+             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
+                   *  @ingroup CreatureRubyExports
+             **/
+            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value = std::make_pair(0, 0));
+            /**
+                   *  Liefert die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer 
+                   *  bestimmten Kampftechnik zurueck.
+             *  @param kampftechnikName Beszeichnet die Kampftechnik.
+             *  @return Ein std::pair<AT, PA>.
+             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
+             *   \c mKampftechniken gefunden werden.
+             **/
+            virtual std::pair<int, int> getKampftechnik(const CeGuiString kampftechnikName) const;
+            /**
+                   *  Setzt die @ref abbdea "AT" und @ref abbdep "PA" Werte in einer bestimmten 
+                   *  Kampftechnik.
+             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
+             *  @param value Die neuen AT/PA Werte.
+             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
+             *    konnte nicht in \c mKampftechniken gefunden werden.
+             **/
+            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair<int, int>& value);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Vorteile
-        /**
-         *  Fuegt einen Vorteil hinzu.
-         *  @param vorteilName Der Name des Vorteils.
-         *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
-         *   Vorteils (z.B. Astrale Regeneration 3).
-         *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
-         **/
-        virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
-        /**
-         *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
-         *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
-         **/
-        virtual bool hasVorteil(const CeGuiString vorteilName);
-        /**
-         *  Liefert das StateSet des Vorteils zurueck.
-         *  Gedacht um die erforderlichen Daten von Gaben abzufragen.
-         *  @param vorteilName Der Name der Gabe.
-         *  @return Ein Zeiger auf das StateSet der Gabe.
-         *  @throws InvalidArgumentException Der Vorteil \a vorteilName konnte
-         *   nicht gefunden werden.
-         **/
-        virtual TalentStateSet* getVorteilStateSet(const CeGuiString vorteilName);
+            /**
+             *  Fuegt einen Vorteil hinzu.
+             *  @param vorteilName Der Name des Vorteils.
+             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
+             *   Vorteils (z.B. Astrale Regeneration 3).
+             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
+             **/
+            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
 
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
+             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
+             **/
+            virtual bool hasVorteil(const CeGuiString vorteilName);
+            /**
+             *  Liefert das StateSet des Vorteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Gaben abzufragen.
+             *  @param vorteilName Der Name der Gabe.
+             *  @return Ein Zeiger auf das StateSet der Gabe.
+             *  @throws InvalidArgumentException Der Vorteil \a vorteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual TalentStateSet* getVorteilStateSet(const CeGuiString vorteilName);
+
 ///////////////////////////////////////////////////////////////////////////////
 // Nachteile
-        /**
-         *  Fuegt einen Nachteil hinzu.
-         *  @param nachteilName Der Name des Nachteils.
-         *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
-         *   die Stufe des Nachteils.
-         *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
-         **/
-        virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
-        /**
-         *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
-         *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
-         **/
-        virtual bool hasNachteil(const CeGuiString nachteilName);
-        /**
-         *  Liefert das StateSet des Nachteils zurueck.
-         *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
-         *  abzufragen.
-         *  @param nachteilName Der Name der Schlechten Eigenschaft.
-         *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
-         *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
-         *   nicht gefunden werden.
-         **/
-        virtual EigenschaftenStateSet* getNachteilStateSet(const CeGuiString nachteilName);
+            /**
+             *  Fuegt einen Nachteil hinzu.
+             *  @param nachteilName Der Name des Nachteils.
+             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
+             *   die Stufe des Nachteils.
+             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
+             **/
+            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
+             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
+             **/
+            virtual bool hasNachteil(const CeGuiString nachteilName);
+            /**
+             *  Liefert das StateSet des Nachteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
+             *  abzufragen.
+             *  @param nachteilName Der Name der Schlechten Eigenschaft.
+             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
+             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual EigenschaftenStateSet* getNachteilStateSet(const CeGuiString nachteilName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Sonderfertigkeiten
 
-		/** 
-         *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
-		 *  @param sfName Bezeichnet die SF.
-         *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
-		 *  @throws InvalidArgumentException \a sfName kann nicht gefunden
-		 *    werden.
-         *  @see SfStatus
-		 */
-		virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-		/** 
-         *  Liefert den Wert der @ref abbdes "SF" zurueck.
-		 *  @param sfName Bezeichnet die SF
-		 *  @throws InvalidArgumentException \a sfName kann nicht in 
-		 *   \c mSonderfertigkeiten gefunden werden.
-		 *  @see SonderfertigkeitMap
-		 */
-		virtual int getSf(const CeGuiString sfName);
-		/** 
-         *  Setzt den Wert der @ref abbdes "SF".
-		 *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
-		 *   werden soll.
-		 *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
-		 *   soll.
-		 *  @throws InvalidArgumentException \a sfName kann nicht in 
-		 *   \c mSonderfertigkeiten gefunden werden.
-		 *  @see SonderfertigkeitMap
-		 */
-		virtual void setSf(const CeGuiString sfName, SfStatus value);
+            /**
+                    *  Fuegt der Kreatur eine @ref abbdes "SF" hinzu.
+             *  @param sfName Bezeichnet die SF.
+                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
+             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
+             *    werden.
+                    *  @see SfStatus
+             */
+            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+            /**
+                   *  Liefert den Wert der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual int getSf(const CeGuiString sfName);
+            /**
+                   *  Setzt den Wert der @ref abbdes "SF".
+             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
+             *   werden soll.
+             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
+             *   soll.
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual void setSf(const CeGuiString sfName, SfStatus value);
 
-        /**
-         *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
-         *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
-		 *  @throws InvalidArgumentException \a sfName kann nicht in 
-		 *   \c mSonderfertigkeiten gefunden werden.
-         *  @ingroup CreatureRubyExports
-         **/
-		virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName);
+            /**
+             *  Liefert einen Zeiger auf das StateSet der @ref abbdes "SF" zurueck.
+             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
+            *  @throws InvalidArgumentException \a sfName kann nicht in 
+            *   \c mSonderfertigkeiten gefunden werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Status
-        /**
-         *  @todo Weitere denkbare Zustaende: unconcious (wie sleeping, nur 
-         *   schwieriger zu wecken), petrified (paralyzed eigentlich = gelaehmt,
-         *   petrified = versteinert
-         **/
+            /**
+             * Gets the status of a creature.
+             **/
+            Effect::Status getStatus();
 
-        /// Checks if the creature is currently blind.
-        bool isBlind();
-        /**
-         *  Set the creature to blind / not blind. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setBlind(bool value);
-        /// Checks if the creature is dead.
-        bool isDead();
-        /**
-         *  Set the creature to dead / alive. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setDead(bool value);
-        /// Checks if the creature is currently deaf.
-        bool isDeaf();
-        /**
-         *  Set the creature to deaf / not deaf. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setDeaf(bool value);
-        /**
-         *  Checks if the creature is currently incapacitated.
-         *  This happens usually if the creature's @ref abbenv "VI" (de: 
-         *  @ref abbdel "LE") falls below the value of 
-         *  WERT_KAMPFUNFAEHIGKEITSSCHWELLE.
-         *  @see Wert
-         **/
-        bool isIncapacitated();
-        /**
-         *  Set the creature to incapacitated / not incapacitated. This status 
-         *  works with reference counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setIncapacitated(bool value);
-        /// Checks if the creature is currently invisible.
-        bool isInvisible();
-        /**
-         *  Set the creature to invisible / visible. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setInvisible(bool value);
-        /// Checks if the creature is currently invulnerable.
-        bool isInvulnerable();
-        /**
-         *  Set the creature to invulnerable / vulnerable. This status works with 
-         *  reference counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setInvulnerable(bool value);
-        /// Checks if the creature is currently parallyzed.
-        bool isParalyzed();
-        /**
-         *  Set the creature to paralyzed / not paralyzed. This status works with 
-         *  reference counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setParalyzed(bool value);
-        /// Checks if the creature is currently silenced.
-        bool isSilenced();
-        /**
-         *  Set the creature to silenced / not silenced. This status works with 
-         *  reference counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setSilenced(bool value);
-        /// Checks if the creature is currently sleeping.
-        bool isSleeping();
-        /**
-         *  Set the creature to sleeping / awake. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setSleeping(bool value);
-        /**
-         *  Checks if the creature is unconcious. This status works with reference
-         *  counting.
-         **/
-        bool isUnconscious();
-        /**
-         *  Set the creature to unconcious/concious. This status works with reference
-         *  counting.
-         *  @see setStatus for a detailed description of the reference system.
-         **/
-        void setUnconscious(bool value);
-        /**
-         *  Returns true if the creature cannot move. This function does not 
-         *  correspond to a certain status variable but checks several other 
-         *  stati such as isDead, isParalyzed and isSleeping.
-         **/
-        bool isImmovable();
-        /**
-         *  Checks if the creature is actively magic. This function does not 
-         *  correspond to a certain status variable but returns true if the 
-         *  modified AE is greater than zero.
-         **/
-		bool isMagic();
+            /**
+             *  @todo Weitere denkbare Zustaende: unconcious (wie sleeping, nur 
+             *   schwieriger zu wecken), petrified (paralyzed eigentlich = gelaehmt,
+             *   petrified = versteinert
+             **/
 
+            /// Checks if the creature is currently blind.
+            bool isBlind();
+            /**
+             *  Set the creature to blind / not blind. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setBlind(bool value);
+            /// Checks if the creature is dead.
+            bool isDead();
+            /**
+             *  Set the creature to dead / alive. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setDead(bool value);
+            /// Checks if the creature is currently deaf.
+            bool isDeaf();
+            /**
+             *  Set the creature to deaf / not deaf. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setDeaf(bool value);
+            /**
+             *  Checks if the creature is currently incapacitated.
+             *  This happens usually if the creature's @ref abbenv "VI" (de: 
+             *  @ref abbdel "LE") falls below the value of 
+             *  WERT_KAMPFUNFAEHIGKEITSSCHWELLE.
+             *  @see Wert
+             **/
+            bool isIncapacitated();
+            /**
+             *  Set the creature to incapacitated / not incapacitated. This status 
+             *  works with reference counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setIncapacitated(bool value);
+            /// Checks if the creature is currently invisible.
+            bool isInvisible();
+            /**
+             *  Set the creature to invisible / visible. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setInvisible(bool value);
+            /// Checks if the creature is currently invulnerable.
+            bool isInvulnerable();
+            /**
+             *  Set the creature to invulnerable / vulnerable. This status works with 
+             *  reference counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setInvulnerable(bool value);
+            /// Checks if the creature is currently parallyzed.
+            bool isParalyzed();
+            /**
+             *  Set the creature to paralyzed / not paralyzed. This status works with 
+             *  reference counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setParalyzed(bool value);
+            /// Checks if the creature is currently silenced.
+            bool isSilenced();
+            /**
+             *  Set the creature to silenced / not silenced. This status works with 
+             *  reference counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setSilenced(bool value);
+            /// Checks if the creature is currently sleeping.
+            bool isSleeping();
+            /**
+             *  Set the creature to sleeping / awake. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setSleeping(bool value);
+            /**
+             *  Checks if the creature is unconcious. This status works with reference
+             *  counting.
+             **/
+            bool isUnconscious();
+            /**
+             *  Set the creature to unconcious/concious. This status works with reference
+             *  counting.
+             *  @see setStatus for a detailed description of the reference system.
+             **/
+            void setUnconscious(bool value);
+            /**
+             *  Returns true if the creature cannot move. This function does not 
+             *  correspond to a certain status variable but checks several other 
+             *  stati such as isDead, isParalyzed and isSleeping.
+             **/
+            bool isImmovable();
+            /**
+             *  Checks if the creature is actively magic. This function does not 
+             *  correspond to a certain status variable but returns true if the 
+             *  modified AE is greater than zero.
+             **/
+            bool isMagic();
 
+
 ///////////////////////////////////////////////////////////////////////////////
 // Inventory
 
 
-		/**
-		 *  Gibt das Inventar der Kreatur zurueck.
-		 *  @return Liefert einen Zeiger auf Inventar der Kreatur
-		 **/
-		Inventory* getInventory();
+            /**
+             *  Gibt das Inventar der Kreatur zurueck.
+             *  @return Liefert einen Zeiger auf Inventar der Kreatur
+             **/
+            Inventory* getInventory();
 
 
 
 ///////////////////////////////////////////////////////////////////////////////
 // Aktionen
-        /** 
-        *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
-		*  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
-		*  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
-        *  die Angabe einer Spezialisierung.
-        *  @param talentName Bezeichnet das Talent
-		*  @param spezialisierungId Bezeichnet die Spezialisierung
-        *  @param modifier Modifikator der Probe, dabei
-        *     ist ein positiver Wert eine Erschwernis,
-        *     ein negativer Wert eine Erleichterung.
-		*  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
-		*     gewuerfelt werden soll
-		*  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
-		*  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
-        *  @return uebrig gebliebene Talentpunkte, ein
-        *     negativer Wert bedeutet die Probe ist nicht bestanden.
-        *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
-        *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
-        *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
-        *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
-        */
-        /**
-         *  @overload doTalentprobe(const CeGuiString,int,int)
-         *  This is the function that should be used in most cases.
-         **/
-        /**
-         *  @overload doTalentprobe(const CeGuiString,int);
-         *  This is the function you should usually use, if there is no fitting
-         *  specialization for the task.
-         *  @ingroup CreatureRubyExports
-         **/
-        /**
-         *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
-         **/
-        virtual int doAlternativeTalentprobe(const CeGuiString talentName, int spezialisierungId, 
-			int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, 
-			CeGuiString eigenschaft3Name);
-        virtual int doTalentprobe(const CeGuiString talentName, int modifier);
+            /**
+            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
+            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
+            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
+            *  die Angabe einer Spezialisierung.
+            *  @param talentName Bezeichnet das Talent
+            *  @param spezialisierungId Bezeichnet die Spezialisierung
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
+            *     gewuerfelt werden soll
+            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
+            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
+            *  @return uebrig gebliebene Talentpunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
+            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
+            */
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int,int)
+             *  This is the function that should be used in most cases.
+             **/
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int);
+             *  This is the function you should usually use, if there is no fitting
+             *  specialization for the task.
+             *  @ingroup CreatureRubyExports
+             **/
+            /**
+             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
+             **/
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int spezialisierungId,
+                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
+                                                 CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
 
-        virtual int doTalentprobe(const CeGuiString talentName, int spezialisierungId,
-			int modifier);
-        virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier, 
-			CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int spezialisierungId,
+                                      int modifier);
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
 
-        /** 
-        *  Durchfuehren einer Eigenschaftsprobe.
-        *  @param eigenschaftName Bezeichnet die Eigenschaft
-        *  @param modifier Modifikator der Probe, dabei
-        *     ist ein positiver Wert eine Erschwernis,
-        *     ein negativer Wert eine Erleichterung.
-        *  @return Uebrig gebliebene Eigenschaftspunkte, ein
-        *     negativer Wert bedeutet die Probe ist nicht bestanden.
-        *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
-        *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
-        *  @ingroup CreatureRubyExports
-        */
-        virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier);
+            /**
+            *  Durchfuehren einer Eigenschaftsprobe.
+            *  @param eigenschaftName Bezeichnet die Eigenschaft
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
+            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
+            *  @ingroup CreatureRubyExports
+            */
+            virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier);
 
-		/** 
-		*  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-		*  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-		*   Attacke ausgefuehrt wird.
-		*  @param modifier Erschwert oder erleichtert die Attacke.
-		*  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-		*  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-		*  @retval RESULT_GLUECKLICH Eine gute Attacke.
-		*  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-		*  @throws InvalidArgumentException Kampftechnik nicht in 
-		*   mKampftechniken gefunden.
-		**/
-		int doAttacke(const CeGuiString kampftechnikName, int modifier);
-		/** 
-		*  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-        *  aufgerufen.
-		*  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-		*   Parade ausgefuehrt wird.
-		*  @param modifier Erschwert oder erleichtert die Parade.
-		*  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-		*  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-		*  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-		*  @retval RESULT_GLUECKLICH Eine gute Parade.
-		*  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-		*  @throws InvalidArgumentException Kampftechnik nicht in 
-		*   \c mKampftechniken gefunden.
-		**/
-		int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
+            /**
+            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Attacke ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Attacke.
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   mKampftechniken gefunden.
+            **/
+            int doAttacke(const CeGuiString kampftechnikName, int modifier);
+            /**
+            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Parade ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Parade.
+            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+            *  @retval RESULT_GLUECKLICH Eine gute Parade.
+            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   \c mKampftechniken gefunden.
+            **/
+            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
 
-		/**
-		 *  Fuehrt einen Initiativewurf durch.
-		 *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
-		 *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
-		 *    'Orientieren'.
-		 **/
-		int doInitiativeWurf(bool getMaxInitiative = false);
+            /**
+             *  Fuehrt einen Initiativewurf durch.
+             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
+             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
+             *    'Orientieren'.
+             **/
+            int doInitiativeWurf(bool getMaxInitiative = false);
 
-		/**
-		 *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
-		 *  @param tp die Trefferpunkte
-         *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
-         *   etc. korrekt zu beruecksichtigen.
-		 **/
-		void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        static const int LEDAMAGE_TP_A = 8;
+            /**
+             *  Fuegt der Kreatur \a tp @ref abbdet "Trefferpunkte" zu.
+             *  @param tp die Trefferpunkte
+                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
+                   *   etc. korrekt zu beruecksichtigen.
+             **/
+            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+            static const int LEDAMAGE_NORMAL = 0;
+            static const int LEDAMAGE_FIRE = 1;
+            static const int LEDAMAGE_WATER = 2;
+            static const int LEDAMAGE_DEMONIC = 4;
+            static const int LEDAMAGE_TP_A = 8;
 
-		/**
-		 *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
-		 *  @param aup die Trefferpunkte
-		 **/
-        void damageAe(int asp);
+            /**
+             *  Zieht der Kreatur \a asp @ref abbdea "Astralpunkte" ab.
+             *  @param aup die Trefferpunkte
+             **/
+            void damageAe(int asp);
 
-        /**
-		 *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
-		 *  @param aup die Trefferpunkte
-         *  @param damageType Typ des Schadens, um Resistenzen
-         *   etc. korrekt zu beruecksichtigen.
-		 **/
-        void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
+            /**
+            *  Zieht der Kreatur \a aup @ref abbdea "Ausdauerpunkte" ab.
+            *  @param aup die Trefferpunkte
+             *  @param damageType Typ des Schadens, um Resistenzen
+             *   etc. korrekt zu beruecksichtigen.
+            **/
+            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
+            static const int AUDAMAGE_NORMAL = 0;
+            static const int AUDAMAGE_HEAT = 1;
+            static const int AUDAMAGE_COLD = 2;
+            static const int AUDAMAGE_CHOKE = 4;
+            static const int AUDAMAGE_DROWN = 8;
 
-        /**
-         *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
-         *  einer mind. 6 stuendigen Ruhephase.
-         *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-         *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-         *   bei Sturm und Hagel...)
-         **/
-        void regenerateLe(int modifier = 0);
-        /**
-         *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
-         *  einer mind. 6 stuendigen Ruhephase.
-         *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-         *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-         *   bei Sturm und Hagel...)
-         **/
-        void regenerateAe(int modifier = 0);
-        /**
-         *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
-         *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
-         *  Parameter time aufgerufen werden.
-         *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
-         *   selten eingesetzt werden.
-         *  @param time Sollte nur benutzt werden, falls es nicht m?glich ist
-         *   die Funktion wirklich nur alle 5 Minuten aufzurufen
-         **/
-        void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
+            /**
+             *  Regeneriert die @reg appdel "LE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateLe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AE" einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateAe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea "AU" einer Kreatur, ueblicherweise nach
+             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+             *  Parameter time aufgerufen werden.
+             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
+             *   selten eingesetzt werden.
+             *  @param time Sollte nur benutzt werden, falls es nicht m???lich ist
+             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
+             **/
+            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
 
-		/**
-		 * Laesst einen Effekt auf der Kreatur wirken.
-		 * @param effect Zeiger auf den Effekt.
-         * @ingroup CreatureRubyExports
-		 **/
-		void addEffect(Effect* effect);
+            /**
+             * Laesst einen Effekt auf der Kreatur wirken.
+             * @param effect Zeiger auf den Effekt.
+                   * @ingroup CreatureRubyExports
+             **/
+            void addEffect(Effect* effect);
 
-        virtual const Property getProperty(const Ogre::String& key) const;
-        virtual void setProperty(const Ogre::String& key, const Property& value);
-        virtual PropertySet* getAllProperties() const;
+            virtual const Property getProperty(const Ogre::String& key) const;
+            virtual void setProperty(const Ogre::String& key, const Property& value);
+            virtual PropertySet* getAllProperties() const;
 
-        
-        /**
-         * Berechnet die taktische Geschwindigkeit bei der angegebenen Bewegungsart (siehe Basisbox S.112 ff).
-         * Eventuelle Athletikproben werden hier nicht miteinbezogen!
-         * Die Wirkung der Modifikatoren h?ngt von den Eigenschaften der Kreatur ab!
-         * Eine gezogene Waffe (bedeutet Aufmerksamkeit) m?sste hier auch miteinbezogen werden.
-         * Eigentlich sind die Modifikatoren laut Regelwerk nur f?r strategische Bewegung gedacht,
-         * aber man k?nnte sie auch gut hier einbauen zum Ausspielen von Vorteilen wie Gel?ndekundig
-         * @param movementType Flag f?r die Art der Bewegung
-         * @param modified Gibt an, ob die Behinderung und ?hnliches miteinbezogen werden soll, 
-         *  bei zu geringerer Au gibt dies auch eine geringere Geschwindigkeit zur?ck
-         * @param modifikatoren Flags f?r verschiedene Modifikatoren wie Gel?nde und Wetter
-         * @retval Berechnete Geschwindigkeit, kann diese Bewegung nicht ausgef?hrt werden, ist der Wert 0
-         *  Bei Spr?ngen ist die Angabe die H?he oder die Weite des Sprungs, bei Drehungen die Umdrehungen pro Sekunde
-        **/
-        float getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren = 0);
-        // die Reihenfolger der Definitionen hier ist wichtig!
-        static const int BEWEGUNG_NONE = 0;
-        //static const int BEWEGUNG_FALLEN = -1 ?
-        // schlie?en sich gegenseitig aus
-        static const int BEWEGUNG_GEHEN = 1; // bitte das hier nicht ?ndern, ohne sich der Folgen in MovementCharacterController bewusst zu sein!
-        static const int BEWEGUNG_JOGGEN = 2;
-        static const int BEWEGUNG_LAUFEN = 4;
-        static const int BEWEGUNG_RENNEN = 8;
-        //static const int BEWEGUNG_SCHWIMMEN = 6;
-        //static const int BEWEGUNG_TAUCHEN = 7;
-        // schlie?en sich gegenseitig aus
-        static const int BEWEGUNG_WEITSPRUNG = 16;
-        static const int BEWEGUNG_HOCHSPRUNG = 32;
-        //static const int BEWEGUNG_PRAEZISER_SPRUNG = 24;
-        static const int BEWEGUNG_SCHLEICHEN = 64; //allgemein f?r den Versuch leise zu sein?
-        // k?nnen miteinander kombiniert werden
-        static const int BEWEGUNG_RUECKWAERTS = 128;
-        static const int BEWEGUNG_SEITWAERTS = 256;
-        // k?nnen nicht miteinander kombiniert werden
-        static const int BEWEGUNG_DREHEN = 512;
-        static const int BEWEGUNG_UMDREHEN = 1024;
-        //static const int BEWEGUNG_BALANCIEREN = 1024;
-        //static const int BEWEGUNG_FLUCHT = 2048; //weiterrennen auch bei zu niedriger AU?
-        //...
-        // folgendes sinnvoll? siehe taktische und strategische Bewegung
-        //static const int BEWEGUNG_MOD_NONE = 0;
-        //static const int BEWEGUNG_MOD_REICHSSTRASSE = 1;
-        //static const int BEWEGUNG_MOD_STADT = 2;
-        //static const int BEWEGUNG_MOD_OFFENES_GELAENDE = 4;
-        //static const int BEWEGUNG_MOD_STEILER_ABHANG = 8; // ? ...
-        
 
-        /**
-         * Gibt an, ob die angegebene taktische Bewegungsart im Moment ?berhaupt m?glich ist.
-         * (Ausdauer und Talentwerte hoch genug?)
-        **/
-        bool canUseTaktischeBewegung(int movementType);
+            /**
+             * Berechnet die taktische Geschwindigkeit bei der angegebenen Bewegungsart (siehe Basisbox S.112 ff).
+             * Eventuelle Athletikproben werden hier nicht miteinbezogen!
+             * Die Wirkung der Modifikatoren h???gt von den Eigenschaften der Kreatur ab!
+             * Eine gezogene Waffe (bedeutet Aufmerksamkeit) msste hier auch miteinbezogen werden.
+             * Eigentlich sind die Modifikatoren laut Regelwerk nur fr strategische Bewegung gedacht,
+             * aber man k???nte sie auch gut hier einbauen zum Ausspielen von Vorteilen wie Gel???dekundig
+             * @param movementType Flag fr die Art der Bewegung
+             * @param modified Gibt an, ob die Behinderung und ???nliches miteinbezogen werden soll, 
+             *  bei zu geringerer Au gibt dies auch eine geringere Geschwindigkeit zurck
+             * @param modifikatoren Flags fr verschiedene Modifikatoren wie Gel???de und Wetter
+             * @retval Berechnete Geschwindigkeit, kann diese Bewegung nicht ausgefhrt werden, ist der Wert 0
+             *  Bei Sprngen ist die Angabe die H???e oder die Weite des Sprungs, bei Drehungen die Umdrehungen pro Sekunde
+            **/
+            float getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren = 0);
+            // die Reihenfolger der Definitionen hier ist wichtig!
+            static const int BEWEGUNG_NONE = 0;
+            //static const int BEWEGUNG_FALLEN = -1 ?
+            // schlie???n sich gegenseitig aus
+            static const int BEWEGUNG_GEHEN = 1; // bitte das hier nicht ???dern, ohne sich der Folgen in MovementCharacterController bewusst zu sein!
+            static const int BEWEGUNG_JOGGEN = 2;
+            static const int BEWEGUNG_LAUFEN = 4;
+            static const int BEWEGUNG_RENNEN = 8;
+            //static const int BEWEGUNG_SCHWIMMEN = 6;
+            //static const int BEWEGUNG_TAUCHEN = 7;
+            // schlie???n sich gegenseitig aus
+            static const int BEWEGUNG_WEITSPRUNG = 16;
+            static const int BEWEGUNG_HOCHSPRUNG = 32;
+            //static const int BEWEGUNG_PRAEZISER_SPRUNG = 24;
+            static const int BEWEGUNG_SCHLEICHEN = 64; //allgemein fr den Versuch leise zu sein?
+            // k???nen miteinander kombiniert werden
+            static const int BEWEGUNG_RUECKWAERTS = 128;
+            static const int BEWEGUNG_SEITWAERTS = 256;
+            // k???nen nicht miteinander kombiniert werden
+            static const int BEWEGUNG_DREHEN = 512;
+            static const int BEWEGUNG_UMDREHEN = 1024;
+            //static const int BEWEGUNG_BALANCIEREN = 1024;
+            //static const int BEWEGUNG_FLUCHT = 2048; //weiterrennen auch bei zu niedriger AU?
+            //...
+            // folgendes sinnvoll? siehe taktische und strategische Bewegung
+            //static const int BEWEGUNG_MOD_NONE = 0;
+            //static const int BEWEGUNG_MOD_REICHSSTRASSE = 1;
+            //static const int BEWEGUNG_MOD_STADT = 2;
+            //static const int BEWEGUNG_MOD_OFFENES_GELAENDE = 4;
+            //static const int BEWEGUNG_MOD_STEILER_ABHANG = 8; // ? ...
 
 
-        /**
-         * F?hrt eine taktische Bewegung aus, das bedeutet, es werden falls n?tig Proben abgelegt
-         * und die Ver?nderungen der AU und LE berechnet; f?r Richtungs?nderungen (Drehung) beim Laufen/etc
-         * muss die Funktion zweimal aufgerufen werden, einmal um die Laufgeschwindigkeit und einmal um die 
-         * Rotationsgeschwindigkeit zu ermitteln 
-         * (das bedeutet auch, dass sobald eine Drehung angegeben wird, nur die Auswirkungen der Drehung, 
-         * nicht der restlichen Bewegung ermittelt werden)
-         * @param movementType Flag f?r die Art der Bewegung
-         * @param modifikator Flags f?r die Umgebung
-         * @param time Die Dauer der Bewegung; hier sind kurze Zeiten vorgesehen (Dauer einer Frame)
-         * @param patzer Falls eine Probe ben?tigt wird, gibt dies die ?briggebliebenen TaW an.
-         *  Ein negativer Wert steht f?r einen Patzer; je kleiner der Wert, desto schlimmer sollten die
-         *  Auswirkungen ausfallen!
-         * @param probenErschwernis Um diesen Wert sind alle ben?tigten Proben erschwert, dient vor allem
-         *  dazu, erschwerte Schleichen-Proben oder ?hnliches zu erm?glichen!
-         * @retval Berechnete Geschwindigkeit (alle Ergebnisse von Talentproben einbezogen)
-        **/
-        float doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis = 0, int modifikatoren = 0);
+            /**
+             * Gibt an, ob die angegebene taktische Bewegungsart im Moment berhaupt m???lich ist.
+             * (Ausdauer und Talentwerte hoch genug?)
+            **/
+            bool canUseTaktischeBewegung(int movementType);
 
-        /**
-         * Fragt den aktuellen Bewegungstyp ab.
-        **/
-        int getTaktischeBewegung(void) const;
 
-        /**
-         * Setzt den aktuellen Bewegungstyp. Wird ebenfalls in doTaktischeBewegung getan!
-        **/
-        void setTaktischeBewegung(int type);
+            /**
+             * Fhrt eine taktische Bewegung aus, das bedeutet, es werden falls n???ig Proben abgelegt
+             * und die Ver???derungen der AU und LE berechnet; fr Richtungs???derungen (Drehung) beim Laufen/etc
+             * muss die Funktion zweimal aufgerufen werden, einmal um die Laufgeschwindigkeit und einmal um die 
+             * Rotationsgeschwindigkeit zu ermitteln 
+             * (das bedeutet auch, dass sobald eine Drehung angegeben wird, nur die Auswirkungen der Drehung, 
+             * nicht der restlichen Bewegung ermittelt werden)
+             * @param movementType Flag fr die Art der Bewegung
+             * @param modifikator Flags fr die Umgebung
+             * @param time Die Dauer der Bewegung; hier sind kurze Zeiten vorgesehen (Dauer einer Frame)
+             * @param patzer Falls eine Probe ben???igt wird, gibt dies die briggebliebenen TaW an.
+             *  Ein negativer Wert steht fr einen Patzer; je kleiner der Wert, desto schlimmer sollten die
+             *  Auswirkungen ausfallen!
+             * @param probenErschwernis Um diesen Wert sind alle ben???igten Proben erschwert, dient vor allem
+             *  dazu, erschwerte Schleichen-Proben oder ???nliches zu erm???lichen!
+             * @retval Berechnete Geschwindigkeit (alle Ergebnisse von Talentproben einbezogen)
+            **/
+            float doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis = 0, int modifikatoren = 0);
 
-    protected:
-        /**
-         * Liefert den Eigenschaftswert \a eigenschaftName fuer eine 
-         * Basiswertberechnung zurueck. Manche Effekte veraendern zwar den
-         * Eigenschaftswert, nicht jedoch die Basiswerte.
-         **/
-        virtual int getEigenschaftForBasiswertCalculation(const CeGuiString eigenschaftName);
-        /**
-         *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
-         **/
-		virtual int getAeBasis();
-        /**
-         *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
-         **/
-		virtual int getAuBasis();
-        /**
-         *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
-         **/
-        virtual int getLeBasis();
-        /**
-         *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
-         **/
-		virtual int getMrBasis();
-		/**
-		 *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
-		 *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
-		 **/
-		virtual int getCurrentBe();
+            /**
+             * Fragt den aktuellen Bewegungstyp ab.
+            **/
+            int getTaktischeBewegung(void) const;
 
+            /**
+             * Setzt den aktuellen Bewegungstyp. Wird ebenfalls in doTaktischeBewegung getan!
+            **/
+            void setTaktischeBewegung(int type);
 
-		/**
-		 * Ueberprueft die wirkenden Effekte auf Lebendigkeit
-		 **/
-		void checkEffects();
+        protected:
+            /**
+             * Liefert den Eigenschaftswert \a eigenschaftName fuer eine 
+             * Basiswertberechnung zurueck. Manche Effekte veraendern zwar den
+             * Eigenschaftswert, nicht jedoch die Basiswerte.
+             **/
+            virtual int getEigenschaftForBasiswertCalculation(const CeGuiString eigenschaftName);
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
+             **/
+            virtual int getAeBasis();
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea "Ausdauer".
+             **/
+            virtual int getAuBasis();
+            /**
+             *  Berechnet den Basiswert von der @ref abbdel "Lebensenergie".
+             **/
+            virtual int getLeBasis();
+            /**
+             *  Berechnet den Basiswert von der @ref abbdem "Magieresistenz".
+             **/
+            virtual int getMrBasis();
+            /**
+             *  Liefert die derzeitge @ref abbdeb "BE" der Kreatur zurueck.
+             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
+             **/
+            virtual int getCurrentBe();
 
-	private:
+
+            /**
+             * Ueberprueft die wirkenden Effekte auf Lebendigkeit
+             **/
+            void checkEffects();
+
+        private:
 ///////////////////////////////////////////////////////////////////////////////
 // Typedefs
-        /**
-         *  Liste der Werte.
-         *  @see Wert
-         **/
-		typedef std::map<const Wert, StateSet*> WertMap;
-		/** 
-         *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
-         *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
-         *  und einem Zeiger auf ihr StateSet.
-		 **/
-		typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
-		/**
-		 *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
-		 *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
-		 *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
-         *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
-		 *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
-		 *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
-		 *  Kampftalent entsprechen.
-		 **/
-        typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
-        /**
-         *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
-         *  den Vorteilen, verhalten sich aber wie Talente.
-         **/
-        typedef std::map<const CeGuiString, TalentStateSet*> VorteilMap;
-        /**
-         *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
-         *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
-         **/
-        typedef std::map<const CeGuiString, EigenschaftenStateSet*> NachteilMap;
-		/** 
-         *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
-         *  Sonderfertigkeit als Schluessel und ihrem Status.
-		 */
-		typedef std::map<const CeGuiString ,SonderfertigkeitenStateSet*> SonderfertigkeitMap;
+            /**
+             *  Liste der Werte.
+             *  @see Wert
+             **/
+            typedef std::map<const Wert, StateSet*> WertMap;
+            /**
+                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
+                   *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
+                   *  und einem Zeiger auf ihr StateSet.
+             **/
+            typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
+            /**
+             *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
+             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
+             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
+                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
+             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
+             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
+             *  Kampftalent entsprechen.
+             **/
+            typedef std::map<const CeGuiString, std::pair<int, int> > KampftechnikMap;
+            /**
+             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
+             *  den Vorteilen, verhalten sich aber wie Talente.
+             **/
+            typedef std::map<const CeGuiString, TalentStateSet*> VorteilMap;
+            /**
+             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
+             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
+             **/
+            typedef std::map<const CeGuiString, EigenschaftenStateSet*> NachteilMap;
+            /**
+                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
+                   *  Sonderfertigkeit als Schluessel und ihrem Status.
+             */
+            typedef std::map<const CeGuiString , SonderfertigkeitenStateSet*> SonderfertigkeitMap;
 
-        struct Ap
-        {
-            int total;
-            int used;
-        };
+            struct Ap
+            {
+                int total;
+                int used;
+            };
 
 ///////////////////////////////////////////////////////////////////////////////
 // Membervariablen
-        /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
-        int mCurrentLe;
-        /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
-		int mCurrentAe;
-        /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
-		float mCurrentAu;
-        /// Die aktuelle Erschoepfung der Kreatur.
-        int mErschoepfung;
-        /// Wenn > 0 ist die Kreatur blind.
-        int mBlind;
-        /// Wenn > 0 ist die Kreatur tot.
-        int mDead;
-        /// Wenn > 0 ist die Kreatur taub.
-        int mDeaf;
-        /// Wenn > 0 ist die Kreatur kampfunfaehig.
-        int mIncapacitated;
-        /// Wenn > 0 ist die Kreatur unverwundbar.
-        int mInvulnerable;
-        /// Wenn > 0 ist die Kreatur unsichtbar.
-        int mInvisible;
-        /// Wenn > 0 ist die Kreatur gelaehmt.
-        int mParalyzed;
-        /// Wenn > 0 ist liegt ein Silentium auf der Kreatur.
-        int mSilenced;
-        /// Wenn > 0 schlaeft die Kreatur.
-        int mSleeping;
-        /// Wenn > 0 ist die Kreatur bewusstlos.
-        int mUnconscious;
-        /// Zuletzt zugewiesene Bewegungsart
-        int mMovementType;
+            /// Die aktuelle @ref abbdel "Lebensenergie" der Kreatur.
+            int mCurrentLe;
+            /// Die aktuelle @ref abbdea "Astralenergie" der Kreatur.
+            int mCurrentAe;
+            /// Die aktuelle @ref abbdea "Ausdauer" der Kreatur.
+            float mCurrentAu;
+            /// Die aktuelle Erschoepfung der Kreatur.
+            int mErschoepfung;
+            /// Wenn > 0 ist die Kreatur blind.
+            int mBlind;
+            /// Wenn > 0 ist die Kreatur tot.
+            int mDead;
+            /// Wenn > 0 ist die Kreatur taub.
+            int mDeaf;
+            /// Wenn > 0 ist die Kreatur kampfunfaehig.
+            int mIncapacitated;
+            /// Wenn > 0 ist die Kreatur unverwundbar.
+            int mInvulnerable;
+            /// Wenn > 0 ist die Kreatur unsichtbar.
+            int mInvisible;
+            /// Wenn > 0 ist die Kreatur gelaehmt.
+            int mParalyzed;
+            /// Wenn > 0 ist liegt ein Silentium auf der Kreatur.
+            int mSilenced;
+            /// Wenn > 0 schlaeft die Kreatur.
+            int mSleeping;
+            /// Wenn > 0 ist die Kreatur bewusstlos.
+            int mUnconscious;
+            /// Zuletzt zugewiesene Bewegungsart
+            int mMovementType;
 
-        /// Verwaltet die Effekte die auf die Kreatur wirken.
-		EffectManager mEffectManager;
-        /// Zeigt auf die gerade aktive Waffe.
-		Weapon* mActiveWeapon;
-        EigenschaftMap mEigenschaften;
-        TalentMap mTalente;
-        KampftechnikMap mKampftechniken;
-        VorteilMap mVorteile;
-        NachteilMap mNachteile;
-		SonderfertigkeitMap mSonderfertigkeiten;
-		WertMap mWerte;
-        Ap mAp;
+            /// Verwaltet die Effekte die auf die Kreatur wirken.
+            EffectManager mEffectManager;
+            /// Zeigt auf die gerade aktive Waffe.
+            Weapon* mActiveWeapon;
+            EigenschaftMap mEigenschaften;
+            TalentMap mTalente;
+            KampftechnikMap mKampftechniken;
+            VorteilMap mVorteile;
+            NachteilMap mNachteile;
+            SonderfertigkeitMap mSonderfertigkeiten;
+            WertMap mWerte;
+            Ap mAp;
 
-        /// Zeigt auf das Inventar der Kreatur.
-		Inventory* mInventory;
+            /// Zeigt auf das Inventar der Kreatur.
+            Inventory* mInventory;
 
-        Property mBehaviours;
+            Property mBehaviours;
 
-        /**
-         *  Sets a the status \a statusVariable. It uses a reference counting
-         *  System to do this, so if for example severeal effects put the creature
-         *  to sleep, and one effect ends the creature doesn't awake until all
-         *  the other effects end too. 
-         *  @param statusVariable is a reference to the status to be set, such as
-         *   \c mBlind.
-         *  @param value If true, the reference is increased, if false it is decreased.
-         *  @param errorMessage If \c setStatus is called with \a value = \c false more often
-         *   than it was with \c true (i.e. the status is removed more often than
-         *   it was applied), \c setStatus throws an exception with \a errorMessage as
-         *   text.
-         *  @throw InvalidArgumentException see \a errorMessage.
-         **/
-        void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
+            /**
+             *  Sets a the status \a statusVariable. It uses a reference counting
+             *  System to do this, so if for example severeal effects put the creature
+             *  to sleep, and one effect ends the creature doesn't awake until all
+             *  the other effects end too. 
+             *  @param statusVariable is a reference to the status to be set, such as
+             *   \c mBlind.
+             *  @param value If true, the reference is increased, if false it is decreased.
+             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
+             *   than it was with \c true (i.e. the status is removed more often than
+             *   it was applied), \c setStatus throws an exception with \a errorMessage as
+             *   text.
+             *  @throw InvalidArgumentException see \a errorMessage.
+             **/
+            void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
     };
 }
 #endif //__CREATURE_H__

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/include/Effect.h	2007-03-08 10:19:28 UTC (rev 3156)
@@ -29,6 +29,20 @@
 	class _RlRulesExport Effect
 	{
 	public:
+        
+      typedef unsigned long Status;
+      static const Status STATUS_NONE = 0;
+      static const Status STATUS_BLIND = 1;
+      static const Status STATUS_DEAD = 2;
+      static const Status STATUS_DEAF = 4;
+      static const Status STATUS_IMMOVABLE = 8;
+      static const Status STATUS_INCAPACITATED = 16;
+      static const Status STATUS_INVISIBLE = 32;
+      static const Status STATUS_INVULNERABLE = 64;
+      static const Status STATUS_PARALYZED = 128;
+      static const Status STATUS_SILENCED = 512;
+      static const Status STATUS_SLEEPING = 1024;
+      static const Status STATUS_UNCONSCIOUS = 2048;
 
         /**
          * Spezifiziert wie oft Effekte des selben Typs gleichzeitig auf dieselbe
@@ -108,6 +122,9 @@
 
 		/// Ueberprueft die Lebendigkeit des Effekts.
 		virtual void check();
+        
+        /// Returns if status is applied to the creature
+        Status getStatus();
 
 	protected:
 		/// Bringt die Aenderungen ein.

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/include/EffectManager.h	2007-03-08 10:19:28 UTC (rev 3156)
@@ -29,7 +29,7 @@
      * Verwaltet die Effekte die auf einer Kreatur wirken.
      * Diese Klasse verwaltet alle Effekte, die auf einer Kreatur liegen.
      * Jede Kreatur hat ihren eigenen EffectManager. Die Funktion checkeffects
-     * sollte w?hrend jeder Aktion (gemeint ist die DSA-Zeiteinheit) aufgerufen
+     * sollte w???rend jeder Aktion (gemeint ist die DSA-Zeiteinheit) aufgerufen
      * werden.
      **/
 
@@ -68,6 +68,11 @@
          * @param effect Ein Zeiger auf den einzufuegenden Effekt.
          **/
 		void addEffect(Effect* effect);
+        
+        /**
+         * Checks the effects for the given status.
+         **/
+        Effect::Status getStatus();
 
 	private:
         /// Eine einfache Menge von Effekten

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-08 10:19:28 UTC (rev 3156)
@@ -613,6 +613,11 @@
 		return it->second;
 	}
 
+    Effect::Status Creature::getStatus()
+    {
+      return mEffectManager.getStatus();
+    }
+    
     bool Creature::isBlind()
     {
         if (mBlind > 0) return true;
@@ -906,7 +911,7 @@
 			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
 		}
 		int rval;
-		int eBe = floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
 
 		int probe = DsaManager::getSingleton().rollD20();
 		if (probe == 1) /// @todo Best??tigen
@@ -936,7 +941,7 @@
 			Throw(IllegalArgumentException, "kampftechnikName nicht in mKampftechniken gefunden");
 		}
 		int rval;
-		int eBe = ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
+		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)->calculateEbe(getWert(WERT_BE))) / 2.0);
 
 		int probe = DsaManager::getSingleton().rollD20();
 		if (probe == 1) /// @todo Best??tigen
@@ -991,7 +996,7 @@
         if ((damageType&LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
         {
             damageAu(tp, AUDAMAGE_NORMAL);
-            tp = floor(tp/2.);
+            tp = (int)floor(tp/2.);
         }
 		modifyLe(-tp);
 	}
@@ -1182,8 +1187,14 @@
         }
 
         // kann sich die Kreatur ueberhaupt bewegen?
+        /*
         if( isImmovable() )
             return false;
+        */
+        ///@todo What other Stati prohibit creature  movement? Paralyzed? Inacapacitated? Sleep? etc.
+        ///@todo Jumping etc. still possible, even if immobilized.
+        if (Effect::STATUS_IMMOVABLE & getStatus())
+          return false;
 
         if( getAu() <= 1 )
             return false;
@@ -1212,15 +1223,15 @@
                 return false;
             }
         }
-        else if( movementType & BEWEGUNG_HOCHSPRUNG || movementType & BEWEGUNG_WEITSPRUNG )
+        else if( (movementType & BEWEGUNG_HOCHSPRUNG) || (movementType & BEWEGUNG_WEITSPRUNG) )
         {
             // if( getragenes Gewicht > KK ) return false
         }
 
 
 
-        if( movementType & BEWEGUNG_DREHEN ||
-            movementType & BEWEGUNG_UMDREHEN)
+        if( (movementType & BEWEGUNG_DREHEN) ||
+            (movementType & BEWEGUNG_UMDREHEN))
         {
         }
         else if( movementType & BEWEGUNG_RENNEN )
@@ -1270,8 +1281,8 @@
 
 
         // drehen ist ein sonderfall! angabe der Rotationsgeschwindigkeit in Umdrehungen pro Sekunde
-        if( movementType & BEWEGUNG_DREHEN ||
-            movementType & BEWEGUNG_UMDREHEN )
+        if( (movementType & BEWEGUNG_DREHEN) ||
+            (movementType & BEWEGUNG_UMDREHEN) )
         {
             if( movementType & BEWEGUNG_UMDREHEN )
                 velocity = 0.5;
@@ -1294,7 +1305,7 @@
             {
                 return 0;
             }
-            if( movementType & BEWEGUNG_RUECKWAERTS || movementType & BEWEGUNG_SEITWAERTS )
+            if( (movementType & BEWEGUNG_RUECKWAERTS) || (movementType & BEWEGUNG_SEITWAERTS) )
                 return 1;
             if( modified && getCurrentBe() > 1 )
                 return 1;
@@ -1356,13 +1367,13 @@
 
         if( movementType & BEWEGUNG_RUECKWAERTS )
         {
-            if( movementType & BEWEGUNG_RENNEN ||
-                movementType & BEWEGUNG_LAUFEN ||
-                movementType & BEWEGUNG_JOGGEN )
+            if( (movementType & BEWEGUNG_RENNEN) ||
+                (movementType & BEWEGUNG_LAUFEN) ||
+                (movementType & BEWEGUNG_JOGGEN) )
             {
                 velocity = 0.6 * act_gs / factorJoggen;
             }
-            else if( movementType & BEWEGUNG_GEHEN )
+            else if( (movementType & BEWEGUNG_GEHEN) )
             {
                 velocity = 0.6 * act_gs / 3.6;
             }
@@ -1375,9 +1386,9 @@
         }
         else if( movementType & BEWEGUNG_SEITWAERTS )
         {
-            if( movementType & BEWEGUNG_RENNEN || 
-                movementType & BEWEGUNG_LAUFEN ||
-                movementType & BEWEGUNG_JOGGEN )
+            if( (movementType & BEWEGUNG_RENNEN) || 
+                (movementType & BEWEGUNG_LAUFEN) ||
+                (movementType & BEWEGUNG_JOGGEN) )
             {
                 velocity = 0.8 * act_gs / factorJoggen;
             }
@@ -1546,9 +1557,9 @@
 
         if( movementType & BEWEGUNG_RUECKWAERTS )
         {
-            if( movementType & BEWEGUNG_RENNEN || 
-                movementType & BEWEGUNG_LAUFEN ||
-                movementType & BEWEGUNG_JOGGEN )
+            if( (movementType & BEWEGUNG_RENNEN) || 
+                (movementType & BEWEGUNG_LAUFEN) ||
+                (movementType & BEWEGUNG_JOGGEN) )
             {
             }
             else if( movementType & BEWEGUNG_GEHEN )
@@ -1558,9 +1569,9 @@
         }
         else if( movementType & BEWEGUNG_SEITWAERTS )
         {
-            if( movementType & BEWEGUNG_RENNEN || 
-                movementType & BEWEGUNG_LAUFEN ||
-                movementType & BEWEGUNG_JOGGEN )
+            if( (movementType & BEWEGUNG_RENNEN) || 
+                (movementType & BEWEGUNG_LAUFEN) ||
+                (movementType & BEWEGUNG_JOGGEN) )
             {
             }
             else if( movementType & BEWEGUNG_GEHEN )

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-03-08 10:19:28 UTC (rev 3156)
@@ -154,4 +154,10 @@
 	{		
         return (DsaManager::getSingleton().getTimestamp() - mStartTime);
 	}
+    
+    Effect::Status Effect::getStatus()
+    {
+      // should be overlaoaded in the specific derivated effects.
+      return STATUS_NONE;
+    }
 }

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-08 10:19:28 UTC (rev 3156)
@@ -95,5 +95,15 @@
 		mEffects.insert(effect);
 		effect->enable();
 	}
+    
+    Effect::Status EffectManager::getStatus()
+    {
+      Effect::Status status;
+      for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+      {
+        status = status | (((*it)->getStatus()));
+      }
+      return false;
+    }
 }
 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-08 00:20:16 UTC (rev 3155)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-08 10:19:28 UTC (rev 3156)
@@ -556,7 +556,22 @@
             EFFECTTAG_NONE,
             EFFECTTAG_KRANKHEIT
         };
+        
+        typedef unsigned long Status;
+        static const Status STATUS_NONE = 0;
+        static const Status STATUS_BLIND = 1;
+        static const Status STATUS_DEAD = 2;
+        static const Status STATUS_DEAF = 4;
+        static const Status STATUS_IMMOVABLE = 8;
+        static const Status STATUS_INCAPACITATED = 16;
+        static const Status STATUS_INVISIBLE = 32;
+        static const Status STATUS_INVULNERABLE = 64;
+        static const Status STATUS_PARALYZED = 128;
+        static const Status STATUS_SILENCED = 512;
+        static const Status STATUS_SLEEPING = 1024;
+        static const Status STATUS_UNCONSCIOUS = 2048;
 
+
 		Effect(int stufe = 1);
 		virtual ~Effect();
 
@@ -580,6 +595,8 @@
 		virtual void disable();
 		virtual void check() = 0;
 
+        Status getStatus();
+        
 	protected:
 		virtual void apply() = 0;
 		virtual void remove() = 0;



From chrber at mail.berlios.de  Thu Mar  8 16:54:28 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Thu, 8 Mar 2007 16:54:28 +0100
Subject: [Dsa-hl-svn] r3157 - in rl/trunk: engine/core/include
	engine/core/src engine/ui/include engine/ui/src
	plugins/fmod4driver/include plugins/fmod4driver/src
	plugins/openaldriver/include plugins/openaldriver/src
Message-ID: <200703081554.l28FsSZ5006672@sheep.berlios.de>

Author: chrber
Date: 2007-03-08 16:54:08 +0100 (Thu, 08 Mar 2007)
New Revision: 3157

Added:
   rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h
   rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp
   rl/trunk/plugins/openaldriver/include/OpenALConfigComponent.h
   rl/trunk/plugins/openaldriver/src/OpenALConfigComponent.cpp
Removed:
   rl/trunk/plugins/fmod4driver/include/Fmod4Config.h
   rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp
   rl/trunk/plugins/openaldriver/include/OpenALConfig.h
   rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp
Modified:
   rl/trunk/engine/core/include/SoundDriver.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/src/SoundDriver.cpp
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/engine/ui/include/ConfigComponent.h
   rl/trunk/engine/ui/include/RenderSystemConfigComponent.h
   rl/trunk/engine/ui/include/SoundDriverConfigComponent.h
   rl/trunk/engine/ui/src/ConfigComponent.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp
   rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp
   rl/trunk/plugins/fmod4driver/include/Makefile.am
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp
   rl/trunk/plugins/fmod4driver/src/Makefile.am
   rl/trunk/plugins/openaldriver/include/Makefile.am
   rl/trunk/plugins/openaldriver/include/OpenALDriver.h
   rl/trunk/plugins/openaldriver/src/Makefile.am
   rl/trunk/plugins/openaldriver/src/OpenALDriverDllMain.cpp
Log:
Adding sounddriver configuration components to the list works
Renamed the specific configuration classes accoding to the new base class names


Modified: rl/trunk/engine/core/include/SoundDriver.h
===================================================================
--- rl/trunk/engine/core/include/SoundDriver.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/core/include/SoundDriver.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -23,6 +23,7 @@
 namespace rl
 {
     class ListenerMovable;
+    class SoundDriverConfigComponent;
 
     typedef enum {ST_SAMPLE, ST_STREAM} SoundType;
 
@@ -96,6 +97,13 @@
         virtual Ogre::NameValuePairList getSettings() const;
 
         /**
+         * Retrieves a pointer to the ConfigComponent of this driver
+         *
+         * @return pointer to ConfigComponent
+         */
+        virtual SoundDriverConfigComponent* getConfigComponent();
+
+        /**
          * Sets certain options for the sound driver, like volume settings for
          * sound effects and music.
          *
@@ -104,16 +112,17 @@
         virtual void applySettings(const Ogre::NameValuePairList& settings);
 
     protected:
+        virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type) = 0;
+
         Ogre::ResourceManager* mSoundResourceManager;
 
         SoundSet mStreamSet;
         SoundSet mSampleSet;
 
-        Ogre::Real mDefaultMusicVolume;  ///!< Music volume
-        Ogre::Real mDefaultSoundVolume;  ///!< Sound effect volume
-        Ogre::Real mMasterVolume;        ///!< Master volume
-
-        virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type) = 0;
+        Ogre::Real mDefaultMusicVolume;               ///!< Music volume
+        Ogre::Real mDefaultSoundVolume;               ///!< Sound effect volume
+        Ogre::Real mMasterVolume;                     ///!< Master volume
+        SoundDriverConfigComponent* mConfigComponent; ///!< Configuration dialog for driver specific settings
     };
 }
 

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/core/include/SoundManager.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -72,6 +72,13 @@
         SoundDriver* getDriverByName(const Ogre::String &name);
 
         /**
+         * Retrieves the curren list of sound drivers
+         *
+         * @return list of sound drivers
+         */
+        const std::list<SoundDriver*>& getDriverList();
+
+        /**
          * Sets the active sound driver and forwards all other settings
          * to the driver's setSettings function.
          *

Modified: rl/trunk/engine/core/src/SoundDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundDriver.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/core/src/SoundDriver.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -107,6 +107,11 @@
         return SoundSettings;
     }
 
+    SoundDriverConfigComponent* SoundDriver::getConfigComponent()
+    {
+        return mConfigComponent;
+    }
+
     void SoundDriver::applySettings(const Ogre::NameValuePairList& settings)
     {
         Ogre::NameValuePairList::const_iterator it;

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -38,8 +38,8 @@
  */
 template<> rl::SoundManager* Singleton<rl::SoundManager>::ms_Singleton = 0;
 
-namespace rl {
-
+namespace rl
+{
     /**
      * @return Eine Referenz auf das Singleton-Objekt.
      * @author JoSch
@@ -238,6 +238,11 @@
     return 0;
 }
 
+    const std::list<SoundDriver*>& SoundManager::getDriverList()
+    {
+        return mDriverList;
+    }
+
     void SoundManager::registerDriver(rl::SoundDriver *driver)
     {
         mDriverList.push_back(driver);

Modified: rl/trunk/engine/ui/include/ConfigComponent.h
===================================================================
--- rl/trunk/engine/ui/include/ConfigComponent.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/include/ConfigComponent.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -23,45 +23,40 @@
 
 namespace rl
 {
-	/**
-	 * Abstract class defining the shared functionality between all
-	 * concrete ConfigComponent implementation classes.
-	 */
-	class _RlUiExport ConfigComponent
-	{
-	public:
-		ConfigComponent(const CEGUI::String& xmlfile);
-		virtual ~ConfigComponent();
+    /**
+     * Abstract class defining the shared functionality between all
+     * concrete ConfigComponent implementation classes.
+     */
+    class _RlUiExport ConfigComponent
+    {
+    public:
+        ConfigComponent(const CEGUI::String& xmlfile, const CEGUI::String& drivername);
+        virtual ~ConfigComponent();
 
-		/**
-		 * Adds this component's root window to a given parent window
-		 *
-		 * @param parent Pointer to parent CEGUI::Window
-		 */
-		void addTo(CEGUI::Window* parent);
+        /**
+         * Adds this component's root window to a given parent window
+         *
+         * @param parent Pointer to parent CEGUI::Window
+         */
+        void addTo(CEGUI::Window* parent);
 
-		/**
-		 * Sets the visibilty state of the window
-		 *
-		 * @param visible true sets window to visible, false the other way
-		 */
-		void setVisible(bool visible);
+        /**
+         * Sets the visibilty state of the window
+         *
+         * @param visible true sets window to visible, false the other way
+         */
+        void setVisible(bool visible);
 
-	protected:
-		/**
-		 * Returns the name for the given driver
-		 */
-		virtual const CEGUI::String getDriverName() const = 0;
+        /**
+         * Returns the name for the given driver
+         */
+        const CEGUI::String getDriverName() const;
 
-		/**
-		 * Initialises the driver of the concrete ConfigComponent
-		 */
-		virtual void initialize() = 0;
-
-	private:
-		CEGUI::Window* mWindow;   //!< CEGUI root window for this component
-		CEGUI::String mXmlFile;   //!< CEGUI layout file
-	};
+    private:
+        CEGUI::Window* mWindow; //!< CEGUI root window for this component
+        CEGUI::String mXmlFile; //!< CEGUI layout file
+        CEGUI::String mName;    //!< User readable name, which is displayed in the driver selection box
+    };
 }
 
 #endif // CONFIGCOMPONENT_H

Modified: rl/trunk/engine/ui/include/RenderSystemConfigComponent.h
===================================================================
--- rl/trunk/engine/ui/include/RenderSystemConfigComponent.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/include/RenderSystemConfigComponent.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -22,23 +22,22 @@
 
 namespace rl
 {
-	class Ogre::RenderSystem;
+    class Ogre::RenderSystem;
 
-	class _RlUiExport RenderSystemConfigComponent : public ConfigComponent
-	{
-	public:
-		RenderSystemConfigComponent(const CEGUI::String& xmlfile);
-		virtual ~RenderSystemConfigComponent();
+    class _RlUiExport RenderSystemConfigComponent : public ConfigComponent
+    {
+    public:
+        RenderSystemConfigComponent(const CEGUI::String& xmlfile, const CEGUI::String& drivername);
+        virtual ~RenderSystemConfigComponent();
 
         virtual void apply() = 0;
         virtual void resetToDefaults() = 0;
         virtual void readDriverData() = 0;
-		const CEGUI::String getDriverName() const;
 
-	protected:
-		virtual Ogre::RenderSystem* getDriver() const = 0;
+    protected:
+        virtual Ogre::RenderSystem* getDriver() const = 0;
         virtual void initialize() = 0;
-	};
+    };
 }
 
 #endif // _RenderSystemConfigComponent_H_

Modified: rl/trunk/engine/ui/include/SoundDriverConfigComponent.h
===================================================================
--- rl/trunk/engine/ui/include/SoundDriverConfigComponent.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/include/SoundDriverConfigComponent.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -22,23 +22,18 @@
 
 namespace rl {
 
-	class SoundDriver;
+    class SoundDriver;
 
-	class _RlUiExport SoundDriverConfigComponent : public ConfigComponent
-	{
-	public:
-		SoundDriverConfigComponent(const CEGUI::String& xmlfile);
-		virtual ~SoundDriverConfigComponent();
+    class _RlUiExport SoundDriverConfigComponent : public ConfigComponent
+    {
+    public:
+        SoundDriverConfigComponent(const CEGUI::String& xmlfile, const CEGUI::String& drivername);
+        virtual ~SoundDriverConfigComponent();
 
         virtual void apply() = 0;
         virtual void resetToDefaults() = 0;
         virtual void readDriverData() = 0;
-		const CEGUI::String getDriverName() const;
-
-	protected:
-		virtual SoundDriver* getDriver() const = 0;
-        virtual void initialize() = 0;
-	};
+    };
 }
 
 #endif // _SoundDriverConfigWindow_H_

Modified: rl/trunk/engine/ui/src/ConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/ConfigComponent.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/src/ConfigComponent.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -15,37 +15,45 @@
  */
 
 #include <CEGUIWindowManager.h>
+#include <iostream>
 
 #include "ConfigComponent.h"
 
 namespace rl
 {
-	ConfigComponent::ConfigComponent(const CEGUI::String& xmlfile)
-	{
-		// Set layout file for component
-		mXmlFile = xmlfile;
-	}
+    ConfigComponent::ConfigComponent(const CEGUI::String& xmlfile, const CEGUI::String& drivername)
+    {
+        // Set layout file for component
+        mXmlFile = xmlfile;
 
-	ConfigComponent::~ConfigComponent()
-	{
-		// Free components root window and its child windows
+        // Set user readable name for driver
+        mName = drivername;
+    }
+
+    ConfigComponent::~ConfigComponent()
+    {
+        // Free components root window and its child windows
         if (mWindow != NULL)
         {
             mWindow->getParent()->removeChildWindow(mWindow);
             CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
             CEGUI::WindowManager::getSingleton().cleanDeadPool();
         }
-	}
+    }
 
-	void ConfigComponent::addTo(CEGUI::Window* parent)
-	{
+    void ConfigComponent::addTo(CEGUI::Window* parent)
+    {
         mWindow = CEGUI::WindowManager::getSingleton().loadWindowLayout(mXmlFile);
         parent->addChildWindow(mWindow);
-        initialize();
-	}
+    }
 
-	void ConfigComponent::setVisible(bool visible)
-	{
-		mWindow->setVisible(visible);
-	}
+    void ConfigComponent::setVisible(bool visible)
+    {
+        mWindow->setVisible(visible);
+    }
+
+    const CEGUI::String ConfigComponent::getDriverName() const
+    {
+        return mName;
+    }
 }

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -15,87 +15,109 @@
  */
 
 #include <boost/bind.hpp>
+#include <iostream>
 
 #include "GameSettings.h"
+#include "SoundManager.h"
+#include "SoundDriver.h"
 
 namespace rl
 {
-	GameSettings::GameSettings()
-	    : CeGuiWindow("gamesettings.xml", WND_MOUSE_INPUT)
-	{
-		// Connect actions to callbacks
-		getWindow()->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
-		                            boost::bind(&GameSettings::onCancel, this));
+    GameSettings::GameSettings()
+        : CeGuiWindow("gamesettings.xml", WND_MOUSE_INPUT)
+    {
+        // Register sound driver components
+        std::list<SoundDriver*> soundDriverList = SoundManager::getSingleton().getDriverList();
 
-		centerWindow();
-	}
+        for (std::list<SoundDriver*>::iterator it = soundDriverList.begin();
+             it != soundDriverList.end(); it++)
+        {
+            if ((*it)->isDriverPlugin())
+            {
+                registerSoundDriverConfig((*it)->getConfigComponent());
+            }
+        }
 
-	GameSettings::~GameSettings()
-	{
-	}
+        // Connect actions to callbacks
+        getWindow()->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
+                                    boost::bind(&GameSettings::onCancel, this));
 
-	void GameSettings::registerSoundDriverConfig(SoundDriverConfigComponent* scc)
-	{
-	}
+        centerWindow();
+    }
 
-	void GameSettings::registerRenderSystemConfig(RenderSystemConfigComponent* rcc)
-	{
-	}
+    GameSettings::~GameSettings()
+    {
+    }
 
-	void GameSettings::setVisible(bool visible, bool destroyAfterHide)
-	{
-		CeGuiWindow::setVisible(visible, destroyAfterHide);
-	}
+    void GameSettings::registerSoundDriverConfig(SoundDriverConfigComponent* scc)
+    {
+        // Add component to list
+        mSoundDriverConfigs.push_back(scc);
 
-	void GameSettings::setConfigComponent(const CEGUI::String& drivername)
-	{
-		// Search the sound configuration component list
-		for (std::list<SoundDriverConfigComponent*>::iterator it = mSoundDriverConfigs.begin();
-		     it != mSoundDriverConfigs.end(); it++)
-		{
-			SoundDriverConfigComponent* cmp = *it;
-			if (drivername == cmp->getDriverName() && mCurrentSoundDriverConfig != cmp)
-			{
-				if (mCurrentSoundDriverConfig != NULL)
-				{
-					mCurrentSoundDriverConfig->setVisible(false);
-				}
-				cmp->setVisible(true);
-				mCurrentSoundDriverConfig = cmp;
-				return;
-			}
-		}
+        getCombobox("GameOptionsWindow/Sound/TableSoundDriver")->addItem(
+            new CEGUI::ListboxTextItem(scc->getDriverName(),
+            getCombobox("GameOptionsWindow/Sound/TableSoundDriver")->getItemCount(),
+            scc));
+    }
 
-		// Search the graphic configuration component list
-		for (std::list<RenderSystemConfigComponent*>::iterator it = mRenderSystemConfigs.begin();
-		     it != mRenderSystemConfigs.end(); it++)
-		{
-			RenderSystemConfigComponent* cmp = *it;
-			if (drivername == cmp->getDriverName() && mCurrentRenderSystemConfig != cmp)
-			{
-				if (mCurrentRenderSystemConfig != NULL)
-				{
-					mCurrentRenderSystemConfig->setVisible(false);
-				}
-				cmp->setVisible(true);
-				mCurrentRenderSystemConfig = cmp;
-				return;
-			}
-		}
-	}
+    void GameSettings::registerRenderSystemConfig(RenderSystemConfigComponent* rcc)
+    {
+    }
 
-	bool GameSettings::onApply()
-	{
+    void GameSettings::setVisible(bool visible, bool destroyAfterHide)
+    {
+        CeGuiWindow::setVisible(visible, destroyAfterHide);
+    }
+
+    void GameSettings::setConfigComponent(const CEGUI::String& drivername)
+    {
+        // Search the sound configuration component list
+        for (std::list<SoundDriverConfigComponent*>::iterator it = mSoundDriverConfigs.begin();
+             it != mSoundDriverConfigs.end(); it++)
+        {
+            SoundDriverConfigComponent* cmp = *it;
+            if (drivername == cmp->getDriverName() && mCurrentSoundDriverConfig != cmp)
+            {
+                if (mCurrentSoundDriverConfig != NULL)
+                {
+                    mCurrentSoundDriverConfig->setVisible(false);
+                }
+                cmp->setVisible(true);
+                mCurrentSoundDriverConfig = cmp;
+                return;
+            }
+        }
+
+        // Search the graphic configuration component list
+        for (std::list<RenderSystemConfigComponent*>::iterator it = mRenderSystemConfigs.begin();
+             it != mRenderSystemConfigs.end(); it++)
+        {
+            RenderSystemConfigComponent* cmp = *it;
+            if (drivername == cmp->getDriverName() && mCurrentRenderSystemConfig != cmp)
+            {
+                if (mCurrentRenderSystemConfig != NULL)
+                {
+                    mCurrentRenderSystemConfig->setVisible(false);
+                }
+                cmp->setVisible(true);
+                mCurrentRenderSystemConfig = cmp;
+                return;
+            }
+        }
+    }
+
+    bool GameSettings::onApply()
+    {
         return true;
-	}
+    }
 
-	bool GameSettings::onCancel()
-	{
+    bool GameSettings::onCancel()
+    {
         return true;
-	}
+    }
 
-	bool GameSettings::onSoundDriverChanged()
-	{
+    bool GameSettings::onSoundDriverChanged()
+    {
         return true;
-	}
+    }
 }

Modified: rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -20,17 +20,12 @@
 #include <CEGUIWindowManager.h>
 
 namespace rl {
-	RenderSystemConfigComponent::RenderSystemConfigComponent(const CeGuiString& xmlfile)
-        : ConfigComponent(xmlfile)
-	{
-	}
+    RenderSystemConfigComponent::RenderSystemConfigComponent(const CeGuiString& xmlfile, const CEGUI::String& drivername)
+        : ConfigComponent(xmlfile, drivername)
+    {
+    }
 
     RenderSystemConfigComponent::~RenderSystemConfigComponent()
     {
     }
-
-	const CEGUI::String RenderSystemConfigComponent::getDriverName() const
-	{
-		return getDriver()->getName();
-	}
 }

Modified: rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -20,17 +20,12 @@
 #include <CEGUIWindowManager.h>
 
 namespace rl {
-	SoundDriverConfigComponent::SoundDriverConfigComponent(const CeGuiString& xmlfile)
-        : ConfigComponent(xmlfile)
-	{
-	}
+    SoundDriverConfigComponent::SoundDriverConfigComponent(const CeGuiString& xmlfile, const CEGUI::String& drivername)
+        : ConfigComponent(xmlfile, drivername)
+    {
+    }
 
     SoundDriverConfigComponent::~SoundDriverConfigComponent()
     {
     }
-
-	const CeGuiString SoundDriverConfigComponent::getDriverName() const
-	{
-		return getDriver()->getName();
-	}
 }

Deleted: rl/trunk/plugins/fmod4driver/include/Fmod4Config.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Config.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Config.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#ifndef _FMOD4CONFIG_H_
-#define _FMOD4CONFIG_H_
-
-#include "SoundDriverConfigComponent.h"
-#include "Fmod4Driver.h"
-
-namespace rl
-{
-	class Fmod4Config : public SoundDriverConfigComponent
-	{
-	public:
-		Fmod4Config(Fmod4Driver* driver);
-		virtual ~Fmod4Config();
-        virtual void apply();
-        virtual void resetToDefaults();
-        virtual void readDriverData();
-
-	protected:
-		Fmod4Driver* getDriver() const;
-        virtual void initialize();
-
-	private:
-		bool handleDriverChanged();
-		bool handleOutputChanged();
-		bool handleSpeakerChanged();
-		
-		// Die Combobox, aus der gew?hlt wird.
-		CEGUI::Combobox* mOutput;
-		CEGUI::Combobox* mDriver;
-		CEGUI::Combobox* mSpeaker;
-
-		// War der Treiber vorher aktiv.
-		bool mWasActive;
-
-		Fmod4Driver* mFmod4Driver;
-	};
-
-}
-
-#endif /* FMOD4CONFIG_H_*/

Copied: rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h (from rev 3134, rl/trunk/plugins/fmod4driver/include/Fmod4Config.h)
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Config.h	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef _FMOD4CONFIG_H_
+#define _FMOD4CONFIG_H_
+
+#include "SoundDriverConfigComponent.h"
+#include "Fmod4Driver.h"
+
+namespace rl
+{
+    class Fmod4ConfigComponent : public SoundDriverConfigComponent
+    {
+    public:
+        Fmod4ConfigComponent();
+        virtual ~Fmod4ConfigComponent();
+        virtual void apply();
+        virtual void resetToDefaults();
+        virtual void readDriverData();
+
+    private:
+        bool handleDriverChanged();
+        bool handleOutputChanged();
+        bool handleSpeakerChanged();
+
+        // Die Combobox, aus der gew?hlt wird.
+        CEGUI::Combobox* mOutput;
+        CEGUI::Combobox* mDriver;
+        CEGUI::Combobox* mSpeaker;
+
+        // War der Treiber vorher aktiv.
+        bool mWasActive;
+
+        Fmod4Driver* mFmod4Driver;
+    };
+
+}
+
+#endif /* FMOD4CONFIG_H_*/

Modified: rl/trunk/plugins/fmod4driver/include/Makefile.am
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Makefile.am	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/include/Makefile.am	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,5 +1,5 @@
 noinst_HEADERS = \
-	Fmod4Config.h \
+	Fmod4ConfigComponent.h \
 	Fmod4Driver.h \
 	Fmod4DriverPrerequisites.h \
 	Fmod4Listener.h \

Deleted: rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,67 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "Fmod4Config.h"
-
-#include <boost/bind.hpp>
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include <fmod.h>
-#else
-    #include <fmodex/fmod.h>
-#endif
-
-
-#include "Exception.h"
-#include "Fmod4Driver.h"
-#include "SoundDriver.h"
-#include "SoundManager.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-    Fmod4Config::Fmod4Config(Fmod4Driver *driver)
-      : SoundDriverConfigComponent("fmod4.xml"),
-        mFmod4Driver(driver)
-    {
-    }
-
-    Fmod4Config::~Fmod4Config()
-    {
-    }
-
-    Fmod4Driver* Fmod4Config::getDriver() const
-    {
-        return mFmod4Driver;
-    }
-
-    void Fmod4Config::apply()
-    {
-    }
-
-    void Fmod4Config::resetToDefaults()
-    {
-    }
-
-    void Fmod4Config::readDriverData()
-    {
-    }
-
-    void Fmod4Config::initialize()
-    {
-    }
-
-}

Copied: rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp (from rev 3134, rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp)
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Config.cpp	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "Fmod4ConfigComponent.h"
+
+#include <boost/bind.hpp>
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+    #include <fmod.h>
+#else
+    #include <fmodex/fmod.h>
+#endif
+
+
+#include "Exception.h"
+#include "Fmod4Driver.h"
+#include "SoundDriver.h"
+#include "SoundManager.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+    Fmod4ConfigComponent::Fmod4ConfigComponent()
+      : SoundDriverConfigComponent("fmod4.xml", "FMOD Ex")
+    {
+    }
+
+    Fmod4ConfigComponent::~Fmod4ConfigComponent()
+    {
+    }
+
+    void Fmod4ConfigComponent::apply()
+    {
+    }
+
+    void Fmod4ConfigComponent::resetToDefaults()
+    {
+    }
+
+    void Fmod4ConfigComponent::readDriverData()
+    {
+    }
+}

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -13,8 +13,9 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+
 #include "Fmod4Driver.h"
-
+#include "Fmod4ConfigComponent.h"
 #include "Fmod4Sound.h"
 #include "Fmod4Listener.h"
 #include "Logger.h"
@@ -34,6 +35,7 @@
         : SoundDriver(soundResourceManager),
         mMasterChannelGroup(NULL)
     {
+        mConfigComponent = new Fmod4ConfigComponent();
         gSoundResourceManager = soundResourceManager;
         gDriver = this;
     }

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,37 +13,27 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
-#include "WindowFactory.h"
 
-#include "Fmod4Config.h"
 #include "Fmod4Driver.h"
 #include "SoundManager.h"
+#include "WindowFactory.h"
 
-
 namespace Ogre
 {
-	using namespace rl;
+    using namespace rl;
 
-	Fmod4Driver* fmod4driver = NULL;
-    Fmod4Config* fmod4config = NULL;
+    Fmod4Driver* fmod4driver = NULL;
 
-	//Called from Ogre's dynload when loading plugins
-	extern "C" void dllStartPlugin( void )
-	{
-		fmod4driver = new Fmod4Driver(SoundManager::getSingletonPtr());
-		SoundManager::getSingleton().registerDriver(fmod4driver);
+    //Called from Ogre's dynload when loading plugins
+    extern "C" void dllStartPlugin( void )
+    {
+        fmod4driver = new Fmod4Driver(SoundManager::getSingletonPtr());
+        SoundManager::getSingleton().registerDriver(fmod4driver);
+    }
 
-		// Register config window
-		///\todo This ain't working. Dunno why, don't care right now.
-        //fmod4config = new Fmod4Config(fmod4driver);
-		//WindowFactory::getSingleton().registerSoundConfigComponent(fmod4config);
-	}
-
-	//Called when unloading plugins
-	extern "C" void dllStopPlugin( void )
-	{
-        delete fmod4config;
-
+    //Called when unloading plugins
+    extern "C" void dllStopPlugin( void )
+    {
         delete fmod4driver;
-	}
+    }
 }

Modified: rl/trunk/plugins/fmod4driver/src/Makefile.am
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Makefile.am	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/fmod4driver/src/Makefile.am	2007-03-08 15:54:08 UTC (rev 3157)
@@ -10,7 +10,7 @@
      -lfmodex $(OGRE_LIBS) $(CEGUIOGRE_LIBS) $(LIBS)
 
 libRlFmod4Driver_la_SOURCES = \
-	Fmod4Config.cpp \
+	Fmod4ConfigComponent.cpp \
 	Fmod4Driver.cpp \
 	Fmod4DriverDllMain.cpp \
 	Fmod4Listener.cpp \

Modified: rl/trunk/plugins/openaldriver/include/Makefile.am
===================================================================
--- rl/trunk/plugins/openaldriver/include/Makefile.am	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/include/Makefile.am	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,5 +1,5 @@
 noinst_HEADERS = \
-	OpenALConfig.h \
+	OpenALConfigComponent.h \
 	OpenALDriver.h \
 	OpenALDriverPrerequisites.h \
 	OpenALListener.h \

Deleted: rl/trunk/plugins/openaldriver/include/OpenALConfig.h
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALConfig.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/include/OpenALConfig.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,43 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#ifndef _OpenALConfig_H_
-#define _OpenALConfig_H
-
-#include "SoundDriverConfigComponent.h"
-#include "OpenALDriver.h"
-
-namespace rl {
-
-	class OpenALConfig : public SoundDriverConfigComponent
-	{
-	public:
-		OpenALConfig(OpenALDriver* driver);
-		~OpenALConfig();
-
-        virtual void apply();
-        virtual void resetToDefaults();
-        virtual void readDriverData();
-
-    protected:
-		virtual OpenALDriver* getDriver() const;
-        virtual void initialize();
-
-	private:
-		OpenALDriver* mDriver;
-	};
-}
-
-#endif //_OpenALConfig_H_

Copied: rl/trunk/plugins/openaldriver/include/OpenALConfigComponent.h (from rev 3134, rl/trunk/plugins/openaldriver/include/OpenALConfig.h)
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALConfig.h	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/plugins/openaldriver/include/OpenALConfigComponent.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -0,0 +1,36 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef _OpenALConfig_H_
+#define _OpenALConfig_H
+
+#include "SoundDriverConfigComponent.h"
+#include "OpenALDriver.h"
+
+namespace rl {
+
+    class OpenALConfigComponent : public SoundDriverConfigComponent
+    {
+    public:
+        OpenALConfigComponent();
+        ~OpenALConfigComponent();
+
+        virtual void apply();
+        virtual void resetToDefaults();
+        virtual void readDriverData();
+    };
+}
+
+#endif //_OpenALConfig_H_

Modified: rl/trunk/plugins/openaldriver/include/OpenALDriver.h
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-03-08 15:54:08 UTC (rev 3157)
@@ -51,10 +51,10 @@
         virtual void setRolloffFactor(const Ogre::Real& f);
         virtual const Ogre::Real getRolloffFactor();
 
-        /**
-         * If this driver is a Ogre plugin, it returns TRUE.
-         * @return bool TRUE if Ogre plugin, FALSE otherwise.
-         */
+        /**
+         * If this driver is a Ogre plugin, it returns TRUE.
+         * @return bool TRUE if Ogre plugin, FALSE otherwise.
+         */
         virtual bool isDriverPlugin();
 
     protected:

Modified: rl/trunk/plugins/openaldriver/src/Makefile.am
===================================================================
--- rl/trunk/plugins/openaldriver/src/Makefile.am	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/src/Makefile.am	2007-03-08 15:54:08 UTC (rev 3157)
@@ -10,8 +10,8 @@
     -lopenal $(RUBY_LIBS) $(OGRE_LIBS) $(CEGUI_LIBS) $(LIBS)
 
 libRlOpenALDriver_la_SOURCES = \
+	OpenALConfigComponent.cpp \
 	OpenALDriver.cpp \
-	OpenALConfig.cpp \
 	OpenALDriverDllMain.cpp \
 	OpenALListener.cpp \
 	OpenALSound.cpp \

Deleted: rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -1,50 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "OpenALConfig.h"
-
-namespace rl {
-
-	OpenALConfig::OpenALConfig(OpenALDriver* driver)
-		:   SoundDriverConfigComponent("openal.xml"),
-			mDriver(driver)
-	{
-	}
-
-	OpenALConfig::~OpenALConfig()
-	{
-	}
-
-	OpenALDriver* OpenALConfig::getDriver() const
-	{
-		return mDriver;
-	}
-
-    void OpenALConfig::apply()
-    {
-    }
-
-    void OpenALConfig::resetToDefaults()
-    {
-    }
-
-    void OpenALConfig::readDriverData()
-    {
-    }
-
-    void OpenALConfig::initialize()
-    {
-    }
-}

Copied: rl/trunk/plugins/openaldriver/src/OpenALConfigComponent.cpp (from rev 3134, rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp)
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALConfig.cpp	2007-03-06 21:57:31 UTC (rev 3134)
+++ rl/trunk/plugins/openaldriver/src/OpenALConfigComponent.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -0,0 +1,40 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "OpenALConfigComponent.h"
+
+namespace rl {
+
+    OpenALConfigComponent::OpenALConfigComponent()
+        :   SoundDriverConfigComponent("openal.xml", "OpenAL")
+    {
+    }
+
+    OpenALConfigComponent::~OpenALConfigComponent()
+    {
+    }
+
+    void OpenALConfigComponent::apply()
+    {
+    }
+
+    void OpenALConfigComponent::resetToDefaults()
+    {
+    }
+
+    void OpenALConfigComponent::readDriverData()
+    {
+    }
+}

Modified: rl/trunk/plugins/openaldriver/src/OpenALDriverDllMain.cpp
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALDriverDllMain.cpp	2007-03-08 10:19:28 UTC (rev 3156)
+++ rl/trunk/plugins/openaldriver/src/OpenALDriverDllMain.cpp	2007-03-08 15:54:08 UTC (rev 3157)
@@ -16,32 +16,28 @@
 #include "WindowFactory.h"
 
 #include "OpenALDriver.h"
-#include "OpenALConfig.h"
 #include "SoundManager.h"
 
 namespace Ogre
 {
-	using namespace rl;
+    using namespace rl;
 
-	OpenALDriver* openaldriver;
+    OpenALDriver* openaldriver;
 
-	//Called from Ogre's dynload when loading plugins
-	extern "C" void dllStartPlugin( void )
-	{
-		// Create the driver
-		openaldriver = new OpenALDriver(SoundManager::getSingletonPtr());
+    //Called from Ogre's dynload when loading plugins
+    extern "C" void dllStartPlugin( void )
+    {
+        // Create the driver
+        openaldriver = new OpenALDriver(SoundManager::getSingletonPtr());
 
-		// Register driver
-		SoundManager::getSingleton().registerDriver(openaldriver);
+        // Register driver
+        SoundManager::getSingleton().registerDriver(openaldriver);
+    }
 
-		// Register config window
-		// WindowFactory::getSingleton().registerSoundConfigComponent(new OpenALConfig(openaldriver));
-	}
-
-	//Called when unloading plugins
-	extern "C" void dllStopPlugin( void )
-	{
-		//Just delete the driver :P
-		delete openaldriver;
-	}
+    //Called when unloading plugins
+    extern "C" void dllStopPlugin( void )
+    {
+        //Just delete the driver :P
+        delete openaldriver;
+    }
 }



From tanis at mail.berlios.de  Thu Mar  8 19:27:41 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 8 Mar 2007 19:27:41 +0100
Subject: [Dsa-hl-svn] r3158 - in rl/trunk/plugins: fmod4driver
	fmod4driver/src openaldriver
Message-ID: <200703081827.l28IRfcN031957@sheep.berlios.de>

Author: tanis
Date: 2007-03-08 19:27:03 +0100 (Thu, 08 Mar 2007)
New Revision: 3158

Modified:
   rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp
   rl/trunk/plugins/openaldriver/RlOpenALDriver.vcproj
Log:
Windows compile fixes.

Modified: rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj
===================================================================
--- rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj	2007-03-08 15:54:08 UTC (rev 3157)
+++ rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj	2007-03-08 18:27:03 UTC (rev 3158)
@@ -255,7 +255,7 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\src\Fmod4Config.cpp"
+				RelativePath=".\src\Fmod4ConfigComponent.cpp"
 				>
 			</File>
 			<File
@@ -281,7 +281,7 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
-				RelativePath=".\include\Fmod4Config.h"
+				RelativePath=".\include\Fmod4ConfigComponent.h"
 				>
 			</File>
 			<File

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-08 15:54:08 UTC (rev 3157)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-08 18:27:03 UTC (rev 3158)
@@ -14,8 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "Fmod4ConfigComponent.h"
 #include "Fmod4Driver.h"
-#include "Fmod4ConfigComponent.h"
 #include "Fmod4Sound.h"
 #include "Fmod4Listener.h"
 #include "Logger.h"

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp	2007-03-08 15:54:08 UTC (rev 3157)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4DriverDllMain.cpp	2007-03-08 18:27:03 UTC (rev 3158)
@@ -16,7 +16,6 @@
 
 #include "Fmod4Driver.h"
 #include "SoundManager.h"
-#include "WindowFactory.h"
 
 namespace Ogre
 {

Modified: rl/trunk/plugins/openaldriver/RlOpenALDriver.vcproj
===================================================================
--- rl/trunk/plugins/openaldriver/RlOpenALDriver.vcproj	2007-03-08 15:54:08 UTC (rev 3157)
+++ rl/trunk/plugins/openaldriver/RlOpenALDriver.vcproj	2007-03-08 18:27:03 UTC (rev 3158)
@@ -240,7 +240,7 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\src\OpenALConfig.cpp"
+				RelativePath=".\src\OpenALConfigComponent.cpp"
 				>
 			</File>
 			<File
@@ -274,7 +274,7 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
-				RelativePath=".\include\OpenALConfig.h"
+				RelativePath=".\include\OpenALConfigComponent.h"
 				>
 			</File>
 			<File



From blakharaz at mail.berlios.de  Fri Mar  9 17:16:43 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 9 Mar 2007 17:16:43 +0100
Subject: [Dsa-hl-svn] r3159 - in rl/trunk/engine/rules: include src
Message-ID: <200703091616.l29GGhgV023900@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-09 17:16:41 +0100 (Fri, 09 Mar 2007)
New Revision: 3159

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
Log:
- Some #include cleanup
- fixes in tactical movement



Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-08 18:27:03 UTC (rev 3158)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-09 16:16:41 UTC (rev 3159)
@@ -19,19 +19,17 @@
 #include "RulesPrerequisites.h"
 
 #include "GameObject.h"
+#include "Effect.h"
 #include "Eigenschaft.h"
 #include "EigenschaftenStateSet.h"
 #include "TalentStateSet.h"
 #include "ZauberStateSet.h"
 #include "SonderfertigkeitenStateSet.h"
-#include "EffectManager.h"
 
-//#include "CompositeEffect.h"
-
 namespace rl
 {
     class Container;
-    class Effect;
+    class EffectManager;
     class Inventory;
     class Item;
     class Weapon;
@@ -638,7 +636,7 @@
              *  Gibt das Inventar der Kreatur zurueck.
              *  @return Liefert einen Zeiger auf Inventar der Kreatur
              **/
-            Inventory* getInventory();
+            Inventory* getInventory() const;
 
 
 
@@ -1009,7 +1007,7 @@
             int mMovementType;
 
             /// Verwaltet die Effekte die auf die Kreatur wirken.
-            EffectManager mEffectManager;
+            EffectManager* mEffectManager;
             /// Zeigt auf die gerade aktive Waffe.
             Weapon* mActiveWeapon;
             EigenschaftMap mEigenschaften;

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-08 18:27:03 UTC (rev 3158)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-09 16:16:41 UTC (rev 3159)
@@ -17,7 +17,8 @@
 
 #include "Actor.h"
 #include "Container.h"
-#include "DsaManager.h"
+#include "DsaManager.h"
+#include "EffectManager.h"
 #include "Eigenschaft.h"
 #include "Exception.h"
 #include "Inventory.h"
@@ -62,7 +63,8 @@
         mSleeping(0),
         mUnconscious(0),
         mMovementType(0)
-    {
+    {
+        mEffectManager = new EffectManager();
         mQueryFlags = QUERYFLAG_CREATURE;
 
 		//RlFail("Test");
@@ -97,9 +99,8 @@
 
 	Creature::~Creature()
     {
-		if (mInventory){
-			delete mInventory;
-		}
+        delete mInventory;
+	delete mEffectManager;
 
         for( WertMap::iterator it=mWerte.begin();it!=mWerte.end(); it++ )
             delete it->second;
@@ -615,7 +616,7 @@
 
     Effect::Status Creature::getStatus()
     {
-      return mEffectManager.getStatus();
+      return mEffectManager->getStatus();
     }
     
     bool Creature::isBlind()
@@ -898,7 +899,7 @@
     }
 
 	
-	Inventory* Creature::getInventory()
+	Inventory* Creature::getInventory() const
 	{
 		return mInventory;
 	}
@@ -1122,13 +1123,13 @@
 	void Creature::addEffect(Effect* effect)
 	{
 		effect->setOwner(this);
-		mEffectManager.addEffect(effect);
+		mEffectManager->addEffect(effect);
 	}
 
 	void Creature::checkEffects()
 	{
 		/// @todo Nur einmal pro Aktion ausfuehren
-		mEffectManager.checkEffects();
+		mEffectManager->checkEffects();
 	}
 
     void Creature::setProperty(const Ogre::String &key, const rl::Property &value)
@@ -1445,13 +1446,13 @@
 
 
 
-    float Creature::doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis, int modifikatoren)
+    float Creature::doTaktischeBewegung(int movementType, Ogre::Real time, int& patzer, int probenErschwernis, int modifikatoren)
     {
         // damit bei einem Sprint immer nur eine Probe gemacht wird!
-        static float lastProbeTaW = 0;
-        static int lastProbeTime = 0;
+        static int lastProbeTaW = 0;
+        static Ogre::Real lastProbeTime = 0;
         static int lastMovementType = 0;
-        lastProbeTaW -= time;
+        lastProbeTime -= time;
         bool movementTypeChanged = false;
         if( movementType != lastMovementType ) // das System l?sst sich durch Zwischendurch nicht rennen austricksen!!!!
             movementTypeChanged = true;
@@ -1590,7 +1591,7 @@
             {
                 if( lastProbeTime <= 0 || movementTypeChanged)
                 {
-                    lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
+                	int lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
                     patzer = lastProbeTaW;
                     lastProbeTime = getAuMax();
                 }
@@ -1630,7 +1631,7 @@
                 if( lastProbeTime <= 0 || movementTypeChanged )
                 {
                     lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
-                    patzer = lastProbeTime;
+                    patzer = lastProbeTaW;
                     lastProbeTime = Date::ONE_SPIELRUNDE;
                 }
                 else



From blakharaz at mail.berlios.de  Sat Mar 10 22:37:12 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 10 Mar 2007 22:37:12 +0100
Subject: [Dsa-hl-svn] r3160 - in rl/trunk/engine: common/include
	core/include core/src dialog/include dialog/src rules/include
	script/swig ui ui/include ui/src
Message-ID: <200703102137.l2ALbCej015862@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-10 22:36:02 +0100 (Sat, 10 Mar 2007)
New Revision: 3160

Added:
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/src/AbstractWindow.cpp
Removed:
   rl/trunk/engine/ui/include/CeGuiWindow.h
   rl/trunk/engine/ui/src/CeGuiWindow.cpp
Modified:
   rl/trunk/engine/common/include/ConfigFile.h
   rl/trunk/engine/common/include/FixRubyHeaders.h
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/common/include/RastullahPrerequisites.h
   rl/trunk/engine/common/include/XmlResourceManager.h
   rl/trunk/engine/core/include/MovableText.h
   rl/trunk/engine/core/include/Sound.h
   rl/trunk/engine/core/include/SoundResource.h
   rl/trunk/engine/core/src/ActorControlledObject.cpp
   rl/trunk/engine/core/src/AnimationManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/DebugVisualisable.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/core/src/MeshObject.cpp
   rl/trunk/engine/core/src/MovableText.cpp
   rl/trunk/engine/core/src/ParticleSystemObject.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/SoundResource.cpp
   rl/trunk/engine/core/src/World.cpp
   rl/trunk/engine/dialog/include/AimlParserImplRl.h
   rl/trunk/engine/dialog/include/DialogSubsystem.h
   rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
   rl/trunk/engine/rules/include/RulesPrerequisites.h
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/AboutWindow.h
   rl/trunk/engine/ui/include/ActionChoiceWindow.h
   rl/trunk/engine/ui/include/CharacterSheetWindow.h
   rl/trunk/engine/ui/include/CharacterStateWindow.h
   rl/trunk/engine/ui/include/CloseConfirmationWindow.h
   rl/trunk/engine/ui/include/CommandMapper.h
   rl/trunk/engine/ui/include/CommandMapperWindow.h
   rl/trunk/engine/ui/include/Console.h
   rl/trunk/engine/ui/include/DataLoadingProgressWindow.h
   rl/trunk/engine/ui/include/DebugWindow.h
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/GameLoggerWindow.h
   rl/trunk/engine/ui/include/GameSettings.h
   rl/trunk/engine/ui/include/InGameMenuWindow.h
   rl/trunk/engine/ui/include/InfoPopup.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/JournalWindow.h
   rl/trunk/engine/ui/include/LogWindow.h
   rl/trunk/engine/ui/include/MainMenuEngineWindow.h
   rl/trunk/engine/ui/include/MainMenuWindow.h
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/include/MessageWindow.h
   rl/trunk/engine/ui/include/ObjectDescriptionWindow.h
   rl/trunk/engine/ui/include/PlaylistWindow.h
   rl/trunk/engine/ui/include/SoundConfig.h
   rl/trunk/engine/ui/include/SubtitleWindow.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/include/WindowFadeJob.h
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/AboutWindow.cpp
   rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/CharacterStateWindow.cpp
   rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
   rl/trunk/engine/ui/src/CommandMapper.cpp
   rl/trunk/engine/ui/src/CommandMapperWindow.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/DataLoadingProgressWindow.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/GameLoggerWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/InGameMenuWindow.cpp
   rl/trunk/engine/ui/src/InfoPopup.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/JournalWindow.cpp
   rl/trunk/engine/ui/src/LogWindow.cpp
   rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
   rl/trunk/engine/ui/src/MainMenuWindow.cpp
   rl/trunk/engine/ui/src/Makefile.am
   rl/trunk/engine/ui/src/MessageWindow.cpp
   rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
   rl/trunk/engine/ui/src/PlaylistWindow.cpp
   rl/trunk/engine/ui/src/SoundConfig.cpp
   rl/trunk/engine/ui/src/SubtitleWindow.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Some cleanup

* clean Ogre imports
  - remove #include Ogre.h, add precise #includes
* rename CeGuiWindow to AbstractWindow 
  - removes issue with similar CeGuiWindow.h/CEGUIWindow.h files
* removed some warnings

Modified: rl/trunk/engine/common/include/ConfigFile.h
===================================================================
--- rl/trunk/engine/common/include/ConfigFile.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/common/include/ConfigFile.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,6 +18,7 @@
 #define CONFIGFILE_H_
 
 #include "CommonPrerequisites.h"
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 
 namespace rl

Modified: rl/trunk/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/trunk/engine/common/include/FixRubyHeaders.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/common/include/FixRubyHeaders.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -37,3 +37,5 @@
     #undef PACKAGE_NAME
     #undef PACKAGE_TARNAME
 #endif
+#undef max
+#undef min
\ No newline at end of file

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/common/include/Property.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,6 +19,7 @@
 #include "CommonPrerequisites.h"
 
 #include <boost/any.hpp>
+#include <OgreSharedPtr.h>
 
 #include "Exception.h"
 #include "Tripel.h"

Modified: rl/trunk/engine/common/include/RastullahPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/RastullahPrerequisites.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/common/include/RastullahPrerequisites.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,8 +18,14 @@
 #define __RastullahPrerequisites_H__
 
 #define OGRE_MEMORY_STRESS_TEST 1
-#include <Ogre.h>
 
+#undef max
+#undef min
+
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreVector3.h>
+
 #if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
 #   define _snprintf snprintf
 template<class T1, class T2>

Modified: rl/trunk/engine/common/include/XmlResourceManager.h
===================================================================
--- rl/trunk/engine/common/include/XmlResourceManager.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/common/include/XmlResourceManager.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,9 +19,10 @@
 
 #include "XmlResource.h"
 #include "CommonPrerequisites.h"
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
 
 
-
 namespace rl {
 
 	class _RlCommonExport XmlResourceManager : 

Modified: rl/trunk/engine/core/include/MovableText.h
===================================================================
--- rl/trunk/engine/core/include/MovableText.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/include/MovableText.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -1,5 +1,5 @@
 //-----------------------------------------------------------
-//Copyright ? 2003 by cTh
+//Copyright ??? 2003 by cTh
 //Use as you see fit.
 //Questions : gavocanov at rambler.ru
 //-----------------------------------------------------------
@@ -10,6 +10,9 @@
 
 #include "CorePrerequisites.h"
 
+#include <OgreMovableObject.h>
+#include <OgreRenderable.h>
+
 namespace rl
 {
     /************************************************************************/

Modified: rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/include/Sound.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,11 +18,12 @@
 #define __Sound_H__
 
 #include "CorePrerequisites.h"
-#include "Exception.h"
 #include <set>
+#include <OgreMovableObject.h>
 #include <OgreVector3.h>
 #include <OgreQuaternion.h>
 
+#include "Exception.h"
 #include "EventCaster.h"
 #include "SoundEvents.h"
 #include "SoundResource.h"

Modified: rl/trunk/engine/core/include/SoundResource.h
===================================================================
--- rl/trunk/engine/core/include/SoundResource.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/include/SoundResource.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,8 +18,9 @@
 #define SOUNDRESOURCE_H
 
 #include "CorePrerequisites.h"
+#include <OgreDataStream.h> 
 #include <OgreResource.h>
-#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
 
 namespace rl {
  
@@ -46,7 +47,7 @@
             Ogre::ManualResourceLoader* loader);
         /// Der Destruktor
         virtual ~SoundResource();
-        /// Den Datenstrom zur?ckgeben
+        /// Den Datenstrom zur???ckgeben
         const Ogre::DataStreamPtr &getDataStream() const;
         /// Groesse zurueckgeben.
         int getSize() const;

Modified: rl/trunk/engine/core/src/ActorControlledObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorControlledObject.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/ActorControlledObject.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -15,6 +15,9 @@
 */
 
 #include "ActorControlledObject.h"
+
+#include <OgreSceneNode.h>
+
 #include "Actor.h"
 
 using namespace Ogre;

Modified: rl/trunk/engine/core/src/AnimationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationManager.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/AnimationManager.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,6 +16,8 @@
 
 #include "AnimationManager.h"
 
+#include <OgreAnimationState.h>
+
 #include "Exception.h"
 #include "Actor.h"
 #include "MeshAnimation.h"
@@ -223,7 +225,7 @@
     {
         BaseAnimation* anim = iter->second;
 
-        // Nicht l?schen, wird noch benutzt
+        // Nicht l???schen, wird noch benutzt
         if( isStillInUse( anim ) )
             return;
 

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -287,7 +287,7 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
-        for (int i = 0; i < modulesList.size(); i++)
+        for (size_t i = 0; i < modulesList.size(); i++)
         {
             mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
 

Modified: rl/trunk/engine/core/src/DebugVisualisable.cpp
===================================================================
--- rl/trunk/engine/core/src/DebugVisualisable.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/DebugVisualisable.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -15,9 +15,12 @@
 */
 
 #include "DebugVisualisable.h"
+
+#include <OgreSceneNode.h>
+
+#include "CoreSubsystem.h"
 #include "DebugVisualsManager.h"
 #include "PrimitiveObject.h"
-#include "CoreSubsystem.h"
 #include "World.h"
 
 using namespace Ogre;

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,10 +13,11 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "GameLoop.h"
 
 #include <OgreRoot.h>
+#include <OgreWindowEventUtilities.h>
 
-#include "GameLoop.h"
 #include "GameTask.h"
 #include "CoreSubsystem.h"
 #include "FixRubyHeaders.h"

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,19 +13,22 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "MeshObject.h"
 
-#include "Exception.h"
-#include "MeshObject.h"
+#include <OgreAnimationState.h>
+#include <OgreMaterialManager.h>
+#include <OgreMeshManager.h>
+#include <OgreSubEntity.h>
+#include <OgreSubMesh.h>
+
 #include "Actor.h"
+#include "AnimationManager.h"
 #include "CoreSubsystem.h"
+#include "MeshAnimation.h"
+#include "Exception.h"
 #include "World.h"
 
-#include "MeshAnimation.h"
-#include "AnimationManager.h"
 
-#include <OgreMeshManager.h>
-#include <OgreAnimationState.h>
-
 using namespace Ogre;
 
 namespace rl {
@@ -327,7 +330,7 @@
             if( subent == NULL )
                 continue;
 
-            // TODO - optimieren, nur wenn der Typ ver?ndert wird
+            // TODO - optimieren, nur wenn der Typ ver???ndert wird
             //if(StringUtil::endsWith(subent->getMaterialName(),nameExtension)
             // == highlight )
             //  continue;  

Modified: rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/MovableText.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -1,5 +1,5 @@
 //-----------------------------------------------------------
-//Copyright ? 2003 by cTh
+//Copyright ??? 2003 by cTh
 //Use as you see fit.
 //Questions : gavocanov at rambler.ru
 //-----------------------------------------------------------
@@ -8,8 +8,14 @@
 #include "MovableText.h"
 #include "Exception.h"
 
+#include <OgreCamera.h>
 #include <OgreFontManager.h>
+#include <OgreHardwareBufferManager.h>
+#include <OgreMaterialManager.h>
+#include <OgreNode.h>
+#include <OgreRoot.h>
 
+
 using namespace Ogre;
 namespace rl {
 

Modified: rl/trunk/engine/core/src/ParticleSystemObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ParticleSystemObject.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/ParticleSystemObject.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -15,11 +15,14 @@
 */
 
 #include "ParticleSystemObject.h"
+
+#include <OgreMeshManager.h>
+#include <OgreParticleEmitter.h>
+
 #include "Actor.h"
 #include "CoreSubsystem.h"
 #include "World.h"
 
-#include <OgreMeshManager.h>
 
 using namespace Ogre;
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -15,12 +15,15 @@
  */
 
 #include "PhysicalThing.h"
-#include "OgreLogManager.h"
-#include "MeshObject.h"
+
+
+#include <OgreSceneNode.h>
+
 #include "Actor.h"
 #include "Exception.h"
+#include "MathUtil.h"
+#include "MeshObject.h"
 #include "PhysicalObject.h"
-#include "MathUtil.h"
 
 using namespace Ogre;
 using namespace OgreNewt;

Modified: rl/trunk/engine/core/src/SoundResource.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundResource.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/SoundResource.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,6 +16,8 @@
 
 #include "SoundResource.h"
 
+#include <OgreResourceGroupManager.h>
+
 using namespace Ogre;
 
 namespace rl {

Modified: rl/trunk/engine/core/src/World.cpp
===================================================================
--- rl/trunk/engine/core/src/World.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/core/src/World.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,10 +13,11 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "World.h"
 
+#include <OgreRoot.h>
 #include <OgreSceneManager.h>
 
-#include "World.h"
 #include "Exception.h"
 
 using namespace Ogre;

Modified: rl/trunk/engine/dialog/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,6 +19,8 @@
 #include "DialogPrerequisites.h"
 #include "XmlMapper/XmlParser.h"
 
+#include <OgreResource.h>
+
 using namespace XmlMapper;
 
 namespace rl

Modified: rl/trunk/engine/dialog/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,11 +16,12 @@
 #ifndef __DialogSubsystem_H__
 #define __DialogSubsystem_H__
 
+#include "DialogPrerequisites.h"
+
+#include <OgreResource.h>
 #include <OgreSingleton.h>
 
-#include "CommonPrerequisites.h"
-#include "DialogPrerequisites.h"
-//#include "AimlCoreComponent.h"
+//#include "CommonPrerequisites.h"
 
 namespace MadaBot
 {

Modified: rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -103,4 +103,4 @@
 {
 }
 
-}
\ No newline at end of file
+}

Modified: rl/trunk/engine/rules/include/RulesPrerequisites.h
===================================================================
--- rl/trunk/engine/rules/include/RulesPrerequisites.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/rules/include/RulesPrerequisites.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -30,13 +30,8 @@
 #   define _RlRulesExport
 #endif
 
-#include <map>
 #include <vector>
 
-#define _t(T) CeGuiString(T)
-
-#include <OgreLogManager.h>
-
 #undef min
 
 namespace rl

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-10 21:36:02 UTC (rev 3160)
@@ -45,6 +45,8 @@
 
 #include "FixRubyHeaders.h"
 
+#include <CEGUIExceptions.h>
+
 %}
 
 // Header includes

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-03-10 21:36:02 UTC (rev 3160)
@@ -413,7 +413,7 @@
 					>
 				</File>
 				<File
-					RelativePath=".\include\CeGuiWindow.h"
+					RelativePath=".\include\AbstractWindow.h"
 					>
 				</File>
 				<File
@@ -586,7 +586,7 @@
 					>
 				</File>
 				<File
-					RelativePath=".\src\CeGuiWindow.cpp"
+					RelativePath=".\src\AbstractWindow.cpp"
 					>
 				</File>
 				<File

Modified: rl/trunk/engine/ui/include/AboutWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AboutWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/AboutWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,12 +18,12 @@
 #define __AboutWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 	
 	class _RlUiExport AboutWindow :
-		public CeGuiWindow
+		public AbstractWindow
 	{
 	public:
 		AboutWindow();

Copied: rl/trunk/engine/ui/include/AbstractWindow.h (from rev 3159, rl/trunk/engine/ui/include/CeGuiWindow.h)
===================================================================
--- rl/trunk/engine/ui/include/CeGuiWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -0,0 +1,123 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __AbstractWindow_H__
+#define __AbstractWindow_H__
+
+#include "UiPrerequisites.h"
+
+
+#include <CEGUIWindow.h>
+#include <elements/CEGUIEditbox.h>
+#include <elements/CEGUIListbox.h>
+#include <elements/CEGUIMultiColumnList.h>
+#include <elements/CEGUIMultiLineEditbox.h>
+#include <elements/CEGUIProgressBar.h>
+#include <elements/CEGUIMenuBase.h>
+#include <elements/CEGUIMenuItem.h>
+#include <elements/CEGUIPushButton.h>
+#include <elements/CEGUICombobox.h>
+#include <elements/CEGUIComboDropList.h>
+#include <elements/CEGUIScrollablePane.h>
+#include <elements/CEGUISlider.h>
+#include <elements/CEGUITabControl.h>
+
+namespace rl {
+
+	class WindowUpdateTask;
+
+	class _RlUiExport AbstractWindow
+	{
+	public:
+
+		enum WindowType
+		{
+			WND_SHOW,
+			WND_MOUSE_INPUT,
+			WND_KEYBOARD_INPUT,
+			WND_ALL_INPUT,
+		};
+		virtual ~AbstractWindow();	
+
+		CEGUI::Window* getWindow();
+
+		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
+		CEGUI::Editbox* getEditbox(const char* name);
+		CEGUI::Listbox* getListbox(const char* name);
+		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
+		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
+		CEGUI::ProgressBar* getProgressBar(const char* name);
+		CEGUI::MenuBase* getMenu(const char* name);
+		CEGUI::MenuItem* getMenuItem(const char* name);
+		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::Combobox* getCombobox(const char* name);
+		CEGUI::ComboDropList* getComboDropList(const char* name);
+        CEGUI::ScrollablePane* getScrollablePane(const char* name);
+		CEGUI::Slider* getSlider(const char* name);
+		CEGUI::TabControl* getTabControl(const char* name);
+
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
+		static CEGUI::Window* getRoot();
+
+		WindowType getWindowType();
+
+        virtual bool isVisible();
+        virtual void setVisible(bool visible, bool destroyAfterHide = false);
+
+		bool isModal();
+		bool isClosingOnEscape();
+
+		const CeGuiString& getName() const;
+		const Ogre::Real& getNormalAlpha() const;
+
+		virtual void windowHid();
+
+	protected:
+		AbstractWindow(
+			const CeGuiString& xmlfile, 
+			WindowType type, 
+			bool closeOnEscape = true,
+			bool modal = false);
+
+		const CeGuiString& getNamePrefix() const;
+		
+		void centerWindow();
+		bool destroyWindow();
+
+		void bindClickToCloseWindow(CEGUI::Window* button);
+		void bindCloseToCloseButton();
+
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
+
+		CEGUI::Window* mWindow;
+		bool mVisible;
+
+	private:
+		
+		WindowType mWindowType;
+		CeGuiString mNamePrefix;
+		CeGuiString mName;
+		bool mModal;
+		bool mCloseOnEscape;
+		Ogre::Real mNormalAlpha;
+
+		static int sNumAbstractWindows;
+
+	};
+
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/ActionChoiceWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ActionChoiceWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/ActionChoiceWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,7 +19,7 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include <set>
 #include <vector>
 #include "Action.h"
@@ -30,7 +30,7 @@
 	class Person;
 	class ActionGroup;
 
-	class _RlUiExport ActionChoiceWindow : public CeGuiWindow
+	class _RlUiExport ActionChoiceWindow : public AbstractWindow
 	{
 	public:
 		ActionChoiceWindow(Person* actor);

Deleted: rl/trunk/engine/ui/include/CeGuiWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CeGuiWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CeGuiWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -1,111 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __CeGuiWindow_H__
-#define __CeGuiWindow_H__
-
-#include "UiPrerequisites.h"
-
-#include <OgreNoMemoryMacros.h>
-#include <CEGUI.h>
-#include <OgreMemoryMacros.h>
-
-namespace rl {
-
-	class WindowUpdateTask;
-
-	class _RlUiExport CeGuiWindow
-	{
-	public:
-
-		enum WindowType
-		{
-			WND_SHOW,
-			WND_MOUSE_INPUT,
-			WND_KEYBOARD_INPUT,
-			WND_ALL_INPUT,
-		};
-		virtual ~CeGuiWindow();	
-
-		CEGUI::Window* getWindow();
-
-		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
-		CEGUI::Editbox* getEditbox(const char* name);
-		CEGUI::Listbox* getListbox(const char* name);
-		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
-		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
-		CEGUI::ProgressBar* getProgressBar(const char* name);
-		CEGUI::MenuBase* getMenu(const char* name);
-		CEGUI::MenuItem* getMenuItem(const char* name);
-		CEGUI::PushButton* getPushButton(const char* name);
-		CEGUI::Combobox* getCombobox(const char* name);
-		CEGUI::ComboDropList* getComboDropList(const char* name);
-        CEGUI::ScrollablePane* getScrollablePane(const char* name);
-		CEGUI::Slider* getSlider(const char* name);
-		CEGUI::TabControl* getTabControl(const char* name);
-
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-		static CEGUI::Window* getRoot();
-
-		WindowType getWindowType();
-
-        virtual bool isVisible();
-        virtual void setVisible(bool visible, bool destroyAfterHide = false);
-
-		bool isModal();
-		bool isClosingOnEscape();
-
-		const CeGuiString& getName() const;
-		const Ogre::Real& getNormalAlpha() const;
-
-		virtual void windowHid();
-
-	protected:
-		CeGuiWindow(
-			const CeGuiString& xmlfile, 
-			WindowType type, 
-			bool closeOnEscape = true,
-			bool modal = false);
-
-		const CeGuiString& getNamePrefix() const;
-		
-		void centerWindow();
-		bool destroyWindow();
-
-		void bindClickToCloseWindow(CEGUI::Window* button);
-		void bindCloseToCloseButton();
-
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
-
-		CEGUI::Window* mWindow;
-		bool mVisible;
-
-	private:
-		
-		WindowType mWindowType;
-		CeGuiString mNamePrefix;
-		CeGuiString mName;
-		bool mModal;
-		bool mCloseOnEscape;
-		Ogre::Real mNormalAlpha;
-
-		static int sNumCeGuiWindows;
-
-	};
-
-}
-
-#endif

Modified: rl/trunk/engine/ui/include/CharacterSheetWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterSheetWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CharacterSheetWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,7 +19,7 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "Eigenschaft.h"
 #include "ObjectStateChangeListener.h"
 
@@ -28,7 +28,7 @@
 	class Person;
 	class ObjectStateChangeEvent;
 
-	class _RlUiExport CharacterSheetWindow : public CeGuiWindow, public ObjectStateChangeListener
+	class _RlUiExport CharacterSheetWindow : public AbstractWindow, public ObjectStateChangeListener
 	{
 	public:
 		CharacterSheetWindow();

Modified: rl/trunk/engine/ui/include/CharacterStateWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterStateWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CharacterStateWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,7 +19,7 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "Eigenschaft.h"
 #include "ObjectStateChangeEventSource.h"
 
@@ -27,7 +27,7 @@
 
 	class Creature;
 
-	class _RlUiExport CharacterStateWindow : public CeGuiWindow, public ObjectStateChangeListener
+	class _RlUiExport CharacterStateWindow : public AbstractWindow, public ObjectStateChangeListener
 	{
 	public:
 		CharacterStateWindow();

Modified: rl/trunk/engine/ui/include/CloseConfirmationWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CloseConfirmationWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CloseConfirmationWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,11 +18,11 @@
 #define __CloseConfirmationWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 
-	class _RlUiExport CloseConfirmationWindow : public CeGuiWindow
+	class _RlUiExport CloseConfirmationWindow : public AbstractWindow
 	{
 	public:
 		CloseConfirmationWindow();

Modified: rl/trunk/engine/ui/include/CommandMapper.h
===================================================================
--- rl/trunk/engine/ui/include/CommandMapper.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CommandMapper.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -20,6 +20,7 @@
 #include "UiPrerequisites.h"
 
 #include <map>
+#include <OgreCommon.h>
 
 namespace rl {
 

Modified: rl/trunk/engine/ui/include/CommandMapperWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CommandMapperWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/CommandMapperWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,7 +18,7 @@
 #define __CommandMapperWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 
@@ -26,7 +26,7 @@
 	class CommandMapper;
 
 	class CommandMapperInputWindow :
-		public CeGuiWindow
+		public AbstractWindow
 	{
 	public:
 		CommandMapperInputWindow();
@@ -35,7 +35,7 @@
 	};
 
 	class _RlUiExport CommandMapperWindow :
-		public CeGuiWindow
+		public AbstractWindow
 	{
 	public:
 		CommandMapperWindow(Creature* actionHolder, CommandMapper* commandMapper);

Modified: rl/trunk/engine/ui/include/Console.h
===================================================================
--- rl/trunk/engine/ui/include/Console.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/Console.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -22,7 +22,7 @@
 #include <vector>
 #include <string>
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 #include <OgreSingleton.h>
 
@@ -32,7 +32,7 @@
 
 	/** This is a Console System
 	 */
-	class _RlUiExport Console : public CeGuiWindow
+	class _RlUiExport Console : public AbstractWindow
 	{
 		public:
 			Console();

Modified: rl/trunk/engine/ui/include/DataLoadingProgressWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DataLoadingProgressWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/DataLoadingProgressWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,12 +18,12 @@
 #define __DataLoadingProgressWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "CoreEvents.h"
 
 namespace rl {
 
-	class _RlUiExport DataLoadingProgressWindow : public CeGuiWindow, public CoreEventListener
+	class _RlUiExport DataLoadingProgressWindow : public AbstractWindow, public CoreEventListener
 	{
 	public:
 		DataLoadingProgressWindow();

Modified: rl/trunk/engine/ui/include/DebugWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DebugWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/DebugWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -20,7 +20,7 @@
 #include "UiPrerequisites.h"
 #include <OgreSingleton.h>
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "GameTask.h"
 
 #include <map>
@@ -28,13 +28,11 @@
 namespace rl {
 
     class _RlUiExport DebugWindow
-		: public Ogre::Singleton<DebugWindow>, public GameTask, public CeGuiWindow
+		: public Ogre::Singleton<DebugWindow>, public GameTask, public AbstractWindow
     {
     public:
         DebugWindow(void);
         ~DebugWindow();
-        static DebugWindow& getSingleton(void);
-        static DebugWindow* getSingletonPtr(void);
 
 		void setVisible(bool visible, bool destroyAfterHide = false);
 

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -22,7 +22,7 @@
 #include <vector>
 #include <map>
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 
@@ -31,7 +31,7 @@
 	class DialogCharacterController;
 	class GameLoggerWindow;
 
-	class _RlUiExport DialogWindow : public CeGuiWindow
+	class _RlUiExport DialogWindow : public AbstractWindow
 	{
 	public:
 		DialogWindow(DialogCharacter* bot, GameLoggerWindow* gamelogger, DialogCharacterController* controller);

Modified: rl/trunk/engine/ui/include/GameLoggerWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameLoggerWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/GameLoggerWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,11 +19,11 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 
-	class _RlUiExport GameLoggerWindow : public CeGuiWindow
+	class _RlUiExport GameLoggerWindow : public AbstractWindow
 	{
 	public:
 		GameLoggerWindow();

Modified: rl/trunk/engine/ui/include/GameSettings.h
===================================================================
--- rl/trunk/engine/ui/include/GameSettings.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/GameSettings.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,13 +17,13 @@
 #ifndef GAMESETTINGS_H
 #define GAMESETTINGS_H
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "SoundDriverConfigComponent.h"
 #include "RenderSystemConfigComponent.h"
 
 namespace rl
 {
-	class GameSettings : CeGuiWindow
+	class GameSettings : AbstractWindow
 	{
 	public:
 		/**

Modified: rl/trunk/engine/ui/include/InGameMenuWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InGameMenuWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/InGameMenuWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,14 +17,14 @@
 #define __InGameMenuWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 	
 	class GameObject;
 	class Action;
 
-	class _RlUiExport InGameMenuWindow : public CeGuiWindow
+	class _RlUiExport InGameMenuWindow : public AbstractWindow
 	{
 	public:
 		InGameMenuWindow();

Modified: rl/trunk/engine/ui/include/InfoPopup.h
===================================================================
--- rl/trunk/engine/ui/include/InfoPopup.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/InfoPopup.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,12 +17,12 @@
 #include "UiPrerequisites.h"
 #include <vector>
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "QuestListener.h"
 
 namespace rl {
 
-    class _RlUiExport InfoPopup : public CeGuiWindow, public QuestListener
+    class _RlUiExport InfoPopup : public AbstractWindow, public QuestListener
     {
     public:
         InfoPopup();

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -28,17 +28,17 @@
 #include "FixRubyHeaders.h"
 #include "GameTask.h"
 
-#include <OgreNoMemoryMacros.h>
-#include <CEGUI.h>
-#include <OgreMemoryMacros.h>
+//#include <OgreNoMemoryMacros.h>
+//#include <CEGUI.h>
+//#include <OgreMemoryMacros.h>
 
-namespace CEGUI {
-    enum MouseButton;
-}
+//namespace CEGUI {
+//    enum MouseButton;
+//}
 
 namespace rl {
 
-    class CeGuiWindow;
+    class AbstractWindow;
     class GameObject;
     class CharacterController;
     class CommandMapper;
@@ -64,8 +64,8 @@
 
         void run(Ogre::Real elapsedTime);
 
-        void registerCeGuiWindow(CeGuiWindow* window);
-        void unregisterCeGuiWindow(CeGuiWindow* window);
+        void registerAbstractWindow(AbstractWindow* window);
+        void unregisterAbstractWindow(AbstractWindow* window);
         bool isCeguiActive() const;
 
         virtual bool mousePressed(const OIS::MouseEvent & arg, OIS::MouseButtonID id);

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,7 +18,7 @@
 #define __InventoryWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "Inventory.h"
 #include "GameTask.h"
 
@@ -38,7 +38,7 @@
         virtual const Ogre::String& getName() const;
 	};
 
-	class _RlUiExport InventoryWindow : public CeGuiWindow
+	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
 		InventoryWindow();

Modified: rl/trunk/engine/ui/include/JournalWindow.h
===================================================================
--- rl/trunk/engine/ui/include/JournalWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/JournalWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,12 +19,12 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "QuestListener.h"
 
 namespace rl {
 
-    class JournalWindow : public CeGuiWindow, public QuestListener {
+    class JournalWindow : public AbstractWindow, public QuestListener {
     public:
         JournalWindow();
         virtual ~JournalWindow();

Modified: rl/trunk/engine/ui/include/LogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/LogWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/LogWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,12 +18,12 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl
 {
 
-	class _RlUiExport LogWindow : public CeGuiWindow
+	class _RlUiExport LogWindow : public AbstractWindow
 	{
 	public:
 		LogWindow();

Modified: rl/trunk/engine/ui/include/MainMenuEngineWindow.h
===================================================================
--- rl/trunk/engine/ui/include/MainMenuEngineWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/MainMenuEngineWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,13 +17,13 @@
 #define __MainMenuEngineWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 	
 	class ContentModule;
 
-	class _RlUiExport MainMenuEngineWindow : public CeGuiWindow
+	class _RlUiExport MainMenuEngineWindow : public AbstractWindow
 	{
 	public:
 		MainMenuEngineWindow();

Modified: rl/trunk/engine/ui/include/MainMenuWindow.h
===================================================================
--- rl/trunk/engine/ui/include/MainMenuWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/MainMenuWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,7 +17,7 @@
 #define __MainMenuWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include <elements/CEGUIMenuItem.h>
 
 namespace rl {
@@ -25,7 +25,7 @@
 	class ContentModule;
 	class MainMenuEngineWindow;
 
-	class _RlUiExport MainMenuWindow : public CeGuiWindow
+	class _RlUiExport MainMenuWindow : public AbstractWindow
 	{
 	public:
 		MainMenuWindow(MainMenuEngineWindow* enginewindow);

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-03-10 21:36:02 UTC (rev 3160)
@@ -1,7 +1,7 @@
 noinst_HEADERS = \
 	AboutWindow.h \
 	ActionChoiceWindow.h \
-	CeGuiWindow.h \
+	AbstractWindow.h \
 	CharacterController.h \
 	CharacterSheetWindow.h \
 	CharacterStateWindow.h \

Modified: rl/trunk/engine/ui/include/MessageWindow.h
===================================================================
--- rl/trunk/engine/ui/include/MessageWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/MessageWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,12 +18,12 @@
 #define __MessageWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 	
 	class _RlUiExport MessageWindow :
-		public CeGuiWindow
+		public AbstractWindow
 	{
 	public:
 		MessageWindow();

Modified: rl/trunk/engine/ui/include/ObjectDescriptionWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ObjectDescriptionWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/ObjectDescriptionWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,13 +18,13 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl
 {
 	class GameObject;
 
-	class _RlUiExport ObjectDescriptionWindow : public CeGuiWindow
+	class _RlUiExport ObjectDescriptionWindow : public AbstractWindow
 	{
 	public:
 		ObjectDescriptionWindow();

Modified: rl/trunk/engine/ui/include/PlaylistWindow.h
===================================================================
--- rl/trunk/engine/ui/include/PlaylistWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/PlaylistWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,13 +19,13 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 
 	class Person;
 
-	class _RlUiExport PlaylistWindow : public CeGuiWindow
+	class _RlUiExport PlaylistWindow : public AbstractWindow
 	{
 	public:
 		PlaylistWindow();

Modified: rl/trunk/engine/ui/include/SoundConfig.h
===================================================================
--- rl/trunk/engine/ui/include/SoundConfig.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/SoundConfig.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -17,14 +17,14 @@
 #ifndef SOUNDCONFIG_H_
 #define SOUNDCONFIG_H_
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl
 {
 
 	class SoundDriverConfigComponent;
 
-	class SoundConfig : public rl::CeGuiWindow
+	class SoundConfig : public rl::AbstractWindow
 	{
 	public:
 		SoundConfig();

Modified: rl/trunk/engine/ui/include/SubtitleWindow.h
===================================================================
--- rl/trunk/engine/ui/include/SubtitleWindow.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/SubtitleWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -18,13 +18,13 @@
 
 #include "UiPrerequisites.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl
 {
 	class GameObject;
 
-	class _RlUiExport SubtitleWindow : public CeGuiWindow
+	class _RlUiExport SubtitleWindow : public AbstractWindow
 	{
 	public:
 		SubtitleWindow();

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -32,7 +32,7 @@
 namespace rl {
 
 	class Actor;
-	class CeGuiWindow;
+	class AbstractWindow;
 	class CharacterStateWindow;
 	class CharacterSheetWindow;
 	class Console;

Modified: rl/trunk/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFadeJob.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/WindowFadeJob.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -24,21 +24,21 @@
 
 namespace rl {
 
-    class CeGuiWindow;
+    class AbstractWindow;
 
     class WindowFadeJob : public Job
     {
     public:
         typedef enum {FADE_IN, FADE_OUT, FADE_OUT_AND_DESTROY} Mode;
 
-        WindowFadeJob(CeGuiWindow* window, Mode mode,
+        WindowFadeJob(AbstractWindow* window, Mode mode,
             Ogre::Real targetAlpha, Ogre::Real changeRate = 4.0f);
 
         virtual bool execute(Ogre::Real time);
         virtual void discard();
 
     protected:
-        CeGuiWindow* mWindow;
+        AbstractWindow* mWindow;
         Mode mMode;
         Ogre::Real mChangeRate;
         Ogre::Real mCurrentAlpha;

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/include/WindowManager.h	2007-03-10 21:36:02 UTC (rev 3160)
@@ -25,13 +25,12 @@
 #include <ruby.h>
 #include "FixRubyHeaders.h"
 #include <OgreMemoryMacros.h>
-#undef min
 
 #include <CEGUIVector.h>
 
 namespace rl {
 
-	class CeGuiWindow;
+	class AbstractWindow;
 	class WindowUpdater;
 
 	class _RlUiExport WindowManager : public Ogre::Singleton<WindowManager>
@@ -43,14 +42,14 @@
 		static WindowManager& getSingleton();
 		static WindowManager* getSingletonPtr();
 
-		void registerWindow(CeGuiWindow* window);
-		void destroyWindow(CeGuiWindow* window);
+		void registerWindow(AbstractWindow* window);
+		void destroyWindow(AbstractWindow* window);
 		void closeTopWindow();
-		bool handleMovedToFront(CeGuiWindow* window);
-		bool handleMovedToBack(CeGuiWindow* window);
+		bool handleMovedToFront(AbstractWindow* window);
+		bool handleMovedToBack(AbstractWindow* window);
 
 	private:
-		std::list<CeGuiWindow*> mWindowList;
+		std::list<AbstractWindow*> mWindowList;
 	};
 }
 

Modified: rl/trunk/engine/ui/src/AboutWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AboutWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/AboutWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -22,7 +22,7 @@
 namespace rl {
 
 AboutWindow::AboutWindow() :
-    CeGuiWindow("aboutwindow.xml", WND_MOUSE_INPUT)
+    AbstractWindow("aboutwindow.xml", WND_MOUSE_INPUT)
 {
     getWindow("AboutWindow/Text")->setText("Rastullahs Lockenpracht\n\nCopyright 2003-2007 Team Pantheon\
 \n\nBenutzte Bibliotheken: Ogre, fmod, Newton, boost, ...");

Copied: rl/trunk/engine/ui/src/AbstractWindow.cpp (from rev 3159, rl/trunk/engine/ui/src/CeGuiWindow.cpp)
===================================================================
--- rl/trunk/engine/ui/src/CeGuiWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -0,0 +1,297 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIFrameWindow.h>
+
+#include "UiPrerequisites.h"
+#include "Exception.h"
+
+#include "UiSubsystem.h"
+#include "AbstractWindow.h"
+#include "CeGuiHelper.h"
+#include "InputManager.h"
+#include "WindowManager.h"
+#include "WindowFadeJob.h"
+#include "JobScheduler.h"
+
+using namespace std;
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+
+	int AbstractWindow::sNumAbstractWindows = 0;
+
+	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, WindowType type, bool closeOnEscape, bool modal)
+	: mVisible(false),
+		mModal(modal),
+		mWindowType(type),
+		mCloseOnEscape(closeOnEscape)
+	{
+        LOG_MESSAGE(Logger::UI, 
+		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
+   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
+		if (mWindow == NULL)
+		{
+			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
+		}
+		
+		getRoot()->addChildWindow(mWindow);
+
+        if (modal)
+		{
+			mWindow->setModalState(true);
+			mWindow->setAlwaysOnTop(true);
+            mWindow->moveToFront();
+            mWindow->show();
+		}
+        else
+        {
+       		mWindow->hide();
+        }
+
+		mNormalAlpha = mWindow->getAlpha();
+		mName = mWindow->getName();
+		WindowManager::getSingleton().registerWindow(this);
+		mWindow->subscribeEvent(Window::EventActivated, 
+			boost::bind(
+				&rl::WindowManager::handleMovedToFront,
+				rl::WindowManager::getSingletonPtr(),
+				this));
+	}
+
+	AbstractWindow::~AbstractWindow()
+	{
+	}
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
+	{
+		CeGuiString prefix = "";
+		return loadWindow(xmlfile, prefix);
+	}
+
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)    
+	{
+		CeGuiString namePrefix;
+		if (prefix == "")
+			prefix.assign(StringConverter::toString(sNumAbstractWindows));
+		sNumAbstractWindows++;
+
+		CEGUI::Window* window = NULL;		
+		try 
+		{
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, 
+				prefix);
+		}
+		catch(...)
+		{
+		}
+
+		return window;
+	}
+
+	bool AbstractWindow::isVisible()
+	{
+		return mVisible;
+	}
+
+	void AbstractWindow::setVisible(bool visible, bool destroy)
+	{
+		if(mVisible != visible)
+		{
+			if (visible)
+			{
+				InputManager::getSingleton().registerAbstractWindow(this);
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
+			}
+			else
+			{
+				InputManager::getSingleton().unregisterAbstractWindow(this);
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
+			}
+            mVisible = visible;
+		}
+	}
+
+	const Ogre::Real& AbstractWindow::getNormalAlpha() const
+	{
+		return mNormalAlpha;
+	}
+
+	bool AbstractWindow::isModal()
+	{
+		return mModal;
+	}
+
+	bool AbstractWindow::isClosingOnEscape()
+	{
+		return mCloseOnEscape;
+	}
+
+	AbstractWindow::WindowType AbstractWindow::getWindowType()
+	{
+		return mWindowType;
+	}
+
+	CEGUI::Window* AbstractWindow::getRoot()
+	{
+		return CEGUI::WindowManager::getSingleton().getWindow(
+			(utf8*)UiSubsystem::CEGUI_ROOT);
+	}
+
+	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
+	{
+		CEGUI::Window* wnd = 
+			CEGUI::WindowManager::getSingleton().getWindow(
+				mNamePrefix + (utf8*)name);
+		
+		if (wnd == NULL)
+			Throw(
+				rl::NullPointerException, 
+				"Window " 
+				+ Ogre::String(name) 
+				+ " is NULL");
+
+		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
+			Throw(
+				rl::NullPointerException, 
+				"Window "
+				+ Ogre::String(name) 
+				+ " has not the required class " 
+				+ Ogre::String(requiredClass));
+
+		return wnd;
+	}
+
+	Editbox* AbstractWindow::getEditbox(const char* name)
+	{
+		return static_cast<Editbox*>(getWindow(name, "Editbox"));
+	}
+
+	Listbox* AbstractWindow::getListbox(const char* name)
+	{
+		return static_cast<Listbox*>(getWindow(name, "Listbox"));
+	}
+
+	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
+	{
+		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
+	}
+
+	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
+	{
+		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
+	}
+
+	ProgressBar* AbstractWindow::getProgressBar(const char* name)
+	{
+		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
+	}
+
+	MenuBase* AbstractWindow::getMenu(const char* name)
+	{
+		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
+	}
+
+	MenuItem* AbstractWindow::getMenuItem(const char* name)
+	{
+		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
+	}
+
+	PushButton* AbstractWindow::getPushButton(const char* name)
+	{
+		return static_cast<PushButton*>(getWindow(name, "PushButton"));
+	}
+
+	Combobox* AbstractWindow::getCombobox(const char* name)
+	{
+		return static_cast<Combobox*>(getWindow(name, "Combobox"));
+	}
+	
+	ComboDropList* AbstractWindow::getComboDropList(const char* name)
+	{
+		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
+	}
+
+    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
+    {
+		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
+    }
+
+	Slider* AbstractWindow::getSlider(const char* name)
+	{
+		return static_cast<Slider*>(getWindow(name, "Slider"));
+	}
+
+	TabControl* AbstractWindow::getTabControl(const char* name)
+	{
+		return static_cast<TabControl*>(getWindow(name, "TabControl"));
+	}
+
+	const CeGuiString& AbstractWindow::getName() const
+	{
+		return mName;
+	}
+
+	void AbstractWindow::centerWindow()
+	{
+		Size screenSize = System::getSingleton().getRenderer()->getSize();
+		Size windowSize = mWindow->getPixelSize();
+		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
+		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
+		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
+	}
+
+	void AbstractWindow::bindClickToCloseWindow(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+	void AbstractWindow::bindCloseToCloseButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+	bool AbstractWindow::destroyWindow()
+	{
+		setVisible(false, true);
+		return true;
+	}
+
+	CEGUI::Window* AbstractWindow::getWindow()
+	{
+		return mWindow;
+	}
+
+	const CeGuiString& AbstractWindow::getNamePrefix() const
+	{
+		return mNamePrefix;
+	}
+
+	void AbstractWindow::windowHid()
+	{
+	}
+
+}

Modified: rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,8 +13,9 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "ActionChoiceWindow.h"
 #include <boost/bind.hpp>
-#include "UiPrerequisites.h"
+#include <CEGUIWindowManager.h>
 
 #include <set>
 #include <algorithm>
@@ -26,7 +27,6 @@
 #include "UiSubsystem.h"
 #include "Exception.h"
 
-#include "ActionChoiceWindow.h"
 
 using namespace CEGUI;
 using namespace std;
@@ -38,7 +38,7 @@
 	const int MAX_NUM_SUBACTIONS = 7;
 
 	ActionChoiceWindow::ActionChoiceWindow(Person* actor)
-		:	CeGuiWindow("actionchoicewindow.xml", WND_MOUSE_INPUT),
+		:	AbstractWindow("actionchoicewindow.xml", WND_MOUSE_INPUT),
 			mActor(actor)
 	{
 		mHint = getWindow("ActionChoiceWindow/Hint");
@@ -85,7 +85,7 @@
 		}
 		mButtons.clear();
 		LOG_DEBUG2(Logger::UI, 
-			"Buttons gel?scht", "ActionChoiceWindow::showActionsOfObject");
+			"Buttons gel???scht", "ActionChoiceWindow::showActionsOfObject");
 
 		CEGUI::UVector2 center(cegui_reldim(0.5), cegui_reldim(0.5));
 		static float RADIUS = 0.10;
@@ -243,11 +243,11 @@
 
 	PushButton* ActionChoiceWindow::createButton(const CeGuiString& name, const CEGUI::UVector2& pos)
 	{
-		Window* button = CeGuiWindow::loadWindow("buttons/"+name+".xml");
+		Window* button = AbstractWindow::loadWindow("buttons/"+name+".xml");
 		if (button == NULL)
 		{
 			button = 
-				CeGuiWindow::loadWindow(
+				AbstractWindow::loadWindow(
 					"buttons/defaultbutton.xml");
 		}
 

Deleted: rl/trunk/engine/ui/src/CeGuiWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CeGuiWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CeGuiWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -1,295 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include <boost/bind.hpp>
-#include <CEGUIWindowManager.h>
-#include "UiPrerequisites.h"
-#include "Exception.h"
-
-#include "UiSubsystem.h"
-#include "CeGuiWindow.h"
-#include "CeGuiHelper.h"
-#include "InputManager.h"
-#include "WindowManager.h"
-#include "WindowFadeJob.h"
-#include "JobScheduler.h"
-
-using namespace std;
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-
-	int CeGuiWindow::sNumCeGuiWindows = 0;
-
-	CeGuiWindow::CeGuiWindow(const CeGuiString& xmlfile, WindowType type, bool closeOnEscape, bool modal)
-	: mVisible(false),
-		mModal(modal),
-		mWindowType(type),
-		mCloseOnEscape(closeOnEscape)
-	{
-        LOG_MESSAGE(Logger::UI, 
-		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
-   		mWindow = CeGuiWindow::loadWindow(xmlfile, mNamePrefix);
-		if (mWindow == NULL)
-		{
-			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
-		}
-		
-		getRoot()->addChildWindow(mWindow);
-
-        if (modal)
-		{
-			mWindow->setModalState(true);
-			mWindow->setAlwaysOnTop(true);
-            mWindow->moveToFront();
-            mWindow->show();
-		}
-        else
-        {
-       		mWindow->hide();
-        }
-
-		mNormalAlpha = mWindow->getAlpha();
-		mName = mWindow->getName();
-		WindowManager::getSingleton().registerWindow(this);
-		mWindow->subscribeEvent(Window::EventActivated, 
-			boost::bind(
-				&rl::WindowManager::handleMovedToFront,
-				rl::WindowManager::getSingletonPtr(),
-				this));
-	}
-
-	CeGuiWindow::~CeGuiWindow()
-	{
-	}
-
-	CEGUI::Window* CeGuiWindow::loadWindow(const CeGuiString& xmlfile)
-	{
-		CeGuiString prefix = "";
-		return loadWindow(xmlfile, prefix);
-	}
-
-
-	CEGUI::Window* CeGuiWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)    
-	{
-		CeGuiString namePrefix;
-		if (prefix == "")
-			prefix.assign(StringConverter::toString(sNumCeGuiWindows));
-		sNumCeGuiWindows++;
-
-		CEGUI::Window* window = NULL;		
-		try 
-		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, 
-				prefix);
-		}
-		catch(...)
-		{
-		}
-
-		return window;
-	}
-
-	bool CeGuiWindow::isVisible()
-	{
-		return mVisible;
-	}
-
-	void CeGuiWindow::setVisible(bool visible, bool destroy)
-	{
-		if(mVisible != visible)
-		{
-			if (visible)
-			{
-				InputManager::getSingleton().registerCeGuiWindow(this);
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
-			}
-			else
-			{
-				InputManager::getSingleton().unregisterCeGuiWindow(this);
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this,
-                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
-                    0.0f));
-			}
-            mVisible = visible;
-		}
-	}
-
-	const Ogre::Real& CeGuiWindow::getNormalAlpha() const
-	{
-		return mNormalAlpha;
-	}
-
-	bool CeGuiWindow::isModal()
-	{
-		return mModal;
-	}
-
-	bool CeGuiWindow::isClosingOnEscape()
-	{
-		return mCloseOnEscape;
-	}
-
-	CeGuiWindow::WindowType CeGuiWindow::getWindowType()
-	{
-		return mWindowType;
-	}
-
-	CEGUI::Window* CeGuiWindow::getRoot()
-	{
-		return CEGUI::WindowManager::getSingleton().getWindow(
-			(utf8*)UiSubsystem::CEGUI_ROOT);
-	}
-
-	Window* CeGuiWindow::getWindow(const char* name, const char* requiredClass)
-	{
-		CEGUI::Window* wnd = 
-			CEGUI::WindowManager::getSingleton().getWindow(
-				mNamePrefix + (utf8*)name);
-		
-		if (wnd == NULL)
-			Throw(
-				rl::NullPointerException, 
-				"Window " 
-				+ Ogre::String(name) 
-				+ " is NULL");
-
-		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
-			Throw(
-				rl::NullPointerException, 
-				"Window "
-				+ Ogre::String(name) 
-				+ " has not the required class " 
-				+ Ogre::String(requiredClass));
-
-		return wnd;
-	}
-
-	Editbox* CeGuiWindow::getEditbox(const char* name)
-	{
-		return static_cast<Editbox*>(getWindow(name, "Editbox"));
-	}
-
-	Listbox* CeGuiWindow::getListbox(const char* name)
-	{
-		return static_cast<Listbox*>(getWindow(name, "Listbox"));
-	}
-
-	MultiColumnList* CeGuiWindow::getMultiColumnList(const char* name)
-	{
-		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
-	}
-
-	MultiLineEditbox* CeGuiWindow::getMultiLineEditbox(const char* name)
-	{
-		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
-	}
-
-	ProgressBar* CeGuiWindow::getProgressBar(const char* name)
-	{
-		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
-	}
-
-	MenuBase* CeGuiWindow::getMenu(const char* name)
-	{
-		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
-	}
-
-	MenuItem* CeGuiWindow::getMenuItem(const char* name)
-	{
-		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
-	}
-
-	PushButton* CeGuiWindow::getPushButton(const char* name)
-	{
-		return static_cast<PushButton*>(getWindow(name, "PushButton"));
-	}
-
-	Combobox* CeGuiWindow::getCombobox(const char* name)
-	{
-		return static_cast<Combobox*>(getWindow(name, "Combobox"));
-	}
-	
-	ComboDropList* CeGuiWindow::getComboDropList(const char* name)
-	{
-		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
-	}
-
-    ScrollablePane* CeGuiWindow::getScrollablePane(const char* name)
-    {
-		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
-    }
-
-	Slider* CeGuiWindow::getSlider(const char* name)
-	{
-		return static_cast<Slider*>(getWindow(name, "Slider"));
-	}
-
-	TabControl* CeGuiWindow::getTabControl(const char* name)
-	{
-		return static_cast<TabControl*>(getWindow(name, "TabControl"));
-	}
-
-	const CeGuiString& CeGuiWindow::getName() const
-	{
-		return mName;
-	}
-
-	void CeGuiWindow::centerWindow()
-	{
-		Size screenSize = System::getSingleton().getRenderer()->getSize();
-		Size windowSize = mWindow->getPixelSize();
-		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
-		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
-		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
-	}
-
-	void CeGuiWindow::bindClickToCloseWindow(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&CeGuiWindow::destroyWindow, this));
-	}
-
-	void CeGuiWindow::bindCloseToCloseButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&CeGuiWindow::destroyWindow, this));
-	}
-
-	bool CeGuiWindow::destroyWindow()
-	{
-		setVisible(false, true);
-		return true;
-	}
-
-	CEGUI::Window* CeGuiWindow::getWindow()
-	{
-		return mWindow;
-	}
-
-	const CeGuiString& CeGuiWindow::getNamePrefix() const
-	{
-		return mNamePrefix;
-	}
-
-	void CeGuiWindow::windowHid()
-	{
-	}
-
-}

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,15 +13,17 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "CharacterSheetWindow.h"
+
 #include <boost/bind.hpp>
-#include "UiPrerequisites.h"
+#include <CEGUIPropertyHelper.h>
+#include <elements/CEGUIListboxTextItem.h>
 
 #include "DsaManager.h"
 #include "Person.h"
 #include "InputManager.h"
 #include "Talent.h"
 
-#include "CharacterSheetWindow.h"
 #include "ObjectStateChangeEvent.h"
 
 using namespace CEGUI;
@@ -31,7 +33,7 @@
 namespace rl {
 
 CharacterSheetWindow::CharacterSheetWindow()
-	: CeGuiWindow("charactersheet.xml", WND_MOUSE_INPUT)
+	: AbstractWindow("charactersheet.xml", WND_MOUSE_INPUT)
 {
 	mTalentTable = getMultiColumnList("CharacterSheet/TalentSheet/Table");
 	mTalentTable->addColumn((utf8*)"Talent", 0, cegui_reldim(0.5));

Modified: rl/trunk/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -30,7 +30,7 @@
 namespace rl {
 
 CharacterStateWindow::CharacterStateWindow()
-: CeGuiWindow("characterstatewindow.xml", WND_SHOW, false),
+: AbstractWindow("characterstatewindow.xml", WND_SHOW, false),
 	mCharacter(NULL)
 {
 	mLP = getProgressBar("CharacterStateWindow/LP");
@@ -102,7 +102,7 @@
 
 void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
 {
-	CeGuiWindow::setVisible(visible, destroyAfterHide);
+	AbstractWindow::setVisible(visible, destroyAfterHide);
 	if (visible) 
 	{
 		update();

Modified: rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -22,7 +22,7 @@
 namespace rl {
 
 CloseConfirmationWindow::CloseConfirmationWindow()
-: CeGuiWindow("closeconfirmationwindow.xml", CeGuiWindow::WND_ALL_INPUT, true, true)
+: AbstractWindow("closeconfirmationwindow.xml", AbstractWindow::WND_ALL_INPUT, true, true)
 {
 	getPushButton("CloseConfirmationWindow/YesButton")->subscribeEvent(
 		CEGUI::Window::EventMouseClick,

Modified: rl/trunk/engine/ui/src/CommandMapper.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapper.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CommandMapper.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -153,7 +153,7 @@
         mKeyCommandsGlobal[getKeyCode("O")] = CeGuiString("togglecharacterstatewindow");
         */
 
-        std::vector<Ogre::String> keys;
+        StringVector keys;
 
         // Extract global actions and movement actions from the list
         for (Ogre::NameValuePairList::const_iterator it = keylist.begin(); it != keylist.end(); it++)
@@ -164,7 +164,7 @@
             // We got a movement action
             if (it->first.find("mov_") != std::string::npos)
             {
-                for (int i = 0; i < keys.size(); i++)
+                for (size_t i = 0; i < keys.size(); i++)
                 {
                     mMovementCommands[InputManager::getSingleton().getScanCode(keys[i])] = getMovement(it->first);
                     LOG_MESSAGE(Logger::UI,
@@ -178,7 +178,7 @@
             // We got a global action
             if (it->first.find("act_") != std::string::npos)
             {
-                for (int i = 0; i < keys.size(); i++)
+                for (size_t i = 0; i < keys.size(); i++)
                 {
                     mKeyCommandsGlobal[getKeyCode(keys[i])] = CeGuiString(it->first);
                     LOG_MESSAGE(Logger::UI,

Modified: rl/trunk/engine/ui/src/CommandMapperWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapperWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/CommandMapperWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,14 +13,15 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+
+#include "CommandMapperWindow.h"
+
 #include <boost/bind.hpp>
+#include <elements/CEGUIListboxTextItem.h>
 
-#include "UiPrerequisites.h"
-
 #include "InputManager.h"
 #include "UiSubsystem.h"
 #include "CommandMapper.h"
-#include "CommandMapperWindow.h"
 
 #include "GameObject.h"
 #include "Creature.h"
@@ -32,7 +33,7 @@
 namespace rl {
 
 CommandMapperWindow::CommandMapperWindow(Creature* actionHolder, CommandMapper* commandMapper)
-	:	CeGuiWindow("commandmapper.xml", WND_ALL_INPUT),
+	:	AbstractWindow("commandmapper.xml", WND_ALL_INPUT),
 		mActionHolder(actionHolder),
 		mInputWindow(new CommandMapperInputWindow()),
 		mCommandMapper(commandMapper)
@@ -177,7 +178,7 @@
 }
 
 CommandMapperInputWindow::CommandMapperInputWindow() :
-	CeGuiWindow("commandmapperinput.xml", CeGuiWindow::WND_SHOW)
+	AbstractWindow("commandmapperinput.xml", AbstractWindow::WND_SHOW)
 {
 	setVisible(false);
 	mWindow->moveToFront();
@@ -186,7 +187,7 @@
 
 void CommandMapperInputWindow::setVisible(bool visible, bool destroyAfterHide)
 {
-	CeGuiWindow::setVisible(visible, destroyAfterHide);
+	AbstractWindow::setVisible(visible, destroyAfterHide);
 	if (visible)
 		mWindow->moveToFront();
 }
@@ -194,7 +195,7 @@
 void CommandMapperWindow::refreshContent()
 {
 	unsigned int row;
-	//// Alle m?glichen Bewegungen aus dem CommandMapper auslesen
+	//// Alle m???glichen Bewegungen aus dem CommandMapper auslesen
 	//row = 0;
 	//const std::map<CeGuiString, MovementState> movements = 
 	//	mCommandMapper->getMovements();

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/Console.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,24 +13,25 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "Console.h"
+
 #include <boost/bind.hpp>
-#include "UiPrerequisites.h"
+#include <elements/CEGUIFrameWindow.h>
 
 #include "RubyInterpreter.h"
 #include "ListboxWrappedTextItem.h"
 #include "CoreSubsystem.h"
-#include "Console.h"
 
 using namespace Ogre;
 
-using CEGUI::WindowManager; using CEGUI::utf8; using CEGUI::ListboxTextItem;
+using CEGUI::utf8; using CEGUI::ListboxTextItem;
 using CEGUI::KeyEventArgs; using CEGUI::Key; using CEGUI::colour;
 using CEGUI::ListboxWrappedTextItem; using CEGUI::TextFormatting;
 
 namespace rl 
 {
 	Console::Console() : 
-		CeGuiWindow("console.xml", WND_KEYBOARD_INPUT)
+		AbstractWindow("console.xml", WND_KEYBOARD_INPUT)
 	{
 		using namespace CEGUI;
 		
@@ -58,7 +59,7 @@
 			mCommandLine->activate();
 		}
 		
-		CeGuiWindow::setVisible(visible, destroy);
+		AbstractWindow::setVisible(visible, destroy);
 	}
 
 	bool Console::handleKeyDown(const CEGUI::EventArgs& e)

Modified: rl/trunk/engine/ui/src/DataLoadingProgressWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DataLoadingProgressWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/DataLoadingProgressWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -19,7 +19,7 @@
 namespace rl {
 
 DataLoadingProgressWindow::DataLoadingProgressWindow()
-: CeGuiWindow("dataloadingprogresswindow.xml", CeGuiWindow::WND_SHOW, false)
+: AbstractWindow("dataloadingprogresswindow.xml", AbstractWindow::WND_SHOW, false)
 {
 	mProgressBar = getProgressBar("DataLoadingProgressWindow/ProgressBar");
 	centerWindow();

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -35,16 +35,7 @@
 
 namespace rl
 {
-  DebugWindow& DebugWindow::getSingleton(void)
-    {
-        return Ogre::Singleton<DebugWindow>::getSingleton();
-    }
-    DebugWindow* DebugWindow::getSingletonPtr(void)
-    {
-        return Ogre::Singleton<DebugWindow>::getSingletonPtr();
-    }
-
-    DebugWindow::DebugWindow() : CeGuiWindow("debugwindow.xml", WND_SHOW),
+    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WND_SHOW),
           mMessageText(),
           mPageCaption(),
           mPageText(),
@@ -212,7 +203,7 @@
 
     void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
     {
-        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        AbstractWindow::setVisible(visible, destroyAfterHide);
         if (visible)
             GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
         else

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,10 +13,11 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "DialogWindow.h"
+
 #include <boost/bind.hpp>
+#include <elements/CEGUIFrameWindow.h>
 
-#include "DialogWindow.h"
-
 #include "Exception.h"
 #include "ConfigurationManager.h"
 #include "Creature.h"
@@ -45,7 +46,7 @@
 
 DialogWindow::DialogWindow(DialogCharacter* bot, GameLoggerWindow* gamelogger,
                            DialogCharacterController* controller)
-  : CeGuiWindow("dialogwindow.xml", WND_MOUSE_INPUT, false),
+  : AbstractWindow("dialogwindow.xml", WND_MOUSE_INPUT, false),
 	mBot(bot), 
 	mCurrentResponse(NULL),
     mCurrentResponseText(""),

Modified: rl/trunk/engine/ui/src/GameLoggerWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -27,7 +27,7 @@
 CEGUI::colour GameLoggerWindow::COLOR_MISC(      0xFFFFFFFF);
 
 GameLoggerWindow::GameLoggerWindow() : 
-	CeGuiWindow("gameloggerwindow.xml", WND_SHOW)
+	AbstractWindow("gameloggerwindow.xml", WND_SHOW)
 {
 	mLog = getListbox ("GameLogger/Log");
 	bindCloseToCloseButton();

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,18 +13,20 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "GameSettings.h"
 
 #include <boost/bind.hpp>
+#include <elements/CEGUIFrameWindow.h>
+#include <elements/CEGUIListboxTextItem.h>
 #include <iostream>
 
-#include "GameSettings.h"
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
 namespace rl
 {
     GameSettings::GameSettings()
-        : CeGuiWindow("gamesettings.xml", WND_MOUSE_INPUT)
+        : AbstractWindow("gamesettings.xml", WND_MOUSE_INPUT)
     {
         // Register sound driver components
         std::list<SoundDriver*> soundDriverList = SoundManager::getSingleton().getDriverList();
@@ -66,7 +68,7 @@
 
     void GameSettings::setVisible(bool visible, bool destroyAfterHide)
     {
-        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        AbstractWindow::setVisible(visible, destroyAfterHide);
     }
 
     void GameSettings::setConfigComponent(const CEGUI::String& drivername)

Modified: rl/trunk/engine/ui/src/InGameMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,16 +13,16 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "InGameMenuWindow.h"
+
 #include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIPopupMenu.h>
 
-#include "UiPrerequisites.h"
-
-#include "UiSubsystem.h"
-#include "CoreSubsystem.h"
-
-#include "InGameMenuWindow.h"
 #include "Action.h"
 #include "ActionManager.h"
+#include "CoreSubsystem.h"
+#include "UiSubsystem.h"
 
 #include <map>
 
@@ -33,7 +33,7 @@
 namespace rl {
 
 InGameMenuWindow::InGameMenuWindow()
-: CeGuiWindow("ingamemenuwindow.xml", WND_MOUSE_INPUT)
+: AbstractWindow("ingamemenuwindow.xml", WND_MOUSE_INPUT)
 {
 	update();
 }

Modified: rl/trunk/engine/ui/src/InfoPopup.cpp
===================================================================
--- rl/trunk/engine/ui/src/InfoPopup.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/InfoPopup.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -22,7 +22,7 @@
 namespace rl {
 
 	InfoPopup::InfoPopup()
-		: CeGuiWindow("infopopup.xml", CeGuiWindow::WND_SHOW, false)
+		: AbstractWindow("infopopup.xml", AbstractWindow::WND_SHOW, false)
 	{
 		mErrorIcon = getWindow("InfoPopup/ErrorIcon");
 		mQuestIcon = getWindow("InfoPopup/QuestIcon");
@@ -78,7 +78,7 @@
 
 	void InfoPopup::setVisible(bool visible, bool destroyAfterHide)
 	{
-        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        AbstractWindow::setVisible(visible, destroyAfterHide);
         ///@todo implement the following, when timed jobs are possible.
 		//if (visible && !isVisible())
 		//{

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -32,7 +32,7 @@
 #include "ActionManager.h"
 #include "Actor.h"
 #include "ActorManager.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "CharacterController.h"
 #include "CommandMapper.h"
 #include "Console.h"
@@ -400,22 +400,22 @@
         return rval;
     }
 
-    void InputManager::registerCeGuiWindow(CeGuiWindow* window)
+    void InputManager::registerAbstractWindow(AbstractWindow* window)
     {
-        if (window->getWindowType() == CeGuiWindow::WND_SHOW)
+        if (window->getWindowType() == AbstractWindow::WND_SHOW)
             return;
 
         bool active = isCeguiActive();
 
-        if (window->getWindowType() == CeGuiWindow::WND_MOUSE_INPUT)
+        if (window->getWindowType() == AbstractWindow::WND_MOUSE_INPUT)
         {
             mNumActiveWindowsMouseInput++;
         }
-        else if (window->getWindowType() == CeGuiWindow::WND_KEYBOARD_INPUT)
+        else if (window->getWindowType() == AbstractWindow::WND_KEYBOARD_INPUT)
         {
             mNumActiveWindowsKeyboardInput++;
         }
-        else if (window->getWindowType() == CeGuiWindow::WND_ALL_INPUT)
+        else if (window->getWindowType() == AbstractWindow::WND_ALL_INPUT)
         {
             mNumActiveWindowsAllInput++;
         }
@@ -429,24 +429,24 @@
         }
     }
 
-    void InputManager::unregisterCeGuiWindow(CeGuiWindow* window)
+    void InputManager::unregisterAbstractWindow(AbstractWindow* window)
     {
-        if (window->getWindowType() == CeGuiWindow::WND_SHOW)
+        if (window->getWindowType() == AbstractWindow::WND_SHOW)
         {
             return;
         }
 
         bool active = isCeguiActive();
 
-        if (window->getWindowType() == CeGuiWindow::WND_MOUSE_INPUT)
+        if (window->getWindowType() == AbstractWindow::WND_MOUSE_INPUT)
         {
             mNumActiveWindowsMouseInput--;
         }
-        else if (window->getWindowType() == CeGuiWindow::WND_KEYBOARD_INPUT)
+        else if (window->getWindowType() == AbstractWindow::WND_KEYBOARD_INPUT)
         {
             mNumActiveWindowsKeyboardInput--;
         }
-        else if (window->getWindowType() == CeGuiWindow::WND_ALL_INPUT)
+        else if (window->getWindowType() == AbstractWindow::WND_ALL_INPUT)
         {
             mNumActiveWindowsAllInput--;
         }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,11 +13,16 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "InventoryWindow.h"
 
 
 #include <boost/bind.hpp>
+#include <CEGUIImageset.h>
+#include <CEGUIImagesetManager.h>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIDragContainer.h>
+#include <elements/CEGUIFrameWindow.h>
 
-#include "InventoryWindow.h"
 
 #include "Actor.h"
 #include "ActorManager.h"
@@ -75,7 +80,7 @@
 	// ***************** Konstruktor *********************************
 	// ***************************************************************
 	InventoryWindow::InventoryWindow()
-		: CeGuiWindow("inventorywindow.xml", WND_MOUSE_INPUT),
+		: AbstractWindow("inventorywindow.xml", WND_MOUSE_INPUT),
 		mDescription(NULL),
 		mRenderItemEntity(NULL),
 		mRenderTexture(NULL),

Modified: rl/trunk/engine/ui/src/JournalWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/JournalWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/JournalWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,22 +13,23 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "JournalWindow.h"
 
 #include <boost/bind.hpp>
+#include <CEGUIPropertyHelper.h>
+#include <elements/CEGUIListboxTextItem.h>
 
-#include "JournalWindow.h"
 #include "RulesSubsystem.h"
 #include "Quest.h"
 #include "QuestBook.h"
 
-#include <CEGUIPropertyHelper.h>
 
 using namespace CEGUI;
 
 namespace rl {
 
     JournalWindow::JournalWindow()
-        : CeGuiWindow("journalwindow.xml", WND_MOUSE_INPUT),
+        : AbstractWindow("journalwindow.xml", WND_MOUSE_INPUT),
         mQuests(0),
         mQuestTitle(0),
         mQuestState(0),

Modified: rl/trunk/engine/ui/src/LogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/LogWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/LogWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -23,7 +23,7 @@
 namespace rl
 {
 	LogWindow::LogWindow()
-		: CeGuiWindow("logwindow.xml", WND_MOUSE_INPUT)
+		: AbstractWindow("logwindow.xml", WND_MOUSE_INPUT)
 	{
 		mRastullahLog = getMultiLineEditbox("LogWindow/RastullahLog/Text");
 		mOgreLog = getMultiLineEditbox("LogWindow/OgreLog/Text");
@@ -54,7 +54,7 @@
 	
 	void LogWindow::setVisible(bool visible, bool destroyAfterHide)
 	{
-		CeGuiWindow::setVisible(visible, destroyAfterHide);
+		AbstractWindow::setVisible(visible, destroyAfterHide);
 
 		if (visible)
 		{

Modified: rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -26,7 +26,7 @@
 namespace rl {
 
     MainMenuEngineWindow::MainMenuEngineWindow() :
-        CeGuiWindow("mainmenuenginewindow.xml", WND_SHOW, false)
+        AbstractWindow("mainmenuenginewindow.xml", WND_SHOW, false)
     {
         getWindow("MainMenu/EngineVersion")->setText(
             CoreSubsystem::getSingleton().getEngineVersionString()+

Modified: rl/trunk/engine/ui/src/MainMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,18 +13,17 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "MainMenuWindow.h"
+
 #include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
 
-#include "UiPrerequisites.h"
-
-#include "WindowFactory.h"
 #include "CoreSubsystem.h"
 #include "ConfigurationManager.h"
 #include "ContentModule.h"
-
 #include "MainMenuEngineWindow.h"
-#include "MainMenuWindow.h"
 #include "SoundConfig.h"
+#include "WindowFactory.h"
 
 using namespace CEGUI;
 using namespace Ogre;
@@ -32,7 +31,7 @@
 namespace rl {
 
 	MainMenuWindow::MainMenuWindow(MainMenuEngineWindow* enginewindow) :
-		CeGuiWindow("mainmenuwindow.xml", WND_MOUSE_INPUT, false, false),
+		AbstractWindow("mainmenuwindow.xml", WND_MOUSE_INPUT, false, false),
 		mActiveModule(NULL),
 		mEngineWindow(enginewindow)
 	{
@@ -138,7 +137,7 @@
 
 	void MainMenuWindow::setVisible(bool visible, bool destroyAfterHide)
 	{
-		CeGuiWindow::setVisible(visible, destroyAfterHide);
+		AbstractWindow::setVisible(visible, destroyAfterHide);
 		mEngineWindow->setVisible(visible, destroyAfterHide);
 	}
 }

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-03-10 21:36:02 UTC (rev 3160)
@@ -11,7 +11,7 @@
 libRlUi_la_SOURCES = \
 	AboutWindow.cpp \
 	ActionChoiceWindow.cpp \
-	CeGuiWindow.cpp \
+	AbstractWindow.cpp \
 	CharacterController.cpp \
 	CharacterSheetWindow.cpp \
 	CharacterStateWindow.cpp \

Modified: rl/trunk/engine/ui/src/MessageWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MessageWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/MessageWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -20,7 +20,7 @@
 namespace rl {
 
 MessageWindow::MessageWindow() :
-	CeGuiWindow("messagewindow.xml", WND_MOUSE_INPUT)
+	AbstractWindow("messagewindow.xml", WND_MOUSE_INPUT)
 {
 	mTextField = getWindow("MessageWindow/Text");
 

Modified: rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -21,7 +21,7 @@
 namespace rl
 {
 	ObjectDescriptionWindow::ObjectDescriptionWindow()
-		: CeGuiWindow("objectdescriptionwindow.xml", WND_SHOW)
+		: AbstractWindow("objectdescriptionwindow.xml", WND_SHOW)
 	{
 		mDescription = getMultiLineEditbox("ObjectDescriptionWindow/Text");
 	}

Modified: rl/trunk/engine/ui/src/PlaylistWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -29,7 +29,7 @@
 namespace rl {
 
 PlaylistWindow::PlaylistWindow()
-	: CeGuiWindow("playlistwindow.xml", WND_MOUSE_INPUT)
+	: AbstractWindow("playlistwindow.xml", WND_MOUSE_INPUT)
 {
 	mPlaylistTable = getMultiColumnList("PlaylistSheet/PlaylistSheet/Table");
 	mPlaylistTable->addColumn((utf8*)"Name", 0, cegui_reldim(0.5));

Modified: rl/trunk/engine/ui/src/SoundConfig.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundConfig.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/SoundConfig.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,6 +16,9 @@
 #include "SoundConfig.h"
 
 #include <boost/bind.hpp>
+#include <elements/CEGUIFrameWindow.h>
+#include <elements/CEGUIListboxTextItem.h>
+
 #include "Exception.h"
 #include "SoundDriver.h"
 #include "SoundDriverConfigComponent.h"
@@ -28,7 +31,7 @@
 {
 
 	SoundConfig::SoundConfig()
-		: CeGuiWindow("soundconfig.xml", WND_ALL_INPUT),
+		: AbstractWindow("soundconfig.xml", WND_ALL_INPUT),
 		mDriverBox(NULL),
 		mVolumeSound(0),
 		mVolumeMusic(0),
@@ -100,7 +103,7 @@
 			SoundDriver *activeDriver = SoundManager::getSingleton().getActiveDriver();        
 			if (item->getText() != activeDriver->getName())
 			{
-				// Nicht der aktive Treiber, also ?ndern.
+				// Nicht der aktive Treiber, also ???ndern.
                 SoundDriver *driver = SoundManager::getSingleton().getDriverByName(item->getText().c_str());
                 if (driver != NULL)
 				{
@@ -170,7 +173,7 @@
 
     void SoundConfig::setVisible(bool visible, bool destroyAfterHide)
     {
-        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        AbstractWindow::setVisible(visible, destroyAfterHide);
         if (visible)
         {
             update();
@@ -185,7 +188,7 @@
 
     void SoundConfig::setDriverPage(const CeGuiString& drivername)
     {
-        for ( std::list<SoundDriverConfigComponent*>::iterator it = mDriverConfigs.begin();
+        for (std::list<SoundDriverConfigComponent*>::iterator it = mDriverConfigs.begin();
 				it != mDriverConfigs.end(); it++)
 		{
 			SoundDriverConfigComponent* curr = *it;

Modified: rl/trunk/engine/ui/src/SubtitleWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -21,7 +21,7 @@
 namespace rl
 {
 	SubtitleWindow::SubtitleWindow()
-		: CeGuiWindow("subtitlewindow.xml", WND_SHOW, false)
+		: AbstractWindow("subtitlewindow.xml", WND_SHOW, false)
 	{
 		mSubtitle = getMultiLineEditbox("SubtitleWindow/Text");
 	}

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,6 +16,11 @@
 
 #include "UiSubsystem.h"
 
+#include <CEGUISystem.h>
+#include <CEGUIWindowManager.h>
+#include <OgreCEGUIRenderer.h>
+#include <OgreCEGUIResourceProvider.h>
+
 #include "Action.h"
 #include "ActionManager.h"
 #include "Actor.h"
@@ -43,9 +48,6 @@
 #include "WindowManager.h"
 #include "World.h"
 #include "CeGuiHelper.h"
-#include <OgreCEGUIRenderer.h>
-#include <CEGUISystem.h>
-#include <OgreCEGUIResourceProvider.h>
 
 template<> rl::UiSubsystem* Singleton<rl::UiSubsystem>::ms_Singleton = 0;
 using namespace Ogre;
@@ -121,7 +123,7 @@
             "CEGUI System initialized.", "UiSubsystem::initializeUiSubsystem");
 
         // load scheme and set up defaults
-        ///@todo Hier sollte was Lookunabh?ngiges rein!!! FIXME TODO BUG!
+        ///@todo Hier sollte was Lookunabh???ngiges rein!!! FIXME TODO BUG!
         System::getSingleton().setDefaultMouseCursor((utf8*)"RastullahLook-Images",
             (utf8*)"MouseArrow");
         LOG_MESSAGE2(Logger::UI, "Mouse arrow loaded.",
@@ -183,7 +185,7 @@
             SoundManager::getSingleton().createListenerActor();
         }
 
-        // Nur wenn es sich ver?ndert hat
+        // Nur wenn es sich ver???ndert hat
         if( person != mCharacter )
         {
             if( mCharacter != NULL )

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -425,7 +425,7 @@
 
     void WindowFactory::logAllWindows()
     {
-        CEGUI::Window* rootWnd = CeGuiWindow::getRoot();
+        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
         CEGUI::uint count = rootWnd->getChildCount();
         for (CEGUI::uint chIdx =  0; chIdx < count; ++chIdx)
         {

Modified: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -16,7 +16,7 @@
 
 #include "WindowFadeJob.h"
 
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 #include "CeGuiHelper.h"
 #include "WindowManager.h"
 
@@ -25,7 +25,7 @@
 
 namespace rl
 {
-    WindowFadeJob::WindowFadeJob(CeGuiWindow* window, Mode mode, Real targetAlpha, Real changeRate)
+    WindowFadeJob::WindowFadeJob(AbstractWindow* window, Mode mode, Real targetAlpha, Real changeRate)
         : Job(true, true),
         mWindow(window),
         mMode(mode),

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-03-09 16:16:41 UTC (rev 3159)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-03-10 21:36:02 UTC (rev 3160)
@@ -13,11 +13,11 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
-#include "CeGuiWindow.h"
 #include "WindowManager.h"
 #include <CEGUIWindowManager.h>
 
 #include "CoreSubsystem.h"
+#include "AbstractWindow.h"
 #include "Exception.h"
 #include "GameLoop.h"
 #include "UiSubsystem.h"
@@ -36,16 +36,16 @@
 	{
 	}
 	
-	void WindowManager::registerWindow(CeGuiWindow* window)
+	void WindowManager::registerWindow(AbstractWindow* window)
 	{
 		mWindowList.push_back(window);
 	}
 
-	void WindowManager::destroyWindow(CeGuiWindow* window)
+	void WindowManager::destroyWindow(AbstractWindow* window)
 	{
 		mWindowList.remove(window);
 		window->getWindow()->hide();
-		CeGuiWindow::getRoot()->removeChildWindow(window->getWindow());
+		AbstractWindow::getRoot()->removeChildWindow(window->getWindow());
 		CEGUI::WindowManager::getSingleton().destroyWindow(window->getWindow());
 
 		///@todo memory leak, aber destroyWindow macht sonst Probleme (heap corruption)
@@ -54,9 +54,9 @@
 
 	void WindowManager::closeTopWindow()
 	{
-		for(std::list<CeGuiWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++)
+		for(std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++)
 		{
-			CeGuiWindow* cur = *it;
+			AbstractWindow* cur = *it;
 			if (cur->isVisible() && cur->isClosingOnEscape())
 			{
 				cur->setVisible(false);
@@ -65,14 +65,14 @@
 		}
 	}
 
-	bool WindowManager::handleMovedToFront(CeGuiWindow* window)
+	bool WindowManager::handleMovedToFront(AbstractWindow* window)
 	{
 		mWindowList.remove(window);
 		mWindowList.push_front(window);
 		return true;
 	}
 	
-	bool WindowManager::handleMovedToBack(CeGuiWindow* window)
+	bool WindowManager::handleMovedToBack(AbstractWindow* window)
 	{
 		mWindowList.remove(window);
 		mWindowList.push_back(window);



From vincent22 at mail.berlios.de  Sun Mar 11 01:39:40 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 01:39:40 +0100
Subject: [Dsa-hl-svn] r3161 - in rl/trunk/engine: rules/include rules/src
	script/swig ui ui/include ui/src
Message-ID: <200703110039.l2B0dep7010004@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 01:39:15 +0100 (Sun, 11 Mar 2007)
New Revision: 3161

Added:
   rl/trunk/engine/ui/include/GameObjectWindow.h
   rl/trunk/engine/ui/src/GameObjectWindow.cpp
Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Added the GameObjectWindow to display debug information of a GO when you are in developer mode.
- Added the GameObjectWindow class
- Added the showGameObjectWindow method to the WindowFactory
- Added the Action ShowGameObjectWindowAction to the standard actions of a GO
- Exports to Ruby
  . showGameObjectWindow to RlUi.swig
  . getDeveloperMode to RlCore.swig
 

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-03-11 00:39:15 UTC (rev 3161)
@@ -62,6 +62,7 @@
         static const Ogre::String PROPERTY_MASS; 
 
 		static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
 
         GameObject(unsigned int id);
         virtual ~GameObject();

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-03-11 00:39:15 UTC (rev 3161)
@@ -24,12 +24,14 @@
 #include "Property.h"
 #include "RulesSubsystem.h"
 #include "GameObjectManager.h"
+#include "CoreSubsystem.h"
 
 using namespace std;
 
 namespace rl
 {
 	const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = "viewobject";
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = "viewobjectdebug";
 
     const Ogre::String GameObject::CLASS_NAME = "GameObject";
 
@@ -61,6 +63,17 @@
             addAction(defaultAction);
         }
 
+        // If game in developer mode, show GameObject debug window
+        // in the radial menu
+        //if( CoreSubsystem::getSingleton().getDeveloperMode() )
+        //{
+            defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
+		    if (defaultAction != NULL)
+            {
+                addAction(defaultAction);
+            }
+        //}
+
 		// Eventsource erzeugen
 		setObject(this);
     }

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-03-11 00:39:15 UTC (rev 3161)
@@ -659,6 +659,7 @@
     void makeScreenshot(const Ogre::String& sName);
     bool isInitialized() const;
     void setScheme(const Ogre::String& schemeName);
+    bool getDeveloperMode() const;
 };
 
 class Sound 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-11 00:39:15 UTC (rev 3161)
@@ -370,6 +370,7 @@
         void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
             
 		static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+		static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
 		
 		bool isHighlightingEnabled();
         void setHighlightingEnabled( bool highlightenabled );

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-03-11 00:39:15 UTC (rev 3161)
@@ -108,6 +108,7 @@
 	void showCharacterSheet(rl::Person* chara);
 	void showContainerContent(rl::Container* container);
 	void showDescriptionWindow(rl::GameObject* obj);
+	void showGameObjectWindow(rl::GameObject* obj);
 	void showDialog(rl::DialogCharacter* bot);
 	void showExitConfirmation();
 	void showJournalWindow();

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-03-11 00:39:15 UTC (rev 3161)
@@ -87,7 +87,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				IgnoreDefaultLibraryNames=""
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
@@ -194,7 +194,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				ProgramDatabaseFile=""
 				SubSystem="2"
 			/>
@@ -260,7 +260,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;..\uicomponents\include;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\uicomponents\include;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include\;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -296,7 +296,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\core\lib\Release;..\rules\lib\Release;..\uicomponents\lib\Release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib\Release;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll"
+				AdditionalLibraryDirectories="..\core\lib\Release;..\rules\lib\Release;..\uicomponents\lib\Release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib\Release;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(TargetDir)$(TargetName).pdb"
 				SubSystem="2"
@@ -457,6 +457,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\GameObjectWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\InfoPopup.h"
 					>
 				</File>
@@ -630,6 +634,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\GameObjectWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\InfoPopup.cpp"
 					>
 				</File>

Added: rl/trunk/engine/ui/include/GameObjectWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-11 00:39:15 UTC (rev 3161)
@@ -0,0 +1,128 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/**
+ * \file GameObjectWindow.h
+ *
+ * Declaration of the GameObject window
+ */
+
+#ifndef __GameObjectWindow_H__
+#define __GameObjectWindow_H__
+
+#include "UiPrerequisites.h"
+#include "CeGuiWindow.h"
+
+namespace rl {
+
+	class GameObject;
+    class Property;
+
+    /**
+     * The GameObject window class
+     *
+     * This window displays all properties of a game object by looping
+     * through the property set of the given object.
+     */
+    class _RlUiExport GameObjectWindow : public AbstractWindow
+	{
+	public:
+
+        /**
+         * Constructor of the GameObject window
+         */
+		GameObjectWindow();
+		
+        /**
+         * Destructor of the GameObject window
+         */
+        virtual ~GameObjectWindow();
+
+        /**
+         * Initializes the window with the specified game object and
+         * fills the window with the properties of the GameObject.
+         *
+         * @param object The GameObject to be displayed
+         */
+		virtual void initialize(GameObject* object);
+	
+	protected:
+
+        /**
+         * Fills the header part of the window with the Name and Description
+         * property of the GameObject.
+         *
+         * @param object The GameObject to be displayed
+         */
+        virtual void fillHeader(GameObject* object);
+ 
+        /**
+         * Adds one row to the property table with the given key
+         * and the property value.
+         *
+         * @param key The key of the property key|value pair
+         * @param prop The property value
+         * @param row The current row in the property table
+         */
+        //virtual void addProperty(const Ogre::String& key, const Property& prop, int row); 
+
+        /**
+         * Adds an Int value to the property table.
+         *
+         * @param key The property to add.
+         */
+        virtual void addPropertyInt(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyIntPair(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyIntTriple(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyString(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyBool(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyReal(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyVector3(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyQuaternion(const Property& prop, 
+            CEGUI::MultiColumnList* table,
+            const CEGUI::String& key = "");
+
+        virtual void addPropertyArray(const Property& prop,
+            const CEGUI::String& key = "");
+
+        
+        CEGUI::TabControl *mTabPane;        //!< TabControl for the property tabs
+        CEGUI::MultiColumnList *mMainTable; //!< Main table for the GameObject properties 
+	};
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-03-11 00:39:15 UTC (rev 3161)
@@ -49,6 +49,7 @@
 	class JournalWindow;
 	class LogWindow;
 	class ObjectDescriptionWindow;
+    class GameObjectWindow;
 	class Person;
 	class WindowUpdater;
     class MainMenuWindow;
@@ -81,6 +82,7 @@
 		void showCharacterSheet(Person* chara);
 		void showContainerContent(Container* container);
 		void showDescriptionWindow(GameObject* obj);
+        void showGameObjectWindow(GameObject* obj);
 		void showDialog(DialogCharacter* bot);
         void showExitConfirmation();
 		bool showInputOptionsMenu(Creature* actionHolder);

Added: rl/trunk/engine/ui/src/GameObjectWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 00:39:15 UTC (rev 3161)
@@ -0,0 +1,592 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/**
+ * \file GameObjectWindow.cpp
+ *
+ * Implementation of the GameObject window
+ */
+
+#include <boost/bind.hpp>
+#include "GameObjectWindow.h"
+#include "GameObject.h"
+
+using namespace CEGUI;
+
+namespace rl {
+
+    //------------------------------------------------------- Constructor
+
+	GameObjectWindow::GameObjectWindow() :
+        CeGuiWindow("gameobjectwindow.xml", WND_MOUSE_INPUT)
+	{
+        // Get access to the tab control
+        mTabPane = getTabControl("GameObjectWindow/PropertiesTabPane");
+        RlAssert(mTabPane != NULL, "GameObjectWindow/PropertiesTabPane is null");
+
+        // Get a access to the main Property table
+        mMainTable = getMultiColumnList("GameObjectWindow/PropertiesTabControl/MainTable");
+        RlAssert(mMainTable != NULL, "GameObjectWindow/PropertiesTabPane is null");
+
+        mMainTable->addColumn( (utf8*)"Key", 0, cegui_reldim(0.3));
+        mMainTable->addColumn( (utf8*)"Type", 1, cegui_reldim(0.3));
+        mMainTable->addColumn( (utf8*)"Value", 2, cegui_reldim(0.4));
+        
+        centerWindow();
+
+        bindCloseToCloseButton();
+        bindClickToCloseWindow(getWindow("GameObjectWindow/CloseButton"));
+	    
+	}
+
+    //------------------------------------------------------- Destructor
+
+	GameObjectWindow::~GameObjectWindow() 
+	{        
+	}
+
+    //------------------------------------------------------- initialize
+
+	void GameObjectWindow::initialize( GameObject* object )
+	{
+        // Fill header text fields with name and description
+        fillHeader(object);    
+
+        // Get the property set of the object
+        PropertySet* props = object->getAllProperties();
+
+        int row = 0;
+        //  Iterate through all properties and add a row for
+        //  every Entry
+        for( PropertyMap::const_iterator propIter = props->begin();
+            propIter != props->end(); propIter++ )
+        {
+            CEGUI::String key = propIter->first;
+            
+            if( key == "description" || key == "name" )
+                continue;
+
+            // Check for Int
+            if( propIter->second.isInt() )
+            {
+                addPropertyInt(propIter->second, mMainTable, key );
+            }
+            // Check for IntPair
+            else if( propIter->second.isIntPair() )
+            {
+                addPropertyIntPair(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for IntTriple
+            else if( propIter->second.isIntTriple() )
+            {
+                addPropertyIntTriple(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for String
+            else if( propIter->second.isString() )
+            {
+                addPropertyString(propIter->second, mMainTable, key);
+            }
+            // Check for Bool
+            else if( propIter->second.isBool() )
+            {
+                addPropertyBool(propIter->second, mMainTable, key);
+            }
+            // Check for Real
+            else if( propIter->second.isReal() )
+            {
+                addPropertyReal(propIter->second, mMainTable, key);
+            }
+            // Check for Vector3
+            else if( propIter->second.isVector3() )
+            {
+                addPropertyVector3(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Quaternion
+            else if( propIter->second.isQuaternion() )
+            {
+                addPropertyQuaternion(propIter->second, mMainTable, key);
+                int rowCount = mMainTable->getRowCount();
+                mMainTable->addRow(rowCount);
+                mMainTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Array
+            else if( propIter->second.isArray() )
+            {
+                addPropertyArray(propIter->second, key);
+            }
+        }
+
+        mMainTable->autoSizeColumnHeader(0);
+        mMainTable->autoSizeColumnHeader(1);
+        mMainTable->autoSizeColumnHeader(2);
+	}
+
+    //------------------------------------------------------- fillHeader
+
+    void GameObjectWindow::fillHeader(GameObject* object)
+    {
+        getWindow("GameObjectWindow/HeaderSheet/ObjectName")->setText(object->getName());
+        getWindow("GameObjectWindow/HeaderSheet/ObjectDescription")->setText(object->getDescription());
+    }
+
+    //------------------------------------------------------- addPropertyInt
+
+    void GameObjectWindow::addPropertyInt(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Int  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("Int  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyIntPair
+
+    void GameObjectWindow::addPropertyIntPair(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        IntPair intPair = prop.toIntPair();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntPair value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(
+                "First " + PropertyHelper::intToString(intPair.first)), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntPair value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem(
+                "Second " + PropertyHelper::intToString(intPair.second)), 
+                2, 
+                rowCount + 1);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(
+                "First " + PropertyHelper::intToString(intPair.first)), 
+                1, 
+                rowCount);
+
+            // Add second for the second IntPair value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem(
+                "Second " + PropertyHelper::intToString(intPair.second)), 
+                2, 
+                rowCount + 1);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyIntTriple
+
+    void GameObjectWindow::addPropertyIntTriple(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Tripel<int> intTriple = prop.toIntTriple();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("IntTriple  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(
+                "First " + PropertyHelper::intToString(intTriple.first)), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem(
+                "Second " + PropertyHelper::intToString(intTriple.second)), 
+                2, 
+                rowCount + 1);
+
+            // Add third for the third IntTriple value
+            table->addRow(rowCount + 2);
+            table->setItem(new ListboxTextItem(
+                "Third " + PropertyHelper::intToString(intTriple.third)), 
+                2, 
+                rowCount + 2);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("IntTriple  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(
+                "First " + PropertyHelper::intToString(intTriple.first)), 
+                1, 
+                rowCount);
+
+            // Add second for the second IntPair value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem(
+                "Second " + PropertyHelper::intToString(intTriple.second)), 
+                2, 
+                rowCount + 1);
+
+            // Add third for the third IntTriple value
+            table->addRow(rowCount + 2);
+            table->setItem(new ListboxTextItem(
+                "Third " + PropertyHelper::intToString(intTriple.third)), 
+                2, 
+                rowCount + 2);
+        } 
+    }
+
+    //------------------------------------------------------- addPropertyString
+
+    void GameObjectWindow::addPropertyString(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("String  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(prop.toString()), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("String  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(prop.toString()), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyBool
+
+    void GameObjectWindow::addPropertyBool(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Bool  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("Bool  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyReal
+
+    void GameObjectWindow::addPropertyReal(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+       // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Real  "), 1, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::floatToString(prop.toReal())), 
+                2, 
+                rowCount);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
+            table->setItem(new ListboxTextItem(PropertyHelper::floatToString(prop.toReal())), 
+                1, 
+                rowCount);
+        }
+    }
+
+    //------------------------------------------------------- addPropertyVector3
+
+    void GameObjectWindow::addPropertyVector3(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Ogre::Vector3 vec = prop.toVector3();
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Vector3  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("X " + PropertyHelper::floatToString(vec.x)), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Y " + PropertyHelper::floatToString(vec.y)), 
+                2, 
+                rowCount + 1);
+
+            // Add third for the third IntTriple value
+            table->addRow(rowCount + 2);
+            table->setItem(new ListboxTextItem("Z " + PropertyHelper::floatToString(vec.z)), 
+                2, 
+                rowCount + 2);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("X " + PropertyHelper::floatToString(vec.x)), 
+                1, 
+                rowCount);
+
+            // Add second for the second IntPair value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Y " + PropertyHelper::floatToString(vec.y)), 
+                2, 
+                rowCount + 1);
+
+            // Add third for the third IntTriple value
+            table->addRow(rowCount + 2);
+            table->setItem(new ListboxTextItem("Z " + PropertyHelper::floatToString(vec.z)), 
+                2, 
+                rowCount + 2);
+        } 
+    }
+
+    //------------------------------------------------------- addPropertyQuaternion
+
+    void GameObjectWindow::addPropertyQuaternion(const Property& prop, 
+        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+    {
+        // Check column count
+        // if count = 3 | MainTable
+        // if count = 2 | Array table
+        int colCount = table->getColumnCount();
+        int rowCount = table->getRowCount();
+
+        Ogre::Quaternion quat = prop.toQuaternion();
+        Ogre::Radian angle;
+        Ogre::Vector3 axis;
+
+        quat.ToAngleAxis( angle, axis );
+
+        // Table has the three columns Key, Type, Value
+        if ( colCount == 3 )
+        {
+            // Add row for the first IntTriple value
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Quaternion  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("Axis " +
+                PropertyHelper::floatToString(axis.x) + ", " +
+                PropertyHelper::floatToString(axis.y) + ", " +
+                PropertyHelper::floatToString(axis.z)), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Radian " + 
+                PropertyHelper::floatToString(angle.valueRadians())), 
+                2, 
+                rowCount + 1);
+        }
+        // Table has the two columns Type, Value
+        else if ( colCount == 2 )
+        {
+            table->setItem(new ListboxTextItem("Quaternion  "), 0, rowCount);
+            table->setItem(new ListboxTextItem("Axis " +
+                PropertyHelper::floatToString(axis.x) + ", " +
+                PropertyHelper::floatToString(axis.y) + ", " +
+                PropertyHelper::floatToString(axis.z)), 
+                2, 
+                rowCount);
+
+            // Add second for the second IntTriple value
+            table->addRow(rowCount + 1);
+            table->setItem(new ListboxTextItem("Radian " + 
+                PropertyHelper::floatToString(angle.valueRadians())), 
+                2, 
+                rowCount + 1);
+        } 
+
+    }
+
+    //------------------------------------------------------- addPropertyArray
+
+    void GameObjectWindow::addPropertyArray(const Property& prop, const CEGUI::String& key)
+    {
+        // Create the new MultiColumnList with two columns
+        // Type and Value and set tab text to key
+        int tabCount = mTabPane->getTabCount();
+        CEGUI::MultiColumnList* newTable = new MultiColumnList(
+            "RastullahLook/MultiColumnList",
+            "GameObjectWindow/PropertiesTabControl/PropertyTab_" + 
+            CEGUI::PropertyHelper::intToString(tabCount) );
+        newTable->setText(key);
+        newTable->addColumn("Type", 0, cegui_reldim(0.3));
+        newTable->addColumn("Value", 1, cegui_reldim(0.7));
+        
+        // Add the MultiColumnList to the tab pane
+        mTabPane->addTab(newTable);
+
+        // Get access to the vector
+        std::vector<Property> vProp = prop.toArray();
+        std::vector<Property>::iterator it;
+
+        // Iterate through the vector entries and add them
+        // to the table
+        for(it = vProp.begin(); it != vProp.end(); it++)
+        {
+            // Check for Int
+            if( it->isInt() )
+            {
+                addPropertyInt(*it, newTable);
+            }
+            // Check for IntPair
+            else if( it->isIntPair() )
+            {
+                addPropertyIntPair(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for IntTriple
+            else if( it->isIntTriple() )
+            {
+                addPropertyIntTriple(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for String
+            else if( it->isString() )
+            {
+                addPropertyString(*it, newTable);
+            }
+            // Check for Bool
+            else if( it->isBool() )
+            {
+                addPropertyBool(*it, newTable);
+            }
+            // Check for Real
+            else if( it->isReal() )
+            {
+                addPropertyReal(*it, newTable);
+            }
+            // Check for Vector3
+            else if( it->isVector3() )
+            {
+                addPropertyVector3(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+            // Check for Quaternion
+            else if( it->isQuaternion() )
+            {
+                addPropertyQuaternion(*it, newTable);
+                int rowCount = newTable->getRowCount();
+                newTable->addRow(rowCount);
+                newTable->setItem(new ListboxTextItem(""), 0, rowCount);
+            }
+        }
+        newTable->autoSizeColumnHeader(0);
+        newTable->autoSizeColumnHeader(1);
+    }
+
+} // namespace rl

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-10 21:36:02 UTC (rev 3160)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-11 00:39:15 UTC (rev 3161)
@@ -52,6 +52,7 @@
 #include "SubtitleWindow.h"
 #include "UiSubsystem.h"
 #include "WindowManager.h"
+#include "GameObjectWindow.h"
 
 #undef max
 
@@ -174,6 +175,13 @@
 		mDebugWindow->setVisible(!mDebugWindow->isVisible());
 	}
 
+	void WindowFactory::showGameObjectWindow(GameObject* obj)
+	{
+        GameObjectWindow* wnd = new GameObjectWindow();
+        wnd->initialize(obj);
+        wnd->setVisible(true);
+	}
+
 	void WindowFactory::toggleGameLogWindow()
 	{
 		mGameLogger->setVisible(!mGameLogger->isVisible());



From vincent22 at mail.berlios.de  Sun Mar 11 01:41:02 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 01:41:02 +0100
Subject: [Dsa-hl-svn] r3162 - in modules/common: gui/windows scripts
Message-ID: <200703110041.l2B0f23L010231@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 01:40:49 +0100 (Sun, 11 Mar 2007)
New Revision: 3162

Added:
   modules/common/gui/windows/gameobjectwindow.xml
Modified:
   modules/common/scripts/global-actions.rb
Log:
Added the window layout for the GameObjectWindow and defined the action to show this window.

Added: modules/common/gui/windows/gameobjectwindow.xml
===================================================================
--- modules/common/gui/windows/gameobjectwindow.xml	2007-03-11 00:39:15 UTC (rev 3161)
+++ modules/common/gui/windows/gameobjectwindow.xml	2007-03-11 00:40:49 UTC (rev 3162)
@@ -0,0 +1,81 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+  	<Window Type="RastullahLook/FrameWindow" Name="GameObjectWindow">
+		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+        <Property Name="UnifiedSize" Value="{{0,400},{0,500}}"/>
+		<Property Name="Text" Value="Spielobjekt Eigenschaften"/>
+		<Property Name="SizingEnabled" Value="false"/>
+
+		<!-- Headersheet for the name and description -->
+		
+		<Window Type="DefaultGUISheet" Name="GameObjectWindow/HeaderSheet">
+      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,30}}"/>
+       	 	<Property Name="UnifiedSize" Value="{{0,350},{0,100}}"/>
+       	
+       	 	<!-- Name of the object -->
+       	 	 	
+			<Window Type="RastullahLook/StaticText" Name="GameObjectWindow/HeaderSheet/Name">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
+       	 		<Property Name="Text" Value="Name:"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<Window Type="RastullahLook/StaticText" Name="GameObjectWindow/HeaderSheet/ObjectName">
+      	 		<Property Name="UnifiedPosition" Value="{{0,90},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,25}}"/>
+       	 		<Property Name="Text" Value="n/a"/>
+        		<Property Name="FrameEnabled" Value="True"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<!-- Description of the object -->
+    	
+			<Window Type="RastullahLook/StaticText" Name="GameObjectWindow/HeaderSheet/Description">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,30}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,80},{0,25}}"/>
+       	 		<Property Name="Text" Value="Description:"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+       	 		<Property Name="HorzFormatting" Value="LeftAligned" />
+    		</Window>
+    		
+    		<Window Type="RastullahLook/MultiLineEditbox" Name="GameObjectWindow/HeaderSheet/ObjectDescription">
+      	 		<Property Name="ReadOnly" Value="true"/>
+            	<Property Name="Disabled" Value="true"/>
+    			<Property Name="UnifiedPosition" Value="{{0,90},{0,30}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{0,250},{0,60}}"/>
+        		<Property Name="FrameEnabled" Value="False"/>
+    		</Window>
+    		
+    	</Window>
+    	
+    	<!-- Properties sheet for the properties of the object -->
+    	
+		<Window Type="RastullahLook/TabControl" Name="GameObjectWindow/PropertiesTabPane">
+      	 	<Property Name="UnifiedPosition" Value="{{0,30},{0,140}}"/>
+       	 	<Property Name="UnifiedSize" Value="{{0,340},{0,300}}"/>
+       	 	<Property Name="FrameEnabled" Value="False"/>
+       	 	
+       		<!-- Table with two columns for the key/value pair -->
+       	 	
+       		<Window Type="RastullahLook/MultiColumnList" Name="GameObjectWindow/PropertiesTabControl/MainTable">
+      	 		<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+       	 		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
+       	 		<Property Name="Text" Value="Eigenschaften"/>
+       	 		<Property Name="SortSettingEnabled" Value="False"/>
+       	 		<Property Name="Font" Value="Vera Serif Bold-8"/>
+       	 		<Property Name="FrameEnabled" Value="False"/>
+    		</Window>   	
+       	 	 	
+       	</Window>
+		
+       	<!-- The Close button -->
+		<Window Type="RastullahLook/Button" Name="GameObjectWindow/CloseButton">
+           	<Property Name="UnifiedPosition" Value="{{0.3,0},{0.9,0}}"/>
+           	<Property Name="UnifiedSize" Value="{{0,125},{0,28}}"/>
+			<Property Name="Font" Value="Vera Serif-10"/>
+			<Property Name="Text" Value="Close"/>
+		</Window>
+		
+	</Window>
+</GUILayout>
\ No newline at end of file

Modified: modules/common/scripts/global-actions.rb
===================================================================
--- modules/common/scripts/global-actions.rb	2007-03-11 00:39:15 UTC (rev 3161)
+++ modules/common/scripts/global-actions.rb	2007-03-11 00:40:49 UTC (rev 3162)
@@ -178,6 +178,20 @@
   end
 end
 
+class ShowGameObjectWindowAction < Action
+  def initialize
+    super(GameObject.DEFAULT_VIEW_OBJECT_ACTION_DEBUG, "GameObject Properties (DeveloperMode)")
+  end
+  
+  def doAction(object, actor, target)
+    $WF.showGameObjectWindow(object)
+  end
+  
+  def canDo(object, actor)
+    $CORE.getDeveloperMode()
+  end
+end
+
 class ShowAboutWindowAction < Action
   def initialize
     super("act_showaboutwindow", "?ber")
@@ -246,3 +260,6 @@
 
 act = ShowObjectDescriptionWindow.new()
 ActionManager.getSingleton().registerAction(act)
+
+act2 = ShowGameObjectWindowAction.new()
+ActionManager.getSingleton().registerAction(act2)



From vincent22 at mail.berlios.de  Sun Mar 11 01:57:13 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 01:57:13 +0100
Subject: [Dsa-hl-svn] r3163 - in rl/trunk/engine/ui: include src
Message-ID: <200703110057.l2B0vDpD010955@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 01:57:10 +0100 (Sun, 11 Mar 2007)
New Revision: 3163

Modified:
   rl/trunk/engine/ui/include/GameObjectWindow.h
   rl/trunk/engine/ui/src/GameObjectWindow.cpp
Log:
Some changes caused through the change from CeGuiWindow to the AbstractWindow base class.

Modified: rl/trunk/engine/ui/include/GameObjectWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-11 00:40:49 UTC (rev 3162)
+++ rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-11 00:57:10 UTC (rev 3163)
@@ -24,7 +24,7 @@
 #define __GameObjectWindow_H__
 
 #include "UiPrerequisites.h"
-#include "CeGuiWindow.h"
+#include "AbstractWindow.h"
 
 namespace rl {
 

Modified: rl/trunk/engine/ui/src/GameObjectWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 00:40:49 UTC (rev 3162)
+++ rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 00:57:10 UTC (rev 3163)
@@ -21,6 +21,9 @@
  */
 
 #include <boost/bind.hpp>
+#include <CEGUIPropertyHelper.h>
+#include <elements/CEGUIListboxTextItem.h>
+
 #include "GameObjectWindow.h"
 #include "GameObject.h"
 
@@ -31,7 +34,7 @@
     //------------------------------------------------------- Constructor
 
 	GameObjectWindow::GameObjectWindow() :
-        CeGuiWindow("gameobjectwindow.xml", WND_MOUSE_INPUT)
+        AbstractWindow("gameobjectwindow.xml", WND_MOUSE_INPUT)
 	{
         // Get access to the tab control
         mTabPane = getTabControl("GameObjectWindow/PropertiesTabPane");



From vincent22 at mail.berlios.de  Sun Mar 11 02:05:39 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 02:05:39 +0100
Subject: [Dsa-hl-svn] r3164 - rl/trunk/engine/ui/src
Message-ID: <200703110105.l2B15ddQ011359@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 02:05:37 +0100 (Sun, 11 Mar 2007)
New Revision: 3164

Modified:
   rl/trunk/engine/ui/src/GameObjectWindow.cpp
Log:
Changed the presentation of the gameobject properties in the debug window. 

Modified: rl/trunk/engine/ui/src/GameObjectWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 00:57:10 UTC (rev 3163)
+++ rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 01:05:37 UTC (rev 3164)
@@ -205,33 +205,21 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(
-                "First " + PropertyHelper::intToString(intPair.first)), 
+            table->setItem(new ListboxTextItem( 
+                PropertyHelper::intToString(intPair.first) + ", " +
+                PropertyHelper::intToString(intPair.second)), 
                 2, 
                 rowCount);
-
-            // Add second for the second IntPair value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem(
-                "Second " + PropertyHelper::intToString(intPair.second)), 
-                2, 
-                rowCount + 1);
         }
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
             table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
             table->setItem(new ListboxTextItem(
-                "First " + PropertyHelper::intToString(intPair.first)), 
+                PropertyHelper::intToString(intPair.first) + ", " +
+                PropertyHelper::intToString(intPair.second)), 
                 1, 
                 rowCount);
-
-            // Add second for the second IntPair value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem(
-                "Second " + PropertyHelper::intToString(intPair.second)), 
-                2, 
-                rowCount + 1);
         }
     }
 
@@ -256,46 +244,22 @@
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("IntTriple  "), 1, rowCount);
             table->setItem(new ListboxTextItem(
-                "First " + PropertyHelper::intToString(intTriple.first)), 
+                PropertyHelper::intToString(intTriple.first) + ", " +
+                PropertyHelper::intToString(intTriple.second) + ", " +
+                PropertyHelper::intToString(intTriple.third)),
                 2, 
                 rowCount);
-
-            // Add second for the second IntTriple value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem(
-                "Second " + PropertyHelper::intToString(intTriple.second)), 
-                2, 
-                rowCount + 1);
-
-            // Add third for the third IntTriple value
-            table->addRow(rowCount + 2);
-            table->setItem(new ListboxTextItem(
-                "Third " + PropertyHelper::intToString(intTriple.third)), 
-                2, 
-                rowCount + 2);
         }
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
             table->setItem(new ListboxTextItem("IntTriple  "), 0, rowCount);
             table->setItem(new ListboxTextItem(
-                "First " + PropertyHelper::intToString(intTriple.first)), 
+                PropertyHelper::intToString(intTriple.first) + ", " +
+                PropertyHelper::intToString(intTriple.second) + ", " +
+                PropertyHelper::intToString(intTriple.third)), 
                 1, 
                 rowCount);
-
-            // Add second for the second IntPair value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem(
-                "Second " + PropertyHelper::intToString(intTriple.second)), 
-                2, 
-                rowCount + 1);
-
-            // Add third for the third IntTriple value
-            table->addRow(rowCount + 2);
-            table->setItem(new ListboxTextItem(
-                "Third " + PropertyHelper::intToString(intTriple.third)), 
-                2, 
-                rowCount + 2);
         } 
     }
 



From chrber at mail.berlios.de  Sun Mar 11 14:22:41 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Sun, 11 Mar 2007 14:22:41 +0100
Subject: [Dsa-hl-svn] r3165 - in rl/trunk/engine: common/include ui/include
	ui/src
Message-ID: <200703111322.l2BDMf8X009774@sheep.berlios.de>

Author: chrber
Date: 2007-03-11 14:22:37 +0100 (Sun, 11 Mar 2007)
New Revision: 3165

Modified:
   rl/trunk/engine/common/include/FixRubyHeaders.h
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
Added missing files to Makefiles
Corrected a missing newline at the end


Modified: rl/trunk/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/trunk/engine/common/include/FixRubyHeaders.h	2007-03-11 01:05:37 UTC (rev 3164)
+++ rl/trunk/engine/common/include/FixRubyHeaders.h	2007-03-11 13:22:37 UTC (rev 3165)
@@ -38,4 +38,5 @@
     #undef PACKAGE_TARNAME
 #endif
 #undef max
-#undef min
\ No newline at end of file
+#undef min
+

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-03-11 01:05:37 UTC (rev 3164)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-03-11 13:22:37 UTC (rev 3165)
@@ -17,6 +17,7 @@
 	DialogCharacterController.h \
 	FreeFlightCharacterController.h \
 	GameLoggerWindow.h \
+	GameObjectWindow.h \
 	GameSettings.h \
 	InfoPopup.h \
 	InGameMenuWindow.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-03-11 01:05:37 UTC (rev 3164)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-03-11 13:22:37 UTC (rev 3165)
@@ -27,6 +27,7 @@
 	DialogWindow.cpp \
 	FreeFlightCharacterController.cpp \
 	GameLoggerWindow.cpp \
+	GameObjectWindow.cpp \
 	GameSettings.cpp \
 	InfoPopup.cpp \
 	InGameMenuWindow.cpp \



From tanis at mail.berlios.de  Sun Mar 11 15:46:58 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Sun, 11 Mar 2007 15:46:58 +0100
Subject: [Dsa-hl-svn] r3166 - rl/trunk/engine/rules/src
Message-ID: <200703111446.l2BEkw47013907@sheep.berlios.de>

Author: tanis
Date: 2007-03-11 15:46:50 +0100 (Sun, 11 Mar 2007)
New Revision: 3166

Modified:
   rl/trunk/engine/rules/src/Creature.cpp
Log:
Creature::getAllProperties now returns behaviors too.

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-11 13:22:37 UTC (rev 3165)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-11 14:46:50 UTC (rev 3166)
@@ -17,7 +17,7 @@
 
 #include "Actor.h"
 #include "Container.h"
-#include "DsaManager.h"
+#include "DsaManager.h"
 #include "EffectManager.h"
 #include "Eigenschaft.h"
 #include "Exception.h"
@@ -63,7 +63,7 @@
         mSleeping(0),
         mUnconscious(0),
         mMovementType(0)
-    {
+    {
         mEffectManager = new EffectManager();
         mQueryFlags = QUERYFLAG_CREATURE;
 
@@ -1163,8 +1163,7 @@
     PropertySet* Creature::getAllProperties() const
     {
         PropertySet* ps = GameObject::getAllProperties();
-        //ps->setProperty(Item::PROPERTY_IMAGENAME, Property(mImageName));
-        //ps->setProperty(Item::PROPERTY_SIZE, Property(mSize));
+        ps->setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
 
         return ps;
     }



From vincent22 at mail.berlios.de  Sun Mar 11 18:21:43 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 18:21:43 +0100
Subject: [Dsa-hl-svn] r3167 - in rl/trunk/engine/ui: include src
Message-ID: <200703111721.l2BHLhUH023766@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 18:21:33 +0100 (Sun, 11 Mar 2007)
New Revision: 3167

Modified:
   rl/trunk/engine/ui/include/GameObjectWindow.h
   rl/trunk/engine/ui/src/GameObjectWindow.cpp
Log:
Fixed the problem with Properties of the type Array in the GameObjectWindow.

Modified: rl/trunk/engine/ui/include/GameObjectWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-11 14:46:50 UTC (rev 3166)
+++ rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-11 17:21:33 UTC (rev 3167)
@@ -86,38 +86,38 @@
          */
         virtual void addPropertyInt(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyIntPair(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyIntTriple(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyString(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyBool(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyReal(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyVector3(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyQuaternion(const Property& prop, 
             CEGUI::MultiColumnList* table,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         virtual void addPropertyArray(const Property& prop,
-            const CEGUI::String& key = "");
+            const Ogre::String& key = "");
 
         
         CEGUI::TabControl *mTabPane;        //!< TabControl for the property tabs

Modified: rl/trunk/engine/ui/src/GameObjectWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 14:46:50 UTC (rev 3166)
+++ rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 17:21:33 UTC (rev 3167)
@@ -22,6 +22,7 @@
 
 #include <boost/bind.hpp>
 #include <CEGUIPropertyHelper.h>
+#include <CEGUIWindowManager.h>
 #include <elements/CEGUIListboxTextItem.h>
 
 #include "GameObjectWindow.h"
@@ -77,7 +78,7 @@
         for( PropertyMap::const_iterator propIter = props->begin();
             propIter != props->end(); propIter++ )
         {
-            CEGUI::String key = propIter->first;
+            Ogre::String key = propIter->first;
             
             if( key == "description" || key == "name" )
                 continue;
@@ -157,7 +158,7 @@
     //------------------------------------------------------- addPropertyInt
 
     void GameObjectWindow::addPropertyInt(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -178,6 +179,7 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Int  "), 0, rowCount);
             table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
                 1, 
@@ -188,7 +190,7 @@
     //------------------------------------------------------- addPropertyIntPair
 
     void GameObjectWindow::addPropertyIntPair(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -205,19 +207,20 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
-            table->setItem(new ListboxTextItem( 
+            table->setItem(new ListboxTextItem( "( " + 
                 PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second)), 
+                PropertyHelper::intToString(intPair.second) + " )"), 
                 2, 
                 rowCount);
         }
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(
+            table->setItem(new ListboxTextItem("( " + 
                 PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second)), 
+                PropertyHelper::intToString(intPair.second) + " )"), 
                 1, 
                 rowCount);
         }
@@ -226,7 +229,7 @@
     //------------------------------------------------------- addPropertyIntTriple
 
     void GameObjectWindow::addPropertyIntTriple(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -243,21 +246,22 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("IntTriple  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(
+            table->setItem(new ListboxTextItem("( " +
                 PropertyHelper::intToString(intTriple.first) + ", " +
                 PropertyHelper::intToString(intTriple.second) + ", " +
-                PropertyHelper::intToString(intTriple.third)),
+                PropertyHelper::intToString(intTriple.third) + " )"),
                 2, 
                 rowCount);
         }
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("IntTriple  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(
+            table->setItem(new ListboxTextItem("( " +
                 PropertyHelper::intToString(intTriple.first) + ", " +
                 PropertyHelper::intToString(intTriple.second) + ", " +
-                PropertyHelper::intToString(intTriple.third)), 
+                PropertyHelper::intToString(intTriple.third) + " )"), 
                 1, 
                 rowCount);
         } 
@@ -266,7 +270,7 @@
     //------------------------------------------------------- addPropertyString
 
     void GameObjectWindow::addPropertyString(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -279,7 +283,7 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("String  "), 1, rowCount);
+            table->setItem(new ListboxTextItem("String    "), 1, rowCount);
             table->setItem(new ListboxTextItem(prop.toString()), 
                 2, 
                 rowCount);
@@ -287,7 +291,8 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
-            table->setItem(new ListboxTextItem("String  "), 0, rowCount);
+            table->addRow(rowCount);
+            table->setItem(new ListboxTextItem("String    "), 0, rowCount);
             table->setItem(new ListboxTextItem(prop.toString()), 
                 1, 
                 rowCount);
@@ -297,7 +302,7 @@
     //------------------------------------------------------- addPropertyBool
 
     void GameObjectWindow::addPropertyBool(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -318,6 +323,7 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Bool  "), 0, rowCount);
             table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
                 1, 
@@ -328,7 +334,7 @@
     //------------------------------------------------------- addPropertyReal
 
     void GameObjectWindow::addPropertyReal(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
        // Check column count
         // if count = 3 | MainTable
@@ -349,6 +355,7 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
             table->setItem(new ListboxTextItem(PropertyHelper::floatToString(prop.toReal())), 
                 1, 
@@ -359,7 +366,7 @@
     //------------------------------------------------------- addPropertyVector3
 
     void GameObjectWindow::addPropertyVector3(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -395,6 +402,7 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
             table->setItem(new ListboxTextItem("X " + PropertyHelper::floatToString(vec.x)), 
                 1, 
@@ -417,7 +425,7 @@
     //------------------------------------------------------- addPropertyQuaternion
 
     void GameObjectWindow::addPropertyQuaternion(const Property& prop, 
-        CEGUI::MultiColumnList* table, const CEGUI::String& key)
+        CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
         // if count = 3 | MainTable
@@ -426,7 +434,7 @@
         int rowCount = table->getRowCount();
 
         Ogre::Quaternion quat = prop.toQuaternion();
-        Ogre::Radian angle;
+        Ogre::Degree angle;
         Ogre::Vector3 axis;
 
         quat.ToAngleAxis( angle, axis );
@@ -447,7 +455,7 @@
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Radian " + 
+            table->setItem(new ListboxTextItem("Degree " + 
                 PropertyHelper::floatToString(angle.valueRadians())), 
                 2, 
                 rowCount + 1);
@@ -455,6 +463,7 @@
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
+            table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Quaternion  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Axis " +
                 PropertyHelper::floatToString(axis.x) + ", " +
@@ -465,7 +474,7 @@
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Radian " + 
+            table->setItem(new ListboxTextItem("Degree " + 
                 PropertyHelper::floatToString(angle.valueRadians())), 
                 2, 
                 rowCount + 1);
@@ -475,19 +484,29 @@
 
     //------------------------------------------------------- addPropertyArray
 
-    void GameObjectWindow::addPropertyArray(const Property& prop, const CEGUI::String& key)
+    void GameObjectWindow::addPropertyArray(const Property& prop, const Ogre::String& key)
     {
         // Create the new MultiColumnList with two columns
         // Type and Value and set tab text to key
         int tabCount = mTabPane->getTabCount();
-        CEGUI::MultiColumnList* newTable = new MultiColumnList(
-            "RastullahLook/MultiColumnList",
-            "GameObjectWindow/PropertiesTabControl/PropertyTab_" + 
-            CEGUI::PropertyHelper::intToString(tabCount) );
+        CEGUI::MultiColumnList* newTable = static_cast<CEGUI::MultiColumnList*>
+            (CEGUI::WindowManager::getSingleton().createWindow("RastullahLook/MultiColumnList", 
+            "GameObjectWindow/PropertiesTabControl/" + key));
+
+        // Set table properties
         newTable->setText(key);
+        newTable->setPosition(CEGUI::UVector2( 
+            CEGUI::UDim(0,0), 
+            CEGUI::UDim(0,0)));
+        newTable->setSize(CEGUI::UVector2(
+            CEGUI::UDim(1,0), 
+            CEGUI::UDim(1,0)));
+        newTable->setUserSortControlEnabled(false);
+        newTable->setFont("Vera Serif-8");
+
         newTable->addColumn("Type", 0, cegui_reldim(0.3));
         newTable->addColumn("Value", 1, cegui_reldim(0.7));
-        
+
         // Add the MultiColumnList to the tab pane
         mTabPane->addTab(newTable);
 



From vincent22 at mail.berlios.de  Sun Mar 11 18:22:39 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 18:22:39 +0100
Subject: [Dsa-hl-svn] r3168 - modules/common/gui/windows
Message-ID: <200703111722.l2BHMdeg023840@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 18:22:21 +0100 (Sun, 11 Mar 2007)
New Revision: 3168

Modified:
   modules/common/gui/windows/gameobjectwindow.xml
Log:
Changed the font size of the GameObject window.

Modified: modules/common/gui/windows/gameobjectwindow.xml
===================================================================
--- modules/common/gui/windows/gameobjectwindow.xml	2007-03-11 17:21:33 UTC (rev 3167)
+++ modules/common/gui/windows/gameobjectwindow.xml	2007-03-11 17:22:21 UTC (rev 3168)
@@ -63,7 +63,7 @@
        	 		<Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
        	 		<Property Name="Text" Value="Eigenschaften"/>
        	 		<Property Name="SortSettingEnabled" Value="False"/>
-       	 		<Property Name="Font" Value="Vera Serif Bold-8"/>
+       	 		<Property Name="Font" Value="Vera Serif-8"/>
        	 		<Property Name="FrameEnabled" Value="False"/>
     		</Window>   	
        	 	 	



From zero-gravity at mail.berlios.de  Sun Mar 11 19:25:38 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Sun, 11 Mar 2007 19:25:38 +0100
Subject: [Dsa-hl-svn] r3169 - in modules: aitest/models combattest/maps
	combattest/models common/models intro/maps minidemo/maps
	regressiontest/maps regressiontest/models ruchin/maps
	ruchin/materials ruchin/models techdemo/maps techdemo/models
	techdemo2/models tutorial/maps tutorial/models
Message-ID: <200703111825.l2BIPc3o007489@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-11 19:10:13 +0100 (Sun, 11 Mar 2007)
New Revision: 3169

Modified:
   modules/aitest/models/tie_wolf_01.mesh
   modules/combattest/maps/combattest_floorplane.mesh
   modules/combattest/models/cube.1m-2m-1m.mesh
   modules/combattest/models/cube.1m.mesh
   modules/combattest/models/nx.chair.mesh
   modules/combattest/models/nx.convex1.mesh
   modules/combattest/models/nx.crosshair.mesh
   modules/combattest/models/nx.raycaster.mesh
   modules/combattest/models/nx.stairs1.mesh
   modules/combattest/models/nx.trafficcone.mesh
   modules/combattest/models/sphere.1m.mesh
   modules/combattest/models/tie_wolf_01.mesh
   modules/common/models/arc_Laden.mesh
   modules/common/models/arc_UnbHaus_01.mesh
   modules/common/models/arc_UnbHaus_02.mesh
   modules/common/models/arc_UnbHaus_04.mesh
   modules/common/models/arc_UnbHaus_05.mesh
   modules/common/models/arc_UnbHaus_06.mesh
   modules/common/models/arc_UnbHaus_07.mesh
   modules/common/models/arc_UnbHaus_08.mesh
   modules/common/models/arc_Unbhaus_03.mesh
   modules/common/models/arc_Wirtshaus_01.mesh
   modules/common/models/arc_Wirtshaus_02.mesh
   modules/common/models/arc_bett_01.mesh
   modules/common/models/arc_boronsrad.mesh
   modules/common/models/arc_bruecke_01.mesh
   modules/common/models/arc_brunnen_01.mesh
   modules/common/models/arc_door_02.mesh
   modules/common/models/arc_eckbank_01.mesh
   modules/common/models/arc_fackel_01.mesh
   modules/common/models/arc_hebel_01.mesh
   modules/common/models/arc_ingerimmschrein_01.mesh
   modules/common/models/arc_kiste_gross.mesh
   modules/common/models/arc_kiste_gross_offen.mesh
   modules/common/models/arc_kommode_01.mesh
   modules/common/models/arc_nachtkasten_01.mesh
   modules/common/models/arc_regal_01.mesh
   modules/common/models/arc_schaukelstuhl_01.mesh
   modules/common/models/arc_schrank_01.mesh
   modules/common/models/arc_schreibtisch_01.mesh
   modules/common/models/arc_stall_01.mesh
   modules/common/models/arc_stuhl_01.mesh
   modules/common/models/arc_tisch_01.mesh
   modules/common/models/arc_tisch_02.mesh
   modules/common/models/arc_tuer_01.mesh
   modules/common/models/arc_wassermuehle_01.mesh
   modules/common/models/arc_zaun_01.mesh
   modules/common/models/arc_zaun_kaputt.mesh
   modules/common/models/bank.mesh
   modules/common/models/bett.mesh
   modules/common/models/books.mesh
   modules/common/models/bottich.mesh
   modules/common/models/door01.mesh
   modules/common/models/eckbank.mesh
   modules/common/models/getreide.mesh
   modules/common/models/grasplane.mesh
   modules/common/models/held.mesh
   modules/common/models/herkulesstaude.mesh
   modules/common/models/hocker.mesh
   modules/common/models/ins_fackel_01.mesh
   modules/common/models/ins_schaufel_01.mesh
   modules/common/models/kiste.mesh
   modules/common/models/kurbis.mesh
   modules/common/models/men_Gennisch.mesh
   modules/common/models/men_alrike.mesh
   modules/common/models/men_wirt.mesh
   modules/common/models/nat_baum_01.mesh
   modules/common/models/nat_baum_02.mesh
   modules/common/models/nat_baum_03.mesh
   modules/common/models/nat_baum_mittel_02.mesh
   modules/common/models/nat_baum_shadix_01.mesh
   modules/common/models/nat_blume_01.mesh
   modules/common/models/nat_blume_weis.mesh
   modules/common/models/nat_busch_klein.mesh
   modules/common/models/nat_busch_shadix_01.mesh
   modules/common/models/nat_busch_stachlig.mesh
   modules/common/models/nat_eiche_gelb.mesh
   modules/common/models/nat_eiche_gruen.mesh
   modules/common/models/nat_eiche_kahl.mesh
   modules/common/models/nat_eichenstumpf.mesh
   modules/common/models/nat_einbeere.mesh
   modules/common/models/nat_farn_01.mesh
   modules/common/models/nat_farn_02.mesh
   modules/common/models/nat_flaechengras_01.mesh
   modules/common/models/nat_gras_01.mesh
   modules/common/models/nat_gras_02.mesh
   modules/common/models/nat_gras_03.mesh
   modules/common/models/nat_grasplane_01.mesh
   modules/common/models/nat_salat_01.mesh
   modules/common/models/nat_stein02_mittel.mesh
   modules/common/models/nat_stein_01.mesh
   modules/common/models/nat_stein_gross_01.mesh
   modules/common/models/nat_stein_klein_01.mesh
   modules/common/models/nat_steinpilz_gross.mesh
   modules/common/models/nat_steinpilz_klein.mesh
   modules/common/models/ns_hackstock_01.mesh
   modules/common/models/obj_heiltrank01.mesh
   modules/common/models/regal.mesh
   modules/common/models/schreibtisch.mesh
   modules/common/models/stuhl.mesh
   modules/common/models/ter_ingerimmschrein_01.mesh
   modules/common/models/ter_waldboden.mesh
   modules/common/models/tie_greifvogel.mesh
   modules/common/models/tie_waldspinne.mesh
   modules/common/models/tutbaum2.mesh
   modules/common/models/urbaum.mesh
   modules/common/models/ver_becher_01.mesh
   modules/common/models/ver_bild_01.mesh
   modules/common/models/ver_brotzeit_01.mesh
   modules/common/models/ver_buch_01.mesh
   modules/common/models/ver_buch_02.mesh
   modules/common/models/ver_essigbottich_01.mesh
   modules/common/models/ver_fass_01.mesh
   modules/common/models/ver_holzscheit_01.mesh
   modules/common/models/ver_kaese_01.mesh
   modules/common/models/ver_kaestchen_01.mesh
   modules/common/models/ver_karaffe_01.mesh
   modules/common/models/ver_kerze_01.mesh
   modules/common/models/ver_kiste_01.mesh
   modules/common/models/ver_korb_01.mesh
   modules/common/models/ver_laterne_01.mesh
   modules/common/models/ver_pergament_01.mesh
   modules/common/models/ver_rattenpaket_01.mesh
   modules/common/models/ver_rinderfell_01.mesh
   modules/common/models/ver_sack_03.mesh
   modules/common/models/ver_schmuckkasten_01.mesh
   modules/common/models/ver_schreibzeug_01.mesh
   modules/common/models/ver_symbol_travia_01.mesh
   modules/common/models/ver_topf_01.mesh
   modules/common/models/ver_truhe_gross01.mesh
   modules/common/models/ver_vase_01.mesh
   modules/common/models/ver_weinflasche_01.mesh
   modules/common/models/ver_zimmerpflanze_01.mesh
   modules/common/models/waf_kurzschwert_01.mesh
   modules/common/models/waf_sense_01.mesh
   modules/intro/maps/wueste.mesh
   modules/minidemo/maps/minidemo.mesh
   modules/regressiontest/maps/regressiontest_floorplane.mesh
   modules/regressiontest/models/cube.1m-2m-1m.mesh
   modules/regressiontest/models/cube.1m.mesh
   modules/regressiontest/models/ins_rucksack.mesh
   modules/regressiontest/models/nx.chair.mesh
   modules/regressiontest/models/nx.convex1.mesh
   modules/regressiontest/models/nx.crosshair.mesh
   modules/regressiontest/models/nx.raycaster.mesh
   modules/regressiontest/models/nx.stairs1.mesh
   modules/regressiontest/models/nx.trafficcone.mesh
   modules/regressiontest/models/sphere.1m.mesh
   modules/ruchin/maps/Plane.003.mesh
   modules/ruchin/maps/Plane.014.mesh
   modules/ruchin/maps/Plane.mesh
   modules/ruchin/maps/nat_busch_01.mesh
   modules/ruchin/maps/nat_farn_01_dark.mesh
   modules/ruchin/maps/nat_nadelbaum_02.mesh
   modules/ruchin/maps/nat_nadelbaum_03.mesh
   modules/ruchin/maps/ruchin_haus_02.mesh
   modules/ruchin/maps/ruchin_haus_03.mesh
   modules/ruchin/materials/nat_nadelbaum_02.mesh
   modules/ruchin/materials/nat_nadelbaum_02_lod.mesh
   modules/ruchin/materials/nat_nadelbaum_03.mesh
   modules/ruchin/materials/nat_nadelbaum_03_lod.mesh
   modules/ruchin/models/Plane.003.mesh
   modules/ruchin/models/Plane.014.mesh
   modules/ruchin/models/Plane.mesh
   modules/ruchin/models/Ruchin_Stadtwache.mesh
   modules/ruchin/models/Ruchin_l.mesh
   modules/ruchin/models/Ruchin_l_innen.mesh
   modules/ruchin/models/Ruchin_m.mesh
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchin_n.mesh
   modules/ruchin/models/Ruchin_p.mesh
   modules/ruchin/models/Ruchin_r.mesh
   modules/ruchin/models/Ruchin_s.mesh
   modules/ruchin/models/Ruchin_v.mesh
   modules/ruchin/models/Stadtmauer.mesh
   modules/ruchin/models/arc_door_tavern.mesh
   modules/ruchin/models/dome.mesh
   modules/ruchin/models/dome_clouds_far.mesh
   modules/ruchin/models/dome_clouds_near.mesh
   modules/ruchin/models/dome_sun.mesh
   modules/ruchin/models/nat_baum_shadix_03.mesh
   modules/ruchin/models/nat_busch_01.mesh
   modules/ruchin/models/nat_farn_01_dark.mesh
   modules/ruchin/models/nat_fels_01.mesh
   modules/ruchin/models/nat_flaechengras_01.mesh
   modules/ruchin/models/nat_fliegenpilz_01.mesh
   modules/ruchin/models/nat_getreide_01.mesh
   modules/ruchin/models/nat_loewenzahn_01.mesh
   modules/ruchin/models/nat_nadelbaum_02.mesh
   modules/ruchin/models/nat_nadelbaum_02_lod.mesh
   modules/ruchin/models/nat_nadelbaum_03.mesh
   modules/ruchin/models/nat_nadelbaum_03_lod.mesh
   modules/ruchin/models/ruchin_haus_02.mesh
   modules/ruchin/models/ruchin_haus_03.mesh
   modules/ruchin/models/ver_lagerfeuer01_an.mesh
   modules/techdemo/maps/techdemo_terrain.mesh
   modules/techdemo/models/Steinhaufen.mesh
   modules/techdemo/models/men_wirt_posed.mesh
   modules/techdemo/models/obj_heiltrank01.mesh
   modules/techdemo2/models/Techdemo2.mesh
   modules/techdemo2/models/Techdemo2_map2.mesh
   modules/techdemo2/models/arc_UnbHaus_08_td2.mesh
   modules/techdemo2/models/arc_UnbHaus_08_td2_boden.mesh
   modules/techdemo2/models/arc_Wachturm_01.mesh
   modules/techdemo2/models/arc_begeHaus_01.mesh
   modules/techdemo2/models/arc_bett_02.mesh
   modules/techdemo2/models/arc_ruin_01.mesh
   modules/techdemo2/models/arc_ruin_02.mesh
   modules/techdemo2/models/arc_ruin_03.mesh
   modules/techdemo2/models/arc_ruin_04.mesh
   modules/techdemo2/models/arc_treppenhilfe_01.mesh
   modules/techdemo2/models/baumstammcoli.mesh
   modules/techdemo2/models/col_TD2_map1.mesh
   modules/techdemo2/models/coli_Techdemo2_map2.mesh
   modules/techdemo2/models/coli_arc_Wachturm_01.mesh
   modules/techdemo2/models/fx_steingischt_01.mesh
   modules/techdemo2/models/men_druide.mesh
   modules/techdemo2/models/men_gennisch2.mesh
   modules/techdemo2/models/men_grim.mesh
   modules/techdemo2/models/men_sonja.mesh
   modules/techdemo2/models/nat_TD2Fluss.mesh
   modules/techdemo2/models/nat_baum_shadix_03.mesh
   modules/techdemo2/models/nat_brunnenwasser.mesh
   modules/techdemo2/models/nat_busch_01.mesh
   modules/techdemo2/models/nat_farn_01_dark.mesh
   modules/techdemo2/models/nat_fels_01.mesh
   modules/techdemo2/models/nat_fliegenpilz_01.mesh
   modules/techdemo2/models/nat_getreide_01.mesh
   modules/techdemo2/models/nat_loewenzahn_01.mesh
   modules/techdemo2/models/nat_nadelbaum_02.mesh
   modules/techdemo2/models/nat_nadelbaum_02_lod.mesh
   modules/techdemo2/models/nat_nadelbaum_03.mesh
   modules/techdemo2/models/nat_nadelbaum_03_lod.mesh
   modules/techdemo2/models/nat_wasser_techdemo2.mesh
   modules/techdemo2/models/ter_TD2_map2_part_01.mesh
   modules/techdemo2/models/ter_TD2_map2_part_01_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_02.mesh
   modules/techdemo2/models/ter_TD2_map2_part_02_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_03.mesh
   modules/techdemo2/models/ter_TD2_map2_part_03_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_04.mesh
   modules/techdemo2/models/ter_TD2_map2_part_04_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_05.mesh
   modules/techdemo2/models/ter_TD2_map2_part_06.mesh
   modules/techdemo2/models/ter_TD2_map2_part_07.mesh
   modules/techdemo2/models/ter_TD2_map2_part_08.mesh
   modules/techdemo2/models/ter_TD2_map2_part_09.mesh
   modules/techdemo2/models/ter_feld.mesh
   modules/techdemo2/models/tie_hase_braun.mesh
   modules/techdemo2/models/tie_schmetterling_01.mesh
   modules/techdemo2/models/tie_schmetterling_02.mesh
   modules/techdemo2/models/tie_wolf_01.mesh
   modules/techdemo2/models/towerplaceholder.mesh
   modules/techdemo2/models/ver_stein_turm.mesh
   modules/tutorial/maps/DialogLevel.mesh
   modules/tutorial/models/men_gennisch2.mesh
Log:


Modified: modules/aitest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/maps/combattest_floorplane.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/cube.1m.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.chair.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.convex1.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.crosshair.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.raycaster.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.stairs1.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/nx.trafficcone.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/sphere.1m.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Laden.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_04.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_05.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_06.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_07.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_08.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Unbhaus_03.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Wirtshaus_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Wirtshaus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_bett_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_boronsrad.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_bruecke_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_brunnen_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_door_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_eckbank_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_fackel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_hebel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_ingerimmschrein_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_kiste_gross.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_kiste_gross_offen.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_kommode_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_nachtkasten_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_regal_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schaukelstuhl_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schrank_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schreibtisch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_stall_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_stuhl_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_tisch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_tisch_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_tuer_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_wassermuehle_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_zaun_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_zaun_kaputt.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/bank.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/bett.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/books.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/bottich.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/door01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/eckbank.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/getreide.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/grasplane.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/held.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/herkulesstaude.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/hocker.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ins_fackel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ins_schaufel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/kiste.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/kurbis.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_Gennisch.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_alrike.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_wirt.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_mittel_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_shadix_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_blume_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_blume_weis.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_busch_klein.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_busch_shadix_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_busch_stachlig.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_eiche_gelb.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_eiche_gruen.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_eiche_kahl.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_eichenstumpf.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_einbeere.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_farn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_farn_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_flaechengras_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_gras_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_gras_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_gras_03.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_grasplane_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_salat_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_stein02_mittel.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_stein_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_stein_gross_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_stein_klein_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_steinpilz_gross.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_steinpilz_klein.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ns_hackstock_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/obj_heiltrank01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/regal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/schreibtisch.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/stuhl.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ter_ingerimmschrein_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ter_waldboden.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/tie_greifvogel.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/tie_waldspinne.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/tutbaum2.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/urbaum.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_becher_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_bild_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_brotzeit_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_buch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_buch_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_essigbottich_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_fass_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_holzscheit_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kaese_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kaestchen_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_karaffe_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kerze_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kiste_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_korb_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_laterne_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_pergament_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_rattenpaket_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_rinderfell_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_sack_03.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_schmuckkasten_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_schreibzeug_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_symbol_travia_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_topf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_truhe_gross01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_vase_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_weinflasche_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_zimmerpflanze_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/waf_sense_01.mesh
===================================================================
(Binary files differ)

Modified: modules/intro/maps/wueste.mesh
===================================================================
(Binary files differ)

Modified: modules/minidemo/maps/minidemo.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/maps/regressiontest_floorplane.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/cube.1m.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/ins_rucksack.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.chair.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.convex1.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.crosshair.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.raycaster.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.stairs1.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/nx.trafficcone.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/sphere.1m.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/Plane.003.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/Plane.014.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/Plane.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/nat_busch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/nat_farn_01_dark.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/ruchin_haus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/ruchin_haus_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Plane.003.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Plane.014.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Plane.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_Stadtwache.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_l.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_l_innen.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_m.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_n.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_p.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_s.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_v.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Stadtmauer.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/arc_door_tavern.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_clouds_far.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_clouds_near.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_sun.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_baum_shadix_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_busch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_farn_01_dark.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_fels_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_flaechengras_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_fliegenpilz_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_getreide_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_loewenzahn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ruchin_haus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ruchin_haus_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ver_lagerfeuer01_an.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo/maps/techdemo_terrain.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo/models/Steinhaufen.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo/models/men_wirt_posed.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo/models/obj_heiltrank01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/Techdemo2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/Techdemo2_map2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_UnbHaus_08_td2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_UnbHaus_08_td2_boden.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_Wachturm_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_begeHaus_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_bett_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_04.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_treppenhilfe_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/baumstammcoli.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/col_TD2_map1.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/coli_Techdemo2_map2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/coli_arc_Wachturm_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/fx_steingischt_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_druide.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_gennisch2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_grim.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_sonja.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_TD2Fluss.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_baum_shadix_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_brunnenwasser.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_busch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_farn_01_dark.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_fels_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_fliegenpilz_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_getreide_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_loewenzahn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_wasser_techdemo2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_01_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_04.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_04_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_05.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_06.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_07.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_08.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_09.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_feld.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_hase_braun.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_schmetterling_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_schmetterling_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/towerplaceholder.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ver_stein_turm.mesh
===================================================================
(Binary files differ)

Modified: modules/tutorial/maps/DialogLevel.mesh
===================================================================
(Binary files differ)

Modified: modules/tutorial/models/men_gennisch2.mesh
===================================================================
(Binary files differ)



From vincent22 at mail.berlios.de  Sun Mar 11 20:15:11 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 20:15:11 +0100
Subject: [Dsa-hl-svn] r3170 - rl/trunk/engine/ui/src
Message-ID: <200703111915.l2BJFBlt010529@sheep.berlios.de>

Author: vincent22
Date: 2007-03-11 20:15:07 +0100 (Sun, 11 Mar 2007)
New Revision: 3170

Modified:
   rl/trunk/engine/ui/src/GameObjectWindow.cpp
Log:
The floating numbers are formatted now.

Modified: rl/trunk/engine/ui/src/GameObjectWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 18:10:13 UTC (rev 3169)
+++ rl/trunk/engine/ui/src/GameObjectWindow.cpp	2007-03-11 19:15:07 UTC (rev 3170)
@@ -342,13 +342,16 @@
         int colCount = table->getColumnCount();
         int rowCount = table->getRowCount();
 
+        char buf [50];
+        sprintf(buf, "%1.2f", prop.toReal());
+
         // Table has the three columns Key, Type, Value
         if ( colCount == 3 )
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Real  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::floatToString(prop.toReal())), 
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
                 2, 
                 rowCount);
         }
@@ -357,7 +360,7 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::floatToString(prop.toReal())), 
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
                 1, 
                 rowCount);
         }
@@ -376,6 +379,13 @@
 
         Ogre::Vector3 vec = prop.toVector3();
 
+        char buf1 [50];
+        sprintf(buf1, "%1.2f", vec.x);
+        char buf2 [50];
+        sprintf(buf2, "%1.2f", vec.y);
+        char buf3 [50];
+        sprintf(buf3, "%1.2f", vec.z);
+
         // Table has the three columns Key, Type, Value
         if ( colCount == 3 )
         {
@@ -383,42 +393,22 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Vector3  "), 1, rowCount);
-            table->setItem(new ListboxTextItem("X " + PropertyHelper::floatToString(vec.x)), 
-                2, 
+            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
+                CEGUI::String(buf2) + ", " +
+                CEGUI::String(buf3) + " )"), 
+                2 , 
                 rowCount);
-
-            // Add second for the second IntTriple value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Y " + PropertyHelper::floatToString(vec.y)), 
-                2, 
-                rowCount + 1);
-
-            // Add third for the third IntTriple value
-            table->addRow(rowCount + 2);
-            table->setItem(new ListboxTextItem("Z " + PropertyHelper::floatToString(vec.z)), 
-                2, 
-                rowCount + 2);
         }
         // Table has the two columns Type, Value
         else if ( colCount == 2 )
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("X " + PropertyHelper::floatToString(vec.x)), 
-                1, 
+            table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
+                CEGUI::String(buf2) + ", " +
+                CEGUI::String(buf3) + " )"), 
+                1 , 
                 rowCount);
-
-            // Add second for the second IntPair value
-            table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Y " + PropertyHelper::floatToString(vec.y)), 
-                2, 
-                rowCount + 1);
-
-            // Add third for the third IntTriple value
-            table->addRow(rowCount + 2);
-            table->setItem(new ListboxTextItem("Z " + PropertyHelper::floatToString(vec.z)), 
-                2, 
-                rowCount + 2);
         } 
     }
 
@@ -439,6 +429,15 @@
 
         quat.ToAngleAxis( angle, axis );
 
+        char buf_angle [50];
+        sprintf(buf_angle, "%1.2f", angle.valueDegrees());
+        char buf_v1 [50];
+        sprintf(buf_v1, "%1.2f", axis.x);
+        char buf_v2 [50];
+        sprintf(buf_v2, "%1.2f", axis.y);
+        char buf_v3 [50];
+        sprintf(buf_v3, "%1.2f", axis.z);
+
         // Table has the three columns Key, Type, Value
         if ( colCount == 3 )
         {
@@ -446,17 +445,17 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Quaternion  "), 1, rowCount);
-            table->setItem(new ListboxTextItem("Axis " +
-                PropertyHelper::floatToString(axis.x) + ", " +
-                PropertyHelper::floatToString(axis.y) + ", " +
-                PropertyHelper::floatToString(axis.z)), 
+            table->setItem(new ListboxTextItem("Axis:   ( " +
+                CEGUI::String(buf_v1) + ", " +
+                CEGUI::String(buf_v2) + ", " +
+                CEGUI::String(buf_v3) + " )"), 
                 2, 
                 rowCount);
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Degree " + 
-                PropertyHelper::floatToString(angle.valueRadians())), 
+            table->setItem(new ListboxTextItem("Degree: " + 
+                CEGUI::String(buf_angle)), 
                 2, 
                 rowCount + 1);
         }
@@ -465,17 +464,17 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Quaternion  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("Axis " +
-                PropertyHelper::floatToString(axis.x) + ", " +
-                PropertyHelper::floatToString(axis.y) + ", " +
-                PropertyHelper::floatToString(axis.z)), 
+            table->setItem(new ListboxTextItem("Axis:   ( " +
+                CEGUI::String(buf_v1) + ", " +
+                CEGUI::String(buf_v2) + ", " +
+                CEGUI::String(buf_v3) + " )"), 
                 2, 
                 rowCount);
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
             table->setItem(new ListboxTextItem("Degree " + 
-                PropertyHelper::floatToString(angle.valueRadians())), 
+                CEGUI::String(buf_angle)), 
                 2, 
                 rowCount + 1);
         } 



From zero-gravity at mail.berlios.de  Sun Mar 11 20:25:52 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Sun, 11 Mar 2007 20:25:52 +0100
Subject: [Dsa-hl-svn] r3171 - modules/common/models
Message-ID: <200703111925.l2BJPqXr011026@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-11 20:25:45 +0100 (Sun, 11 Mar 2007)
New Revision: 3171

Modified:
   modules/common/models/men_alrike.mesh
Log:


Modified: modules/common/models/men_alrike.mesh
===================================================================
(Binary files differ)



From no22 at mail.berlios.de  Sun Mar 11 20:45:43 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Sun, 11 Mar 2007 20:45:43 +0100
Subject: [Dsa-hl-svn] r3172 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200703111945.l2BJjhBp011904@sheep.berlios.de>

Author: no22
Date: 2007-03-11 20:45:31 +0100 (Sun, 11 Mar 2007)
New Revision: 3172

Removed:
   rl/trunk/engine/rules/include/AtomicEffect.h
   rl/trunk/engine/rules/include/CompositeEffect.h
   rl/trunk/engine/rules/src/AtomicEffect.cpp
   rl/trunk/engine/rules/src/CompositeEffect.cpp
Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
* Creature::getStatus() should work now
* removed deprecated AtomicEffect and Composite effect (VS files need to 
be updated!)
* Effects can now wear off after a gifen time or to a given date



Deleted: rl/trunk/engine/rules/include/AtomicEffect.h
===================================================================
--- rl/trunk/engine/rules/include/AtomicEffect.h	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/AtomicEffect.h	2007-03-11 19:45:31 UTC (rev 3172)
@@ -1,40 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __AtomicEffect_H__
-#define __AtomicEffect_H__
-
-#include "Effect.h"
-
-namespace rl
-{
-
-	class _RlRulesExport AtomicEffect : public Effect
-	{
-	public:
-		AtomicEffect();
-		virtual ~AtomicEffect();
-
-		virtual void check();
-	protected:
-		/// Bringt die Aenderungen ein.
-		virtual void apply();
-		/// Entfernt die Aenderungen.
-		virtual void remove();
-	};
-}
-
-#endif //__AtomicEffect_H__

Deleted: rl/trunk/engine/rules/include/CompositeEffect.h
===================================================================
--- rl/trunk/engine/rules/include/CompositeEffect.h	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/CompositeEffect.h	2007-03-11 19:45:31 UTC (rev 3172)
@@ -1,46 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __COMPOSITEEFFECT_H__
-#define __COMPOSITEEFFECT_H__
-
-#include "Effect.h"
-#include <vector>
-
-namespace rl
-{
-
-	class _RlRulesExport CompositeEffect : public Effect
-	{
-	public:
-		CompositeEffect();
-		virtual ~CompositeEffect();
-
-		/// F?gt einen Effekt zur Liste hinzu.
-		void addEffect(Effect* effect);
-		/// ?berpr?ft die Lebendigkeit des Effekts.
-		virtual void check();
-	protected:
-		/// Bringt die Aenderungen ein.
-		void apply();
-		/// Entfernt die Aenderungen.
-		void remove();
-		typedef std::set<Effect*> Effects;
-		Effects mEffects;
-	};
-}
-
-#endif //__COMPOSITEEFFECT_H__

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-11 19:45:31 UTC (rev 3172)
@@ -519,112 +519,7 @@
              **/
             Effect::Status getStatus();
 
-            /**
-             *  @todo Weitere denkbare Zustaende: unconcious (wie sleeping, nur 
-             *   schwieriger zu wecken), petrified (paralyzed eigentlich = gelaehmt,
-             *   petrified = versteinert
-             **/
 
-            /// Checks if the creature is currently blind.
-            bool isBlind();
-            /**
-             *  Set the creature to blind / not blind. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setBlind(bool value);
-            /// Checks if the creature is dead.
-            bool isDead();
-            /**
-             *  Set the creature to dead / alive. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setDead(bool value);
-            /// Checks if the creature is currently deaf.
-            bool isDeaf();
-            /**
-             *  Set the creature to deaf / not deaf. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setDeaf(bool value);
-            /**
-             *  Checks if the creature is currently incapacitated.
-             *  This happens usually if the creature's @ref abbenv "VI" (de: 
-             *  @ref abbdel "LE") falls below the value of 
-             *  WERT_KAMPFUNFAEHIGKEITSSCHWELLE.
-             *  @see Wert
-             **/
-            bool isIncapacitated();
-            /**
-             *  Set the creature to incapacitated / not incapacitated. This status 
-             *  works with reference counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setIncapacitated(bool value);
-            /// Checks if the creature is currently invisible.
-            bool isInvisible();
-            /**
-             *  Set the creature to invisible / visible. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setInvisible(bool value);
-            /// Checks if the creature is currently invulnerable.
-            bool isInvulnerable();
-            /**
-             *  Set the creature to invulnerable / vulnerable. This status works with 
-             *  reference counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setInvulnerable(bool value);
-            /// Checks if the creature is currently parallyzed.
-            bool isParalyzed();
-            /**
-             *  Set the creature to paralyzed / not paralyzed. This status works with 
-             *  reference counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setParalyzed(bool value);
-            /// Checks if the creature is currently silenced.
-            bool isSilenced();
-            /**
-             *  Set the creature to silenced / not silenced. This status works with 
-             *  reference counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setSilenced(bool value);
-            /// Checks if the creature is currently sleeping.
-            bool isSleeping();
-            /**
-             *  Set the creature to sleeping / awake. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setSleeping(bool value);
-            /**
-             *  Checks if the creature is unconcious. This status works with reference
-             *  counting.
-             **/
-            bool isUnconscious();
-            /**
-             *  Set the creature to unconcious/concious. This status works with reference
-             *  counting.
-             *  @see setStatus for a detailed description of the reference system.
-             **/
-            void setUnconscious(bool value);
-            /**
-             *  Returns true if the creature cannot move. This function does not 
-             *  correspond to a certain status variable but checks several other 
-             *  stati such as isDead, isParalyzed and isSleeping.
-             **/
-            bool isImmovable();
-            /**
-             *  Checks if the creature is actively magic. This function does not 
-             *  correspond to a certain status variable but returns true if the 
-             *  modified AE is greater than zero.
-             **/
             bool isMagic();
 
 
@@ -800,9 +695,11 @@
             /**
              * Laesst einen Effekt auf der Kreatur wirken.
              * @param effect Zeiger auf den Effekt.
-                   * @ingroup CreatureRubyExports
+             * @ingroup CreatureRubyExports
              **/
             void addEffect(Effect* effect);
+            void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
+            void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
 
             virtual const Property getProperty(const Ogre::String& key) const;
             virtual void setProperty(const Ogre::String& key, const Property& value);

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/Effect.h	2007-03-11 19:45:31 UTC (rev 3172)
@@ -31,18 +31,25 @@
 	public:
         
       typedef unsigned long Status;
-      static const Status STATUS_NONE = 0;
-      static const Status STATUS_BLIND = 1;
-      static const Status STATUS_DEAD = 2;
-      static const Status STATUS_DEAF = 4;
-      static const Status STATUS_IMMOVABLE = 8;
-      static const Status STATUS_INCAPACITATED = 16;
-      static const Status STATUS_INVISIBLE = 32;
-      static const Status STATUS_INVULNERABLE = 64;
-      static const Status STATUS_PARALYZED = 128;
-      static const Status STATUS_SILENCED = 512;
-      static const Status STATUS_SLEEPING = 1024;
-      static const Status STATUS_UNCONSCIOUS = 2048;
+      static const Status STATUS_NONE           = 1<<0;
+      static const Status STATUS_BLIND          = 1<<1;   ///< The creature can't see anything.
+      static const Status STATUS_DEAD           = 1<<2;   ///< The creature is dead.
+      static const Status STATUS_DEAF           = 1<<3;   ///< The creature can't hear anything.
+      static const Status STATUS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
+      static const Status STATUS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
+      static const Status STATUS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
+      static const Status STATUS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
+      static const Status STATUS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
+      static const Status STATUS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
+      static const Status STATUS_SLEEPING       = 1<<10;  ///< The creature is asleep.
+      static const Status STATUS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
+      
+      // Meta stati
+      static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
+      
+      // other constants
+      static const int REMOVE = -1;
+      static const int PERMANENT = 0;
 
         /**
          * Spezifiziert wie oft Effekte des selben Typs gleichzeitig auf dieselbe
@@ -120,11 +127,15 @@
 		/// Macht den Effekt unwirksam.
 		virtual void disable();
 
-		/// Ueberprueft die Lebendigkeit des Effekts.
-		virtual void check();
+		/**
+         * runs a check on the effect.
+         * @return Returns the time to the next check. If REMOVE is returned, the 
+         * effect will be removed, if PERMANENT is returned, the effect lasts permanently.
+         **/
+		virtual RL_LONGLONG check();
         
         /// Returns if status is applied to the creature
-        Status getStatus();
+        virtual Status getStatus();
 
 	protected:
 		/// Bringt die Aenderungen ein.

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/EffectManager.h	2007-03-11 19:45:31 UTC (rev 3172)
@@ -52,7 +52,7 @@
          *  @throws IllegalArgumentException effect pointer is NULL
          *  @see addCheckDate Date
          **/
-        void addCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
+        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
         /**
          *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
          *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
@@ -62,13 +62,15 @@
          *  @throws IllegalArgumentException effect pointer is NULL
          *  @see addCheck, Date
          **/
-        void addCheckDate(RL_LONGLONG date, Effect* effect);
+        void addDateCheck(RL_LONGLONG date, Effect* effect);
         /**
          * Fuegt einen neuen Effekt in die Liste ein.
          * @param effect Ein Zeiger auf den einzufuegenden Effekt.
          **/
 		void addEffect(Effect* effect);
         
+        void removeEffect(Effect* effect);
+        
         /**
          * Checks the effects for the given status.
          **/

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-03-11 19:45:31 UTC (rev 3172)
@@ -1,8 +1,6 @@
 noinst_HEADERS = \
 	Action.h \
 	ActionManager.h \
-	AtomicEffect.h \
-	CompositeEffect.h \
 	Container.h \
 	Creature.h \
 	Date.h \

Deleted: rl/trunk/engine/rules/src/AtomicEffect.cpp
===================================================================
--- rl/trunk/engine/rules/src/AtomicEffect.cpp	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/AtomicEffect.cpp	2007-03-11 19:45:31 UTC (rev 3172)
@@ -1,40 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "AtomicEffect.h"
-
-namespace rl
-{
-	AtomicEffect::AtomicEffect() : Effect()
-	{
-	}
-
-	AtomicEffect::~AtomicEffect()
-	{
-	}
-
-	void AtomicEffect::check()
-	{
-	}
-
-	void AtomicEffect::apply()
-	{
-	}
-
-	void AtomicEffect::remove()
-	{
-	}
-}

Deleted: rl/trunk/engine/rules/src/CompositeEffect.cpp
===================================================================
--- rl/trunk/engine/rules/src/CompositeEffect.cpp	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/CompositeEffect.cpp	2007-03-11 19:45:31 UTC (rev 3172)
@@ -1,62 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "CompositeEffect.h"
-
-namespace rl
-{
-	CompositeEffect::CompositeEffect() : Effect()
-	{
-	}
-
-	CompositeEffect::~CompositeEffect()
-	{
-		disable();
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			delete (*it);
-		}
-	}
-
-	void CompositeEffect::addEffect(rl::Effect *effect)
-	{
-		mEffects.insert(effect);
-	}
-
-	void CompositeEffect::check()
-	{
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			(*it)->check();
-		}
-	}
-
-	void CompositeEffect::apply()
-	{
-		for (Effects::const_iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			(*it)->enable();
-		}
-	}
-
-	void CompositeEffect::remove()
-	{
-		for (Effects::const_iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			(*it)->disable();
-		}
-	}
-}

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-11 19:45:31 UTC (rev 3172)
@@ -242,7 +242,7 @@
 		if (mCurrentLe <= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &&
             oldLe > getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
 		{
-            setIncapacitated(true);
+            ///@todo set incapacitated.
 			MeshObject* mo = static_cast<MeshObject*>(getActor()->getControlledObject());
 			mo->stopAllAnimations();
             ///@todo Sturzanimation aufrufen, sobald sie verfuegbar ist.
@@ -251,12 +251,12 @@
         if (mCurrentLe <= 0 &&
             oldLe > 0)
         {
-            setUnconscious(true);
+            ///@todo set unconscious
         }
         if (mCurrentLe <= -getEigenschaft("KO") &&
             oldLe > -getEigenschaft("KO"))
         {
-            setDead(true);
+            ///@todo set dead
         }
 		fireObjectStateChangeEvent();
     }
@@ -296,7 +296,7 @@
 			mCurrentAu = min(mCurrentAu, float(getAuMax()));
         if (getAu() <= 0)
         {
-            setIncapacitated(true);
+            ///@todo set incapacitated
         }
 		fireObjectStateChangeEvent();
     }
@@ -618,78 +618,7 @@
     {
       return mEffectManager->getStatus();
     }
-    
-    bool Creature::isBlind()
-    {
-        if (mBlind > 0) return true;
-        else return false;
-    }
 
-    bool Creature::isDead()
-    {
-        if (mDead > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isDeaf()
-    {
-        if (mDeaf > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isIncapacitated()
-    {
-        if (mIncapacitated > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isInvulnerable()
-    {
-        if (mInvulnerable > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isInvisible()
-    {
-        if (mInvisible > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isParalyzed()
-    {
-        if (mParalyzed > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isSilenced()
-    {
-        if (mSilenced > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isSleeping()
-    {
-        if (mSleeping > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isUnconscious()
-    {
-        if (mUnconscious > 0) return true;
-        else return false;
-    }
-
-    bool Creature::isImmovable()
-    {
-        if (isDead() ||
-            isParalyzed() ||
-            isSleeping() ||
-            isUnconscious())
-            return true;
-        else
-            return false;
-    }
-
 	bool Creature::isMagic()
 	{
 		return getWert(WERT_MOD_AE) > 0;
@@ -714,68 +643,7 @@
         } //value == false
     }
 
-    void Creature::setBlind(bool value)
-    {
-        setStatus(mBlind, value, 
-            "Trying to remove blindness from a seeing creature.");
-    }
 
-    
-    void Creature::setDead(bool value)
-    {
-        setStatus(mDead, value, 
-            "Trying to revive a living creature.");
-    }
-    
-    void Creature::setDeaf(bool value)
-    {
-        setStatus(mDeaf, value, 
-            "Trying to remove deafness from a hearing creature.");
-    }
-    
-    void Creature::setIncapacitated(bool value)
-    {
-        setStatus(mIncapacitated, value,
-            "Trying to remove incapacitation from a non incapacitated "
-            "creature.");
-    }
-
-    void Creature::setInvisible(bool value)
-    {
-        setStatus(mInvisible, value,
-            "Trying to remove Invisibility from a visible creature.");
-    }
-    
-    void Creature::setInvulnerable(bool value)
-    {
-        setStatus(mInvulnerable, value,
-            "Trying to remove Invulnerability from a vulnerable creature.");
-    }
-    
-    void Creature::setParalyzed(bool value)
-    {
-        setStatus(mParalyzed, value,
-            "Trying to remove paralyzation from a non paralyzed creature.");
-    }
-    
-    void Creature::setSilenced(bool value)
-    {
-        setStatus(mSilenced, value,
-            "Trying to remove silence from a non silenced creature.");
-    }
-    
-    void Creature::setSleeping(bool value)
-    {
-        setStatus(mSleeping, value,
-            "Trying to awake a wake creature.");
-    }
-
-    void Creature::setUnconscious(bool value)
-    {
-        setStatus(mUnconscious, value,
-            "Trying to awake a conscious creature.");
-    }
-
     int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int spezialisierungId,
 		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
     {
@@ -1022,7 +890,7 @@
            aup = 0;
            ///@todo evtl. eine modifyErschoepfung()?
            mErschoepfung += DsaManager::getSingleton().rollD6();
-           setIncapacitated(true);
+           ///@todo set incapacitated
         }
         // bei ??beranstrengung, kostet alles doppelte Au!!!!!
         if( mErschoepfung > getEigenschaft("KO") )
@@ -1125,7 +993,20 @@
 		effect->setOwner(this);
 		mEffectManager->addEffect(effect);
 	}
+    
+    void Creature::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
+    {
+      addEffect(effect);
+      mEffectManager->addTimeCheck(time, effect);
+    }
+    
+    void Creature::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
+    {
+      addEffect(effect);
+      mEffectManager->addDateCheck(date, effect);
+    }
 
+
 	void Creature::checkEffects()
 	{
 		/// @todo Nur einmal pro Aktion ausfuehren
@@ -1185,16 +1066,14 @@
         {
             return true;
         }
-
         // kann sich die Kreatur ueberhaupt bewegen?
-        /*
-        if( isImmovable() )
-            return false;
-        */
-        ///@todo What other Stati prohibit creature  movement? Paralyzed? Inacapacitated? Sleep? etc.
-        ///@todo Jumping etc. still possible, even if immobilized.
-        if (Effect::STATUS_IMMOVABLE & getStatus())
+        ///@todo What other Stati prohibit creature  movement? Paralyzed? Incapacitated? Sleep? etc.
+        ///@todo Crouching still possible, even if immobilized.
+        if (getStatus() & Effect::STATUS_IMMOBILE)
+        {
+          //CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Immobile!\"");
           return false;
+        }
 
         if( getAu() <= 1 )
             return false;
@@ -1591,7 +1470,7 @@
                 if( lastProbeTime <= 0 || movementTypeChanged)
                 {
                 	int lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
-                    patzer = lastProbeTaW;
+                    patzer = (int)lastProbeTaW;
                     lastProbeTime = getAuMax();
                 }
                 else

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-03-11 19:45:31 UTC (rev 3172)
@@ -146,8 +146,9 @@
 		}
 	}
 
-    void Effect::check()
+    RL_LONGLONG Effect::check()
     {
+      return PERMANENT;
     }
 
 	RL_LONGLONG Effect::getTimePassed()

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-11 19:45:31 UTC (rev 3172)
@@ -17,6 +17,9 @@
 #include "EffectManager.h"
 #include "DsaManager.h"
 #include "Exception.h"
+#include "CoreSubsystem.h"
+#include "RubyInterpreter.h"
+#include "ScriptWrapper.h"
 
 namespace rl
 {
@@ -28,7 +31,8 @@
 	{
 		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
 		{
-			delete (*it);
+			//delete (*it);
+            ScriptWrapper::getSingleton().disowned(*it);
 		}
 	}
 
@@ -39,16 +43,28 @@
         if (checkIt == mChecklist.end()) return;
         while ( checkIt->first <= now )
         {
+          std::cout << "Effect check: " << checkIt->first << " now: " << now << std::endl;
             for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
             {
-                (*effIt)->check();
+                int nextCheck; 
+                nextCheck = (*effIt)->check();
+                switch (nextCheck)
+                {
+                  case Effect::REMOVE:
+                    removeEffect(*effIt);
+                    break;
+                  case Effect::PERMANENT:
+                    break;
+                  default:
+                    addTimeCheck(nextCheck, *effIt);
+                }
             }
             mChecklist.erase(checkIt);
             checkIt++;
         }
 	}
 
-    void EffectManager::addCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
+    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
     {
         // Preconditions: time > 0, effect != NULL
         if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
@@ -58,9 +74,12 @@
         RL_LONGLONG timeForCheck = now + timeUntilCheck;
         // Fuege die Summe und Effekt in die Checklist ein
         mChecklist[timeForCheck].insert(effect);
+        std::cout << "####################### Effect expires in: " << timeUntilCheck << " ms." << std::endl;
+        std::cout << "####################### Now              : " << now << std::endl;
+        std::cout << "####################### Check            : " << timeForCheck << std::endl;
     }
-
-    void EffectManager::addCheckDate(RL_LONGLONG date, Effect* effect)
+    
+    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
     {
         // Preconditions: date > now, effect != NULL
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
@@ -91,19 +110,36 @@
 				}
 			}
 		}
-		
+        CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Adding Effect \"");
+        ScriptWrapper::getSingleton().owned( effect );
 		mEffects.insert(effect);
 		effect->enable();
 	}
     
+    void EffectManager::removeEffect(Effect* effect)
+    {
+      effect->disable();
+      mEffects.erase(effect);
+      ScriptWrapper::getSingleton().disowned(effect);
+      ///@todo also remove from the check lists?
+    }
+    
     Effect::Status EffectManager::getStatus()
     {
-      Effect::Status status;
+      checkEffects();
+      Effect::Status status = 0;
       for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
       {
-        status = status | (((*it)->getStatus()));
+        //try
+        //{
+            status = status | ((*it)->getStatus());
+        //}
+        //catch (ScriptInvocationFailedException& sife)
+        //{
+        //  Logger::getSingleton().log(Logger::CORE, Logger::LL_ERROR, sife.toString() );
+        //}
       }
-      return false;
+      return status;
     }
 }
 

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-03-11 19:45:31 UTC (rev 3172)
@@ -6,8 +6,6 @@
 	Action.cpp \
 	ActionManager.cpp \
 	Armor.cpp \
-	AtomicEffect.cpp \
-	CompositeEffect.cpp \
 	Container.cpp \
 	Creature.cpp \
 	Date.cpp \

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-03-11 19:45:31 UTC (rev 3172)
@@ -22,7 +22,6 @@
 #include "Action.h"
 #include "ActionManager.h"
 #include "Armor.h"
-#include "CompositeEffect.h"
 #include "Container.h"
 #include "Creature.h"
 #include "Date.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-11 19:25:45 UTC (rev 3171)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-11 19:45:31 UTC (rev 3172)
@@ -559,18 +559,25 @@
         };
         
         typedef unsigned long Status;
-        static const Status STATUS_NONE = 0;
-        static const Status STATUS_BLIND = 1;
-        static const Status STATUS_DEAD = 2;
-        static const Status STATUS_DEAF = 4;
-        static const Status STATUS_IMMOVABLE = 8;
-        static const Status STATUS_INCAPACITATED = 16;
-        static const Status STATUS_INVISIBLE = 32;
-        static const Status STATUS_INVULNERABLE = 64;
-        static const Status STATUS_PARALYZED = 128;
-        static const Status STATUS_SILENCED = 512;
-        static const Status STATUS_SLEEPING = 1024;
-        static const Status STATUS_UNCONSCIOUS = 2048;
+        static const Status STATUS_NONE           = 1<<0;
+        static const Status STATUS_BLIND          = 1<<1;   ///< The creature can't see anything.
+        static const Status STATUS_DEAD           = 1<<2;   ///< The creature is dead.
+        static const Status STATUS_DEAF           = 1<<3;   ///< The creature can't hear anything.
+        static const Status STATUS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
+        static const Status STATUS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
+        static const Status STATUS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
+        static const Status STATUS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
+        static const Status STATUS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
+        static const Status STATUS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
+        static const Status STATUS_SLEEPING       = 1<<10;  ///< The creature is asleep.
+        static const Status STATUS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
+      
+      // Meta stati
+        static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
+      
+      // other constants
+        static const int REMOVE = -1;
+        static const int PERMANENT = 0;
 
 
 		Effect(int stufe = 1);
@@ -594,9 +601,9 @@
 		virtual void decreaseStufe();
 		virtual void enable();
 		virtual void disable();
-		virtual void check() = 0;
+		virtual RL_LONGLONG check() = 0;
 
-        Status getStatus();
+        virtual Status getStatus();
         
 	protected:
 		virtual void apply() = 0;
@@ -673,7 +680,10 @@
         rl::Inventory* getInventory();
         
 		void addEffect(Effect* effect);
-		void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
+        
+        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
         static const int LEDAMAGE_NORMAL = 0;
         static const int LEDAMAGE_FIRE = 1;
         static const int LEDAMAGE_WATER = 2;
@@ -699,20 +709,6 @@
         virtual void setProperty(const Ogre::String& key, const rl::Property& value);
 	};
 		
-	%feature("director") CompositeEffect;	
-	class CompositeEffect : public Effect
-	{
-	public:
-		CompositeEffect();
-		virtual ~CompositeEffect();
-
-		void addEffect(Effect* effect);
-		virtual void check();
-	protected:
-		void apply();
-		void remove();
-	};
-
 	%feature("director") ActionMananger;
     class ActionManager
     {



From no22 at mail.berlios.de  Mon Mar 12 04:59:20 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Mon, 12 Mar 2007 04:59:20 +0100
Subject: [Dsa-hl-svn] r3173 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200703120359.l2C3xKGq021527@sheep.berlios.de>

Author: no22
Date: 2007-03-12 04:59:16 +0100 (Mon, 12 Mar 2007)
New Revision: 3173

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
*working on further changes of the effect system.


Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-12 03:59:16 UTC (rev 3173)
@@ -293,7 +293,7 @@
              *   Gross/Kleinschreibung beachtet?).
                    *  @ingroup CreatureRubyExports
              **/
-            virtual int getEigenschaft(const CeGuiString eigenschaftName);
+            virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
             /**
              *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
              *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
@@ -790,13 +790,7 @@
             void setTaktischeBewegung(int type);
 
         protected:
-            /**
-             * Liefert den Eigenschaftswert \a eigenschaftName fuer eine 
-             * Basiswertberechnung zurueck. Manche Effekte veraendern zwar den
-             * Eigenschaftswert, nicht jedoch die Basiswerte.
-             **/
-            virtual int getEigenschaftForBasiswertCalculation(const CeGuiString eigenschaftName);
-            /**
+           /**
              *  Berechnet den Basiswert von der @ref abbdea "Astralenergie".
              **/
             virtual int getAeBasis();

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/include/Effect.h	2007-03-12 03:59:16 UTC (rev 3173)
@@ -47,6 +47,19 @@
       // Meta stati
       static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
       
+      typedef int ModType;
+      static const ModType MODTYPE_NONE         = 1 << 0;
+      static const ModType MODTYPE_WERTMOD      = 1 << 1;   ///< Modifies the actual value.
+      static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
+      static const ModType MODTYPE_WERTMULT     = 1 << 3;   ///< Will be multiplied on the value.
+      static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
+      
+      typedef unsigned long ModTag;
+      static const ModTag MODTAG_NONE           = 1 << 0;
+      static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
+      static const ModTag MODTAG_RECALCULATE    = 1 << 2;
+
+      
       // other constants
       static const int REMOVE = -1;
       static const int PERMANENT = 0;
@@ -134,8 +147,11 @@
          **/
 		virtual RL_LONGLONG check();
         
-        /// Returns if status is applied to the creature
+        /// Returns the status that is applied to the creature by this effect.
         virtual Status getStatus();
+        
+        /// Returns the modificator applied on the value specified by the parameters.
+        virtual int getMod(CeGuiString target, ModType type, ModTag tag);
 
 	protected:
 		/// Bringt die Aenderungen ein.

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/include/EffectManager.h	2007-03-12 03:59:16 UTC (rev 3173)
@@ -75,6 +75,14 @@
          * Checks the effects for the given status.
          **/
         Effect::Status getStatus();
+        
+        /**
+         * Returns the specified modificator.
+         * @param target specifies what modificator you want to get (e.g. "Athletik")
+         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
+         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
+         **/
+        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
 
 	private:
         /// Eine einfache Menge von Effekten

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-12 03:59:16 UTC (rev 3173)
@@ -119,71 +119,71 @@
 
     int Creature::getAttackeBasis()
     {
-        double es = getEigenschaftForBasiswertCalculation(E_MUT) +
-            getEigenschaftForBasiswertCalculation(E_GEWANDTHEIT) +
-            getEigenschaftForBasiswertCalculation(E_KOERPERKRAFT);
+        double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 5.0 + 0.5);
     }
 
     int Creature::getParadeBasis()
     {
-        double es = getEigenschaftForBasiswertCalculation(E_INTUITION) +
-            getEigenschaftForBasiswertCalculation(E_GEWANDTHEIT) +
-            getEigenschaftForBasiswertCalculation(E_KOERPERKRAFT);
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 5.0 + 0.5);
     }
 
     int Creature::getFernkampfBasis()
     {
-        double es = getEigenschaftForBasiswertCalculation(E_INTUITION) +
-            getEigenschaftForBasiswertCalculation(E_FINGERFERTIGKEIT) +
-            getEigenschaftForBasiswertCalculation(E_KOERPERKRAFT);
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 5.0 + 0.5);
     }
 
     int Creature::getInitiativeBasis()
     {
-        int es = 2 * getEigenschaftForBasiswertCalculation(E_MUT) +
-            getEigenschaftForBasiswertCalculation(E_INTUITION) +
-            getEigenschaftForBasiswertCalculation(E_GEWANDTHEIT);
+      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 5.0 + 0.5);
     }
 
     int Creature::getMrBasis()
     {
-        int es = getEigenschaftForBasiswertCalculation(E_MUT) +
-            getEigenschaftForBasiswertCalculation(E_KLUGHEIT) +
-            getEigenschaftForBasiswertCalculation(E_KONSTITUTION);
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 5.0 + 0.5);
     }
 
     int Creature::getLeBasis()
     {
-        int es =  2 * getEigenschaftForBasiswertCalculation(E_KONSTITUTION) +
-            getEigenschaftForBasiswertCalculation(E_KOERPERKRAFT);
+      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 2.0 + 0.5);
     }
 
     int Creature::getAuBasis()
     {
-        int es = getEigenschaftForBasiswertCalculation(E_MUT) +
-            getEigenschaftForBasiswertCalculation(E_KONSTITUTION) +
-            getEigenschaftForBasiswertCalculation(E_GEWANDTHEIT);
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 2.0 + 0.5);
     }
 
 	int Creature::getAeBasis()
 	{
-        int es = getEigenschaftForBasiswertCalculation(E_MUT) +
-			getEigenschaftForBasiswertCalculation(E_INTUITION) +
-            getEigenschaftForBasiswertCalculation(E_CHARISMA);
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
 
         return static_cast<int>(es / 2.0 + 0.5);
     }
@@ -331,7 +331,7 @@
         return mAp.used;
     }
 
-    int Creature::getEigenschaft(const CeGuiString eigenschaftName)
+    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag)
     {
 		checkEffects();
 		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
@@ -339,20 +339,11 @@
 		{
 			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
 		}
-		return it->second->getValue();
+		int result = it->second->getValue();
+        result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_WERTMOD, tag);
+        return result;
     }
 
-    int Creature::getEigenschaftForBasiswertCalculation(const CeGuiString eigenschaftName)
-    {
-		checkEffects();
-		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-		if (it == mEigenschaften.end())
-		{
-			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-		}
-		return it->second->getValueForBasiswertCalculation();
-    }
-
     void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
     {
         EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-03-12 03:59:16 UTC (rev 3173)
@@ -161,4 +161,9 @@
       // should be overlaoaded in the specific derivated effects.
       return STATUS_NONE;
     }
+    
+    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
+    {
+      return 0;
+    }
 }

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-03-12 03:59:16 UTC (rev 3173)
@@ -74,9 +74,6 @@
         RL_LONGLONG timeForCheck = now + timeUntilCheck;
         // Fuege die Summe und Effekt in die Checklist ein
         mChecklist[timeForCheck].insert(effect);
-        std::cout << "####################### Effect expires in: " << timeUntilCheck << " ms." << std::endl;
-        std::cout << "####################### Now              : " << now << std::endl;
-        std::cout << "####################### Check            : " << timeForCheck << std::endl;
     }
     
     void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
@@ -110,7 +107,6 @@
 				}
 			}
 		}
-        CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Adding Effect \"");
         ScriptWrapper::getSingleton().owned( effect );
 		mEffects.insert(effect);
 		effect->enable();
@@ -130,16 +126,20 @@
       Effect::Status status = 0;
       for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
       {
-        //try
-        //{
             status = status | ((*it)->getStatus());
-        //}
-        //catch (ScriptInvocationFailedException& sife)
-        //{
-        //  Logger::getSingleton().log(Logger::CORE, Logger::LL_ERROR, sife.toString() );
-        //}
       }
       return status;
     }
+    
+    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
+    {
+      checkEffects();
+      int mod = 0;
+      for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+      {
+        mod += (*it)->getMod(target, type, tag);
+      }
+      return mod;
+    }
 }
 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-11 19:45:31 UTC (rev 3172)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-12 03:59:16 UTC (rev 3173)
@@ -575,6 +575,17 @@
       // Meta stati
         static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
       
+        typedef int ModType;
+        static const ModType MODTYPE_NONE         = 1 << 0;
+        static const ModType MODTYPE_WERTMOD      = 1 << 1;   ///< Modifies the actual value.
+        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
+        static const ModType MODTYPE_WERTMULT     = 1 << 3;   ///< Will be multiplied on the value.
+        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
+      
+        typedef unsigned long ModTag;
+        static const ModTag MODTAG_NONE           = 1 << 0;
+        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
+
       // other constants
         static const int REMOVE = -1;
         static const int PERMANENT = 0;
@@ -604,6 +615,7 @@
 		virtual RL_LONGLONG check() = 0;
 
         virtual Status getStatus();
+        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
         
 	protected:
 		virtual void apply() = 0;
@@ -655,7 +667,7 @@
         void setWert(Wert wertId, int value);
         virtual StateSet* getWertStateSet(Wert wertId);
         
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName);
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag = Effect::MODTAG_NONE);
         virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
         virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
 		virtual EigenschaftenStateSet* getEigenschaftenStateSet(const rl::CeGuiString eigenschaftName);



From no22 at mail.berlios.de  Mon Mar 12 05:00:43 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Mon, 12 Mar 2007 05:00:43 +0100
Subject: [Dsa-hl-svn] r3174 - in modules: common/scripts/effects
	regressiontest/dsa regressiontest/scripts
	regressiontest/scripts/maps
Message-ID: <200703120400.l2C40hp2021687@sheep.berlios.de>

Author: no22
Date: 2007-03-12 05:00:39 +0100 (Mon, 12 Mar 2007)
New Revision: 3174

Added:
   modules/common/scripts/effects/paralues.rb
   modules/common/scripts/effects/resistentgegenkrankheiten.rb
   modules/regressiontest/scripts/effecttest.rb
Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
Tests for the effect system


Added: modules/common/scripts/effects/paralues.rb
===================================================================
--- modules/common/scripts/effects/paralues.rb	2007-03-12 03:59:16 UTC (rev 3173)
+++ modules/common/scripts/effects/paralues.rb	2007-03-12 04:00:39 UTC (rev 3174)
@@ -0,0 +1,16 @@
+class Paralues < Effect
+  def initialize()
+    super(0);
+    setName("Versteinert");
+    setDescription("Die Haut sieht aus wie aus feinem Marmor.");
+  end
+
+  def getStatus()
+    return (STATUS_PETRIFIED | STATUS_INVULNERABLE | STATUS_DEAF);
+  end
+    
+  def check()
+    p "Paralues check called";
+    return REMOVE;
+  end
+end

Added: modules/common/scripts/effects/resistentgegenkrankheiten.rb
===================================================================
--- modules/common/scripts/effects/resistentgegenkrankheiten.rb	2007-03-12 03:59:16 UTC (rev 3173)
+++ modules/common/scripts/effects/resistentgegenkrankheiten.rb	2007-03-12 04:00:39 UTC (rev 3174)
@@ -0,0 +1,20 @@
+class ResistentGegenKrankheiten < Effect
+  def initialize()
+    super(0);
+    setName("Resistent gegen Krankheiten");
+    setDescription("Der Character ist sehr Widerstandskr?ftig gegen Krankheiten.");
+  end
+
+  def getMod(target, type, tag)
+    if ((target == "KO") && (type == MODTYPE_WERTMOD) && (tag == MODTAG_KRANKHEIT))
+      return 3;
+    else
+      return 0;
+    end
+  end
+
+  def check()
+    p "Resistent gegen Krankheiten check called";
+    return PERMANENT;
+  end
+end

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-12 03:59:16 UTC (rev 3173)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-12 04:00:39 UTC (rev 3174)
@@ -84,5 +84,15 @@
         <property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
         <property name="geometrytype" type="STRING" data="box"/>
     </gameobjectclass>
+    
+    <!-- EffectTest -->
+    <gameobjectclass>
+        <property name="classid" type= "STRING" data="EffectTest" />
+        <property name="baseclass" type="STRING" data="GameObject"/>
+        <property name="name" type="STRING" data="Bottich der Versteinerung"/>
+        <property name="description" type="STRING" data="Der Essigbottich der Versteinerung (Vorsicht!)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
 
 </GameObjectDefinitions>

Added: modules/regressiontest/scripts/effecttest.rb
===================================================================
--- modules/regressiontest/scripts/effecttest.rb	2007-03-12 03:59:16 UTC (rev 3173)
+++ modules/regressiontest/scripts/effecttest.rb	2007-03-12 04:00:39 UTC (rev 3174)
@@ -0,0 +1,69 @@
+require 'testcase.rb'
+load "effects/paralues.rb"
+    load "effects/resistentgegenkrankheiten.rb"
+
+
+class ParaluesAction < Action
+  def initialize
+    super("paralues", "Spontan versteinern.");
+  end
+  
+  def canDo(go, user)
+    true
+  end
+  
+  def doAction(go, user, target)
+     p "Du wirst versteinert.";
+     $hero.getGameObject().addEffectWithCheckTime($paralueseffect, 1 * Date::ONE_SPIELRUNDE);
+     p "Du solltest dich jetzt eine Weile nicht mehr bewegen k?nnen.";
+  end
+end
+
+class ResistenzAction < Action
+  def initialize
+    super("resistenz", "Resistenz gegen Krankheiten erweben.");
+  end
+  
+    def canDo(go, user)
+    true
+    end
+  
+  def doAction(go, user, target)
+     p "KO normal: " 
+     p $hero.getGameObject().getEigenschaft("KO");
+     p "Du wirst resistent gegen Krankheiten.";
+     $hero.getGameObject().addEffect($resistenzeffect);
+     p "Effekt angewendet.";
+     p "KO gegen Krankheiten: " 
+     p $hero.getGameObject().getEigenschaft("KO", Effect::MODTAG_KRANKHEIT);
+  end
+end
+
+
+# Test case for weffects. 
+class EffectTest < TestCase
+    def initialize(center)
+        super(center)
+        # Define a base box to place everything else on.
+        height = 0.3
+        min_base = [-2.0, 0.05, -2.0]
+        max_base = [2.0, height, 2.0]
+        base = $AM.createBoxPrimitiveActor("EffectTestBase", min_base, max_base,
+                                          "alpha_yellow")
+        base.placeIntoScene(center);
+
+        bottich = $GOM.createGameObjectProxy("EffectTest").getGameObject();
+        bottich.addAction(ParaluesAction.new());
+        bottich.addAction(ResistenzAction.new());
+        bottich.placeIntoScene();
+        bottich.setPosition(rel_pos([0.0, height, 0.0]));
+
+
+        $paralueseffect = Paralues.new();
+        $resistenzeffect = ResistentGegenKrankheiten.new();
+
+
+        $SCRIPT.log("EffectTest initialisiert.");
+    end
+end
+

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-03-12 03:59:16 UTC (rev 3173)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-03-12 04:00:39 UTC (rev 3174)
@@ -11,6 +11,7 @@
 require 'InventoryTest.rb'
 require 'ErrorHandlingTest.rb'
 require 'JobSequenceTest.rb'
+require 'effecttest.rb'
 
 # Physik aktivieren
 $PM.setEnabled(true)
@@ -44,4 +45,5 @@
 ErrorHandlingTest.new([-10, 0, 5])
 InventoryTest.new([0, 0, 10])
 JobSequenceTest.new([5, 0, -5])
+EffectTest.new([5, 0, 5])
 $SCRIPT.log("tests initialisiert.");



From zero-gravity at mail.berlios.de  Mon Mar 12 19:02:07 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Mon, 12 Mar 2007 19:02:07 +0100
Subject: [Dsa-hl-svn] r3175 - in modules: aitest/maps aitest/models
	combattest/maps combattest/models common/models intro/maps
	minidemo/maps regressiontest/maps regressiontest/models
	ruchin/maps ruchin/materials ruchin/models techdemo2/models
	tutorial/maps tutorial/models
Message-ID: <200703121802.l2CI27Sl024141@sheep.berlios.de>

Author: zero-gravity
Date: 2007-03-12 18:59:25 +0100 (Mon, 12 Mar 2007)
New Revision: 3175

Modified:
   modules/aitest/maps/aitest_floorplane.mesh
   modules/aitest/models/tie_wolf_01.mesh
   modules/combattest/maps/combattest_floorplane.mesh
   modules/combattest/models/cube.1m-2m-1m.mesh
   modules/combattest/models/tie_wolf_01.mesh
   modules/common/models/arc_Laden.mesh
   modules/common/models/arc_UnbHaus_02.mesh
   modules/common/models/arc_UnbHaus_04.mesh
   modules/common/models/arc_UnbHaus_05.mesh
   modules/common/models/arc_UnbHaus_06.mesh
   modules/common/models/arc_UnbHaus_07.mesh
   modules/common/models/arc_UnbHaus_08.mesh
   modules/common/models/arc_Wirtshaus_02.mesh
   modules/common/models/arc_bett_01.mesh
   modules/common/models/arc_brunnen_01.mesh
   modules/common/models/arc_door_02.mesh
   modules/common/models/arc_fackel_01.mesh
   modules/common/models/arc_hebel_01.mesh
   modules/common/models/arc_kommode_01.mesh
   modules/common/models/arc_nachtkasten_01.mesh
   modules/common/models/arc_regal_01.mesh
   modules/common/models/arc_schaukelstuhl_01.mesh
   modules/common/models/arc_schrank_01.mesh
   modules/common/models/arc_schreibtisch_01.mesh
   modules/common/models/arc_stuhl_01.mesh
   modules/common/models/arc_tisch_01.mesh
   modules/common/models/arc_tisch_02.mesh
   modules/common/models/arc_wassermuehle_01.mesh
   modules/common/models/herkulesstaude.mesh
   modules/common/models/ins_schaufel_01.mesh
   modules/common/models/men_wirt.mesh
   modules/common/models/nat_baum_shadix_01.mesh
   modules/common/models/nat_blume_01.mesh
   modules/common/models/nat_busch_shadix_01.mesh
   modules/common/models/nat_farn_01.mesh
   modules/common/models/nat_grasplane_01.mesh
   modules/common/models/nat_salat_01.mesh
   modules/common/models/nat_stein_01.mesh
   modules/common/models/schreibtisch.mesh
   modules/common/models/ver_becher_01.mesh
   modules/common/models/ver_bild_01.mesh
   modules/common/models/ver_brotzeit_01.mesh
   modules/common/models/ver_buch_01.mesh
   modules/common/models/ver_buch_02.mesh
   modules/common/models/ver_essigbottich_01.mesh
   modules/common/models/ver_fass_01.mesh
   modules/common/models/ver_holzscheit_01.mesh
   modules/common/models/ver_kaese_01.mesh
   modules/common/models/ver_kaestchen_01.mesh
   modules/common/models/ver_karaffe_01.mesh
   modules/common/models/ver_kerze_01.mesh
   modules/common/models/ver_kiste_01.mesh
   modules/common/models/ver_korb_01.mesh
   modules/common/models/ver_laterne_01.mesh
   modules/common/models/ver_pergament_01.mesh
   modules/common/models/ver_rattenpaket_01.mesh
   modules/common/models/ver_rinderfell_01.mesh
   modules/common/models/ver_sack_03.mesh
   modules/common/models/ver_schmuckkasten_01.mesh
   modules/common/models/ver_schreibzeug_01.mesh
   modules/common/models/ver_symbol_travia_01.mesh
   modules/common/models/ver_topf_01.mesh
   modules/common/models/ver_vase_01.mesh
   modules/common/models/ver_weinflasche_01.mesh
   modules/common/models/ver_zimmerpflanze_01.mesh
   modules/common/models/waf_kurzschwert_01.mesh
   modules/intro/maps/wueste.mesh
   modules/minidemo/maps/minidemo.mesh
   modules/regressiontest/maps/regressiontest_floorplane.mesh
   modules/regressiontest/models/cube.1m-2m-1m.mesh
   modules/ruchin/maps/ruchin_haus_02.mesh
   modules/ruchin/materials/nat_nadelbaum_02_lod.mesh
   modules/ruchin/materials/nat_nadelbaum_03_lod.mesh
   modules/ruchin/models/Ruchin_Stadtwache.mesh
   modules/ruchin/models/Ruchin_l.mesh
   modules/ruchin/models/Ruchin_l_innen.mesh
   modules/ruchin/models/Ruchin_m.mesh
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchin_n.mesh
   modules/ruchin/models/Ruchin_p.mesh
   modules/ruchin/models/Ruchin_r.mesh
   modules/ruchin/models/Ruchin_s.mesh
   modules/ruchin/models/Ruchin_v.mesh
   modules/ruchin/models/Stadtmauer.mesh
   modules/ruchin/models/arc_door_tavern.mesh
   modules/ruchin/models/dome.mesh
   modules/ruchin/models/dome_clouds_far.mesh
   modules/ruchin/models/dome_clouds_near.mesh
   modules/ruchin/models/dome_sun.mesh
   modules/ruchin/models/nat_baum_shadix_03.mesh
   modules/ruchin/models/nat_busch_01.mesh
   modules/ruchin/models/nat_farn_01_dark.mesh
   modules/ruchin/models/nat_fels_01.mesh
   modules/ruchin/models/nat_fliegenpilz_01.mesh
   modules/ruchin/models/nat_loewenzahn_01.mesh
   modules/ruchin/models/nat_nadelbaum_02.mesh
   modules/ruchin/models/nat_nadelbaum_02_lod.mesh
   modules/ruchin/models/nat_nadelbaum_03.mesh
   modules/ruchin/models/nat_nadelbaum_03_lod.mesh
   modules/ruchin/models/ruchin_haus_02.mesh
   modules/ruchin/models/ver_lagerfeuer01_an.mesh
   modules/techdemo2/models/Techdemo2.mesh
   modules/techdemo2/models/Techdemo2_map2.mesh
   modules/techdemo2/models/arc_UnbHaus_08_td2.mesh
   modules/techdemo2/models/arc_UnbHaus_08_td2_boden.mesh
   modules/techdemo2/models/arc_Wachturm_01.mesh
   modules/techdemo2/models/arc_begeHaus_01.mesh
   modules/techdemo2/models/arc_bett_02.mesh
   modules/techdemo2/models/arc_ruin_01.mesh
   modules/techdemo2/models/arc_ruin_02.mesh
   modules/techdemo2/models/arc_ruin_03.mesh
   modules/techdemo2/models/arc_ruin_04.mesh
   modules/techdemo2/models/arc_treppenhilfe_01.mesh
   modules/techdemo2/models/baumstammcoli.mesh
   modules/techdemo2/models/col_TD2_map1.mesh
   modules/techdemo2/models/coli_Techdemo2_map2.mesh
   modules/techdemo2/models/coli_arc_Wachturm_01.mesh
   modules/techdemo2/models/fx_steingischt_01.mesh
   modules/techdemo2/models/men_druide.mesh
   modules/techdemo2/models/men_gennisch2.mesh
   modules/techdemo2/models/men_grim.mesh
   modules/techdemo2/models/men_sonja.mesh
   modules/techdemo2/models/nat_TD2Fluss.mesh
   modules/techdemo2/models/nat_baum_shadix_03.mesh
   modules/techdemo2/models/nat_brunnenwasser.mesh
   modules/techdemo2/models/nat_busch_01.mesh
   modules/techdemo2/models/nat_farn_01_dark.mesh
   modules/techdemo2/models/nat_fels_01.mesh
   modules/techdemo2/models/nat_fliegenpilz_01.mesh
   modules/techdemo2/models/nat_loewenzahn_01.mesh
   modules/techdemo2/models/nat_nadelbaum_02.mesh
   modules/techdemo2/models/nat_nadelbaum_02_lod.mesh
   modules/techdemo2/models/nat_nadelbaum_03.mesh
   modules/techdemo2/models/nat_nadelbaum_03_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_01.mesh
   modules/techdemo2/models/ter_TD2_map2_part_01_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_02.mesh
   modules/techdemo2/models/ter_TD2_map2_part_02_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_03.mesh
   modules/techdemo2/models/ter_TD2_map2_part_03_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_04.mesh
   modules/techdemo2/models/ter_TD2_map2_part_04_lod.mesh
   modules/techdemo2/models/ter_TD2_map2_part_05.mesh
   modules/techdemo2/models/ter_TD2_map2_part_06.mesh
   modules/techdemo2/models/ter_TD2_map2_part_07.mesh
   modules/techdemo2/models/ter_TD2_map2_part_08.mesh
   modules/techdemo2/models/ter_TD2_map2_part_09.mesh
   modules/techdemo2/models/ter_feld.mesh
   modules/techdemo2/models/tie_schmetterling_01.mesh
   modules/techdemo2/models/tie_schmetterling_02.mesh
   modules/techdemo2/models/tie_wolf_01.mesh
   modules/techdemo2/models/towerplaceholder.mesh
   modules/techdemo2/models/ver_stein_turm.mesh
   modules/tutorial/maps/DialogLevel.mesh
   modules/tutorial/models/men_gennisch2.mesh
Log:
added bounding box fixes

Modified: modules/aitest/maps/aitest_floorplane.mesh
===================================================================
(Binary files differ)

Modified: modules/aitest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/maps/combattest_floorplane.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)

Modified: modules/combattest/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Laden.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_04.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_05.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_06.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_07.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_UnbHaus_08.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_Wirtshaus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_bett_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_brunnen_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_door_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_fackel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_hebel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_kommode_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_nachtkasten_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_regal_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schaukelstuhl_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schrank_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_schreibtisch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_stuhl_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_tisch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_tisch_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/arc_wassermuehle_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/herkulesstaude.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ins_schaufel_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_wirt.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_baum_shadix_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_blume_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_busch_shadix_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_farn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_grasplane_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_salat_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/nat_stein_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/schreibtisch.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_becher_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_bild_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_brotzeit_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_buch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_buch_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_essigbottich_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_fass_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_holzscheit_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kaese_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kaestchen_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_karaffe_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kerze_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_kiste_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_korb_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_laterne_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_pergament_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_rattenpaket_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_rinderfell_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_sack_03.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_schmuckkasten_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_schreibzeug_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_symbol_travia_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_topf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_vase_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_weinflasche_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/ver_zimmerpflanze_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)

Modified: modules/intro/maps/wueste.mesh
===================================================================
(Binary files differ)

Modified: modules/minidemo/maps/minidemo.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/maps/regressiontest_floorplane.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/ruchin_haus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/materials/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_Stadtwache.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_l.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_l_innen.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_m.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_n.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_p.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_s.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_v.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Stadtmauer.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/arc_door_tavern.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_clouds_far.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_clouds_near.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/dome_sun.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_baum_shadix_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_busch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_farn_01_dark.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_fels_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_fliegenpilz_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_loewenzahn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ruchin_haus_02.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/ver_lagerfeuer01_an.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/Techdemo2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/Techdemo2_map2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_UnbHaus_08_td2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_UnbHaus_08_td2_boden.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_Wachturm_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_begeHaus_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_bett_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_ruin_04.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/arc_treppenhilfe_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/baumstammcoli.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/col_TD2_map1.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/coli_Techdemo2_map2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/coli_arc_Wachturm_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/fx_steingischt_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_druide.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_gennisch2.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_grim.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/men_sonja.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_TD2Fluss.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_baum_shadix_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_brunnenwasser.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_busch_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_farn_01_dark.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_fels_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_fliegenpilz_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_loewenzahn_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/nat_nadelbaum_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_01_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_02_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_03.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_03_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_04.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_04_lod.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_05.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_06.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_07.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_08.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_TD2_map2_part_09.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ter_feld.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_schmetterling_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_schmetterling_02.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/tie_wolf_01.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/towerplaceholder.mesh
===================================================================
(Binary files differ)

Modified: modules/techdemo2/models/ver_stein_turm.mesh
===================================================================
(Binary files differ)

Modified: modules/tutorial/maps/DialogLevel.mesh
===================================================================
(Binary files differ)

Modified: modules/tutorial/models/men_gennisch2.mesh
===================================================================
(Binary files differ)



From tanis at mail.berlios.de  Mon Mar 12 19:55:18 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 12 Mar 2007 19:55:18 +0100
Subject: [Dsa-hl-svn] r3176 - rl/trunk/engine/rules
Message-ID: <200703121855.l2CItIpS026405@sheep.berlios.de>

Author: tanis
Date: 2007-03-12 19:55:15 +0100 (Mon, 12 Mar 2007)
New Revision: 3176

Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
Log:
AtomicEffect and CompoundEffect have been removed.

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-03-12 17:59:25 UTC (rev 3175)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-03-12 18:55:15 UTC (rev 3176)
@@ -293,14 +293,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\AtomicEffect.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\CompositeEffect.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\Date.cpp"
 				>
 			</File>
@@ -471,14 +463,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\AtomicEffect.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\CompositeEffect.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\Date.h"
 				>
 			</File>



From natoka at mail.berlios.de  Tue Mar 13 22:43:04 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 13 Mar 2007 22:43:04 +0100
Subject: [Dsa-hl-svn] r3177 - rl/trunk/engine/ai/src
Message-ID: <200703132143.l2DLh4Bt020707@sheep.berlios.de>

Author: natoka
Date: 2007-03-13 22:42:53 +0100 (Tue, 13 Mar 2007)
New Revision: 3177

Modified:
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
Log:
* Ogre.h dependency removed and replaced by proper smaller import


Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-12 18:55:15 UTC (rev 3176)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-13 21:42:53 UTC (rev 3177)
@@ -19,7 +19,7 @@
 #include "SteeringVehicle.h"
 #include "Actor.h"
 #include "PhysicalThing.h"
-#include <Ogre.h>
+#include "OgreVector3.h"
 #include "PhysicsMaterialRaycast.h"
 
 using namespace OpenSteer;

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-12 18:55:15 UTC (rev 3176)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-13 21:42:53 UTC (rev 3177)
@@ -16,7 +16,7 @@
 #include "WayPointGraph.h"
 #include "WayPointNode.h"
 #include <algorithm>
-#include <Ogre.h>
+#include "OgreVector3.h"
 #include "CoreSubsystem.h"
 #include "World.h"
 #include "Exception.h"



From melven at mail.berlios.de  Tue Mar 13 22:48:09 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 13 Mar 2007 22:48:09 +0100
Subject: [Dsa-hl-svn] r3178 - in rl/trunk/engine: core/src rules/src
	ui/include ui/src
Message-ID: <200703132148.l2DLm9SB020976@sheep.berlios.de>

Author: melven
Date: 2007-03-13 22:47:48 +0100 (Tue, 13 Mar 2007)
New Revision: 3178

Modified:
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
removed shivering of the FreeFlightCharacterController
fixed some bugs of the MovementCharacterController like the velocity of jogging and running and character now doesn't stop any more before a jump
for testing: jumps are relative to the time the jump-key is pressed

Modified: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-03-13 21:42:53 UTC (rev 3177)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-03-13 21:47:48 UTC (rev 3178)
@@ -55,7 +55,7 @@
 
             mCamera->setPosition( getStartPoint() );
             mCamera->setFOVy(Degree(60));
-            mCamera->setFixedYawAxis(false);
+            mCamera->setFixedYawAxis(true);
             mCamera->setAutoAspectRatio(true);
 
             actor->placeIntoScene();

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-13 21:42:53 UTC (rev 3177)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-13 21:47:48 UTC (rev 3178)
@@ -1296,11 +1296,11 @@
         }
         else if( movementType & BEWEGUNG_LAUFEN )
         {
-            velocity = act_gs / 2.5;
+            velocity = act_gs / 2.0;
         }
         else if( movementType & BEWEGUNG_JOGGEN )
         {
-            velocity = act_gs / 2.0;
+            velocity = act_gs / 3.0;
         }
         else if( movementType & BEWEGUNG_GEHEN )
         {
@@ -1391,7 +1391,7 @@
                 patzer = 0;
             }
             // Ausdauerverbrauch: eigentlich 1, aber ich denke das ist zu hoch
-            damageAu(1./3);
+            damageAu(2./3);
             return velocity;
         }
         else if( movementType & BEWEGUNG_HOCHSPRUNG )

Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-03-13 21:42:53 UTC (rev 3177)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-03-13 21:47:48 UTC (rev 3178)
@@ -65,8 +65,7 @@
 		Ogre::Real mSpeedIncrement;
 		Ogre::Real mRotationSpeed;
         Ogre::Vector3 mDesiredVelocity;
-        Ogre::Degree mPitch;
-        Ogre::Degree mYaw;
+        Ogre::Vector3 mCameraUpConstraint;
         bool mCollisionsEnabled;
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse;

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-13 21:42:53 UTC (rev 3177)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-13 21:47:48 UTC (rev 3178)
@@ -41,11 +41,11 @@
 		mCurrentMovementState(0),
         mDesiredVelocity(Vector3::ZERO),
         mCollisionsEnabled(false),
-        mPitch(Degree(0)),
-        mYaw(Degree(0)),
-        mPitchRange(Degree(-89), Degree(89))
+        mPitchRange(Degree(-89), Degree(89)),
+        mCameraUpConstraint(Vector3::ZERO)
 	{
-		//mCameraActor->getPhysicalThing()->freeze();
+		mCameraActor->getPhysicalThing()->freeze();
+        mCameraUpConstraint = mCameraActor->getPhysicalThing()->getUpConstraint();
 		mCharacterActor->getPhysicalThing()->freeze();
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(ConfigurationManager::CS_INPUT, "Mouse Sensitivity");
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(ConfigurationManager::CS_INPUT, "Mouse Invert");
@@ -72,7 +72,9 @@
 
 	FreeFlightCharacterController::~FreeFlightCharacterController()
 	{
-		//mCameraActor->getPhysicalThing()->unfreeze();
+		mCameraActor->getPhysicalThing()->unfreeze();
+        if(mCameraUpConstraint != Vector3::ZERO)
+            mCameraActor->getPhysicalThing()->setUpConstraint(mCameraUpConstraint);
 		mCharacterActor->getPhysicalThing()->unfreeze();
 	}
 
@@ -139,32 +141,34 @@
 		}
 
 
+        Radian yaw;
         if (movement & TURN_LEFT)
-            mYaw += elapsedTime * Degree(120.0f);
+            yaw = elapsedTime * Degree(120.0f);
         if (movement & TURN_RIGHT)
-            mYaw -= elapsedTime * Degree(120.0f);
+            yaw = -elapsedTime * Degree(120.0f);
 
         // mouse
         if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
         {
-            Degree rotation = mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
-
-            mYaw -= rotation;
-
-            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
+            yaw = -mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
         }
+        while (yaw.valueDegrees() > 360.0f) yaw -= Degree(360.0f);
+        while (yaw.valueDegrees() < -360.0f) yaw += Degree(360.0f);
 
-
+        Radian pitch;
         if (mInvertedMouse)
-            mPitch += mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+            pitch = mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
         else
-            mPitch -= mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+            pitch = -mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
 
-        while (mPitch.valueDegrees() > 360.0f) mPitch -= Degree(360.0f);
-        while (mPitch.valueDegrees() < -360.0f) mPitch += Degree(360.0f);
-        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+        while (pitch.valueDegrees() > 360.0f) pitch -= Degree(360.0f);
+        while (pitch.valueDegrees() < -360.0f) pitch += Degree(360.0f);
+        if (pitch < mPitchRange.first) pitch = mPitchRange.first;
+        if (pitch > mPitchRange.second) pitch = mPitchRange.second;
+
+        mCameraActor->getPhysicalThing()->clearUpConstraint();
+        mCameraActor->yaw(yaw.valueDegrees());
+        mCameraActor->pitch(pitch.valueDegrees());
     }
 
 	void FreeFlightCharacterController::toggleViewMode()
@@ -176,8 +180,6 @@
 
 	void FreeFlightCharacterController::resetCamera()
 	{
-        mYaw = Degree(0);
-        mPitch = Degree(0);
 		// Position camera at char position
         if( mCharacterActor != NULL )
         {
@@ -280,11 +282,6 @@
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
 
             body->setForce(force);
-
-
-            mCameraActor->setOrientation(Quaternion::IDENTITY);
-            mCameraActor->yaw(mYaw.valueDegrees());
-            mCameraActor->pitch(mPitch.valueDegrees());
         }
     }
 

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-13 21:42:53 UTC (rev 3177)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-13 21:47:48 UTC (rev 3178)
@@ -440,8 +440,6 @@
 
             if( !blockMovement )
             {
-                mCharacterState.mDesiredVel = Vector3::ZERO;
-
                 // not handled movements:
                 if( movement & MOVE_FORWARD && movement & MOVE_BACKWARD ||
                     movement & MOVE_LEFT && movement & MOVE_RIGHT )
@@ -494,41 +492,26 @@
 
                 // ---------- jumping-behaviour (and falling?) ---------
                 {
-                    if( !(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
-                        !blockMovement && !mCharacterState.beginJump &&
-                        !(creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG) &&
-                        !(creatureMovement & Creature::BEWEGUNG_WEITSPRUNG) &&
+                    if( !((creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) || 
+                        blockMovement || mCharacterState.beginJump ||
+                        (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG) ||
+                        (creatureMovement & Creature::BEWEGUNG_WEITSPRUNG)) &&
                         movement & MOVE_JUMP)
                     {
                         if( mCharacterState.mDesiredVel.squaredLength() > 0 )
                         {
-                            mCharacterState.jumpType = CharacterState::WEITSPRUNG;
-                            if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG) )
+                            if( movement & MOVE_FORWARD )
                             {
                                 mCharacterState.beginJump = true;
-                                Real jumpWidth = 
-                                    mCharacter->doTaktischeBewegung(
-                                            newCreatureMovement | Creature::BEWEGUNG_WEITSPRUNG,
-                                            elapsedTime,
-                                            patzer);
-
-                                mCharacterState.mJumpWidthHeight = jumpWidth;
+                                mCharacterState.jumpType = CharacterState::WEITSPRUNG;
+                                creatureMovement = newCreatureMovement;
                             }
                         }
                         else
                         {
+                            mCharacterState.beginJump = true;
                             mCharacterState.jumpType = CharacterState::HOCHSPRUNG;
-                            if( mCharacter->canUseTaktischeBewegung(newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG) )
-                            {
-                                mCharacterState.beginJump = true;
-                                Real jumpHeight = 
-                                    mCharacter->doTaktischeBewegung(
-                                            newCreatureMovement | Creature::BEWEGUNG_HOCHSPRUNG,
-                                            elapsedTime,
-                                            patzer);
-
-                                mCharacterState.mJumpWidthHeight = jumpHeight;
-                            }
+                            creatureMovement = newCreatureMovement;
                         }
                     }
 
@@ -542,18 +525,15 @@
                     }
 
 
-
-                    
-                    Real timeJumpKeyPressed (0.0);
-                    if( !mCharacterState.beginJump )
+                    static Real timeJumpKeyPressed (0.0);
+                    if( mCharacterState.beginJump && (movement & MOVE_JUMP) )
+                        timeJumpKeyPressed += elapsedTime;
+                    else
                         timeJumpKeyPressed = 0;
-                    else if( movement & MOVE_JUMP && 
-                        (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
-                        creatureMovement & Creature::BEWEGUNG_WEITSPRUNG ) )
-                        timeJumpKeyPressed += elapsedTime;
 
 
 
+
                     if( mCharacterState.beginJump )
                     {
                         blockMovement = true;
@@ -565,6 +545,7 @@
                         else // HOCHSPRUNG
                         {
                             newAnimation = "idle_absprung";
+
                         }
                         animTimesToPlay = 1;
                         
@@ -572,13 +553,63 @@
                         MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
                         if (meshAnim->getTimePlayed() >= meshAnim->getLength())
                         {
-                            mCharacterState.mStartJump = true;
-                            if( timeJumpKeyPressed > 0.5 )
-                            mCharacterState.mJumpWidthHeight *= timeJumpKeyPressed / meshAnim->getLength();
                             mCharacterState.beginJump = false;
+                            
+                            if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
+                            {
+                                if( mCharacter->canUseTaktischeBewegung(creatureMovement | Creature::BEWEGUNG_WEITSPRUNG) )
+                                {
+                                    Real jumpWidth = 
+                                        mCharacter->doTaktischeBewegung(
+                                                creatureMovement | Creature::BEWEGUNG_WEITSPRUNG,
+                                                elapsedTime,
+                                                patzer);
+
+                                    mCharacterState.mJumpWidthHeight = jumpWidth;
+                                    mCharacterState.mStartJump = true;
+                                }
+                            }
+                            else
+                            {
+                                if( mCharacter->canUseTaktischeBewegung(creatureMovement | Creature::BEWEGUNG_HOCHSPRUNG) )
+                                {
+                                    Real jumpHeight = 
+                                        mCharacter->doTaktischeBewegung(
+                                                creatureMovement | Creature::BEWEGUNG_HOCHSPRUNG,
+                                                elapsedTime,
+                                                patzer);
+
+                                    mCharacterState.mJumpWidthHeight = jumpHeight;
+                                    mCharacterState.mStartJump = true;
+                                }
+                            }
+
+                            if( timeJumpKeyPressed < 0.1f )
+                                timeJumpKeyPressed = 0.1f;
+                            Real factor = timeJumpKeyPressed / meshAnim->getLength();
+                            if (factor > 1.0f)
+                                factor = 1.0f;
+
+
+                            mCharacterState.mJumpWidthHeight *= factor;
                         }
+                        else
+                        {
+                            mCharacterState.mDesiredVel = Vector3::ZERO;
+                            if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
+                            {
+                                mCharacterState.mDesiredVel.z = -1;
+                                Real vel = mCharacter->doTaktischeBewegung(
+                                    creatureMovement, elapsedTime, patzer);
+                                mCharacterState.mDesiredVel *= vel;
+                            }
+                            else
+                            {
+                                mCharacter->setTaktischeBewegung(creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG);
+                            }
+                        }
                     }
-                    else // !beginJump
+                    else
                     {
                         if( creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG )
                         {
@@ -594,13 +625,33 @@
                         }
                     }
 
+
                     if( mCharacterState.endJump )
                     {
+                        mCharacterState.mDesiredVel = Vector3::ZERO;
+
                         blockMovement = true;
-                        if( creatureMovement & Creature::BEWEGUNG_WEITSPRUNG )
+                        if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
                         {
                             newAnimation = "rennen_sprung_landung";
                             animSpeed = factor_rennen_sprung * vel;
+
+                            // schneller oder gleich schnell weiterlaufen
+                            if( movement & MOVE_FORWARD )
+                            {
+                                int dummy = Creature::BEWEGUNG_GEHEN |
+                                            Creature::BEWEGUNG_LAUFEN |
+                                            Creature::BEWEGUNG_JOGGEN |
+                                            Creature::BEWEGUNG_RENNEN;
+                                if( (newCreatureMovement & dummy) >=
+                                    (creatureMovement & dummy) )
+                                {
+                                    blockMovement = false;
+                                    mCharacterState.mDesiredVel.z = -1;
+                                    newCreatureMovement &= ~Creature::BEWEGUNG_WEITSPRUNG;
+                                }
+                                    
+                            }
                         }
                         else // HOCHSPRUNG
                         {
@@ -718,9 +769,11 @@
             }
 
 
+            static bool lastTurning(false);
             if( mCharacter->getTaktischeBewegung() == Creature::BEWEGUNG_DREHEN &&
-                charOmega.y != 0 )
+                (rotation <= Degree(-2) || rotation >= Degree(2) || lastTurning) )
             {
+                lastTurning = true;
                 if( charOmega.y > 0 )
                     newAnimation = "drehen_links";
                 else
@@ -728,6 +781,8 @@
                 
                 animSpeed = factor_drehen_idle * charOmega.y;
             }
+            else
+                lastTurning = false;
 
 
             mYaw -= rotation;
@@ -1043,9 +1098,6 @@
                         Real g = mGravitation.length();
                         Real t = timestep;
                         Real h = height;
-                        std::ostringstream os;
-                        os << "Sprungh?he: " << height;
-                        LOG_MESSAGE(Logger::UI, os.str());
                         Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
                         force += Vector3(0,
                             jumpForce,
@@ -1059,9 +1111,6 @@
                         Real v0 = currentVel.x;
                         Real t = timestep;
                         Real s = width;
-                        std::ostringstream os;
-                        os << "Sprungweite: " << width;
-                        LOG_MESSAGE(Logger::UI, os.str());
                         Real jumpForcezy = 
                             m*g/4 - v0*m /2 /t + 
                             Math::Sqrt( 
@@ -1070,16 +1119,7 @@
                                 m*m * g*g * t*t /4 +
                                 2 * s * m*m *g
                                        )/2/t;
-                        force += Vector3(0,jumpForcezy,0);
-                        // in the direction of mDesiredVel
-                        if( mCharacterState.mDesiredVel.squaredLength() == 0 )
-                        {
-                            // this shouldn't happen...
-                            mCharacterState.mDesiredVel.z = -1;                            
-                        }
-                        mCharacterState.mDesiredVel.y = 0;
-                        mCharacterState.mDesiredVel.normalise();
-                        force += orientation * mCharacterState.mDesiredVel * jumpForcezy;
+                        force += orientation * Vector3(0,jumpForcezy,-jumpForcezy);
                     }
 
                     mCharacterState.mStartJump = false;
@@ -1089,6 +1129,8 @@
                 else
                 {
                     Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh?ngig von der framerate!
+                    if( mCharacterState.mDesiredVel.squaredLength() < currentVel.squaredLength() )
+                        delay *= 4;
                     force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
                 }
             }
@@ -1731,6 +1773,7 @@
         mCharacterState.endJump = false;
         mCharacterState.beginSneak = false;
         mCharacterState.endSneak = false;
+        mCharacter->modifyAu(100);
     }
 
     //------------------------------------------------------------------------



From josch at mail.berlios.de  Wed Mar 14 22:46:20 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Wed, 14 Mar 2007 22:46:20 +0100
Subject: [Dsa-hl-svn] r3179 - in rl/trunk: engine/core/include
	engine/core/include/nulldriver engine/core/src
	engine/core/src/nulldriver engine/script/swig
	plugins/fmod4driver/include plugins/fmod4driver/src
	plugins/openaldriver/include plugins/openaldriver/src
Message-ID: <200703142146.l2ELkKT5031254@sheep.berlios.de>

Author: josch
Date: 2007-03-14 22:46:04 +0100 (Wed, 14 Mar 2007)
New Revision: 3179

Modified:
   rl/trunk/engine/core/include/Sound.h
   rl/trunk/engine/core/include/SoundEvents.h
   rl/trunk/engine/core/include/SoundObject.h
   rl/trunk/engine/core/include/nulldriver/NullSound.h
   rl/trunk/engine/core/src/SoundEvents.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/core/src/nulldriver/NullSound.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
   rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
   rl/trunk/plugins/openaldriver/include/OpenALSound.h
   rl/trunk/plugins/openaldriver/src/OpenALSound.cpp
Log:
- Priorities can be set in sound objects.
- Fmod4: Connected all channel callback to event listener.

Modified: rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/include/Sound.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -99,6 +99,10 @@
 	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
 	    virtual void setRolloffEndDistance(const Ogre::Real&);
 	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
 
         /// Spielt den Sound ab.
         virtual void play(bool destroyWhenDone=false) = 0;
@@ -124,6 +128,8 @@
         Ogre::Quaternion mDirection;
         /// Die Geschwindigkeit
         Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
 
 	    Ogre::Real mRolloffStartDistance;
 	    Ogre::Real mRolloffEndDistance;
@@ -141,6 +147,7 @@
         bool mIs3d;
         // Ob dieser Sound loopen soll.
         bool mIsLooping;
+        
     }; 
 
 

Modified: rl/trunk/engine/core/include/SoundEvents.h
===================================================================
--- rl/trunk/engine/core/include/SoundEvents.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/include/SoundEvents.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -56,7 +56,7 @@
 class _RlCoreExport  SoundTimingEvent : public SoundEvent {
 
 public:
-    double mTime;
+    unsigned int mTime;
 
     SoundTimingEvent(EventSource *source);
     SoundTimingEvent(EventSource *source, const unsigned int reason );
@@ -65,6 +65,18 @@
     static const unsigned int TIMEEVENT = 14;
 };
 
+class _RlCoreExport  SoundVoiceEvent : public SoundEvent {
 
+public:
+
+    SoundVoiceEvent(EventSource *source);
+    SoundVoiceEvent(EventSource *source, const unsigned int reason );
+    virtual ~SoundVoiceEvent();
+    
+    static const unsigned int SWAPINEVENT = 16;
+    static const unsigned int SWAPOUTEVENT = 17;
+};
+
+
 }
 #endif // SOUNDEVENT_H

Modified: rl/trunk/engine/core/include/SoundObject.h
===================================================================
--- rl/trunk/engine/core/include/SoundObject.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/include/SoundObject.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -68,6 +68,10 @@
         virtual void stop();
 		/// Setzt die Lautstaerke (1.0 = volle Lautst?rke)
 		void setVolume(float volume = 1.0);
+        // Sets the priority of this sound
+        void setPriority(const int priority);
+        // Gets the priority of this sound
+        const int getPriority() const;
 
 		float getLength() const;
 

Modified: rl/trunk/engine/core/include/nulldriver/NullSound.h
===================================================================
--- rl/trunk/engine/core/include/nulldriver/NullSound.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/include/nulldriver/NullSound.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -76,6 +76,11 @@
     //         void rewind() throw (RuntimeException);
         /// Laeuft der Sound noch
          const bool isPlaying() const;
+        
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority);
+        // Gets the priority of this sound
+        virtual const int getPriority() const;
 
     protected:
         // Sind wir gueltig?

Modified: rl/trunk/engine/core/src/SoundEvents.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundEvents.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/src/SoundEvents.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -74,4 +74,18 @@
 {
 }
 
+SoundVoiceEvent::SoundVoiceEvent(EventSource *source) :
+    SoundEvent(source)
+{
 }
+
+SoundVoiceEvent::SoundVoiceEvent(EventSource *source, const unsigned int reason):
+    SoundEvent(source, reason)
+{
+}
+
+SoundVoiceEvent::~SoundVoiceEvent()
+{
+}
+
+}

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -192,4 +192,16 @@
 	return getSound()->getLength();
 }
 
+// Sets the priority of this sound
+void SoundObject::setPriority(const int priority)
+{
+    getSound()->setPriority(priority);
 }
+
+// Gets the priority of this sound
+const int SoundObject::getPriority() const
+{
+    return getSound()->getPriority();
+}
+
+}

Modified: rl/trunk/engine/core/src/nulldriver/NullSound.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -229,5 +229,26 @@
     return true;
 }
 
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @param priority The new priority of this sound
+ */ 
+void NullSound::setPriority(const int priority)
+{
+    mPriority = priority;
+}
 
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @return The new priority of this sound
+ */ 
+const int NullSound::getPriority() const
+{
+    return mPriority;
+}
+
 } // Namespace

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-03-14 21:46:04 UTC (rev 3179)
@@ -422,6 +422,10 @@
     void stop();
 	/// Setzt die Lautstaerke (1.0 = volle Lautst?rke)
 	void setVolume(float volume = 1.0);
+    // Sets the priority of this sound
+    void setPriority(const int priority);
+    // Gets the priority of this sound
+    const int getPriority() const;
 	
 	rl::Sound* getSound();
 };
@@ -706,6 +710,11 @@
     /// Laeuft der Sound noch
     const bool isPlaying() const ;
 
+    // Sets the priority of this sound
+    virtual void setPriority(const int priority);
+    // Gets the priority of this sound
+    virtual const int getPriority() const;
+
     /// Gibt zur?ck ob der Sound geloopt werden soll 
     bool isLooping() const;
     /// Setzt ob der Sound geloopt werden soll 

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -99,8 +99,8 @@
         const DriverMap& getDriverData() const;
 
         FMOD::System* _getFmodSystem();
-        void _registerForAutoDestruction(Fmod4Sound* sound, FMOD::Channel* channel);
-
+        void _registerChannel(FMOD::Channel* channel, Fmod4Sound* sound);
+        
     protected:
         virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type);
 

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -65,6 +65,11 @@
 		virtual void setDirection(const Ogre::Quaternion&);
 		/// Setzt die Geschwindigkeit der Soundquelle.
 		virtual void setVelocity(const Ogre::Vector3&);
+        
+        /// Gibt den FMOD Channel zur?ck.
+        FMOD::Channel* getFmodChannel() const;
+        /// Gibt den FMOD Sound zur?ck.
+        FMOD::Sound* getFmodSound() const;
 
         virtual void play(bool destroyWhenDone=false);
 		/// Pausiert den Sound.
@@ -75,6 +80,15 @@
 		virtual void stop();
 		/// Laeuft der Sound noch
 		virtual const bool isPlaying() const;
+        
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority);
+        // Gets the priority of this sound
+        virtual const int getPriority() const;
+        
+        
+        /// Should the sound be autodestructed when playing is done.
+        bool isAutoDestroying() const;
 
     private:
 		/// Shared class-level name for Movable type
@@ -83,6 +97,7 @@
         SoundType mType;
         FMOD::Sound *mSound;
         Fmod4Driver* mDriver;
+        bool mAutoDestroy;
     };
 
     class _RlFmod4DriverExport Fmod4SoundPtr :

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -327,23 +327,75 @@
         return FMOD_ERR_INVALID_PARAM;
     }
 
-    FMOD_RESULT F_CALLBACK Fmod4Driver::channelCallback(
-        FMOD_CHANNEL* channel,
-        FMOD_CHANNEL_CALLBACKTYPE type,
-        int command,
-        unsigned int commanddata1,
-        unsigned int commanddata2)
+/**
+ * This static method is as channel callback, so that we get callbacks
+ * from FMOD
+ * @author Blakharaz
+ * @version 1.0
+ * @author JoSch
+ * @version 1.1
+ * @date 07-03-2007
+ * @param _channel The channel for which the callback is registered.
+ * @param type Type of the event.
+ * @param command A commando
+ * @param commanddata1 Data
+ * @param commanddata2 Data
+ */
+FMOD_RESULT F_CALLBACK Fmod4Driver::channelCallback(
+    FMOD_CHANNEL *_channel,
+    FMOD_CHANNEL_CALLBACKTYPE type,
+    int command,
+    unsigned int commanddata1, 
+    unsigned int commanddata2)
+{
+    /// Extract the Fmod channel and then our Sound object.
+    FMOD::Channel* channel = (FMOD::Channel*)_channel;
+    RlAssert1(channel != NULL);
+    ChannelSoundMap::iterator it = gDriver->mChannelSoundMap.find((FMOD::Channel*)channel);
+    if (it != gDriver->mChannelSoundMap.end())
     {
-        // Look up sound for this channel
-        ChannelSoundMap::iterator it = gDriver->mChannelSoundMap.find((FMOD::Channel*)channel);
-        if (it != gDriver->mChannelSoundMap.end())
+        Fmod4Sound* sound = it->second;
+        RlAssert1(sound != NULL);
+        switch(type)
         {
-            gDriver->destroySound(it->second);
-            gDriver->mChannelSoundMap.erase(it);
+            case FMOD_CHANNEL_CALLBACKTYPE_END:
+                {
+                    // We dispatch a stop event
+                    SoundPlayEvent event(NULL, SoundPlayEvent::STOPEVENT);
+                    sound->dispatchEvent(&event);
+                    // If the sound is set for autodestruction,
+                    // we destroy it now.
+                    if (sound->isAutoDestroying())
+                    {
+                        gDriver->destroySound(sound);
+                        gDriver->mChannelSoundMap.erase(it);
+                    }
+                }
+                break;
+                
+            case FMOD_CHANNEL_CALLBACKTYPE_SYNCPOINT:
+                {
+                    FMOD::Sound *fmodsound = NULL;
+                    FMOD_SYNCPOINT* syncpoint = NULL;
+                    SoundTimingEvent event(NULL, SoundTimingEvent::TIMEEVENT);
+        
+                    // We get the time point of the sync point and put it in a timing event.
+                    sound->getFmodChannel()->getCurrentSound(&fmodsound);
+                    fmodsound->getSyncPoint(commanddata1, &syncpoint);
+                    fmodsound->getSyncPointInfo(syncpoint, NULL, 0, &event.mTime, FMOD_TIMEUNIT_MS);
+                    sound->dispatchEvent(&event);
+                }
+                break;
+             case FMOD_CHANNEL_CALLBACKTYPE_VIRTUALVOICE:
+                {
+                }
+                break;
         }
-        return FMOD_OK;
-    }
+    }  
+    return FMOD_OK;
+}
 
+
     void Fmod4Driver::setMasterVolume(const Ogre::Real& vol)
     {
         SoundDriver::setMasterVolume(vol);
@@ -363,10 +415,14 @@
         return factor;
     }
 
-    void Fmod4Driver::_registerForAutoDestruction(Fmod4Sound* sound, FMOD::Channel* channel)
+    void Fmod4Driver::_registerChannel(FMOD::Channel* channel, Fmod4Sound* sound)
     {
         FMOD_RESULT res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_END, channelCallback, 0);
         CHECK_FMOD4_ERRORS(res);
+        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_SYNCPOINT, channelCallback, 0);
+        CHECK_FMOD4_ERRORS(res);
+        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_VIRTUALVOICE, channelCallback, 0);
+        CHECK_FMOD4_ERRORS(res);
         mChannelSoundMap.insert(std::make_pair(channel, sound));
     }
 }

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -33,6 +33,7 @@
     mDriver(driver),
     mChannel(NULL)
 {
+    setPriority(128);
 }
 
 float Fmod4Sound::getLength() const
@@ -131,10 +132,8 @@
     CHECK_FMOD4_ERRORS(res);
 
     RlAssert1(mChannel != NULL);
-    if (destroyWhenDone)
-    {
-        mDriver->_registerForAutoDestruction(this, mChannel);
-    }
+    mAutoDestroy = destroyWhenDone;
+    mDriver->_registerChannel(mChannel, this);
 
     float vol;
 	if (is3d())
@@ -147,6 +146,7 @@
 	}
 	setVolume(vol);
 
+    setPriority(mPriority);
     setPosition(mPosition);
     setDirection(mDirection);
 	setVelocity(mVelocity); 
@@ -260,4 +260,43 @@
     return vol;
 }
 
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @param priority The new priority of this sound
+ */ 
+void Fmod4Sound::setPriority(const int priority)
+{
+    mPriority = priority;
+    if (mPriority < 0)
+    {
+        mPriority = 0;
+    }
+    if (mPriority > 256)
+    {
+        mPriority = 256;
+    }
+    if (isValid())
+    {
+        mChannel->setPriority(mPriority);
+    }
+}
+
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @return The new priority of this sound
+ */ 
+const int Fmod4Sound::getPriority() const
+{
+    int priority = mPriority;
+    if (isValid())
+    {
+        mChannel->getPriority(&priority);
+    }
+    return priority;
+}
+
 } // Namespace

Modified: rl/trunk/plugins/openaldriver/include/OpenALSound.h
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALSound.h	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/openaldriver/include/OpenALSound.h	2007-03-14 21:46:04 UTC (rev 3179)
@@ -66,6 +66,11 @@
     /// Laeuft der Sound noch
     virtual const bool isPlaying() const;
     
+    // Sets the priority of this sound
+    virtual void setPriority(const int priority);
+    // Gets the priority of this sound
+    virtual const int getPriority() const;
+
     // Sind wir gueltig
     bool isValid() const throw (RuntimeException);
 

Modified: rl/trunk/plugins/openaldriver/src/OpenALSound.cpp
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALSound.cpp	2007-03-13 21:47:48 UTC (rev 3178)
+++ rl/trunk/plugins/openaldriver/src/OpenALSound.cpp	2007-03-14 21:46:04 UTC (rev 3179)
@@ -207,4 +207,35 @@
     return !mIsPlaying;
 }
 
+
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @param priority The new priority of this sound
+ */ 
+void OpenALSound::setPriority(const int priority)
+{
+    mPriority = priority;
+    if (isValid())
+    {
+    }
+}
+
+/**
+ * @author JoSch
+ * @date 14-03-2007
+ * @version 1.0
+ * @return The new priority of this sound
+ */ 
+const int OpenALSound::getPriority() const
+{
+    if (isValid())
+    {
+        return mPriority;
+    } else {
+        return mPriority;
+    }
+}
+
 };



From natoka at mail.berlios.de  Thu Mar 15 01:03:46 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Thu, 15 Mar 2007 01:03:46 +0100
Subject: [Dsa-hl-svn] r3180 - in rl/trunk/engine: ai/include ai/src
	core/include core/src ui/src
Message-ID: <200703150003.l2F03kH7024895@sheep.berlios.de>

Author: natoka
Date: 2007-03-15 01:03:20 +0100 (Thu, 15 Mar 2007)
New Revision: 3180

Modified:
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/include/PhysicsController.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/ui/src/CharacterController.cpp
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
Major API fix for PhysicsManager which introduces a better material handling of OgreNewts materials and materialpairs. Additionally the PhysicsController is now known in PhysicalThing and has been removed from PhysicsManager.
Summarizing: the NPCs collision detection works again properly, because they are not set to 'character' material anymore, but instead to default.


Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-03-15 00:03:20 UTC (rev 3180)
@@ -75,7 +75,7 @@
             BOTTOM
         };
 		//! newton material id
-        OgreNewt::MaterialID *mLevelMaterial;
+        const OgreNewt::MaterialID *mLevelMaterial;
 		//! newton world
         OgreNewt::World *mNewtonWorld;
     };

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -59,8 +59,7 @@
 Agent::~Agent(void)
 {
     if(mType == AgentManager::AGENT_STD_NPC)
-        PhysicsManager::getSingleton().
-			setPhysicsController( mCreature->getActor()->getPhysicalThing(), NULL );
+        mCreature->getActor()->getPhysicalThing()->setPhysicsController( NULL );
 
     delete mVehicle;
     delete mBehaviour;
@@ -94,8 +93,7 @@
 //  the steering force with the help of different steering behaviours
 	if(mType == AgentManager::AGENT_STD_NPC)
 	{
-		PhysicsManager::getSingleton().
-			setPhysicsController(mCreature->getActor()->getPhysicalThing(), this);
+		mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
         LOG_MESSAGE(Logger::AI, 
 			"added Agent to PhysicsManager as PhysicsController");
 	}

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -73,7 +73,7 @@
 
 NewtonWorldAsObstacle::NewtonWorldAsObstacle(void)
 {
-    mLevelMaterial = PhysicsManager::getSingleton()._getLevelMaterialID();
+    mLevelMaterial = PhysicsManager::getSingleton().getMaterialID("level");
     mNewtonWorld = PhysicsManager::getSingleton()._getNewtonWorld();
 }
 

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-03-15 00:03:20 UTC (rev 3180)
@@ -145,6 +145,28 @@
         void setContactListener(PhysicsContactListener* listener);
         PhysicsContactListener* getContactListener() const;
 
+        /** Retrieves the PhysicsController of this object.
+         * @returns the responsible PhysicsController object reacting on force/torque updates
+         */
+        PhysicsController* getPhysicsController() const;
+        /** Sets the PhysicsController for this object.
+         * When the given controller object is NULL, then this removes only
+         * removes the previous controller object.
+         * @param controller is the responsible PhysicsController object reacting on force/torque updates
+         * @param materialid of the material to use for this physical object
+         */
+        void setPhysicsController(PhysicsController* controller);
+
+        /** Sets the material id for this OgreNewt Body.
+         * @param materialid to set to.
+         */
+        void setMaterialID(const OgreNewt::MaterialID* materialid);
+        /** Retrieves the material id for the OgreNewt Body.
+         * @returns materialid of the OgreNewt body.
+         */
+        const OgreNewt::MaterialID* getMaterialID() const;
+
+    protected:
 		void prepareUserControl(OgreNewt::MaterialID* material);
         void unprepareUserControl();
 
@@ -180,6 +202,9 @@
 		PhysicalObject* mPhysicalObject;
 		bool mHullModifier;
 
+        //! the responsible PhysicsController object reacting on force/torque updates
+        PhysicsController* mPhysicsController;
+
 		/** returns the geometrytype of the collision primitiv.
 		 * That is normally box, sphere, ellipsoid, capsule, convexhull or mesh.
 		 * question: is mesh also userdefined ?

Modified: rl/trunk/engine/core/include/PhysicsController.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsController.h	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/include/PhysicsController.h	2007-03-15 00:03:20 UTC (rev 3180)
@@ -8,7 +8,7 @@
 {
 	/** abstract baseclass for PhysicalObject with an external force/torque control.
 	 * Derived objects register with PhysicalManager. Whenever force/torque is
-	 * going to be applied to the an object controlled by a PhysicsController, the
+	 * going to be applied to the object controlled by a PhysicsController, the
 	 * associated PhysicsControllers OnApplyForceAndTorque gets executed.
 	 * So the applied force/torque can be modified before it is applied to the
 	 * associated PhysicalThing.

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-03-15 00:03:20 UTC (rev 3180)
@@ -44,12 +44,25 @@
     class PhysicsGenericContactCallback;
     class World;
 
+    /** Management class for the physical properties of game world objects.
+     * This class utilizes OgreNewt (and therefore indirectly Newton) for handling
+     * the physics of RL. It sets up OgreNewt and realizes the timestepping for Newton.
+     * Additionally it manages materials which are needed for handling different kinds
+     * of object collisions. It also installs a basic forcefeedback function per object,
+     * in a way that is perhaps not the quickest one, but removes the need for a per object
+     * registration.
+     * So basically this class handles the global settings and things related 
+     * to the object world.
+     * It also manages a list of physical controllers (that are objects that
+     * modify physical properties of a specific object).
+     */
     class _RlCoreExport PhysicsManager
         :   public GameTask,
             protected Ogre::Singleton<PhysicsManager>
     {
     public:
 
+        //! differentiates between the different collision primitives
         enum GeometryType {
             GT_NONE = -1,
             GT_BOX = 0,
@@ -62,7 +75,11 @@
 
         static const Ogre::Real NEWTON_GRID_WIDTH;
         
+        //! default constructor
         PhysicsManager();
+        /** explicit virtual destructor.
+         * frees any acquired memory.
+         */
         virtual ~PhysicsManager();
 
         virtual void run( Ogre::Real elapsedTime );
@@ -112,34 +129,6 @@
 		void toggleDebugMode();
         bool isDebugMode() const;
 
-        PhysicsController* getPhysicsController(PhysicalThing* thing) const;
-        /**
-         * @param thing, the PhysicalThing to be controlled by controller
-         * @param controller, the controller may be NULL.
-         *        In this case, thing is not controlled anymore
-         */
-        void setPhysicsController(PhysicalThing* thing, PhysicsController* controller);
-
-        /**
-         * Sets the special contact callback for character-level-interaction.
-         * This is handled specifically
-         * @todo If other special cases are identified, the interface for
-         * material handling has to be generalised.
-         * @ param callback, the new contact callback. Can be NULL, in this case the default
-         *   callback is set.
-         */
-        void setCharLevelContactCallback(PhysicsGenericContactCallback* callback);
-
-        /**
-         * Sets the special contact callback for character-interaction with any other
-         * material, that has not yet a specialised handler defined.
-         * @todo If other special cases are identified, the interface for
-         * material handling has to be generalised.
-         * @ param callback, the new contact callback. Can be NULL, in this case the default
-         *   callback is set.
-         */
-        void setCharDefaultContactCallback(PhysicsGenericContactCallback* callback);
-
         // Newton callbacks ...
         /// generic force callback. Gravity is applied and the force,
         /// applied via PhysicalThing interface.
@@ -150,9 +139,6 @@
         static void controlledForceCallback(OgreNewt::Body* body);
 
         OgreNewt::World* _getNewtonWorld() const;
-        OgreNewt::MaterialID* _getLevelMaterialID() const;
-        OgreNewt::MaterialID* _getCharMaterialID() const;
-		const OgreNewt::MaterialID* _getDefaultMaterialID() const;
 
         virtual const Ogre::String& getName() const;
 
@@ -170,16 +156,57 @@
         {
             return mMaxTimestep;
         }
+
+        // Material handling (for different types of collision)
+        /** retrieves a material by name.
+         * @param materialname string identifying the material
+         * @returns the specified material object
+         */
+        const OgreNewt::MaterialID* getMaterialID(const Ogre::String& materialname) const;
+        /** creates a material by name.
+         * Whenever the material exists already, the existing object is returned.
+         * @param materialname string identifying the material
+         * @returns the newly created material object (or the already present one)
+         */
+        const OgreNewt::MaterialID* createMaterialID(const Ogre::String& materialname);
+
+        /** creates a materialpair.
+         * Whenever the materialpair exists already, the existing object is returned.
+         * @param M1 material id of first material
+         * @param M2 material id of second material
+         * @returns the created materialpair object (or the already present one)
+         */
+        OgreNewt::MaterialPair* createMaterialPair(const OgreNewt::MaterialID* M1,
+            const OgreNewt::MaterialID* M2);
+        /** retrieves a material by name.
+         * @param M1 material id of first material
+         * @param M2 material id of second material
+         * @returns the specified materialpair object
+         */
+        OgreNewt::MaterialPair* getMaterialPair(const OgreNewt::MaterialID* M1,
+            const OgreNewt::MaterialID* M2) const;
+        /** reset MaterialPair to default.
+         * @param M1 material id of first material
+         * @param M2 material id of second material
+         */
+        void resetMaterialPair( const OgreNewt::MaterialID* M1,
+            const OgreNewt::MaterialID* M2);
+
+        /** converts a string identifying a collision property into an enum.
+         * Mainly for making string definitions of the collision property
+         * possible in .gof files.
+         * @param geomTypeString giving the collision primitiv.
+         */
 		static GeometryType convertStringToGeometryType(const Ogre::String& geomTypeString);
 
     private:
-        typedef std::map<PhysicalThing*, PhysicsController*> ControllerMap;
+        //typedef std::map<PhysicalThing*, PhysicsController*> ControllerMap;
+        //ControllerMap mControlledThings;
 
         bool mEnabled;
         OgreNewt::World* mWorld;
         OgreNewt::Debugger* mNewtonDebugger;
         std::vector<PhysicalThing*> mPhysicalThings;
-        ControllerMap mControlledThings;
         std::vector<OgreNewt::Body*> mLevelBodies;
         bool mDebugMode;
         Ogre::Vector3 mGravity;
@@ -188,12 +215,46 @@
         Ogre::Real mMinTimestep;
         Ogre::Real mMaxTimestep;
 
+        // Material handling needed for different types of collisions
+        //! shortens the type definition for maps of materials
+        typedef std::map<const Ogre::String, const OgreNewt::MaterialID*> MaterialMap;
+        //! shortens the creation of pair types for the stl map
+        typedef std::pair<const Ogre::String, const OgreNewt::MaterialID*> MaterialMapPair;
+
+        //! defines a pair of MaterialIDs
+        typedef std::pair< const OgreNewt::MaterialID*, const OgreNewt::MaterialID* > PairOfMaterials;
+
+        //! defines a comparison operator for pairs of MaterialIDs
+        struct ltPairOfMaterials
+        {
+            bool operator()(const PairOfMaterials P1, const PairOfMaterials P2) const
+            {
+                if (P1.first->getID() == P2.first->getID())
+                    return (P1.second->getID() < P2.second->getID());
+
+                return (P1.first->getID() < P2.first->getID());
+            }
+        };
+
+        //! shortens the type definition for maps of materialpairs
+        typedef std::multimap< PairOfMaterials, OgreNewt::MaterialPair*, ltPairOfMaterials > MaterialPairMap;
+        //! shortens the type definition for pairs for the stl multimap
+        typedef std::pair< PairOfMaterials, OgreNewt::MaterialPair* > MaterialPairMapPair;
+
+        //! contains a list materials with string id as a key
+        MaterialMap mMaterials;
+        //! contains a list of materialpairs (for different collisionhandling)
+        MaterialPairMap mMaterialPairs;
+
+        /*
         OgreNewt::MaterialID* mLevelID;
         OgreNewt::MaterialID* mCharacterID;
         OgreNewt::MaterialPair* mDefaultPair;
         OgreNewt::MaterialPair* mCharLevelPair;
         OgreNewt::MaterialPair* mCharCharPair;
         OgreNewt::MaterialPair* mCharDefaultPair;
+        */
+
         PhysicsGenericContactCallback* mGenericCallback;
     };
 }

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -300,7 +300,7 @@
                 100.0f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
 			pt->_getBody()->setMaterialGroupID(
-				PhysicsManager::getSingleton()._getCharMaterialID());
+                PhysicsManager::getSingleton().getMaterialID("character"));
             actor = new Actor(uniquename, co, pt);
 
             mActors.insert(ActorPtrPair(uniquename,actor)); 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -45,17 +45,16 @@
 		mGeometryType(geomType),
 		mPhysicalObject(po),
 		mMass(mass),
-		mHullModifier(hullModifier)
+		mHullModifier(hullModifier),
+        mPhysicsController(NULL)
 	{
 	}
 
     PhysicalThing::~PhysicalThing()
 	{
-        PhysicsManager::getSingleton().setPhysicsController( this, NULL );
 		// missing removal of list of collision objects here ...
 		delete mBody;
 		mBody = NULL;
-
     }
 
     Ogre::Vector3 PhysicalThing::getPosition() const
@@ -605,24 +604,45 @@
         }
 	}
 
-	void PhysicalThing::prepareUserControl(OgreNewt::MaterialID* material)
+    PhysicsController* PhysicalThing::getPhysicsController() const
     {
-        mBody->setMaterialGroupID(material);
-        mBody->setAutoFreeze(0);
-        mBody->unFreeze();
-        mBody->setLinearDamping(0.0f);
-        mBody->setAngularDamping(Vector3::ZERO);
+        return mPhysicsController;
+    }
 
-        mBody->setCustomForceAndTorqueCallback( PhysicsManager::controlledForceCallback );
+    void PhysicalThing::setPhysicsController(PhysicsController* controller)
+    {
+        if (mPhysicsController)
+        {
+            // if there is an old controller, remove it
+            mBody->setCustomForceAndTorqueCallback( PhysicsManager::genericForceCallback );
+            setUpConstraint(Vector3::ZERO);
+            mPhysicsController = NULL;
+        }
 
-        // Set up-vector, so force application doesn't let the char fall over
-        setUpConstraint(Vector3::UNIT_Y);
+        if(controller)
+        {
+            // prepare for control
+            mPhysicsController = controller;
+            mBody->setAutoFreeze(0);
+            mBody->unFreeze();
+            mBody->setLinearDamping(0.0f);
+            mBody->setAngularDamping(Vector3::ZERO);
+
+            mBody->setCustomForceAndTorqueCallback( PhysicsManager::controlledForceCallback );
+
+            // Set up-vector, so force application doesn't let the char fall over
+            setUpConstraint(Vector3::UNIT_Y);
+        }
     }
 
-    void PhysicalThing::unprepareUserControl()
+    void PhysicalThing::setMaterialID(const OgreNewt::MaterialID* materialid)
     {
-		mBody->setMaterialGroupID(PhysicsManager::getSingleton()._getDefaultMaterialID());
-        mBody->setCustomForceAndTorqueCallback( PhysicsManager::genericForceCallback );
-        setUpConstraint(Vector3::ZERO);
+        mBody->setMaterialGroupID(materialid);
     }
+
+    const OgreNewt::MaterialID* PhysicalThing::getMaterialID() const
+    {
+        return mBody->getMaterialGroupID();
+    }
+
 }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -51,18 +51,18 @@
         : mEnabled(false),
         mNewtonDebugger(),
         mPhysicalThings(),
-        mControlledThings(),
+        //mControlledThings(),
         mDebugMode(false),
         mGravity(0, -9.81, 0),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
         mElapsed(0.0f),
         mMinTimestep(1.0f/600.0f),
         mMaxTimestep(1.0f/30.0f),
-        mLevelID(),
-        mCharacterID(),
-        mDefaultPair(),
-        mCharLevelPair(),
-        mCharCharPair(),
+        //mLevelID(),
+        //mCharacterID(),
+        //mDefaultPair(),
+        //mCharLevelPair(),
+        //mCharCharPair(),
         mGenericCallback()
     {
 		mWorld = new OgreNewt::World();
@@ -72,35 +72,40 @@
 
         // setup materials: default<->default
         const OgreNewt::MaterialID* defaultID = mWorld->getDefaultMaterialID();
-        mDefaultPair = new OgreNewt::MaterialPair(
-            mWorld, defaultID, defaultID);
+        mMaterials.insert(MaterialMapPair("default", defaultID));
+
+        OgreNewt::MaterialPair* mDefaultPair = createMaterialPair( defaultID, defaultID );
         mGenericCallback = new PhysicsGenericContactCallback();
         mDefaultPair->setContactCallback(mGenericCallback);
         mDefaultPair->setDefaultFriction(0.85f, 0.80f);
 
-        // setup materials: character/cam<->level
-        mLevelID = new OgreNewt::MaterialID(mWorld);
-        mCharacterID = new OgreNewt::MaterialID(mWorld);
-        mCharLevelPair = new OgreNewt::MaterialPair(mWorld, mCharacterID, mLevelID);
-        mCharLevelPair->setDefaultFriction(0, 0);
+        // setup level material
+        createMaterialID("level");
 
-        mCharDefaultPair = new OgreNewt::MaterialPair(mWorld, mCharacterID, defaultID);
-        mCharDefaultPair->setDefaultFriction(0, 0);
+        // below here starts 'old' stale fix code that should be removed
 
-        // setup material: char<->cam. there should be no collision
-        mCharCharPair = new OgreNewt::MaterialPair(mWorld, mCharacterID, mCharacterID);
-        mCharCharPair->setDefaultCollidable(0);
+        // setup camera material (actually not needed)
+        //createMaterialID("camera");
+
+        // setup character material
+        // actually this is needed here, because the actor is created in advance before the
+        // character controller who actually does create 'character' material too.
+        createMaterialID("character");      
     }
 
     PhysicsManager::~PhysicsManager()
     {
+        // remove all materials
+        for (MaterialMap::iterator it = mMaterials.begin(); it != mMaterials.end(); it++)
+        {
+            // default material has been provided by OgreNewt, therefore it
+            // it must not be deleted here
+            if ((*it).first != "default") 
+                delete (*it).second;
+        }
+        mMaterials.clear();
+
         delete mGenericCallback;
-        delete mCharCharPair;
-		delete mCharDefaultPair;
-        delete mCharLevelPair;
-        delete mCharacterID;
-        delete mLevelID;
-        delete mDefaultPair;
         delete mWorld;
     }
 
@@ -222,7 +227,7 @@
             body->attachToNode(node);
             body->setPositionOrientation(node->getWorldPosition(),
                 node->getWorldOrientation());
-            body->setMaterialGroupID(mLevelID);
+            body->setMaterialGroupID(getMaterialID("level"));
 
             mLevelBodies.push_back(body);
         }
@@ -272,10 +277,9 @@
         PhysicalThing* thing =
             static_cast<Actor*>(body->getUserData())->getPhysicalThing();
 
-        ControllerMap::const_iterator it = getSingleton().mControlledThings.find(thing);
-        if (it != getSingleton().mControlledThings.end())
+        if (thing->getPhysicsController())
         {
-            (*it).second->OnApplyForceAndTorque(thing);
+            thing->getPhysicsController()->OnApplyForceAndTorque(thing);
         }
         else
         {
@@ -284,93 +288,77 @@
         }
     }
 
+    OgreNewt::World* PhysicsManager::_getNewtonWorld() const
+    {
+        return mWorld;
+    }
 
-    PhysicsController* PhysicsManager::getPhysicsController(PhysicalThing* thing) const
+    const Ogre::String& PhysicsManager::getName() const
     {
-        PhysicsController* rval = 0;
+        static String NAME = "PhysicsManager";
 
-        ControllerMap::const_iterator it = mControlledThings.find(thing);
-        if (it != mControlledThings.end())
-        {
-            rval = (*it).second;
-        }
-
-        return rval;
+        return NAME;
     }
 
-    void PhysicsManager::setPhysicsController(PhysicalThing* thing,
-        PhysicsController* controller)
+    const OgreNewt::MaterialID* PhysicsManager::getMaterialID(const Ogre::String& materialname) const
     {
-        RlAssert1(thing);
+        MaterialMap::const_iterator it;
 
-        // first see, if the thing has another controller already
-        PhysicsController* oldController = getPhysicsController(thing);
-        if (oldController)
+        it = mMaterials.find(materialname);
+        if (it != mMaterials.end())
         {
-            // if so, remove it
-            thing->unprepareUserControl();
-            mControlledThings.erase(thing);
+            return (*it).second;
         }
 
-        if(controller)
-        {
-            // add it to the map and prepare it for control
-            mControlledThings[thing] = controller;
-			thing->prepareUserControl(mCharacterID); /** @TODO: Nicht immer nur Char-Material nehmen */
-        }
+        return NULL;
     }
 
-    void PhysicsManager::setCharLevelContactCallback(PhysicsGenericContactCallback* callback)
+    const OgreNewt::MaterialID* PhysicsManager::createMaterialID(const Ogre::String& materialname)
     {
-        if (callback != NULL)
+        const OgreNewt::MaterialID* materialid = NULL;
+
+        if ((materialid = getMaterialID(materialname)) == NULL)
         {
-            mCharLevelPair->setContactCallback(callback);
+            materialid = new OgreNewt::MaterialID(mWorld);
+            mMaterials.insert( MaterialMapPair(materialname, materialid) );
         }
-        else
-        {
-            mCharLevelPair->setContactCallback(PhysicsManager::mGenericCallback);
-        }
+        return materialid;
     }
 
-    void PhysicsManager::setCharDefaultContactCallback(PhysicsGenericContactCallback* callback)
+    OgreNewt::MaterialPair* PhysicsManager::createMaterialPair(const OgreNewt::MaterialID* M1,
+        const OgreNewt::MaterialID* M2)
     {
-        if (callback != NULL)
+        OgreNewt::MaterialPair* materialpair = NULL;
+
+        if ((materialpair = getMaterialPair(M1, M2)) == NULL)
         {
-            mCharDefaultPair->setContactCallback(callback);
+            materialpair = new OgreNewt::MaterialPair(mWorld, M1, M2);
+            mMaterialPairs.insert(
+                MaterialPairMapPair( PairOfMaterials(M1,M2), materialpair ));
         }
-        else
-        {
-            mCharDefaultPair->setContactCallback(PhysicsManager::mGenericCallback);
-        }
+        return materialpair;
     }
 
-    OgreNewt::World* PhysicsManager::_getNewtonWorld() const
+    OgreNewt::MaterialPair* PhysicsManager::getMaterialPair(const OgreNewt::MaterialID* M1,
+            const OgreNewt::MaterialID* M2) const
     {
-        return mWorld;
-    }
+        MaterialPairMap::const_iterator it;
 
-    OgreNewt::MaterialID* PhysicsManager::_getLevelMaterialID() const
-    {
-        return mLevelID;
-    }
+        it = mMaterialPairs.find(PairOfMaterials(M1,M2));
+        if (it != mMaterialPairs.end())
+        {
+            return (*it).second;
+        }
 
-	OgreNewt::MaterialID* PhysicsManager::_getCharMaterialID() const
-    {
-        return mCharacterID;
+        return NULL;
     }
 
-	const OgreNewt::MaterialID* PhysicsManager::_getDefaultMaterialID() const
+    void PhysicsManager::resetMaterialPair( const OgreNewt::MaterialID* M1,
+            const OgreNewt::MaterialID* M2)
     {
-        return 	mWorld->getDefaultMaterialID();
+        getMaterialPair(M1,M2)->setContactCallback(mGenericCallback);
     }
 
-    const Ogre::String& PhysicsManager::getName() const
-    {
-        static String NAME = "PhysicsManager";
-
-        return NAME;
-    }
-
 	PhysicsManager::GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String& geomTypeString)
 	{
 		if (geomTypeString == "box")

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -98,7 +98,7 @@
         OgreNewt::BasicRaycast raycast = OgreNewt::BasicRaycast(
             PhysicsManager::getSingleton()._getNewtonWorld(), mRayStart, mRayEnd, true);
 
-	    OgreNewt::MaterialID* levelId = PhysicsManager::getSingleton()._getLevelMaterialID();
+	    const OgreNewt::MaterialID* levelId = PhysicsManager::getSingleton().getMaterialID("level");
 
         // Collect results
         for (int i = 0, num = raycast.getHitCount(); i < num; ++i)

Modified: rl/trunk/engine/ui/src/CharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterController.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ui/src/CharacterController.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -75,6 +75,20 @@
 		ogreCam->setOrientation(Quaternion::IDENTITY);
 
 		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
+
+        PhysicsManager::getSingleton().createMaterialID("character");
+
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("default"))->setDefaultFriction(0,0);
+
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("level"))->setDefaultFriction(0,0);
+
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
 	}
     
     CharacterController::~CharacterController()

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -56,13 +56,16 @@
 
         // The actor should be controlled manually,
         // so let the PM prepare it accordingly
-        PhysicsManager::getSingleton().setPhysicsController(
-            mCameraActor->getPhysicalThing(), this);
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
         // We also handle char<->level, char<->default collision from now on (camera=char!)
-        PhysicsManager::getSingleton().setCharLevelContactCallback(this);
-        PhysicsManager::getSingleton().setCharDefaultContactCallback(this);
+        PhysicsManager::getSingleton().getMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
+        PhysicsManager::getSingleton().getMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
 
-		MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
         if( mesh != NULL )
         {
 		    mesh->stopAllAnimations();

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-14 21:46:04 UTC (rev 3179)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-15 00:03:20 UTC (rev 3180)
@@ -132,13 +132,20 @@
 
         // The actor should be controlled manually,
         // so let the PM prepare it accordingly
-        PhysicsManager::getSingleton().setPhysicsController(
-            mCharacterActor->getPhysicalThing(), this);
-        PhysicsManager::getSingleton().setPhysicsController(
-            mCameraActor->getPhysicalThing(), this);
+        mCharacterActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mCharacterActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
         // We also handle char<->level, char<->default collision from now on
-        PhysicsManager::getSingleton().setCharLevelContactCallback(this);
-        PhysicsManager::getSingleton().setCharDefaultContactCallback(this);
+        PhysicsManager::getSingleton().getMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
+        PhysicsManager::getSingleton().getMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
+        
         // Fit Collision proxy to idle anim
         mCharacterActor->getPhysicalThing()->fitToPose("idle");
 
@@ -157,14 +164,16 @@
     {
         delete mRaycast;
         // actors aren't controlled anymore
-        PhysicsManager::getSingleton().setPhysicsController(
-            mCharacterActor->getPhysicalThing(), NULL);
-        PhysicsManager::getSingleton().setPhysicsController(
-            mCameraActor->getPhysicalThing(), NULL);
+        mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
         // Char<->Level collision back to default
-        PhysicsManager::getSingleton().setCharLevelContactCallback(NULL);
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
         // Char<->Default collision back to default
-        PhysicsManager::getSingleton().setCharDefaultContactCallback(NULL);
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
 
         if (DebugWindow::getSingletonPtr())
         {



From josch at mail.berlios.de  Thu Mar 15 19:15:20 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Thu, 15 Mar 2007 19:15:20 +0100
Subject: [Dsa-hl-svn] r3181 - rl/trunk/plugins/fmod4driver/src
Message-ID: <200703151815.l2FIFKtV019652@sheep.berlios.de>

Author: josch
Date: 2007-03-15 19:15:15 +0100 (Thu, 15 Mar 2007)
New Revision: 3181

Modified:
   rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
Log:
Fehlende Methoden.

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2007-03-15 00:03:20 UTC (rev 3180)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2007-03-15 18:15:15 UTC (rev 3181)
@@ -299,4 +299,38 @@
     return priority;
 }
 
+
+/**
+ * @author JoSch
+ * @date 15-03-2007
+ * @version 1.0
+ * @return The Fmod4 Channel object
+ */ 
+FMOD::Channel *Fmod4Sound::getFmodChannel() const
+{
+    return mChannel;
+}
+
+/**
+ * @author JoSch
+ * @date 15-03-2007
+ * @version 1.0
+ * @return The Fmod4 Sound object
+ */ 
+FMOD::Sound *Fmod4Sound::getFmodSound() const
+{
+    return mSound;
+}
+
+/**
+ * @author JoSch
+ * @date 15-03-2007
+ * @version 1.0
+ * @return TRUE, if the sound should autodestroy when playing ended.
+ */ 
+bool Fmod4Sound::isAutoDestroying() const
+{
+    return mAutoDestroy;
+}
+
 } // Namespace



From tanis at mail.berlios.de  Fri Mar 16 21:47:59 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 16 Mar 2007 21:47:59 +0100
Subject: [Dsa-hl-svn] r3182 - modules/common/models
Message-ID: <200703162047.l2GKlxRF009612@sheep.berlios.de>

Author: tanis
Date: 2007-03-16 21:47:47 +0100 (Fri, 16 Mar 2007)
New Revision: 3182

Removed:
   modules/common/models/men_alrike.skeleton
Log:
Skeleton is unused, so delete it.

Deleted: modules/common/models/men_alrike.skeleton
===================================================================
(Binary files differ)



From vincent22 at mail.berlios.de  Sat Mar 17 09:39:35 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Sat, 17 Mar 2007 09:39:35 +0100
Subject: [Dsa-hl-svn] r3183 - rl/trunk/engine/ui/include
Message-ID: <200703170839.l2H8dZs4032700@sheep.berlios.de>

Author: vincent22
Date: 2007-03-17 09:39:34 +0100 (Sat, 17 Mar 2007)
New Revision: 3183

Modified:
   rl/trunk/engine/ui/include/GameObjectWindow.h
Log:
Added doxygen documentation

Modified: rl/trunk/engine/ui/include/GameObjectWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-16 20:47:47 UTC (rev 3182)
+++ rl/trunk/engine/ui/include/GameObjectWindow.h	2007-03-17 08:39:34 UTC (rev 3183)
@@ -70,16 +70,6 @@
         virtual void fillHeader(GameObject* object);
  
         /**
-         * Adds one row to the property table with the given key
-         * and the property value.
-         *
-         * @param key The key of the property key|value pair
-         * @param prop The property value
-         * @param row The current row in the property table
-         */
-        //virtual void addProperty(const Ogre::String& key, const Property& prop, int row); 
-
-        /**
          * Adds an Int value to the property table.
          *
          * @param key The property to add.
@@ -88,34 +78,75 @@
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds the IntPair values to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyIntPair(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds the IntTriple values to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyIntTriple(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds a String value to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyString(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds a Bool value to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyBool(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds a Real value to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyReal(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds the Vector3 values to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyVector3(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds the Quaternion values to the property table.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyQuaternion(const Property& prop, 
             CEGUI::MultiColumnList* table,
             const Ogre::String& key = "");
 
+        /**
+         * Adds a new tab to the tabpane and lists
+         * the array values.
+         *
+         * @param key The property to add.
+         */
         virtual void addPropertyArray(const Property& prop,
             const Ogre::String& key = "");
 



From no22 at mail.berlios.de  Sun Mar 18 18:03:43 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Sun, 18 Mar 2007 18:03:43 +0100
Subject: [Dsa-hl-svn] r3184 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200703181703.l2IH3hmk003070@sheep.berlios.de>

Author: no22
Date: 2007-03-18 18:03:38 +0100 (Sun, 18 Mar 2007)
New Revision: 3184

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Just saving the WIP, no changes should be noticable.


Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-17 08:39:34 UTC (rev 3183)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-18 17:03:38 UTC (rev 3184)
@@ -21,7 +21,7 @@
 #include "GameObject.h"
 #include "Effect.h"
 #include "Eigenschaft.h"
-#include "EigenschaftenStateSet.h"
+//#include "EigenschaftenStateSet.h"
 #include "TalentStateSet.h"
 #include "ZauberStateSet.h"
 #include "SonderfertigkeitenStateSet.h"
@@ -316,17 +316,6 @@
              **/
             virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
 
-            /**
-             *  Liefert einen Zeiger auf das StateSet von \a eigenschaftName zurueck.
-            *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem "MU", 
-             *   @ref abbdef "FF", etc.).
-            *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-            *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-            *   Gross/Kleinschreibung beachtet?).
-             *  @ingroup CreatureRubyExports
-            **/
-            virtual EigenschaftenStateSet* getEigenschaftenStateSet(const CeGuiString eigenschaftName);
-
 ///////////////////////////////////////////////////////////////////////////////
 // Talente
 
@@ -469,7 +458,7 @@
              *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
              *   nicht gefunden werden.
              **/
-            virtual EigenschaftenStateSet* getNachteilStateSet(const CeGuiString nachteilName);
+            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Sonderfertigkeiten
@@ -831,7 +820,8 @@
                    *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
                    *  und einem Zeiger auf ihr StateSet.
              **/
-            typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
+            //typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
+            typedef std::map<const CeGuiString, int> EigenschaftMap;
             /**
              *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
              *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
@@ -851,7 +841,7 @@
              *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
              *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
              **/
-            typedef std::map<const CeGuiString, EigenschaftenStateSet*> NachteilMap;
+            typedef std::map<const CeGuiString, int> NachteilMap;
             /**
                    *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
                    *  Sonderfertigkeit als Schluessel und ihrem Status.

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-17 08:39:34 UTC (rev 3183)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-18 17:03:38 UTC (rev 3184)
@@ -85,14 +85,14 @@
 		setWert(WERT_GS, 8);
 		setWert(WERT_BE, 0);
         setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
-		mEigenschaften[E_MUT] = new EigenschaftenStateSet();
-		mEigenschaften[E_KLUGHEIT] = new EigenschaftenStateSet();
-		mEigenschaften[E_INTUITION] = new EigenschaftenStateSet();
-		mEigenschaften[E_CHARISMA] = new EigenschaftenStateSet();
-		mEigenschaften[E_FINGERFERTIGKEIT] = new EigenschaftenStateSet();
-		mEigenschaften[E_GEWANDTHEIT] = new EigenschaftenStateSet();
-		mEigenschaften[E_KONSTITUTION] = new EigenschaftenStateSet();
-		mEigenschaften[E_KOERPERKRAFT] = new EigenschaftenStateSet();
+		mEigenschaften[E_MUT] = 0;
+		mEigenschaften[E_KLUGHEIT] = 0;
+		mEigenschaften[E_INTUITION] = 0;
+		mEigenschaften[E_CHARISMA] = 0;
+		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
+		mEigenschaften[E_GEWANDTHEIT] = 0;
+		mEigenschaften[E_KONSTITUTION] = 0;
+		mEigenschaften[E_KOERPERKRAFT] = 0;
 
 		mInventory = new Inventory(this);
     }
@@ -105,8 +105,6 @@
         for( WertMap::iterator it=mWerte.begin();it!=mWerte.end(); it++ )
             delete it->second;
         mWerte.clear();
-        for( EigenschaftMap::iterator it=mEigenschaften.begin();it!=mEigenschaften.end(); it++ )
-            delete it->second;
         mEigenschaften.clear();
         for( TalentMap::iterator it=mTalente.begin();it!=mTalente.end(); it++ )
             delete it->second;
@@ -339,7 +337,7 @@
 		{
 			Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
 		}
-		int result = it->second->getValue();
+		int result = it->second;
         result += mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_WERTMOD, tag);
         return result;
     }
@@ -351,27 +349,16 @@
         {
             Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
         }
-		it->second->setOriginalValue( value );
-		fireObjectStateChangeEvent();
+		it->second = value;
+        fireObjectStateChangeEvent();
     }
 
     void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
     {
-		mEigenschaften[eigenschaftName]->setOriginalValue( mEigenschaften[eigenschaftName]->getOriginalValue() + mod );
+		mEigenschaften[eigenschaftName] += mod ;
 		fireObjectStateChangeEvent();
     }
 
-	EigenschaftenStateSet* Creature::getEigenschaftenStateSet(const CeGuiString eigenschaftName)
-	{
-		checkEffects();
-        EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-        if (it == mEigenschaften.end())
-        {
-            Throw(IllegalArgumentException, "Eigenschaft nicht gefunden.");
-        }
-		return it->second;
-	}
-
     int Creature::getTalent(const CeGuiString talentName)
     {
 		checkEffects();
@@ -533,8 +520,7 @@
         {
             Throw(IllegalArgumentException, "Nachteil schon in mNachteile enthalten");
         }
-        mNachteile[nachteilName] = new EigenschaftenStateSet();
-        mNachteile[nachteilName]->setOriginalValue( value );
+        mNachteile[nachteilName] = value;
     }
 
     bool Creature::hasNachteil(const CeGuiString nachteilName)
@@ -547,7 +533,7 @@
         else return false;
     }
 
-    EigenschaftenStateSet* Creature::getNachteilStateSet(const CeGuiString nachteilName)
+    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName)
     {
 		checkEffects();
         NachteilMap::const_iterator it = mNachteile.find(nachteilName);
@@ -555,7 +541,7 @@
         {
             Throw(IllegalArgumentException, "Nachteil nicht gefunden.");
         }
-		else return it->second;
+		else return it->second + mEffectManager->getMod(nachteilName, Effect::MODTYPE_WERTMOD);
     }
 
     int Creature::getSf(const CeGuiString sfName)
@@ -751,7 +737,7 @@
         else
         {
 			rval = getEigenschaft(eigenschaftName) - 
-				(probe + modifier + getEigenschaftenStateSet(eigenschaftName)->getProbenModifier() 
+				(probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD) 
 				+ getWertStateSet(WERT_MOD_ALL_EIGENSCHAFTSPROBEN)->getProbenModifier());
         }
         return rval;

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-17 08:39:34 UTC (rev 3183)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-18 17:03:38 UTC (rev 3184)
@@ -670,7 +670,7 @@
         virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag = Effect::MODTAG_NONE);
         virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
         virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-		virtual EigenschaftenStateSet* getEigenschaftenStateSet(const rl::CeGuiString eigenschaftName);
+
 		
         void addTalent(const rl::CeGuiString talentName, int value=0);
         virtual int getTalent(const rl::CeGuiString talentName);



From no22 at mail.berlios.de  Mon Mar 19 18:19:17 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Mon, 19 Mar 2007 18:19:17 +0100
Subject: [Dsa-hl-svn] r3185 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200703191719.l2JHJHQS024263@sheep.berlios.de>

Author: no22
Date: 2007-03-19 18:19:13 +0100 (Mon, 19 Mar 2007)
New Revision: 3185

Modified:
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Just saving WIP


Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-18 17:03:38 UTC (rev 3184)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-19 17:19:13 UTC (rev 3185)
@@ -21,8 +21,6 @@
 #include "GameObject.h"
 #include "Effect.h"
 #include "Eigenschaft.h"
-//#include "EigenschaftenStateSet.h"
-#include "TalentStateSet.h"
 #include "ZauberStateSet.h"
 #include "SonderfertigkeitenStateSet.h"
 
@@ -105,7 +103,7 @@
              *  Liste der Talente. Besteht aus den Namen der Talente (z.B. Athletik)
                    *  als Schluessel und ihrem Wert.
              **/
-            typedef std::map<const CeGuiString, TalentStateSet*> TalentMap;
+            typedef std::map<const CeGuiString, int> TalentMap;
 
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_BEHAVIOURS;
@@ -151,8 +149,6 @@
                 WERT_MOD_REGENERATION_LE, ///< Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
                 WERT_MOD_REGENERATION_AE, ///< Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
                 WERT_MOD_ERSCHOEPFUNGSSCHWELLE, ///< Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-                WERT_MOD_ALL_EIGENSCHAFTSPROBEN, ///< Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
-                WERT_MOD_ALL_TALENTPROBEN, ///< Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
                 WERT_GS, ///< Geschwindigkeit
                 WERT_SOZIALSTATUS, ///< Sozialstatus
                 WERT_BE, ///< Behinderung
@@ -368,14 +364,6 @@
                    *  @ingroup CreatureRubyExports
              */
             virtual void addSe(const CeGuiString talentName);
-            /**
-             *  Liefert einen Zeiger auf das StateSet des Talents \a talentName zurueck.
-             *  @param talentName Bezeichnet das Talent von dem das StateSet zurueckgegeben
-             *   werden soll.
-             *  @throws IllegalArgumentException Talent nicht gefunden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual TalentStateSet* getTalentStateSet(const CeGuiString talentName);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Kampftechniken
@@ -424,16 +412,7 @@
              *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
              **/
             virtual bool hasVorteil(const CeGuiString vorteilName);
-            /**
-             *  Liefert das StateSet des Vorteils zurueck.
-             *  Gedacht um die erforderlichen Daten von Gaben abzufragen.
-             *  @param vorteilName Der Name der Gabe.
-             *  @return Ein Zeiger auf das StateSet der Gabe.
-             *  @throws InvalidArgumentException Der Vorteil \a vorteilName konnte
-             *   nicht gefunden werden.
-             **/
-            virtual TalentStateSet* getVorteilStateSet(const CeGuiString vorteilName);
-
+ 
 ///////////////////////////////////////////////////////////////////////////////
 // Nachteile
             /**
@@ -560,12 +539,12 @@
             /**
              *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
              **/
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int spezialisierungId,
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
                                                  int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
                                                  CeGuiString eigenschaft3Name);
             virtual int doTalentprobe(const CeGuiString talentName, int modifier);
 
-            virtual int doTalentprobe(const CeGuiString talentName, int spezialisierungId,
+            virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
                                       int modifier);
             virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
                                                  CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
@@ -582,7 +561,7 @@
             *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
             *  @ingroup CreatureRubyExports
             */
-            virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier);
+            virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
 
             /**
             *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
@@ -820,7 +799,6 @@
                    *  Eigenschaft (z.B. @ref abbdem "MU", @ref abbdek "KL") als Schluessel 
                    *  und einem Zeiger auf ihr StateSet.
              **/
-            //typedef std::map<const CeGuiString, EigenschaftenStateSet*> EigenschaftMap;
             typedef std::map<const CeGuiString, int> EigenschaftMap;
             /**
              *  Liste der Kampftechniken und ihrer @ref abbdea "AT"/@ref abbdep "PA2 Werte.
@@ -836,7 +814,7 @@
              *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
              *  den Vorteilen, verhalten sich aber wie Talente.
              **/
-            typedef std::map<const CeGuiString, TalentStateSet*> VorteilMap;
+            typedef std::map<const CeGuiString, int> VorteilMap;
             /**
              *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
              *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
@@ -864,26 +842,6 @@
             float mCurrentAu;
             /// Die aktuelle Erschoepfung der Kreatur.
             int mErschoepfung;
-            /// Wenn > 0 ist die Kreatur blind.
-            int mBlind;
-            /// Wenn > 0 ist die Kreatur tot.
-            int mDead;
-            /// Wenn > 0 ist die Kreatur taub.
-            int mDeaf;
-            /// Wenn > 0 ist die Kreatur kampfunfaehig.
-            int mIncapacitated;
-            /// Wenn > 0 ist die Kreatur unverwundbar.
-            int mInvulnerable;
-            /// Wenn > 0 ist die Kreatur unsichtbar.
-            int mInvisible;
-            /// Wenn > 0 ist die Kreatur gelaehmt.
-            int mParalyzed;
-            /// Wenn > 0 ist liegt ein Silentium auf der Kreatur.
-            int mSilenced;
-            /// Wenn > 0 schlaeft die Kreatur.
-            int mSleeping;
-            /// Wenn > 0 ist die Kreatur bewusstlos.
-            int mUnconscious;
             /// Zuletzt zugewiesene Bewegungsart
             int mMovementType;
 

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-03-18 17:03:38 UTC (rev 3184)
+++ rl/trunk/engine/rules/include/Effect.h	2007-03-19 17:19:13 UTC (rev 3185)
@@ -30,6 +30,10 @@
 	{
 	public:
         
+      // some targets
+      static const CeGuiString ALL_EIGENSCHAFTEN;
+      static const CeGuiString ALL_TALENTE;
+      
       typedef unsigned long Status;
       static const Status STATUS_NONE           = 1<<0;
       static const Status STATUS_BLIND          = 1<<1;   ///< The creature can't see anything.

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-18 17:03:38 UTC (rev 3184)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-19 17:19:13 UTC (rev 3185)
@@ -52,16 +52,6 @@
         mKampftechniken(),
         mSonderfertigkeiten(),
         mErschoepfung(0),
-        mBlind(0),
-        mDead(0),
-        mDeaf(0),
-        mIncapacitated(0),
-        mInvulnerable(0),
-        mInvisible(0),
-        mParalyzed(0),
-        mSilenced(0),
-        mSleeping(0),
-        mUnconscious(0),
         mMovementType(0)
     {
         mEffectManager = new EffectManager();
@@ -80,8 +70,6 @@
         setWert(WERT_MOD_REGENERATION_LE, 0);
         setWert(WERT_MOD_REGENERATION_AE, 0);
         setWert(WERT_MOD_ERSCHOEPFUNGSSCHWELLE, 0);
-        setWert(WERT_MOD_ALL_EIGENSCHAFTSPROBEN, 0);
-        setWert(WERT_MOD_ALL_TALENTPROBEN, 0);
 		setWert(WERT_GS, 8);
 		setWert(WERT_BE, 0);
         setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
@@ -105,10 +93,6 @@
         for( WertMap::iterator it=mWerte.begin();it!=mWerte.end(); it++ )
             delete it->second;
         mWerte.clear();
-        mEigenschaften.clear();
-        for( TalentMap::iterator it=mTalente.begin();it!=mTalente.end(); it++ )
-            delete it->second;
-        mTalente.clear();
         mKampftechniken.clear();
         for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
             delete it->second;
@@ -382,7 +366,7 @@
             }
             return rval;
         } //if (it == mTalente.end())
-		return it->second->getValue();
+		return it->second;
     }
 
 	void Creature::addTalent(const CeGuiString talentName, int value)
@@ -393,8 +377,7 @@
 			Throw(IllegalArgumentException, "Talent schon in mTalente enthalten.");
         }
 	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
-		mTalente[talentName] = new TalentStateSet();
-		mTalente[talentName]->setOriginalValue(value);
+		mTalente[talentName] = value;
 		fireObjectStateChangeEvent();
 	}
 
@@ -405,7 +388,7 @@
         {
             Throw(IllegalArgumentException, "Talent nicht gefunden.");
         }
-		it->second->setOriginalValue( it->second->getOriginalValue() + mod );
+		it->second += mod ;
 		fireObjectStateChangeEvent();
     }
 
@@ -421,7 +404,7 @@
         {
             Throw(IllegalArgumentException, "Talent nicht gefunden.");
         }
-		it->second->setOriginalValue( value );
+		it->second = value;
 		fireObjectStateChangeEvent();
     }
 
@@ -432,20 +415,10 @@
         {
             Throw(IllegalArgumentException, "Talent nicht gefunden.");
         }
-		it->second->setSe( true );
+		//it->second->setSe( true );
+        /// @todo Implement SEs
 	}
 
-	TalentStateSet* Creature::getTalentStateSet(const CeGuiString talentName)
-	{
-		checkEffects();
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, "Talent nicht gefunden.");
-        }
-		return it->second;
-	}
-
 	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair<int,int>& value)
 	{
 		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
@@ -488,8 +461,7 @@
         {
             Throw(IllegalArgumentException, "Vorteil schon in mVorteile enthalten");
         }
-        mVorteile[vorteilName] = new TalentStateSet();
-        mVorteile[vorteilName]->setOriginalValue( value );
+        mVorteile[vorteilName] = value;
     }
 
     bool Creature::hasVorteil(const CeGuiString vorteilName)
@@ -502,17 +474,6 @@
         else return false;
     }
 
-    TalentStateSet* Creature::getVorteilStateSet(const CeGuiString vorteilName)
-    {
-		checkEffects();
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it == mVorteile.end())
-        {
-            Throw(IllegalArgumentException, "Vorteil nicht gefunden.");
-        }
-		else return it->second;
-    }
-
     void Creature::addNachteil(const CeGuiString nachteilName, int value)
     {
         NachteilMap::const_iterator it = mNachteile.find(nachteilName);
@@ -621,14 +582,16 @@
     }
 
 
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int spezialisierungId,
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
 		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
 		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) || 
 			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
 		{
-			Throw(OutOfRangeException, "TaW zu niedrig");
+          /// @todo Find proper return value. Prompt an error message?
+			//Throw(OutOfRangeException, "TaW zu niedrig");
+          return -1;
 		}
         EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
 
@@ -665,16 +628,10 @@
 
 
         // Vor dem Vergleich hat man den Talentwert ?brig.
-		int taW = 0;
 		int eBe = DsaManager::getSingleton().getTalent(talentName)->calculateEbe(getWert(WERT_BE));
-		try 
-		{
-			//if (1 == getSf(sfName)) taW = 2; //Spezialisiereung?
-		}
-		catch(IllegalArgumentException){};
-		taW += getTalent(talentName);
-		int rval = taW - modifier - getTalentStateSet(talentName)->getProbenModifier()
-			- getWertStateSet(WERT_MOD_ALL_TALENTPROBEN)->getProbenModifier() - eBe;
+		int taW = getTalent(talentName);
+		int rval = taW - modifier - mEffectManager->getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
+            - mEffectManager->getMod(Effect::ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
 		// Bei negativen TaP*
 		int handicap = 0;
 		if (rval < 0)
@@ -701,15 +658,15 @@
     int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier, 
 		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
     {
-		return doAlternativeTalentprobe(talentName, -1, modifier, eigenschaft1Name,
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
 			eigenschaft2Name, eigenschaft3Name);
 	}
 
-    int Creature::doTalentprobe(const CeGuiString talentName, int spezialisierungId, int modifier)
+    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
         EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierungId, modifier, 
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier, 
 			et.first, et. second, et.third);
 	}
 
@@ -717,11 +674,11 @@
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
         EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, -1, modifier, et.first, 
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first, 
 			et. second, et.third);
 	}
 
-    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier)
+    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
     {
         int rval;
 
@@ -737,8 +694,7 @@
         else
         {
 			rval = getEigenschaft(eigenschaftName) - 
-				(probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD) 
-				+ getWertStateSet(WERT_MOD_ALL_EIGENSCHAFTSPROBEN)->getProbenModifier());
+                (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
         }
         return rval;
     }
@@ -771,7 +727,7 @@
 		else
 		{
 			rval = getAttackeBasis() + (*it).second.first - (probe + modifier 
-				+ getWertStateSet(WERT_MOD_ALL_EIGENSCHAFTSPROBEN)->getProbenModifier() + eBe);
+                + mEffectManager->getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
 		if (rval < 0) 
 			return RESULT_MISSERFOLG;
@@ -802,7 +758,7 @@
 		{
 			/// @todo Gute Parade
 			rval = getParadeBasis() + (*it).second.second - (probe + modifier 
-				+ getWertStateSet(WERT_MOD_ALL_EIGENSCHAFTSPROBEN)->getProbenModifier() + eBe);
+                + mEffectManager->getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
 		if (rval < 0) 
 			return RESULT_MISSERFOLG;

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-03-18 17:03:38 UTC (rev 3184)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-03-19 17:19:13 UTC (rev 3185)
@@ -20,6 +20,10 @@
 
 namespace rl
 {
+  const CeGuiString Effect::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+  const CeGuiString Effect::ALL_TALENTE = "alle Talente";
+ 
+  
 	Effect::Effect(int stufe)
 	{
 		mStufe = stufe;

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-18 17:03:38 UTC (rev 3184)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-19 17:19:13 UTC (rev 3185)
@@ -558,6 +558,9 @@
             EFFECTTAG_KRANKHEIT
         };
         
+        static const CeGuiString ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+        static const CeGuiString ALL_TALENTE = "alle Talente";
+        
         typedef unsigned long Status;
         static const Status STATUS_NONE           = 1<<0;
         static const Status STATUS_BLIND          = 1<<1;   ///< The creature can't see anything.
@@ -650,8 +653,6 @@
             WERT_MOD_REGENERATION_LE, // Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
             WERT_MOD_REGENERATION_AE, // Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
             WERT_MOD_ERSCHOEPFUNGSSCHWELLE, // Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-            WERT_MOD_ALL_EIGENSCHAFTSPROBEN, // Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
-            WERT_MOD_ALL_TALENTPROBEN, // Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
             WERT_GS, // Geschwindigkeit
             WERT_SOZIALSTATUS, // Sozialstatus
             WERT_BE // Behinderung
@@ -667,7 +668,7 @@
         void setWert(Wert wertId, int value);
         virtual StateSet* getWertStateSet(Wert wertId);
         
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag = Effect::MODTAG_NONE);
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
         virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
         virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
 
@@ -677,7 +678,6 @@
         virtual void setTalent(const rl::CeGuiString talentName, int value);
         virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
 		virtual void addSe(const rl::CeGuiString talentName);
-		virtual TalentStateSet* getTalentStateSet(const rl::CeGuiString talentName);
 		
 		void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
 		void addNachteil(const rl::CeGuiString nachteilName, int value = 0);		



From natoka at mail.berlios.de  Tue Mar 20 00:13:04 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 20 Mar 2007 00:13:04 +0100
Subject: [Dsa-hl-svn] r3186 - in rl/trunk/engine/core: include src
Message-ID: <200703192313.l2JND4r0028523@sheep.berlios.de>

Author: natoka
Date: 2007-03-20 00:12:57 +0100 (Tue, 20 Mar 2007)
New Revision: 3186

Modified:
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
collision primitive creation with caching by PhysicalManager and a Collision primitive factory.
starts to replace collision primitive creation in physicalthing


Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-03-19 17:19:13 UTC (rev 3185)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-03-19 23:12:57 UTC (rev 3186)
@@ -44,6 +44,9 @@
     class PhysicsGenericContactCallback;
     class World;
 
+    class PhysicsCollisionFactory;
+
+
     /** Management class for the physical properties of game world objects.
      * This class utilizes OgreNewt (and therefore indirectly Newton) for handling
      * the physics of RL. It sets up OgreNewt and realizes the timestepping for Newton.
@@ -70,7 +73,8 @@
             GT_CAPSULE = 2,
             GT_MESH = 3,
             GT_ELLIPSOID = 4,
-            GT_CONVEXHULL = 5
+            GT_CONVEXHULL = 5,
+            GT_PYRAMID = 6
         };
 
         static const Ogre::Real NEWTON_GRID_WIDTH;
@@ -192,6 +196,31 @@
         void resetMaterialPair( const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2);
 
+        /** creates a collision primitive for OgreNewt.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given mesh,
+         * so whenever an other entity with the same mesh tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+		 * @param aabb AxisAlignedBox that contains the extents of mesh whose coll. primitiv is to be created
+		 * @param inertiaCoefficients Vector3 returns the inertia coefficients for the created coll. primitiv
+		 * @param animName String specifies the name of the animation of the mesh whose coll. primitiv should be created,
+		 *        when "", then the basic mesh is used as a basis.
+		 * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+		*/
+		OgreNewt::CollisionPtr createCollision(
+			Ogre::Entity* entity,
+            const Ogre::String animName = "",
+            const PhysicsManager::GeometryType& geomType = PhysicsManager::GT_NONE,
+			Ogre::Vector3* offset = NULL,
+			Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+
         /** converts a string identifying a collision property into an enum.
          * Mainly for making string definitions of the collision property
          * possible in .gof files.
@@ -199,18 +228,56 @@
          */
 		static GeometryType convertStringToGeometryType(const Ogre::String& geomTypeString);
 
+        /** converts an enum into a string identifying a collision property.
+         * Mainly for making string definitions of the collision property
+         * possible in error messages.
+         * @param geomType enum giving the collision primitiv.
+         */
+        static Ogre::String PhysicsManager::convertGeometryTypeToString(const PhysicsManager::GeometryType& geomType);
+
     private:
-        //typedef std::map<PhysicalThing*, PhysicsController*> ControllerMap;
-        //ControllerMap mControlledThings;
 
+        /** structure containing further information about the collision primitive.
+         * Actually this information should go into either the collisionptr or the
+         * object for the primitive ...
+         */
+        struct CollisionInUse
+        {
+        public:
+            PhysicsManager::GeometryType geomType;  //! primitive type
+            OgreNewt::CollisionPtr colPtr;          //! the collision primitve
+        };
+
+        /** shortens definition of a list of collision primitives.
+         * currently only one geometry type per entity (mesh) is allowed.
+         * if multiple should be possible, the geometry type should be
+         * moved from the above struct into the key.
+         */
+        typedef std::map< std::string, CollisionInUse > CollisionMap;
+
         bool mEnabled;
+        //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
+        //! the visualisation for physical behaviour (actually not the best)
         OgreNewt::Debugger* mNewtonDebugger;
+        bool mDebugMode;
+
+        //! factory for creating new collision primitives
+        PhysicsCollisionFactory* mPhysicsCollisionFactory;
+        //! a list of collision primitives
+        CollisionMap mCollisionPrimitives;
+
+        //! a list of objects of the physical world
         std::vector<PhysicalThing*> mPhysicalThings;
+        //! a list of bodies for the static level parts
         std::vector<OgreNewt::Body*> mLevelBodies;
-        bool mDebugMode;
+        //! the extents of the level
+        Ogre::AxisAlignedBox mWorldAABB;
+        
+        //! the globally known gravity force
         Ogre::Vector3 mGravity;
-        Ogre::AxisAlignedBox mWorldAABB;
+        
+        // time stuff
         Ogre::Real mElapsed;
         Ogre::Real mMinTimestep;
         Ogre::Real mMaxTimestep;
@@ -246,17 +313,91 @@
         //! contains a list of materialpairs (for different collisionhandling)
         MaterialPairMap mMaterialPairs;
 
-        /*
-        OgreNewt::MaterialID* mLevelID;
-        OgreNewt::MaterialID* mCharacterID;
-        OgreNewt::MaterialPair* mDefaultPair;
-        OgreNewt::MaterialPair* mCharLevelPair;
-        OgreNewt::MaterialPair* mCharCharPair;
-        OgreNewt::MaterialPair* mCharDefaultPair;
-        */
-
+        //! generic physics contact callback handler object
         PhysicsGenericContactCallback* mGenericCallback;
     };
+
+    class PhysicsCollisionFactory
+    {
+    public:
+        /** checks if the specified size is ok for OgreNewt
+         * @param size to check
+         */
+        bool checkSize(const Ogre::Vector3& size) const;
+        /** corrects the specified size if it is not ok for OgreNewt
+         * @param size to correct
+         */
+        void correctSize(Ogre::Vector3& size);
+        /** calculates the Inertia for the given primitive type
+         */
+        //Ogre::Vector3 calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients);
+
+        /** creates a collision primitive for OgreNewt an Ogre::Entity.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * Scaling should be implemented through attaching to a scene node.
+         * if that is not the case, we'll have to fix OgreNewt ...
+		 * @param entity Ogre::Entity mesh object
+		 * @param geomType specifies the type of collision primitiv to create.
+		 * @param offset gives the offset of the coordinate system of the coll. primitiv
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+		*/
+        OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
+            const PhysicsManager::GeometryType& geomType,
+            Ogre::Vector3* offset = NULL, 
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertiaCoefficients = NULL);
+
+        /** creates a collision primitive for OgreNewt from an AABB box.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * Since no entity is given several physical collision primitives are not
+         * possible (convexhull, tree, etc.)
+         * Scaling should be implemented through attaching to a scene node.
+         * if that is not the case, we'll have to fix OgreNewt ...
+		 * @param entity Ogre::Entity mesh object
+		 * @param geomType specifies the type of collision primitiv to create.
+		 * @param offset gives the offset of the coordinate system of the coll. primitiv
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+		*/
+        OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+            const PhysicsManager::GeometryType& geomType,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertiaCoefficients = NULL);
+    protected:
+        // to ease understanding and break up a huge factory creation function
+        // into smaller parts
+        OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+        OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+        OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+        OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+        OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset = NULL,
+            Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real Mass = 0,
+            Ogre::Vector3* inertia = NULL);
+    };
 }
 
 #endif

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-19 17:19:13 UTC (rev 3185)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-19 23:12:57 UTC (rev 3186)
@@ -316,22 +316,45 @@
         return mContactListener;
     }
 
-    void PhysicalThing::fitToPose(const Ogre::String& name)
+    void PhysicalThing::fitToPose(const Ogre::String& animName)
     {
 		CollisionPtr coll;
         
         if (mPhysicalObject->isMeshObject())
         {
             MeshObject* meshObject = dynamic_cast<MeshObject*>(mPhysicalObject);
-            AxisAlignedBox size = meshObject->getPoseSize(name);
+            //AxisAlignedBox size = meshObject->getPoseSize(name);
 
             // Do we already have a collision for the wanted pose?
-            CollisionMap::iterator it = mPoseCollisions.find(name);
+            CollisionMap::iterator it = mPoseCollisions.find(animName);
             if (it == mPoseCollisions.end())
             {
+                Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
+                MeshObject *tempMesh = NULL;
+
+                // the problem fixed and it's source:
+				// entity is a MeshObject containing the basic state of the Mesh, but
+				// this function should create the physical bounding convex hull for one of the
+				// animated states. Therefore the convex hull must be created from a mesh
+				// representing the animated state and not from a mesh containing the basic state
+
+				// check if this is a 'animated' state we have to create the convex hull for ...
+
+				if (animName != "") {
+					// Duplicating the MeshObject and animate it into the animName pose
+					tempMesh = dynamic_cast<MeshObject*>(mPhysicalObject)->createPosedCopy(animName);
+
+					entity = tempMesh->getEntity();
+				}
+
+				// calculate the convex hull of the animated mesh
+ 				coll = PhysicsManager::getSingleton().createCollision(entity, animName, mGeometryType);
+
+				// cleanup the temporary mesh
+				delete tempMesh;
+
                 // No, so create it and put it into the map
-                coll = createCollision(size, NULL, name);
-                mPoseCollisions.insert(make_pair(name, coll));
+                mPoseCollisions.insert(make_pair(animName, coll));
             }
             else
             {

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-19 17:19:13 UTC (rev 3185)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-19 23:12:57 UTC (rev 3186)
@@ -51,19 +51,14 @@
         : mEnabled(false),
         mNewtonDebugger(),
         mPhysicalThings(),
-        //mControlledThings(),
         mDebugMode(false),
         mGravity(0, -9.81, 0),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
         mElapsed(0.0f),
         mMinTimestep(1.0f/600.0f),
         mMaxTimestep(1.0f/30.0f),
-        //mLevelID(),
-        //mCharacterID(),
-        //mDefaultPair(),
-        //mCharLevelPair(),
-        //mCharCharPair(),
-        mGenericCallback()
+        mGenericCallback(),
+        mPhysicsCollisionFactory(new PhysicsCollisionFactory())
     {
 		mWorld = new OgreNewt::World();
         mWorld->setFrictionModel(OgreNewt::World::FM_ADAPTIVE);
@@ -84,9 +79,6 @@
 
         // below here starts 'old' stale fix code that should be removed
 
-        // setup camera material (actually not needed)
-        //createMaterialID("camera");
-
         // setup character material
         // actually this is needed here, because the actor is created in advance before the
         // character controller who actually does create 'character' material too.
@@ -105,6 +97,7 @@
         }
         mMaterials.clear();
 
+        delete mPhysicsCollisionFactory;
         delete mGenericCallback;
         delete mWorld;
     }
@@ -222,8 +215,8 @@
             OgreNewt::CollisionPtr collision = collisions[i];
             
 		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
+            
 
-
             body->attachToNode(node);
             body->setPositionOrientation(node->getWorldPosition(),
                 node->getWorldOrientation());
@@ -353,16 +346,84 @@
         return NULL;
     }
 
-    void PhysicsManager::resetMaterialPair( const OgreNewt::MaterialID* M1,
+    void PhysicsManager::resetMaterialPair(const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2)
     {
         getMaterialPair(M1,M2)->setContactCallback(mGenericCallback);
     }
 
+    OgreNewt::CollisionPtr PhysicsManager::createCollision(Ogre::Entity* entity,
+            const Ogre::String animName, const PhysicsManager::GeometryType& geomType,
+            Ogre::Vector3* offset, Ogre::Quaternion* orientation,
+            const Ogre::Real Mass, Ogre::Vector3* inertia)
+    {
+        // problem here is that a mesh can have different animations with
+        // different extents. Therefore we add the animName to the meshname
+        // to compute a unique name for the collision primitiv.
+        Ogre::String collisionName (entity->getMesh()->getName() + animName);
+
+        // result value
+        CollisionPtr rval;
+		
+        // check if there is a collision primitiv for the specified mesh object
+        CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
+        // log some performance warning if collisionname is equal, but geomtype different ?
+
+        if (! usedcol.colPtr.isNull() )
+        {
+            if ( usedcol.geomType != geomType )
+            {   // when geometry types mismatch, issue performance warning
+                LOG_DEBUG(Logger::CORE, " performance warning creating an other collision primitives '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+ "' for Entity '"+
+                entity->getName()+"' that already has got '"+
+                PhysicsManager::convertGeometryTypeToString(usedcol.geomType)+ "' as a primitive.");
+            } else {
+                // found it
+                rval = usedcol.colPtr;
+            }
+        }
+        
+        if (rval.isNull())
+        {
+            // if there is none, then create a new collision object
+            rval = mPhysicsCollisionFactory->createCollisionFromEntity(
+                entity, geomType, offset, orientation, Mass, inertia );
+
+            usedcol.geomType = geomType;
+            usedcol.colPtr = rval;
+        }
+
+        return rval;
+
+            if (geomType == GT_CONVEXHULL) {
+                MeshObject *tempMesh = NULL;
+
+            // the problem fixed and it's source:
+			// entity is a MeshObject containing the basic state of the Mesh, but
+			// this function should create the physical bounding convex hull for one of the
+			// animated states. Therefore the convex hull must be created from a mesh
+			// representing the animated state and not from a mesh containing the basic state
+
+			// check if this is a 'animated' state we have to create the convex hull for ...
+
+			if (animName != "") {
+				// Duplicating the MeshObject and animate it into the animName pose
+				//tempMesh = dynamic_cast<MeshObject*>(mPhysicalObject)->createPosedCopy(animName);
+				//entity = tempMesh->getEntity();
+			}
+            // fetch the collision body here ...
+
+            // cleanup the temporary mesh
+			delete tempMesh;
+        }
+    }
+
 	PhysicsManager::GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String& geomTypeString)
 	{
 		if (geomTypeString == "box")
 			return GT_BOX;
+        if (geomTypeString == "pyramid")
+            return GT_PYRAMID;
 		if (geomTypeString == "sphere")
 			return GT_SPHERE;
 		if (geomTypeString == "capsule")
@@ -375,4 +436,367 @@
 			return GT_CONVEXHULL;
 		return GT_NONE;
 	}
+
+    Ogre::String PhysicsManager::convertGeometryTypeToString(const PhysicsManager::GeometryType& geomType)
+	{
+        Ogre::String typestr("none");
+
+		if (geomType == GT_BOX)
+            typestr = "box";
+        if (geomType == GT_PYRAMID)
+            typestr = "pyramid";
+		if (geomType == GT_SPHERE)
+			typestr = "sphere";
+		if (geomType == GT_CAPSULE)
+			typestr = "capsule";
+		if (geomType == GT_MESH)
+			typestr = "mesh";
+		if (geomType == GT_ELLIPSOID)
+			typestr = "ellipsoid";
+		if (geomType == GT_CONVEXHULL)
+			typestr = "convexhull";
+		return typestr;
+	}
+
+    bool PhysicsCollisionFactory::checkSize(const Ogre::Vector3& size) const
+    {
+        if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.z < PhysicsManager::NEWTON_GRID_WIDTH )
+            return false;
+        return true;            
+    }
+
+    void PhysicsCollisionFactory::correctSize(Ogre::Vector3& size)
+    {
+        // correct size, log warning and fail back to box
+        if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.x = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.y < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.y = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.z = PhysicsManager::NEWTON_GRID_WIDTH;
+        LOG_MESSAGE(Logger::CORE, "Correcting collision primitiv size");
+    }
+
+    /*
+    Ogre::Vector3 PhysicsCollisionFactory::calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients)
+    {
+        return Ogre::Vector3(0,0,0);
+    }
+    */
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+        const PhysicsManager::GeometryType& geomType,
+        Ogre::Vector3* offset,
+        Ogre::Quaternion* orientation,
+        const Ogre::Real Mass,
+        Ogre::Vector3* inertia) 
+    {
+        // size of the mesh
+        Vector3 size( aabb.getSize() );
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+		
+        // result value
+        CollisionPtr rval;
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(size) == false )
+        {
+            correctSize(size);
+            LOG_MESSAGE(Logger::CORE, 
+                " AABB is too small, using 'box' instead of primitiv '" +
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+        // check if the geometry type is supported for aabb
+        if (geomType == PhysicsManager::GT_CONVEXHULL || 
+            geomType == PhysicsManager::GT_MESH)
+        {
+            LOG_MESSAGE(Logger::CORE, 
+                " the geometry type '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+
+                "' is not supported for aabb, fail back to box");
+            forceBox = true;
+        }
+
+        /* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+		if (geomType == PhysicsManager::GT_BOX || forceBox == true)
+        {
+			rval = createBox(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_PYRAMID)
+        {
+            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_SPHERE)
+        {
+			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_ELLIPSOID)
+        {
+            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+        }
+		else if (geomType == PhysicsManager::GT_CAPSULE)
+		{
+			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+		}
+        return rval;
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
+        const PhysicsManager::GeometryType& geomType,
+        Ogre::Vector3* offset,
+        Ogre::Quaternion* orientation,
+        const Ogre::Real Mass,
+        Ogre::Vector3* inertia) 
+    {
+        // bounding box of the mesh
+        const Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
+        // size of the mesh
+        Vector3 size( aabb.getSize() );
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+		
+        // result value
+        CollisionPtr rval;
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(size) == false )
+        {
+            correctSize(size);
+            LOG_MESSAGE(Logger::CORE, " Entity '"+entity->getName()+
+                "' is too small, using 'box' instead of primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+		/* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+		if (geomType == PhysicsManager::GT_BOX || forceBox == true)
+        {
+			rval = createBox(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_PYRAMID)
+        {
+            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_SPHERE)
+        {
+			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+        }
+        else if (geomType == PhysicsManager::GT_ELLIPSOID)
+        {
+            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+        }
+		else if (geomType == PhysicsManager::GT_CAPSULE)
+		{
+			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+		}
+        else if (geomType == PhysicsManager::GT_CONVEXHULL)
+        {
+            // offset of the collision primitiv
+	    	Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
+            // orientation of the collision primitiv
+		    Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+				
+            // set offset/orientation when they are null
+			if (! offset)
+				offset = &object_offset;
+			if (! orientation)
+				orientation = &object_orientation;
+
+			// calculate the convex hull of the animated mesh
+			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
+                PhysicsManager::getSingleton()._getNewtonWorld(),
+				entity, true, *orientation, *offset));
+
+			if (inertia != NULL)
+			{
+				*inertia = Vector3(
+				size.x*size.x/6.0f * Mass,
+				size.y*size.y/6.0f * Mass,
+				size.z*size.z/6.0f * Mass);
+			}
+        }
+        else if (geomType == PhysicsManager::GT_MESH)
+        {
+            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
+                PhysicsManager::getSingleton()._getNewtonWorld(),
+                entity, false, true));
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "unknown geometry type.");
+        }
+
+        if (rval.isNull())
+        {
+            LOG_DEBUG(Logger::CORE, " creating collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' for Entity '"+
+                entity->getName()+"' failed.");
+        }
+        else
+        {
+            LOG_DEBUG(Logger::CORE, " collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' created for Entity '"+
+                entity->getName()+"'");
+        }
+
+        return rval;
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset,
+            Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia)
+    {
+        // offset of the collision primitiv
+		Ogre::Vector3 object_offset( aabb.getCenter() );
+        // orientation of the collision primitiv
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+        // set offset/orientation when they are null
+		if (! offset)
+			offset = &object_offset;
+		if (! orientation)
+			orientation = &object_orientation;
+        if (inertia)
+            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(Mass, aabb.getSize());
+
+		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            aabb.getSize(), *orientation, *offset));
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset,
+            Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // positional offset of the collision primitiv
+        Ogre::Vector3 object_offset(aabb.getCenter());
+        // orientation of the collision primitiv
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+        // set offset/orientation when they are null
+		if (! offset)
+			offset = &object_offset;
+		if (! orientation)
+			orientation = &object_orientation;
+        if (inertia)
+            *inertia = Ogre::Vector3(size.x*Mass,size.y/2.0f*Mass, size.z*Mass);
+
+        return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            size, *orientation, *offset));
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset,
+            Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // calculate the maximum radius needed to include 'everything'
+        double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
+        // positional offset of the collision primitiv
+		Ogre::Vector3 object_offset(0,radius,0);
+        // orientation of the collision primitiv
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+        
+		// set offset/orientation when they are null
+		if (! offset)
+			offset = &object_offset;
+		if (! orientation)
+			orientation = &object_orientation;
+        if (inertia)
+            *inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
+
+		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+    		PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), *orientation, *offset));
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset,
+            Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // set the size x/z values to the maximum
+        Vector3 s(size/2.0);
+        s.x = std::max(s.x, s.z);
+        s.z = s.x;
+        // positional offset of the collision primitiv
+		Ogre::Vector3 object_offset(0,s.y,0);
+        // orientation of the collision primitiv
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+		// set offset/orientation when they are null
+		if (! offset) 
+			offset = &object_offset;
+		if (! orientation)
+			orientation = &object_orientation;
+        if (inertia)
+            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z);
+
+        // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
+        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            s, *orientation, *offset));
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
+            Ogre::Vector3* offset,
+            Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // positional offset of the collision primitiv
+		Ogre::Vector3 object_offset(0, size.y/2, 0);
+        // orientation of the collision primitiv
+		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+        double radius = std::max(size.x, size.z) / 2.0;
+		double height = size.y;
+        object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
+
+		// set offset/orientation when they are null
+		if (! offset)
+    		offset = &object_offset;
+		if (! orientation) 
+			orientation = &object_orientation;
+        if (inertia) {
+            double sradius = radius*radius;
+			*inertia = Vector3(sradius, size.y*size.y, sradius);
+        }
+
+		// an capsule primitiv has got its coordinate system at its center, so shift it with radius
+		// additionally it is x axis aligned, so rotate it 90 degrees around z axis
+		return CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            radius, height, *orientation, *offset));
+    }
+
 }



From josch at mail.berlios.de  Tue Mar 20 21:27:27 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Tue, 20 Mar 2007 21:27:27 +0100
Subject: [Dsa-hl-svn] r3187 - rl/trunk/engine/core/include
Message-ID: <200703202027.l2KKRR7A001604@sheep.berlios.de>

Author: josch
Date: 2007-03-20 21:27:24 +0100 (Tue, 20 Mar 2007)
New Revision: 3187

Modified:
   rl/trunk/engine/core/include/PhysicsManager.h
Log:
Syntax error removed

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-03-19 23:12:57 UTC (rev 3186)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-03-20 20:27:24 UTC (rev 3187)
@@ -233,7 +233,7 @@
          * possible in error messages.
          * @param geomType enum giving the collision primitiv.
          */
-        static Ogre::String PhysicsManager::convertGeometryTypeToString(const PhysicsManager::GeometryType& geomType);
+        static Ogre::String convertGeometryTypeToString(const PhysicsManager::GeometryType& geomType);
 
     private:
 



From natoka at mail.berlios.de  Tue Mar 20 21:31:25 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 20 Mar 2007 21:31:25 +0100
Subject: [Dsa-hl-svn] r3188 - rl/trunk/engine/core/src
Message-ID: <200703202031.l2KKVPgc001979@sheep.berlios.de>

Author: natoka
Date: 2007-03-20 21:31:17 +0100 (Tue, 20 Mar 2007)
New Revision: 3188

Modified:
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
bug fix for collisionptr deallocation problem


Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-20 20:27:24 UTC (rev 3187)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-20 20:31:17 UTC (rev 3188)
@@ -87,6 +87,9 @@
 
     PhysicsManager::~PhysicsManager()
     {
+        // simply remove all collision ptrs (is this really ok?)
+        mCollisionPrimitives.clear();
+
         // remove all materials
         for (MaterialMap::iterator it = mMaterials.begin(); it != mMaterials.end(); it++)
         {



From natoka at mail.berlios.de  Wed Mar 21 00:36:23 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 21 Mar 2007 00:36:23 +0100
Subject: [Dsa-hl-svn] r3189 - in rl/trunk/engine/core: include src
Message-ID: <200703202336.l2KNaNiO023205@sheep.berlios.de>

Author: natoka
Date: 2007-03-21 00:36:11 +0100 (Wed, 21 Mar 2007)
New Revision: 3189

Modified:
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
minor cleanup and some additional comments


Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-03-20 20:31:17 UTC (rev 3188)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-03-20 23:36:11 UTC (rev 3189)
@@ -205,12 +205,12 @@
          * so whenever an other entity with the same mesh tries to fetch
          * a collision primitive here, then it gets back the already existing
          * one (no need to duplicate).
-		 * @param aabb AxisAlignedBox that contains the extents of mesh whose coll. primitiv is to be created
-		 * @param inertiaCoefficients Vector3 returns the inertia coefficients for the created coll. primitiv
-		 * @param animName String specifies the name of the animation of the mesh whose coll. primitiv should be created,
-		 *        when "", then the basic mesh is used as a basis.
-		 * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
+		 * @param entity gives the mesh entity that needs a collision primitive
+         * @param geomType defines the geometry of the collision type
+         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		*/
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
@@ -218,9 +218,43 @@
             const PhysicsManager::GeometryType& geomType = PhysicsManager::GT_NONE,
 			Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
 
+        /** creates a collision primitive for OgreNewt.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given aabb,
+         * so whenever an other aabb with the same name tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
+         * @param name gives the name of the AxisAlignedBox
+         * @param geomType defines the geometry of the collision type
+         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		*/
+        OgreNewt::CollisionPtr createCollision(
+            const Ogre::String& name,
+            const Ogre::AxisAlignedBox& aabb,
+            const PhysicsManager::GeometryType& geomType = PhysicsManager::GT_NONE,
+            Ogre::Vector3* offset = NULL,
+			Ogre::Quaternion* orientation = NULL,
+            const Ogre::Real mass = 0,
+            Ogre::Vector3* inertia = NULL);
+
+        /** Makes the collision primitive generation available to non mesh objects.
+         * Non mesh objects need collision objects too. Therefore they can
+         * utilise this function for bypassing the caching mechanism of
+         * PhysicalManager.
+         * @returns a collision primitive creating factory object.
+         */
+        PhysicsCollisionFactory* getCollisionFactory();
+
         /** converts a string identifying a collision property into an enum.
          * Mainly for making string definitions of the collision property
          * possible in .gof files.
@@ -342,6 +376,8 @@
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
             const PhysicsManager::GeometryType& geomType,
@@ -362,6 +398,8 @@
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
             const PhysicsManager::GeometryType& geomType,
@@ -370,32 +408,70 @@
             const Ogre::Real Mass = 0,
             Ogre::Vector3* inertiaCoefficients = NULL);
     protected:
-        // to ease understanding and break up a huge factory creation function
-        // into smaller parts
+        /** creates a box collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         * @param mass gives the mass for inertia calculation.
+         * @param inertia when not null, an inertia is calculated and passed back.
+         */
         OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
+        /** creates a pyramid collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         * @param mass gives the mass for inertia calculation.
+         * @param inertia when not null, an inertia is calculated and passed back.
+         */
         OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
+        /** creates a sphere collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         * @param mass gives the mass for inertia calculation.
+         * @param inertia when not null, an inertia is calculated and passed back.
+         */
         OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
+        /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         * @param mass gives the mass for inertia calculation.
+         * @param inertia when not null, an inertia is calculated and passed back.
+         */
         OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
+        /** creates a capsule collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         * @param mass gives the mass for inertia calculation.
+         * @param inertia when not null, an inertia is calculated and passed back.
+         */
         OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
+            const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL);
     };
 }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-20 20:31:17 UTC (rev 3188)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-20 23:36:11 UTC (rev 3189)
@@ -355,10 +355,10 @@
         getMaterialPair(M1,M2)->setContactCallback(mGenericCallback);
     }
 
-    OgreNewt::CollisionPtr PhysicsManager::createCollision(Ogre::Entity* entity,
-            const Ogre::String animName, const PhysicsManager::GeometryType& geomType,
-            Ogre::Vector3* offset, Ogre::Quaternion* orientation,
-            const Ogre::Real Mass, Ogre::Vector3* inertia)
+    OgreNewt::CollisionPtr PhysicsManager::createCollision(
+        Ogre::Entity* entity, const Ogre::String animName,
+        const PhysicsManager::GeometryType& geomType, Ogre::Vector3* offset,
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
     {
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -390,35 +390,57 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromEntity(
-                entity, geomType, offset, orientation, Mass, inertia );
+                entity, geomType, offset, orientation, mass, inertia );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
         }
 
         return rval;
+    }
 
-            if (geomType == GT_CONVEXHULL) {
-                MeshObject *tempMesh = NULL;
+    OgreNewt::CollisionPtr PhysicsManager::createCollision(
+        const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
+        const PhysicsManager::GeometryType& geomType, Ogre::Vector3* offset,
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+    {
+        // result value
+        CollisionPtr rval;
+		
+        // check if there is a collision primitiv for the specified mesh object
+        CollisionInUse &usedcol (mCollisionPrimitives[name]);
+        // log some performance warning if collisionname is equal, but geomtype different ?
 
-            // the problem fixed and it's source:
-			// entity is a MeshObject containing the basic state of the Mesh, but
-			// this function should create the physical bounding convex hull for one of the
-			// animated states. Therefore the convex hull must be created from a mesh
-			// representing the animated state and not from a mesh containing the basic state
+        if (! usedcol.colPtr.isNull() )
+        {
+            if ( usedcol.geomType != geomType )
+            {   // when geometry types mismatch, issue performance warning
+                LOG_DEBUG(Logger::CORE, " performance warning creating an other collision primitives '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+ "' for AABB '"+
+                name +"' that already has got '"+
+                PhysicsManager::convertGeometryTypeToString(usedcol.geomType)+ "' as a primitive.");
+            } else {
+                // found it
+                rval = usedcol.colPtr;
+            }
+        }
+        
+        if (rval.isNull())
+        {
+            // if there is none, then create a new collision object
+            rval = mPhysicsCollisionFactory->createCollisionFromAABB(
+                aabb, geomType, offset, orientation, mass, inertia );
 
-			// check if this is a 'animated' state we have to create the convex hull for ...
+            usedcol.geomType = geomType;
+            usedcol.colPtr = rval;
+        }
 
-			if (animName != "") {
-				// Duplicating the MeshObject and animate it into the animName pose
-				//tempMesh = dynamic_cast<MeshObject*>(mPhysicalObject)->createPosedCopy(animName);
-				//entity = tempMesh->getEntity();
-			}
-            // fetch the collision body here ...
+        return rval;
+    }
 
-            // cleanup the temporary mesh
-			delete tempMesh;
-        }
+    PhysicsCollisionFactory* PhysicsManager::getCollisionFactory()
+    {
+        return mPhysicsCollisionFactory;
     }
 
 	PhysicsManager::GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String& geomTypeString)
@@ -715,7 +737,7 @@
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
+            const Ogre::Real mass,
             Ogre::Vector3* inertia)
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -732,7 +754,8 @@
 		if (! orientation)
 			orientation = &object_orientation;
         if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
+            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
+            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
 
 		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
         return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(



From natoka at mail.berlios.de  Wed Mar 21 22:08:22 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 21 Mar 2007 22:08:22 +0100
Subject: [Dsa-hl-svn] r3190 - in rl/trunk/engine/core: include src
Message-ID: <200703212108.l2LL8MiW004920@sheep.berlios.de>

Author: natoka
Date: 2007-03-21 22:08:05 +0100 (Wed, 21 Mar 2007)
New Revision: 3190

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
better handling and creation of collison primitives by caching collision primitives of meshs


Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-03-20 23:36:11 UTC (rev 3189)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-03-21 21:08:05 UTC (rev 3190)
@@ -229,6 +229,7 @@
 			const Ogre::String animName = "",
 			Ogre::Vector3* offset = NULL, 
 			Ogre::Quaternion* orientation = NULL) const;
+            
 	};
 }
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-20 23:36:11 UTC (rev 3189)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-21 21:08:05 UTC (rev 3190)
@@ -347,7 +347,7 @@
 					entity = tempMesh->getEntity();
 				}
 
-				// calculate the convex hull of the animated mesh
+				// create the collision primitive of the animated mesh
  				coll = PhysicsManager::getSingleton().createCollision(entity, animName, mGeometryType);
 
 				// cleanup the temporary mesh
@@ -373,6 +373,7 @@
         }
     }
 
+    
 	OgreNewt::CollisionPtr PhysicalThing::createCollision(
 		const AxisAlignedBox& aabb, Vector3* inertiaCoefficients,
 		const String animName, Vector3* offset, Quaternion* orientation ) const
@@ -384,16 +385,16 @@
 
         CollisionPtr rval;
 
-		/* inertiaCoefficients could be calculated like OgreNewt::MomentOfInertia 
-			or even better is to use it ? */
+		// inertiaCoefficients could be calculated like OgreNewt::MomentOfInertia 
+		//	or even better is to use it ? 
 
-		/* differentiate between the different collision primitives, because they all
-		   need different offset and probably different orientation values.
-		   Newton SDK is really nifty and helps here, because we can shift the origin
-		   of the coordinate system of the primitiv we create into any position we
-		   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		   always constructed like that.
-	    */
+		// differentiate between the different collision primitives, because they all
+		//   need different offset and probably different orientation values.
+		//   Newton SDK is really nifty and helps here, because we can shift the origin
+		//   of the coordinate system of the primitiv we create into any position we
+		//   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		//   always constructed like that.
+	    
 		if (mGeometryType == PhysicsManager::GT_BOX)
         {
 			// set offset/orientation when they are null
@@ -607,18 +608,44 @@
 	{
 		if (mBody == NULL) 
 		{
-            const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
-                        
-            Vector3 inertiaCoefficients;
-			OgreNewt::CollisionPtr coll = createCollision(aabb, &inertiaCoefficients);
+            OgreNewt::CollisionPtr coll;
+            Vector3 inertia;
 
+            // there is a difference between a meshobject and a 'normal' object
+            // because a meshobject has got an entity and therefore a direct name
+            // which is used to determine it's collision primitive cache hash
+            // value (in order to avoid duplication)
+
+            if (mPhysicalObject->isMeshObject())
+            {
+                Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
+                coll = PhysicsManager::getSingleton().createCollision(
+                    entity,
+                    "",
+                    mGeometryType,
+                    NULL,
+                    NULL,
+                    mMass,
+                    &inertia);
+            }
+            else
+            {
+                coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
+                    aabb,
+                    mGeometryType,
+                    NULL,
+                    NULL,
+                    mMass,
+                    &inertia);
+            }
+
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
 
 			Ogre::Real mass = mMass;
 			if (mass > 0.0 && mGeometryType != PhysicsManager::GT_MESH)
             {
-                body->setMassMatrix(mass, mass*inertiaCoefficients);
+                body->setMassMatrix(mass, inertia);
             }
 
 			body->setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-20 23:36:11 UTC (rev 3189)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-21 21:08:05 UTC (rev 3190)
@@ -652,9 +652,9 @@
 			if (inertia != NULL)
 			{
 				*inertia = Vector3(
-				size.x*size.x/6.0f * Mass,
-				size.y*size.y/6.0f * Mass,
-				size.z*size.z/6.0f * Mass);
+				size.x*size.x/6.0f,
+				size.y*size.y/6.0f,
+				size.z*size.z/6.0f) * Mass;
 			}
         }
         else if (geomType == PhysicsManager::GT_MESH)
@@ -687,7 +687,7 @@
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
+            const Ogre::Real mass,
             Ogre::Vector3* inertia)
     {
         // offset of the collision primitiv
@@ -701,7 +701,7 @@
 		if (! orientation)
 			orientation = &object_orientation;
         if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(Mass, aabb.getSize());
+            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
 
 		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
 		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
@@ -712,7 +712,7 @@
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
+            const Ogre::Real mass,
             Ogre::Vector3* inertia)
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -727,7 +727,7 @@
 		if (! orientation)
 			orientation = &object_orientation;
         if (inertia)
-            *inertia = Ogre::Vector3(size.x*Mass,size.y/2.0f*Mass, size.z*Mass);
+            *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
 
         return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
@@ -766,7 +766,7 @@
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
+            const Ogre::Real mass,
             Ogre::Vector3* inertia)
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -785,7 +785,7 @@
 		if (! orientation)
 			orientation = &object_orientation;
         if (inertia)
-            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z);
+            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
         return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
@@ -796,7 +796,7 @@
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
+            const Ogre::Real mass,
             Ogre::Vector3* inertia)
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -815,7 +815,7 @@
 			orientation = &object_orientation;
         if (inertia) {
             double sradius = radius*radius;
-			*inertia = Vector3(sradius, size.y*size.y, sradius);
+			*inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
         }
 
 		// an capsule primitiv has got its coordinate system at its center, so shift it with radius



From natoka at mail.berlios.de  Wed Mar 21 22:42:52 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 21 Mar 2007 22:42:52 +0100
Subject: [Dsa-hl-svn] r3191 - in rl/trunk/engine/core: include src
Message-ID: <200703212142.l2LLgqqt008456@sheep.berlios.de>

Author: natoka
Date: 2007-03-21 22:42:46 +0100 (Wed, 21 Mar 2007)
New Revision: 3191

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
removing old code and fixing a small bug preventing compilation


Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2007-03-21 21:08:05 UTC (rev 3190)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2007-03-21 21:42:46 UTC (rev 3191)
@@ -211,25 +211,6 @@
 		 */
 		PhysicsManager::GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
-
-		/** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-		 * @param aabb AxisAlignedBox that contains the extents of mesh whose coll. primitiv is to be created
-		 * @param inertiaCoefficients Vector3 returns the inertia coefficients for the created coll. primitiv
-		 * @param animName String specifies the name of the animation of the mesh whose coll. primitiv should be created,
-		 *        when "", then the basic mesh is used as a basis.
-		 * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-		*/
-		OgreNewt::CollisionPtr createCollision(
-			const Ogre::AxisAlignedBox& aabb,
-			Ogre::Vector3* inertiaCoefficients = NULL,
-			const Ogre::String animName = "",
-			Ogre::Vector3* offset = NULL, 
-			Ogre::Quaternion* orientation = NULL) const;
-            
 	};
 }
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-21 21:08:05 UTC (rev 3190)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-03-21 21:42:46 UTC (rev 3191)
@@ -373,238 +373,7 @@
         }
     }
 
-    
-	OgreNewt::CollisionPtr PhysicalThing::createCollision(
-		const AxisAlignedBox& aabb, Vector3* inertiaCoefficients,
-		const String animName, Vector3* offset, Quaternion* orientation ) const
-    {
-		const Vector3 size( aabb.getSize() );
-		OgreNewt::World* physWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-		Ogre::Vector3 object_offset = Ogre::Vector3::ZERO;
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-        CollisionPtr rval;
-
-		// inertiaCoefficients could be calculated like OgreNewt::MomentOfInertia 
-		//	or even better is to use it ? 
-
-		// differentiate between the different collision primitives, because they all
-		//   need different offset and probably different orientation values.
-		//   Newton SDK is really nifty and helps here, because we can shift the origin
-		//   of the coordinate system of the primitiv we create into any position we
-		//   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		//   always constructed like that.
-	    
-		if (mGeometryType == PhysicsManager::GT_BOX)
-        {
-			// set offset/orientation when they are null
-			if (! offset) {
-				offset = &object_offset;
-				*offset = aabb.getCenter();
-			}
-			if (! orientation)
-				orientation = &object_orientation;
-
-			// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-				physWorld,
-				size,
-				*orientation,
-				*offset)
-				);
-
-			if (inertiaCoefficients != NULL)
-			{
-                *inertiaCoefficients = Vector3(
-					size.x*size.x/6.0f,
-                    size.y*size.y/6.0f,
-                    size.z*size.z/6.0f);
-			}
-        }
-        else if (mGeometryType == PhysicsManager::GT_SPHERE)
-        {
-			double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-
-			// set offset/orientation when they are null
-			if (! offset) {
-				offset = &object_offset;
-				*offset = Vector3(0,radius,0);
-			}
-			if (! orientation)
-				orientation = &object_orientation;
-
-			// a sphere primitiv has got its coordinate system at its center, so shift it with radius
-            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-				physWorld,
-				Vector3(radius, radius, radius),
-				*orientation,
-				*offset)
-				);
-            
-			if (inertiaCoefficients != NULL)
-			{
-				*inertiaCoefficients = Vector3(radius*radius, radius*radius, radius*radius);
-			}
-        }
-        else if (mGeometryType == PhysicsManager::GT_ELLIPSOID)
-        {
-            // set the size x/z values to the maximum
-            Vector3 s(size/2.0);
-            s.x = std::max(s.x, s.z);
-            s.z = s.x;
-
-			// set offset/orientation when they are null
-			if (! offset) {
-				offset = &object_offset;
-				*offset = Vector3(0,s.y,0);
-			}
-			if (! orientation)
-				orientation = &object_orientation;
-
-			// an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-				physWorld, 
-				s,
-				*orientation,
-				*offset)
-				);
-
-            if (inertiaCoefficients != NULL)
-			{
-				*inertiaCoefficients = Vector3(s.x*s.x, s.y*s.y, s.z*s.z);
-            }
-        }
-		else if (mGeometryType == PhysicsManager::GT_CAPSULE)
-		{
-			double radius = std::max(size.x, size.z) / 2.0;
-			double height = size.y;
-
-			// set offset/orientation when they are null
-			if (! offset) {
-				offset = &object_offset;
-				*offset = Vector3(0, size.y/2, 0);
-			}
-			if (! orientation) {
-				orientation = &object_orientation;
-				orientation->FromAngleAxis(Degree(90), Vector3::UNIT_Z);
-			}
-
-			// an capsule primitiv has got its coordinate system at its center, so shift it with radius
-			// additionally it is x axis aligned, so rotate it 90 degrees around z axis
-			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-				physWorld, 
-				radius, 
-				height,
-				*orientation,
-				*offset)
-				);
-			
-			if (inertiaCoefficients != NULL)
-			{
-				double sradius = radius*radius;
-				*inertiaCoefficients = Vector3(sradius, size.y*size.y, sradius);
-			}
-		}
-        else if (mGeometryType == PhysicsManager::GT_CONVEXHULL)
-        {
-            if (mPhysicalObject->isMeshObject())
-            {
-				Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
-				MeshObject *tempMesh = NULL;
-				
-				if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
-					size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
-					size.z < PhysicsManager::NEWTON_GRID_WIDTH )
-				{
-					// Objekt zu klein!
-					LOG_MESSAGE(Logger::CORE, " PhyiscalThing too small to create a convexhull, using 'box' instead! ");
-
-					// set offset/orientation when they are null
-					if (! offset) {
-						offset = &object_offset;
-						*offset = aabb.getCenter();
-					}
-					if (! orientation)
-						orientation = &object_orientation;
-					
-					rval = CollisionPtr(new CollisionPrimitives::Box(
-						physWorld, 
-						size, 
-						*orientation,
-						*offset)
-						);
-				}
-				else
-				{
-					// set offset/orientation when they are null
-					if (! offset)
-						offset = &object_offset;
-					if (! orientation)
-						orientation = &object_orientation;
-
-					// the problem fixed and it's source:
-					// entity is a MeshObject containing the basic state of the Mesh, but
-					// this function should create the physical bounding convex hull for one of the
-					// animated states. Therefore the convex hull must be created from a mesh
-					// representing the animated state and not from a mesh containing the basic state
-
-					// check if this is a 'animated' state we have to create the convex hull for ...
-
-					if (animName != "") {
-						// Duplicating the MeshObject and animate it into the animName pose
-						tempMesh = dynamic_cast<MeshObject*>(mPhysicalObject)->createPosedCopy(animName);
-
-						entity = tempMesh->getEntity();
-					}
-
-					// calculate the convex hull of the animated mesh
-					rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(physWorld,
-						entity, true, *orientation, *offset));
-
-					// cleanup the temporary mesh
-					delete tempMesh;
-				}
-				if (inertiaCoefficients != NULL)
-				{
-					*inertiaCoefficients = Vector3(
-					size.x*size.x/6.0f,
-					size.y*size.y/6.0f,
-					size.z*size.z/6.0f);
-				}
-            }
-            else
-            {
-                Throw(IllegalArgumentException, "ConvexHull not possible for non-mesh objects.");
-            }
-        }
-        else if (mGeometryType == PhysicsManager::GT_MESH)
-        {
-            if (mPhysicalObject->isMeshObject())
-            {
-                Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
-                rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(physWorld,
-                    entity, false, true));
-            }
-            else
-            {
-                Throw(IllegalArgumentException,
-                    "TreeCollision not possible for non-mesh objects.");
-            }
-        }
-        else
-        {
-            Throw(IllegalArgumentException, "unknown geometry type.");
-        }
-
-		if (mHullModifier)
-        {
-            return CollisionPtr(new CollisionPrimitives::HullModifier(physWorld, rval));
-        }
-
-        return rval;
-    }
-
-	void PhysicalThing::createPhysicsProxy(SceneNode* node)
+    void PhysicalThing::createPhysicsProxy(SceneNode* node)
 	{
 		if (mBody == NULL) 
 		{
@@ -612,9 +381,9 @@
             Vector3 inertia;
 
             // there is a difference between a meshobject and a 'normal' object
-            // because a meshobject has got an entity and therefore a direct name
-            // which is used to determine it's collision primitive cache hash
-            // value (in order to avoid duplication)
+            // because a meshobject has got a mesh entity and therefore a it is
+            // likely that there will be more than one object with those collision 
+            // primitives, so they need to get cached.
 
             if (mPhysicalObject->isMeshObject())
             {
@@ -630,6 +399,7 @@
             }
             else
             {
+                const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
                 coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
                     aabb,
                     mGeometryType,

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-21 21:08:05 UTC (rev 3190)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-21 21:42:46 UTC (rev 3191)
@@ -659,6 +659,9 @@
         }
         else if (geomType == PhysicsManager::GT_MESH)
         {
+            if (inertia != NULL)
+                *inertia = Ogre::Vector3::ZERO;
+
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
                 entity, false, true));
@@ -806,6 +809,7 @@
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
         double radius = std::max(size.x, size.z) / 2.0;
 		double height = size.y;
+        // fixme: this is a semi ugly fix - because the orientation should be set by the loader
         object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
 
 		// set offset/orientation when they are null



From natoka at mail.berlios.de  Fri Mar 23 13:51:54 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Fri, 23 Mar 2007 13:51:54 +0100
Subject: [Dsa-hl-svn] r3192 - rl/trunk/engine/core/include
Message-ID: <200703231251.l2NCpsZ0012312@sheep.berlios.de>

Author: natoka
Date: 2007-03-23 13:51:24 +0100 (Fri, 23 Mar 2007)
New Revision: 3192

Added:
   rl/trunk/engine/core/include/QuadTree.h
Log:
adding a basic Quadtree template (which is yet not finished, but has to be discussed a bit)


Added: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-21 21:42:46 UTC (rev 3191)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-23 12:51:24 UTC (rev 3192)
@@ -0,0 +1,140 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+  
+#ifndef __QUADTREE_H__
+#define __QUADTREE_H__
+
+#include "CorePrerequisites.h"
+
+namespace rl
+{
+	
+/** A very basic quad tree template.
+ * It just stores whether the current node is subdivided or not and
+ * the data contained in the node.
+ * Normally this would be used in a uniform flat quadtree. That means
+ * that the quadtrees memory would be preallocated once and indexing
+ * would be used to map the 2D structure into the 1D memory.
+ * Non uniform quadtrees are also possible, but quite useless, because
+ * they consume the preallocated memory anyway.
+ * Anyway the node indexing should follow the defined style by the enum
+ * NodeLocation.
+ */
+template <class TData>
+struct TBasicQuadTree 
+{
+	/** Tells where the node within an array is located.
+	 * creates a counterclockwise location of nodes.
+	 */
+	enum NodeLocation 
+	{
+		TOP_LEFT = 0,		//!< upper left quad
+		BOTTOM_LEFT,		//!< lower left quad
+		BOTTOM_RIGHT,		//!< lower right quad
+		TOP_RIGHT			//!< upper right quad
+	};
+
+	bool		mSubDivided;	//!< true if node has subnodes
+	TData		mData;			//!< data of this node
+};
+
+/** A basic quadtree with pointer to it's children nodes.
+ * This quadree template is for (non) uniform quadtrees where additional
+ * nodes can be allocated and inserted on demand.
+ */
+template <class TData, class TNode>
+struct TBasicPointerQuadTree : public TBasicQuadTree< TData >
+{
+	TNode*		mNodes[4];	//!< four pointers to subnodes
+
+	// function for recursively deleting the quad tree
+	static void Delete (TBasicPointerQuadTree<TData, TNode> *node);
+};
+
+/** A basic Quadtree containing vertex data
+ */
+template <class TData, class TNode>
+struct TQuadTree : public TBasicPointerQuadTree< TData, TNode >
+{
+	Ogre::Vector3	mVertices[4];	//!< vertices of this node
+	float			mWidth;	//!< length of this quad
+
+
+	static void Delete (TQuadTree<TData, TNode> *node);
+}; /* TQuadTree */
+
+/** A basic loose quadtree.
+ * A loose quadtree consists of loose quads, which have an extended
+ * 'loose' area around them. So the quads do not only store the
+ * contents of the quad, but of the extende area too. This can be
+ * helpfull in eliminating additional traversals of the tree, when
+ * objects are near the border of the quad (or reaching into neighbouring
+ * quads).
+ */
+template <class TData, class TNode>
+struct TLooseQuadTree : public TQuadTree< std::vector< TData >, TNode >
+{
+	/** maximum number of elements in one leaf.
+	 * Whenever this number is reached a subdivision takes place.
+	 */
+	int mMaxData;
+	/** maximum level of depth.
+	 * prevents further subdivision when a leafnode is at this subdivision
+	 * level
+	 */
+	int mMaxDepth;
+	/** The looseness factor
+	 * Defines the size of the 'loose' area around the quad.
+	 * Should be between 1.0 and 1.5 - less or more doesn't make sense at all.
+	 */
+	float mLooseness;
+
+
+	void SetLooseness(float looseness);
+	void SetMaxDepth(int maxDepth);
+	void SetMaxData(int maxData);
+
+	float GetLooseness();
+	int GetMaxDepth();
+	int GetMaxData();
+
+	/** inserts the specified data.
+	 * The supplied axisaligned box specifies the extents of the given data.
+	 * According to that information the data is inserted at one or more
+	 * leaf nodes.
+	 */
+	void insert(const Ogre::AxisAlignedBoundingBox& aabb, TData data);
+
+	/** removes a node.
+	 * When the node has got subnodes they are also removed
+	 */
+	void removeNode();
+
+	/** searches the quadtree for a leaf that covers the specified position.
+	 * The search is done as if this is a normal quadtree (without any
+	 * loose boundaries applied 
+	 * @param position in world space coordinates
+	 */
+	TLooseQuadTree* find(Ogre::Vector3 position);
+
+}
+
+// contains the code for the defined functions
+#include "TQuadTree.hpp"
+
+}; /* world */
+
+#endif /* __QUADTREE_H__ */



From natoka at mail.berlios.de  Fri Mar 23 23:38:52 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Fri, 23 Mar 2007 23:38:52 +0100
Subject: [Dsa-hl-svn] r3193 - rl/trunk/engine/core/include
Message-ID: <200703232238.l2NMcqZH013057@sheep.berlios.de>

Author: natoka
Date: 2007-03-23 23:38:49 +0100 (Fri, 23 Mar 2007)
New Revision: 3193

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
adding additional functionality to a very basic quadtree template


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-23 12:51:24 UTC (rev 3192)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-23 22:38:49 UTC (rev 3193)
@@ -34,12 +34,12 @@
  * NodeLocation.
  */
 template <class TData>
-struct TBasicQuadTree 
+struct TQuadTreeBasicNode
 {
 	/** Tells where the node within an array is located.
 	 * creates a counterclockwise location of nodes.
 	 */
-	enum NodeLocation 
+	enum NodeLocation
 	{
 		TOP_LEFT = 0,		//!< upper left quad
 		BOTTOM_LEFT,		//!< lower left quad
@@ -56,24 +56,23 @@
  * nodes can be allocated and inserted on demand.
  */
 template <class TData, class TNode>
-struct TBasicPointerQuadTree : public TBasicQuadTree< TData >
+struct TQuadTreeBasicPointerNode : public TQuadTreeBasicNode< TData >
 {
 	TNode*		mNodes[4];	//!< four pointers to subnodes
 
 	// function for recursively deleting the quad tree
-	static void Delete (TBasicPointerQuadTree<TData, TNode> *node);
+	void removeNode (TQuadTreeBasicPointerNode<TData, TNode> *node);
 };
 
 /** A basic Quadtree containing vertex data
  */
 template <class TData, class TNode>
-struct TQuadTree : public TBasicPointerQuadTree< TData, TNode >
+struct TQuadTreeOgreNode : public TQuadTreeBasicPointerNode< TData, TNode >
 {
 	Ogre::Vector3	mVertices[4];	//!< vertices of this node
 	float			mWidth;	//!< length of this quad
 
-
-	static void Delete (TQuadTree<TData, TNode> *node);
+	void removeNode (TQuadTree<TData, TNode> *node);
 }; /* TQuadTree */
 
 /** A basic loose quadtree.
@@ -85,7 +84,7 @@
  * quads).
  */
 template <class TData, class TNode>
-struct TLooseQuadTree : public TQuadTree< std::vector< TData >, TNode >
+struct TLooseQuadTree : public TQuadTreeOgreNode< std::vector< TData >, TNode >
 {
 	/** maximum number of elements in one leaf.
 	 * Whenever this number is reached a subdivision takes place.
@@ -103,13 +102,13 @@
 	float mLooseness;
 
 
-	void SetLooseness(float looseness);
-	void SetMaxDepth(int maxDepth);
-	void SetMaxData(int maxData);
+	void SetLooseness(float looseness) { mLooseness = looseness; }
+	void SetMaxDepth(int maxDepth) { mMaxDepth = maxDepth; }
+	void SetMaxData(int maxData) { mMaxData = maxData; }
 
-	float GetLooseness();
-	int GetMaxDepth();
-	int GetMaxData();
+	float GetLooseness() { return mLooseness; }
+	int GetMaxDepth() { return mMaxDepth; }
+	int GetMaxData() { return mMaxData; }
 
 	/** inserts the specified data.
 	 * The supplied axisaligned box specifies the extents of the given data.
@@ -128,13 +127,50 @@
 	 * loose boundaries applied 
 	 * @param position in world space coordinates
 	 */
-	TLooseQuadTree* find(Ogre::Vector3 position);
+	TLooseQuadTree* find(const Ogre::Vector3& position);
 
 }
 
-// contains the code for the defined functions
-#include "TQuadTree.hpp"
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::insert(const Ogre::AxisAlignedBoundingBox& aabb, TData data)
+{
+	if (mSubdivided)
+	{
+		// try to add the data to any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i])
+				mNodes[i]->insert(aabb, data);
+		}
+	}
+	else
+	{
+		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
+		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
+		//aabb.getCorner(Ogre::AxisAlignedBox::FAR_RIGHT_BOTTOM)
+		//aabb.getCorner(Ogre::AxisAlignedBox::NEAR_LEFT_BOTTOM) 
+		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
+		if ( (isXInside(flb) && (isZInside(flb) || isZInside(nrb))) ||
+			 (isXInside(nrb) && (isZInside(flb) || isZInside(nrb))) )
+		{
+			// if at least one is in the loose quad, store the data
+			mData.push_back(data);
+		}
+	}
+}
 
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::removeNode()
+{
+}
+
+template <class TData, class TNode>
+TLooseQuadTree* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+{
+}
+
+
+
 }; /* world */
 
 #endif /* __QUADTREE_H__ */



From pnyx at mail.berlios.de  Sat Mar 24 12:53:12 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 24 Mar 2007 12:53:12 +0100
Subject: [Dsa-hl-svn] r3194 - in modules/ruchin: maps materials/textures
	models
Message-ID: <200703241153.l2OBrCAW020287@sheep.berlios.de>

Author: pnyx
Date: 2007-03-24 12:48:46 +0100 (Sat, 24 Mar 2007)
New Revision: 3194

Added:
   modules/ruchin/materials/textures/Ingrimiane_diffuse.png
   modules/ruchin/materials/textures/Ingrimiane_normal.png
   modules/ruchin/materials/textures/arc_Temple_Dirtmap.png
   modules/ruchin/materials/textures/arc_Temple_diffuse.png
   modules/ruchin/materials/textures/temple_outside_AO.png
   modules/ruchin/models/Statue01.material
   modules/ruchin/models/Statue_01.mesh
   modules/ruchin/models/Temple.material
   modules/ruchin/models/temple_outside.mesh
Modified:
   modules/ruchin/maps/ruchin.scene
Log:
Temple WIP added

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-03-23 22:38:49 UTC (rev 3193)
+++ modules/ruchin/maps/ruchin.scene	2007-03-24 11:48:46 UTC (rev 3194)
@@ -226,5 +226,52 @@
   
 
 		</node>
+		
+		<node name="temple_outside" id="1" >
+			<position x="122.11" y="0.076957" z="-20.5749" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="temple_outside"
+				id="2"
+				meshFile ="temple_outside.mesh"
+				materialFile="ruchin_terrainlayout19.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		
+		<node name="Statue_02" id="1" >
+			<position x="112.486" y="1.53497" z="-17.18" />
+			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Statue_02"
+				id="2"
+				meshFile ="Statue_01.mesh"
+				materialFile="ruchin_terrainlayout19.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
+		<node name="Statue_01" id="3" >
+			<position x="112.486" y="1.53497" z="-24.0179" />
+			<rotation qx="0.0" qy="-0.707107" qz="0.0" qw="0.707107" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Statue_01"
+				id="4"
+				meshFile ="Statue_01.mesh"
+				materialFile="ruchin_terrainlayout19.material"
+				castsShadow="false"
+			/>
+
+  
+
+		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Added: modules/ruchin/materials/textures/Ingrimiane_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Ingrimiane_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/Ingrimiane_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Ingrimiane_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/arc_Temple_Dirtmap.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/arc_Temple_Dirtmap.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/arc_Temple_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/arc_Temple_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/temple_outside_AO.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/temple_outside_AO.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/models/Statue01.material
===================================================================
--- modules/ruchin/models/Statue01.material	2007-03-23 22:38:49 UTC (rev 3193)
+++ modules/ruchin/models/Statue01.material	2007-03-24 11:48:46 UTC (rev 3194)
@@ -0,0 +1,6 @@
+material Statue_01 : NormalMapMaterial2Lights2UV
+{
+			set_texture_alias normalmap Ingrimiane_normal.png
+			set_texture_alias diffusemap Ingrimiane_diffuse.png
+
+}
\ No newline at end of file

Added: modules/ruchin/models/Statue_01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Statue_01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/models/Temple.material
===================================================================
--- modules/ruchin/models/Temple.material	2007-03-23 22:38:49 UTC (rev 3193)
+++ modules/ruchin/models/Temple.material	2007-03-24 11:48:46 UTC (rev 3194)
@@ -0,0 +1,36 @@
+
+material orig_06_-_Default
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.47451 0.47451 0.47451 1
+			diffuse 0.533333 0.533333 0.533333 1
+			specular 0.0784314 0.0784314 0.0784314 1 10
+			emissive 0.235294 0.235294 0.235294 1
+
+			texture_unit
+			{
+				texture_alias 0
+				texture arc_Temple_diffuse.png
+			}
+
+			texture_unit
+			{
+				texture_alias 1
+				texture arc_Temple_Dirtmap.png
+				tex_coord_set 1
+			}
+
+			texture_unit
+			{
+				texture_alias 2
+				texture temple_outside_AO.png
+				tex_coord_set 2
+			}
+		}
+
+	}
+
+}

Added: modules/ruchin/models/temple_outside.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/temple_outside.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From natoka at mail.berlios.de  Sun Mar 25 23:15:16 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Sun, 25 Mar 2007 23:15:16 +0200
Subject: [Dsa-hl-svn] r3195 - rl/trunk/engine/core/include
Message-ID: <200703252115.l2PLFGqU023710@sheep.berlios.de>

Author: natoka
Date: 2007-03-25 23:14:59 +0200 (Sun, 25 Mar 2007)
New Revision: 3195

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
extended loose quadtree design,  but it's still not finished.


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-24 11:48:46 UTC (rev 3194)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-25 21:14:59 UTC (rev 3195)
@@ -17,6 +17,10 @@
 #ifndef __QUADTREE_H__
 #define __QUADTREE_H__
 
+namespace Ogre {
+	class AxisAlignedBoundingBox;
+};
+
 #include "CorePrerequisites.h"
 
 namespace rl
@@ -47,6 +51,11 @@
 		TOP_RIGHT			//!< upper right quad
 	};
 
+	/** Returns the stored data.
+	 * @returns a const reference to the internally stored data
+	 */
+	const TData& getData() { return mData; }
+
 	bool		mSubDivided;	//!< true if node has subnodes
 	TData		mData;			//!< data of this node
 };
@@ -60,10 +69,21 @@
 {
 	TNode*		mNodes[4];	//!< four pointers to subnodes
 
+	TNode*	getNode(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location);
+
+	TQuadTreeBasicPointerNode();
+
 	// function for recursively deleting the quad tree
 	void removeNode (TQuadTreeBasicPointerNode<TData, TNode> *node);
 };
 
+template <class TData, class TNode>
+TQuadTreeBasicPointerNode<TData, TNode>::TQuadTreeBasicPointerNode()
+{
+	memset(mNodes, 0, sizeof(mNodes));
+	mSubDivided = false;
+}
+
 /** A basic Quadtree containing vertex data
  */
 template <class TData, class TNode>
@@ -72,9 +92,37 @@
 	Ogre::Vector3	mVertices[4];	//!< vertices of this node
 	float			mWidth;	//!< length of this quad
 
-	void removeNode (TQuadTree<TData, TNode> *node);
+	TQuadTreeOgreNode();
+
+	/** tests if the given u value is inside the quad.
+	 * Since this is a 2D test, the name refers to u coordinate
+	 * (instead of x for the 3D case).
+	 * @param u coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isUInside(Ogre::Real u) 
+	{ 
+		return (mVertices[TOP_LEFT].x < u && u < mVertices[BOTTOM_RIGHT].x);
+	}
+	/** tests if the given v value is inside the quad.
+	 * Since this is a 2D test, the name refers to v coordinate
+	 * (instead of z for the 3D case).
+	 * @param v coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isVInside(Ogre::Real v) 
+	{
+		return (mVertices[TOP_LEFT].z < v && v < mVertices[BOTTOM_RIGHT].z);
+	}
+
+	void remove(); //TQuadTree<TData, TNode> *node);
 }; /* TQuadTree */
 
+template <class TData, class TNode>
+TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode()
+: mWidth(0.0f)
+{
+	memset((char*) mVertices, 0, sizeof(mVertices));
+}
+
 /** A basic loose quadtree.
  * A loose quadtree consists of loose quads, which have an extended
  * 'loose' area around them. So the quads do not only store the
@@ -86,6 +134,8 @@
 template <class TData, class TNode>
 struct TLooseQuadTree : public TQuadTreeOgreNode< std::vector< TData >, TNode >
 {
+	TLooseQuadTree();
+
 	/** maximum number of elements in one leaf.
 	 * Whenever this number is reached a subdivision takes place.
 	 */
@@ -101,26 +151,64 @@
 	 */
 	float mLooseness;
 
-
-	void SetLooseness(float looseness) { mLooseness = looseness; }
+	/** Retrieves the loosness factor.
+	 */
+	float GetLooseness() { return (mLooseness / mWidth * 2.0f); }
+	/** Retrieves the maximum depth of the quadtree
+	 */
+	int GetMaxDepth() { return mMaxDepth; }
+	/** Retrieves the maximum number of data elements for a quad.
+	 */
+	int GetMaxData() { return mMaxData; }
+	
+	/** Sets the looseness factor to a new value.
+	 * mLooseness stores a precalculated looseness value.
+	 * The looseness is specified in percents of the width, so the loose quad
+	 * is the original quad + some additional area. e.g. 0.5 extends the original
+	 * length by 50% which means an additional area of 125%. Since this is evenly
+	 * distributed in all directions, the value that has to be added/substracted 
+	 * to the quad's original vertices is 25% of width. Those 25% of width are
+	 * stored in mLooseness.
+	 * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+	 */
+	void SetLooseness(float looseness) { mLooseness = mWidth * looseness / 2.0f; }
+	
 	void SetMaxDepth(int maxDepth) { mMaxDepth = maxDepth; }
+	
 	void SetMaxData(int maxData) { mMaxData = maxData; }
+	
+	/** tests if the given u value is inside the quad.
+	 * Since this is a 2D test, the name refers to u coordinate
+	 * (instead of x for the 3D case).
+	 * @param u coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isUInsideLoose(Ogre::Real u) 
+	{ 
+		return (mVertices[TOP_LEFT].x - mLooseness < u &&
+			u < mVertices[BOTTOM_RIGHT].x + mLooseness);
+	}
+	/** tests if the given v value is inside the quad.
+	 * Since this is a 2D test, the name refers to v coordinate
+	 * (instead of z for the 3D case).
+	 * @param v coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isVInsideLoose(Ogre::Real v) 
+	{
+		return (mVertices[TOP_LEFT].z - mLooseness < v &&
+			v < mVertices[BOTTOM_RIGHT].z + mLooseness);
+	}
 
-	float GetLooseness() { return mLooseness; }
-	int GetMaxDepth() { return mMaxDepth; }
-	int GetMaxData() { return mMaxData; }
-
 	/** inserts the specified data.
 	 * The supplied axisaligned box specifies the extents of the given data.
 	 * According to that information the data is inserted at one or more
 	 * leaf nodes.
 	 */
-	void insert(const Ogre::AxisAlignedBoundingBox& aabb, TData data);
+	void insert(Ogre::AxisAlignedBox& aabb, TData data);
 
 	/** removes a node.
 	 * When the node has got subnodes they are also removed
 	 */
-	void removeNode();
+	void remove();
 
 	/** searches the quadtree for a leaf that covers the specified position.
 	 * The search is done as if this is a normal quadtree (without any
@@ -129,12 +217,27 @@
 	 */
 	TLooseQuadTree* find(const Ogre::Vector3& position);
 
+	/** splits the node into subnodes.
+	 * Forces a split of the nodes data, creating 4 subnodes containing the
+	 * data of the original node. The original node persists as the parent
+	 * node of the new nodes.
+	 */
+	void split();
+
+};
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>::TLooseQuadTree()
+: mMaxData(0),
+  mMaxDepth(0),
+  mLooseness(0)
+{
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::insert(const Ogre::AxisAlignedBoundingBox& aabb, TData data)
+void TLooseQuadTree<TData,TNode>::insert(Ogre::AxisAlignedBox& aabb, TData data)
 {
-	if (mSubdivided)
+	if (mSubDivided)
 	{
 		// try to add the data to any of the subnodes
 		for (int i=0; i<4; i++)
@@ -150,25 +253,95 @@
 		//aabb.getCorner(Ogre::AxisAlignedBox::FAR_RIGHT_BOTTOM)
 		//aabb.getCorner(Ogre::AxisAlignedBox::NEAR_LEFT_BOTTOM) 
 		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
-		if ( (isXInside(flb) && (isZInside(flb) || isZInside(nrb))) ||
-			 (isXInside(nrb) && (isZInside(flb) || isZInside(nrb))) )
+		if ( (isVInsideLoose(flb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) ||
+			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
 		{
 			// if at least one is in the loose quad, store the data
 			mData.push_back(data);
 		}
+		// split if maximum number of elements is reached ...
+		if (mData.size() == mMaxData) 
+		{
+			split();
+		}
 	}
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::removeNode()
+void TLooseQuadTree<TData,TNode>::split()
 {
+	// create 4 subnodes
+	for (int i=0; i<4; i++)
+	{
+		if (! mNodes[i])
+			mNodes[i] = new TNode();
+	}
+
+	// distribute the data accordingly
+	Ogre::AxisAlignedBox aab;
+	for (std::vector<TData>::iterator it = mData.begin();
+		it != mData.end(); it++)
+	{
+		aab = TNode::getAABB((*it));
+		insert(aab,(*it));
+	}
+	// simply erase the data here ...
+	mData.clear();
+	mData.resize(1);
+
+	// remember that it's subdivided
+	mSubDivided = true;
 }
 
 template <class TData, class TNode>
-TLooseQuadTree* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+void TLooseQuadTree<TData,TNode>::remove()
 {
+	if (mSubdivided)
+	{
+		// try to add the data to any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i]) 
+			{
+				mNodes[i].removeNode();
+				delete mNodes[i];
+			}
+		}
+	}
 }
 
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+{
+	TLooseQuadTree* result = NULL;
+	if (mSubdivided)
+	{
+		// try to add the data to any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i]) 
+			{
+				result = mNodes[i].find(position);
+				if (result)
+					break;
+			}
+		}
+	}
+	else
+	{
+		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
+		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
+		//aabb.getCorner(Ogre::AxisAlignedBox::FAR_RIGHT_BOTTOM)
+		//aabb.getCorner(Ogre::AxisAlignedBox::NEAR_LEFT_BOTTOM) 
+		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
+		if ( isUInside(position.x) && isVInside(position.z) )
+		{
+			// if position is in the loose quad, return it
+			result = *this;
+		}
+	}
+	return result;
+}
 
 
 }; /* world */



From natoka at mail.berlios.de  Mon Mar 26 11:50:41 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Mon, 26 Mar 2007 11:50:41 +0200
Subject: [Dsa-hl-svn] r3196 - rl/trunk/engine/core/include
Message-ID: <200703260950.l2Q9ofFb030059@sheep.berlios.de>

Author: natoka
Date: 2007-03-26 11:50:07 +0200 (Mon, 26 Mar 2007)
New Revision: 3196

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
added non default constructors allowing the proper initialisation of the contents of a quad


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-25 21:14:59 UTC (rev 3195)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-26 09:50:07 UTC (rev 3196)
@@ -13,15 +13,18 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
-  
+
 #ifndef __QUADTREE_H__
 #define __QUADTREE_H__
 
 namespace Ogre {
-	class AxisAlignedBoundingBox;
+	class AxisAlignedBox;
+	class Vector2;
+	class Vector3;
 };
 
 #include "CorePrerequisites.h"
+#include "Exception.h"
 
 namespace rl
 {
@@ -38,8 +41,9 @@
  * NodeLocation.
  */
 template <class TData>
-struct TQuadTreeBasicNode
+class TQuadTreeBasicNode
 {
+public:
 	/** Tells where the node within an array is located.
 	 * creates a counterclockwise location of nodes.
 	 */
@@ -55,7 +59,7 @@
 	 * @returns a const reference to the internally stored data
 	 */
 	const TData& getData() { return mData; }
-
+protected:
 	bool		mSubDivided;	//!< true if node has subnodes
 	TData		mData;			//!< data of this node
 };
@@ -65,16 +69,27 @@
  * nodes can be allocated and inserted on demand.
  */
 template <class TData, class TNode>
-struct TQuadTreeBasicPointerNode : public TQuadTreeBasicNode< TData >
+class TQuadTreeBasicPointerNode : public TQuadTreeBasicNode< TData >
 {
+protected:
 	TNode*		mNodes[4];	//!< four pointers to subnodes
 
+public:
+	/** default constructor.
+	 * Initializes the subquad pointers to NULL
+	 */
+	TQuadTreeBasicPointerNode();
+
+	/** Retrieve the specified subnode.
+	 * Accounting the nature of (non) uniform quadtrees the returned pointer might
+	 * be NULL.
+	 * @param location whether to fetch the upper/lower left/right quad.
+	 * @returns the subquadtree node
+	 */
 	TNode*	getNode(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location);
 
-	TQuadTreeBasicPointerNode();
-
 	// function for recursively deleting the quad tree
-	void removeNode (TQuadTreeBasicPointerNode<TData, TNode> *node);
+	void remove(); //Node (TQuadTreeBasicPointerNode<TData, TNode> *node);
 };
 
 template <class TData, class TNode>
@@ -87,13 +102,60 @@
 /** A basic Quadtree containing vertex data
  */
 template <class TData, class TNode>
-struct TQuadTreeOgreNode : public TQuadTreeBasicPointerNode< TData, TNode >
+class TQuadTreeOgreNode : public TQuadTreeBasicPointerNode< TData, TNode >
 {
-	Ogre::Vector3	mVertices[4];	//!< vertices of this node
-	float			mWidth;	//!< length of this quad
+protected:
+	Ogre::Vector2	mVertexTL;	//!< top left vertex of this node
+	Ogre::Vector2	mVertexBR;	//!< bottom right vertex of this node
+	Ogre::Real		mWidth;		//!< length of this quad
 
+public:
+	/** Default constructor.
+	 * initializes a completely empty quad, that even doesn't represent a part
+	 * a space.
+	 */
 	TQuadTreeOgreNode();
 
+	/** Constructor to use for correct setup of quad.
+	 * Initialises the quad with all necessary data to function properly.
+	 */
+	TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth=0.0f);
+
+	/** Constructor to use for correct setup of quad.
+	 * Initialises the quad with all necessary data to function properly.
+	 */
+	//TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& blc, Ogre Vector2& lrc);
+
+	/** Fetches the width of the quad.
+	 * @returns the width of the quad.
+	 */
+	inline Ogre::Real getWidth() { return mWidth; }
+
+	/** Retrieve the specified corner vertex.
+	 * Since only the upper left and lower right corner of the quad are stored,
+	 * the two others have to be constructed.
+	 * @param location specifies which vertex to fetch (upper/lower-left/right).
+	 * @returns the wanted vertex.
+	 */
+	inline Ogre::Vector2 getVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location)
+	{
+		switch (location)
+		{
+		case TOP_LEFT:
+			return mVertexTL;
+		case BOTTOM_LEFT:
+			return Ogre::Vector2(mVertexTL.x, mVertexBR.y);
+		case BOTTOM_RIGHT:
+			return mVertexBR;
+		case TOP_RIGHT:
+			return Ogre::Vector2(mVertexBR.x, mVertexTL.y);
+		default:
+			Throw(IllegalArgumentException, "unknown NodeLocation type.");
+		}
+
+		return Ogre::Vector2(0.0f,0.0f);
+	}
+
 	/** tests if the given u value is inside the quad.
 	 * Since this is a 2D test, the name refers to u coordinate
 	 * (instead of x for the 3D case).
@@ -101,7 +163,7 @@
 	 */
 	inline bool isUInside(Ogre::Real u) 
 	{ 
-		return (mVertices[TOP_LEFT].x < u && u < mVertices[BOTTOM_RIGHT].x);
+		return (mVertices[TOP_LEFT].x < u && u < mVertices[BOTTOM_RIGHT].);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -110,7 +172,7 @@
 	 */
 	inline bool isVInside(Ogre::Real v) 
 	{
-		return (mVertices[TOP_LEFT].z < v && v < mVertices[BOTTOM_RIGHT].z);
+		return (mVertices[TOP_LEFT].y < v && v < mVertices[BOTTOM_RIGHT].y);
 	}
 
 	void remove(); //TQuadTree<TData, TNode> *node);
@@ -118,11 +180,29 @@
 
 template <class TData, class TNode>
 TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode()
-: mWidth(0.0f)
+: mWidth(0.0f),
+  mVertexTL(0,0),
+  mVertexBR(0,0)
 {
-	memset((char*) mVertices, 0, sizeof(mVertices));
+	//memset((char*) mVertices, 0, sizeof(mVertices));
 }
 
+template <class TData, class TNode>
+TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth)
+: mWidth(mWidth),
+  mVertexTL(tlc),
+  mVertexBR(brc)
+{
+	/*
+	mVertices[TOP_LEFT] = tlc;
+	mVertices[BOTTOM_LEFT].x = tlc.x;
+	mVertices[BOTTOM_LEFT].z = brc.z;
+	mVertices[BOTTOM_RIGHT] = brc;
+	mVertices[TOP_RIGHT].x = brc.x;
+	mVertices[TOP_RIGHT].z = tlc.z;
+	*/
+}
+
 /** A basic loose quadtree.
  * A loose quadtree consists of loose quads, which have an extended
  * 'loose' area around them. So the quads do not only store the
@@ -134,8 +214,14 @@
 template <class TData, class TNode>
 struct TLooseQuadTree : public TQuadTreeOgreNode< std::vector< TData >, TNode >
 {
+	//! default constructor
 	TLooseQuadTree();
 
+
+	TLooseQuadTree(int maxData, int maxDepth, float looseness, 
+		Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth=0.0f);
+
+
 	/** maximum number of elements in one leaf.
 	 * Whenever this number is reached a subdivision takes place.
 	 */
@@ -184,8 +270,9 @@
 	 */
 	inline bool isUInsideLoose(Ogre::Real u) 
 	{ 
-		return (mVertices[TOP_LEFT].x - mLooseness < u &&
-			u < mVertices[BOTTOM_RIGHT].x + mLooseness);
+		return (mVertexTL.x - mLooseness < u && u < mVertexBR.x + mLooseness);
+		//return (mVertices[TOP_LEFT].x - mLooseness < u &&
+		//	u < mVertices[BOTTOM_RIGHT].x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -194,8 +281,9 @@
 	 */
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
-		return (mVertices[TOP_LEFT].z - mLooseness < v &&
-			v < mVertices[BOTTOM_RIGHT].z + mLooseness);
+		return (mVertexTL.y - mLooseness < v && v < mVertexBR.y + mLooseness);
+		//return (mVertices[TOP_LEFT].y - mLooseness < v &&
+		//	v < mVertices[BOTTOM_RIGHT].y + mLooseness);
 	}
 
 	/** inserts the specified data.
@@ -203,7 +291,7 @@
 	 * According to that information the data is inserted at one or more
 	 * leaf nodes.
 	 */
-	void insert(Ogre::AxisAlignedBox& aabb, TData data);
+	void insert(TData data);
 
 	/** removes a node.
 	 * When the node has got subnodes they are also removed
@@ -235,23 +323,33 @@
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::insert(Ogre::AxisAlignedBox& aabb, TData data)
+TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
+											 float looseness, Ogre::Vector2& tlc,
+											 Ogre::Vector2& brc, float mWidth)
+: TQuadTreeOgreNode< std::vector< TData >, TNode >(tlc, brc, mWidth),
+  mMaxData(maxData),
+  mMaxDepth(maxDepth),
+  mLooseness(looseness)
 {
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::insert(TData data)
+{
 	if (mSubDivided)
 	{
 		// try to add the data to any of the subnodes
 		for (int i=0; i<4; i++)
 		{
 			if (mNodes[i])
-				mNodes[i]->insert(aabb, data);
+				mNodes[i]->insert(data);
 		}
 	}
 	else
 	{
+		Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
 		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
 		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
-		//aabb.getCorner(Ogre::AxisAlignedBox::FAR_RIGHT_BOTTOM)
-		//aabb.getCorner(Ogre::AxisAlignedBox::NEAR_LEFT_BOTTOM) 
 		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
 		if ( (isVInsideLoose(flb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) ||
 			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
@@ -270,20 +368,30 @@
 template <class TData, class TNode>
 void TLooseQuadTree<TData,TNode>::split()
 {
+	Ogre::Real HalfWidth = mWidth/2.0f;
+	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, -HalfWidth));
 	// create 4 subnodes
-	for (int i=0; i<4; i++)
-	{
-		if (! mNodes[i])
-			mNodes[i] = new TNode();
-	}
+	mNodes[TOP_LEFT] = 
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+		          mVertexTL, center, HalfWidth);
+	mNodes[BOTTOM_LEFT] = 
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+		          Ogre::Vector2(mVertexTL.x, center.y),
+				  Ogre::Vector2(center.x, mVertexBR.y), HalfWidth);
+	mNodes[BOTTOM_RIGHT] =
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
+				  center, mVertexBR, HalfWidth);
+	mNodes[TOP_RIGHT] =
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+				  Ogre::Vector2(center.x, mVertexTL.y),
+				  Ogre::Vector2(mVertexBR.x, center.y), HalfWidth);
 
-	// distribute the data accordingly
+	// distribute the data accordingly between the subnodes
 	Ogre::AxisAlignedBox aab;
 	for (std::vector<TData>::iterator it = mData.begin();
 		it != mData.end(); it++)
 	{
-		aab = TNode::getAABB((*it));
-		insert(aab,(*it));
+		insert((*it));
 	}
 	// simply erase the data here ...
 	mData.clear();
@@ -298,7 +406,7 @@
 {
 	if (mSubdivided)
 	{
-		// try to add the data to any of the subnodes
+		// try to remove the data of any of the subnodes
 		for (int i=0; i<4; i++)
 		{
 			if (mNodes[i]) 
@@ -316,10 +424,10 @@
 	TLooseQuadTree* result = NULL;
 	if (mSubdivided)
 	{
-		// try to add the data to any of the subnodes
+		// try to search for the data in any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i]) 
+			if (mNodes[i])
 			{
 				result = mNodes[i].find(position);
 				if (result)
@@ -330,10 +438,6 @@
 	else
 	{
 		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
-		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
-		//aabb.getCorner(Ogre::AxisAlignedBox::FAR_RIGHT_BOTTOM)
-		//aabb.getCorner(Ogre::AxisAlignedBox::NEAR_LEFT_BOTTOM) 
-		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
 		if ( isUInside(position.x) && isVInside(position.z) )
 		{
 			// if position is in the loose quad, return it



From natoka at mail.berlios.de  Tue Mar 27 22:59:56 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Tue, 27 Mar 2007 22:59:56 +0200
Subject: [Dsa-hl-svn] r3197 - rl/trunk/engine/core/include
Message-ID: <200703272059.l2RKxuUV016883@sheep.berlios.de>

Author: natoka
Date: 2007-03-27 22:59:52 +0200 (Tue, 27 Mar 2007)
New Revision: 3197

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
splitup of TLooseQuadTree template, because it is better to distinguish between tree management code and node code


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-26 09:50:07 UTC (rev 3196)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-27 20:59:52 UTC (rev 3197)
@@ -119,7 +119,7 @@
 	/** Constructor to use for correct setup of quad.
 	 * Initialises the quad with all necessary data to function properly.
 	 */
-	TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth=0.0f);
+	TQuadTreeOgreNode(const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
 
 	/** Constructor to use for correct setup of quad.
 	 * Initialises the quad with all necessary data to function properly.
@@ -156,6 +156,9 @@
 		return Ogre::Vector2(0.0f,0.0f);
 	}
 
+    inline Ogre::Vector2 getTopLeft() { return mVertexTL; }
+    inline Ogre::Vector2 getBottomRight() { return mVertexBR; }
+
 	/** tests if the given u value is inside the quad.
 	 * Since this is a 2D test, the name refers to u coordinate
 	 * (instead of x for the 3D case).
@@ -163,7 +166,7 @@
 	 */
 	inline bool isUInside(Ogre::Real u) 
 	{ 
-		return (mVertices[TOP_LEFT].x < u && u < mVertices[BOTTOM_RIGHT].);
+		return (mVertexTL.x < u && u < mVertexBR.x);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -172,7 +175,7 @@
 	 */
 	inline bool isVInside(Ogre::Real v) 
 	{
-		return (mVertices[TOP_LEFT].y < v && v < mVertices[BOTTOM_RIGHT].y);
+		return (mVertexTL.y < v && v < mVertexBR.y);
 	}
 
 	void remove(); //TQuadTree<TData, TNode> *node);
@@ -188,7 +191,8 @@
 }
 
 template <class TData, class TNode>
-TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth)
+TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode(
+    const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
 : mWidth(mWidth),
   mVertexTL(tlc),
   mVertexBR(brc)
@@ -212,17 +216,82 @@
  * quads).
  */
 template <class TData, class TNode>
-struct TLooseQuadTree : public TQuadTreeOgreNode< std::vector< TData >, TNode >
+class TLooseQuadTree //: public TQuadTreeOgreNode< std::vector< TData >, TNode >
 {
+public:
 	//! default constructor
 	TLooseQuadTree();
 
-
 	TLooseQuadTree(int maxData, int maxDepth, float looseness, 
-		Ogre::Vector2& tlc, Ogre::Vector2& brc, float mWidth=0.0f);
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
 
+	//TLooseQuadTree(const TLooseQuadTree<TData, TNode>& Node);
 
-	/** maximum number of elements in one leaf.
+	/** Retrieves the loosness factor.
+	 */
+	float getLooseness() { return (mLooseness / mWidth * 2.0f); }
+	/** Retrieves the maximum depth of the quadtree
+	 */
+	int getMaxDepth() { return mMaxDepth; }
+	/** Retrieves the maximum number of data elements for a quad.
+	 */
+	int getMaxData() { return mMaxData; }
+
+    TLooseQuadTree<TData, TNode>* find(const Ogre::Vector3& position);
+	
+	/** Sets the looseness factor to a new value.
+	 * mLooseness stores a precalculated looseness value.
+	 * The looseness is specified in percents of the width, so the loose quad
+	 * is the original quad + some additional area. e.g. 0.5 extends the original
+	 * length by 50% which means an additional area of 125%. Since this is evenly
+	 * distributed in all directions, the value that has to be added/substracted 
+	 * to the quad's original vertices is 25% of width. Those 25% of width are
+	 * stored in mLooseness.
+	 * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+	 */
+	void setLoosenessFactor(float loosenessfactor) { mLoosenessFactor = loosenessfactor; }
+	
+	void setMaxDepth(int maxDepth) { mMaxDepth = maxDepth; }
+	
+	void setMaxData(int maxData) { mMaxData = maxData; }
+
+    inline void setExtents(const Ogre::Vector2& tlc, const Ogre::Vector2& brc)
+    {
+        if (!mRoot)
+            mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (brc.x-tlc.x) / 2.0f,
+            tlc, brc, brc.x-tlc.x);
+    }
+
+	/** adds the specified data.
+	 * Takes into account that the specified data might not be completely
+	 * inside the quadtree resulting into a top node 'split'.
+	 * @param data the data to insert.
+	 */
+	void add(TData data);
+
+
+    void removeAll();
+
+protected:
+
+    /* adds nodes to the quadtree at it's top.
+     * This extends the quadtree above it's root node, so that the specified
+     * point is covered by the node.
+     * @param u x-coordinate of point in world space
+     * @param v z-coordinate of point in world space
+     */
+    void extend(const Ogre::Real& u, const Ogre::Real& v);
+
+    /* creates a new root node and adds the tree as one of it's subparts.
+     * The nodelocation gives the orientation of the new rootnode relative to
+     * the existing root node. So e.g TOP_LEFT means that the new root node
+     * will extend into the TOP_LEFT direction (!= place the old root node
+     * TOP_LEFT).
+     * @param location new location direction
+     */
+    void createNewRootNode(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location);
+
+    /** maximum number of elements in one leaf.
 	 * Whenever this number is reached a subdivision takes place.
 	 */
 	int mMaxData;
@@ -235,40 +304,48 @@
 	 * Defines the size of the 'loose' area around the quad.
 	 * Should be between 1.0 and 1.5 - less or more doesn't make sense at all.
 	 */
-	float mLooseness;
+	float mLoosenessFactor;
 
+    /** The root node of the quad tree.
+     */
+    TNode* mRoot;
+    //TLooseQuadTreeNode< std::vector< TData >,
+    
+};
+
+/** A basic loose quadtree.
+ * A loose quadtree consists of loose quads, which have an extended
+ * 'loose' area around them. So the quads do not only store the
+ * contents of the quad, but of the extende area too. This can be
+ * helpfull in eliminating additional traversals of the tree, when
+ * objects are near the border of the quad (or reaching into neighbouring
+ * quads).
+ */
+template <class TData, class TNode>
+class TLooseQuadTreeNode : public TQuadTreeOgreNode< std::vector< TData >, TNode >
+{
+public:
+    TLooseQuadTreeNode(int maxData, int maxDepth, float looseness, 
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
+
+    TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node);
+
 	/** Retrieves the loosness factor.
 	 */
-	float GetLooseness() { return (mLooseness / mWidth * 2.0f); }
+	float getLooseness() { return (mLooseness / mWidth * 2.0f); }
 	/** Retrieves the maximum depth of the quadtree
 	 */
-	int GetMaxDepth() { return mMaxDepth; }
+	int getMaxDepth() { return mMaxDepth; }
 	/** Retrieves the maximum number of data elements for a quad.
 	 */
-	int GetMaxData() { return mMaxData; }
-	
-	/** Sets the looseness factor to a new value.
-	 * mLooseness stores a precalculated looseness value.
-	 * The looseness is specified in percents of the width, so the loose quad
-	 * is the original quad + some additional area. e.g. 0.5 extends the original
-	 * length by 50% which means an additional area of 125%. Since this is evenly
-	 * distributed in all directions, the value that has to be added/substracted 
-	 * to the quad's original vertices is 25% of width. Those 25% of width are
-	 * stored in mLooseness.
-	 * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
-	 */
-	void SetLooseness(float looseness) { mLooseness = mWidth * looseness / 2.0f; }
-	
-	void SetMaxDepth(int maxDepth) { mMaxDepth = maxDepth; }
-	
-	void SetMaxData(int maxData) { mMaxData = maxData; }
-	
-	/** tests if the given u value is inside the quad.
+	int getMaxData() { return mMaxData; }
+
+   	/** tests if the given u value is inside the quad.
 	 * Since this is a 2D test, the name refers to u coordinate
 	 * (instead of x for the 3D case).
 	 * @param u coordinate to test whether it is inside the quad or not.
 	 */
-	inline bool isUInsideLoose(Ogre::Real u) 
+	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
 		return (mVertexTL.x - mLooseness < u && u < mVertexBR.x + mLooseness);
 		//return (mVertices[TOP_LEFT].x - mLooseness < u &&
@@ -286,7 +363,7 @@
 		//	v < mVertices[BOTTOM_RIGHT].y + mLooseness);
 	}
 
-	/** inserts the specified data.
+   	/** inserts the specified data.
 	 * The supplied axisaligned box specifies the extents of the given data.
 	 * According to that information the data is inserted at one or more
 	 * leaf nodes.
@@ -303,29 +380,40 @@
 	 * loose boundaries applied 
 	 * @param position in world space coordinates
 	 */
-	TLooseQuadTree* find(const Ogre::Vector3& position);
+	TLooseQuadTreeNode* find(const Ogre::Vector3& position);
 
-	/** splits the node into subnodes.
+    friend TLooseQuadTree< TData, TNode >;
+
+protected:
+   	/** splits the node into subnodes.
 	 * Forces a split of the nodes data, creating 4 subnodes containing the
 	 * data of the original node. The original node persists as the parent
 	 * node of the new nodes.
 	 */
 	void split();
 
+    void SetVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex);
+
+    /** maximum number of elements in one leaf.
+	 * Whenever this number is reached a subdivision takes place.
+	 */
+	int mMaxData;
+	/** maximum level of depth.
+	 * prevents further subdivision when a leafnode is at this subdivision
+	 * level
+	 */
+	int mMaxDepth;
+	/** The looseness factor
+	 * Defines the size of the 'loose' area around the quad.
+	 * Should be between 1.0 and 1.5 - less or more doesn't make sense at all.
+	 */
+	float mLooseness;
 };
 
 template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>::TLooseQuadTree()
-: mMaxData(0),
-  mMaxDepth(0),
-  mLooseness(0)
-{
-}
-
-template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
-											 float looseness, Ogre::Vector2& tlc,
-											 Ogre::Vector2& brc, float mWidth)
+TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(int maxData, int maxDepth,
+											 float looseness, const Ogre::Vector2& tlc,
+											 const Ogre::Vector2& brc, float mWidth)
 : TQuadTreeOgreNode< std::vector< TData >, TNode >(tlc, brc, mWidth),
   mMaxData(maxData),
   mMaxDepth(maxDepth),
@@ -334,8 +422,17 @@
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::insert(TData data)
+TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node)
+: TQuadTreeOgreNode< std::vector< TData >, TNode >(Node.mVertexTL, Node.mVertexBR, Node.mWidth),
+  mMaxData(Node.mMaxData),
+  mMaxDepth(Node.mMaxDepth),
+  mLooseness(Node.mLooseness)
 {
+}
+
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
+{
 	if (mSubDivided)
 	{
 		// try to add the data to any of the subnodes
@@ -366,7 +463,7 @@
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::split()
+void TLooseQuadTreeNode<TData,TNode>::split()
 {
 	Ogre::Real HalfWidth = mWidth/2.0f;
 	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, -HalfWidth));
@@ -402,24 +499,27 @@
 }
 
 template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::remove()
+void TLooseQuadTreeNode<TData,TNode>::remove()
 {
-	if (mSubdivided)
+	if (mSubDivided)
 	{
 		// try to remove the data of any of the subnodes
 		for (int i=0; i<4; i++)
 		{
 			if (mNodes[i]) 
 			{
-				mNodes[i].removeNode();
+				mNodes[i]->remove();
 				delete mNodes[i];
+				mNodes[i] = NULL;
 			}
 		}
 	}
+	else 
+		mSubDivided = false;
 }
 
 template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
 {
 	TLooseQuadTree* result = NULL;
 	if (mSubdivided)
@@ -447,7 +547,239 @@
 	return result;
 }
 
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData, TNode>::SetVertex(
+	enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex)
+{
+	switch (location)
+	{
+	case TOP_LEFT:
+		mVertexTL = vertex;
+		break;
+	case BOTTOM_RIGHT:
+		mVertexBR = vertex;
+		break;
+	case BOTTOM_LEFT:
+	case TOP_RIGHT:
+		Throw (IllegalArgumentException, "Cannot set lowerleft/upperright corner");
+		break;
+	default:
+		Throw (IllegalArgumentException, "unknown NodeLocation type.");
+	}
+}
 
+
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>::TLooseQuadTree()
+: mMaxData(0),
+  mMaxDepth(0),
+  mLoosenessFactor(0),
+  mRoot(NULL)
+{
+}
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
+											 float loosenessfactor, const Ogre::Vector2& tlc,
+											 const Ogre::Vector2& brc, float mWidth)
+: mMaxData(maxData),
+  mMaxDepth(maxDepth),
+  mLoosenessFactor(loosenessfactor)
+{
+    mRoot = new TNode(maxData,maxDepth,looseness, tlc, brc, mWidth);
+}
+
+
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::add(TData data)
+{
+    Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
+    Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
+    Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
+
+    if (!mRoot)
+        mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (nrb.x-flb.x) / 2.0f,
+        Ogre::Vector2(flb.x,flb.z), Ogre::Vector2(nrb.x,nrb.z), nrb.x-flb.x);
+
+	// check if the bounding box is completely inside
+    if ( ! (mRoot->isVInside(flb.x) && mRoot->isUInside(flb.z) && 
+            mRoot->isVInside(nrb.x) && mRoot->isUInside(nrb.z)) )
+    {
+        // when not, then split root node accordingly
+        extend(flb.x, flb.z);
+        extend(nrb.x, nrb.z);
+    }
+    // after test insert normally
+    mRoot->insert(data);
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::createNewRootNode(
+    enum rl::TQuadTreeBasicNode<TData>::NodeLocation location)
+{
+    typedef rl::TQuadTreeBasicNode<TData> BNode;
+    TNode* oldroot = mRoot;
+    int oldMaxDepth = mMaxDepth;
+    float oldLooseness = oldroot->getLooseness();
+    float oldWidth = oldroot->getWidth();
+
+    float newLooseness = oldLooseness * 2.0f;
+    float newWidth = oldWidth * 2.0f;
+    mMaxDepth++;
+    Ogre::Vector2 vertexTL(oldroot->mVertexTL);
+    Ogre::Vector2 vertexBR(oldroot->mVertexBR);
+    
+    Ogre::Vector2 newVertexTL;
+    Ogre::Vector2 newVertexBR;
+	switch (location)
+	{
+	case BNode::TOP_LEFT:
+        // first create new root (top) node
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, vertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] = 
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      vertexTL + Ogre::Vector2(-oldWidth,oldWidth), 
+                      vertexTL, oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      vertexTL + Ogre::Vector2(-oldWidth,0.0f), 
+                      vertexBR + Ogre::Vector2(-oldWidth,0.0f), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = oldroot;
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, mMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(0.0f,oldWidth), 
+            vertexBR + Ogre::Vector2(0.0f,oldWidth), oldWidth);
+		break;
+    case BNode::BOTTOM_LEFT:
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,0.0f);
+        newVertexBR = vertexBR + Ogre::Vector2(0.0f,-oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, newVertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(-oldWidth,0.0f), 
+            vertexBR + Ogre::Vector2(-oldWidth,0.0f), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(-oldWidth,-oldWidth), 
+            vertexBR + Ogre::Vector2(-oldWidth,-oldWidth), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(0.0f,-oldWidth), 
+            vertexBR + Ogre::Vector2(0.0f,-oldWidth), oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] = oldroot;
+        break;
+    case BNode::BOTTOM_RIGHT:
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,-oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            vertexTL, newVertexBR, newWidth);
+
+		mRoot->mNodes[BNode::TOP_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(0.0f,-oldWidth), 
+            vertexBR + Ogre::Vector2(0.0f,-oldWidth), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexBR,
+            vertexBR + Ogre::Vector2(oldWidth,-oldWidth), oldWidth);
+        mRoot->mNodes[rl::TQuadTreeBasicNode<TData>::TOP_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(oldWidth,0.0f), 
+            vertexBR + Ogre::Vector2(oldWidth,0.0f), oldWidth);
+        
+		break;
+	case BNode::TOP_RIGHT:
+        newVertexTL = vertexTL + Ogre::Vector2(0.0f,oldWidth);
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,0.0f);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, newVertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(0.0f,oldWidth),
+            vertexBR + Ogre::Vector2(0.0f,oldWidth), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(oldWidth,0.0f),
+            vertexBR + Ogre::Vector2(oldWidth,0.0f), oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
+            vertexTL + Ogre::Vector2(oldWidth,oldWidth),
+            vertexBR + Ogre::Vector2(oldWidth,oldWidth), oldWidth);
+		break;
+	default:
+		Throw (IllegalArgumentException, "unknown NodeLocation type.");
+    }
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::extend(const Ogre::Real& u, const Ogre::Real& v)
+{
+    // grow the root node according to the position of the point
+    if ( u < mRoot->mVertexTL.x ) 
+    {
+        if ( v < mRoot->mVertexTL.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexBR.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_LEFT);
+            extend(u,v);
+        }
+        else
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
+            extend(u,v);
+        }
+    }
+    else if ( u > mRoot->mVertexBR.x )
+    {
+        if ( v < mRoot->mVertexBR.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexTL.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
+            extend(u,v);
+        }  
+        else
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+    }
+    else //  u is inside
+    {
+        if ( v < mRoot->mVertexBR.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexTL.y )
+        {
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
+            extend(u,v);
+        }
+    }
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::removeAll()
+{
+    if (mRoot)
+        delete mRoot;
+    mRoot = NULL;
+}
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+{
+    return mRoot->find(position);
+}
+
 }; /* world */
 
 #endif /* __QUADTREE_H__ */



From natoka at mail.berlios.de  Wed Mar 28 05:26:53 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 28 Mar 2007 05:26:53 +0200
Subject: [Dsa-hl-svn] r3198 - rl/trunk/engine/core/include
Message-ID: <200703280326.l2S3QrpK023067@sheep.berlios.de>

Author: natoka
Date: 2007-03-28 05:26:49 +0200 (Wed, 28 Mar 2007)
New Revision: 3198

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
reversed y coordinate handling to properly support right hand side coordinate system


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-27 20:59:52 UTC (rev 3197)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-28 03:26:49 UTC (rev 3198)
@@ -156,7 +156,11 @@
 		return Ogre::Vector2(0.0f,0.0f);
 	}
 
+    /** retrieves the topleft vertex
+     */
     inline Ogre::Vector2 getTopLeft() { return mVertexTL; }
+    /** retrieves the bottom right vertex
+     */
     inline Ogre::Vector2 getBottomRight() { return mVertexBR; }
 
 	/** tests if the given u value is inside the quad.
@@ -197,14 +201,8 @@
   mVertexTL(tlc),
   mVertexBR(brc)
 {
-	/*
-	mVertices[TOP_LEFT] = tlc;
-	mVertices[BOTTOM_LEFT].x = tlc.x;
-	mVertices[BOTTOM_LEFT].z = brc.z;
-	mVertices[BOTTOM_RIGHT] = brc;
-	mVertices[TOP_RIGHT].x = brc.x;
-	mVertices[TOP_RIGHT].z = tlc.z;
-	*/
+    // right hand side coordinate system (2D part) xz plane
+    RlAssert ( (tlc < brc), "coordinates don't fit together" );
 }
 
 /** A basic loose quadtree.
@@ -348,8 +346,6 @@
 	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
 		return (mVertexTL.x - mLooseness < u && u < mVertexBR.x + mLooseness);
-		//return (mVertices[TOP_LEFT].x - mLooseness < u &&
-		//	u < mVertices[BOTTOM_RIGHT].x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -359,8 +355,6 @@
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
 		return (mVertexTL.y - mLooseness < v && v < mVertexBR.y + mLooseness);
-		//return (mVertices[TOP_LEFT].y - mLooseness < v &&
-		//	v < mVertices[BOTTOM_RIGHT].y + mLooseness);
 	}
 
    	/** inserts the specified data.
@@ -392,6 +386,10 @@
 	 */
 	void split();
 
+    /** sets the specified vertex to a new value
+     * @param location gives the position of the vertex
+     * @param vertex contains the new value
+     */
     void SetVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex);
 
     /** maximum number of elements in one leaf.
@@ -466,7 +464,7 @@
 void TLooseQuadTreeNode<TData,TNode>::split()
 {
 	Ogre::Real HalfWidth = mWidth/2.0f;
-	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, -HalfWidth));
+	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, HalfWidth));
 	// create 4 subnodes
 	mNodes[TOP_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
@@ -637,74 +635,83 @@
 	{
 	case BNode::TOP_LEFT:
         // first create new root (top) node
-        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,oldWidth);
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,oldWidth);
         mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            newVertexTL, vertexBR, newWidth);
+            vertexTL, newVertexBR, newWidth);
 
-        mRoot->mNodes[BNode::TOP_LEFT] = 
+		mRoot->mNodes[BNode::TOP_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = 
             new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      vertexTL + Ogre::Vector2(-oldWidth,oldWidth), 
-                      vertexTL, oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), 
+                      Ogre::Vector2(vertexBR.x,newVertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
             new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      vertexTL + Ogre::Vector2(-oldWidth,0.0f), 
-                      vertexBR + Ogre::Vector2(-oldWidth,0.0f), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] = oldroot;
+                      vertexBR,
+                      newVertexBR, oldWidth);
         mRoot->mNodes[BNode::TOP_RIGHT] =
-            new TNode(mMaxData, mMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(0.0f,oldWidth), 
-            vertexBR + Ogre::Vector2(0.0f,oldWidth), oldWidth);
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,vertexTL.y),
+                      Ogre::Vector2(newVertexBR.x,vertexBR.y), oldWidth);
+
 		break;
     case BNode::BOTTOM_LEFT:
-        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,0.0f);
-        newVertexBR = vertexBR + Ogre::Vector2(0.0f,-oldWidth);
+        newVertexTL = vertexTL + Ogre::Vector2(0.0f, -oldWidth);
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth, 0.0f);
         mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
             newVertexTL, newVertexBR, newWidth);
 
-        mRoot->mNodes[BNode::TOP_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(-oldWidth,0.0f), 
-            vertexBR + Ogre::Vector2(-oldWidth,0.0f), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(-oldWidth,-oldWidth), 
-            vertexBR + Ogre::Vector2(-oldWidth,-oldWidth), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(0.0f,-oldWidth), 
-            vertexBR + Ogre::Vector2(0.0f,-oldWidth), oldWidth);
-        mRoot->mNodes[BNode::TOP_RIGHT] = oldroot;
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL, 
+                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,vertexTL.y),
+                      newVertexBR, oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,newVertexTL.y), 
+                      Ogre::Vector2(newVertexBR.x,vertexTL.y), oldWidth);
         break;
     case BNode::BOTTOM_RIGHT:
-        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,-oldWidth);
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,-oldWidth);
         mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            vertexTL, newVertexBR, newWidth);
+            newVertexTL, vertexBR, newWidth);
 
-		mRoot->mNodes[BNode::TOP_LEFT] = oldroot;
-        mRoot->mNodes[BNode::BOTTOM_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(0.0f,-oldWidth), 
-            vertexBR + Ogre::Vector2(0.0f,-oldWidth), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexBR,
-            vertexBR + Ogre::Vector2(oldWidth,-oldWidth), oldWidth);
-        mRoot->mNodes[rl::TQuadTreeBasicNode<TData>::TOP_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(oldWidth,0.0f), 
-            vertexBR + Ogre::Vector2(oldWidth,0.0f), oldWidth);
-        
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL,
+                      vertexTL, oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(newVertexTL.x,vertexTL.y),
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = oldroot;
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, mMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexTL.x,newVertexTL.y),
+                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
 		break;
 	case BNode::TOP_RIGHT:
-        newVertexTL = vertexTL + Ogre::Vector2(0.0f,oldWidth);
-        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,0.0f);
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth, 0.0f);
+        newVertexBR = vertexBR + Ogre::Vector2(0.0f, oldWidth);
         mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
             newVertexTL, newVertexBR, newWidth);
 
-        mRoot->mNodes[BNode::TOP_LEFT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(0.0f,oldWidth),
-            vertexBR + Ogre::Vector2(0.0f,oldWidth), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] = oldroot;
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(oldWidth,0.0f),
-            vertexBR + Ogre::Vector2(oldWidth,0.0f), oldWidth);
-        mRoot->mNodes[BNode::TOP_RIGHT] = new TNode(mMaxData, oldMaxDepth, oldLooseness,
-            vertexTL + Ogre::Vector2(oldWidth,oldWidth),
-            vertexBR + Ogre::Vector2(oldWidth,oldWidth), oldWidth);
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL,
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(newVertexTL.x,vertexBR.y),
+                      Ogre::Vector2(vertexTL.x,newVertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexTL.x,vertexBR.y),
+                      newVertexBR, oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] = oldroot;
 		break;
 	default:
 		Throw (IllegalArgumentException, "unknown NodeLocation type.");
@@ -719,46 +726,46 @@
     {
         if ( v < mRoot->mVertexTL.y )
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
             extend(u,v);
         }
         else if ( v > mRoot->mVertexBR.y )
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_LEFT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
             extend(u,v);
         }
         else
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
             extend(u,v);
         }
     }
     else if ( u > mRoot->mVertexBR.x )
     {
-        if ( v < mRoot->mVertexBR.y )
+        if ( v < mRoot->mVertexTL.y )
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
             extend(u,v);
         }
-        else if ( v > mRoot->mVertexTL.y )
+        else if ( v > mRoot->mVertexBR.y )
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_LEFT);
             extend(u,v);
         }  
         else
         {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
+            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
             extend(u,v);
         }
     }
     else //  u is inside
     {
-        if ( v < mRoot->mVertexBR.y )
+        if ( v < mRoot->mVertexTL.y )
         {
             createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
             extend(u,v);
         }
-        else if ( v > mRoot->mVertexTL.y )
+        else if ( v > mRoot->mVertexBR.y )
         {
             createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
             extend(u,v);



From natoka at mail.berlios.de  Wed Mar 28 06:00:51 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 28 Mar 2007 06:00:51 +0200
Subject: [Dsa-hl-svn] r3199 - rl/trunk/engine/core/include
Message-ID: <200703280400.l2S40pOJ024416@sheep.berlios.de>

Author: natoka
Date: 2007-03-28 06:00:45 +0200 (Wed, 28 Mar 2007)
New Revision: 3199

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
bugfix for 'entity is inside/outside' check


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-28 03:26:49 UTC (rev 3198)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-28 04:00:45 UTC (rev 3199)
@@ -170,7 +170,7 @@
 	 */
 	inline bool isUInside(Ogre::Real u) 
 	{ 
-		return (mVertexTL.x < u && u < mVertexBR.x);
+		return (mVertexTL.x <= u && u <= mVertexBR.x);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -179,7 +179,7 @@
 	 */
 	inline bool isVInside(Ogre::Real v) 
 	{
-		return (mVertexTL.y < v && v < mVertexBR.y);
+		return (mVertexTL.y <= v && v <= mVertexBR.y);
 	}
 
 	void remove(); //TQuadTree<TData, TNode> *node);
@@ -345,7 +345,7 @@
 	 */
 	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
-		return (mVertexTL.x - mLooseness < u && u < mVertexBR.x + mLooseness);
+		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -354,7 +354,7 @@
 	 */
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
-		return (mVertexTL.y - mLooseness < v && v < mVertexBR.y + mLooseness);
+		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
 	}
 
    	/** inserts the specified data.



From twel at mail.berlios.de  Wed Mar 28 12:53:29 2007
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Wed, 28 Mar 2007 12:53:29 +0200
Subject: [Dsa-hl-svn] r3200 - modules/ruchin/models
Message-ID: <200703281053.l2SArTg7004321@sheep.berlios.de>

Author: twel
Date: 2007-03-28 12:52:27 +0200 (Wed, 28 Mar 2007)
New Revision: 3200

Modified:
   modules/ruchin/models/temple_outside.mesh
Log:
Fixed bounding boxes with OgreMeshUpgrade

Modified: modules/ruchin/models/temple_outside.mesh
===================================================================
(Binary files differ)



From josch at mail.berlios.de  Wed Mar 28 13:02:31 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Wed, 28 Mar 2007 13:02:31 +0200
Subject: [Dsa-hl-svn] r3201 - rl/trunk
Message-ID: <200703281102.l2SB2VRr015008@sheep.berlios.de>

Author: josch
Date: 2007-03-28 13:02:29 +0200 (Wed, 28 Mar 2007)
New Revision: 3201

Modified:
   rl/trunk/configure.in
Log:
Install tool strips ;-) in release mode and DEBUG and NDEBUG symbols defined appropriately

Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-03-28 10:52:27 UTC (rev 3200)
+++ rl/trunk/configure.in	2007-03-28 11:02:29 UTC (rev 3201)
@@ -14,12 +14,14 @@
 AC_PROG_INSTALL
 AM_PROG_LIBTOOL
 
+
 # ***** DEBUGGING
 AC_ARG_ENABLE(debug,AS_HELP_STRING([--enable-debug],[enable debugging @<:@default=no@:>@]))
 if test "$enable_debug" = "yes"; then
-    CXXFLAGS="$CXXFLAGS -g -O0"
+    CXXFLAGS="$CXXFLAGS -g -O0 -DDEBUG"
 else
-    CXXFLAGS="$CXXFLAGS -O2"
+    CXXFLAGS="$CXXFLAGS -O2 -DNDEBUG -s"
+    INSTALL="$INSTALL -s"
 fi
 # ***** PROFILING
 AC_ARG_ENABLE([profiling], AS_HELP_STRING([--enable-profiling], [enable profiling @<:@default=no@:>@]))
@@ -152,9 +154,9 @@
 AC_SUBST(RUBY_LIBS)
 
 dnl Test for modified swig version
-SWIG_PROG(1.3.29-pantheon)
-SWIG_ENABLE_CXX
-SWIG_RUBY
+#SWIG_PROG(1.3.29)
+#SWIG_ENABLE_CXX
+#SWIG_RUBY
 
 dnl Define the directory, where RL should look for modules
 if test "x${prefix}" = "xNONE"; then



From josch at mail.berlios.de  Wed Mar 28 15:43:59 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Wed, 28 Mar 2007 15:43:59 +0200
Subject: [Dsa-hl-svn] r3202 - rl/trunk
Message-ID: <200703281343.l2SDhxEi001482@sheep.berlios.de>

Author: josch
Date: 2007-03-28 15:43:58 +0200 (Wed, 28 Mar 2007)
New Revision: 3202

Modified:
   rl/trunk/configure.in
Log:


Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-03-28 11:02:29 UTC (rev 3201)
+++ rl/trunk/configure.in	2007-03-28 13:43:58 UTC (rev 3202)
@@ -154,9 +154,9 @@
 AC_SUBST(RUBY_LIBS)
 
 dnl Test for modified swig version
-#SWIG_PROG(1.3.29)
-#SWIG_ENABLE_CXX
-#SWIG_RUBY
+SWIG_PROG(1.3.29)
+SWIG_ENABLE_CXX
+SWIG_RUBY
 
 dnl Define the directory, where RL should look for modules
 if test "x${prefix}" = "xNONE"; then



From natoka at mail.berlios.de  Wed Mar 28 17:47:09 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 28 Mar 2007 17:47:09 +0200
Subject: [Dsa-hl-svn] r3203 - rl/trunk/engine/core/include
Message-ID: <200703281547.l2SFl90l021036@sheep.berlios.de>

Author: natoka
Date: 2007-03-28 17:47:03 +0200 (Wed, 28 Mar 2007)
New Revision: 3203

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
added extended comments and corrected several missleading statements


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-28 13:43:58 UTC (rev 3202)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-28 15:47:03 UTC (rev 3203)
@@ -93,6 +93,26 @@
 };
 
 template <class TData, class TNode>
+void TQuadTreeBasicPointerNode<TData,TNode>::remove()
+{
+	if (mSubDivided)
+	{
+		// try to remove the data of any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i]) 
+			{
+				mNodes[i]->remove();
+				delete mNodes[i];
+				mNodes[i] = NULL;
+			}
+		}
+	}
+	else 
+		mSubDivided = false;
+}
+
+template <class TData, class TNode>
 TQuadTreeBasicPointerNode<TData, TNode>::TQuadTreeBasicPointerNode()
 {
 	memset(mNodes, 0, sizeof(mNodes));
@@ -121,11 +141,6 @@
 	 */
 	TQuadTreeOgreNode(const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
 
-	/** Constructor to use for correct setup of quad.
-	 * Initialises the quad with all necessary data to function properly.
-	 */
-	//TQuadTreeOgreNode(Ogre::Vector2& tlc, Ogre::Vector2& blc, Ogre Vector2& lrc);
-
 	/** Fetches the width of the quad.
 	 * @returns the width of the quad.
 	 */
@@ -156,10 +171,12 @@
 		return Ogre::Vector2(0.0f,0.0f);
 	}
 
-    /** retrieves the topleft vertex
+    /** retrieves the topleft vertex.
+    * @todo is this really necessary?
      */
     inline Ogre::Vector2 getTopLeft() { return mVertexTL; }
-    /** retrieves the bottom right vertex
+    /** retrieves the bottom right vertex.
+     * @todo is this really necessary?
      */
     inline Ogre::Vector2 getBottomRight() { return mVertexBR; }
 
@@ -191,7 +208,6 @@
   mVertexTL(0,0),
   mVertexBR(0,0)
 {
-	//memset((char*) mVertices, 0, sizeof(mVertices));
 }
 
 template <class TData, class TNode>
@@ -220,11 +236,27 @@
 	//! default constructor
 	TLooseQuadTree();
 
+    /** Detailed constructor.
+     * Gives the possibility to initialise all internal values to meaningfull
+     * values
+     * @param maxDepth gives the maximum number of levels inside the quadtree. \c setMaxDepth
+     * @param maxData maximum number of data elements per node. \c setMaxData 
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%) \c setLooseness
+     * @param tlc gives the top left corner (in world space) \c setExtents
+     * @param tlc gives the bottom rigth corner (in world space) \c setExtents
+     */
 	TLooseQuadTree(int maxData, int maxDepth, float looseness, 
-		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc);
 
 	//TLooseQuadTree(const TLooseQuadTree<TData, TNode>& Node);
 
+    /** Searches the quadtree for the node containing position.
+     * Returns the node containing the specified position or null if position
+     * is outside the quadtree.
+     * @return pointer to the node containing position or null if not inside.
+     */
+    TLooseQuadTree<TData, TNode>* find(const Ogre::Vector3& position);
+
 	/** Retrieves the loosness factor.
 	 */
 	float getLooseness() { return (mLooseness / mWidth * 2.0f); }
@@ -235,29 +267,64 @@
 	 */
 	int getMaxData() { return mMaxData; }
 
-    TLooseQuadTree<TData, TNode>* find(const Ogre::Vector3& position);
-	
-	/** Sets the looseness factor to a new value.
+    /** Sets the looseness factor to a new value.
+     * Changing this value is only possible, when the tree is empty.
 	 * mLooseness stores a precalculated looseness value.
 	 * The looseness is specified in percents of the width, so the loose quad
 	 * is the original quad + some additional area. e.g. 0.5 extends the original
-	 * length by 50% which means an additional area of 125%. Since this is evenly
-	 * distributed in all directions, the value that has to be added/substracted 
-	 * to the quad's original vertices is 25% of width. Those 25% of width are
-	 * stored in mLooseness.
-	 * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+	 * length by 50% which means an additional area of 125%.
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
 	 */
 	void setLoosenessFactor(float loosenessfactor) { mLoosenessFactor = loosenessfactor; }
 	
-	void setMaxDepth(int maxDepth) { mMaxDepth = maxDepth; }
+    /** Sets the maximum depth of the quadtree.
+     * Changing this value is only possible, when the tree is empty.
+     * This value can change (grow) when data is added to the quad tree
+     * that is outside the quadtree.
+     * Setting this value is only possible, when there is no data in the
+     * quadtree.
+     * @param maxDepth gives the maximum number of levels inside the quadtree.
+     */
+	void setMaxDepth(int maxDepth) 
+    { 
+        if (!mRoot)
+            mMaxDepth = maxDepth;
+        else
+            LOG_DEBUG(Logger::CORE, "Setting maximum depth on non empty quadtree not possible");
+    }
 	
-	void setMaxData(int maxData) { mMaxData = maxData; }
+    /** Sets the maximum number of data elements per quad.
+     * Changing this value is only possible, when the tree is empty.
+     * Whenever this number is exceeded, the quad is split creating 4 new
+     * subquads.
+     * When maxData is reached at the maximum depth level of the quadtree,
+     * no split will take place (because the depth limit prevents it),
+     * \c setMaxDepth.
+     * @param maxData maximum number of data elements per node.
+     */
+	void setMaxData(int maxData) 
+    {
+        if (!mRoot) 
+            mMaxData = maxData;
+        else
+            LOG_DEBUG(Logger::CORE, "Setting maximum data on non empty quadtree not possible");
+    }
 
+    /** Sets the extents of the quadtree to the specified one.
+     * Changing these value is only possible, when the tree is empty.
+     * This creates a new quadtree with the specified extents, when the
+     * tree was initially empty.
+     * The coordinates have world space (right hand sided, y is facing down).
+     * @param tlc gives the top left corner (in world space)
+     * @param tlc gives the bottom rigth corner (in world space)
+     */
     inline void setExtents(const Ogre::Vector2& tlc, const Ogre::Vector2& brc)
     {
         if (!mRoot)
             mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (brc.x-tlc.x) / 2.0f,
             tlc, brc, brc.x-tlc.x);
+        else
+            LOG_DEBUG(Logger::CORE, "Settings extents on non empty quadtree not possible");
     }
 
 	/** adds the specified data.
@@ -267,7 +334,8 @@
 	 */
 	void add(TData data);
 
-
+    /** deletes the complete quadtree.
+     */
     void removeAll();
 
 protected:
@@ -300,32 +368,44 @@
 	int mMaxDepth;
 	/** The looseness factor
 	 * Defines the size of the 'loose' area around the quad.
-	 * Should be between 1.0 and 1.5 - less or more doesn't make sense at all.
+	 * Should be between 0.25 and 1.0 - less or more doesn't make sense at all.
 	 */
 	float mLoosenessFactor;
 
-    /** The root node of the quad tree.
-     */
+    //! The root node of the quad tree.
     TNode* mRoot;
-    //TLooseQuadTreeNode< std::vector< TData >,
-    
 };
 
-/** A basic loose quadtree.
+/** A basic loose quadtree node.
  * A loose quadtree consists of loose quads, which have an extended
  * 'loose' area around them. So the quads do not only store the
- * contents of the quad, but of the extende area too. This can be
- * helpfull in eliminating additional traversals of the tree, when
- * objects are near the border of the quad (or reaching into neighbouring
- * quads).
+ * contents of the quad, but of the extended area too. This can be
+ * helpfull in eliminating additional traversals of the tree, when searching
+ * in case the objects are near the border of the quad (or reaching into
+ * neighbouring quads).
  */
 template <class TData, class TNode>
 class TLooseQuadTreeNode : public TQuadTreeOgreNode< std::vector< TData >, TNode >
 {
 public:
+    /** Detailed quad node constructor.
+     * Gives the possibility to initialise all internal values to meaningfull
+     * values
+     * @param maxDepth gives the maximum number of levels inside the quadtree.
+     * @param maxData maximum number of data elements per node.
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+     * @param tlc gives the top left corner (in world space)
+     * @param tlc gives the bottom rigth corner (in world space)
+     * @param mWidth gives the width of the node (passing this for performance).
+     */ 
     TLooseQuadTreeNode(int maxData, int maxDepth, float looseness, 
 		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
 
+    /** copy constructor.
+     * Should copy the data of the specified node into the new object.
+     * Normally it is not necessary to do a deep copy here (wastes performance).
+     * @param Node to copy.
+     */
     TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node);
 
 	/** Retrieves the loosness factor.
@@ -376,6 +456,8 @@
 	 */
 	TLooseQuadTreeNode* find(const Ogre::Vector3& position);
 
+    /** TLooseQuadTree is the management class for this node class. 
+     */
     friend TLooseQuadTree< TData, TNode >;
 
 protected:
@@ -390,7 +472,7 @@
      * @param location gives the position of the vertex
      * @param vertex contains the new value
      */
-    void SetVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex);
+    void setVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex);
 
     /** maximum number of elements in one leaf.
 	 * Whenever this number is reached a subdivision takes place.
@@ -403,7 +485,7 @@
 	int mMaxDepth;
 	/** The looseness factor
 	 * Defines the size of the 'loose' area around the quad.
-	 * Should be between 1.0 and 1.5 - less or more doesn't make sense at all.
+	 * Is added and substracted from the corner vertices.
 	 */
 	float mLooseness;
 };
@@ -463,6 +545,10 @@
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::split()
 {
+    // first test if this node is allowed to be subdivided
+    if (mMaxDepth == 0)
+        return; // last level reached, prevent subdivision
+
 	Ogre::Real HalfWidth = mWidth/2.0f;
 	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, HalfWidth));
 	// create 4 subnodes
@@ -546,7 +632,7 @@
 }
 
 template <class TData, class TNode>
-void TLooseQuadTreeNode<TData, TNode>::SetVertex(
+void TLooseQuadTreeNode<TData, TNode>::setVertex(
 	enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex)
 {
 	switch (location)
@@ -580,12 +666,14 @@
 template <class TData, class TNode>
 TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
 											 float loosenessfactor, const Ogre::Vector2& tlc,
-											 const Ogre::Vector2& brc, float mWidth)
+											 const Ogre::Vector2& brc)
 : mMaxData(maxData),
   mMaxDepth(maxDepth),
   mLoosenessFactor(loosenessfactor)
 {
-    mRoot = new TNode(maxData,maxDepth,looseness, tlc, brc, mWidth);
+    RlAssert(brc.x - tlc.x == brc.y - tlc.y, 
+        "topleft and bottom right vertices specify non quad");
+    mRoot = new TNode(maxData,maxDepth,looseness, tlc, brc, brc.x - tlc.x);
 }
 
 
@@ -597,6 +685,7 @@
     Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
     Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
 
+    // essential, create a root node when none is present
     if (!mRoot)
         mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (nrb.x-flb.x) / 2.0f,
         Ogre::Vector2(flb.x,flb.z), Ogre::Vector2(nrb.x,nrb.z), nrb.x-flb.x);
@@ -784,7 +873,10 @@
 template <class TData, class TNode>
 TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
 {
-    return mRoot->find(position);
+    TLooseQuadTree<TData, TNode>* result;
+    if (mRoot)
+        result = mRoot->find(position);
+    return result;
 }
 
 }; /* world */



From natoka at mail.berlios.de  Wed Mar 28 23:19:15 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 28 Mar 2007 23:19:15 +0200
Subject: [Dsa-hl-svn] r3204 - in rl/trunk/engine/core: . include src
Message-ID: <200703282119.l2SLJF5B002529@sheep.berlios.de>

Author: natoka
Date: 2007-03-28 23:19:09 +0200 (Wed, 28 Mar 2007)
New Revision: 3204

Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
deactivated old way of handling levelobjects, added new quadtree style handling


Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-03-28 15:47:03 UTC (rev 3203)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-03-28 21:19:09 UTC (rev 3204)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="8.00"
 	Name="RlCore"
 	ProjectGUID="{0935F495-4540-40E3-AC8F-AA54C85DC5B2}"
 	RootNamespace="RlCore"
@@ -525,6 +525,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\QuadTree.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\RubyInterpreter.h"
 				>
 			</File>

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-03-28 15:47:03 UTC (rev 3203)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-03-28 21:19:09 UTC (rev 3204)
@@ -35,6 +35,8 @@
 #include "GameTask.h"
 #include "CorePrerequisites.h"
 
+#include "QuadTree.h"
+
 namespace rl {
 
     class Actor;
@@ -43,10 +45,20 @@
     class PhysicsController;
     class PhysicsGenericContactCallback;
     class World;
-
     class PhysicsCollisionFactory;
 
+	class LQTBodies : public TLooseQuadTreeNode<OgreNewt::Body*, LQTBodies>
+	{
+	public:
+		typedef std::vector<OgreNewt::Body*> BodyList;
+		LQTBodies(int maxData, int maxDepth, float looseness, const Ogre::Vector2& tlc,
+			const Ogre::Vector2& brc, float mWidth);
+        LQTBodies(const LQTBodies& LQT);
+		~LQTBodies();
 
+		static const Ogre::AxisAlignedBox getAABB(OgreNewt::Body* body);
+	};
+
     /** Management class for the physical properties of game world objects.
      * This class utilizes OgreNewt (and therefore indirectly Newton) for handling
      * the physics of RL. It sets up OgreNewt and realizes the timestepping for Newton.
@@ -304,7 +316,9 @@
         //! a list of objects of the physical world
         std::vector<PhysicalThing*> mPhysicalThings;
         //! a list of bodies for the static level parts
-        std::vector<OgreNewt::Body*> mLevelBodies;
+        //std::vector<OgreNewt::Body*> mLevelBodies;
+		//! a quadtree storing a spatial partioning of static level parts
+        TLooseQuadTree<OgreNewt::Body*, LQTBodies> mLevelBodiesQuadTree;
         //! the extents of the level
         Ogre::AxisAlignedBox mWorldAABB;
         

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-28 15:47:03 UTC (rev 3203)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-03-28 21:19:09 UTC (rev 3204)
@@ -36,7 +36,36 @@
 {
     const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.01;
 
+	LQTBodies::LQTBodies(int maxData, int maxDepth, float looseness,
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
+		: TLooseQuadTreeNode<OgreNewt::Body*, LQTBodies>( maxData, maxDepth, looseness, tlc, brc, mWidth)
+	{
+	}
 
+    LQTBodies::LQTBodies(const LQTBodies& LQT)
+        : TLooseQuadTreeNode<OgreNewt::Body*, LQTBodies>(LQT)
+    {
+        for (BodyList::const_iterator it = LQT.mData.begin(); it != LQT.mData.end(); it++)
+		{
+            mData.push_back(*it);
+        }
+    }
+
+	LQTBodies::~LQTBodies()
+	{
+		for (BodyList::iterator it = mData.begin(); it != mData.end(); it++)
+		{
+			delete (*it);
+		}
+		mData.clear();
+	}
+
+
+	const Ogre::AxisAlignedBox LQTBodies::getAABB(OgreNewt::Body* body) 
+	{
+		return body->getCollision()->getAABB();
+	}
+
     PhysicsManager& PhysicsManager::getSingleton(void)
     {
         return Singleton<PhysicsManager>::getSingleton();
@@ -82,7 +111,13 @@
         // setup character material
         // actually this is needed here, because the actor is created in advance before the
         // character controller who actually does create 'character' material too.
-        createMaterialID("character");      
+        createMaterialID("character");
+
+        // setup level quadtree extents
+        mLevelBodiesQuadTree.setMaxData(20);
+        mLevelBodiesQuadTree.setMaxDepth(10);
+        mLevelBodiesQuadTree.setLoosenessFactor(0.5f);
+        mLevelBodiesQuadTree.setExtents(Ogre::Vector2(-100,-100), Ogre::Vector2(100,100));
     }
 
     PhysicsManager::~PhysicsManager()
@@ -224,8 +259,9 @@
             body->setPositionOrientation(node->getWorldPosition(),
                 node->getWorldOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
-
-            mLevelBodies.push_back(body);
+			
+			mLevelBodiesQuadTree.add(body);
+            //mLevelBodies.push_back(body);
         }
 
         // adjust worldAABB
@@ -249,11 +285,13 @@
 
     void PhysicsManager::clearLevelGeometry(  )
     {
-        for (size_t i = 0; i < mLevelBodies.size(); i++ )
+		mLevelBodiesQuadTree.removeAll();
+        /*for (size_t i = 0; i < mLevelBodies.size(); i++ )
         {
             delete mLevelBodies[i];
         }
         mLevelBodies.clear();
+		*/
     }
 
     // adopted from the chararcter demo in the newton sdk



From natoka at mail.berlios.de  Wed Mar 28 23:22:04 2007
From: natoka at mail.berlios.de (natoka at mail.berlios.de)
Date: Wed, 28 Mar 2007 23:22:04 +0200
Subject: [Dsa-hl-svn] r3205 - rl/trunk/engine/core/include
Message-ID: <200703282122.l2SLM4a8002699@sheep.berlios.de>

Author: natoka
Date: 2007-03-28 23:21:59 +0200 (Wed, 28 Mar 2007)
New Revision: 3205

Modified:
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/include/QuadTree.h
Log:
adding QuadTree.h to include list
added newline at end of file

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-03-28 21:19:09 UTC (rev 3204)
+++ rl/trunk/engine/core/include/Makefile.am	2007-03-28 21:21:59 UTC (rev 3205)
@@ -44,6 +44,7 @@
 	PlayAnimationJob.h \
 	PlaySoundJob.h \
 	PrimitiveObject.h \
+	QuadTree.h \
 	RubyInterpreter.h \
 	SceneQuery.h \
 	Sound.h \

Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-28 21:19:09 UTC (rev 3204)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-28 21:21:59 UTC (rev 3205)
@@ -882,3 +882,4 @@
 }; /* world */
 
 #endif /* __QUADTREE_H__ */
+



From blakharaz at mail.berlios.de  Fri Mar 30 12:58:04 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 12:58:04 +0200
Subject: [Dsa-hl-svn] r3206 - rl/trunk/engine/core/include
Message-ID: <200703301058.l2UAw40r006560@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 12:57:56 +0200 (Fri, 30 Mar 2007)
New Revision: 3206

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
* Removed unnessessary template class TQuadTreeBasicPointerNode
* removed lots of compiler errors shown by gcc (still some left)



Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-28 21:21:59 UTC (rev 3205)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-30 10:57:56 UTC (rev 3206)
@@ -12,874 +12,866 @@
  *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __QUADTREE_H__
-#define __QUADTREE_H__
-
-namespace Ogre {
-	class AxisAlignedBox;
-	class Vector2;
-	class Vector3;
-};
-
-#include "CorePrerequisites.h"
-#include "Exception.h"
-
-namespace rl
-{
-	
-/** A very basic quad tree template.
- * It just stores whether the current node is subdivided or not and
- * the data contained in the node.
- * Normally this would be used in a uniform flat quadtree. That means
- * that the quadtrees memory would be preallocated once and indexing
- * would be used to map the 2D structure into the 1D memory.
- * Non uniform quadtrees are also possible, but quite useless, because
- * they consume the preallocated memory anyway.
- * Anyway the node indexing should follow the defined style by the enum
- * NodeLocation.
- */
-template <class TData>
-class TQuadTreeBasicNode
-{
-public:
-	/** Tells where the node within an array is located.
-	 * creates a counterclockwise location of nodes.
-	 */
-	enum NodeLocation
-	{
-		TOP_LEFT = 0,		//!< upper left quad
-		BOTTOM_LEFT,		//!< lower left quad
-		BOTTOM_RIGHT,		//!< lower right quad
-		TOP_RIGHT			//!< upper right quad
-	};
-
-	/** Returns the stored data.
-	 * @returns a const reference to the internally stored data
-	 */
-	const TData& getData() { return mData; }
-protected:
-	bool		mSubDivided;	//!< true if node has subnodes
-	TData		mData;			//!< data of this node
-};
-
-/** A basic quadtree with pointer to it's children nodes.
- * This quadree template is for (non) uniform quadtrees where additional
- * nodes can be allocated and inserted on demand.
- */
-template <class TData, class TNode>
-class TQuadTreeBasicPointerNode : public TQuadTreeBasicNode< TData >
-{
-protected:
-	TNode*		mNodes[4];	//!< four pointers to subnodes
-
-public:
-	/** default constructor.
-	 * Initializes the subquad pointers to NULL
-	 */
-	TQuadTreeBasicPointerNode();
-
-	/** Retrieve the specified subnode.
-	 * Accounting the nature of (non) uniform quadtrees the returned pointer might
-	 * be NULL.
-	 * @param location whether to fetch the upper/lower left/right quad.
-	 * @returns the subquadtree node
-	 */
-	TNode*	getNode(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location);
-
-	// function for recursively deleting the quad tree
-	void remove(); //Node (TQuadTreeBasicPointerNode<TData, TNode> *node);
-};
-
-template <class TData, class TNode>
-void TQuadTreeBasicPointerNode<TData,TNode>::remove()
-{
-	if (mSubDivided)
-	{
-		// try to remove the data of any of the subnodes
-		for (int i=0; i<4; i++)
-		{
-			if (mNodes[i]) 
-			{
-				mNodes[i]->remove();
-				delete mNodes[i];
-				mNodes[i] = NULL;
-			}
-		}
-	}
-	else 
-		mSubDivided = false;
-}
-
-template <class TData, class TNode>
-TQuadTreeBasicPointerNode<TData, TNode>::TQuadTreeBasicPointerNode()
-{
-	memset(mNodes, 0, sizeof(mNodes));
-	mSubDivided = false;
-}
-
-/** A basic Quadtree containing vertex data
- */
-template <class TData, class TNode>
-class TQuadTreeOgreNode : public TQuadTreeBasicPointerNode< TData, TNode >
-{
-protected:
-	Ogre::Vector2	mVertexTL;	//!< top left vertex of this node
-	Ogre::Vector2	mVertexBR;	//!< bottom right vertex of this node
-	Ogre::Real		mWidth;		//!< length of this quad
-
-public:
-	/** Default constructor.
-	 * initializes a completely empty quad, that even doesn't represent a part
-	 * a space.
-	 */
-	TQuadTreeOgreNode();
-
-	/** Constructor to use for correct setup of quad.
-	 * Initialises the quad with all necessary data to function properly.
-	 */
-	TQuadTreeOgreNode(const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
-
-	/** Fetches the width of the quad.
-	 * @returns the width of the quad.
-	 */
-	inline Ogre::Real getWidth() { return mWidth; }
-
-	/** Retrieve the specified corner vertex.
-	 * Since only the upper left and lower right corner of the quad are stored,
-	 * the two others have to be constructed.
-	 * @param location specifies which vertex to fetch (upper/lower-left/right).
-	 * @returns the wanted vertex.
-	 */
-	inline Ogre::Vector2 getVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location)
-	{
-		switch (location)
-		{
-		case TOP_LEFT:
-			return mVertexTL;
-		case BOTTOM_LEFT:
-			return Ogre::Vector2(mVertexTL.x, mVertexBR.y);
-		case BOTTOM_RIGHT:
-			return mVertexBR;
-		case TOP_RIGHT:
-			return Ogre::Vector2(mVertexBR.x, mVertexTL.y);
-		default:
-			Throw(IllegalArgumentException, "unknown NodeLocation type.");
-		}
-
-		return Ogre::Vector2(0.0f,0.0f);
-	}
-
-    /** retrieves the topleft vertex.
-    * @todo is this really necessary?
-     */
-    inline Ogre::Vector2 getTopLeft() { return mVertexTL; }
-    /** retrieves the bottom right vertex.
-     * @todo is this really necessary?
-     */
-    inline Ogre::Vector2 getBottomRight() { return mVertexBR; }
-
-	/** tests if the given u value is inside the quad.
-	 * Since this is a 2D test, the name refers to u coordinate
-	 * (instead of x for the 3D case).
-	 * @param u coordinate to test whether it is inside the quad or not.
-	 */
-	inline bool isUInside(Ogre::Real u) 
-	{ 
-		return (mVertexTL.x <= u && u <= mVertexBR.x);
-	}
-	/** tests if the given v value is inside the quad.
-	 * Since this is a 2D test, the name refers to v coordinate
-	 * (instead of z for the 3D case).
-	 * @param v coordinate to test whether it is inside the quad or not.
-	 */
-	inline bool isVInside(Ogre::Real v) 
-	{
-		return (mVertexTL.y <= v && v <= mVertexBR.y);
-	}
-
-	void remove(); //TQuadTree<TData, TNode> *node);
-}; /* TQuadTree */
-
-template <class TData, class TNode>
-TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode()
-: mWidth(0.0f),
-  mVertexTL(0,0),
-  mVertexBR(0,0)
-{
-}
-
-template <class TData, class TNode>
-TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode(
-    const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
-: mWidth(mWidth),
-  mVertexTL(tlc),
-  mVertexBR(brc)
-{
-    // right hand side coordinate system (2D part) xz plane
-    RlAssert ( (tlc < brc), "coordinates don't fit together" );
-}
-
-/** A basic loose quadtree.
- * A loose quadtree consists of loose quads, which have an extended
- * 'loose' area around them. So the quads do not only store the
- * contents of the quad, but of the extende area too. This can be
- * helpfull in eliminating additional traversals of the tree, when
- * objects are near the border of the quad (or reaching into neighbouring
- * quads).
- */
-template <class TData, class TNode>
-class TLooseQuadTree //: public TQuadTreeOgreNode< std::vector< TData >, TNode >
-{
-public:
-	//! default constructor
-	TLooseQuadTree();
-
-    /** Detailed constructor.
-     * Gives the possibility to initialise all internal values to meaningfull
-     * values
-     * @param maxDepth gives the maximum number of levels inside the quadtree. \c setMaxDepth
-     * @param maxData maximum number of data elements per node. \c setMaxData 
-     * @param looseness looseness factor in percent (e.g. 0.5 for 50%) \c setLooseness
-     * @param tlc gives the top left corner (in world space) \c setExtents
-     * @param tlc gives the bottom rigth corner (in world space) \c setExtents
-     */
-	TLooseQuadTree(int maxData, int maxDepth, float looseness, 
-		const Ogre::Vector2& tlc, const Ogre::Vector2& brc);
-
-	//TLooseQuadTree(const TLooseQuadTree<TData, TNode>& Node);
-
-    /** Searches the quadtree for the node containing position.
-     * Returns the node containing the specified position or null if position
-     * is outside the quadtree.
-     * @return pointer to the node containing position or null if not inside.
-     */
-    TLooseQuadTree<TData, TNode>* find(const Ogre::Vector3& position);
-
-	/** Retrieves the loosness factor.
-	 */
-	float getLooseness() { return (mLooseness / mWidth * 2.0f); }
-	/** Retrieves the maximum depth of the quadtree
-	 */
-	int getMaxDepth() { return mMaxDepth; }
-	/** Retrieves the maximum number of data elements for a quad.
-	 */
-	int getMaxData() { return mMaxData; }
-
-    /** Sets the looseness factor to a new value.
-     * Changing this value is only possible, when the tree is empty.
-	 * mLooseness stores a precalculated looseness value.
-	 * The looseness is specified in percents of the width, so the loose quad
-	 * is the original quad + some additional area. e.g. 0.5 extends the original
-	 * length by 50% which means an additional area of 125%.
-     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
-	 */
-	void setLoosenessFactor(float loosenessfactor) { mLoosenessFactor = loosenessfactor; }
-	
-    /** Sets the maximum depth of the quadtree.
-     * Changing this value is only possible, when the tree is empty.
-     * This value can change (grow) when data is added to the quad tree
-     * that is outside the quadtree.
-     * Setting this value is only possible, when there is no data in the
-     * quadtree.
-     * @param maxDepth gives the maximum number of levels inside the quadtree.
-     */
-	void setMaxDepth(int maxDepth) 
-    { 
-        if (!mRoot)
-            mMaxDepth = maxDepth;
-        else
-            LOG_DEBUG(Logger::CORE, "Setting maximum depth on non empty quadtree not possible");
-    }
-	
-    /** Sets the maximum number of data elements per quad.
-     * Changing this value is only possible, when the tree is empty.
-     * Whenever this number is exceeded, the quad is split creating 4 new
-     * subquads.
-     * When maxData is reached at the maximum depth level of the quadtree,
-     * no split will take place (because the depth limit prevents it),
-     * \c setMaxDepth.
-     * @param maxData maximum number of data elements per node.
-     */
-	void setMaxData(int maxData) 
-    {
-        if (!mRoot) 
-            mMaxData = maxData;
-        else
-            LOG_DEBUG(Logger::CORE, "Setting maximum data on non empty quadtree not possible");
-    }
-
-    /** Sets the extents of the quadtree to the specified one.
-     * Changing these value is only possible, when the tree is empty.
-     * This creates a new quadtree with the specified extents, when the
-     * tree was initially empty.
-     * The coordinates have world space (right hand sided, y is facing down).
-     * @param tlc gives the top left corner (in world space)
-     * @param tlc gives the bottom rigth corner (in world space)
-     */
-    inline void setExtents(const Ogre::Vector2& tlc, const Ogre::Vector2& brc)
-    {
-        if (!mRoot)
-            mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (brc.x-tlc.x) / 2.0f,
-            tlc, brc, brc.x-tlc.x);
-        else
-            LOG_DEBUG(Logger::CORE, "Settings extents on non empty quadtree not possible");
-    }
-
-	/** adds the specified data.
-	 * Takes into account that the specified data might not be completely
-	 * inside the quadtree resulting into a top node 'split'.
-	 * @param data the data to insert.
-	 */
-	void add(TData data);
-
-    /** deletes the complete quadtree.
-     */
-    void removeAll();
-
-protected:
-
-    /* adds nodes to the quadtree at it's top.
-     * This extends the quadtree above it's root node, so that the specified
-     * point is covered by the node.
-     * @param u x-coordinate of point in world space
-     * @param v z-coordinate of point in world space
-     */
-    void extend(const Ogre::Real& u, const Ogre::Real& v);
-
-    /* creates a new root node and adds the tree as one of it's subparts.
-     * The nodelocation gives the orientation of the new rootnode relative to
-     * the existing root node. So e.g TOP_LEFT means that the new root node
-     * will extend into the TOP_LEFT direction (!= place the old root node
-     * TOP_LEFT).
-     * @param location new location direction
-     */
-    void createNewRootNode(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location);
-
-    /** maximum number of elements in one leaf.
-	 * Whenever this number is reached a subdivision takes place.
-	 */
-	int mMaxData;
-	/** maximum level of depth.
-	 * prevents further subdivision when a leafnode is at this subdivision
-	 * level
-	 */
-	int mMaxDepth;
-	/** The looseness factor
-	 * Defines the size of the 'loose' area around the quad.
-	 * Should be between 0.25 and 1.0 - less or more doesn't make sense at all.
-	 */
-	float mLoosenessFactor;
-
-    //! The root node of the quad tree.
-    TNode* mRoot;
-};
-
-/** A basic loose quadtree node.
- * A loose quadtree consists of loose quads, which have an extended
- * 'loose' area around them. So the quads do not only store the
- * contents of the quad, but of the extended area too. This can be
- * helpfull in eliminating additional traversals of the tree, when searching
- * in case the objects are near the border of the quad (or reaching into
- * neighbouring quads).
- */
-template <class TData, class TNode>
-class TLooseQuadTreeNode : public TQuadTreeOgreNode< std::vector< TData >, TNode >
-{
-public:
-    /** Detailed quad node constructor.
-     * Gives the possibility to initialise all internal values to meaningfull
-     * values
-     * @param maxDepth gives the maximum number of levels inside the quadtree.
-     * @param maxData maximum number of data elements per node.
-     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
-     * @param tlc gives the top left corner (in world space)
-     * @param tlc gives the bottom rigth corner (in world space)
-     * @param mWidth gives the width of the node (passing this for performance).
-     */ 
-    TLooseQuadTreeNode(int maxData, int maxDepth, float looseness, 
-		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
-
-    /** copy constructor.
-     * Should copy the data of the specified node into the new object.
-     * Normally it is not necessary to do a deep copy here (wastes performance).
-     * @param Node to copy.
-     */
-    TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node);
-
-	/** Retrieves the loosness factor.
-	 */
-	float getLooseness() { return (mLooseness / mWidth * 2.0f); }
-	/** Retrieves the maximum depth of the quadtree
-	 */
-	int getMaxDepth() { return mMaxDepth; }
-	/** Retrieves the maximum number of data elements for a quad.
-	 */
-	int getMaxData() { return mMaxData; }
-
-   	/** tests if the given u value is inside the quad.
-	 * Since this is a 2D test, the name refers to u coordinate
-	 * (instead of x for the 3D case).
-	 * @param u coordinate to test whether it is inside the quad or not.
-	 */
-	inline bool isUInsideLoose(Ogre::Real u)
-	{ 
-		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
-	}
-	/** tests if the given v value is inside the quad.
-	 * Since this is a 2D test, the name refers to v coordinate
-	 * (instead of z for the 3D case).
-	 * @param v coordinate to test whether it is inside the quad or not.
-	 */
-	inline bool isVInsideLoose(Ogre::Real v) 
-	{
-		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
-	}
-
-   	/** inserts the specified data.
-	 * The supplied axisaligned box specifies the extents of the given data.
-	 * According to that information the data is inserted at one or more
-	 * leaf nodes.
-	 */
-	void insert(TData data);
-
-	/** removes a node.
-	 * When the node has got subnodes they are also removed
-	 */
-	void remove();
-
-	/** searches the quadtree for a leaf that covers the specified position.
-	 * The search is done as if this is a normal quadtree (without any
-	 * loose boundaries applied 
-	 * @param position in world space coordinates
-	 */
-	TLooseQuadTreeNode* find(const Ogre::Vector3& position);
-
-    /** TLooseQuadTree is the management class for this node class. 
-     */
-    friend TLooseQuadTree< TData, TNode >;
-
-protected:
-   	/** splits the node into subnodes.
-	 * Forces a split of the nodes data, creating 4 subnodes containing the
-	 * data of the original node. The original node persists as the parent
-	 * node of the new nodes.
-	 */
-	void split();
-
-    /** sets the specified vertex to a new value
-     * @param location gives the position of the vertex
-     * @param vertex contains the new value
-     */
-    void setVertex(enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex);
-
-    /** maximum number of elements in one leaf.
-	 * Whenever this number is reached a subdivision takes place.
-	 */
-	int mMaxData;
-	/** maximum level of depth.
-	 * prevents further subdivision when a leafnode is at this subdivision
-	 * level
-	 */
-	int mMaxDepth;
-	/** The looseness factor
-	 * Defines the size of the 'loose' area around the quad.
-	 * Is added and substracted from the corner vertices.
-	 */
-	float mLooseness;
-};
-
-template <class TData, class TNode>
-TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(int maxData, int maxDepth,
-											 float looseness, const Ogre::Vector2& tlc,
-											 const Ogre::Vector2& brc, float mWidth)
-: TQuadTreeOgreNode< std::vector< TData >, TNode >(tlc, brc, mWidth),
-  mMaxData(maxData),
-  mMaxDepth(maxDepth),
-  mLooseness(looseness)
-{
-}
-
-template <class TData, class TNode>
-TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node)
-: TQuadTreeOgreNode< std::vector< TData >, TNode >(Node.mVertexTL, Node.mVertexBR, Node.mWidth),
-  mMaxData(Node.mMaxData),
-  mMaxDepth(Node.mMaxDepth),
-  mLooseness(Node.mLooseness)
-{
-}
-
-template <class TData, class TNode>
-void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
-{
-	if (mSubDivided)
-	{
-		// try to add the data to any of the subnodes
-		for (int i=0; i<4; i++)
-		{
-			if (mNodes[i])
-				mNodes[i]->insert(data);
-		}
-	}
-	else
-	{
-		Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
-		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
-		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
-		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
-		if ( (isVInsideLoose(flb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) ||
-			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
-		{
-			// if at least one is in the loose quad, store the data
-			mData.push_back(data);
-		}
-		// split if maximum number of elements is reached ...
-		if (mData.size() == mMaxData) 
-		{
-			split();
-		}
-	}
-}
-
-template <class TData, class TNode>
-void TLooseQuadTreeNode<TData,TNode>::split()
-{
-    // first test if this node is allowed to be subdivided
-    if (mMaxDepth == 0)
-        return; // last level reached, prevent subdivision
-
-	Ogre::Real HalfWidth = mWidth/2.0f;
-	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(HalfWidth, HalfWidth));
-	// create 4 subnodes
-	mNodes[TOP_LEFT] = 
-		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          mVertexTL, center, HalfWidth);
-	mNodes[BOTTOM_LEFT] = 
-		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          Ogre::Vector2(mVertexTL.x, center.y),
-				  Ogre::Vector2(center.x, mVertexBR.y), HalfWidth);
-	mNodes[BOTTOM_RIGHT] =
-		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
-				  center, mVertexBR, HalfWidth);
-	mNodes[TOP_RIGHT] =
-		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-				  Ogre::Vector2(center.x, mVertexTL.y),
-				  Ogre::Vector2(mVertexBR.x, center.y), HalfWidth);
-
-	// distribute the data accordingly between the subnodes
-	Ogre::AxisAlignedBox aab;
-	for (std::vector<TData>::iterator it = mData.begin();
-		it != mData.end(); it++)
-	{
-		insert((*it));
-	}
-	// simply erase the data here ...
-	mData.clear();
-	mData.resize(1);
-
-	// remember that it's subdivided
-	mSubDivided = true;
-}
-
-template <class TData, class TNode>
-void TLooseQuadTreeNode<TData,TNode>::remove()
-{
-	if (mSubDivided)
-	{
-		// try to remove the data of any of the subnodes
-		for (int i=0; i<4; i++)
-		{
-			if (mNodes[i]) 
-			{
-				mNodes[i]->remove();
-				delete mNodes[i];
-				mNodes[i] = NULL;
-			}
-		}
-	}
-	else 
-		mSubDivided = false;
-}
-
-template <class TData, class TNode>
-TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
-{
-	TLooseQuadTree* result = NULL;
-	if (mSubdivided)
-	{
-		// try to search for the data in any of the subnodes
-		for (int i=0; i<4; i++)
-		{
-			if (mNodes[i])
-			{
-				result = mNodes[i].find(position);
-				if (result)
-					break;
-			}
-		}
-	}
-	else
-	{
-		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
-		if ( isUInside(position.x) && isVInside(position.z) )
-		{
-			// if position is in the loose quad, return it
-			result = *this;
-		}
-	}
-	return result;
-}
-
-template <class TData, class TNode>
-void TLooseQuadTreeNode<TData, TNode>::setVertex(
-	enum rl::TQuadTreeBasicNode<TData>::NodeLocation location, Ogre::Vector2 vertex)
-{
-	switch (location)
-	{
-	case TOP_LEFT:
-		mVertexTL = vertex;
-		break;
-	case BOTTOM_RIGHT:
-		mVertexBR = vertex;
-		break;
-	case BOTTOM_LEFT:
-	case TOP_RIGHT:
-		Throw (IllegalArgumentException, "Cannot set lowerleft/upperright corner");
-		break;
-	default:
-		Throw (IllegalArgumentException, "unknown NodeLocation type.");
-	}
-}
-
-
-
-template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>::TLooseQuadTree()
-: mMaxData(0),
-  mMaxDepth(0),
-  mLoosenessFactor(0),
-  mRoot(NULL)
-{
-}
-
-template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
-											 float loosenessfactor, const Ogre::Vector2& tlc,
-											 const Ogre::Vector2& brc)
-: mMaxData(maxData),
-  mMaxDepth(maxDepth),
-  mLoosenessFactor(loosenessfactor)
-{
-    RlAssert(brc.x - tlc.x == brc.y - tlc.y, 
-        "topleft and bottom right vertices specify non quad");
-    mRoot = new TNode(maxData,maxDepth,looseness, tlc, brc, brc.x - tlc.x);
-}
-
-
-
-template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::add(TData data)
-{
-    Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
-    Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
-    Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
-
-    // essential, create a root node when none is present
-    if (!mRoot)
-        mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (nrb.x-flb.x) / 2.0f,
-        Ogre::Vector2(flb.x,flb.z), Ogre::Vector2(nrb.x,nrb.z), nrb.x-flb.x);
-
-	// check if the bounding box is completely inside
-    if ( ! (mRoot->isVInside(flb.x) && mRoot->isUInside(flb.z) && 
-            mRoot->isVInside(nrb.x) && mRoot->isUInside(nrb.z)) )
-    {
-        // when not, then split root node accordingly
-        extend(flb.x, flb.z);
-        extend(nrb.x, nrb.z);
-    }
-    // after test insert normally
-    mRoot->insert(data);
-}
-
-template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::createNewRootNode(
-    enum rl::TQuadTreeBasicNode<TData>::NodeLocation location)
-{
-    typedef rl::TQuadTreeBasicNode<TData> BNode;
-    TNode* oldroot = mRoot;
-    int oldMaxDepth = mMaxDepth;
-    float oldLooseness = oldroot->getLooseness();
-    float oldWidth = oldroot->getWidth();
-
-    float newLooseness = oldLooseness * 2.0f;
-    float newWidth = oldWidth * 2.0f;
-    mMaxDepth++;
-    Ogre::Vector2 vertexTL(oldroot->mVertexTL);
-    Ogre::Vector2 vertexBR(oldroot->mVertexBR);
-    
-    Ogre::Vector2 newVertexTL;
-    Ogre::Vector2 newVertexBR;
-	switch (location)
-	{
-	case BNode::TOP_LEFT:
-        // first create new root (top) node
-        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,oldWidth);
-        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            vertexTL, newVertexBR, newWidth);
-
-		mRoot->mNodes[BNode::TOP_LEFT] = oldroot;
-        mRoot->mNodes[BNode::BOTTOM_LEFT] = 
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexTL.x,vertexBR.y), 
-                      Ogre::Vector2(vertexBR.x,newVertexBR.y), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      vertexBR,
-                      newVertexBR, oldWidth);
-        mRoot->mNodes[BNode::TOP_RIGHT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexBR.x,vertexTL.y),
-                      Ogre::Vector2(newVertexBR.x,vertexBR.y), oldWidth);
-
-		break;
-    case BNode::BOTTOM_LEFT:
-        newVertexTL = vertexTL + Ogre::Vector2(0.0f, -oldWidth);
-        newVertexBR = vertexBR + Ogre::Vector2(oldWidth, 0.0f);
-        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            newVertexTL, newVertexBR, newWidth);
-
-        mRoot->mNodes[BNode::TOP_LEFT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      newVertexTL, 
-                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] = oldroot;
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexBR.x,vertexTL.y),
-                      newVertexBR, oldWidth);
-        mRoot->mNodes[BNode::TOP_RIGHT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexBR.x,newVertexTL.y), 
-                      Ogre::Vector2(newVertexBR.x,vertexTL.y), oldWidth);
-        break;
-    case BNode::BOTTOM_RIGHT:
-        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,-oldWidth);
-        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            newVertexTL, vertexBR, newWidth);
-
-        mRoot->mNodes[BNode::TOP_LEFT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      newVertexTL,
-                      vertexTL, oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(newVertexTL.x,vertexTL.y),
-                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] = oldroot;
-        mRoot->mNodes[BNode::TOP_RIGHT] =
-            new TNode(mMaxData, mMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexTL.x,newVertexTL.y),
-                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
-		break;
-	case BNode::TOP_RIGHT:
-        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth, 0.0f);
-        newVertexBR = vertexBR + Ogre::Vector2(0.0f, oldWidth);
-        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
-            newVertexTL, newVertexBR, newWidth);
-
-        mRoot->mNodes[BNode::TOP_LEFT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      newVertexTL,
-                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_LEFT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(newVertexTL.x,vertexBR.y),
-                      Ogre::Vector2(vertexTL.x,newVertexBR.y), oldWidth);
-        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
-            new TNode(mMaxData, oldMaxDepth, oldLooseness,
-                      Ogre::Vector2(vertexTL.x,vertexBR.y),
-                      newVertexBR, oldWidth);
-        mRoot->mNodes[BNode::TOP_RIGHT] = oldroot;
-		break;
-	default:
-		Throw (IllegalArgumentException, "unknown NodeLocation type.");
-    }
-}
-
-template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::extend(const Ogre::Real& u, const Ogre::Real& v)
-{
-    // grow the root node according to the position of the point
-    if ( u < mRoot->mVertexTL.x ) 
-    {
-        if ( v < mRoot->mVertexTL.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
-            extend(u,v);
-        }
-        else if ( v > mRoot->mVertexBR.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
-            extend(u,v);
-        }
-        else
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
-            extend(u,v);
-        }
-    }
-    else if ( u > mRoot->mVertexBR.x )
-    {
-        if ( v < mRoot->mVertexTL.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
-            extend(u,v);
-        }
-        else if ( v > mRoot->mVertexBR.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_LEFT);
-            extend(u,v);
-        }  
-        else
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_LEFT);
-            extend(u,v);
-        }
-    }
-    else //  u is inside
-    {
-        if ( v < mRoot->mVertexTL.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::BOTTOM_RIGHT);
-            extend(u,v);
-        }
-        else if ( v > mRoot->mVertexBR.y )
-        {
-            createNewRootNode(rl::TQuadTreeBasicNode<TData>::TOP_RIGHT);
-            extend(u,v);
-        }
-    }
-}
-
-template <class TData, class TNode>
-void TLooseQuadTree<TData,TNode>::removeAll()
-{
-    if (mRoot)
-        delete mRoot;
-    mRoot = NULL;
-}
-
-template <class TData, class TNode>
-TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
-{
-    TLooseQuadTree<TData, TNode>* result;
-    if (mRoot)
-        result = mRoot->find(position);
-    return result;
-}
-
-}; /* world */
-
-#endif /* __QUADTREE_H__ */
-
+ */
+
+#ifndef __QUADTREE_H__
+#define __QUADTREE_H__
+
+namespace Ogre {
+	class AxisAlignedBox;
+	class Vector2;
+	class Vector3;
+};
+
+#include "CorePrerequisites.h"
+#include "Exception.h"
+
+namespace rl
+{
+	
+/** A very basic quad tree template.
+ * It just stores whether the current node is subdivided or not and
+ * the data contained in the node.
+ * Normally this would be used in a uniform flat quadtree. That means
+ * that the quadtrees memory would be preallocated once and indexing
+ * would be used to map the 2D structure into the 1D memory.
+ * Non uniform quadtrees are also possible, but quite useless, because
+ * they consume the preallocated memory anyway.
+ * Anyway the node indexing should follow the defined style by the enum
+ * NodeLocation.
+ */
+template <class TData, class TNode>
+class TQuadTreeBasicNode
+{
+public:
+	/** Tells where the node within an array is located.
+	 * creates a counterclockwise location of nodes.
+	 */
+	enum NodeLocation
+	{
+		TOP_LEFT = 0,		//!< upper left quad
+		BOTTOM_LEFT,		//!< lower left quad
+		BOTTOM_RIGHT,		//!< lower right quad
+		TOP_RIGHT			//!< upper right quad
+	};
+
+    TQuadTreeBasicNode();
+
+	/** Returns the stored data.
+	 * @returns a const reference to the internally stored data
+	 */
+	const TData& getData() { return mData; }
+
+    /** Retrieve the specified subnode.
+     * Accounting the nature of (non) uniform quadtrees the returned pointer might
+     * be NULL.
+     * @param location whether to fetch the upper/lower left/right quad.
+     * @returns the subquadtree node
+     */
+    TNode*  getNode(enum rl::TQuadTreeBasicNode<TData, TNode>::NodeLocation location);
+
+    // function for recursively deleting the quad tree
+    void remove(); //Node (TQuadTreeBasicPointerNode<TData, TNode> *node);
+
+protected:
+	bool		mSubDivided;	//!< true if node has subnodes
+	TData		mData;			//!< data of this node
+
+    TNode*      mNodes[4];  //!< four pointers to subnodes
+};
+
+template <class TData, class TNode>
+void TQuadTreeBasicNode<TData,TNode>::remove()
+{
+	if (mSubDivided)
+	{
+		// try to remove the data of any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i]) 
+			{
+				mNodes[i]->remove();
+				delete mNodes[i];
+				mNodes[i] = NULL;
+			}
+		}
+	}
+	else 
+		mSubDivided = false;
+}
+
+template <class TData, class TNode>
+TQuadTreeBasicNode<TData, TNode>::TQuadTreeBasicNode()
+{
+	for (int i=0; i<4; i++)
+    {
+        mNodes[i] = NULL;
+    }
+	mSubDivided = false;
+}
+
+/** A basic Quadtree containing vertex data
+ */
+template <class TData, class TNode>
+class TQuadTreeOgreNode : public TQuadTreeBasicNode< TData, TNode >
+{
+protected:
+	Ogre::Vector2	mVertexTL;	//!< top left vertex of this node
+	Ogre::Vector2	mVertexBR;	//!< bottom right vertex of this node
+	Ogre::Real		mWidth;		//!< length of this quad
+
+public:
+	/** Default constructor.
+	 * initializes a completely empty quad, that even doesn't represent a part
+	 * a space.
+	 */
+	TQuadTreeOgreNode();
+
+	/** Constructor to use for correct setup of quad.
+	 * Initialises the quad with all necessary data to function properly.
+	 */
+	TQuadTreeOgreNode(const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
+
+	/** Fetches the width of the quad.
+	 * @returns the width of the quad.
+	 */
+	inline Ogre::Real getWidth() { return mWidth; }
+
+	/** Retrieve the specified corner vertex.
+	 * Since only the upper left and lower right corner of the quad are stored,
+	 * the two others have to be constructed.
+	 * @param location specifies which vertex to fetch (upper/lower-left/right).
+	 * @returns the wanted vertex.
+	 */
+	inline Ogre::Vector2 getVertex(enum TQuadTreeBasicNode<TData,TNode>::NodeLocation location)
+	{
+		switch (location)
+		{
+		case TQuadTreeBasicNode<TData,TNode>::TOP_LEFT:
+			return mVertexTL;
+		case TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT:
+			return Ogre::Vector2(mVertexTL.x, mVertexBR.y);
+		case TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT:
+			return mVertexBR;
+		case TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT:
+			return Ogre::Vector2(mVertexBR.x, mVertexTL.y);
+		default:
+			Throw(IllegalArgumentException, "unknown NodeLocation type.");
+		}
+
+		return Ogre::Vector2(0.0f,0.0f);
+	}
+
+    /** retrieves the topleft vertex.
+    * @todo is this really necessary?
+     */
+    inline Ogre::Vector2 getTopLeft() { return mVertexTL; }
+    /** retrieves the bottom right vertex.
+     * @todo is this really necessary?
+     */
+    inline Ogre::Vector2 getBottomRight() { return mVertexBR; }
+
+	/** tests if the given u value is inside the quad.
+	 * Since this is a 2D test, the name refers to u coordinate
+	 * (instead of x for the 3D case).
+	 * @param u coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isUInside(Ogre::Real u) 
+	{ 
+		return (mVertexTL.x <= u && u <= mVertexBR.x);
+	}
+	/** tests if the given v value is inside the quad.
+	 * Since this is a 2D test, the name refers to v coordinate
+	 * (instead of z for the 3D case).
+	 * @param v coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isVInside(Ogre::Real v) 
+	{
+		return (mVertexTL.y <= v && v <= mVertexBR.y);
+	}
+
+	void remove(); //TQuadTree<TData, TNode> *node);
+}; /* TQuadTree */
+
+template <class TData, class TNode>
+TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode()
+: mWidth(0.0f),
+  mVertexTL(0,0),
+  mVertexBR(0,0)
+{
+}
+
+template <class TData, class TNode>
+TQuadTreeOgreNode<TData, TNode>::TQuadTreeOgreNode(
+    const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
+: mWidth(mWidth),
+  mVertexTL(tlc),
+  mVertexBR(brc)
+{
+    // right hand side coordinate system (2D part) xz plane
+    RlAssert ( (tlc < brc), "coordinates don't fit together" );
+}
+
+/** A basic loose quadtree.
+ * A loose quadtree consists of loose quads, which have an extended
+ * 'loose' area around them. So the quads do not only store the
+ * contents of the quad, but of the extende area too. This can be
+ * helpfull in eliminating additional traversals of the tree, when
+ * objects are near the border of the quad (or reaching into neighbouring
+ * quads).
+ */
+template <class TData, class TNode>
+class TLooseQuadTree //: public TQuadTreeOgreNode< std::vector< TData >, TNode >
+{
+public:
+	//! default constructor
+	TLooseQuadTree();
+
+    /** Detailed constructor.
+     * Gives the possibility to initialise all internal values to meaningfull
+     * values
+     * @param maxDepth gives the maximum number of levels inside the quadtree. \c setMaxDepth
+     * @param maxData maximum number of data elements per node. \c setMaxData 
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%) \c setLooseness
+     * @param tlc gives the top left corner (in world space) \c setExtents
+     * @param tlc gives the bottom rigth corner (in world space) \c setExtents
+     */
+	TLooseQuadTree(int maxData, int maxDepth, float looseness, 
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc);
+
+	//TLooseQuadTree(const TLooseQuadTree<TData, TNode>& Node);
+
+    /** Searches the quadtree for the node containing position.
+     * Returns the node containing the specified position or null if position
+     * is outside the quadtree.
+     * @return pointer to the node containing position or null if not inside.
+     */
+    TLooseQuadTree<TData, TNode>* find(const Ogre::Vector3& position);
+
+	/** Retrieves the loosness factor.
+	 */
+	float getLooseness() { return /*mLooseness / mWidth * 2.0f;*/ mLoosenessFactor; }
+	/** Retrieves the maximum depth of the quadtree
+	 */
+	int getMaxDepth() { return mMaxDepth; }
+	/** Retrieves the maximum number of data elements for a quad.
+	 */
+	int getMaxData() { return mMaxData; }
+
+    /** Sets the looseness factor to a new value.
+     * Changing this value is only possible, when the tree is empty.
+	 * mLooseness stores a precalculated looseness value.
+	 * The looseness is specified in percents of the width, so the loose quad
+	 * is the original quad + some additional area. e.g. 0.5 extends the original
+	 * length by 50% which means an additional area of 125%.
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+	 */
+	void setLoosenessFactor(float loosenessfactor) { mLoosenessFactor = loosenessfactor; }
+	
+    /** Sets the maximum depth of the quadtree.
+     * Changing this value is only possible, when the tree is empty.
+     * This value can change (grow) when data is added to the quad tree
+     * that is outside the quadtree.
+     * Setting this value is only possible, when there is no data in the
+     * quadtree.
+     * @param maxDepth gives the maximum number of levels inside the quadtree.
+     */
+	void setMaxDepth(int maxDepth) 
+    { 
+        if (!mRoot)
+            mMaxDepth = maxDepth;
+        else
+            LOG_DEBUG(Logger::CORE, "Setting maximum depth on non empty quadtree not possible");
+    }
+	
+    /** Sets the maximum number of data elements per quad.
+     * Changing this value is only possible, when the tree is empty.
+     * Whenever this number is exceeded, the quad is split creating 4 new
+     * subquads.
+     * When maxData is reached at the maximum depth level of the quadtree,
+     * no split will take place (because the depth limit prevents it),
+     * \c setMaxDepth.
+     * @param maxData maximum number of data elements per node.
+     */
+	void setMaxData(int maxData) 
+    {
+        if (!mRoot) 
+            mMaxData = maxData;
+        else
+            LOG_DEBUG(Logger::CORE, "Setting maximum data on non empty quadtree not possible");
+    }
+
+    /** Sets the extents of the quadtree to the specified one.
+     * Changing these value is only possible, when the tree is empty.
+     * This creates a new quadtree with the specified extents, when the
+     * tree was initially empty.
+     * The coordinates have world space (right hand sided, y is facing down).
+     * @param tlc gives the top left corner (in world space)
+     * @param tlc gives the bottom rigth corner (in world space)
+     */
+    inline void setExtents(const Ogre::Vector2& tlc, const Ogre::Vector2& brc)
+    {
+        if (!mRoot)
+            mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (brc.x-tlc.x) / 2.0f,
+            tlc, brc, brc.x-tlc.x);
+        else
+            LOG_DEBUG(Logger::CORE, "Settings extents on non empty quadtree not possible");
+    }
+
+	/** adds the specified data.
+	 * Takes into account that the specified data might not be completely
+	 * inside the quadtree resulting into a top node 'split'.
+	 * @param data the data to insert.
+	 */
+	void add(TData data);
+
+    /** deletes the complete quadtree.
+     */
+    void removeAll();
+
+protected:
+
+    /* adds nodes to the quadtree at it's top.
+     * This extends the quadtree above it's root node, so that the specified
+     * point is covered by the node.
+     * @param u x-coordinate of point in world space
+     * @param v z-coordinate of point in world space
+     */
+    void extend(const Ogre::Real& u, const Ogre::Real& v);
+
+    /* creates a new root node and adds the tree as one of it's subparts.
+     * The nodelocation gives the orientation of the new rootnode relative to
+     * the existing root node. So e.g TOP_LEFT means that the new root node
+     * will extend into the TOP_LEFT direction (!= place the old root node
+     * TOP_LEFT).
+     * @param location new location direction
+     */
+    void createNewRootNode(enum rl::TQuadTreeBasicNode<TData, TNode>::NodeLocation location);
+
+    /** maximum number of elements in one leaf.
+	 * Whenever this number is reached a subdivision takes place.
+	 */
+	int mMaxData;
+	/** maximum level of depth.
+	 * prevents further subdivision when a leafnode is at this subdivision
+	 * level
+	 */
+	int mMaxDepth;
+	/** The looseness factor
+	 * Defines the size of the 'loose' area around the quad.
+	 * Should be between 0.25 and 1.0 - less or more doesn't make sense at all.
+	 */
+	float mLoosenessFactor;
+
+    //! The root node of the quad tree.
+    TNode* mRoot;
+};
+
+/** A basic loose quadtree node.
+ * A loose quadtree consists of loose quads, which have an extended
+ * 'loose' area around them. So the quads do not only store the
+ * contents of the quad, but of the extended area too. This can be
+ * helpfull in eliminating additional traversals of the tree, when searching
+ * in case the objects are near the border of the quad (or reaching into
+ * neighbouring quads).
+ */
+template <class TData, class TNode>
+class TLooseQuadTreeNode : public TQuadTreeOgreNode< std::vector< TData >, TNode >
+{
+public:
+    /** Detailed quad node constructor.
+     * Gives the possibility to initialise all internal values to meaningfull
+     * values
+     * @param maxDepth gives the maximum number of levels inside the quadtree.
+     * @param maxData maximum number of data elements per node.
+     * @param looseness looseness factor in percent (e.g. 0.5 for 50%)
+     * @param tlc gives the top left corner (in world space)
+     * @param tlc gives the bottom rigth corner (in world space)
+     * @param mWidth gives the width of the node (passing this for performance).
+     */ 
+    TLooseQuadTreeNode(int maxData, int maxDepth, float looseness, 
+		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth=0.0f);
+
+    /** copy constructor.
+     * Should copy the data of the specified node into the new object.
+     * Normally it is not necessary to do a deep copy here (wastes performance).
+     * @param Node to copy.
+     */
+    TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node);
+
+	/** Retrieves the loosness factor.
+	 */
+	float getLooseness() { return /*mLooseness / mWidth * 2.0f*/mLooseness; }
+	/** Retrieves the maximum depth of the quadtree
+	 */
+	int getMaxDepth() { return mMaxDepth; }
+	/** Retrieves the maximum number of data elements for a quad.
+	 */
+	int getMaxData() { return mMaxData; }
+
+   	/** tests if the given u value is inside the quad.
+	 * Since this is a 2D test, the name refers to u coordinate
+	 * (instead of x for the 3D case).
+	 * @param u coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isUInsideLoose(Ogre::Real u)
+	{ 
+		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
+	}
+	/** tests if the given v value is inside the quad.
+	 * Since this is a 2D test, the name refers to v coordinate
+	 * (instead of z for the 3D case).
+	 * @param v coordinate to test whether it is inside the quad or not.
+	 */
+	inline bool isVInsideLoose(Ogre::Real v) 
+	{
+		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
+	}
+
+   	/** inserts the specified data.
+	 * The supplied axisaligned box specifies the extents of the given data.
+	 * According to that information the data is inserted at one or more
+	 * leaf nodes.
+	 */
+	void insert(TData data);
+
+	/** removes a node.
+	 * When the node has got subnodes they are also removed
+	 */
+	void remove();
+
+	/** searches the quadtree for a leaf that covers the specified position.
+	 * The search is done as if this is a normal quadtree (without any
+	 * loose boundaries applied 
+	 * @param position in world space coordinates
+	 */
+	TLooseQuadTreeNode* find(const Ogre::Vector3& position);
+
+    /** TLooseQuadTree is the management class for this node class. 
+     */
+    friend class TLooseQuadTree< TData, TNode >;
+
+protected:
+   	/** splits the node into subnodes.
+	 * Forces a split of the nodes data, creating 4 subnodes containing the
+	 * data of the original node. The original node persists as the parent
+	 * node of the new nodes.
+	 */
+	void split();
+
+    /** sets the specified vertex to a new value
+     * @param location gives the position of the vertex
+     * @param vertex contains the new value
+     */
+    void setVertex(enum rl::TQuadTreeBasicNode<TData, TNode>::NodeLocation location, Ogre::Vector2 vertex);
+
+    /** maximum number of elements in one leaf.
+	 * Whenever this number is reached a subdivision takes place.
+	 */
+	int mMaxData;
+	/** maximum level of depth.
+	 * prevents further subdivision when a leafnode is at this subdivision
+	 * level
+	 */
+	int mMaxDepth;
+	/** The looseness factor
+	 * Defines the size of the 'loose' area around the quad.
+	 * Is added and substracted from the corner vertices.
+	 */
+	float mLooseness;
+};
+
+template <class TData, class TNode>
+TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(int maxData, int maxDepth,
+											 float looseness, const Ogre::Vector2& tlc,
+											 const Ogre::Vector2& brc, float mWidth)
+: TQuadTreeOgreNode< std::vector< TData >, TNode >(tlc, brc, mWidth),
+  mMaxData(maxData),
+  mMaxDepth(maxDepth),
+  mLooseness(looseness)
+{
+}
+
+template <class TData, class TNode>
+TLooseQuadTreeNode<TData, TNode>::TLooseQuadTreeNode(const TLooseQuadTreeNode<TData, TNode>& Node)
+: TQuadTreeOgreNode< std::vector< TData >, TNode >(Node.mVertexTL, Node.mVertexBR, Node.mWidth),
+  mMaxData(Node.mMaxData),
+  mMaxDepth(Node.mMaxDepth),
+  mLooseness(Node.mLooseness)
+{
+}
+
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
+{
+	if (mSubDivided)
+	{
+		// try to add the data to any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i])
+				mNodes[i]->insert(data);
+		}
+	}
+	else
+	{
+		Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
+		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
+		Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
+		Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
+		if ( (isVInsideLoose(flb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) ||
+			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
+		{
+			// if at least one is in the loose quad, store the data
+			mData.push_back(data);
+		}
+		// split if maximum number of elements is reached ...
+		if (mData.size() == mMaxData) 
+		{
+			split();
+		}
+	}
+}
+
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData,TNode>::split()
+{
+    // first test if this node is allowed to be subdivided
+    if (mMaxDepth == 0)
+        return; // last level reached, prevent subdivision
+
+	Ogre::Real halfWidth = mWidth/2.0f;
+	Ogre::Vector2 center (getVertex(TQuadTreeBasicNode<TData,TNode>::TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
+	// create 4 subnodes
+	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+		          mVertexTL, center, halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+		          Ogre::Vector2(mVertexTL.x, center.y),
+				  Ogre::Vector2(center.x, mVertexBR.y), halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
+				  center, mVertexBR, halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
+		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
+				  Ogre::Vector2(center.x, mVertexTL.y),
+				  Ogre::Vector2(mVertexBR.x, center.y), halfWidth);
+
+	// distribute the data accordingly between the subnodes
+	Ogre::AxisAlignedBox aab;
+	for (typename std::vector<TData>::iterator it = mData.begin();
+		it != mData.end(); it++)
+	{
+		insert((*it));
+	}
+	// simply erase the data here ...
+	mData.clear();
+	mData.resize(1);
+
+	// remember that it's subdivided
+	mSubDivided = true;
+}
+
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData,TNode>::remove()
+{
+	if (mSubDivided)
+	{
+		// try to remove the data of any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i]) 
+			{
+				mNodes[i]->remove();
+				delete mNodes[i];
+				mNodes[i] = NULL;
+			}
+		}
+	}
+	else 
+		mSubDivided = false;
+}
+
+template <class TData, class TNode>
+TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
+{
+	TLooseQuadTree<TData, TNode>* result = NULL;
+	if (mSubDivided)
+	{
+		// try to search for the data in any of the subnodes
+		for (int i=0; i<4; i++)
+		{
+			if (mNodes[i])
+			{
+				result = mNodes[i].find(position);
+				if (result)
+					break;
+			}
+		}
+	}
+	else
+	{
+		// check whether any of the 4 edges of the axisalignedbox are in the loose quad
+		if ( isUInsideLoose(position.x) && isVInsideLoose(position.z) )
+		{
+			// if position is in the loose quad, return it
+			result = *this;
+		}
+	}
+	return result;
+}
+
+template <class TData, class TNode>
+void TLooseQuadTreeNode<TData, TNode>::setVertex(
+	enum rl::TQuadTreeBasicNode<TData, TNode>::NodeLocation location, Ogre::Vector2 vertex)
+{
+	switch (location)
+	{
+	case TQuadTreeBasicNode<TData,TNode>::TOP_LEFT:
+		mVertexTL = vertex;
+		break;
+	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT:
+		mVertexBR = vertex;
+		break;
+	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT:
+	case TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT:
+		Throw (IllegalArgumentException, "Cannot set lowerleft/upperright corner");
+		break;
+	default:
+		Throw (IllegalArgumentException, "unknown NodeLocation type.");
+	}
+}
+
+
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>::TLooseQuadTree()
+: mMaxData(0),
+  mMaxDepth(0),
+  mLoosenessFactor(0),
+  mRoot(NULL)
+{
+}
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>::TLooseQuadTree(int maxData, int maxDepth,
+											 float loosenessfactor, const Ogre::Vector2& tlc,
+											 const Ogre::Vector2& brc)
+: mMaxData(maxData),
+  mMaxDepth(maxDepth),
+  mLoosenessFactor(loosenessfactor)
+{
+    RlAssert(brc.x - tlc.x == brc.y - tlc.y, 
+        "topleft and bottom right vertices specify non quad");
+    mRoot = new TNode(maxData, maxDepth, loosenessfactor, tlc, brc, brc.x - tlc.x);
+}
+
+
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::add(TData data)
+{
+    Ogre::AxisAlignedBox aabb = TNode::getAABB(data);
+    Ogre::Vector3 flb = aabb.getCorner(Ogre::AxisAlignedBox::FAR_LEFT_BOTTOM);
+    Ogre::Vector3 nrb = aabb.getCorner(Ogre::AxisAlignedBox::NEAR_RIGHT_BOTTOM);
+
+    // essential, create a root node when none is present
+    if (!mRoot)
+        mRoot = new TNode(mMaxData, mMaxDepth, mLoosenessFactor * (nrb.x-flb.x) / 2.0f,
+        Ogre::Vector2(flb.x,flb.z), Ogre::Vector2(nrb.x,nrb.z), nrb.x-flb.x);
+
+	// check if the bounding box is completely inside
+    if ( ! (mRoot->isVInside(flb.x) && mRoot->isUInside(flb.z) && 
+            mRoot->isVInside(nrb.x) && mRoot->isUInside(nrb.z)) )
+    {
+        // when not, then split root node accordingly
+        extend(flb.x, flb.z);
+        extend(nrb.x, nrb.z);
+    }
+    // after test insert normally
+    mRoot->insert(data);
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::createNewRootNode(
+    enum rl::TQuadTreeBasicNode<TData, TNode>::NodeLocation location)
+{
+    typedef rl::TQuadTreeBasicNode<TData, TNode> BNode;
+    TNode* oldroot = mRoot;
+    int oldMaxDepth = mMaxDepth;
+    float oldLooseness = oldroot->getLooseness();
+    float oldWidth = oldroot->getWidth();
+
+    float newLooseness = oldLooseness * 2.0f;
+    float newWidth = oldWidth * 2.0f;
+    mMaxDepth++;
+    Ogre::Vector2 vertexTL(oldroot->mVertexTL);
+    Ogre::Vector2 vertexBR(oldroot->mVertexBR);
+    
+    Ogre::Vector2 newVertexTL;
+    Ogre::Vector2 newVertexBR;
+	switch (location)
+	{
+	case BNode::TOP_LEFT:
+        // first create new root (top) node
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth,oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            vertexTL, newVertexBR, newWidth);
+
+		mRoot->mNodes[BNode::TOP_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = 
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), 
+                      Ogre::Vector2(vertexBR.x,newVertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      vertexBR,
+                      newVertexBR, oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,vertexTL.y),
+                      Ogre::Vector2(newVertexBR.x,vertexBR.y), oldWidth);
+
+		break;
+    case BNode::BOTTOM_LEFT:
+        newVertexTL = vertexTL + Ogre::Vector2(0.0f, -oldWidth);
+        newVertexBR = vertexBR + Ogre::Vector2(oldWidth, 0.0f);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, newVertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL, 
+                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] = oldroot;
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,vertexTL.y),
+                      newVertexBR, oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexBR.x,newVertexTL.y), 
+                      Ogre::Vector2(newVertexBR.x,vertexTL.y), oldWidth);
+        break;
+    case BNode::BOTTOM_RIGHT:
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth,-oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, vertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL,
+                      vertexTL, oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(newVertexTL.x,vertexTL.y),
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] = oldroot;
+        mRoot->mNodes[BNode::TOP_RIGHT] =
+            new TNode(mMaxData, mMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexTL.x,newVertexTL.y),
+                      Ogre::Vector2(vertexBR.x,vertexTL.y), oldWidth);
+		break;
+	case BNode::TOP_RIGHT:
+        newVertexTL = vertexTL + Ogre::Vector2(-oldWidth, 0.0f);
+        newVertexBR = vertexBR + Ogre::Vector2(0.0f, oldWidth);
+        mRoot = new TNode(mMaxData, mMaxDepth, newLooseness,
+            newVertexTL, newVertexBR, newWidth);
+
+        mRoot->mNodes[BNode::TOP_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      newVertexTL,
+                      Ogre::Vector2(vertexTL.x,vertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_LEFT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(newVertexTL.x,vertexBR.y),
+                      Ogre::Vector2(vertexTL.x,newVertexBR.y), oldWidth);
+        mRoot->mNodes[BNode::BOTTOM_RIGHT] =
+            new TNode(mMaxData, oldMaxDepth, oldLooseness,
+                      Ogre::Vector2(vertexTL.x,vertexBR.y),
+                      newVertexBR, oldWidth);
+        mRoot->mNodes[BNode::TOP_RIGHT] = oldroot;
+		break;
+	default:
+		Throw (IllegalArgumentException, "unknown NodeLocation type.");
+    }
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::extend(const Ogre::Real& u, const Ogre::Real& v)
+{
+    // grow the root node according to the position of the point
+    if ( u < mRoot->mVertexTL.x ) 
+    {
+        if ( v < mRoot->mVertexTL.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexBR.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::TOP_RIGHT);
+            extend(u,v);
+        }
+        else
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+    }
+    else if ( u > mRoot->mVertexBR.x )
+    {
+        if ( v < mRoot->mVertexTL.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::BOTTOM_LEFT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexBR.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::TOP_LEFT);
+            extend(u,v);
+        }  
+        else
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::BOTTOM_LEFT);
+            extend(u,v);
+        }
+    }
+    else //  u is inside
+    {
+        if ( v < mRoot->mVertexTL.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::BOTTOM_RIGHT);
+            extend(u,v);
+        }
+        else if ( v > mRoot->mVertexBR.y )
+        {
+            createNewRootNode(TQuadTreeBasicNode<TData, TNode>::TOP_RIGHT);
+            extend(u,v);
+        }
+    }
+}
+
+template <class TData, class TNode>
+void TLooseQuadTree<TData,TNode>::removeAll()
+{
+    delete mRoot;
+    mRoot = NULL;
+}
+
+template <class TData, class TNode>
+TLooseQuadTree<TData, TNode>* TLooseQuadTree<TData,TNode>::find(const Ogre::Vector3& position)
+{
+    TLooseQuadTree<TData, TNode>* result = NULL;
+    if (mRoot != NULL)
+    {
+        result = mRoot->find(position);
+    }
+    return result;
+}
+
+}; /* world */
+
+#endif /* __QUADTREE_H__ */
+



From blakharaz at mail.berlios.de  Fri Mar 30 14:06:17 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 14:06:17 +0200
Subject: [Dsa-hl-svn] r3207 - rl/trunk/engine/core/include
Message-ID: <200703301206.l2UC6HUR022660@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 14:06:16 +0200 (Fri, 30 Mar 2007)
New Revision: 3207

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
Inherited members of template classes must be fully qualified (at least 
for gcc)


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-30 10:57:56 UTC (rev 3206)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-30 12:06:16 UTC (rev 3207)
@@ -416,7 +416,7 @@
 	 */
 	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
-		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
+		return (TQuadTreeOgreNode<TData, TNode>::mVertexTL.x - mLooseness <= u && u <= TQuadTreeOgreNode<TData, TNode>::mVertexBR.x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -425,7 +425,7 @@
 	 */
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
-		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
+		return (TQuadTreeOgreNode<TData, TNode>::mVertexTL.y - mLooseness <= v && v <= TQuadTreeOgreNode<TData, TNode>::mVertexBR.y + mLooseness);
 	}
 
    	/** inserts the specified data.
@@ -504,13 +504,15 @@
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
 {
-	if (mSubDivided)
+	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
 	{
 		// try to add the data to any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i])
-				mNodes[i]->insert(data);
+			if (TQuadTreeOgreNode<TData, TNode>::mNodes[i] != NULL)
+            {
+				TQuadTreeOgreNode<TData, TNode>::mNodes[i]->insert(data);
+            }
 		}
 	}
 	else
@@ -523,10 +525,10 @@
 			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
 		{
 			// if at least one is in the loose quad, store the data
-			mData.push_back(data);
+			TQuadTreeOgreNode<TData, TNode>::mData.push_back(data);
 		}
 		// split if maximum number of elements is reached ...
-		if (mData.size() == mMaxData) 
+		if (TQuadTreeOgreNode<TData, TNode>::mData.size() == mMaxData) 
 		{
 			split();
 		}
@@ -540,73 +542,77 @@
     if (mMaxDepth == 0)
         return; // last level reached, prevent subdivision
 
-	Ogre::Real halfWidth = mWidth/2.0f;
+	Ogre::Real halfWidth = TQuadTreeOgreNode<TData, TNode>::mWidth/2.0f;
 	Ogre::Vector2 center (getVertex(TQuadTreeBasicNode<TData,TNode>::TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
 	// create 4 subnodes
-	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
+	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          mVertexTL, center, halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
+		          TQuadTreeOgreNode<TData, TNode>::mVertexTL, center, halfWidth);
+	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          Ogre::Vector2(mVertexTL.x, center.y),
-				  Ogre::Vector2(center.x, mVertexBR.y), halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
+		          Ogre::Vector2(TQuadTreeOgreNode<TData, TNode>::mVertexTL.x, center.y),
+				  Ogre::Vector2(center.x, TQuadTreeOgreNode<TData, TNode>::mVertexBR.y), halfWidth);
+	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
-				  center, mVertexBR, halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
+				  center, TQuadTreeOgreNode<TData, TNode>::mVertexBR, halfWidth);
+	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-				  Ogre::Vector2(center.x, mVertexTL.y),
-				  Ogre::Vector2(mVertexBR.x, center.y), halfWidth);
+				  Ogre::Vector2(center.x, TQuadTreeOgreNode<TData, TNode>::mVertexTL.y),
+				  Ogre::Vector2(TQuadTreeOgreNode<TData, TNode>::mVertexBR.x, center.y), halfWidth);
 
 	// distribute the data accordingly between the subnodes
 	Ogre::AxisAlignedBox aab;
-	for (typename std::vector<TData>::iterator it = mData.begin();
-		it != mData.end(); it++)
+	for (typename std::vector<TData>::iterator it = TQuadTreeBasicNode<TData, TNode>::mData.begin();
+		it != TQuadTreeBasicNode<TData, TNode>::mData.end(); it++)
 	{
 		insert((*it));
 	}
 	// simply erase the data here ...
-	mData.clear();
-	mData.resize(1);
+	TQuadTreeBasicNode<TData, TNode>::mData.clear();
+	TQuadTreeBasicNode<TData, TNode>::mData.resize(1);
 
 	// remember that it's subdivided
-	mSubDivided = true;
+	TQuadTreeBasicNode<TData, TNode>::mSubDivided = true;
 }
 
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::remove()
 {
-	if (mSubDivided)
+	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
 	{
 		// try to remove the data of any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i]) 
+			if (TQuadTreeBasicNode<TData, TNode>::mNodes[i] != NULL) 
 			{
-				mNodes[i]->remove();
-				delete mNodes[i];
-				mNodes[i] = NULL;
+				TQuadTreeBasicNode<TData, TNode>::mNodes[i]->remove();
+				delete TQuadTreeBasicNode<TData, TNode>::mNodes[i];
+				TQuadTreeBasicNode<TData, TNode>::mNodes[i] = NULL;
 			}
 		}
 	}
 	else 
-		mSubDivided = false;
+    {
+		TQuadTreeBasicNode<TData, TNode>::mSubDivided = false;
+    }
 }
 
 template <class TData, class TNode>
 TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
 {
 	TLooseQuadTree<TData, TNode>* result = NULL;
-	if (mSubDivided)
+	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
 	{
 		// try to search for the data in any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i])
+			if (TQuadTreeBasicNode<TData, TNode>::mNodes[i])
 			{
-				result = mNodes[i].find(position);
-				if (result)
+				result = TQuadTreeBasicNode<TData, TNode>::mNodes[i].find(position);
+				if (result != NULL)
+                {
 					break;
+                }
 			}
 		}
 	}
@@ -629,10 +635,10 @@
 	switch (location)
 	{
 	case TQuadTreeBasicNode<TData,TNode>::TOP_LEFT:
-		mVertexTL = vertex;
+		TQuadTreeOgreNode<TData, TNode>::mVertexTL = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT:
-		mVertexBR = vertex;
+		TQuadTreeOgreNode<TData, TNode>::mVertexBR = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT:
 	case TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT:



From blakharaz at mail.berlios.de  Fri Mar 30 18:13:30 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 18:13:30 +0200
Subject: [Dsa-hl-svn] r3208 - rl/trunk/engine/core/include
Message-ID: <200703301613.l2UGDUU6008515@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 18:13:16 +0200 (Fri, 30 Mar 2007)
New Revision: 3208

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
Make it compile on Visual Studio again :)

Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-30 12:06:16 UTC (rev 3207)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-30 16:13:16 UTC (rev 3208)
@@ -416,7 +416,7 @@
 	 */
 	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
-		return (TQuadTreeOgreNode<TData, TNode>::mVertexTL.x - mLooseness <= u && u <= TQuadTreeOgreNode<TData, TNode>::mVertexBR.x + mLooseness);
+		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -425,7 +425,7 @@
 	 */
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
-		return (TQuadTreeOgreNode<TData, TNode>::mVertexTL.y - mLooseness <= v && v <= TQuadTreeOgreNode<TData, TNode>::mVertexBR.y + mLooseness);
+		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
 	}
 
    	/** inserts the specified data.
@@ -504,14 +504,14 @@
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
 {
-	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
+	if (mSubDivided)
 	{
 		// try to add the data to any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (TQuadTreeOgreNode<TData, TNode>::mNodes[i] != NULL)
+			if (mNodes[i] != NULL)
             {
-				TQuadTreeOgreNode<TData, TNode>::mNodes[i]->insert(data);
+				mNodes[i]->insert(data);
             }
 		}
 	}
@@ -525,10 +525,10 @@
 			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
 		{
 			// if at least one is in the loose quad, store the data
-			TQuadTreeOgreNode<TData, TNode>::mData.push_back(data);
+			mData.push_back(data);
 		}
 		// split if maximum number of elements is reached ...
-		if (TQuadTreeOgreNode<TData, TNode>::mData.size() == mMaxData) 
+		if (mData.size() == mMaxData) 
 		{
 			split();
 		}
@@ -542,58 +542,58 @@
     if (mMaxDepth == 0)
         return; // last level reached, prevent subdivision
 
-	Ogre::Real halfWidth = TQuadTreeOgreNode<TData, TNode>::mWidth/2.0f;
-	Ogre::Vector2 center (getVertex(TQuadTreeBasicNode<TData,TNode>::TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
+	Ogre::Real halfWidth = mWidth/2.0f;
+	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
 	// create 4 subnodes
-	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
+	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          TQuadTreeOgreNode<TData, TNode>::mVertexTL, center, halfWidth);
-	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
+		          mVertexTL, center, halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          Ogre::Vector2(TQuadTreeOgreNode<TData, TNode>::mVertexTL.x, center.y),
-				  Ogre::Vector2(center.x, TQuadTreeOgreNode<TData, TNode>::mVertexBR.y), halfWidth);
-	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
+		          Ogre::Vector2(mVertexTL.x, center.y),
+				  Ogre::Vector2(center.x, mVertexBR.y), halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
-				  center, TQuadTreeOgreNode<TData, TNode>::mVertexBR, halfWidth);
-	TQuadTreeBasicNode<TData, TNode>::mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
+				  center, mVertexBR, halfWidth);
+	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-				  Ogre::Vector2(center.x, TQuadTreeOgreNode<TData, TNode>::mVertexTL.y),
-				  Ogre::Vector2(TQuadTreeOgreNode<TData, TNode>::mVertexBR.x, center.y), halfWidth);
+				  Ogre::Vector2(center.x, mVertexTL.y),
+				  Ogre::Vector2(mVertexBR.x, center.y), halfWidth);
 
 	// distribute the data accordingly between the subnodes
 	Ogre::AxisAlignedBox aab;
-	for (typename std::vector<TData>::iterator it = TQuadTreeBasicNode<TData, TNode>::mData.begin();
-		it != TQuadTreeBasicNode<TData, TNode>::mData.end(); it++)
+	for (typename std::vector<TData>::iterator it = mData.begin();
+		it != mData.end(); it++)
 	{
 		insert((*it));
 	}
 	// simply erase the data here ...
-	TQuadTreeBasicNode<TData, TNode>::mData.clear();
-	TQuadTreeBasicNode<TData, TNode>::mData.resize(1);
+	mData.clear();
+	mData.resize(1);
 
 	// remember that it's subdivided
-	TQuadTreeBasicNode<TData, TNode>::mSubDivided = true;
+	mSubDivided = true;
 }
 
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::remove()
 {
-	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
+	if (mSubDivided)
 	{
 		// try to remove the data of any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (TQuadTreeBasicNode<TData, TNode>::mNodes[i] != NULL) 
+			if (mNodes[i] != NULL) 
 			{
-				TQuadTreeBasicNode<TData, TNode>::mNodes[i]->remove();
-				delete TQuadTreeBasicNode<TData, TNode>::mNodes[i];
-				TQuadTreeBasicNode<TData, TNode>::mNodes[i] = NULL;
+				mNodes[i]->remove();
+				delete mNodes[i];
+				mNodes[i] = NULL;
 			}
 		}
 	}
 	else 
     {
-		TQuadTreeBasicNode<TData, TNode>::mSubDivided = false;
+		mSubDivided = false;
     }
 }
 
@@ -601,14 +601,14 @@
 TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
 {
 	TLooseQuadTree<TData, TNode>* result = NULL;
-	if (TQuadTreeBasicNode<TData, TNode>::mSubDivided)
+	if (mSubDivided)
 	{
 		// try to search for the data in any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (TQuadTreeBasicNode<TData, TNode>::mNodes[i])
+			if (mNodes[i])
 			{
-				result = TQuadTreeBasicNode<TData, TNode>::mNodes[i].find(position);
+				result = mNodes[i].find(position);
 				if (result != NULL)
                 {
 					break;
@@ -635,10 +635,10 @@
 	switch (location)
 	{
 	case TQuadTreeBasicNode<TData,TNode>::TOP_LEFT:
-		TQuadTreeOgreNode<TData, TNode>::mVertexTL = vertex;
+		mVertexTL = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT:
-		TQuadTreeOgreNode<TData, TNode>::mVertexBR = vertex;
+		mVertexBR = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT:
 	case TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT:



From blakharaz at mail.berlios.de  Fri Mar 30 18:39:41 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 18:39:41 +0200
Subject: [Dsa-hl-svn] r3209 - rl/trunk/engine/core/include
Message-ID: <200703301639.l2UGdf2B029536@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 18:39:34 +0200 (Fri, 30 Mar 2007)
New Revision: 3209

Modified:
   rl/trunk/engine/core/include/QuadTree.h
Log:
GCC can't find the fields of template base classes, added some this-> to 
prevent compiler errors


Modified: rl/trunk/engine/core/include/QuadTree.h
===================================================================
--- rl/trunk/engine/core/include/QuadTree.h	2007-03-30 16:13:16 UTC (rev 3208)
+++ rl/trunk/engine/core/include/QuadTree.h	2007-03-30 16:39:34 UTC (rev 3209)
@@ -416,7 +416,7 @@
 	 */
 	inline bool isUInsideLoose(Ogre::Real u)
 	{ 
-		return (mVertexTL.x - mLooseness <= u && u <= mVertexBR.x + mLooseness);
+		return (this->mVertexTL.x - mLooseness <= u && u <= this->mVertexBR.x + mLooseness);
 	}
 	/** tests if the given v value is inside the quad.
 	 * Since this is a 2D test, the name refers to v coordinate
@@ -425,7 +425,7 @@
 	 */
 	inline bool isVInsideLoose(Ogre::Real v) 
 	{
-		return (mVertexTL.y - mLooseness <= v && v <= mVertexBR.y + mLooseness);
+		return (this->mVertexTL.y - mLooseness <= v && v <= this->mVertexBR.y + mLooseness);
 	}
 
    	/** inserts the specified data.
@@ -504,14 +504,14 @@
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::insert(TData data)
 {
-	if (mSubDivided)
+	if (this->mSubDivided)
 	{
 		// try to add the data to any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i] != NULL)
+			if (this->mNodes[i] != NULL)
             {
-				mNodes[i]->insert(data);
+				this->mNodes[i]->insert(data);
             }
 		}
 	}
@@ -525,10 +525,10 @@
 			 (isVInsideLoose(nrb.x) && (isUInsideLoose(flb.z) || isUInsideLoose(nrb.z))) )
 		{
 			// if at least one is in the loose quad, store the data
-			mData.push_back(data);
+			this->mData.push_back(data);
 		}
 		// split if maximum number of elements is reached ...
-		if (mData.size() == mMaxData) 
+		if (this->mData.size() == mMaxData) 
 		{
 			split();
 		}
@@ -542,58 +542,58 @@
     if (mMaxDepth == 0)
         return; // last level reached, prevent subdivision
 
-	Ogre::Real halfWidth = mWidth/2.0f;
-	Ogre::Vector2 center (getVertex(TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
+	Ogre::Real halfWidth = this->mWidth/2.0f;
+	Ogre::Vector2 center (getVertex(this->TOP_LEFT) + Ogre::Vector2(halfWidth, halfWidth));
 	// create 4 subnodes
-	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
+	this->mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          mVertexTL, center, halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
+		          this->mVertexTL, center, halfWidth);
+	this->mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT] = 
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-		          Ogre::Vector2(mVertexTL.x, center.y),
-				  Ogre::Vector2(center.x, mVertexBR.y), halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
+		          Ogre::Vector2(this->mVertexTL.x, center.y),
+				  Ogre::Vector2(center.x, this->mVertexBR.y), halfWidth);
+	this->mNodes[TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f, 
-				  center, mVertexBR, halfWidth);
-	mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
+				  center, this->mVertexBR, halfWidth);
+	this->mNodes[TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT] =
 		new TNode(mMaxData,mMaxDepth-1,mLooseness/2.0f,
-				  Ogre::Vector2(center.x, mVertexTL.y),
-				  Ogre::Vector2(mVertexBR.x, center.y), halfWidth);
+				  Ogre::Vector2(center.x, this->mVertexTL.y),
+				  Ogre::Vector2(this->mVertexBR.x, center.y), halfWidth);
 
 	// distribute the data accordingly between the subnodes
 	Ogre::AxisAlignedBox aab;
-	for (typename std::vector<TData>::iterator it = mData.begin();
-		it != mData.end(); it++)
+	for (typename std::vector<TData>::iterator it = this->mData.begin();
+		it != this->mData.end(); it++)
 	{
 		insert((*it));
 	}
 	// simply erase the data here ...
-	mData.clear();
-	mData.resize(1);
+	this->mData.clear();
+	this->mData.resize(1);
 
 	// remember that it's subdivided
-	mSubDivided = true;
+	this->mSubDivided = true;
 }
 
 template <class TData, class TNode>
 void TLooseQuadTreeNode<TData,TNode>::remove()
 {
-	if (mSubDivided)
+	if (this->mSubDivided)
 	{
 		// try to remove the data of any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i] != NULL) 
+			if (this->mNodes[i] != NULL) 
 			{
-				mNodes[i]->remove();
-				delete mNodes[i];
-				mNodes[i] = NULL;
+				this->mNodes[i]->remove();
+				delete this->mNodes[i];
+				this->mNodes[i] = NULL;
 			}
 		}
 	}
 	else 
     {
-		mSubDivided = false;
+		this->mSubDivided = false;
     }
 }
 
@@ -601,14 +601,14 @@
 TLooseQuadTreeNode<TData, TNode>* TLooseQuadTreeNode<TData,TNode>::find(const Ogre::Vector3& position)
 {
 	TLooseQuadTree<TData, TNode>* result = NULL;
-	if (mSubDivided)
+	if (this->mSubDivided)
 	{
 		// try to search for the data in any of the subnodes
 		for (int i=0; i<4; i++)
 		{
-			if (mNodes[i])
+			if (this->mNodes[i] != NULL)
 			{
-				result = mNodes[i].find(position);
+				result = this->mNodes[i].find(position);
 				if (result != NULL)
                 {
 					break;
@@ -635,10 +635,10 @@
 	switch (location)
 	{
 	case TQuadTreeBasicNode<TData,TNode>::TOP_LEFT:
-		mVertexTL = vertex;
+		this->mVertexTL = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_RIGHT:
-		mVertexBR = vertex;
+		this->mVertexBR = vertex;
 		break;
 	case TQuadTreeBasicNode<TData,TNode>::BOTTOM_LEFT:
 	case TQuadTreeBasicNode<TData,TNode>::TOP_RIGHT:



From blakharaz at mail.berlios.de  Fri Mar 30 21:12:10 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 21:12:10 +0200
Subject: [Dsa-hl-svn] r3210 - rl/trunk/engine/dialog/src/predicates
Message-ID: <200703301912.l2UJCAIZ001095@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 21:11:55 +0200 (Fri, 30 Mar 2007)
New Revision: 3210

Modified:
   rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
Log:
Added newlines at file end

Modified: rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-03-30 16:39:34 UTC (rev 3209)
+++ rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-03-30 19:11:55 UTC (rev 3210)
@@ -81,4 +81,5 @@
 	return "grundwert";
 }
 
-}
\ No newline at end of file
+}
+

Modified: rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-03-30 16:39:34 UTC (rev 3209)
+++ rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-03-30 19:11:55 UTC (rev 3210)
@@ -98,4 +98,5 @@
 	return "questparts";
 }
 
-}
\ No newline at end of file
+}
+



From blakharaz at mail.berlios.de  Fri Mar 30 21:13:13 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 21:13:13 +0200
Subject: [Dsa-hl-svn] r3211 - rl/trunk/engine/rules/src
Message-ID: <200703301913.l2UJDD1L001478@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 21:13:11 +0200 (Fri, 30 Mar 2007)
New Revision: 3211

Modified:
   rl/trunk/engine/rules/src/TimerEventSource.cpp
Log:
removed unused import

Modified: rl/trunk/engine/rules/src/TimerEventSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-03-30 19:11:55 UTC (rev 3210)
+++ rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-03-30 19:13:11 UTC (rev 3211)
@@ -19,7 +19,6 @@
 #include "TimerEvent.h"
 #include "TimerManager.h"
 #include "TimerListener.h"
-#include "GameObject.h"
 #include "DsaManager.h"
 #include "GameLoop.h"
 #include "ScriptWrapper.h"



From blakharaz at mail.berlios.de  Fri Mar 30 21:20:29 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 21:20:29 +0200
Subject: [Dsa-hl-svn] r3212 - modules/common/dsa
	modules/common/gui/imagesets modules/common/gui/windows
	modules/regressiontest/dsa rl/branches
	rl/branches/old_inventory_window
	rl/branches/old_inventory_window/engine
	rl/branches/old_inventory_window/engine/ui
	rl/branches/old_inventory_window/engine/ui/include
	rl/branches/old_inventory_window/engine/ui/src
	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
Message-ID: <200703301920.l2UJKTZ0002885@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 21:20:10 +0200 (Fri, 30 Mar 2007)
New Revision: 3212

Added:
   modules/common/gui/windows/inventory_human.xml
   rl/branches/old_inventory_window/
   rl/branches/old_inventory_window/engine/
   rl/branches/old_inventory_window/engine/ui/
   rl/branches/old_inventory_window/engine/ui/include/
   rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h
   rl/branches/old_inventory_window/engine/ui/src/
   rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp
Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/common/gui/imagesets/ModelThumbnails.imageset
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Started work on new inventory window

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/dsa/gameobjectdefinitions.gof	2007-03-30 19:20:10 UTC (rev 3212)
@@ -17,6 +17,7 @@
 		<property name="baseclass" type="STRING" data="Hero" />
 		<property name="geometrytype" type="STRING" data="ellipsoid" />
 		<property name="mass" type="REAL" data="75"/>
+		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
 	</gameobjectclass>
 
 </GameObjectDefinitions>

Modified: modules/common/gui/imagesets/ModelThumbnails.imageset
===================================================================
--- modules/common/gui/imagesets/ModelThumbnails.imageset	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/gui/imagesets/ModelThumbnails.imageset	2007-03-30 19:20:10 UTC (rev 3212)
@@ -8,6 +8,7 @@
 	<Image Name="Stiefel" XPos="30" YPos="62" Width="60" Height="60" />
 	<Image Name="Fellumhang" XPos="154" YPos="1" Width="60" Height="120" />
 	<Image Name="Rubinring" XPos="217" YPos="1" Width="30" Height="30" />
+	<Image Name="waf_kurzschwert_01" XPos="170" YPos="130" Width="30" Height="120" />
 	<Image Name="Kurzschwert" XPos="170" YPos="130" Width="30" Height="120" />
     <Image Name="Fackel" XPos="218" YPos="31" Width="30" Height="90" />
 	<Image Name="Amboss" XPos="0" YPos="256" Width="120" Height="60" />

Added: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/gui/windows/inventory_human.xml	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,163 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+    <Window Type="RastullahLook/FrameWindow" Name="InventoryWindow">
+		<Property Name="VerticalAlignment" Value="Centre" />
+		<Property Name="HorizontalAlignment" Value="Centre" />
+		<Property Name="UnifiedSize" Value="{{0,830},{0,560}}" />
+		<Property Name="Text" Value="Inventar" />
+		
+		<Window Type="RastullahLook/InventoryBackground" Name="InventoryWindow/Slots">
+			<Property Name="UnifiedPosition" Value="{{0,5},{0,5}}" />
+			<Property Name="UnifiedSize" Value="{{0,820},{0,540}}" />
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Head">
+				<Property Name="UnifiedPosition" Value="{{0.0,150},{0,40}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Back">
+				<Property Name="UnifiedPosition" Value="{{0,270},{0,450}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Ring">
+				<Property Name="UnifiedPosition" Value="{{0,30},{0,240}}" />
+				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+			</Window>
+
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Ring">
+				<Property Name="UnifiedPosition" Value="{{0,300},{0,240}}" />
+				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+			</Window>				
+
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Right Hand">
+				<Property Name="UnifiedPosition" Value="{{0,30},{0,80}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Left Hand">
+				<Property Name="UnifiedPosition" Value="{{0,270},{0,80}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,150}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Armor">
+				<Property Name="UnifiedPosition" Value="{{0,135},{0,110}}" />
+				<Property Name="UnifiedSize" Value="{{0,90},{0,120}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Belt">
+				<Property Name="UnifiedPosition" Value="{{0,135},{0,240}}" />
+				<Property Name="UnifiedSize" Value="{{0,90},{0,30}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Trousers">
+				<Property Name="UnifiedPosition" Value="{{0,150},{0,280}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,90}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Boots">
+				<Property Name="UnifiedPosition" Value="{{0,150},{0,450}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Shinbone">
+				<Property Name="UnifiedPosition" Value="{{0,150},{0,380}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Necklace">
+				<Property Name="UnifiedPosition" Value="{{0,225},{0,70}}" />
+				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+			</Window>
+			
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletRight">
+				<Property Name="UnifiedPosition" Value="{{0,70},{0,240}}" />
+				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+			</Window>
+		
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/BraceletLeft">
+				<Property Name="UnifiedPosition" Value="{{0,260},{0,240}}" />
+				<Property Name="UnifiedSize" Value="{{0,30},{0,30}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Gloves">
+				<Property Name="UnifiedPosition" Value="{{0,30},{0,350}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Bracers">
+				<Property Name="UnifiedPosition" Value="{{0,30},{0,280}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,60}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/Container" Name="InventoryWindow/Slots/Cape">
+				<Property Name="UnifiedPosition" Value="{{0,270},{0,280}}" />
+				<Property Name="UnifiedSize" Value="{{0,60},{0,120}}" />
+			</Window>
+			
+						
+			
+			<!--
+			*** Helden wechsel ***
+			
+			<Window Type="RastullahLook/Listbox" Name="InventoryWindow/Heroes">
+				<Property Name="Text" Value="Heroes"/>
+				<Property Name="UnifiedAreaRect" Value="{{0,30},{0,475},{0,330},{0,525}}" />
+			</Window>
+			-->
+			<!-- Rechte Seite --> 
+			
+			<!-- Itembild -->
+			<Window Type="RastullahLook/StaticImage" Name="InventoryWindow/ItemPicture">
+				<Property Name="Text" Value="Itempicture"/>
+				<Property Name="UnifiedAreaRect" Value="{{0,370},{0,20},{0,498},{0,148}}" />
+			</Window>
+			
+			<Window Type="RastullahLook/ScrollablePane" Name="InventoryWindow/Description">
+				<Property Name="Text" Value=""/>
+				<Property Name="UnifiedAreaRect" Value="{{0,508},{0,20},{1,-25},{0,148}}" />
+			</Window>
+	
+			<Window Type="RastullahLook/MultiLineEditbox" Name="InventoryWindow/Infos">
+				<Property Name="Font" Value="Vera Serif-10" />
+                <!--<Property Name="FrameEnabled" Value="false" />-->
+				<Property Name="Text" Value="BE: 0, AT: 5, Traglast: 0 Stein, Max: 50 Stein, Guthaben: 5 Dukaten, Ausdauer: 25"/>
+				
+				<Property Name="UnifiedAreaRect" Value="{{0,370},{0,158},{1,-25},{0,210}}" />
+			</Window>
+				
+			<Window Type="RastullahLook/TabControl" Name="InventoryWindow/Tabs">
+				<Property Name="UnifiedAreaRect" Value="{{0,370},{0,220},{1,-25},{0.9,-20}}" />
+			</Window>
+			
+			<!-- Das Ruestungsfenster -->
+			<Window Type="RastullahLook/TransparentStaticImage" Name="InventoryWindow/ArmorValueWindow">
+				<Property Name="UnifiedPosition" Value="{{0,370},{0,475}}" />
+				<Property Name="UnifiedSize" Value="{{0,50},{0,50}}" />
+				
+				<Window Type="RastullahLook/TransparentStaticText" Name="InventoryWindow/ArmorValue">
+					<Property Name="UnifiedPosition" Value="{{0,6},{0,0}}" />
+					<Property Name="UnifiedSize" Value="{{1,0},{0.67,0}}" />
+				</Window>
+				
+				<Window Type="RastullahLook/TransparentStaticText" Name="InventoryWindow/HandicapValue">
+					<Property Name="UnifiedPosition" Value="{{0,24},{0,0}}" />
+					<Property Name="UnifiedSize" Value="{{1,0},{0.67,0}}" />
+				</Window>
+			</Window>
+			<!-- Das Gewichtsfenster -->
+			<Window Type="RastullahLook/TransparentStaticImage" Name="InventoryWindow/WeightWindow">
+				<Property Name="UnifiedPosition" Value="{{0,430},{0,475}}" />
+				<Property Name="UnifiedSize" Value="{{0,45},{0,50}}" />
+
+				<Window Type="RastullahLook/TransparentStaticText" Name="InventoryWindow/TotalWeight">
+					<Property Name="UnifiedPosition" Value="{{0,6},{0,4}}" />
+					<Property Name="UnifiedSize" Value="{{1,0},{1,-4}}" />
+				</Window>
+			</Window>
+			
+		</Window>
+	</Window>
+</GUILayout>
+
+

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-30 19:20:10 UTC (rev 3212)
@@ -60,6 +60,7 @@
         <property name="baseclass" type="STRING" data="Weapon" />
         <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
         <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
     </gameobjectclass>
 
     <gameobjectclass>

Added: rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,275 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __InventoryWindow_H__
+#define __InventoryWindow_H__
+
+#include "UiPrerequisites.h"
+#include "CeGuiWindow.h"
+#include "Inventory.h"
+#include "GameTask.h"
+
+namespace rl {
+
+	class Creature;
+    class Item;
+
+	class _RlUiExport InventoryArrangeTask : public GameTask
+	{
+	public:
+		InventoryArrangeTask();
+		~InventoryArrangeTask();
+		
+		void run(Ogre::Real elapsedTime);
+
+        virtual const Ogre::String& getName() const;
+	};
+
+	class _RlUiExport InventoryWindow : public CeGuiWindow
+	{
+	public:
+		InventoryWindow();
+		~InventoryWindow();
+
+		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
+		CEGUI::DragContainer* mDroppedItem;
+
+		/**
+		* Gibt dem Fenster das anzuzeigende Inventar
+		*/
+		void setInventory(Inventory* inventory);
+
+		/**
+		* Methode fr das OnMouseOver Event
+		*/
+		bool handleMouseEnters(const CEGUI::EventArgs &args);
+		
+		/**
+		* Methode fr das OnMouseLeaves Event
+		*/
+		bool handleMouseLeaves(const CEGUI::EventArgs &args);
+
+		/**
+		* Methode fr das OnMouseClick Event
+		*/
+		bool handleMouseClicked(const CEGUI::EventArgs &args);
+
+		/**
+		* 
+		*/
+		void update();
+
+		/**
+		* ?ergibt ?derungen ans Inventar
+		*/
+		void updateInventory();
+
+		/**
+		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
+		* dafr ne externe Methode
+		*/
+		void updateItemPosition();
+
+		// FIXME, wenn BUG im CEGUI behoben ist: entfernen
+
+		/**
+		* Schaut nach, ob das Item an der Position gedroppt werden kann.
+		*/
+		bool isFreeInContainer(Item* item, std::pair<int,int> kaestechenPos, Container* container);
+
+
+		Item* getGroundItem();
+
+	private:
+		Inventory* mInventory;
+
+		// Farbschema fr die Fenster und Itemhintergrnde
+		const CeGuiString mColorAccept;
+		const CeGuiString mColorReject;
+		const CeGuiString mColorNormal;
+		const CeGuiString mColorItemNormal;
+		const CeGuiString mColorItemSelected;
+
+		// TODO : Ersetze durch etwas dynamisches
+		Item* mGroundItem;
+
+		// Der Knoten an dem das zu redernde Item angebracht wird;
+		Ogre::SceneNode* mInventoryItemNode;
+		// Entity des jeweils zu rendernden Items
+		Ogre::Entity* mRenderItemEntity;
+		// 128*128 Textur fr das Item-view Fenster
+		Ogre::RenderTexture* mRenderTexture;
+		// Viewport des RenderToTexture Features
+		Ogre::Viewport* mRenderViewport;
+		// Die Camera, die das Item filmt
+		Actor* mCameraActor;
+
+		CEGUI::Texture* mTexture;
+		CEGUI::Imageset* mImageSet;
+
+        InventoryArrangeTask* mInventoryArrangeTask;
+
+		// Das Item-Renderfenster
+		CEGUI::Window* mItemRenderImage;
+
+
+		// Das Rstungs- und Behinderungswert Fenster
+		CEGUI::Window* mArmorValueWindow;
+		CEGUI::Window* mArmorValue;
+		CEGUI::Window* mHandicapValue;
+
+		// Das Gewichtsfenster
+		CEGUI::Window* mWeightWindow;
+		CEGUI::Window* mTotalWeight;
+		
+
+		// Das Item-Beschreibungsfenster
+		CEGUI::ScrollablePane* mDescription;
+
+		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew?lt ist
+		CEGUI::Window* mActiveItemWindow;
+
+		// Das Fenster, in das der Rucksackcontainer soll
+		CEGUI::TabControl* mContainerTabs;
+
+		// Die Containerslots (besonders, da alle Arten von Items akzeptiert)
+		std::list<CEGUI::Window*> mContainerContents;
+
+		std::list<CEGUI::Window*> mContainers;
+
+		CEGUI::Window* mGroundTab;
+		CEGUI::Window* mGroundContainer;
+
+		const std::pair<int,int> mGroundDimension;
+
+		// Alle verschiedenen Inventoryslots
+		CEGUI::Window* mRingLeft;
+		CEGUI::Window* mRingRight;
+		CEGUI::Window* mHandLeft;
+		CEGUI::Window* mHandRight;
+		CEGUI::Window* mGloves;
+		CEGUI::Window* mBraceletLeft;
+		CEGUI::Window* mBraceletRight;
+		CEGUI::Window* mArmor;
+		CEGUI::Window* mCape;
+		CEGUI::Window* mBracers;
+		CEGUI::Window* mBackpack;
+		CEGUI::Window* mBelt;
+		CEGUI::Window* mNecklace;
+		CEGUI::Window* mHelmet;
+		CEGUI::Window* mTrousers;
+		CEGUI::Window* mShinbone;
+		CEGUI::Window* mBoots;
+
+		CEGUI::Point mPosDraggedTo;
+		CEGUI::Window* mContainerDraggedTo;
+		CEGUI::DragContainer* mOldItemInSlot;
+        
+        CEGUI::DragContainer* createItem(Item* item, CEGUI::Window* parent, CEGUI::UVector2 position = CEGUI::UVector2(cegui_reldim(0.0f), cegui_reldim(0.0f)));
+
+		/**
+		* Schliesst das Fenster bei Klick auf X
+		*/
+		bool handleClose();
+
+		void initRenderToTexture();
+
+		/**
+		* L?t die Rtt-Camera
+		*/
+		void loadCamera();
+		void unloadCamera();
+
+		/**
+		* Rendert das Item in das Vorschaufenster im Inventar
+		*/
+		void renderItem(Item* item);
+
+		/**
+		* Initiiert die Slots des Inventars
+		*/
+		void initSlots();
+
+		/**
+		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
+		*/
+		void fillSlots();
+
+		/**
+		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
+		*/
+		void createAndFillContainer(Container* container);
+
+		/**
+		* entfernt ein ContainerTab mitsamt Inhalt aus dem Inventar
+		*/
+		void removeContainerAndContent(Container* container);
+
+		/**
+		* Entleert die Slots im InventarFenster wieder
+		*/
+		void emptySlots();
+
+
+		void refreshTabs();
+
+		/**
+		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh?t
+		*/
+		CEGUI::Window* findContainer(Container* container);
+
+		/**
+		*
+		* Entfernt alle Unterfenster
+		*/
+		void emptySlot(CEGUI::Window* slot);
+		/** 
+		* Gibt dem Slot die F?igkeit Dragcontainer zu akzeptieren
+		*/
+		void addDropListener(CEGUI::Window* slot);
+
+		/*!
+		* fgt dem Inventar den Container fr den Rucksack zu,
+		* gibt ihm die n?ige Funktionalit? fr drag&drop
+		*/
+		void initBackpack(std::pair<int,int> dim);
+
+
+		/**
+		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
+		* im Inventar
+		*/
+		void createContainerWindows();
+
+		/**
+		* ?erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
+		* @return true: Item wird akzeptiert
+		*         false: Item wird nicht akzeptiert
+		*/ 
+		bool checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem);
+
+
+		/**
+		* Errechnet die K?tchenposition, an der das Item im Container gedroppt wurde
+		*/
+		std::pair<int,int> calculateNewPosition(const CEGUI::DragDropEventArgs& ddea);
+
+		bool handleDragEnter(const CEGUI::EventArgs& args);
+		bool handleDragLeave(const CEGUI::EventArgs& args);
+		bool handleDragDropped(const CEGUI::EventArgs& args);
+	};
+}
+#endif

Added: rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,1295 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+
+#include <boost/bind.hpp>
+
+#include "InventoryWindow.h"
+
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "Exception.h"
+#include "GameLoop.h"
+#include "Inventory.h"
+#include "MeshObject.h"
+#include "PhysicalThing.h"
+#include "RulesSubsystem.h"
+#include "UiSubsystem.h"
+#include "WindowFactory.h"
+#include "World.h"
+#include "CeGuiHelper.h"
+
+#include <CEGUIPropertyHelper.h>
+#include <OgreCEGUIRenderer.h>
+
+using namespace CEGUI;
+using namespace Ogre;
+using namespace std;
+
+namespace rl {
+
+	// @FIXME Wenn CeGUI Bug beseitigt hat:
+	InventoryArrangeTask::InventoryArrangeTask() : GameTask()
+	{
+	}
+
+	InventoryArrangeTask::~InventoryArrangeTask()
+	{
+	}
+
+	void InventoryArrangeTask::run(Ogre::Real elapsedTime)
+	{
+		static InventoryWindow* invWin = WindowFactory::getSingletonPtr()->getInventoryWindow();
+		if (invWin->mDroppedItem)
+		{
+			LOG_MESSAGE("InventoryWindow", "Item placed");
+			invWin->updateItemPosition();
+		}
+	}
+
+    const Ogre::String& InventoryArrangeTask::getName() const
+    {
+        static Ogre::String NAME = "InventoryArrangeTask";
+
+        return NAME;
+    }
+
+
+	// ***************************************************************
+	// ***************** Konstruktor *********************************
+	// ***************************************************************
+	InventoryWindow::InventoryWindow()
+		: CeGuiWindow("inventorywindow.xml", WND_MOUSE_INPUT),
+		mDescription(NULL),
+		mRenderItemEntity(NULL),
+		mRenderTexture(NULL),
+		mRenderViewport(NULL),
+		mItemRenderImage(NULL),
+		mCameraActor(NULL),
+		mInventoryItemNode(NULL),
+		mTexture(NULL),
+		mImageSet(NULL),
+		mActiveItemWindow(NULL),
+		mArmorValueWindow(NULL),
+		mArmorValue(NULL),
+		mHandicapValue(NULL),
+		mWeightWindow(NULL),
+		mTotalWeight(NULL),
+		mPosDraggedTo(),
+		mContainerDraggedTo(NULL),
+		mDroppedItem(NULL),
+		mOldItemInSlot(NULL),
+		mContainerTabs(NULL),
+		mContainerContents(NULL),
+		mGroundTab(NULL),
+		mGroundItem(NULL),
+		mGroundContainer(NULL),
+		mColorAccept("FF22FF22"),
+		mColorReject("FFFF2222"),
+		mColorNormal("FFFFFFFF"),
+		mColorItemNormal("FF999955"),
+		mColorItemSelected("FFDDDD99"),
+		mRingLeft(NULL),
+		mRingRight(NULL),
+		mHandLeft(NULL),
+		mHandRight(NULL),
+		mGloves(NULL),
+		mBraceletLeft(NULL),
+		mBraceletRight(NULL),
+		mArmor(NULL),
+		mCape(NULL),
+		mBracers(NULL),
+		mBackpack(NULL),
+		mBelt(NULL),
+		mNecklace(NULL),
+		mHelmet(NULL),
+		mTrousers(NULL),
+		mShinbone(NULL),
+		mBoots(NULL),
+        mInventoryArrangeTask(),
+		mGroundDimension(make_pair<int,int>(12,15))
+	{
+		initSlots();
+		initRenderToTexture();
+
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&InventoryWindow::handleClose, this));
+
+        mInventoryArrangeTask = new InventoryArrangeTask();
+        GameLoop::getSingletonPtr()->addTask(mInventoryArrangeTask, GameLoop::TG_GRAPHICS);
+	}
+	
+	InventoryWindow::~InventoryWindow()
+	{
+		/*if(mBackpackContent){
+			mBackpackContent->destroy();
+		}*/
+        delete mInventoryArrangeTask;
+//        delete mGroundItem;
+	}
+
+
+	/** Methoden */
+
+	void InventoryWindow::setInventory(Inventory* inventory)
+	{
+		if (inventory != NULL && mInventory != inventory){
+			// Entleere Slots zur Sicherheit (falls anderes Inventar zuvor gezeigt wurde)
+			emptySlots();
+			// Speichere das neue Inventar
+			mInventory = inventory;
+			// Fuelle das Fenster entsprechend dem neuen Inventar, das angezeigt werden soll
+			fillSlots();
+			update();
+		}
+	}
+
+	bool InventoryWindow::handleClose()
+	{
+		if (isVisible())
+		{
+			setVisible(false);
+		}
+		return true;
+	}
+
+	void InventoryWindow::update()
+	{
+		// Aktualisiere Werte
+
+		// Rstung
+		mArmorValue->setText(Ogre::StringConverter::toString(mInventory->getOverallRs()));
+
+		// Behinderung
+		pair<int,int> behinderung = mInventory->getOverallBe();
+		mHandicapValue->setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
+		if (behinderung.second > 0)
+		{
+			mArmorValueWindow->setTooltipText("Rstung / Behinderung\r\n           / +"+Ogre::StringConverter::toString(behinderung.second)+" berladen");
+		} 
+		else
+		{
+			mArmorValueWindow->setTooltipText("Rstung / Behinderung");
+		}
+
+		// Gewicht in Unzen
+		int weight = mInventory->getOverallWeight() / 40;
+		// TODO: runden
+		mTotalWeight->setText(Ogre::StringConverter::toString(weight));
+	}
+
+	void InventoryWindow::updateItemPosition(){
+		
+		// Positionieren
+        mDroppedItem->setPosition(CeGuiHelper::asAbsolute(mPosDraggedTo));
+		mDroppedItem = NULL;
+
+		// Loggen
+		LOG_MESSAGE(
+			"InventoryWindow",
+			Ogre::String("Position set to: Point x:")
+			+ StringConverter::toString(mPosDraggedTo.d_x)
+			+ ", Point y:"
+			+ StringConverter::toString(mPosDraggedTo.d_y));
+
+		LOG_MESSAGE("InventoryWindow", "updateItemPosition finished");
+	}
+
+	void InventoryWindow::updateInventory(){
+		// Nach Drop
+		Item* item = static_cast<Item*>(mDroppedItem->getUserData());
+
+		// Gegenstand von alter Position entfernen
+		//mInventory->removeItem(item);
+
+		// Gegenstand vom Boden entfernen
+		//mInventory->removeItemFromContainer(item, mGroundItem);
+
+		// Welchem Item wird das Item hinzugefgt? -> speichere das in die Variable container
+		Item* container = static_cast<Item*>(mContainerDraggedTo->getUserData());
+
+		// Extra Behandlung, falls Item auf den Boden gelegt wird
+		if (container == mGroundItem)
+		{
+			//mInventory->setItemContainerPosition(
+			//	item,
+			//	(int)(mPosDraggedTo.d_x/30), 
+			//	(int)(mPosDraggedTo.d_y/30),
+			//	container);
+
+			// Zusaetzlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
+			if (item->isContainer())
+			{
+				removeContainerAndContent(dynamic_cast<Container*>(item));
+				refreshTabs();
+			}
+			update();
+			return;
+		} 
+				
+		// Item im Container platzieren
+		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
+
+		while (it != mContainerContents.end())
+		{
+			if (mContainerDraggedTo == *it++){
+				//mInventory->setItemContainerPosition(
+				//	item,
+				//	(int)(mPosDraggedTo.d_x/30), 
+				//	(int)(mPosDraggedTo.d_y/30),
+				//	container);
+				break;
+			}
+		}
+
+		if (item->isContainer())
+		{
+			// ContainerTab hinzufgen, wenn nicht schon vorhanden
+			createAndFillContainer(dynamic_cast<Container*>(item));
+			refreshTabs();
+
+		}
+		
+
+		bool itemSwitched = false;
+		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
+		//if (mContainerDraggedTo == mArmor){
+		//	if (mInventory->getArmor() != NULL){
+		//		//Pack die alte Rstung ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeArmor(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setArmor(item);
+		//}
+		//if (mContainerDraggedTo == mCape){
+		//	if (mInventory->getCape() != NULL){
+		//		//Pack die alte Rstung ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeCape(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setCape(item);
+		//}
+		//if (mContainerDraggedTo == mBackpack) {
+		//	if (mInventory->getBackpack() != NULL){
+		//		//Pack den alten Rucksack auf den Boden
+		//		mInventory->addItemToContainer(mInventory->removeBackpack(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBackpack(item);
+		//}
+		//if (mContainerDraggedTo == mBelt) {
+		//	if (mInventory->getBelt() != NULL){
+		//		//Pack den alten Grtel ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeBelt(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBelt(item);
+		//}
+		//if (mContainerDraggedTo == mBoots) {
+		//	if (mInventory->getBoots() != NULL){
+		//		//pack die alten Stiefel ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeBoots(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBoots(item);
+		//}
+		//if (mContainerDraggedTo == mBraceletLeft) {
+		//	if (mInventory->getBraceletLeft() != NULL){
+		//		//pack den alten Armreif ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeBraceletLeft(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBraceletLeft(item);
+		//}
+		//if (mContainerDraggedTo == mBraceletRight) {
+		//	if (mInventory->getBraceletRight() != NULL){
+		//		//pack den alten Armreif ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeBraceletRight(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBraceletRight(item);
+		//}
+		//if (mContainerDraggedTo == mRingLeft) {
+		//	if (mInventory->getRingLeft() != NULL){
+		//		//pack den alten Ring ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeRingLeft(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setRingLeft(item);
+		//}
+		//if (mContainerDraggedTo == mRingRight) {
+		//	if (mInventory->getRingRight() != NULL){
+		//		//pack den alten Ring ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeRingRight(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setRingRight(item);
+		//}
+		//if (mContainerDraggedTo == mHelmet) {
+		//	if (mInventory->getHelmet() != NULL){
+		//		//pack den alten Helm ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeHelmet(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setHelmet(item);
+		//}
+		//if (mContainerDraggedTo == mBracers) {
+		//	if (mInventory->getBracers() != NULL){
+		//		//pack die alte Armschienen ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeBracers(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setBracers(item);
+		//}
+		//if (mContainerDraggedTo == mNecklace) {
+		//	if (mInventory->getNecklace() != NULL){
+		//		//pack das alte Amulett ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeNecklace(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setNecklace(item);
+		//}
+		//if (mContainerDraggedTo == mGloves) {
+		//	if (mInventory->getGloves() != NULL){
+		//		//pack die alten Handschuhe ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeGloves(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setGloves(item);
+		//}
+		//if (mContainerDraggedTo == mTrousers) {
+		//	if (mInventory->getTrousers() != NULL){
+		//		//pack die alte Hose ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeTrousers(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setTrousers(item);
+		//}
+		//if (mContainerDraggedTo == mShinbone) {
+		//	if (mInventory->getShinbone() != NULL){
+		//		//pack die alte Hose ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeShinbone(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setShinbone(item);
+		//}
+		//if (mContainerDraggedTo == mHandLeft) {
+		//	if (mInventory->getHandLeft() != NULL){
+		//		//pack das alte Schild ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeHandLeft(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setHandLeft(item);
+		//}
+		//if (mContainerDraggedTo == mHandRight) {
+		//	if (mInventory->getHandRight() != NULL){
+		//		//pack die alte Waffe ins Inventar
+		//		mInventory->addItemToContainer(mInventory->removeHandRight(), mInventory->getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory->setHandRight(item);
+		//}
+		if (itemSwitched)
+		{
+			try {
+				//Bild muss im Inventarfenster an die neue Position gelegt werden
+				//pair<pair<int,int>,Item*> posInContainer = mInventory->getItemPositionInContainer(static_cast<Item*>(mOldItemInSlot->getUserData()));
+
+				//// Container Fenster suchen
+				//CEGUI::Window* win = findContainer(posInContainer.second);
+				//// Dem Fenster hinzufgen
+				//win->addChildWindow(mOldItemInSlot);
+				//// Positionieren		
+				//mOldItemInSlot->setPosition( CEGUI::Absolute,
+				//	CEGUI::Point(posInContainer.first.first * 30, posInContainer.first.second * 30));
+
+			}
+			catch (IllegalArgumentException iae)
+			{
+				// TODO: Item am Boden suchen
+			}
+		}
+
+
+		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
+		update();
+	}
+
+
+	void InventoryWindow::refreshTabs()
+	{
+		std::list<CEGUI::Window*>::iterator it = mContainers.begin();
+
+		// entferne alle Unterfenster
+		while(mContainerTabs->getTabCount() > 0)
+		{
+			mContainerTabs->removeTab(mContainerTabs->getTabContents(0)->getName());
+		}
+
+		// fge sie in richtiger Reihenfolge wieder hinzu
+		while (it != mContainers.end())
+		{
+			mContainerTabs->addTab(*it++);
+		}
+	}
+
+	bool InventoryWindow::isFreeInContainer(Item* item, pair<int,int> kaestchenPos, Container* container)
+	{
+        return container->canPlaceAt(item, kaestchenPos.first, kaestchenPos.second);
+		//return mInventory->isFreeInContainer(item, kaestchenPos, container);
+        //return true;
+	}
+
+
+	Item* InventoryWindow::getGroundItem()
+	{
+		return mGroundItem;
+	}
+
+	void InventoryWindow::initSlots()
+	{
+		mArmorValueWindow = getWindow("InventoryWindow/ArmorValueWindow");
+        mArmorValueWindow->setProperty("Image", "set:InventorySymbols image:Shield");
+		mArmorValueWindow->setTooltipText("Rstung / Behinderung");
+		//TODO: An Tooltip anhaengen: woraus setzt sich die Rstung zusammen?
+		mArmorValue = getWindow("InventoryWindow/ArmorValue");
+		mArmorValue->setText(" 3");
+		//mArmorValue->setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
+		mArmorValue->disable();
+		mHandicapValue = getWindow("InventoryWindow/HandicapValue");
+		mHandicapValue->setText("2");
+		//mHandicapValue->setTextColours(CEGUI::colour(0.4,0.0,0.0)); //TODO port to cegui0.5
+		mHandicapValue->disable();
+
+		mWeightWindow = getWindow("InventoryWindow/WeightWindow");
+        mWeightWindow->setProperty("Image", "set:InventorySymbols image:Weight");
+		mWeightWindow->setTooltipText("Getragenes Gewicht\r\nin Stein");
+
+		mTotalWeight = getWindow("InventoryWindow/TotalWeight");
+		mTotalWeight->setText("");
+		// Schwarzer Text (wird rot, wenn berladen)
+		//mTotalWeight->setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
+		mTotalWeight->disable();
+				
+
+		// Das Item-Beschreibungsfeld holen
+		mDescription = getScrollablePane("InventoryWindow/Description");
+
+		// Das "BodenItem" initiieren
+		mGroundItem = new Item(1/*"Boden", "Dieses Item repr?entiert den Boden"*/);
+		mGroundItem->setImageName("Trank");
+		mGroundItem->setItemType(Item::ITEMTYPE_OTHER);
+		mGroundItem->setSize(1,1);
+		//mGroundItem->setContainer(true, std::make_pair<int,int>(mGroundDimension.first,mGroundDimension.second));
+
+
+		mContainerTabs = getTabControl("InventoryWindow/Tabs");
+		
+		// Hole die einzelnen Slots aus dem XML-File
+		mHelmet = getWindow("InventoryWindow/Helmet");
+		mHelmet->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_HELMET));
+		
+		mRingLeft = getWindow("InventoryWindow/RingLeft");
+		mRingLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_RING));
+		
+		mRingRight = getWindow("InventoryWindow/RingRight");
+		mRingRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_RING));
+		
+		mHandLeft = getWindow("InventoryWindow/HandLeft");
+		mHandLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_SHIELD));
+
+		mHandRight = getWindow("InventoryWindow/HandRight");
+		mHandRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_WEAPON));
+
+		mGloves = getWindow("InventoryWindow/Gloves");
+		mGloves->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_GLOVES));
+
+		mBraceletLeft = getWindow("InventoryWindow/BraceletLeft");
+		mBraceletLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
+
+		mBraceletRight = getWindow("InventoryWindow/BraceletRight");
+		mBraceletRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
+
+		mArmor = getWindow("InventoryWindow/Armor");
+		mArmor->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_ARMOR));
+
+		mCape = getWindow("InventoryWindow/Cape");
+		mCape->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_CAPE));
+
+		mBracers = getWindow("InventoryWindow/Bracers");
+		mBracers->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACERS));
+
+		mBackpack = getWindow("InventoryWindow/Backpack");
+		mBackpack->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BACKPACK));
+
+		mBelt = getWindow("InventoryWindow/Belt");
+		mBelt->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BELT));
+
+		mNecklace = getWindow("InventoryWindow/Necklace");
+		mNecklace->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_NECKLACE));
+
+		mTrousers = getWindow("InventoryWindow/Trousers");
+		mTrousers->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_TROUSERS));
+
+		mShinbone = getWindow("InventoryWindow/Shinbone");
+		mShinbone->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_SHINBONE));
+
+		mBoots = getWindow("InventoryWindow/Boots");
+		mBoots->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
+
+		// gib ihnen die Funktionalitaet Items aufzunehmen
+		addDropListener(mHelmet);
+		addDropListener(mRingLeft);
+		addDropListener(mRingRight);
+		addDropListener(mHandLeft);
+		addDropListener(mHandRight);
+		addDropListener(mGloves);
+		addDropListener(mBraceletLeft);
+		addDropListener(mBraceletRight);
+		addDropListener(mArmor);
+		addDropListener(mCape);
+		addDropListener(mBracers);
+		addDropListener(mBackpack);
+		addDropListener(mBelt);
+		addDropListener(mNecklace);
+		addDropListener(mTrousers);
+		addDropListener(mShinbone);
+		addDropListener(mBoots);
+	}
+
+	void InventoryWindow::fillSlots()
+	{
+		//createItem(mInventory->getRingLeft(), mRingLeft);
+		//createItem(mInventory->getRingRight(), mRingRight);
+		createItem(mInventory->getItem("Left Hand"), mHandLeft);
+		//createItem(mInventory->getHandRight(), mHandRight);
+		//createItem(mInventory->getGloves(), mGloves);
+		//createItem(mInventory->getBraceletLeft(), mBraceletLeft);
+		//createItem(mInventory->getBraceletRight(), mBraceletRight);
+		//createItem(mInventory->getArmor(), mArmor);
+		//createItem(mInventory->getCape(), mCape);
+		//createItem(mInventory->getBracers(), mBracers);
+		//createItem(mInventory->getBackpack(), mBackpack);
+		//createItem(mInventory->getBelt(), mBelt);
+		//createItem(mInventory->getNecklace(), mNecklace);
+		//createItem(mInventory->getHelmet(), mHelmet);
+		//createItem(mInventory->getTrousers(), mTrousers);
+		//createItem(mInventory->getShinbone(), mShinbone);
+		//createItem(mInventory->getBoots(), mBoots);
+
+
+		// Fenster fr ContainerItems erstellen
+		createContainerWindows();
+	}
+
+
+	void InventoryWindow::createContainerWindows() {
+		
+
+		std::list<Item*> allItems = mInventory->getAllItems();
+
+		std::list<Item*>::iterator itemIterator = allItems.begin();
+		
+		while (itemIterator != allItems.end()){
+			Item* currentItem = *itemIterator++;
+
+			if (currentItem->isContainer()){
+				// Tab fr Item erzeugen, da es als Container funktioniert
+				createAndFillContainer(dynamic_cast<Container*>(currentItem));
+			}
+		}
+		// Den Boden hinzufuegen
+		//createAndFillContainer(mGroundItem);
+	}
+
+	void InventoryWindow::createAndFillContainer(Container* container){
+		assert(mContainerContents.size() == mContainers.size());
+
+		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
+		bool found = false;
+		// berprfe, ob schon vorhanden
+		while (it != mContainerContents.end())
+		{
+			if (container == static_cast<Item*>((*it)->getUserData()))
+			{
+				found = true;
+				break;
+			}
+			it++;
+		}
+		
+		// Nur wenn noch nicht vorhanden, soll Containertab erzeugt werden
+		if (!found)
+		{
+
+			// Erzeuge Tab im Inventar fr den Container
+			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow("DefaultGUISheet", "InventoryWindow/Tabs/"+container->getName());
+			// Name fr das Tab
+			containerWindow->setText(container->getName());
+
+
+			mContainerTabs->addTab(containerWindow);
+
+			CEGUI::Window* containerSpace = static_cast<CEGUI::Window*>(CEGUI::WindowManager::getSingletonPtr()->createWindow("RastullahLook/Container", "InventoryWindow/Tabs/"+container->getName()+"/Content"));
+			
+			containerSpace->setVerticalAlignment(CEGUI::VA_CENTRE);
+			containerSpace->setHorizontalAlignment(CEGUI::HA_CENTRE);
+            containerSpace->setSize(UVector2(cegui_absdim(container->getVolume().first*30),
+                cegui_absdim(container->getVolume().second*30)));
+			containerSpace->setUserData(container);
+			containerWindow->addChildWindow(containerSpace);
+
+
+			// Inhalt in die Liste Einfgen
+						// Boden an das Ende der Liste einfgen
+			if (container == mGroundItem)
+			{
+				mContainers.push_back(containerWindow);
+				mContainerContents.push_back(containerSpace);
+			}
+			// Rucksack vorne in die Liste einfuegen
+			else if (container->getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				mContainers.push_front(containerWindow);
+				mContainerContents.push_front(containerSpace);
+			}
+			// den Rest dazwischen
+			else 
+			{
+				if (mContainers.size() > 1)
+				{
+					mContainers.insert(++(mContainers.begin()),containerWindow);
+					mContainerContents.insert(++(mContainerContents.begin()),containerSpace);
+				} else {
+					mContainers.push_front(containerWindow);
+					mContainerContents.push_front(containerSpace);
+				}
+			}
+			
+
+			addDropListener(containerSpace);
+
+			// Items im Container erstellen
+			std::set<Item*> itemsInContainer;
+
+			//ContainerLayout temp = container->getContainerLayout();
+			//for (unsigned x = 0; x < temp.size(); x++){
+			//	for (unsigned y = 0; y < temp[0].size(); y++) {
+			//		if (temp[x][y] != NULL && (itemsInContainer.find(temp[x][y]) == itemsInContainer.end())){
+			//			DragContainer* itemhandler = createItem(temp[x][y],containerSpace);
+			//			itemhandler->setPosition(CEGUI::Absolute,CEGUI::Point(x*30,y*30));
+			//			itemsInContainer.insert(temp[x][y]);
+			//			LOG_MESSAGE(
+			//				"InventoryWindow",
+			//				Ogre::String("erzeuge Bild im Container: ") + temp[x][y]->getName());
+			//		}
+			//	}
+			//}
+		}
+	}
+
+
+	void InventoryWindow::removeContainerAndContent(Container* container)
+	{
+		assert(mContainerContents.size() == mContainers.size());
+		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
+		std::list<CEGUI::Window*>::iterator itParent = mContainers.begin();
+		CEGUI::Window* windowToEmpty = NULL;
+		CEGUI::Window* parentTabWindow = NULL;
+
+		bool found = false;
+		while (it != mContainerContents.end())
+		{
+			if (container == static_cast<Item*>((*it)->getUserData()))
+			{
+				// Aus Liste entfernen
+				windowToEmpty = *it;
+				parentTabWindow = *itParent;
+				found = true;
+				break;
+			}
+			it++;
+			itParent++;
+		}
+		if (found)
+		{
+			// Entferne die Elemente aus den Listen
+			mContainerContents.erase(it);
+			mContainers.erase(itParent);
+
+
+			emptySlot(windowToEmpty);
+			emptySlot(parentTabWindow);
+
+			mContainerTabs->removeTab(parentTabWindow->getName());
+
+			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(parentTabWindow);
+		}
+	}
+
+	void InventoryWindow::emptySlots()
+	{
+		emptySlot(mHelmet);
+		emptySlot(mRingLeft);
+		emptySlot(mRingRight);
+		emptySlot(mHandLeft);
+		emptySlot(mHandRight);
+		emptySlot(mGloves);
+		emptySlot(mBraceletLeft);
+		emptySlot(mBraceletRight);
+		emptySlot(mArmor);
+		emptySlot(mCape);
+		emptySlot(mBracers);
+		emptySlot(mBackpack);
+		emptySlot(mBelt);
+		emptySlot(mNecklace);
+		emptySlot(mTrousers);
+		emptySlot(mShinbone);
+		emptySlot(mBoots);
+
+		// Zus?zlich alle Container durchgehen und entleeren
+		
+		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
+		
+		while (it != mContainerContents.end())
+		{
+			emptySlot(*it);
+			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(*it);
+			it++;
+		} // alle Container wurden entleert
+
+		it = mContainers.begin();
+		while (it != mContainers.end())
+		{
+			emptySlot(*it);
+			mContainerTabs->removeTab((*it)->getName());
+			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(*it);
+			it++;
+		} // alle ContainerTabs wurden entleert
+		mContainerContents.clear();
+		mContainers.clear();
+	}
+
+	void InventoryWindow::emptySlot(CEGUI::Window* slot)
+	{
+		while(slot->getChildCount() > 0){
+			CEGUI::Window* windowToDestroy = slot->getChildAtIdx(0);
+			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(windowToDestroy);
+			slot->removeChildWindow(windowToDestroy);
+		}
+	}
+
+	void InventoryWindow::addDropListener(CEGUI::Window* slot){
+		// onMouseOver (beim Drag)
+		slot->subscribeEvent(Window::EventDragDropItemEnters, boost::bind(&InventoryWindow::handleDragEnter,this,_1));
+		// onMouseOut (beim Drag)
+		slot->subscribeEvent(Window::EventDragDropItemLeaves, boost::bind(&InventoryWindow::handleDragLeave,this,_1));
+		// onItemDropped
+		slot->subscribeEvent(Window::EventDragDropItemDropped, boost::bind(&InventoryWindow::handleDragDropped,this,_1)); 
+	}
+
+	CEGUI::Window* InventoryWindow::findContainer(Container* container)
+	{
+		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
+		while (it != mContainerContents.end())
+		{
+			if (static_cast<Item*>((*it)->getUserData()) == container)
+				return (*it);
+			it++;
+		}
+		Throw(IllegalArgumentException, "Es gibt kein Containerfenster zu dem gesuchten Item");
+	}
+
+	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
+	{
+		// Prfe, ob ein Item da ist
+		if (item != NULL) {
+
+			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
+			// Waffe:
+			if (parent == mHandRight || parent == mHandLeft) 
+			{
+				position = UVector2(cegui_absdim(30-(item->getSize().first * 15)), cegui_absdim(75-(item->getSize().second *15)));
+			}
+
+			static int itemCnt = 0;
+			itemCnt++;
+
+			// Erzeuge einen Handler fr Drag and Drop
+			DragContainer* itemhandler = static_cast<DragContainer*>(
+				CEGUI::WindowManager::getSingletonPtr()->createWindow("DragContainer", Ogre::StringConverter::toString(itemCnt) + item->getName()));
+			itemhandler->setPosition(position);
+			itemhandler->setSize(UVector2(cegui_absdim(item->getSize().first*30),
+                cegui_absdim(item->getSize().second*30))); 
+			itemhandler->setUserString("ItemType",Item::getItemTypeString(item->getItemType()));
+			itemhandler->setUserData(item);
+			itemhandler->setTooltipText(item->getName());
+			itemhandler->subscribeEvent(CEGUI::Window::EventMouseClick,
+				Event::Subscriber(&InventoryWindow::handleMouseClicked,this));
+			
+			parent->addChildWindow(itemhandler);
+
+			CeGuiString tempName = item->getName();
+
+			// Erzeuge das Hintergrundfenster des Items
+			Window* itemWindow = 
+				CEGUI::WindowManager::getSingletonPtr()->createWindow(
+					"RastullahLook/StaticImage", 
+					tempName + "Item");
+
+			itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+			itemWindow->setSize(UVector2(cegui_absdim(item->getSize().first*30),
+                cegui_absdim(item->getSize().second*30)));
+			itemWindow->setProperty("FrameEnabled", "false");
+			//itemWindow->setProperty("BackgroundColour", mColorItemNormal);
+			// Gib dem Item noch ein Bild...
+			itemWindow->setProperty("Image", item->getImageName());
+            itemWindow->disable(); 
+
+			itemhandler->addChildWindow(itemWindow);
+
+			return itemhandler;
+		}
+		else
+		{
+			// Kein Item da...
+			return NULL;
+		}
+	}
+
+	bool InventoryWindow::handleMouseEnters(const EventArgs &args) 
+	{
+		return true;
+	}
+
+	bool InventoryWindow::handleMouseLeaves(const EventArgs &args) 
+	{
+		return true;
+	}
+
+
+	bool InventoryWindow::handleMouseClicked(const EventArgs &args) 
+	{
+		// Hole das ausgew?lte Item
+		const CEGUI::MouseEventArgs& mea = static_cast<const MouseEventArgs&>(args);
+
+		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
+		if (mea.window->getUserData() != NULL)
+		{
+			Item* item = NULL;
+			item = static_cast<Item*>(mea.window->getUserData());
+	
+			// deaktiviere das letzte aktive Item, falls es eins gab
+			if (mActiveItemWindow){
+				mActiveItemWindow->setProperty("BackgroundColour", mColorItemNormal);
+				mActiveItemWindow->setProperty("FrameEnabled", "False");
+			}
+			
+			assert(mea.window->getChildCount() > 0);
+			
+			// aktiviere das angew?lte Item...
+			mActiveItemWindow = mea.window->getChildAtIdx(0);
+			mActiveItemWindow->setProperty("BackgroundColour", mColorItemSelected);
+			mActiveItemWindow->setProperty("FrameEnabled", "True");
+			
+			// Schreibe Iteminfos in Description Fenster
+			if (item) 
+			{
+				mDescription->setText(item->getDescription());
+				if (item->getDescription().length() > 200)
+				{
+					// Scrollbalken aktivieren
+                    mDescription->setShowVertScrollbar(true);
+				}
+				else 
+				{
+
+				}
+				renderItem(item);
+			}
+			else
+			{
+				mDescription->setText("");
+			}
+		}
+		return true;
+	}
+
+	void InventoryWindow::initRenderToTexture()
+	{
+		// Das Feld, in das gerendert werden soll (TransparentStaticImage)
+		mItemRenderImage = getWindow("InventoryWindow/ItemPicture");
+
+		SceneManager* tempManager = CoreSubsystem::getSingleton().
+				getWorld()->getSceneManager();
+	
+
+		// Setup Render To Texture for preview window
+		mRenderTexture = Root::getSingleton().getRenderSystem()->createRenderTexture( "InventoryItemRttTex", 128, 128, TEX_TYPE_2D, PF_R8G8B8 );
+        {
+			
+			/*Ogre::Camera* itemRenderCam = tempManager->createCamera("InventoryItemRenderCamera");
+			
+            SceneNode* itemCamNode = 
+				tempManager->getRootSceneNode()->createChildSceneNode(Ogre::Vector3(0,-1000,0));
+			
+			itemCamNode->attachObject(itemRenderCam);
+			itemRenderCam->pitch(Ogre::Radian(90));
+
+            mRenderViewport = mRenderTexture->addViewport( itemRenderCam );
+            mRenderTexture->setAutoUpdated(false);
+			mRenderViewport->setOverlaysEnabled(false);
+            mRenderViewport->setClearEveryFrame( true );
+			//mRenderViewport->setClearEveryFrame(false);
+            mRenderViewport->setBackgroundColour( ColourValue::Black );
+			*/
+			
+			//loadCamera();
+
+            
+			
+			
+        }
+
+        // Retrieve CEGUI texture for the RTT
+		mTexture = UiSubsystem::getSingleton().getGUIRenderer()->createTexture((CEGUI::utf8*)"InventoryItemRttTex");
+
+        mImageSet = CEGUI::ImagesetManager::getSingleton().createImageset(
+                    (CEGUI::utf8*)"InventoryItemRttImageset", mTexture);
+
+        mImageSet->defineImage((CEGUI::utf8*)"InventoryItemRttImage", 
+                CEGUI::Point(0.0f, 0.0f),
+                CEGUI::Size(mTexture->getWidth(), mTexture->getHeight()),
+                CEGUI::Point(0.0f,0.0f));
+	}
+
+	void InventoryWindow::renderItem(Item* item)
+	{
+		SceneManager* tempManager = CoreSubsystem::getSingleton().
+					getWorld()->getSceneManager();
+
+		// Fr einen Aufh?geknoten Sorgen
+		if (mInventoryItemNode == NULL){
+			mInventoryItemNode = tempManager->getRootSceneNode()->createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
+			//mInventoryItemNode->setPosition(0,-100,-0.2);
+		}
+		
+		if (mRenderItemEntity) {
+			// Vom Knoten entfernen
+			mInventoryItemNode->detachAllObjects();
+			// alte Entity entfernen
+			tempManager->destroyEntity(mRenderItemEntity);
+			mRenderItemEntity = NULL;
+		}
+		if (item->getActor())
+		{
+			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k?nte
+			unloadCamera();
+			loadCamera();
+
+			// Item setzen und Schnappschuss machen
+			mRenderItemEntity = tempManager->createEntity("inventoryRenderedItem",
+                (static_cast<MeshObject*>(item->getActor()->getControlledObject()))->getMeshName());
+			mInventoryItemNode->attachObject(mRenderItemEntity);
+		
+			// Das Item hat einen Actor
+			//mItemActor = ActorManager::getSingleton().createMeshActor("inventoryRenderedItem",
+            //  (static_cast<MeshObject*>(item->getActor()->getControlledObject()))->getMeshName());
+			//mItemActor->placeIntoScene(Ogre::Vector3(0,-101055.3,-0.2));
+            mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128)));
+			mItemRenderImage->setProperty("Image",
+                "set:" + mImageSet->getName() + " image:InventoryItemRttImage");
+			mRenderTexture->update();
+
+		}
+        else if (item->getImageName() != "")
+        {
+            mItemRenderImage->setProperty("Image",
+                "set:ModelThumbnails image:" + item->getImageName());
+
+			float div = item->getSize().first / float(item->getSize().second);
+
+			if (div < 1)
+			{
+				//schmales Item
+                mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128*div, 128)));
+			}
+			else
+			{
+				// breites oder quadratisches Item
+                mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128/div)));
+			}
+		}
+	}
+
+
+	void InventoryWindow::loadCamera()
+	{
+		mCameraActor = ActorManager::getSingleton().createCameraActor("InventoryItemRttCam");
+		mCameraActor->placeIntoScene(Ogre::Vector3(0,-999999,0));
+		mCameraActor->pitch(-90);
+		mCameraActor->getPhysicalThing()->freeze();
+
+		mRenderTexture->setAutoUpdated(false);
+        mRenderViewport = mRenderTexture->addViewport(
+            (static_cast<CameraObject*>(mCameraActor->getControlledObject()))->getCamera());
+        mRenderViewport->setOverlaysEnabled(false);
+        mRenderViewport->setClearEveryFrame(true);
+        mRenderViewport->setBackgroundColour( ColourValue::Black );
+	}
+
+	void InventoryWindow::unloadCamera()
+	{
+		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst?t werden
+		if (mRenderViewport)
+		{
+			mRenderTexture->removeViewport(0);
+			ActorManager::getSingleton().destroyActor(mCameraActor);
+		}
+	}
+
+	/*!
+	*		?erprft, ob das Item von dem Slot akzeptiert wird
+	*/
+	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
+	{
+		if (window->getUserString("ItemType").compare(draggedItem->getUserString("ItemType")) == 0)
+		{
+			return true;
+		} 
+		else 
+		{
+			return false;
+		}
+	}
+
+	/**
+	* Berechnet aus relativen und Absoluten Mousekoordinaten die neue Position im Container
+	*/
+	std::pair<int,int> InventoryWindow::calculateNewPosition(const DragDropEventArgs& ddea)
+	{
+		// Errechnung der Koordinaten, in welchem K?tchen denn nun gedroppt wird
+		Point absMouse = MouseCursor::getSingleton().getPosition();
+        Point scrnPt = ddea.window->getPixelRect().getPosition();
+		Point relMouse = absMouse - ddea.dragDropItem->getPixelRect().getPosition();
+
+		//Bug in CeGUI (1. rel Mouse koordinate spinnt
+		if (relMouse.d_x < 0) {
+			relMouse.d_x = 15;
+		}
+
+		LOG_MESSAGE(
+			"InventoryWindow",
+			Ogre::String("relMouse: Point x:")
+			+ StringConverter::toString(relMouse.d_x)
+			+ ", Point y:"
+			+ StringConverter::toString(relMouse.d_y));
+
+		Point pointInBackpack = absMouse-scrnPt;
+		pointInBackpack -= relMouse;
+
+		// Position des n?hsten K?tchens bestimmen		
+		if (pointInBackpack.d_x < 0)
+        {
+			pointInBackpack.d_x = 0;
+		}
+		if (pointInBackpack.d_y < 0)
+        {
+			pointInBackpack.d_y = 0;
+		}
+
+		if (pointInBackpack.d_x > 16)
+        {
+			pointInBackpack.d_x = (int(pointInBackpack.d_x) + 14) -
+                ((int(pointInBackpack.d_x) + 14) % 30);
+		}
+        else
+        {
+			pointInBackpack.d_x = 0;
+		}
+
+		if (pointInBackpack.d_y > 16)
+        {
+			pointInBackpack.d_y = (int(pointInBackpack.d_y) + 14 ) -
+                ((int(pointInBackpack.d_y) + 14) % 30);
+		}
+        else
+        {
+			pointInBackpack.d_y = 0;
+		}
+
+		int xKaestchen = (int) (pointInBackpack.d_x / 30);
+		int yKaestchen = (int) (pointInBackpack.d_y / 30);
+
+		std::pair<int,int> result = std::make_pair<int,int>(xKaestchen, yKaestchen);
+		return result;
+	}
+
+
+	/*!
+	* Behandlung fr Mouse-over mit Item in der Maus
+	* ?erprft, ob das Item passt, und f?bt dementsprechend den Beh?ter ein
+	*/
+	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs& args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
+		
+		if (ddea.window->getUserData()){
+			// Es handelt sich um einen Container
+			Item* container = static_cast<Item*>(ddea.window->getUserData());
+			if (container == getGroundItem())
+			{
+				// Boden (nimmt alles)
+				ddea.window->setProperty("ContainerColour", mColorAccept);
+				return true;
+			} 
+			else if (container && container->getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				// Ein Container kann keinen Rucksack aufnehmen
+				if (!(ddea.dragDropItem->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
+				{
+					ddea.window->setProperty("ContainerColour", mColorReject);
+					return false;
+				}
+				else 
+				{
+					ddea.window->setProperty("ContainerColour", mColorAccept);
+					return true;
+				}
+			}
+			else {
+				// Beliebiger anderer Container am K?per
+				// TODO: Beschr?kung auf Itemtypen... 
+
+				ddea.window->setProperty("ContainerColour", mColorAccept);
+				return true;
+			}
+		}
+		else if (checkTypeAccepted(ddea.window, ddea.dragDropItem))
+		{
+			ddea.window->setProperty("ContainerColour", mColorAccept);
+			return true;
+		}
+		else
+		{
+			ddea.window->setProperty("ContainerColour", mColorReject);
+			return false;
+		}
+	}
+
+	bool InventoryWindow::handleDragLeave(const CEGUI::EventArgs& args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
+		ddea.window->setProperty("ContainerColour", mColorNormal);
+		return true;
+	}
+
+	bool InventoryWindow::handleDragDropped(const CEGUI::EventArgs& args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
+		// Farbe zurcksetzen
+		ddea.window->setProperty("ContainerColour", mColorNormal);
+
+
+		if (ddea.window->getUserData()){
+			// Es handelt sich um einen Container
+			Item* container = static_cast<Item*>(ddea.window->getUserData());
+			if (container == mGroundItem)
+			{
+				// Boden (nimmt alles)
+			} 
+			else if (container->getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				// Rucksack (nimmt alles au?r dem Rucksack selbst)
+				if (!(ddea.dragDropItem->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
+				{
+					return false;
+				}
+			}
+			else {
+				// Beliebiger anderer Container am K?per
+				// TODO: Beschr?kung auf Itemtypen... 
+			}
+
+			std::pair<int,int> newPos = calculateNewPosition(ddea);
+
+			if (isFreeInContainer(
+				static_cast<Item*>(ddea.dragDropItem->getUserData()),
+				newPos, static_cast<Container*>(ddea.window->getUserData())))
+			{
+				ddea.window->addChildWindow(ddea.dragDropItem);
+
+				mPosDraggedTo=CEGUI::Point(newPos.first*30,newPos.second*30);
+				mDroppedItem = ddea.dragDropItem;
+				mContainerDraggedTo = ddea.window;
+
+				updateInventory();
+				return true;
+			}
+			else 
+			{
+				return false;
+			}
+
+
+		} else {
+			// Es handelt sich um einen Slot am K?per
+			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
+				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k?nen
+
+				if (ddea.window->getChildCount() > 0)
+				{
+					// Slot hat schon einen anderen Gegenstand getragen
+					mOldItemInSlot = static_cast<CEGUI::DragContainer*>(ddea.window->getChildAtIdx(0));
+					ddea.window->removeChildWindow(mOldItemInSlot);
+				}
+				else
+				{
+					mOldItemInSlot = NULL;
+				}
+
+				ddea.window->addChildWindow(ddea.dragDropItem);
+
+				// Waffe und Schild sollen mittig positioniert werden
+				if ((!ddea.window->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_WEAPON)) ||
+					(!ddea.window->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_SHIELD)))) &&
+					(ddea.dragDropItem->getUserData()))
+				{
+					Item* item = static_cast<Item*>(ddea.dragDropItem->getUserData());
+					mPosDraggedTo= CEGUI::Point(30-(item->getSize().first * 15),75-(item->getSize().second *15));
+				}
+				// Rest kommt in die linke obere Ecke (weil ausfllend)
+				else {
+					mPosDraggedTo=CEGUI::Point(0.0,0.0);
+				}
+				mDroppedItem = ddea.dragDropItem;
+				mContainerDraggedTo = ddea.window;
+
+				updateInventory();
+				return true;
+			} else {
+				// Item passt nicht zum Slot
+				return false;
+			}
+		}
+	}
+}

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -18,9 +18,11 @@
 
 #include "RulesPrerequisites.h"
 
-#include "GameObject.h"
+#include "Date.h"
 #include "Effect.h"
+#include "Effect.h"
 #include "Eigenschaft.h"
+#include "GameObject.h"
 #include "ZauberStateSet.h"
 #include "SonderfertigkeitenStateSet.h"
 
@@ -107,7 +109,8 @@
 
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_BEHAVIOURS;
-
+        static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+        
             Creature(unsigned int id);
 
             /// Der Standarddestruktor.
@@ -501,8 +504,8 @@
              **/
             Inventory* getInventory() const;
 
+        const Ogre::String& getInventoryWindowType() const;
 
-
 ///////////////////////////////////////////////////////////////////////////////
 // Aktionen
             /**
@@ -857,9 +860,9 @@
             SonderfertigkeitMap mSonderfertigkeiten;
             WertMap mWerte;
             Ap mAp;
-
             /// Zeigt auf das Inventar der Kreatur.
             Inventory* mInventory;
+        Ogre::String mInventoryWindowType;
 
             Property mBehaviours;
 

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -41,6 +41,11 @@
 	**/
 	typedef std::list<Item*> ItemList;
 
+    /**
+     * @brief A map of slot names to slots
+     */
+    typedef std::map<CeGuiString, Slot*> SlotMap;
+
 	Inventory(Creature* owner);
 	virtual ~Inventory();
 
@@ -79,10 +84,9 @@
 
     Item* getItem(const CeGuiString& slotName) const;
     void addSlot(const CeGuiString& name, const Ogre::String& bone, int itemMask);
+    const SlotMap& getAllSlots() const;
 
 private:
-    typedef std::map<CeGuiString, Slot*> SlotMap;
-
 	bool mValuesUpToDate;
 	int mCurrentWeight;
 	int mCurrentBeByWeight;

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Item.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -61,9 +61,7 @@
 		Item(unsigned int id);
         virtual ~Item(void);
 
-		const CeGuiString getDescription() const;
-
-        void setWeight(Ogre::Real weight);
+	    void setWeight(Ogre::Real weight);
         Ogre::Real getWeight() const;
 
 		void setItemType(ItemType itemType);
@@ -79,7 +77,7 @@
 
 		/**
 		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden k?nen
+		 * in dem andere gespeichert werden koennen
 		 */
         virtual bool isContainer() const;
 		

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -255,7 +255,7 @@
         }
         else if (key == Container::PROPERTY_VOLUME)
         {
-            return Property(mVolume);
+            return Property(make_pair((int)mVolume.first, (int)mVolume.second));
         }
         else
         {
@@ -267,7 +267,7 @@
     {
         PropertySet* ps = Item::getAllProperties();
         ps->setProperty(Container::PROPERTY_CAPACITY, Property(mCapacity));
-        ps->setProperty(Container::PROPERTY_VOLUME, Property(mVolume));
+        ps->setProperty(Container::PROPERTY_VOLUME, Property(make_pair((int)mVolume.first, (int)mVolume.second)));
 
         return ps;
     }

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -39,6 +39,8 @@
     const Ogre::String Creature::CLASS_NAME = "Creature";
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
 
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype"; 
+
     Creature::Creature(unsigned int id)
         : GameObject(id), 
 		mCurrentLe(0),
@@ -82,6 +84,8 @@
 		mEigenschaften[E_KONSTITUTION] = 0;
 		mEigenschaften[E_KOERPERKRAFT] = 0;
 
+        mEffectManager = new EffectManager();
+
 		mInventory = new Inventory(this);
     }
 
@@ -704,6 +708,11 @@
 	{
 		return mInventory;
 	}
+
+    const Ogre::String& Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
 	
 	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
 	{
@@ -952,6 +961,10 @@
         {
             mBehaviours = value;
         }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
         else
         {
             GameObject::setProperty(key, value);
@@ -964,10 +977,10 @@
         {
             return mBehaviours;
         }
-        //else if (key == Item::PROPERTY_SIZE)
-        //{
-        //    return Property(mSize);
-        //}
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
         else
         {
             return GameObject::getProperty(key);
@@ -978,6 +991,7 @@
     {
         PropertySet* ps = GameObject::getAllProperties();
         ps->setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
+        ps->setProperty(Creature::PROPERTY_INVENTORY_WINDOW_TYPE, Property(mInventoryWindowType));
 
         return ps;
     }
@@ -1489,4 +1503,5 @@
     }
 
 
+
 }

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -196,4 +196,8 @@
         mSlots[name] = new Slot(mOwner, name, bone, itemMask);
     }
 
+    const Inventory::SlotMap& Inventory::getAllSlots() const
+    {
+        return mSlots;
+    }
 }

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -124,24 +124,23 @@
 		return CeGuiString("undefined");
 	}
 
-	const CeGuiString Item::getDescription() const
-	{
-		CeGuiString desc = mName + "\r\n\r\n" + 
-			getFormattedText(mDescription)+
-			"\r\n\r\n"+
-			"Gewicht: ";
-		if (mWeight >= 40)
-		{
-			desc += Ogre::StringConverter::toString(mWeight / 40)+ " Stein";
-		}
-		else
-		{
-			desc += Ogre::StringConverter::toString(mWeight)+ " Unzen";
-		}
-		return desc;
+	//const CeGuiString Item::getDescription() const
+	//{
+	//	CeGuiString desc = mName + "\r\n\r\n" + 
+	//		getFormattedText(mDescription)+
+	//		"\r\n\r\n"+
+	//		"Gewicht: ";
+	//	if (mWeight >= 40)
+	//	{
+	//		desc += Ogre::StringConverter::toString(mWeight / 40)+ " Stein";
+	//	}
+	//	else
+	//	{
+	//		desc += Ogre::StringConverter::toString(mWeight)+ " Unzen";
+	//	}
+	//	return desc;
+	//}
 
-	}
-
     void Item::setWeight(Ogre::Real weight)
     {
         mWeight = weight;

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -24,252 +24,34 @@
 
 namespace rl {
 
-	class Creature;
-    class Item;
+    class Inventory;
 
-	class _RlUiExport InventoryArrangeTask : public GameTask
-	{
-	public:
-		InventoryArrangeTask();
-		~InventoryArrangeTask();
-		
-		void run(Ogre::Real elapsedTime);
+	//class _RlUiExport InventoryArrangeTask : public GameTask
+	//{
+	//public:
+	//	InventoryArrangeTask();
+	//	~InventoryArrangeTask();
+	//	
+	//	void run(Ogre::Real elapsedTime);
 
-        virtual const Ogre::String& getName() const;
-	};
+ //       virtual const Ogre::String& getName() const;
+	//};
 
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
-		InventoryWindow();
+		InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory);
 		~InventoryWindow();
 
-		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
-		CEGUI::DragContainer* mDroppedItem;
+    private:
+        Inventory* mInventory;
+        std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
 
-		/**
-		* Gibt dem Fenster das anzuzeigende Inventar
-		*/
-		void setInventory(Inventory* inventory);
+        CEGUI::Window* mContainerTabs;
 
-		/**
-		* Methode fr das OnMouseOver Event
-		*/
-		bool handleMouseEnters(const CEGUI::EventArgs &args);
-		
-		/**
-		* Methode fr das OnMouseLeaves Event
-		*/
-		bool handleMouseLeaves(const CEGUI::EventArgs &args);
-
-		/**
-		* Methode fr das OnMouseClick Event
-		*/
-		bool handleMouseClicked(const CEGUI::EventArgs &args);
-
-		/**
-		* 
-		*/
-		void update();
-
-		/**
-		* ?ergibt ?derungen ans Inventar
-		*/
-		void updateInventory();
-
-		/**
-		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
-		* dafr ne externe Methode
-		*/
-		void updateItemPosition();
-
-		// FIXME, wenn BUG im CEGUI behoben ist: entfernen
-
-		/**
-		* Schaut nach, ob das Item an der Position gedroppt werden kann.
-		*/
-		bool isFreeInContainer(Item* item, std::pair<int,int> kaestechenPos, Container* container);
-
-
-		Item* getGroundItem();
-
-	private:
-		Inventory* mInventory;
-
-		// Farbschema fr die Fenster und Itemhintergrnde
-		const CeGuiString mColorAccept;
-		const CeGuiString mColorReject;
-		const CeGuiString mColorNormal;
-		const CeGuiString mColorItemNormal;
-		const CeGuiString mColorItemSelected;
-
-		// TODO : Ersetze durch etwas dynamisches
-		Item* mGroundItem;
-
-		// Der Knoten an dem das zu redernde Item angebracht wird;
-		Ogre::SceneNode* mInventoryItemNode;
-		// Entity des jeweils zu rendernden Items
-		Ogre::Entity* mRenderItemEntity;
-		// 128*128 Textur fr das Item-view Fenster
-		Ogre::RenderTexture* mRenderTexture;
-		// Viewport des RenderToTexture Features
-		Ogre::Viewport* mRenderViewport;
-		// Die Camera, die das Item filmt
-		Actor* mCameraActor;
-
-		CEGUI::Texture* mTexture;
-		CEGUI::Imageset* mImageSet;
-
-        InventoryArrangeTask* mInventoryArrangeTask;
-
-		// Das Item-Renderfenster
-		CEGUI::Window* mItemRenderImage;
-
-
-		// Das Rstungs- und Behinderungswert Fenster
-		CEGUI::Window* mArmorValueWindow;
-		CEGUI::Window* mArmorValue;
-		CEGUI::Window* mHandicapValue;
-
-		// Das Gewichtsfenster
-		CEGUI::Window* mWeightWindow;
-		CEGUI::Window* mTotalWeight;
-		
-
-		// Das Item-Beschreibungsfenster
-		CEGUI::ScrollablePane* mDescription;
-
-		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew?lt ist
-		CEGUI::Window* mActiveItemWindow;
-
-		// Das Fenster, in das der Rucksackcontainer soll
-		CEGUI::TabControl* mContainerTabs;
-
-		// Die Containerslots (besonders, da alle Arten von Items akzeptiert)
-		std::list<CEGUI::Window*> mContainerContents;
-
-		std::list<CEGUI::Window*> mContainers;
-
-		CEGUI::Window* mGroundTab;
-		CEGUI::Window* mGroundContainer;
-
-		const std::pair<int,int> mGroundDimension;
-
-		// Alle verschiedenen Inventoryslots
-		CEGUI::Window* mRingLeft;
-		CEGUI::Window* mRingRight;
-		CEGUI::Window* mHandLeft;
-		CEGUI::Window* mHandRight;
-		CEGUI::Window* mGloves;
-		CEGUI::Window* mBraceletLeft;
-		CEGUI::Window* mBraceletRight;
-		CEGUI::Window* mArmor;
-		CEGUI::Window* mCape;
-		CEGUI::Window* mBracers;
-		CEGUI::Window* mBackpack;
-		CEGUI::Window* mBelt;
-		CEGUI::Window* mNecklace;
-		CEGUI::Window* mHelmet;
-		CEGUI::Window* mTrousers;
-		CEGUI::Window* mShinbone;
-		CEGUI::Window* mBoots;
-
-		CEGUI::Point mPosDraggedTo;
-		CEGUI::Window* mContainerDraggedTo;
-		CEGUI::DragContainer* mOldItemInSlot;
-        
-        CEGUI::DragContainer* createItem(Item* item, CEGUI::Window* parent, CEGUI::UVector2 position = CEGUI::UVector2(cegui_reldim(0.0f), cegui_reldim(0.0f)));
-
-		/**
-		* Schliesst das Fenster bei Klick auf X
-		*/
-		bool handleClose();
-
-		void initRenderToTexture();
-
-		/**
-		* L?t die Rtt-Camera
-		*/
-		void loadCamera();
-		void unloadCamera();
-
-		/**
-		* Rendert das Item in das Vorschaufenster im Inventar
-		*/
-		void renderItem(Item* item);
-
-		/**
-		* Initiiert die Slots des Inventars
-		*/
-		void initSlots();
-
-		/**
-		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
-		*/
-		void fillSlots();
-
-		/**
-		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
-		*/
-		void createAndFillContainer(Container* container);
-
-		/**
-		* entfernt ein ContainerTab mitsamt Inhalt aus dem Inventar
-		*/
-		void removeContainerAndContent(Container* container);
-
-		/**
-		* Entleert die Slots im InventarFenster wieder
-		*/
-		void emptySlots();
-
-
-		void refreshTabs();
-
-		/**
-		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh?t
-		*/
-		CEGUI::Window* findContainer(Container* container);
-
-		/**
-		*
-		* Entfernt alle Unterfenster
-		*/
-		void emptySlot(CEGUI::Window* slot);
-		/** 
-		* Gibt dem Slot die F?igkeit Dragcontainer zu akzeptieren
-		*/
-		void addDropListener(CEGUI::Window* slot);
-
-		/*!
-		* fgt dem Inventar den Container fr den Rucksack zu,
-		* gibt ihm die n?ige Funktionalit? fr drag&drop
-		*/
-		void initBackpack(std::pair<int,int> dim);
-
-
-		/**
-		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
-		* im Inventar
-		*/
-		void createContainerWindows();
-
-		/**
-		* ?erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
-		* @return true: Item wird akzeptiert
-		*         false: Item wird nicht akzeptiert
-		*/ 
-		bool checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem);
-
-
-		/**
-		* Errechnet die K?tchenposition, an der das Item im Container gedroppt wurde
-		*/
-		std::pair<int,int> calculateNewPosition(const CEGUI::DragDropEventArgs& ddea);
-
-		bool handleDragEnter(const CEGUI::EventArgs& args);
-		bool handleDragLeave(const CEGUI::EventArgs& args);
-		bool handleDragDropped(const CEGUI::EventArgs& args);
-	};
+        void createSlotWindows(Inventory* inventory);
+        void initInventoryWindow(Inventory* inventory);
+    };
 }
-#endif
+
+#endif //__InventoryWindow_H__

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -24,1278 +24,99 @@
 #include <elements/CEGUIFrameWindow.h>
 
 
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "Exception.h"
-#include "GameLoop.h"
-#include "Inventory.h"
-#include "MeshObject.h"
-#include "PhysicalThing.h"
-#include "RulesSubsystem.h"
-#include "UiSubsystem.h"
-#include "WindowFactory.h"
-#include "World.h"
-#include "CeGuiHelper.h"
-
-#include <CEGUIPropertyHelper.h>
-#include <OgreCEGUIRenderer.h>
-
 using namespace CEGUI;
-using namespace Ogre;
 using namespace std;
 
 namespace rl {
 
-	// @FIXME Wenn CeGUI Bug beseitigt hat:
-	InventoryArrangeTask::InventoryArrangeTask() : GameTask()
-	{
-	}
+    InventoryWindow::InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory)
+        : AbstractWindow(inventoryWindow, AbstractWindow::WND_MOUSE_INPUT)
+    {
+        mInventory = inventory;
 
-	InventoryArrangeTask::~InventoryArrangeTask()
-	{
-	}
+        mContainerTabs = getTabControl("InventoryWindow/Tabs");
+        //mSquareSize = ...;
 
-	void InventoryArrangeTask::run(Ogre::Real elapsedTime)
-	{
-		static InventoryWindow* invWin = WindowFactory::getSingletonPtr()->getInventoryWindow();
-		if (invWin->mDroppedItem)
-		{
-			LOG_MESSAGE("InventoryWindow", "Item placed");
-			invWin->updateItemPosition();
-		}
-	}
+        createSlotWindows(inventory);
+        initInventoryWindow(inventory);
+    }
 
-    const Ogre::String& InventoryArrangeTask::getName() const
+    InventoryWindow::~InventoryWindow()
     {
-        static Ogre::String NAME = "InventoryArrangeTask";
-
-        return NAME;
     }
 
+    void InventoryWindow::createSlotWindows(Inventory* inventory)
+    {
+        std::map<CeGuiString, Window*> slotsInWindowDefinition;
 
-	// ***************************************************************
-	// ***************** Konstruktor *********************************
-	// ***************************************************************
-	InventoryWindow::InventoryWindow()
-		: AbstractWindow("inventorywindow.xml", WND_MOUSE_INPUT),
-		mDescription(NULL),
-		mRenderItemEntity(NULL),
-		mRenderTexture(NULL),
-		mRenderViewport(NULL),
-		mItemRenderImage(NULL),
-		mCameraActor(NULL),
-		mInventoryItemNode(NULL),
-		mTexture(NULL),
-		mImageSet(NULL),
-		mActiveItemWindow(NULL),
-		mArmorValueWindow(NULL),
-		mArmorValue(NULL),
-		mHandicapValue(NULL),
-		mWeightWindow(NULL),
-		mTotalWeight(NULL),
-		mPosDraggedTo(),
-		mContainerDraggedTo(NULL),
-		mDroppedItem(NULL),
-		mOldItemInSlot(NULL),
-		mContainerTabs(NULL),
-		mContainerContents(NULL),
-		mGroundTab(NULL),
-		mGroundItem(NULL),
-		mGroundContainer(NULL),
-		mColorAccept("FF22FF22"),
-		mColorReject("FFFF2222"),
-		mColorNormal("FFFFFFFF"),
-		mColorItemNormal("FF999955"),
-		mColorItemSelected("FFDDDD99"),
-		mRingLeft(NULL),
-		mRingRight(NULL),
-		mHandLeft(NULL),
-		mHandRight(NULL),
-		mGloves(NULL),
-		mBraceletLeft(NULL),
-		mBraceletRight(NULL),
-		mArmor(NULL),
-		mCape(NULL),
-		mBracers(NULL),
-		mBackpack(NULL),
-		mBelt(NULL),
-		mNecklace(NULL),
-		mHelmet(NULL),
-		mTrousers(NULL),
-		mShinbone(NULL),
-		mBoots(NULL),
-        mInventoryArrangeTask(),
-		mGroundDimension(make_pair<int,int>(12,15))
-	{
-		initSlots();
-		initRenderToTexture();
+        Window* containers = getWindow("InventoryWindow/Slots");
 
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&InventoryWindow::handleClose, this));
-
-        mInventoryArrangeTask = new InventoryArrangeTask();
-        GameLoop::getSingletonPtr()->addTask(mInventoryArrangeTask, GameLoop::TG_GRAPHICS);
-	}
-	
-	InventoryWindow::~InventoryWindow()
-	{
-		/*if(mBackpackContent){
-			mBackpackContent->destroy();
-		}*/
-        delete mInventoryArrangeTask;
-//        delete mGroundItem;
-	}
-
-
-	/** Methoden */
-
-	void InventoryWindow::setInventory(Inventory* inventory)
-	{
-		if (inventory != NULL && mInventory != inventory){
-			// Entleere Slots zur Sicherheit (falls anderes Inventar zuvor gezeigt wurde)
-			emptySlots();
-			// Speichere das neue Inventar
-			mInventory = inventory;
-			// Fuelle das Fenster entsprechend dem neuen Inventar, das angezeigt werden soll
-			fillSlots();
-			update();
-		}
-	}
-
-	bool InventoryWindow::handleClose()
-	{
-		if (isVisible())
-		{
-			setVisible(false);
-		}
-		return true;
-	}
-
-	void InventoryWindow::update()
-	{
-		// Aktualisiere Werte
-
-		// Rstung
-		mArmorValue->setText(Ogre::StringConverter::toString(mInventory->getOverallRs()));
-
-		// Behinderung
-		pair<int,int> behinderung = mInventory->getOverallBe();
-		mHandicapValue->setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
-		if (behinderung.second > 0)
-		{
-			mArmorValueWindow->setTooltipText("Rstung / Behinderung\r\n           / +"+Ogre::StringConverter::toString(behinderung.second)+" berladen");
-		} 
-		else
-		{
-			mArmorValueWindow->setTooltipText("Rstung / Behinderung");
-		}
-
-		// Gewicht in Unzen
-		int weight = mInventory->getOverallWeight() / 40;
-		// TODO: runden
-		mTotalWeight->setText(Ogre::StringConverter::toString(weight));
-	}
-
-	void InventoryWindow::updateItemPosition(){
-		
-		// Positionieren
-        mDroppedItem->setPosition(CeGuiHelper::asAbsolute(mPosDraggedTo));
-		mDroppedItem = NULL;
-
-		// Loggen
-		LOG_MESSAGE(
-			"InventoryWindow",
-			Ogre::String("Position set to: Point x:")
-			+ StringConverter::toString(mPosDraggedTo.d_x)
-			+ ", Point y:"
-			+ StringConverter::toString(mPosDraggedTo.d_y));
-
-		LOG_MESSAGE("InventoryWindow", "updateItemPosition finished");
-	}
-
-	void InventoryWindow::updateInventory(){
-		// Nach Drop
-		Item* item = static_cast<Item*>(mDroppedItem->getUserData());
-
-		// Gegenstand von alter Position entfernen
-		//mInventory->removeItem(item);
-
-		// Gegenstand vom Boden entfernen
-		//mInventory->removeItemFromContainer(item, mGroundItem);
-
-		// Welchem Item wird das Item hinzugefgt? -> speichere das in die Variable container
-		Item* container = static_cast<Item*>(mContainerDraggedTo->getUserData());
-
-		// Extra Behandlung, falls Item auf den Boden gelegt wird
-		if (container == mGroundItem)
-		{
-			//mInventory->setItemContainerPosition(
-			//	item,
-			//	(int)(mPosDraggedTo.d_x/30), 
-			//	(int)(mPosDraggedTo.d_y/30),
-			//	container);
-
-			// Zus?zlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
-			if (item->isContainer())
-			{
-				removeContainerAndContent(dynamic_cast<Container*>(item));
-				refreshTabs();
-			}
-			update();
-			return;
-		} 
-				
-		// Item im Container platzieren
-		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
-
-		while (it != mContainerContents.end())
-		{
-			if (mContainerDraggedTo == *it++){
-				//mInventory->setItemContainerPosition(
-				//	item,
-				//	(int)(mPosDraggedTo.d_x/30), 
-				//	(int)(mPosDraggedTo.d_y/30),
-				//	container);
-				break;
-			}
-		}
-
-		if (item->isContainer())
-		{
-			// ContainerTab hinzufgen, wenn nicht schon vorhanden
-			createAndFillContainer(dynamic_cast<Container*>(item));
-			refreshTabs();
-
-		}
-		
-
-		bool itemSwitched = false;
-		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
-		//if (mContainerDraggedTo == mArmor){
-		//	if (mInventory->getArmor() != NULL){
-		//		//Pack die alte Rstung ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeArmor(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setArmor(item);
-		//}
-		//if (mContainerDraggedTo == mCape){
-		//	if (mInventory->getCape() != NULL){
-		//		//Pack die alte Rstung ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeCape(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setCape(item);
-		//}
-		//if (mContainerDraggedTo == mBackpack) {
-		//	if (mInventory->getBackpack() != NULL){
-		//		//Pack den alten Rucksack auf den Boden
-		//		mInventory->addItemToContainer(mInventory->removeBackpack(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBackpack(item);
-		//}
-		//if (mContainerDraggedTo == mBelt) {
-		//	if (mInventory->getBelt() != NULL){
-		//		//Pack den alten Grtel ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeBelt(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBelt(item);
-		//}
-		//if (mContainerDraggedTo == mBoots) {
-		//	if (mInventory->getBoots() != NULL){
-		//		//pack die alten Stiefel ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeBoots(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBoots(item);
-		//}
-		//if (mContainerDraggedTo == mBraceletLeft) {
-		//	if (mInventory->getBraceletLeft() != NULL){
-		//		//pack den alten Armreif ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeBraceletLeft(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBraceletLeft(item);
-		//}
-		//if (mContainerDraggedTo == mBraceletRight) {
-		//	if (mInventory->getBraceletRight() != NULL){
-		//		//pack den alten Armreif ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeBraceletRight(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBraceletRight(item);
-		//}
-		//if (mContainerDraggedTo == mRingLeft) {
-		//	if (mInventory->getRingLeft() != NULL){
-		//		//pack den alten Ring ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeRingLeft(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setRingLeft(item);
-		//}
-		//if (mContainerDraggedTo == mRingRight) {
-		//	if (mInventory->getRingRight() != NULL){
-		//		//pack den alten Ring ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeRingRight(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setRingRight(item);
-		//}
-		//if (mContainerDraggedTo == mHelmet) {
-		//	if (mInventory->getHelmet() != NULL){
-		//		//pack den alten Helm ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeHelmet(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setHelmet(item);
-		//}
-		//if (mContainerDraggedTo == mBracers) {
-		//	if (mInventory->getBracers() != NULL){
-		//		//pack die alte Armschienen ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeBracers(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setBracers(item);
-		//}
-		//if (mContainerDraggedTo == mNecklace) {
-		//	if (mInventory->getNecklace() != NULL){
-		//		//pack das alte Amulett ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeNecklace(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setNecklace(item);
-		//}
-		//if (mContainerDraggedTo == mGloves) {
-		//	if (mInventory->getGloves() != NULL){
-		//		//pack die alten Handschuhe ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeGloves(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setGloves(item);
-		//}
-		//if (mContainerDraggedTo == mTrousers) {
-		//	if (mInventory->getTrousers() != NULL){
-		//		//pack die alte Hose ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeTrousers(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setTrousers(item);
-		//}
-		//if (mContainerDraggedTo == mShinbone) {
-		//	if (mInventory->getShinbone() != NULL){
-		//		//pack die alte Hose ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeShinbone(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setShinbone(item);
-		//}
-		//if (mContainerDraggedTo == mHandLeft) {
-		//	if (mInventory->getHandLeft() != NULL){
-		//		//pack das alte Schild ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeHandLeft(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setHandLeft(item);
-		//}
-		//if (mContainerDraggedTo == mHandRight) {
-		//	if (mInventory->getHandRight() != NULL){
-		//		//pack die alte Waffe ins Inventar
-		//		mInventory->addItemToContainer(mInventory->removeHandRight(), mInventory->getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory->setHandRight(item);
-		//}
-		if (itemSwitched)
-		{
-			try {
-				//Bild muss im Inventarfenster an die neue Position gelegt werden
-				//pair<pair<int,int>,Item*> posInContainer = mInventory->getItemPositionInContainer(static_cast<Item*>(mOldItemInSlot->getUserData()));
-
-				//// Container Fenster suchen
-				//CEGUI::Window* win = findContainer(posInContainer.second);
-				//// Dem Fenster hinzufgen
-				//win->addChildWindow(mOldItemInSlot);
-				//// Positionieren		
-				//mOldItemInSlot->setPosition( CEGUI::Absolute,
-				//	CEGUI::Point(posInContainer.first.first * 30, posInContainer.first.second * 30));
-
-			}
-			catch (IllegalArgumentException iae)
-			{
-				// TODO: Item am Boden suchen
-			}
-		}
-
-
-		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
-		update();
-	}
-
-
-	void InventoryWindow::refreshTabs()
-	{
-		std::list<CEGUI::Window*>::iterator it = mContainers.begin();
-
-		// entferne alle Unterfenster
-		while(mContainerTabs->getTabCount() > 0)
-		{
-			mContainerTabs->removeTab(mContainerTabs->getTabContents(0)->getName());
-		}
-
-		// fge sie in richtiger Reihenfolge wieder hinzu
-		while (it != mContainers.end())
-		{
-			mContainerTabs->addTab(*it++);
-		}
-	}
-
-	bool InventoryWindow::isFreeInContainer(Item* item, pair<int,int> kaestchenPos, Container* container)
-	{
-        return container->canPlaceAt(item, kaestchenPos.first, kaestchenPos.second);
-		//return mInventory->isFreeInContainer(item, kaestchenPos, container);
-        //return true;
-	}
-
-
-	Item* InventoryWindow::getGroundItem()
-	{
-		return mGroundItem;
-	}
-
-	void InventoryWindow::initSlots()
-	{
-		mArmorValueWindow = getWindow("InventoryWindow/ArmorValueWindow");
-        mArmorValueWindow->setProperty("Image", "set:InventorySymbols image:Shield");
-		mArmorValueWindow->setTooltipText("Rstung / Behinderung");
-		//TODO: An Tooltip anh?gen: woraus setzt sich die Rstung zusammen?
-		mArmorValue = getWindow("InventoryWindow/ArmorValue");
-		mArmorValue->setText(" 3");
-		//mArmorValue->setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
-		mArmorValue->disable();
-		mHandicapValue = getWindow("InventoryWindow/HandicapValue");
-		mHandicapValue->setText("2");
-		//mHandicapValue->setTextColours(CEGUI::colour(0.4,0.0,0.0)); //TODO port to cegui0.5
-		mHandicapValue->disable();
-
-		mWeightWindow = getWindow("InventoryWindow/WeightWindow");
-        mWeightWindow->setProperty("Image", "set:InventorySymbols image:Weight");
-		mWeightWindow->setTooltipText("Getragenes Gewicht\r\nin Stein");
-
-		mTotalWeight = getWindow("InventoryWindow/TotalWeight");
-		mTotalWeight->setText("");
-		// Schwarzer Text (wird rot, wenn berladen)
-		//mTotalWeight->setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
-		mTotalWeight->disable();
-				
-
-		// Das Item-Beschreibungsfeld holen
-		mDescription = getScrollablePane("InventoryWindow/Description");
-
-		// Das "BodenItem" initiieren
-		mGroundItem = new Item(1/*"Boden", "Dieses Item repr?entiert den Boden"*/);
-		mGroundItem->setImageName("Trank");
-		mGroundItem->setItemType(Item::ITEMTYPE_OTHER);
-		mGroundItem->setSize(1,1);
-		//mGroundItem->setContainer(true, std::make_pair<int,int>(mGroundDimension.first,mGroundDimension.second));
-
-
-		mContainerTabs = getTabControl("InventoryWindow/Tabs");
-		
-		// Hole die einzelnen Slots aus dem XML-File
-		mHelmet = getWindow("InventoryWindow/Helmet");
-		mHelmet->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_HELMET));
-		
-		mRingLeft = getWindow("InventoryWindow/RingLeft");
-		mRingLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_RING));
-		
-		mRingRight = getWindow("InventoryWindow/RingRight");
-		mRingRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_RING));
-		
-		mHandLeft = getWindow("InventoryWindow/HandLeft");
-		mHandLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_SHIELD));
-
-		mHandRight = getWindow("InventoryWindow/HandRight");
-		mHandRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_WEAPON));
-
-		mGloves = getWindow("InventoryWindow/Gloves");
-		mGloves->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_GLOVES));
-
-		mBraceletLeft = getWindow("InventoryWindow/BraceletLeft");
-		mBraceletLeft->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
-
-		mBraceletRight = getWindow("InventoryWindow/BraceletRight");
-		mBraceletRight->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
-
-		mArmor = getWindow("InventoryWindow/Armor");
-		mArmor->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_ARMOR));
-
-		mCape = getWindow("InventoryWindow/Cape");
-		mCape->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_CAPE));
-
-		mBracers = getWindow("InventoryWindow/Bracers");
-		mBracers->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BRACERS));
-
-		mBackpack = getWindow("InventoryWindow/Backpack");
-		mBackpack->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BACKPACK));
-
-		mBelt = getWindow("InventoryWindow/Belt");
-		mBelt->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BELT));
-
-		mNecklace = getWindow("InventoryWindow/Necklace");
-		mNecklace->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_NECKLACE));
-
-		mTrousers = getWindow("InventoryWindow/Trousers");
-		mTrousers->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_TROUSERS));
-
-		mShinbone = getWindow("InventoryWindow/Shinbone");
-		mShinbone->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_SHINBONE));
-
-		mBoots = getWindow("InventoryWindow/Boots");
-		mBoots->setUserString("ItemType",Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
-
-		// gib ihnen die Funktionalit? Items aufzunehmen
-		addDropListener(mHelmet);
-		addDropListener(mRingLeft);
-		addDropListener(mRingRight);
-		addDropListener(mHandLeft);
-		addDropListener(mHandRight);
-		addDropListener(mGloves);
-		addDropListener(mBraceletLeft);
-		addDropListener(mBraceletRight);
-		addDropListener(mArmor);
-		addDropListener(mCape);
-		addDropListener(mBracers);
-		addDropListener(mBackpack);
-		addDropListener(mBelt);
-		addDropListener(mNecklace);
-		addDropListener(mTrousers);
-		addDropListener(mShinbone);
-		addDropListener(mBoots);
-	}
-
-	void InventoryWindow::fillSlots()
-	{
-		//createItem(mInventory->getRingLeft(), mRingLeft);
-		//createItem(mInventory->getRingRight(), mRingRight);
-		//createItem(mInventory->getHandLeft(), mHandLeft);
-		//createItem(mInventory->getHandRight(), mHandRight);
-		//createItem(mInventory->getGloves(), mGloves);
-		//createItem(mInventory->getBraceletLeft(), mBraceletLeft);
-		//createItem(mInventory->getBraceletRight(), mBraceletRight);
-		//createItem(mInventory->getArmor(), mArmor);
-		//createItem(mInventory->getCape(), mCape);
-		//createItem(mInventory->getBracers(), mBracers);
-		//createItem(mInventory->getBackpack(), mBackpack);
-		//createItem(mInventory->getBelt(), mBelt);
-		//createItem(mInventory->getNecklace(), mNecklace);
-		//createItem(mInventory->getHelmet(), mHelmet);
-		//createItem(mInventory->getTrousers(), mTrousers);
-		//createItem(mInventory->getShinbone(), mShinbone);
-		//createItem(mInventory->getBoots(), mBoots);
-
-
-		// Fenster fr ContainerItems erstellen
-		createContainerWindows();
-	}
-
-
-	void InventoryWindow::createContainerWindows() {
-		
-
-		std::list<Item*> allItems = mInventory->getAllItems();
-
-		std::list<Item*>::iterator itemIterator = allItems.begin();
-		
-		while (itemIterator != allItems.end()){
-			Item* currentItem = *itemIterator++;
-
-			if (currentItem->isContainer()){
-				// Tab fr Item erzeugen, da es als Container funktioniert
-				createAndFillContainer(dynamic_cast<Container*>(currentItem));
-			}
-		}
-		// Den Boden hinzufuegen
-		//createAndFillContainer(mGroundItem);
-	}
-
-	void InventoryWindow::createAndFillContainer(Container* container){
-		assert(mContainerContents.size() == mContainers.size());
-
-		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
-		bool found = false;
-		// berprfe, ob schon vorhanden
-		while (it != mContainerContents.end())
-		{
-			if (container == static_cast<Item*>((*it)->getUserData()))
-			{
-				found = true;
-				break;
-			}
-			it++;
-		}
-		
-		// Nur wenn noch nicht vorhanden, soll Containertab erzeugt werden
-		if (!found)
-		{
-
-			// Erzeuge Tab im Inventar fr den Container
-			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow("DefaultGUISheet", "InventoryWindow/Tabs/"+container->getName());
-			// Name fr das Tab
-			containerWindow->setText(container->getName());
-
-
-			mContainerTabs->addTab(containerWindow);
-
-			CEGUI::Window* containerSpace = static_cast<CEGUI::Window*>(CEGUI::WindowManager::getSingletonPtr()->createWindow("RastullahLook/Container", "InventoryWindow/Tabs/"+container->getName()+"/Content"));
-			
-			containerSpace->setVerticalAlignment(CEGUI::VA_CENTRE);
-			containerSpace->setHorizontalAlignment(CEGUI::HA_CENTRE);
-            containerSpace->setSize(UVector2(cegui_absdim(container->getVolume().first*30),
-                cegui_absdim(container->getVolume().second*30)));
-			containerSpace->setUserData(container);
-			containerWindow->addChildWindow(containerSpace);
-
-
-			// Inhalt in die Liste Einfgen
-						// Boden an das Ende der Liste einfgen
-			if (container == mGroundItem)
-			{
-				mContainers.push_back(containerWindow);
-				mContainerContents.push_back(containerSpace);
-			}
-			// Rucksack vorne in die Liste einfuegen
-			else if (container->getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				mContainers.push_front(containerWindow);
-				mContainerContents.push_front(containerSpace);
-			}
-			// den Rest dazwischen
-			else 
-			{
-				if (mContainers.size() > 1)
-				{
-					mContainers.insert(++(mContainers.begin()),containerWindow);
-					mContainerContents.insert(++(mContainerContents.begin()),containerSpace);
-				} else {
-					mContainers.push_front(containerWindow);
-					mContainerContents.push_front(containerSpace);
-				}
-			}
-			
-
-			addDropListener(containerSpace);
-
-			// Items im Container erstellen
-			std::set<Item*> itemsInContainer;
-
-			//ContainerLayout temp = container->getContainerLayout();
-			//for (unsigned x = 0; x < temp.size(); x++){
-			//	for (unsigned y = 0; y < temp[0].size(); y++) {
-			//		if (temp[x][y] != NULL && (itemsInContainer.find(temp[x][y]) == itemsInContainer.end())){
-			//			DragContainer* itemhandler = createItem(temp[x][y],containerSpace);
-			//			itemhandler->setPosition(CEGUI::Absolute,CEGUI::Point(x*30,y*30));
-			//			itemsInContainer.insert(temp[x][y]);
-			//			LOG_MESSAGE(
-			//				"InventoryWindow",
-			//				Ogre::String("erzeuge Bild im Container: ") + temp[x][y]->getName());
-			//		}
-			//	}
-			//}
-		}
-	}
-
-
-	void InventoryWindow::removeContainerAndContent(Container* container)
-	{
-		assert(mContainerContents.size() == mContainers.size());
-		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
-		std::list<CEGUI::Window*>::iterator itParent = mContainers.begin();
-		CEGUI::Window* windowToEmpty = NULL;
-		CEGUI::Window* parentTabWindow = NULL;
-
-		bool found = false;
-		while (it != mContainerContents.end())
-		{
-			if (container == static_cast<Item*>((*it)->getUserData()))
-			{
-				// Aus Liste entfernen
-				windowToEmpty = *it;
-				parentTabWindow = *itParent;
-				found = true;
-				break;
-			}
-			it++;
-			itParent++;
-		}
-		if (found)
-		{
-			// Entferne die Elemente aus den Listen
-			mContainerContents.erase(it);
-			mContainers.erase(itParent);
-
-
-			emptySlot(windowToEmpty);
-			emptySlot(parentTabWindow);
-
-			mContainerTabs->removeTab(parentTabWindow->getName());
-
-			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(parentTabWindow);
-		}
-	}
-
-	void InventoryWindow::emptySlots()
-	{
-		emptySlot(mHelmet);
-		emptySlot(mRingLeft);
-		emptySlot(mRingRight);
-		emptySlot(mHandLeft);
-		emptySlot(mHandRight);
-		emptySlot(mGloves);
-		emptySlot(mBraceletLeft);
-		emptySlot(mBraceletRight);
-		emptySlot(mArmor);
-		emptySlot(mCape);
-		emptySlot(mBracers);
-		emptySlot(mBackpack);
-		emptySlot(mBelt);
-		emptySlot(mNecklace);
-		emptySlot(mTrousers);
-		emptySlot(mShinbone);
-		emptySlot(mBoots);
-
-		// Zus?zlich alle Container durchgehen und entleeren
-		
-		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
-		
-		while (it != mContainerContents.end())
-		{
-			emptySlot(*it);
-			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(*it);
-			it++;
-		} // alle Container wurden entleert
-
-		it = mContainers.begin();
-		while (it != mContainers.end())
-		{
-			emptySlot(*it);
-			mContainerTabs->removeTab((*it)->getName());
-			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(*it);
-			it++;
-		} // alle ContainerTabs wurden entleert
-		mContainerContents.clear();
-		mContainers.clear();
-	}
-
-	void InventoryWindow::emptySlot(CEGUI::Window* slot)
-	{
-		while(slot->getChildCount() > 0){
-			CEGUI::Window* windowToDestroy = slot->getChildAtIdx(0);
-			CEGUI::WindowManager::getSingletonPtr()->destroyWindow(windowToDestroy);
-			slot->removeChildWindow(windowToDestroy);
-		}
-	}
-
-	void InventoryWindow::addDropListener(CEGUI::Window* slot){
-		// onMouseOver (beim Drag)
-		slot->subscribeEvent(Window::EventDragDropItemEnters, boost::bind(&InventoryWindow::handleDragEnter,this,_1));
-		// onMouseOut (beim Drag)
-		slot->subscribeEvent(Window::EventDragDropItemLeaves, boost::bind(&InventoryWindow::handleDragLeave,this,_1));
-		// onItemDropped
-		slot->subscribeEvent(Window::EventDragDropItemDropped, boost::bind(&InventoryWindow::handleDragDropped,this,_1)); 
-	}
-
-	CEGUI::Window* InventoryWindow::findContainer(Container* container)
-	{
-		std::list<CEGUI::Window*>::iterator it = mContainerContents.begin();
-		while (it != mContainerContents.end())
-		{
-			if (static_cast<Item*>((*it)->getUserData()) == container)
-				return (*it);
-			it++;
-		}
-		Throw(IllegalArgumentException, "Es gibt kein Containerfenster zu dem gesuchten Item");
-	}
-
-	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
-	{
-		// Prfe, ob ein Item da ist
-		if (item != NULL) {
-
-			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
-			// Waffe:
-			if (parent == mHandRight || parent == mHandLeft) 
-			{
-				position = UVector2(cegui_absdim(30-(item->getSize().first * 15)), cegui_absdim(75-(item->getSize().second *15)));
-			}
-
-			static int itemCnt = 0;
-			itemCnt++;
-
-			// Erzeuge einen Handler fr Drag and Drop
-			DragContainer* itemhandler = static_cast<DragContainer*>(
-				CEGUI::WindowManager::getSingletonPtr()->createWindow("DragContainer", Ogre::StringConverter::toString(itemCnt) + item->getName()));
-			itemhandler->setPosition(position);
-			itemhandler->setSize(UVector2(cegui_absdim(item->getSize().first*30),
-                cegui_absdim(item->getSize().second*30))); 
-			itemhandler->setUserString("ItemType",Item::getItemTypeString(item->getItemType()));
-			itemhandler->setUserData(item);
-			itemhandler->setTooltipText(item->getName());
-			itemhandler->subscribeEvent(CEGUI::Window::EventMouseClick,
-				Event::Subscriber(&InventoryWindow::handleMouseClicked,this));
-			
-			parent->addChildWindow(itemhandler);
-
-			CeGuiString tempName = item->getName();
-
-			// Erzeuge das Hintergrundfenster des Items
-			Window* itemWindow = 
-				CEGUI::WindowManager::getSingletonPtr()->createWindow(
-					"RastullahLook/Item", 
-					tempName + "Item");
-
-			itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-			itemWindow->setSize(UVector2(cegui_absdim(item->getSize().first*30),
-                cegui_absdim(item->getSize().second*30)));
-			itemWindow->setProperty("FrameEnabled", "false");
-			itemWindow->setProperty("BackgroundColour", mColorItemNormal);
-			// Gib dem Item noch ein Bild...
-			itemWindow->setProperty("Image",
-                CeGuiString("set:ModelThumbnails image:") + item->getImageName());
-			itemWindow->disable(); 
-
-			itemhandler->addChildWindow(itemWindow);
-
-			return itemhandler;
-		}
-		else
-		{
-			// Kein Item da...
-			return NULL;
-		}
-	}
-
-	bool InventoryWindow::handleMouseEnters(const EventArgs &args) 
-	{
-		return true;
-	}
-
-	bool InventoryWindow::handleMouseLeaves(const EventArgs &args) 
-	{
-		return true;
-	}
-
-
-	bool InventoryWindow::handleMouseClicked(const EventArgs &args) 
-	{
-		// Hole das ausgew?lte Item
-		const CEGUI::MouseEventArgs& mea = static_cast<const MouseEventArgs&>(args);
-
-		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
-		if (mea.window->getUserData() != NULL)
-		{
-			Item* item = NULL;
-			item = static_cast<Item*>(mea.window->getUserData());
-	
-			// deaktiviere das letzte aktive Item, falls es eins gab
-			if (mActiveItemWindow){
-				mActiveItemWindow->setProperty("BackgroundColour", mColorItemNormal);
-				mActiveItemWindow->setProperty("FrameEnabled", "False");
-			}
-			
-			assert(mea.window->getChildCount() > 0);
-			
-			// aktiviere das angew?lte Item...
-			mActiveItemWindow = mea.window->getChildAtIdx(0);
-			mActiveItemWindow->setProperty("BackgroundColour", mColorItemSelected);
-			mActiveItemWindow->setProperty("FrameEnabled", "True");
-			
-			// Schreibe Iteminfos in Description Fenster
-			if (item) 
-			{
-				mDescription->setText(item->getDescription());
-				if (item->getDescription().length() > 200)
-				{
-					// Scrollbalken aktivieren
-                    mDescription->setShowVertScrollbar(true);
-				}
-				else 
-				{
-
-				}
-				renderItem(item);
-			}
-			else
-			{
-				mDescription->setText("");
-			}
-		}
-		return true;
-	}
-
-	void InventoryWindow::initRenderToTexture()
-	{
-		// Das Feld, in das gerendert werden soll (TransparentStaticImage)
-		mItemRenderImage = getWindow("InventoryWindow/ItemPicture");
-
-		SceneManager* tempManager = CoreSubsystem::getSingleton().
-				getWorld()->getSceneManager();
-	
-
-		// Setup Render To Texture for preview window
-		mRenderTexture = Root::getSingleton().getRenderSystem()->createRenderTexture( "InventoryItemRttTex", 128, 128, TEX_TYPE_2D, PF_R8G8B8 );
+        for (size_t idx = 0; idx < containers->getChildCount(); idx++)
         {
-			
-			/*Ogre::Camera* itemRenderCam = tempManager->createCamera("InventoryItemRenderCamera");
-			
-            SceneNode* itemCamNode = 
-				tempManager->getRootSceneNode()->createChildSceneNode(Ogre::Vector3(0,-1000,0));
-			
-			itemCamNode->attachObject(itemRenderCam);
-			itemRenderCam->pitch(Ogre::Radian(90));
-
-            mRenderViewport = mRenderTexture->addViewport( itemRenderCam );
-            mRenderTexture->setAutoUpdated(false);
-			mRenderViewport->setOverlaysEnabled(false);
-            mRenderViewport->setClearEveryFrame( true );
-			//mRenderViewport->setClearEveryFrame(false);
-            mRenderViewport->setBackgroundColour( ColourValue::Black );
-			*/
-			
-			//loadCamera();
-
-            
-			
-			
+            Window* curWnd = containers->getChildAtIdx(idx);
+            CeGuiString curWndName = curWnd->getName();
+            if (curWndName.find("InventoryWindow/Slots/") != CeGuiString::npos)
+            {
+                CeGuiString slotname = 
+                    curWndName.substr(
+                        curWndName.find("InventoryWindow/Slots/") + 22);
+                slotsInWindowDefinition[slotname] = curWnd;
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, "Not a slot: "+curWndName);
+            }
         }
 
-        // Retrieve CEGUI texture for the RTT
-		mTexture = UiSubsystem::getSingleton().getGUIRenderer()->createTexture((CEGUI::utf8*)"InventoryItemRttTex");
-
-        mImageSet = CEGUI::ImagesetManager::getSingleton().createImageset(
-                    (CEGUI::utf8*)"InventoryItemRttImageset", mTexture);
-
-        mImageSet->defineImage((CEGUI::utf8*)"InventoryItemRttImage", 
-                CEGUI::Point(0.0f, 0.0f),
-                CEGUI::Size(mTexture->getWidth(), mTexture->getHeight()),
-                CEGUI::Point(0.0f,0.0f));
-	}
-
-	void InventoryWindow::renderItem(Item* item)
-	{
-		SceneManager* tempManager = CoreSubsystem::getSingleton().
-					getWorld()->getSceneManager();
-
-		// Fr einen Aufh?geknoten Sorgen
-		if (mInventoryItemNode == NULL){
-			mInventoryItemNode = tempManager->getRootSceneNode()->createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
-			//mInventoryItemNode->setPosition(0,-100,-0.2);
-		}
-		
-		if (mRenderItemEntity) {
-			// Vom Knoten entfernen
-			mInventoryItemNode->detachAllObjects();
-			// alte Entity entfernen
-			tempManager->destroyEntity(mRenderItemEntity);
-			mRenderItemEntity = NULL;
-		}
-		if (item->getActor())
-		{
-			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k?nte
-			unloadCamera();
-			loadCamera();
-
-			// Item setzen und Schnappschuss machen
-			mRenderItemEntity = tempManager->createEntity("inventoryRenderedItem",
-                (static_cast<MeshObject*>(item->getActor()->getControlledObject()))->getMeshName());
-			mInventoryItemNode->attachObject(mRenderItemEntity);
-		
-			// Das Item hat einen Actor
-			//mItemActor = ActorManager::getSingleton().createMeshActor("inventoryRenderedItem",
-            //  (static_cast<MeshObject*>(item->getActor()->getControlledObject()))->getMeshName());
-			//mItemActor->placeIntoScene(Ogre::Vector3(0,-101055.3,-0.2));
-            mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128)));
-			mItemRenderImage->setProperty("Image",
-                "set:" + mImageSet->getName() + " image:InventoryItemRttImage");
-			mRenderTexture->update();
-
-		}
-        else if (item->getImageName() != "")
+        Inventory::SlotMap slots = inventory->getAllSlots();
+        for (Inventory::SlotMap::const_iterator it = slots.begin(); it != slots.end(); it++)
         {
-            mItemRenderImage->setProperty("Image",
-                "set:ModelThumbnails image:" + item->getImageName());
+            CeGuiString slotName = (*it).first;
+            std::map<CeGuiString, Window*>::iterator 
+                slotInWindowFile = slotsInWindowDefinition.find(slotName);
 
-			float div = item->getSize().first / float(item->getSize().second);
+            if (slotInWindowFile != slotsInWindowDefinition.end())
+            {
+                mSlotWindows[slotName] = (*slotInWindowFile).second; 
+                slotsInWindowDefinition.erase(slotInWindowFile);
+                LOG_DEBUG(Logger::UI, "Found slot "+slotName);
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, "Not found slot "+slotName);
+                ///@todo Create tab
+                // mSlotWindows.push_back();
+            }
+        }
 
-			if (div < 1)
-			{
-				//schmales Item
-                mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128*div, 128)));
-			}
-			else
-			{
-				// breites oder quadratisches Item
-                mItemRenderImage->setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128/div)));
-			}
-		}
-	}
+        ///@todo deactivate all remaining elements of slotsInWindowDefinition
+    }
 
-
-	void InventoryWindow::loadCamera()
-	{
-		mCameraActor = ActorManager::getSingleton().createCameraActor("InventoryItemRttCam");
-		mCameraActor->placeIntoScene(Ogre::Vector3(0,-999999,0));
-		mCameraActor->pitch(-90);
-		mCameraActor->getPhysicalThing()->freeze();
-
-		mRenderTexture->setAutoUpdated(false);
-        mRenderViewport = mRenderTexture->addViewport(
-            (static_cast<CameraObject*>(mCameraActor->getControlledObject()))->getCamera());
-        mRenderViewport->setOverlaysEnabled(false);
-        mRenderViewport->setClearEveryFrame(true);
-        mRenderViewport->setBackgroundColour( ColourValue::Black );
-	}
-
-	void InventoryWindow::unloadCamera()
-	{
-		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst?t werden
-		if (mRenderViewport)
-		{
-			mRenderTexture->removeViewport(0);
-			ActorManager::getSingleton().destroyActor(mCameraActor);
-		}
-	}
-
-	/*!
-	*		?erprft, ob das Item von dem Slot akzeptiert wird
-	*/
-	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
-	{
-		if (window->getUserString("ItemType").compare(draggedItem->getUserString("ItemType")) == 0)
-		{
-			return true;
-		} 
-		else 
-		{
-			return false;
-		}
-	}
-
-	/**
-	* Berechnet aus relativen und Absoluten Mousekoordinaten die neue Position im Container
-	*/
-	std::pair<int,int> InventoryWindow::calculateNewPosition(const DragDropEventArgs& ddea)
-	{
-		// Errechnung der Koordinaten, in welchem K?tchen denn nun gedroppt wird
-		Point absMouse = MouseCursor::getSingleton().getPosition();
-        Point scrnPt = ddea.window->getPixelRect().getPosition();
-		Point relMouse = absMouse - ddea.dragDropItem->getPixelRect().getPosition();
-
-		//Bug in CeGUI (1. rel Mouse koordinate spinnt
-		if (relMouse.d_x < 0) {
-			relMouse.d_x = 15;
-		}
-
-		LOG_MESSAGE(
-			"InventoryWindow",
-			Ogre::String("relMouse: Point x:")
-			+ StringConverter::toString(relMouse.d_x)
-			+ ", Point y:"
-			+ StringConverter::toString(relMouse.d_y));
-
-		Point pointInBackpack = absMouse-scrnPt;
-		pointInBackpack -= relMouse;
-
-		// Position des n?hsten K?tchens bestimmen		
-		if (pointInBackpack.d_x < 0)
+    void InventoryWindow::initInventoryWindow(Inventory* inventory)
+    {
+        for (std::map<CeGuiString, Window*>::iterator it = mSlotWindows.begin(); it != mSlotWindows.end(); it++)
         {
-			pointInBackpack.d_x = 0;
-		}
-		if (pointInBackpack.d_y < 0)
-        {
-			pointInBackpack.d_y = 0;
-		}
-
-		if (pointInBackpack.d_x > 16)
-        {
-			pointInBackpack.d_x = (int(pointInBackpack.d_x) + 14) -
-                ((int(pointInBackpack.d_x) + 14) % 30);
-		}
-        else
-        {
-			pointInBackpack.d_x = 0;
-		}
-
-		if (pointInBackpack.d_y > 16)
-        {
-			pointInBackpack.d_y = (int(pointInBackpack.d_y) + 14 ) -
-                ((int(pointInBackpack.d_y) + 14) % 30);
-		}
-        else
-        {
-			pointInBackpack.d_y = 0;
-		}
-
-		int xKaestchen = (int) (pointInBackpack.d_x / 30);
-		int yKaestchen = (int) (pointInBackpack.d_y / 30);
-
-		std::pair<int,int> result = std::make_pair<int,int>(xKaestchen, yKaestchen);
-		return result;
-	}
-
-
-	/*!
-	* Behandlung fr Mouse-over mit Item in der Maus
-	* ?erprft, ob das Item passt, und f?bt dementsprechend den Beh?ter ein
-	*/
-	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs& args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
-		
-		if (ddea.window->getUserData()){
-			// Es handelt sich um einen Container
-			Item* container = static_cast<Item*>(ddea.window->getUserData());
-			if (container == getGroundItem())
-			{
-				// Boden (nimmt alles)
-				ddea.window->setProperty("ContainerColour", mColorAccept);
-				return true;
-			} 
-			else if (container && container->getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				// Ein Container kann keinen Rucksack aufnehmen
-				if (!(ddea.dragDropItem->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
-				{
-					ddea.window->setProperty("ContainerColour", mColorReject);
-					return false;
-				}
-				else 
-				{
-					ddea.window->setProperty("ContainerColour", mColorAccept);
-					return true;
-				}
-			}
-			else {
-				// Beliebiger anderer Container am K?per
-				// TODO: Beschr?kung auf Itemtypen... 
-
-				ddea.window->setProperty("ContainerColour", mColorAccept);
-				return true;
-			}
-		}
-		else if (checkTypeAccepted(ddea.window, ddea.dragDropItem))
-		{
-			ddea.window->setProperty("ContainerColour", mColorAccept);
-			return true;
-		}
-		else
-		{
-			ddea.window->setProperty("ContainerColour", mColorReject);
-			return false;
-		}
-	}
-
-	bool InventoryWindow::handleDragLeave(const CEGUI::EventArgs& args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
-		ddea.window->setProperty("ContainerColour", mColorNormal);
-		return true;
-	}
-
-	bool InventoryWindow::handleDragDropped(const CEGUI::EventArgs& args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs& ddea = static_cast<const DragDropEventArgs&>(args);
-		// Farbe zurcksetzen
-		ddea.window->setProperty("ContainerColour", mColorNormal);
-
-
-		if (ddea.window->getUserData()){
-			// Es handelt sich um einen Container
-			Item* container = static_cast<Item*>(ddea.window->getUserData());
-			if (container == mGroundItem)
-			{
-				// Boden (nimmt alles)
-			} 
-			else if (container->getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				// Rucksack (nimmt alles au?r dem Rucksack selbst)
-				if (!(ddea.dragDropItem->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
-				{
-					return false;
-				}
-			}
-			else {
-				// Beliebiger anderer Container am K?per
-				// TODO: Beschr?kung auf Itemtypen... 
-			}
-
-			std::pair<int,int> newPos = calculateNewPosition(ddea);
-
-			if (isFreeInContainer(
-				static_cast<Item*>(ddea.dragDropItem->getUserData()),
-				newPos, static_cast<Container*>(ddea.window->getUserData())))
-			{
-				ddea.window->addChildWindow(ddea.dragDropItem);
-
-				mPosDraggedTo=CEGUI::Point(newPos.first*30,newPos.second*30);
-				mDroppedItem = ddea.dragDropItem;
-				mContainerDraggedTo = ddea.window;
-
-				updateInventory();
-				return true;
-			}
-			else 
-			{
-				return false;
-			}
-
-
-		} else {
-			// Es handelt sich um einen Slot am K?per
-			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
-				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k?nen
-
-				if (ddea.window->getChildCount() > 0)
-				{
-					// Slot hat schon einen anderen Gegenstand getragen
-					mOldItemInSlot = static_cast<CEGUI::DragContainer*>(ddea.window->getChildAtIdx(0));
-					ddea.window->removeChildWindow(mOldItemInSlot);
-				}
-				else
-				{
-					mOldItemInSlot = NULL;
-				}
-
-				ddea.window->addChildWindow(ddea.dragDropItem);
-
-				// Waffe und Schild sollen mittig positioniert werden
-				if ((!ddea.window->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_WEAPON)) ||
-					(!ddea.window->getUserString("ItemType").compare(Item::getItemTypeString(Item::ITEMTYPE_SHIELD)))) &&
-					(ddea.dragDropItem->getUserData()))
-				{
-					Item* item = static_cast<Item*>(ddea.dragDropItem->getUserData());
-					mPosDraggedTo= CEGUI::Point(30-(item->getSize().first * 15),75-(item->getSize().second *15));
-				}
-				// Rest kommt in die linke obere Ecke (weil ausfllend)
-				else {
-					mPosDraggedTo=CEGUI::Point(0.0,0.0);
-				}
-				mDroppedItem = ddea.dragDropItem;
-				mContainerDraggedTo = ddea.window;
-
-				updateInventory();
-				return true;
-			} else {
-				// Item passt nicht zum Slot
-				return false;
-			}
-		}
-	}
+            CeGuiString slotName = (*it).first;
+            Item* item = inventory->getItem(slotName);
+            if (item != NULL)
+            {
+                LOG_MESSAGE(Logger::UI, (*it).first + " - " + item->getDescription());
+                CeGuiString icon = item->getImageName();
+                if (icon != "" /*&& icon.find("/") != CeGuiString::npos*/)
+                {
+                    LOG_MESSAGE("IW", icon);
+                    Window* itemWindow = 
+				        CEGUI::WindowManager::getSingletonPtr()->createWindow(
+					    "RastullahLook/StaticImage", 
+                        mWindow->getName() + "/" + slotName + "/" + icon);
+                    itemWindow->setProperty("Image", icon);
+                    (*it).second->addChildWindow(itemWindow);
+                    itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+                    itemWindow->setSize(
+                        UVector2(cegui_absdim(item->getSize().first*30),
+                                 cegui_absdim(item->getSize().second*30)));
+                }
+            }
+        }
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -66,7 +66,8 @@
 	WindowFactory::WindowFactory()
 		: mShownObject(NULL),
 		  mObjectNameText(NULL),
-          mMainMenuWindow(NULL)
+          mMainMenuWindow(NULL),
+          mInventoryWindow(NULL)
     {
     }
 
@@ -83,7 +84,6 @@
 		mGameLogger = new GameLoggerWindow();
 		mCharacterStateWindow = new CharacterStateWindow();
 		mInGameMenuWindow = new InGameMenuWindow();
-		mInventoryWindow = new InventoryWindow();
 		mCharacterSheet = new CharacterSheetWindow();
 		mJournalWindow = new JournalWindow();
 		mInfoPopup = new InfoPopup();
@@ -189,19 +189,32 @@
 
 	void WindowFactory::toggleInventoryWindow()
 	{
-		if (mInventoryWindow->isVisible())
-		{
-			mInventoryWindow->setVisible(false);
-		}
-		else if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
+        if (mInventoryWindow != NULL && mInventoryWindow->isVisible())
         {
-			mInventoryWindow->setInventory(UiSubsystem::getSingleton().getActiveCharacter()->getInventory());
-			mInventoryWindow->setVisible(true);
-		}
-	}
+            mInventoryWindow->setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
 
-	InventoryWindow* WindowFactory::getInventoryWindow(){
-		return mInventoryWindow;
+		    if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat->getInventoryWindowType();
+                if (inventoryWindowType == "")
+                {
+                    inventoryWindowType = "inventory_default.xml"; ///TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat->getInventory());
+			    mInventoryWindow->setVisible(true);
+		    }
+        }
 	}
 
 



From tanis at mail.berlios.de  Fri Mar 30 21:22:32 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 30 Mar 2007 21:22:32 +0200
Subject: [Dsa-hl-svn] r3213 - in tools/mesh_combiner: include src
Message-ID: <200703301922.l2UJMWNB002988@sheep.berlios.de>

Author: tanis
Date: 2007-03-30 21:22:27 +0200 (Fri, 30 Mar 2007)
New Revision: 3213

Removed:
   tools/mesh_combiner/include/Makefile.in
   tools/mesh_combiner/src/Makefile.in
Log:
Uneeded intermediate files removed.

Deleted: tools/mesh_combiner/include/Makefile.in
===================================================================
--- tools/mesh_combiner/include/Makefile.in	2007-03-30 19:20:10 UTC (rev 3212)
+++ tools/mesh_combiner/include/Makefile.in	2007-03-30 19:22:27 UTC (rev 3213)
@@ -1,349 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-subdir = include
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in $(srcdir)/config.h.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.in
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = config.h
-CONFIG_CLEAN_FILES =
-SOURCES =
-DIST_SOURCES =
-HEADERS = $(noinst_HEADERS)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
-AMTAR = @AMTAR@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-ECHO = @ECHO@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
-GREP = @GREP@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-OBJEXT = @OBJEXT@
-OGRE_CFLAGS = @OGRE_CFLAGS@
-OGRE_LIBS = @OGRE_LIBS@
-OGRE_PLUGINDIR = @OGRE_PLUGINDIR@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-RANLIB = @RANLIB@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_F77 = @ac_ct_F77@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-noinst_HEADERS = 
-all: config.h
-	$(MAKE) $(AM_MAKEFLAGS) all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  include/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  include/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-config.h: stamp-h1
-	@if test ! -f $@; then \
-	  rm -f stamp-h1; \
-	  $(MAKE) stamp-h1; \
-	else :; fi
-
-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
-	@rm -f stamp-h1
-	cd $(top_builddir) && $(SHELL) ./config.status include/config.h
-$(srcdir)/config.h.in:  $(am__configure_deps) 
-	cd $(top_srcdir) && $(AUTOHEADER)
-	rm -f stamp-h1
-	touch $@
-
-distclean-hdr:
-	-rm -f config.h stamp-h1
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-tags: TAGS
-TAGS:
-
-ctags: CTAGS
-CTAGS:
-
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(HEADERS) config.h
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-hdr \
-	distclean-libtool
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-hdr distclean-libtool \
-	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	uninstall uninstall-am uninstall-info-am
-
-	config.h \
-	MergeMesh.h \
-	MergeSkeleton.h \
-	MeshCombiner.h
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: tools/mesh_combiner/src/Makefile.in
===================================================================
--- tools/mesh_combiner/src/Makefile.in	2007-03-30 19:20:10 UTC (rev 3212)
+++ tools/mesh_combiner/src/Makefile.in	2007-03-30 19:22:27 UTC (rev 3213)
@@ -1,470 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-bin_PROGRAMS = meshcombiner$(EXEEXT)
-subdir = src
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.in
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/include/config.h
-CONFIG_CLEAN_FILES =
-am__installdirs = "$(DESTDIR)$(bindir)"
-binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
-PROGRAMS = $(bin_PROGRAMS)
-am_meshcombiner_OBJECTS = MergeMesh.$(OBJEXT) MergeSkeleton.$(OBJEXT) \
-	MeshCombiner.$(OBJEXT) MeshCombinerMain.$(OBJEXT)
-meshcombiner_OBJECTS = $(am_meshcombiner_OBJECTS)
-meshcombiner_LDADD = $(LDADD)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CXXFLAGS) $(CXXFLAGS)
-CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) --tag=CXX --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(meshcombiner_SOURCES)
-DIST_SOURCES = $(meshcombiner_SOURCES)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
-AMTAR = @AMTAR@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-ECHO = @ECHO@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
-GREP = @GREP@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-OBJEXT = @OBJEXT@
-OGRE_CFLAGS = @OGRE_CFLAGS@
-OGRE_LIBS = @OGRE_LIBS@
-OGRE_PLUGINDIR = @OGRE_PLUGINDIR@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-RANLIB = @RANLIB@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_F77 = @ac_ct_F77@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-INCLUDES = $(OGRE_CFLAGS) -I../include
-meshcombiner_LDFLAGS = $(OGRE_LIBS) $(LIBS)
-meshcombiner_SOURCES = \
-	MergeMesh.cpp \
-	MergeSkeleton.cpp \
-	MeshCombiner.cpp \
-	MeshCombinerMain.cpp
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .cpp .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  src/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-install-binPROGRAMS: $(bin_PROGRAMS)
-	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
-	  if test -f $$p \
-	     || test -f $$p1 \
-	  ; then \
-	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
-	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
-	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
-	  else :; fi; \
-	done
-
-uninstall-binPROGRAMS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
-	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
-	done
-
-clean-binPROGRAMS:
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
-	  echo " rm -f $$p $$f"; \
-	  rm -f $$p $$f ; \
-	done
-meshcombiner$(EXEEXT): $(meshcombiner_OBJECTS) $(meshcombiner_DEPENDENCIES) 
-	@rm -f meshcombiner$(EXEEXT)
-	$(CXXLINK) $(meshcombiner_LDFLAGS) $(meshcombiner_OBJECTS) $(meshcombiner_LDADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MergeMesh.Po at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MergeSkeleton.Po at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MeshCombiner.Po at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MeshCombinerMain.Po at am__quote@
-
-.cpp.o:
- at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`; \
- at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ $<; \
- at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Po"; else rm -f "$$depbase.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
-
-.cpp.obj:
- at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`; \
- at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
- at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Po"; else rm -f "$$depbase.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.cpp.lo:
- at am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`; \
- at am__fastdepCXX_TRUE@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ $<; \
- at am__fastdepCXX_TRUE@	then mv -f "$$depbase.Tpo" "$$depbase.Plo"; else rm -f "$$depbase.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(PROGRAMS)
-installdirs:
-	for dir in "$(DESTDIR)$(bindir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-exec-am: install-binPROGRAMS
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-binPROGRAMS
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
-	clean-generic clean-libtool ctags distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-binPROGRAMS install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am tags uninstall uninstall-am \
-	uninstall-binPROGRAMS uninstall-info-am
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:



From blakharaz at mail.berlios.de  Fri Mar 30 21:28:22 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 30 Mar 2007 21:28:22 +0200
Subject: [Dsa-hl-svn] r3214 - modules/techdemo/scripts/maps
Message-ID: <200703301928.l2UJSM8D003556@sheep.berlios.de>

Author: blakharaz
Date: 2007-03-30 21:28:20 +0200 (Fri, 30 Mar 2007)
New Revision: 3214

Modified:
   modules/techdemo/scripts/maps/techdemo.rb
   modules/techdemo/scripts/maps/techdemo_hoehle_eingang.rb
Log:
adapt techdemo to gameobject system

Modified: modules/techdemo/scripts/maps/techdemo.rb
===================================================================
--- modules/techdemo/scripts/maps/techdemo.rb	2007-03-30 19:22:27 UTC (rev 3213)
+++ modules/techdemo/scripts/maps/techdemo.rb	2007-03-30 19:28:20 UTC (rev 3214)
@@ -30,24 +30,25 @@
 techdemoWelt.getControlledObject().play();
 $SCRIPT.log("Welten-Thema fertig");
 
-$SCRIPT.log("Held erstellen");
-$hero = Hero.new;
-$SCRIPT.log("Held erstellt");
-$SCRIPT.log("Held in die Szene einfuegen.");
-$hero.getActor().placeIntoScene([-69.220, 3.440, -4.000], [[0.0, 1.0, 0.0], 0.0]);
-$SCRIPT.log("Held eingef?gt.");
-PlayerSettings.preparePlayer($hero);
-$SCRIPT.log("Held vorbereitet.");
-$UI.setActiveCharacter($hero);
-$SCRIPT.log("Held als aktiver Charakter gesetzt.");
+$SCRIPT.log("Create hero")
+$hero = $GOM.createGameObjectProxy("hero", 1);
 
+$SCRIPT.log("Place hero into scene")
+$hero.getGameObject().placeIntoScene()
+
+$SCRIPT.log("Prepare hero for being the active character")
+PlayerSettings.preparePlayer($hero.getGameObject())
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero.getGameObject())
+
 $World.setFog( World::FOG_EXP, [0.8,0.8,1.0,0.5], 0.00003, 0.4, 1.0);
 
 load "techdemo_umgebung.rb"
 load "techdemo_quests.rb"
 
-
 load "techdemo_bauer.rb"
+$bauer = 
 $bauer = BauerArnolfGrossschaedel.new()
 $bauer.getActor().placeIntoScene([29.9182, -0.6554, 9.590], [[0, 1, 0], 280])
 

Modified: modules/techdemo/scripts/maps/techdemo_hoehle_eingang.rb
===================================================================
--- modules/techdemo/scripts/maps/techdemo_hoehle_eingang.rb	2007-03-30 19:22:27 UTC (rev 3213)
+++ modules/techdemo/scripts/maps/techdemo_hoehle_eingang.rb	2007-03-30 19:28:20 UTC (rev 3214)
@@ -122,13 +122,13 @@
 	def initialize(rock1, rock2, rock3)
 		super()
 		@mRock1 = rock1
-		@mRock1.spawn()
+		@mRock1.placeIntoScene()
 		@mRock1.getActor().setVisible(false);
 		@mRock2 = rock2
-		@mRock2.spawn()
+		@mRock2.placeIntoScene()
 		@mRock2.getActor().setVisible(false);
 		@mRock3 = rock3
-		@mRock3.spawn()
+		@mRock3.placeIntoScene()
 		@mRock3.getActor().setVisible(false);
 	end
 



