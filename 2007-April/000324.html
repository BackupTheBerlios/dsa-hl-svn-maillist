<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3253 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3253%20-%20in%20rl/trunk/engine%3A%20ai/src%20rules/include%0A%09rules/src%20script/swig%20ui/src&In-Reply-To=%3C200704111912.l3BJCbO8029619%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000323.html">
   <LINK REL="Next"  HREF="000325.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3253 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src</H1>
    <B>no22 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3253%20-%20in%20rl/trunk/engine%3A%20ai/src%20rules/include%0A%09rules/src%20script/swig%20ui/src&In-Reply-To=%3C200704111912.l3BJCbO8029619%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3253 - in rl/trunk/engine: ai/src rules/include	rules/src script/swig ui/src">no22 at mail.berlios.de
       </A><BR>
    <I>Wed Apr 11 21:12:37 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000323.html">[Dsa-hl-svn] r3252 - in rl/trunk/engine: core/include core/src	rules/include rules/src script/swig ui/include ui/src
</A></li>
        <LI>Next message: <A HREF="000325.html">[Dsa-hl-svn] r3254 - in modules: common/scripts	common/scripts/effects regressiontest/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: no22
Date: 2007-04-11 21:12:16 +0200 (Wed, 11 Apr 2007)
New Revision: 3253

Modified:
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/TypeOgreString.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
saving WIP

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -72,7 +72,7 @@
 	Vector3 inertia;
 	mActor-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getMassMatrix(mMass, inertia);
 
-//	mSpeed = (float)mCreature-&gt;getWert(WERT_GS) / (float)Date::ONE_KAMPFRUNDE * 1000.0f;
+//	mSpeed = (float)mCreature-&gt;getWert(Creature::WERT_GS) / (float)Date::ONE_KAMPFRUNDE * 1000.0f;
 
 //  reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/include/Creature.h	2007-04-11 19:12:16 UTC (rev 3253)
@@ -109,10 +109,30 @@
 
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_BEHAVIOURS;
-        static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
-        
-            Creature(unsigned int id);
+			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
 
+			typedef std::string Wert;
+
+    // some targets
+			static const std::string ALL_EIGENSCHAFTEN;
+			static const std::string ALL_TALENTE;
+
+    static const Wert WERT_MOD_AE;
+    static const Wert WERT_MOD_LE;
+    static const Wert WERT_MOD_AU;
+    static const Wert WERT_MOD_MR;
+    static const Wert WERT_MOD_AT;
+    static const Wert WERT_MOD_PA;
+    static const Wert WERT_MOD_FK;
+    static const Wert WERT_GS;
+    static const Wert WERT_SOZIALSTATUS;
+    static const Wert WERT_BE;
+    static const Wert WERT_INI;
+    static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
+    static const Wert WERT_REGENERATION;
+    			
+			Creature(unsigned int id);
+
             /// Der Standarddestruktor.
             virtual ~Creature();
 
@@ -132,31 +152,6 @@
                 SFSTATUS_OK,
                 SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
         };
-            /**
-              * Identifiziert welcher Wert angesprochen werden soll.
-              * @warning Bei WERT_MOD_* gibt getValue() Unsinn zurueck, da 
-              * der Multiplikator dann auf 0 + modifier multipliziert wird. 
-              * Stattdessen einzeln auf die Modifikatoren zugreifen!
-              * @ingroup CreatureRubyExports
-              **/
-            enum Wert
-            {
-                WERT_MOD_AE = 1, ///&lt; Astralenergie
-                WERT_MOD_LE, ///&lt; Lebensenergie
-                WERT_MOD_AT, ///&lt; Attacke
-                WERT_MOD_PA, ///&lt; Parade
-                WERT_MOD_FK, ///&lt; Fernkampf
-                WERT_MOD_AU, ///&lt; Ausdauer
-                WERT_MOD_MR, ///&lt; Magieresistenz
-                WERT_MOD_INI, ///&lt; Initiative
-                WERT_MOD_REGENERATION_LE, ///&lt; Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
-                WERT_MOD_REGENERATION_AE, ///&lt; Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
-                WERT_MOD_ERSCHOEPFUNGSSCHWELLE, ///&lt; Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-                WERT_GS, ///&lt; Geschwindigkeit
-                WERT_SOZIALSTATUS, ///&lt; Sozialstatus
-                WERT_BE, ///&lt; Behinderung
-                WERT_KAMPFUNFAEHIGKEITSSCHWELLE ///&lt; Die Schwelle zur Kampfunfaehigkeit, bei Menschen 5 LE
-        };
 
 ///////////////////////////////////////////////////////////////////////////////
 // Werte
@@ -251,14 +246,8 @@
              *    gefunden werden.
              **/
             virtual int getWert(Wert wertId, bool getUnmodified = false);
+
             /**
-             *  Gibt einen Zeiger auf das ganze Stateset des Basiswerts \a wertId zurueck.
-             *  @param wertID Bezeichnet den Basiswert, von dem das StateSet zurueckgegeben
-             *   werden soll.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual StateSet* getWertStateSet(Wert wertId);
-            /**
              *  Gibt der Kreatur @ref abbddea &quot;AP&quot;.
              *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
              **/
@@ -292,7 +281,7 @@
              *   Gross/Kleinschreibung beachtet?).
                    *  @ingroup CreatureRubyExports
              **/
-            virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
+			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
             /**
              *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
              *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
@@ -488,7 +477,7 @@
             /**
              * Gets the status of a creature.
              **/
-            Effect::Status getStatus();
+			Effect::Status getStatus();
 
 
             bool isMagic();
@@ -542,12 +531,12 @@
             /**
              *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
              **/
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
+		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
                                                  int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
                                                  CeGuiString eigenschaft3Name);
             virtual int doTalentprobe(const CeGuiString talentName, int modifier);
 
-            virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
                                       int modifier);
             virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
                                                  CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
@@ -564,7 +553,7 @@
             *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
             *  @ingroup CreatureRubyExports
             */
-            virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
+			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
 
             /**
             *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
@@ -796,7 +785,7 @@
              *  Liste der Werte.
              *  @see Wert
              **/
-            typedef std::map&lt;const Wert, StateSet*&gt; WertMap;
+            typedef std::map&lt;const Wert, int&gt; WertMap;
             /**
                    *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
                    *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/include/Effect.h	2007-04-11 19:12:16 UTC (rev 3253)
@@ -29,10 +29,6 @@
 	class _RlRulesExport Effect
 	{
 	public:
-        
-      // some targets
-      static const CeGuiString ALL_EIGENSCHAFTEN;
-      static const CeGuiString ALL_TALENTE;
       
       typedef unsigned long Status;
       static const Status STATUS_NONE           = 1&lt;&lt;0;
@@ -62,6 +58,9 @@
       static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
       static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
       static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
+	  static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
+	  static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
+	  static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
 
       
       // other constants

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -38,9 +38,30 @@
 {
     const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = &quot;behaviours&quot;;
-
+    
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;; 
 
+
+    // some targets
+	const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+	const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
+	const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
+    const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
+    const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
+    const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
+    const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
+    const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
+    const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
+    const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
+    const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
+    const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
+    const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
+    const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
+    
+    
+
+
     Creature::Creature(unsigned int id)
         : GameObject(id), 
 		mCurrentLe(0),
@@ -62,18 +83,9 @@
 		//RlFail(&quot;Test&quot;);
 		setWert(WERT_MOD_AE, 0);
 		setWert(WERT_MOD_LE, 0);
-		setWert(WERT_MOD_AT, 0);
-		setWert(WERT_MOD_PA, 0);
-		setWert(WERT_MOD_FK, 0);
 		setWert(WERT_MOD_AU, 0);
 		setWert(WERT_MOD_MR, 0);
-		setWert(WERT_MOD_INI, 0);
-		setWert(WERT_SOZIALSTATUS, 0);
-        setWert(WERT_MOD_REGENERATION_LE, 0);
-        setWert(WERT_MOD_REGENERATION_AE, 0);
-        setWert(WERT_MOD_ERSCHOEPFUNGSSCHWELLE, 0);
 		setWert(WERT_GS, 8);
-		setWert(WERT_BE, 0);
         setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
 		mEigenschaften[E_MUT] = 0;
 		mEigenschaften[E_KLUGHEIT] = 0;
@@ -94,10 +106,6 @@
         delete mInventory;
 	delete mEffectManager;
 
-        for( WertMap::iterator it=mWerte.begin();it!=mWerte.end(); it++ )
-            delete it-&gt;second;
-        mWerte.clear();
-        mKampftechniken.clear();
         for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
             delete it-&gt;second;
         mSonderfertigkeiten.clear();
@@ -105,7 +113,7 @@
 
     int Creature::getAttackeBasis()
     {
-        double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
             getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
               getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
 
@@ -182,7 +190,13 @@
         {
             Throw(IllegalArgumentException, &quot;Wert nicht gefunden.&quot;);
         }
-		return it-&gt;second-&gt;getValue(getUnmodified);
+        int rval = it-&gt;second;
+        if (!getUnmodified)
+        {
+          rval += mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_WERTMOD);
+          rval *= mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_WERTMULT);
+        }
+		return rval;
 	}
 
 	int Creature::getCurrentBe()
@@ -197,28 +211,14 @@
 		WertMap::iterator it = mWerte.find(wertId);
         if (it == mWerte.end())
         {
-			StateSet* newWert = new StateSet();
-			newWert-&gt;setOriginalValue(value);
-			mWerte.insert(make_pair(wertId, newWert));
+			mWerte.insert(make_pair(wertId, value));
         }
 		else
 		{
-			it-&gt;second-&gt;setOriginalValue(value);
+			it-&gt;second = value;
 		}
 	}
 
-	StateSet* Creature::getWertStateSet(Wert wertId)
-	{
-		checkEffects();
-        WertMap::const_iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-            Throw(IllegalArgumentException, 
-                &quot;Wert &quot;+Ogre::StringConverter::toString(wertId)+&quot; not found.&quot;);
-        }
-		return it-&gt;second;
-	}
-
    void Creature::modifyLe(int mod, bool ignoreMax)
     {
         int oldLe = mCurrentLe;
@@ -632,10 +632,10 @@
 
 
         // Vor dem Vergleich hat man den Talentwert &#195;&#188;brig.
-		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(getWert(WERT_BE));
+		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_WERTMOD));
 		int taW = getTalent(talentName);
 		int rval = taW - modifier - mEffectManager-&gt;getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
-            - mEffectManager-&gt;getMod(Effect::ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
+            - mEffectManager-&gt;getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
 		// Bei negativen TaP*
 		int handicap = 0;
 		if (rval &lt; 0)
@@ -698,7 +698,7 @@
         else
         {
 			rval = getEigenschaft(eigenschaftName) - 
-                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
+                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
         }
         return rval;
     }
@@ -736,7 +736,7 @@
 		else
 		{
 			rval = getAttackeBasis() + (*it).second.first - (probe + modifier 
-                + mEffectManager-&gt;getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
 		if (rval &lt; 0) 
 			return RESULT_MISSERFOLG;
@@ -767,7 +767,7 @@
 		{
 			/// @todo Gute Parade
 			rval = getParadeBasis() + (*it).second.second - (probe + modifier 
-                + mEffectManager-&gt;getMod(Effect::ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
 		if (rval &lt; 0) 
 			return RESULT_MISSERFOLG;
@@ -778,8 +778,8 @@
 	int Creature::doInitiativeWurf(bool getMaxInitiave)
 	{
 		int rval = getInitiativeBasis();
-		rval += getWert(WERT_MOD_INI);
-		rval -= getWert(WERT_BE);
+		rval += mEffectManager-&gt;getMod(WERT_INI, Effect::MODTYPE_WERTMOD);
+		rval -= mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_WERTMOD);
 		if (getMaxInitiave) 
         {
             rval += 6;
@@ -845,10 +845,10 @@
         //Grundregeneration von 1W6
         int regeneratedLe = DsaManager::getSingleton().rollD6();
         //Addiere eventuelle Modifikatoren hinzu
-        regeneratedLe += getWert(WERT_MOD_REGENERATION_LE);
+        regeneratedLe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_WERTMOD, Effect::MODTAG_REGENERATION_LE);
         //Bei gelungener KO Probe addiere 1
         if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;, 
-            getWertStateSet(WERT_MOD_REGENERATION_LE)-&gt;getProbenModifier()))
+            0, Effect::MODTAG_REGENERATION_LE))
         {
             regeneratedLe++;
         }
@@ -861,10 +861,10 @@
         //Grundregeneration von 1W6
         int regeneratedAe = DsaManager::getSingleton().rollD6();
         //Addiere eventuelle Modifikatoren hinzu
-        regeneratedAe += getWert(WERT_MOD_REGENERATION_AE);
+        regeneratedAe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_WERTMOD, Effect::MODTAG_REGENERATION_AE);
         //Bei gelungener KO Probe addiere 1
         if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;IN&quot;, 
-            getWertStateSet(WERT_MOD_REGENERATION_AE)-&gt;getProbenModifier()))
+            0, Effect::MODTAG_REGENERATION_AE))
         {
             regeneratedAe++;
         }
@@ -903,7 +903,7 @@
             //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
             //Bei gelungener KO Probe addiere 1
             if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;, 
-                getWertStateSet(WERT_MOD_REGENERATION_LE)-&gt;getProbenModifier()))
+                0, mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_WERTMOD, Effect::MODTAG_REGENERATION_AU)))
             {
                 modifyAu(6*factor);
             }
@@ -1097,7 +1097,7 @@
             return 0;
 
 
-        int act_gs = getWert(Creature::WERT_GS);
+		int act_gs = getWert(WERT_GS);
         if( modified )
             act_gs -= getCurrentBe();
         if( act_gs &lt; 1 )

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -29,6 +29,7 @@
 #include &quot;Talent.h&quot;
 #include &quot;Person.h&quot;
 #include &quot;Kampftechnik.h&quot;
+#include &quot;RulesPrerequisites.h&quot;
 #include &quot;RulesSubsystem.h&quot;
 
 #include &quot;Exception.h&quot;
@@ -272,23 +273,23 @@
 			
 			AutoChar wertId = wertXml-&gt;getAttribute(ID.data());
 			if (strcmp(wertId.data(), &quot;Lebensenergie&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_LE, wert - basis);
+				rval-&gt;setWert(rl::Creature::WERT_MOD_LE, wert - basis);
 			else if (strcmp(wertId.data(), &quot;Ausdauer&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_AU, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_AU, wert - basis);
 			else if (strcmp(wertId.data(), &quot;AttackeBasis&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_AT, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_AT, wert - basis);
 			else if (strcmp(wertId.data(), &quot;ParadeBasis&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_PA, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_PA, wert - basis);
 			else if (strcmp(wertId.data(), &quot;FernkampfBasis&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_FK, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_FK, wert - basis);
 			else if (strcmp(wertId.data(), &quot;InitiativeBasis&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_INI, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_INI, wert - basis);
 			else if (strcmp(wertId.data(), &quot;Magieresistenz&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_MR, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_MR, wert - basis);
 			else if (strcmp(wertId.data(), &quot;Astralenergie&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_MOD_AE, wert - basis);
+                rval-&gt;setWert(rl::Creature::WERT_MOD_AE, wert - basis);
 			else if (strcmp(wertId.data(), &quot;Sozialstatus&quot;) == 0)
-                rval-&gt;setWert(Creature::WERT_SOZIALSTATUS, wert);
+                rval-&gt;setWert(rl::Creature::WERT_SOZIALSTATUS, wert);
 		}
 
 		// Talente laden

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -20,10 +20,7 @@
 
 namespace rl
 {
-  const CeGuiString Effect::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-  const CeGuiString Effect::ALL_TALENTE = &quot;alle Talente&quot;;
- 
-  
+   
 	Effect::Effect(int stufe)
 	{
 		mStufe = stufe;
@@ -160,7 +157,7 @@
         return (DsaManager::getSingleton().getTimestamp() - mStartTime);
 	}
     
-    Effect::Status Effect::getStatus()
+	Effect::Status Effect::getStatus()
     {
       // should be overlaoaded in the specific derivated effects.
       return STATUS_NONE;

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -134,6 +134,7 @@
     {
       checkEffects();
       int mod = 0;
+	  if (type == Effect::MODTYPE_WERTMULT) mod = 1;
       for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
       {
         mod += (*it)-&gt;getMod(target, type, tag);

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-04-11 19:12:16 UTC (rev 3253)
@@ -18,6 +18,8 @@
 
 	// Before first use of GameObject or subclasses!
 	%apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+        
+
 					
    template&lt;typename T&gt;
    class Tripel {
@@ -480,71 +482,44 @@
         virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
 	};
 	
-	class StateSet
-	{
-	public:
-		StateSet();
-		virtual ~StateSet();
 
-		virtual int getValue(bool getUnmodfiedValue = false) const;
-		virtual int getOriginalValue() const;
-		virtual void setOriginalValue(int newValue);
-		virtual int getModifier() const;
-		virtual void setModifier(int newModifier);
-		virtual void modifyModifier(int modifier);
-		virtual int getProbenModifier() const;
-		virtual void setProbenModifier(int newProbenModifier);
-		virtual void modifyProbenModifier(int modifier);
-		virtual int getMultiplier() const;
-		virtual void setMultiplier(int newMultiplier);
-	};
-
-	class EigenschaftenStateSet : public StateSet
-	{
-	public:
-		EigenschaftenStateSet();
-		~EigenschaftenStateSet();
-
-		int getStartValue();
-		void setStartValue( int newStartValue );
-		int getPermanentModifier();
-		void setPermanentModifier( int newPermanentModifier );
-		int getModifierWithoutRecalculation();
-		void setModifierWithoutRecalculation( int newModifierWithoutRecalculation );
-
-		int getValue( bool getUnmodifiedValue = false );
-		int getValueForBasiswertCalculation();
-	};
-	
-	class SonderfertigkeitenStateSet : public StateSet
-	{
-	public:
-		SonderfertigkeitenStateSet();
-		~SonderfertigkeitenStateSet();
-
-		void setModifier( int newModifier );
-		int getLehrmeisterZeiteinheiten();
-		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
-	};
-	
-	class TalentStateSet : public StateSet
-	{
-	public:
-		TalentStateSet();
-		~TalentStateSet();
-
-		bool getSe();
-		void setSe(bool newSe);
-		int getLehrmeisterZeiteinheiten();
-		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
-		int getSelbststudiumZeiteinheiten();
-		void setSelbststudiumZeiteinheiten( int newSelbststudiumZeiteinheiten );
-	};
-	
 	%feature(&quot;director&quot;) Effect;
 	class Effect
 	{
 	public:
+	
+    typedef unsigned long Status;
+    static const Status STATUS_NONE           = 1&lt;&lt;0;
+    static const Status STATUS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
+    static const Status STATUS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
+    static const Status STATUS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
+    static const Status STATUS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
+    static const Status STATUS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
+    static const Status STATUS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
+    static const Status STATUS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
+    static const Status STATUS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
+    static const Status STATUS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
+    static const Status STATUS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
+    static const Status STATUS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
+      
+      // Meta stati
+    static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
+      
+    typedef int ModType;
+    static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
+    static const ModType MODTYPE_WERTMOD      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
+    static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
+    static const ModType MODTYPE_WERTMULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
+    static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
+      
+    typedef unsigned long ModTag;
+    static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
+    static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
+    static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
+	  static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
+	  static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
+	  static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
+	
         enum Quantifier
         {
             QUANTIFIER_MULTIPLE,
@@ -559,36 +534,6 @@
             EFFECTTAG_KRANKHEIT
         };
         
-        static const CeGuiString ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-        static const CeGuiString ALL_TALENTE = &quot;alle Talente&quot;;
-        
-        typedef unsigned long Status;
-        static const Status STATUS_NONE           = 1&lt;&lt;0;
-        static const Status STATUS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
-        static const Status STATUS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
-        static const Status STATUS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
-        static const Status STATUS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
-        static const Status STATUS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const Status STATUS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
-        static const Status STATUS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
-        static const Status STATUS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
-        static const Status STATUS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
-        static const Status STATUS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
-        static const Status STATUS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
-      
-      // Meta stati
-        static const Status STATUS_IMMOBILE = STATUS_PARALYZED | STATUS_SLEEPING | STATUS_UNCONSCIOUS | STATUS_PETRIFIED | STATUS_DEAD;
-      
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
-        static const ModType MODTYPE_WERTMOD      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
-        static const ModType MODTYPE_WERTMULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
-      
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
 
       // other constants
         static const int REMOVE = -1;
@@ -641,25 +586,20 @@
     %feature(&quot;director&quot;) Creature;
     class Creature : public GameObject {
     public:
+    
+    typedef std::string Wert;
+        // some targets
+    const std::string ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+    const std::string ALL_TALENTE = &quot;alle Talente&quot;;
 
-        enum Wert
-        {
-            WERT_MOD_AE = 1, // Astralenergie
-            WERT_MOD_LE, // Lebensenergie
-            WERT_MOD_AT, // Attacke
-            WERT_MOD_PA, // Parade
-            WERT_MOD_FK, // Fernkampf
-            WERT_MOD_AU, // Ausdauer
-            WERT_MOD_MR, // Magieresistenz
-            WERT_MOD_INI, // Initiative
-            WERT_MOD_REGENERATION_LE, // Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
-            WERT_MOD_REGENERATION_AE, // Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
-            WERT_MOD_ERSCHOEPFUNGSSCHWELLE, // Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-            WERT_GS, // Geschwindigkeit
-            WERT_SOZIALSTATUS, // Sozialstatus
-            WERT_BE // Behinderung
-        };
-
+    static const Wert WERT_MOD_AE = &quot;ModAE&quot;;
+    static const Wert WERT_MOD_LE = &quot;ModLE&quot;;
+    static const Wert WERT_MOD_AU = &quot;ModAU&quot;;
+    static const Wert WERT_MOD_MR = &quot;ModMR&quot;;
+    static const Wert WERT_GS = &quot;GS&quot;;
+    static const Wert WERT_SOZIALSTATUS = &quot;SO&quot;;
+    static const Wert WERT_BE = &quot;BE&quot;;
+    static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
         Creature(unsigned int id);
         virtual ~Creature();
 
@@ -668,7 +608,7 @@
         virtual void modifyAe(int mod);
         virtual void modifyAu(int mod);
         void setWert(Wert wertId, int value);
-        virtual StateSet* getWertStateSet(Wert wertId);
+        virtual int getWert(Wert wertId, bool getUnmodified = false);
         
         virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
         virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
@@ -686,8 +626,6 @@
 		
         void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
         
-		virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const rl::CeGuiString sfName);
-
         virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
         virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
         

Modified: rl/trunk/engine/script/swig/TypeOgreString.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreString.swig	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/script/swig/TypeOgreString.swig	2007-04-11 19:12:16 UTC (rev 3253)
@@ -50,3 +50,7 @@
 
 %typemap(directorout) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
 &quot;    $result = new Ogre::String(StringValuePtr($1));&quot;
+
+%typemap(argout) Ogre::String, const Ogre::String
+&quot;    $result = rb_str_buf_new2($1.c_str());&quot;
+

Modified: rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2007-04-11 19:12:16 UTC (rev 3253)
@@ -55,4 +55,3 @@
     &quot;$result = new rl::CeGuiString();
      $result-&gt;append( 
 		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)) );&quot;
-

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-04-11 14:49:03 UTC (rev 3252)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-04-11 19:12:16 UTC (rev 3253)
@@ -128,7 +128,7 @@
             mCharacterActor-&gt;getControlledObject());
         AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
 
-        // wird sp&#228;ter neu berechnet in calculateOptimalCameraPosition
+        // wird sp&#239;&#191;&#189;er neu berechnet in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
         // The actor should be controlled manually,
@@ -205,7 +205,7 @@
     void MovementCharacterController::run(Real elapsedTime)
     {
         //int movement = mCharacterState.mCurrentMovementState;
-        //updateAnimationState(movement); // lasse updateAnimationState das &#228;ndern
+        //updateAnimationState(movement); // lasse updateAnimationState das &#239;&#191;&#189;dern
         //updateCharacterState(movement, elapsedTime);
         updateCharacterState(elapsedTime);
         updateCameraLookAt(elapsedTime);
@@ -269,7 +269,7 @@
         Real animSpeed = 1;
         static Real lastSpeed = 1;
         unsigned int animTimesToPlay = 0;
-        Real gs = mCharacter-&gt;getWert(Creature::WERT_GS);
+		Real gs = mCharacter-&gt;getWert(Creature::WERT_GS);
         static String lastCollisionPose = &quot;&quot;;
         String collisionPose = &quot;idle&quot;;
 
@@ -816,7 +816,7 @@
         // ---------------------------- show animation -----------------------------
         if (newAnimation != &quot;&quot;)
         {
-            // nur schneller nicht langsamer ausf&#252;hren!
+            // nur schneller nicht langsamer ausfhren!
             if (animSpeed &lt; 1) animSpeed = 1;
 
             if (lastAnimation != newAnimation)
@@ -845,7 +845,7 @@
             }
             else
             {
-                if ( lastSpeed != animSpeed ) // Geschwindigkeits&#228;nderung
+                if ( lastSpeed != animSpeed ) // Geschwindigkeits&#239;&#191;&#189;derung
                 {
                     MeshAnimation *meshAnim = mesh-&gt;getAnimation(newAnimation);
                     meshAnim-&gt;setSpeed(animSpeed);
@@ -901,7 +901,7 @@
         }
         else if( mViewMode == VM_THIRD_PERSON )
         {
-            // Kamera-Gr&#246;&#223;e beziehen
+            // Kamera-Gr&#239;&#191;&#189;e beziehen
             CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
                 mCameraActor-&gt;getControlledObject());
             AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
@@ -983,7 +983,7 @@
             getContactPositionAndNormal(point, normal);
 
             // determine if this contact is with the floor.
-            // Meaning the contact normal has an angle to UNIT_Y of 20&#176; or less.
+            // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
             Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
 
             Vector3 charPos;
@@ -1017,10 +1017,10 @@
             }
 
 
-            // beinflusst die Sprungh&#246;he!
-            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef&#228;hr um
-            // die angegebene Zahl h&#246;her (eher 2*die angegebene Zahl oder so,
-            // vermutlich wieder framedauer abh&#228;ngig!)
+            // beinflusst die Sprungh&#239;&#191;&#189;e!
+            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef&#239;&#191;&#189;r um
+            // die angegebene Zahl h&#239;&#191;&#189;er (eher 2*die angegebene Zahl oder so,
+            // vermutlich wieder framedauer abh&#239;&#191;&#189;gig!)
             setContactElasticity(0.3f); // was 0.3f
             setContactSoftness(0.01f);
 
@@ -1056,7 +1056,7 @@
         else
         {
             mCharacterState.mJumpTimer += timestep;
-            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum &quot;Sprung f&#252;hren&quot;
+            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum &quot;Sprung fhren&quot;
             if( !mCharacterState.mHasFloorContact )
                 timeSinceLastFloorContact += timestep;
             else
@@ -1138,7 +1138,7 @@
                 }
                 else
                 {
-                    Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh&#228;ngig von der framerate!
+                    Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh&#239;&#191;&#189;gig von der framerate!
                     if( mCharacterState.mDesiredVel.squaredLength() &lt; currentVel.squaredLength() )
                         delay *= 4;
                     force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
@@ -1257,7 +1257,7 @@
 
 
 
-        // Kamera-Gr&#246;&#223;e beziehen
+        // Kamera-Gr&#239;&#191;&#189;e beziehen
         CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
             mCameraActor-&gt;getControlledObject());
         AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
@@ -1286,9 +1286,9 @@
             RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
                 world,
                 materialId,
-                camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera einbeziehen
+                camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr&#246;&#223;e der Kamera einbeziehen
+                true); // Gr&#239;&#191;&#189;e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast-&gt;execute(
                 world,
@@ -1325,17 +1325,17 @@
                     RaycastInfo infoCastNewPos;
                     Real delta = lenToOptCamPos/2.0f;
                     Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann&#228;herung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    // Ann&#239;&#191;&#189;erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
                     while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
                     {
                         infoCastNewPos = mRaycast-&gt;execute(
                             world,
                             materialId,
-                            camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera!
+                            camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera!
                             temp,
                             true);
                         delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n&#228;her an Char ran
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n&#239;&#191;&#189;er an Char ran
                         {
                             temp = temp - delta * normToOptCamPos;
                         }
@@ -1345,9 +1345,9 @@
                         }
                     }
 
-                    // Jetzt k&#246;nnen wir sicher sein, dass diese Stelle erreichbar ist:
+                    // Jetzt k&#239;&#191;&#189;nen wir sicher sein, dass diese Stelle erreichbar ist:
                     temp = temp - 0.05 * normToOptCamPos;
-                    // Gr&#246;&#223;e der Kamera einbeziehen
+                    // Gr&#239;&#191;&#189;e der Kamera einbeziehen
                     optimalCamPos = temp - camRadius * normToOptCamPos;
                     // so ab hier kann ganz normal weiter gerechnet werden!
                 }
@@ -1356,7 +1356,7 @@
 
             static bool isPathfinding (false);
             static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten f&#252;r den
+            // gibt an, ob schon gebufferte Daten fr den
             // neuen Weg existieren und dort weitergemacht werden kann,
             // oder ob neu nach einem Weg gesucht werden muss!
             if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
@@ -1364,8 +1364,8 @@
                 // anderen Weg finden
                 // hier werden erstmal nur alte Player-Positionen betrachtet
                 // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
-                // und durch &quot;Geraden&quot; miteinander verbunden werden k&#246;nnen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fl&#252;ssig
+                // und durch &quot;Geraden&quot; miteinander verbunden werden k&#239;&#191;&#189;nen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
                 // und weich (keine scharfen Kurven) erscheinen
 
                 size_t buffSize = charPositionsBuffer.size();
@@ -1406,12 +1406,12 @@
                 }
                 else
                 {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergef&#252;hrt werden!&quot;);
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
 
 
                     // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
                     unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta &gt; 0 ) // delta = 0 braucht nicht &#252;berpr&#252;ft zu werden, wurde oben schon ausgeschlossen!
+                    while ( delta &gt; 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast-&gt;execute(
                             world,
@@ -1429,7 +1429,7 @@
                     // auf zu der ermittelten Position!
                     optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
                 }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Pr&#252;fung gleicher sachen)
+                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
             }
             else
             {
@@ -1496,7 +1496,7 @@
             }
 
 
-            // Kamera-Gr&#246;&#223;e beziehen
+            // Kamera-Gr&#239;&#191;&#189;e beziehen
             CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
                 mCameraActor-&gt;getControlledObject());
             AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
@@ -1517,7 +1517,7 @@
             endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
                                       // dadurch kann aber sichergestellt
                                       // werden, dass kein Objekt direkt
-                                      // hinter dem Helden &#252;bersehen wird
+                                      // hinter dem Helden bersehen wird
             startRay[1] = charPos + radiusOffset;
             endRay[1] = targetCamPos + radiusOffset;
             radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
@@ -1730,7 +1730,7 @@
         Vector3 interpolatedSize;
 
 
-        // Die Gr&#246;&#223;e der beiden Animationen abfragen
+        // Die Gr&#239;&#191;&#189;e der beiden Animationen abfragen
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
         aab = mesh-&gt;getPoseSize(actAnim);
         size[0] = aab.getMaximum() - aab.getMinimum();
@@ -1738,7 +1738,7 @@
         aab = mesh-&gt;getPoseSize(newAnim);
         size[1] = aab.getMaximum() - aab.getMinimum();
 
-        // interpolierte Gr&#246;&#223;e (linear) berechnen
+        // interpolierte Gr&#239;&#191;&#189;e (linear) berechnen
         interpolatedSize = size[0] + factor*(size[1] - size[0]);
 
         // LookAtOffset berechnen!


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000323.html">[Dsa-hl-svn] r3252 - in rl/trunk/engine: core/include core/src	rules/include rules/src script/swig ui/include ui/src
</A></li>
	<LI>Next message: <A HREF="000325.html">[Dsa-hl-svn] r3254 - in modules: common/scripts	common/scripts/effects regressiontest/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
