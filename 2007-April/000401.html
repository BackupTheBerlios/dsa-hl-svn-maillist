<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3331 - in tools/meshhandle/src/meshhandle: . data	io/xml io/xml/scene model/module model/scene sceneeditor ui
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3331%20-%20in%20tools/meshhandle/src/meshhandle%3A%20.%20data%0A%09io/xml%20io/xml/scene%20model/module%20model/scene%20sceneeditor%20ui&In-Reply-To=%3C200704260704.l3Q747Eu015440%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000407.html">
   <LINK REL="Next"  HREF="000402.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3331 - in tools/meshhandle/src/meshhandle: . data	io/xml io/xml/scene model/module model/scene sceneeditor ui</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3331%20-%20in%20tools/meshhandle/src/meshhandle%3A%20.%20data%0A%09io/xml%20io/xml/scene%20model/module%20model/scene%20sceneeditor%20ui&In-Reply-To=%3C200704260704.l3Q747Eu015440%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3331 - in tools/meshhandle/src/meshhandle: . data	io/xml io/xml/scene model/module model/scene sceneeditor ui">blakharaz at mail.berlios.de
       </A><BR>
    <I>Thu Apr 26 09:04:07 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000407.html">[Dsa-hl-svn] r3330 - modules/regressiontest/maps	modules/regressiontest/scripts modules/techdemo/maps	modules/techdemo/scripts rl/trunk/docs/documents	rl/trunk/engine/common/include rl/trunk/engine/rules	rl/trunk/engine/rules/include rl/trunk/engine/rules/src	rl/trunk/engine/script/swig
</A></li>
        <LI>Next message: <A HREF="000402.html">[Dsa-hl-svn] r3332 - tools/meshhandle
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#401">[ date ]</a>
              <a href="thread.html#401">[ thread ]</a>
              <a href="subject.html#401">[ subject ]</a>
              <a href="author.html#401">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-04-26 09:03:53 +0200 (Thu, 26 Apr 2007)
New Revision: 3331

Added:
   tools/meshhandle/src/meshhandle/SceneConverter.java
   tools/meshhandle/src/meshhandle/data/ColourValue.java
   tools/meshhandle/src/meshhandle/io/xml/scene/
   tools/meshhandle/src/meshhandle/io/xml/scene/AbstractSceneWriter.java
   tools/meshhandle/src/meshhandle/io/xml/scene/ISceneLoader.java
   tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Loader.java
   tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Writer.java
   tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat3Loader.java
   tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat4Writer.java
   tools/meshhandle/src/meshhandle/model/scene/GameObject.java
   tools/meshhandle/src/meshhandle/model/scene/Light.java
   tools/meshhandle/src/meshhandle/model/scene/LightAttenuation.java
   tools/meshhandle/src/meshhandle/model/scene/Sound.java
Removed:
   tools/meshhandle/src/meshhandle/io/xml/SceneLoader.java
Modified:
   tools/meshhandle/src/meshhandle/ImExportTest.java
   tools/meshhandle/src/meshhandle/MeshScaler.java
   tools/meshhandle/src/meshhandle/SceneScaler.java
   tools/meshhandle/src/meshhandle/SkeletonScaler.java
   tools/meshhandle/src/meshhandle/data/Quaternion.java
   tools/meshhandle/src/meshhandle/data/Vector3.java
   tools/meshhandle/src/meshhandle/io/xml/MeshLoader.java
   tools/meshhandle/src/meshhandle/io/xml/SkeletonLoader.java
   tools/meshhandle/src/meshhandle/io/xml/XMLLoader.java
   tools/meshhandle/src/meshhandle/model/module/Module.java
   tools/meshhandle/src/meshhandle/model/module/ModuleLoader.java
   tools/meshhandle/src/meshhandle/model/scene/Entity.java
   tools/meshhandle/src/meshhandle/model/scene/NodeUserData.java
   tools/meshhandle/src/meshhandle/model/scene/Scene.java
   tools/meshhandle/src/meshhandle/model/scene/SceneNode.java
   tools/meshhandle/src/meshhandle/sceneeditor/SceneEditor.java
   tools/meshhandle/src/meshhandle/sceneeditor/SceneTreeCreator.java
   tools/meshhandle/src/meshhandle/ui/MeshHandlerWindow.java
Log:
* Added support for loading and saving different scene format versions
* Added scene converter class
* Some minor interface changes

Modified: tools/meshhandle/src/meshhandle/ImExportTest.java
===================================================================
--- tools/meshhandle/src/meshhandle/ImExportTest.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/ImExportTest.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -23,7 +23,7 @@
 	 */
 	public static void main(String[] args) {
 		try {
-			Mesh testmesh = MeshLoader
+			Mesh testmesh = new MeshLoader()
 					.readMesh(&quot;D:/Eigene Dateien/Java/meshhandle2/Mr_Cylinder.mesh.xml&quot;);
 			FileWriter writer = new FileWriter(
 					&quot;D:/Eigene Dateien/Java/meshhandle2/Mr_Cylinder2.mesh.xml&quot;);
@@ -70,7 +70,7 @@
 			e.printStackTrace();
 		}
 		try {
-			Skeleton testskel = SkeletonLoader
+			Skeleton testskel = new SkeletonLoader()
 					.readSkeleton(&quot;D:/Eigene Dateien/Java/meshhandle2/Mr_Cylinder_mesh.skeleton.xml&quot;);
 			FileWriter writer = new FileWriter(
 					&quot;D:/Eigene Dateien/Java/meshhandle2/Mr_Cylinder2_mesh.skeleton.xml&quot;);

Modified: tools/meshhandle/src/meshhandle/MeshScaler.java
===================================================================
--- tools/meshhandle/src/meshhandle/MeshScaler.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/MeshScaler.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -44,7 +44,7 @@
         }
 
         System.out.println(&quot;processing &quot; + inputFile);
-        Mesh mesh = MeshLoader.readMesh(inputFile);
+        Mesh mesh = new MeshLoader().readMesh(inputFile);
         mesh.scale(factor);
         FileWriter outFile = new FileWriter(outputFile, false);
         outFile.write(mesh.toXML());

Added: tools/meshhandle/src/meshhandle/SceneConverter.java
===================================================================
--- tools/meshhandle/src/meshhandle/SceneConverter.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/SceneConverter.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,65 @@
+package meshhandle;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import javax.xml.parsers.ParserConfigurationException;
+import org.xml.sax.SAXException;
+import meshhandle.io.xml.scene.AbstractSceneWriter;
+import meshhandle.io.xml.scene.ISceneLoader;
+import meshhandle.io.xml.scene.SceneFormat2Loader;
+import meshhandle.io.xml.scene.SceneFormat3Loader;
+import meshhandle.model.scene.Scene;
+
+public class SceneConverter
+{
+	/**
+	 * @param args
+	 * @throws IOException 
+	 * @throws SAXException 
+	 * @throws ParserConfigurationException 
+	 */
+	public static void main(String[] args) throws IOException, ParserConfigurationException, SAXException
+	{
+		String infile = null;
+		String outfile = null;
+		String version = null;
+
+		for (int idx = 0; idx &lt; args.length; idx++)
+		{
+			String curParam = args[idx];
+			if (curParam.equals(&quot;--input&quot;))
+			{
+				infile = args[idx+1];
+				idx++;
+			}
+			else if (curParam.equals(&quot;--output&quot;))
+			{
+				outfile = args[idx+1];
+				idx++;
+			}
+			else if (curParam.equals(&quot;--outputformat&quot;))
+			{
+				version = args[idx+1];
+				idx++;
+			}
+		}
+		
+		if (infile == null || version == null)
+		{
+			System.exit(0);
+		}
+		
+		if (outfile == null)
+		{
+			outfile = infile.substring(0, infile.lastIndexOf(&quot;.&quot;)) + &quot;_out.xml&quot;;
+		}
+		
+		ISceneLoader sceneLoader = new SceneFormat3Loader();
+		Scene scene = sceneLoader.readScene(infile);
+		FileWriter outputWriter = new FileWriter(new File(outfile));
+		AbstractSceneWriter sceneWriter = AbstractSceneWriter.createSceneWriter(version, outputWriter);
+		sceneWriter.write(scene);
+		outputWriter.close();
+	}
+}

Modified: tools/meshhandle/src/meshhandle/SceneScaler.java
===================================================================
--- tools/meshhandle/src/meshhandle/SceneScaler.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/SceneScaler.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -4,12 +4,10 @@
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
-
 import javax.xml.parsers.ParserConfigurationException;
-
-import meshhandle.io.xml.SceneLoader;
+import meshhandle.io.xml.scene.SceneFormat2Loader;
+import meshhandle.io.xml.scene.SceneFormat2Writer;
 import meshhandle.model.scene.Scene;
-
 import org.xml.sax.SAXException;
 
 public class SceneScaler {
@@ -44,10 +42,10 @@
         }
 
         System.out.println(&quot;processing &quot; + inputFile);
-        Scene scene = SceneLoader.readScene(inputFile);
+        Scene scene = new SceneFormat2Loader().readScene(inputFile);
         scene.scale(factor);
         FileWriter outFile = new FileWriter(outputFile, false);
-        outFile.write(scene.toXML());
+        new SceneFormat2Writer(outFile).write(scene);
         outFile.flush();
     }
 }

Modified: tools/meshhandle/src/meshhandle/SkeletonScaler.java
===================================================================
--- tools/meshhandle/src/meshhandle/SkeletonScaler.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/SkeletonScaler.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -44,7 +44,7 @@
         }
 
         System.out.println(&quot;processing &quot; + inputFile);
-        Skeleton skel = SkeletonLoader.readSkeleton(inputFile);
+        Skeleton skel = new SkeletonLoader().readSkeleton(inputFile);
         skel.scale(factor);
         FileWriter outFile = new FileWriter(outputFile, false);
         outFile.write(skel.toXML());

Added: tools/meshhandle/src/meshhandle/data/ColourValue.java
===================================================================
--- tools/meshhandle/src/meshhandle/data/ColourValue.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/data/ColourValue.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,45 @@
+package meshhandle.data;
+
+public class ColourValue {
+    private float mG, mB, mR;
+
+    public ColourValue(float r, float g, float b) {
+        mR = r;
+        mG = g;
+        mB = b;
+    }
+
+    public float getG() {
+        return mG;
+    }
+
+    public void setG(float x) {
+        mG = x;
+    }
+
+    public float getB() {
+        return mB;
+    }
+
+    public void setB(float y) {
+        mB = y;
+    }
+
+    public String toXML(String nodeName) {
+        return &quot;&lt;&quot; + nodeName + &quot; r=\&quot;&quot; + round(mR) + &quot;\&quot;&quot; + &quot; g=\&quot;&quot;
+                + round(mG) + &quot;\&quot;&quot; + &quot; b=\&quot;&quot; + round(mB) + &quot;\&quot;/&gt;&quot;;
+    }
+
+    private float round(float y) {
+        return Math.abs(y) &lt; 1E-5 ? 0 : y;
+    }
+
+    public float getR() {
+        return mR;
+    }
+
+    public void setR(float w) {
+        mR = w;
+    }
+
+}

Modified: tools/meshhandle/src/meshhandle/data/Quaternion.java
===================================================================
--- tools/meshhandle/src/meshhandle/data/Quaternion.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/data/Quaternion.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,73 +1,73 @@
 package meshhandle.data;
 
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
+public class Quaternion
+{
+	private float mX, mY, mZ, mW;
 
-public class Quaternion {
-    private float mX, mY, mZ, mW;
+	public Quaternion(float w, float x, float y, float z)
+	{
+		mW = w;
+		mX = x;
+		mY = y;
+		mZ = z;
+	}
 
-    public Quaternion(float w, float x, float y, float z) {
-        mW = w;
-        mX = x;
-        mY = y;
-        mZ = z;
-    }
+	public float getX()
+	{
+		return mX;
+	}
 
-    public float getX() {
-        return mX;
-    }
+	public void setX(float x)
+	{
+		mX = x;
+	}
 
-    public void setX(float x) {
-        mX = x;
-    }
+	public float getY()
+	{
+		return mY;
+	}
 
-    public float getY() {
-        return mY;
-    }
+	public void setY(float y)
+	{
+		mY = y;
+	}
 
-    public void setY(float y) {
-        mY = y;
-    }
+	public float getZ()
+	{
+		return mZ;
+	}
 
-    public float getZ() {
-        return mZ;
-    }
+	public void setZ(float z)
+	{
+		mZ = z;
+	}
 
-    public void setZ(float z) {
-        mZ = z;
-    }
+	public void scale(float factor)
+	{
+		mX *= factor;
+		mY *= factor;
+		mZ *= factor;
+	}
 
-    public void scale(float factor) {
-        mX *= factor;
-        mY *= factor;
-        mZ *= factor;
-    }
+	public String toXML(String nodeName)
+	{
+		return &quot;&lt;&quot; + nodeName + &quot; qw=\&quot;&quot; + round(mW) + &quot;\&quot;&quot; + &quot; qx=\&quot;&quot;
+				+ round(mX) + &quot;\&quot;&quot; + &quot; qy=\&quot;&quot; + round(mY) + &quot;\&quot;&quot; + &quot; qz=\&quot;&quot;
+				+ round(mZ) + &quot;\&quot;/&gt;&quot;;
+	}
 
-    public static Quaternion createFromXML(Node node) {
-        NamedNodeMap attrs = node.getAttributes();
-        return new Quaternion(Float.parseFloat(attrs.getNamedItem(&quot;qw&quot;)
-                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qx&quot;)
-                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qy&quot;)
-                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qz&quot;)
-                .getNodeValue()));
-    }
+	private float round(float y)
+	{
+		return Math.abs(y) &lt; 1E-5 ? 0 : y;
+	}
 
-    public String toXML(String nodeName) {
-        return &quot;&lt;&quot; + nodeName + &quot; qw=\&quot;&quot; + round(mW) + &quot;\&quot;&quot; + &quot; qx=\&quot;&quot;
-                + round(mX) + &quot;\&quot;&quot; + &quot; qy=\&quot;&quot; + round(mY) + &quot;\&quot;&quot; + &quot; qz=\&quot;&quot;
-                + round(mZ) + &quot;\&quot;/&gt;&quot;;
-    }
+	public float getW()
+	{
+		return mW;
+	}
 
-    private float round(float y) {
-        return Math.abs(y) &lt; 1E-5 ? 0 : y;
-    }
-
-    public float getW() {
-        return mW;
-    }
-
-    public void setW(float w) {
-        mW = w;
-    }
-
+	public void setW(float w)
+	{
+		mW = w;
+	}
 }

Modified: tools/meshhandle/src/meshhandle/data/Vector3.java
===================================================================
--- tools/meshhandle/src/meshhandle/data/Vector3.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/data/Vector3.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,7 +1,5 @@
 package meshhandle.data;
 
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
 
 public class Vector3 {
     private float mX, mY, mZ;
@@ -42,14 +40,6 @@
         mZ *= factor;
     }
 
-    public static Vector3 createFromXML(Node node) {
-        NamedNodeMap attrs = node.getAttributes();
-        return new Vector3(Float.parseFloat(attrs.getNamedItem(&quot;x&quot;)
-                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;y&quot;)
-                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;z&quot;)
-                .getNodeValue()));
-    }
-
     public String toXML(String nodeName) {
         return &quot;&lt;&quot; + nodeName + &quot; x=\&quot;&quot; + round(mX) + &quot;\&quot;&quot; + &quot; y=\&quot;&quot;
                 + round(mY) + &quot;\&quot;&quot; + &quot; z=\&quot;&quot; + round(mZ) + &quot;\&quot;/&gt;&quot;;

Modified: tools/meshhandle/src/meshhandle/io/xml/MeshLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/MeshLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/MeshLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,10 +1,7 @@
 package meshhandle.io.xml;
 
 import java.io.IOException;
-
 import javax.xml.parsers.ParserConfigurationException;
-
-import meshhandle.data.Vector3;
 import meshhandle.model.mesh.Face;
 import meshhandle.model.mesh.Mesh;
 import meshhandle.model.mesh.Submesh;
@@ -13,7 +10,6 @@
 import meshhandle.model.mesh.Vertex;
 import meshhandle.model.mesh.VertexBoneAssignment;
 import meshhandle.model.mesh.VertexBufferData;
-
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
@@ -26,7 +22,7 @@
 		return face;
 	}
 
-	private static Submesh processSubmesh(Element submeshElem) {
+	private Submesh processSubmesh(Element submeshElem) {
 		Submesh submesh = new Submesh();
 		submesh.setMaterial(submeshElem.getAttribute(&quot;material&quot;));
 		submesh.setUse32bitIndices(submeshElem.getAttribute(&quot;use32bitindexes&quot;)
@@ -79,17 +75,17 @@
 		return texture;
 	}
 
-	private static Vertex processVertex(Element vertElem) {
+	private Vertex processVertex(Element vertElem) {
 		Vertex vert = new Vertex();
 		Element normalElem = (Element) vertElem.getElementsByTagName(&quot;normal&quot;)
 				.item(0);
 		if (normalElem != null) {
-			vert.setNormal(Vector3.createFromXML(normalElem));
+			vert.setNormal(processVector3(normalElem));
 		}
 		Element positionElem = (Element) vertElem.getElementsByTagName(
 				&quot;position&quot;).item(0);
 		if (positionElem != null) {
-			vert.setPosition(Vector3.createFromXML(positionElem));
+			vert.setPosition(processVector3(positionElem));
 		}
 		NodeList texCoordElems = vertElem.getElementsByTagName(&quot;texcoord&quot;);
 		for (int idx = 0; idx &lt; texCoordElems.getLength(); idx++) {
@@ -123,7 +119,7 @@
 		return assignment;
 	}
 
-	private static VertexBufferData processVertexBuffer(Element vertexBufferElem) {
+	private VertexBufferData processVertexBuffer(Element vertexBufferElem) {
 		VertexBufferData vertexbuffer = new VertexBufferData();
 		vertexbuffer.setNormals(vertexBufferElem.getAttribute(&quot;normals&quot;)
 				.equals(&quot;true&quot;));
@@ -161,7 +157,7 @@
 		return vertexbuffer;
 	}
 
-	public static Mesh readMesh(String fileName)
+	public Mesh readMesh(String fileName)
 			throws ParserConfigurationException, SAXException, IOException {
 		Document doc = readDocument(fileName);
 

Deleted: tools/meshhandle/src/meshhandle/io/xml/SceneLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/SceneLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/SceneLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,137 +0,0 @@
-package meshhandle.io.xml;
-
-import java.io.IOException;
-import javax.xml.parsers.ParserConfigurationException;
-import meshhandle.data.Quaternion;
-import meshhandle.data.Vector3;
-import meshhandle.model.scene.Entity;
-import meshhandle.model.scene.NodeUserData;
-import meshhandle.model.scene.Scene;
-import meshhandle.model.scene.SceneNode;
-import meshhandle.model.scene.SceneUserData;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NodeList;
-import org.xml.sax.SAXException;
-
-public class SceneLoader extends XMLLoader
-{
-	public static Scene readScene(String fileName)
-			throws ParserConfigurationException, SAXException, IOException
-	{
-		Document doc = readDocument(fileName);
-		Element sceneElem = (Element)doc.getElementsByTagName(&quot;scene&quot;).item(0);
-		Scene scene = new Scene(sceneElem.getAttribute(&quot;formatVersion&quot;));
-		NodeList nodeNodeList = sceneElem.getElementsByTagName(&quot;node&quot;);
-		for (int idx = 0; idx &lt; nodeNodeList.getLength(); idx++)
-		{
-			SceneNode scenenode = processNode((Element)nodeNodeList.item(idx));
-			scene.addNode(scenenode);
-		}
-		nodeNodeList = sceneElem.getElementsByTagName(&quot;userData&quot;);
-		for (int idx = 0; idx &lt; nodeNodeList.getLength(); idx++)
-		{
-			Element elem = (Element)nodeNodeList.item(idx);
-			if (elem.getParentNode() == sceneElem)
-			{
-				SceneUserData sceneUserData = processSceneUserData(elem);
-				scene.addUserData(sceneUserData);
-			}
-		}
-		return scene;
-	}
-
-	private static SceneUserData processSceneUserData(Element userDataElem)
-	{
-		SceneUserData sceneUserData = new SceneUserData();
-		NodeList nl = userDataElem.getElementsByTagName(&quot;property&quot;);
-		for (int i = 0; i &lt; nl.getLength(); ++i)
-		{
-			Element elem = (Element)nl.item(i);
-			if (elem.getAttribute(&quot;name&quot;).equals(&quot;default_renderingdistance&quot;))
-			{
-				sceneUserData.setDefaultRenderingDistance(Float.parseFloat(elem
-						.getAttribute(&quot;data&quot;)));
-			}
-		}
-		return sceneUserData;
-	}
-
-	private static SceneNode processNode(Element sceneNodeElem)
-	{
-		SceneNode scenenode = new SceneNode(sceneNodeElem.getAttribute(&quot;name&quot;));
-		Element elem = (Element)sceneNodeElem.getElementsByTagName(&quot;position&quot;)
-				.item(0);
-		if (elem != null)
-		{
-			scenenode.setPosition(Vector3.createFromXML(elem));
-		}
-		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;scale&quot;).item(0);
-		if (elem != null)
-		{
-			scenenode.setScale(Vector3.createFromXML(elem));
-		}
-		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;rotation&quot;).item(0);
-		if (elem != null)
-		{
-			scenenode.setRotation(Quaternion.createFromXML(elem));
-		}
-		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;entity&quot;).item(0);
-		if (elem != null)
-		{
-			scenenode.setEntity(processEntity(elem));
-		}
-		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;entity&quot;).item(0);
-		if (elem != null)
-		{
-			scenenode.setEntity(processEntity(elem));
-		}
-		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;userdata&quot;).item(0);
-		if (elem != null)
-		{
-			scenenode.setUserData(processNodeUserData(elem));
-		}
-		return scenenode;
-	}
-
-	private static Entity processEntity(Element elem)
-	{
-		String name = elem.getAttribute(&quot;name&quot;);
-		String file = elem.getAttribute(&quot;meshFile&quot;);
-		Entity entity = new Entity(name, file);
-		if (elem.hasAttribute(&quot;id&quot;))
-		{
-			entity.setId(elem.getAttribute(&quot;id&quot;));
-		}
-		if (elem.hasAttribute(&quot;castsShadows&quot;))
-		{
-			entity.setCastsShadows(Boolean.valueOf(elem.getAttribute(&quot;castsShadows&quot;)));
-		}
-		return entity;
-	}
-
-	private static NodeUserData processNodeUserData(Element userDataElem)
-	{
-		NodeUserData nodeUserData = new NodeUserData();
-		NodeList nl = userDataElem.getElementsByTagName(&quot;property&quot;);
-		for (int i = 0; i &lt; nl.getLength(); ++i)
-		{
-			Element elem = (Element)nl.item(i);
-			if (elem.getAttribute(&quot;name&quot;).equals(&quot;renderingdistance&quot;))
-			{
-				nodeUserData.setRenderingDistance(Float.parseFloat(elem
-						.getAttribute(&quot;data&quot;)));
-			}
-			else if (elem.getAttribute(&quot;name&quot;).equals(&quot;staticgeom_group&quot;))
-			{
-				nodeUserData.setStaticGeomGroup(Integer.parseInt(elem
-						.getAttribute(&quot;data&quot;)));
-			}
-			else if (elem.getAttribute(&quot;name&quot;).equals(&quot;physical_body&quot;))
-			{
-				nodeUserData.setPhysicalBody(elem.getAttribute(&quot;data&quot;));
-			}
-		}
-		return nodeUserData;
-	}
-}

Modified: tools/meshhandle/src/meshhandle/io/xml/SkeletonLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/SkeletonLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/SkeletonLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,17 +1,13 @@
 package meshhandle.io.xml;
 
 import java.io.IOException;
-
 import javax.xml.parsers.ParserConfigurationException;
-
-import meshhandle.data.Vector3;
 import meshhandle.model.skeleton.Animation;
 import meshhandle.model.skeleton.AnimationLink;
 import meshhandle.model.skeleton.AnimationTrack;
 import meshhandle.model.skeleton.Bone;
 import meshhandle.model.skeleton.Keyframe;
 import meshhandle.model.skeleton.Skeleton;
-
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
@@ -20,7 +16,7 @@
 import org.xml.sax.SAXException;
 
 public class SkeletonLoader extends XMLLoader {
-    public static Skeleton readSkeleton(String filename) throws SAXException,
+    public Skeleton readSkeleton(String filename) throws SAXException,
             ParserConfigurationException, IOException {
         Document document = readDocument(filename);
 
@@ -38,16 +34,16 @@
         return skel;
     }
 
-	private static void processBones(Skeleton skel, Element bonesNode) {
+	private void processBones(Skeleton skel, Element bonesNode) {
         NodeList bonesList = bonesNode.getElementsByTagName(&quot;bone&quot;);
         for (int idx = 0; idx &lt; bonesList.getLength(); idx++) {
             Element boneNode = (Element) bonesList.item(idx);
             Bone bone = new Bone(Integer.parseInt(boneNode.getAttributes()
                     .getNamedItem(&quot;id&quot;).getNodeValue()), boneNode
                     .getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());
-            bone.setPosition(Vector3.createFromXML(boneNode
+            bone.setPosition(processVector3(boneNode
                     .getElementsByTagName(&quot;position&quot;).item(0)));
-            bone.setRotationAxis(Vector3.createFromXML(boneNode
+            bone.setRotationAxis(processVector3(boneNode
                     .getElementsByTagName(&quot;axis&quot;).item(0)));
             bone.setRotationAngle(Float.parseFloat(boneNode
                     .getElementsByTagName(&quot;rotation&quot;).item(0).getAttributes()
@@ -56,7 +52,7 @@
         }
     }
 
-    private static void processBoneHierarchy(Skeleton skel,
+    private void processBoneHierarchy(Skeleton skel,
             Element hierarchyNode) {
         NodeList parentRelList = hierarchyNode
                 .getElementsByTagName(&quot;boneparent&quot;);
@@ -69,7 +65,7 @@
         }
     }
 
-    private static void processAnimations(Skeleton skel, Element animationsNode) {
+    private void processAnimations(Skeleton skel, Element animationsNode) {
     	if (animationsNode != null)
     	{
 	        NodeList animationList = animationsNode
@@ -86,7 +82,7 @@
 
     }
 
-    private static void processAnimationTracks(Animation anim,
+    private void processAnimationTracks(Animation anim,
             NodeList trackList) {
         for (int idx = 0; idx &lt; trackList.getLength(); idx++) {
             Element trackElem = (Element) trackList.item(idx);
@@ -97,7 +93,7 @@
         }
     }
 
-    private static void processKeyFrames(AnimationTrack track,
+    private void processKeyFrames(AnimationTrack track,
             NodeList keyframeList) {
         for (int idx = 0; idx &lt; keyframeList.getLength(); idx++) {
             Element keyframeElem = (Element) keyframeList.item(idx);
@@ -112,7 +108,7 @@
             if (rotateElem != null) {
                 keyframe.setRotationAngle(Float.parseFloat(rotateElem
                         .getAttributes().getNamedItem(&quot;angle&quot;).getNodeValue()));
-                keyframe.setRotationAxis(Vector3.createFromXML(keyframeElem
+                keyframe.setRotationAxis(processVector3(keyframeElem
                         .getElementsByTagName(&quot;axis&quot;).item(0)));
             }
 
@@ -120,20 +116,20 @@
                     .getElementsByTagName(&quot;translate&quot;).item(0);
 
             if (translateElem != null) {
-                keyframe.setTranslation(Vector3.createFromXML(translateElem));
+                keyframe.setTranslation(processVector3(translateElem));
             }
 
             Element scaleElem = (Element) keyframeElem.getElementsByTagName(
                     &quot;scale&quot;).item(0);
 
             if (scaleElem != null) {
-                keyframe.setScale(Vector3.createFromXML(scaleElem));
+                keyframe.setScale(processVector3(scaleElem));
             }
             track.addKeyframe(keyframe);
         }
     }
 
-    private static void processAnimationLinks(Skeleton skel, Element animationLinksElement) {
+    private void processAnimationLinks(Skeleton skel, Element animationLinksElement) {
     	if (animationLinksElement != null)
     	{
     		NodeList keyframeList = animationLinksElement.getElementsByTagName(&quot;animationlink&quot;);

Modified: tools/meshhandle/src/meshhandle/io/xml/XMLLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/XMLLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/XMLLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -7,7 +7,12 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
+import meshhandle.data.ColourValue;
+import meshhandle.data.Quaternion;
+import meshhandle.data.Vector3;
 import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
 import org.xml.sax.SAXException;
 
 public class XMLLoader {
@@ -18,4 +23,33 @@
         Document document = builder.parse(new File(filename));
         return document;
     }
+    
+    protected ColourValue processColourValue(Node node) {
+        NamedNodeMap attrs = node.getAttributes();
+        return new ColourValue(Float.parseFloat(attrs.getNamedItem(&quot;r&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;g&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;b&quot;)
+                .getNodeValue()));
+    }
+    
+    protected Quaternion processQuaternion(Node node) {
+        NamedNodeMap attrs = node.getAttributes();
+        return new Quaternion(Float.parseFloat(attrs.getNamedItem(&quot;qw&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qx&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qy&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;qz&quot;)
+                .getNodeValue()));
+    }
+
+    protected Vector3 processVector3(Node node) {
+        NamedNodeMap attrs = node.getAttributes();
+        return new Vector3(Float.parseFloat(attrs.getNamedItem(&quot;x&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;y&quot;)
+                .getNodeValue()), Float.parseFloat(attrs.getNamedItem(&quot;z&quot;)
+                .getNodeValue()));
+    }
+
+
+
+
 }

Added: tools/meshhandle/src/meshhandle/io/xml/scene/AbstractSceneWriter.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/AbstractSceneWriter.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/AbstractSceneWriter.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,69 @@
+package meshhandle.io.xml.scene;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.Writer;
+
+import meshhandle.model.scene.Entity;
+import meshhandle.model.scene.Light;
+import meshhandle.model.scene.NodeUserData;
+import meshhandle.model.scene.Scene;
+import meshhandle.model.scene.SceneNode;
+import meshhandle.model.scene.SceneUserData;
+
+public abstract class AbstractSceneWriter
+{
+	protected BufferedWriter mOutput;
+
+	public AbstractSceneWriter(Writer outputStreamWriter)
+	{
+		mOutput = new BufferedWriter(outputStreamWriter);
+	}
+	
+	public static AbstractSceneWriter createSceneWriter(String format, Writer outputWriter)
+	{
+		if (format.equals(SceneFormat2Writer.FORMAT_STRING))
+		{
+			return new SceneFormat2Writer(outputWriter);
+		}
+		
+		if (format.equals(SceneFormat4Writer.FORMAT_STRING))
+		{
+			return new SceneFormat4Writer(outputWriter);
+		}
+		
+		return null;
+	}
+	
+	public abstract void write(SceneUserData scene) throws IOException;
+	public abstract void write(Entity entity) throws IOException;
+	public abstract void write(Light light) throws IOException;
+	public abstract void write(NodeUserData scene) throws IOException;
+
+	public void write(Scene scene) throws IOException
+	{
+		mOutput.append(&quot;&lt;scene formatVersion=\&quot;&quot; + getFormatVersion() + &quot;\&quot;&gt;\n&quot;);
+	    mOutput.append(&quot;    &lt;nodes&gt;\n&quot;);
+	    for (SceneNode node : scene.getNodes()) 
+	    {
+	    	if (node instanceof Entity)
+			{
+				write((Entity)node);
+			}
+			else if (node instanceof Light)
+			{
+				write((Light)node);
+			}        	
+	        mOutput.append(&quot;\n&quot;);
+	    }
+	    mOutput.append(&quot;    &lt;/nodes&gt;\n&quot;);
+	    if (scene.getUserData() != null)
+		{
+			write(scene.getUserData());
+		}
+	    mOutput.append(&quot;&lt;/scene&gt;&quot;);
+	    mOutput.flush();
+	}
+
+	protected abstract String getFormatVersion();
+}

Added: tools/meshhandle/src/meshhandle/io/xml/scene/ISceneLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/ISceneLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/ISceneLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,15 @@
+package meshhandle.io.xml.scene;
+
+import java.io.IOException;
+import javax.xml.parsers.ParserConfigurationException;
+import meshhandle.model.scene.Scene;
+import org.xml.sax.SAXException;
+
+public interface ISceneLoader
+{
+
+	public Scene readScene(String fileName) throws ParserConfigurationException,
+			SAXException, IOException;
+	
+	public String getFormatVersion();
+}

Added: tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Loader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Loader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Loader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,178 @@
+package meshhandle.io.xml.scene;
+
+import java.io.IOException;
+import javax.xml.parsers.ParserConfigurationException;
+import meshhandle.io.xml.XMLLoader;
+import meshhandle.model.scene.Entity;
+import meshhandle.model.scene.Light;
+import meshhandle.model.scene.NodeUserData;
+import meshhandle.model.scene.Scene;
+import meshhandle.model.scene.SceneNode;
+import meshhandle.model.scene.SceneUserData;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.SAXException;
+
+public class SceneFormat2Loader extends XMLLoader implements ISceneLoader
+{
+	public Scene readScene(String fileName)
+			throws ParserConfigurationException, SAXException, IOException
+	{
+		Document doc = readDocument(fileName);
+		Element sceneElem = (Element)doc.getFirstChild();
+		Scene scene = new Scene();
+		NodeList nodeNodeList = sceneElem.getElementsByTagName(&quot;node&quot;);
+		for (int idx = 0; idx &lt; nodeNodeList.getLength(); idx++)
+		{
+			SceneNode scenenode = processNode((Element)nodeNodeList.item(idx));
+			scene.addNode(scenenode);
+		}
+		for (int idx = 0; idx &lt; nodeNodeList.getLength(); idx++)
+		{
+			Element elem = (Element)nodeNodeList.item(idx);
+			if (elem.getParentNode() == sceneElem)
+			{
+				SceneUserData sceneUserData = processSceneUserData(elem);
+				scene.addUserData(sceneUserData);
+			}
+		}
+		return scene;
+	}
+
+	public String getFormatVersion()
+	{
+		return &quot;0.2.0&quot;;
+	}
+	
+	protected SceneUserData processSceneUserData(Element userDataElem)
+	{
+		SceneUserData sceneUserData = new SceneUserData();
+		NodeList nl = userDataElem.getElementsByTagName(&quot;property&quot;);
+		for (int i = 0; i &lt; nl.getLength(); ++i)
+		{
+			Element elem = (Element)nl.item(i);
+			if (elem.getAttribute(&quot;name&quot;).equals(&quot;default_renderingdistance&quot;))
+			{
+				sceneUserData.setDefaultRenderingDistance(Float.parseFloat(elem
+						.getAttribute(&quot;data&quot;)));
+			}
+		}
+		return sceneUserData;
+	}
+
+	protected SceneNode processNode(Element sceneNodeElem)
+	{
+		SceneNode scenenode = null;
+		
+		Element elem = (Element)sceneNodeElem.getElementsByTagName(&quot;entity&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode = processEntity(elem);
+		}
+
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;light&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode = processLight(elem);
+		}
+
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;position&quot;)
+				.item(0);
+		if (elem != null)
+		{
+			scenenode.setPosition(processVector3(elem));
+		}
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;scale&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode.setScale(processVector3(elem));
+		}
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;rotation&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode.setRotation(processQuaternion(elem));
+		}
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;userdata&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode.setUserData(processNodeUserData(elem));
+		}
+		return scenenode;
+	}
+
+	protected Entity processEntity(Element elem)
+	{
+		String name = elem.getAttribute(&quot;name&quot;);
+		String file = elem.getAttribute(&quot;meshFile&quot;);
+		Entity entity = new Entity(name, file);
+		if (elem.hasAttribute(&quot;id&quot;))
+		{
+			entity.setId(elem.getAttribute(&quot;id&quot;));
+		}
+		if (elem.hasAttribute(&quot;castShadow&quot;))
+		{
+			entity.setCastShadow(Boolean.valueOf(elem.getAttribute(&quot;castShadow&quot;)));
+		}
+		return entity;
+	}
+	
+	protected Light processLight(Element elem)
+	{
+		String name = elem.getAttribute(&quot;name&quot;);
+		Light light = new Light(name);
+		
+		if (elem.hasAttribute(&quot;id&quot;))
+		{
+			light.setId(elem.getAttribute(&quot;id&quot;));
+		}
+
+		String type = elem.getAttribute(&quot;type&quot;);
+		light.setType(type);
+		
+		if (elem.hasAttribute(&quot;visible&quot;))
+		{
+			boolean visible = Boolean.parseBoolean(elem.getAttribute(&quot;visible&quot;));
+			light.setVisible(visible);
+		}
+		
+		Node diffColElem = elem.getElementsByTagName(&quot;colourDiffuse&quot;).item(0);
+		if (diffColElem != null)
+		{
+			light.setDiffuseColour(processColourValue(diffColElem));
+		}
+		Node specColElem = elem.getElementsByTagName(&quot;colourSpecular&quot;).item(0);
+		if (specColElem != null)
+		{
+			light.setDiffuseColour(processColourValue(specColElem));
+		}
+		
+		return light;
+	}
+
+	protected NodeUserData processNodeUserData(Element userDataElem)
+	{
+		NodeUserData nodeUserData = new NodeUserData();
+		NodeList nl = userDataElem.getElementsByTagName(&quot;property&quot;);
+		for (int i = 0; i &lt; nl.getLength(); ++i)
+		{
+			Element elem = (Element)nl.item(i);
+			if (elem.getAttribute(&quot;name&quot;).equals(&quot;renderingdistance&quot;))
+			{
+				nodeUserData.setRenderingDistance(Float.parseFloat(elem
+						.getAttribute(&quot;data&quot;)));
+			}
+			else if (elem.getAttribute(&quot;name&quot;).equals(&quot;staticgeom_group&quot;))
+			{
+				nodeUserData.setStaticGeomGroup(Integer.parseInt(elem
+						.getAttribute(&quot;data&quot;)));
+			}
+			else if (elem.getAttribute(&quot;name&quot;).equals(&quot;physical_body&quot;))
+			{
+				nodeUserData.setPhysicalBody(elem.getAttribute(&quot;data&quot;));
+			}
+		}
+		return nodeUserData;
+	}
+}

Added: tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Writer.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Writer.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat2Writer.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,169 @@
+package meshhandle.io.xml.scene;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import meshhandle.model.scene.Entity;
+import meshhandle.model.scene.Light;
+import meshhandle.model.scene.NodeUserData;
+import meshhandle.model.scene.SceneNode;
+import meshhandle.model.scene.SceneUserData;
+
+public class SceneFormat2Writer extends AbstractSceneWriter
+{
+	public static final String FORMAT_STRING = &quot;0.2.0&quot;;
+
+	public SceneFormat2Writer(Writer out)
+	{
+		super(out);
+	}
+	
+	@Override
+	protected String getFormatVersion()
+	{
+		return FORMAT_STRING;
+	}
+	
+	@Override
+	public void write(SceneUserData scene) throws IOException
+	{
+		// TODO Auto-generated method stub
+	}
+
+	private void writeHeader(SceneNode node) throws IOException
+	{
+		if (node.getName() != null &amp;&amp; !node.getName().equals(&quot;&quot;))
+		{
+			mOutput.append(&quot;        &lt;node name=\&quot;&quot; + node.getName() + &quot;\&quot;&gt;\n&quot;);
+		}
+		else
+		{
+			mOutput.append(&quot;        &lt;node&gt;\n&quot;);
+		}
+		
+		if (node.getPosition() != null)
+		{
+			mOutput.append(&quot;            &quot; + node.getPosition().toXML(&quot;position&quot;) + &quot;\n&quot;);
+		}
+		if (node.getRotation() != null)
+		{
+			mOutput.append(&quot;            &quot; + node.getRotation().toXML(&quot;rotation&quot;) + &quot;\n&quot;);
+		}
+		if (node.getScale() != null)
+		{
+			mOutput.append(&quot;            &quot; + node.getScale().toXML(&quot;scale&quot;) + &quot;\n&quot;);
+		}
+	}
+	
+	private void writeFooter(SceneNode node) throws IOException
+	{
+		if (node.getUserData() != null)
+		{
+			write(node.getUserData());
+		}
+		mOutput.append(&quot;        &lt;/node&gt;&quot;);
+	}
+
+	@Override
+	public void write(Entity entity) throws IOException 
+	{
+		writeHeader(entity);
+		mOutput.append(&quot;            &quot;);
+		mOutput.append(&quot;&lt;entity&quot;);
+		if (entity.getName() != null &amp;&amp; !entity.getName().equals(&quot;&quot;))
+		{
+			mOutput.append(&quot; name=\&quot;&quot; + entity.getName() + &quot;\&quot;&quot;); 
+		}
+		if (entity.getId() != null &amp;&amp; !entity.getId().equals(&quot;&quot;))
+		{
+			mOutput.append(&quot; id=\&quot;&quot; + entity.getId() + &quot;\&quot;&quot;); 
+		}
+		mOutput.append(&quot; meshFile=\&quot;&quot; + entity.getMeshFile() + &quot;\&quot;&quot;);
+		
+		if (entity.getCastShadow() != null)
+		{
+			if (entity.getCastShadow() == true)
+			{
+				mOutput.append(&quot; castShadow=\&quot;true\&quot;&quot;);
+			}
+			else if (entity.getCastShadow() == false)
+			{
+				mOutput.append(&quot; castShadow=\&quot;false\&quot;&quot;);
+			}
+		}
+		mOutput.append(&quot;/&gt;\n&quot;);
+		writeFooter(entity);
+	}
+
+	@Override
+	public void write(NodeUserData userData) throws IOException
+	{
+		if (userData != null)
+		{
+			mOutput.append(&quot;&lt;userData&gt;&quot;);
+			mOutput.append(userData.toXML());
+			mOutput.append(&quot;&lt;/userData&gt;&quot;);
+		}
+	}
+
+	@Override
+	public void write(Light light) throws IOException
+	{
+		// TODO Auto-generated method stub
+		writeHeader(light);
+		mOutput.append(&quot;            &quot;);
+		mOutput.append(&quot;&lt;light&quot;);
+		if (light.getName() != null &amp;&amp; !light.getName().equals(&quot;&quot;))
+		{
+			mOutput.append(&quot; name=\&quot;&quot; + light.getName() + &quot;\&quot;&quot;); 
+		}
+		if (light.getId() != null &amp;&amp; !light.getId().equals(&quot;&quot;))
+		{
+			mOutput.append(&quot; id=\&quot;&quot; + light.getId() + &quot;\&quot;&quot;); 
+		}
+		
+		mOutput.append(&quot; type=\&quot;&quot; + light.getType() + &quot;\&quot;&quot;);
+		
+		if (light.getCastShadows() != null)
+		{
+			if (light.getCastShadows() == true)
+			{
+				mOutput.append(&quot; castShadows=\&quot;true\&quot;&quot;);
+			}
+			else if (light.getCastShadows() == false)
+			{
+				mOutput.append(&quot; castShadows=\&quot;false\&quot;&quot;);
+			}
+		}
+		mOutput.append(&quot;/&gt;\n&quot;);
+		
+		if (light.getDiffuseColour() != null)
+		{
+			mOutput.append(&quot;              &quot;);
+			mOutput.append(light.getDiffuseColour().toXML(&quot;colourDiffuse&quot;));
+		}
+		if (light.getSpecularColour() != null)
+		{
+			mOutput.append(&quot;              &quot;);
+			mOutput.append(light.getSpecularColour().toXML(&quot;colourSpecular&quot;));
+		}
+		if (light.getAttenuation() != null)
+		{
+			mOutput.append(&quot;              &quot;);
+			mOutput.append(light.getAttenuation().toXML(&quot;lightAttenuation&quot;));
+		}
+		
+		if (light.getSpotLightSettings() != null)
+		{
+			mOutput.append(&quot;              &quot;);
+			mOutput.append(light.getSpotLightSettings().toXML());
+		}
+		else if (light.getDirection() != null)
+		{
+			mOutput.append(&quot;              &quot;);
+			mOutput.append(light.getDirection().toXML(&quot;direction&quot;));
+		}
+
+		writeFooter(light);
+	}
+}

Added: tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat3Loader.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat3Loader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat3Loader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,45 @@
+package meshhandle.io.xml.scene;
+
+import meshhandle.model.scene.SceneNode;
+import org.w3c.dom.Element;
+
+public class SceneFormat3Loader extends SceneFormat2Loader
+{
+	protected SceneNode processNode(Element sceneNodeElem)
+	{
+		SceneNode scenenode = null;
+		
+		Element elem = (Element)sceneNodeElem.getElementsByTagName(&quot;entity&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode = processEntity(elem);
+		}
+
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;light&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode = processLight(elem);
+		}
+
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;position&quot;)
+				.item(0);
+		if (elem != null)
+		{
+			scenenode.setPosition(processVector3(elem));
+		}
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;scale&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode.setScale(processVector3(elem));
+		}
+		elem = (Element)sceneNodeElem.getElementsByTagName(&quot;rotation&quot;).item(0);
+		if (elem != null)
+		{
+			scenenode.setRotation(processQuaternion(elem));
+		}
+		scenenode.setUserData(processNodeUserData(sceneNodeElem));
+		return scenenode;
+	}
+
+
+}

Added: tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat4Writer.java
===================================================================
--- tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat4Writer.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/io/xml/scene/SceneFormat4Writer.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,125 @@
+package meshhandle.io.xml.scene;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import meshhandle.model.scene.Entity;
+import meshhandle.model.scene.Light;
+import meshhandle.model.scene.NodeUserData;
+import meshhandle.model.scene.SceneNode;
+import meshhandle.model.scene.SceneUserData;
+
+public class SceneFormat4Writer extends AbstractSceneWriter
+{
+	public static final String FORMAT_STRING = &quot;0.4.0&quot;;
+	private int mEntities = 0;
+	private int mLights = 0;
+
+	public SceneFormat4Writer(Writer out)
+	{
+		super(out);
+	}
+	
+	@Override
+	public void write(SceneUserData scene) throws IOException
+	{
+		// TODO Auto-generated method stub
+	}
+
+	@Override
+	public void write(Entity entity) throws IOException
+	{
+		mOutput.append(&quot;&lt;entity&quot;);
+		String name = entity.getName();
+		if (name == null || &quot;&quot;.equals(name))
+		{
+			name = entity.getId();
+		}
+		if (name == null || &quot;&quot;.equals(name))
+		{
+			name = &quot;entity_&quot; + (mEntities++);
+		}
+		mOutput.append(&quot; name=\&quot;&quot; + name + &quot;\&quot;&quot;);
+		mOutput.append(&quot; meshFile=\&quot;&quot; + entity.getMeshFile() + &quot;\&quot;&quot;);
+		if (entity.getCastShadow() != null)
+		{
+			mOutput.append(&quot; castShadows=\&quot;&quot; + entity.getCastShadow() + &quot;\&quot;&quot;);
+		}
+		mOutput.append(&quot;&gt;\n&quot;);
+		writeNode3DData(entity);
+		write(entity.getUserData());
+		mOutput.append(&quot;\n&lt;/entity&gt;&quot;);
+	}
+
+	private void writeNode3DData(SceneNode node) throws IOException
+	{
+		if (node.getPosition() != null)
+		{
+			mOutput.append(node.getPosition().toXML(&quot;position&quot;));
+		}
+		if (node.getRotation() != null)
+		{
+			mOutput.append(node.getRotation().toXML(&quot;rotation&quot;));
+		}
+		if (node.getScale() != null)
+		{
+			mOutput.append(node.getScale().toXML(&quot;scale&quot;));
+		}
+	}
+
+	@Override
+	public void write(Light light) throws IOException
+	{
+		mOutput.append(&quot;&lt;entity&quot;);
+		String name = light.getName();
+		if (name == null || &quot;&quot;.equals(name))
+		{
+			name = light.getId();
+		}
+		if (name == null || &quot;&quot;.equals(name))
+		{
+			name = &quot;light_&quot; + (mLights++);
+		}
+		mOutput.append(&quot; name=\&quot;&quot; + name + &quot;\&quot;&quot;);
+		mOutput.append(&quot; type=\&quot;&quot; + light.getType() + &quot;\&quot;&quot;);
+		if (light.getVisible() != null)
+		{
+			mOutput.append(&quot; visible=\&quot;&quot; + light.getVisible() + &quot;\&quot;&quot;);
+		}
+		
+		if (light.getCastShadows() != null)
+		{
+			mOutput.append(&quot; castShadows=\&quot;&quot; + light.getCastShadows() + &quot;\&quot;&quot;);
+		}
+		mOutput.append(&quot;&gt;\n&quot;);
+		writeNode3DData(light);
+		write(light.getUserData());
+		if (light.getDirection() != null)
+		{
+			mOutput.append(light.getDirection().toXML(&quot;direction&quot;));
+		}
+		
+		if (light.getSpotLightSettings() != null)
+		{
+			mOutput.append(light.getSpotLightSettings().toXML());
+		}
+		
+		mOutput.append(&quot;\n&lt;/light&gt;&quot;);
+	}
+
+	@Override
+	public void write(NodeUserData userData) throws IOException
+	{
+		if (userData != null)
+		{
+			mOutput.append(userData.toXML());
+		}
+		// TODO Auto-generated method stub
+	}
+
+	@Override
+	protected String getFormatVersion()
+	{
+		return FORMAT_STRING;
+	}
+}

Modified: tools/meshhandle/src/meshhandle/model/module/Module.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/module/Module.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/module/Module.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -7,6 +7,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+
+import meshhandle.model.scene.Entity;
 import meshhandle.model.scene.Scene;
 import meshhandle.model.scene.SceneNode;
 
@@ -64,10 +66,11 @@
 		{
 			for (SceneNode curSceneNode : curScene.getNodes())
 			{
-				if (curSceneNode.getEntity() != null
-					&amp;&amp; curSceneNode.getEntity().getMeshFile() != null)
+				if (curSceneNode instanceof Entity)
 				{
-					mMeshFiles.add(curSceneNode.getEntity().getMeshFile());
+					String meshfile = ((Entity)curSceneNode).getMeshFile();
+					if (meshfile != null)
+					mMeshFiles.add(meshfile);
 				}
 			}
 		}

Modified: tools/meshhandle/src/meshhandle/model/module/ModuleLoader.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/module/ModuleLoader.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/module/ModuleLoader.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -6,7 +6,7 @@
 import java.util.List;
 import javax.xml.parsers.ParserConfigurationException;
 import meshhandle.io.plaintext.RubyFileLoader;
-import meshhandle.io.xml.SceneLoader;
+import meshhandle.io.xml.scene.SceneFormat2Loader;
 import meshhandle.model.scene.Scene;
 import org.xml.sax.SAXException;
 
@@ -54,7 +54,7 @@
 			try
 			{
 				System.out.print(&quot;Processing &quot;+mod.getPath() + &quot;/maps/&quot; + sceneFile);
-				Scene scene = SceneLoader.readScene(
+				Scene scene = new SceneFormat2Loader().readScene(
 						mod.getPath() + &quot;/maps/&quot; + sceneFile);
 				list.add(scene);
 				System.out.println(&quot; done&quot;);

Modified: tools/meshhandle/src/meshhandle/model/scene/Entity.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/Entity.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/Entity.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -1,48 +1,19 @@
 package meshhandle.model.scene;
 
-public class Entity
+public class Entity extends SceneNode
 {
 	private final String mName;
 	private final String mMeshFile;
-	private Boolean mCastsShadows;
+	private Boolean mCastShadow;
 	private String mId;
 
 	public Entity(String name, String meshFile)
 	{
+		super(name);
 		mName = name;
 		mMeshFile = meshFile;
 	}
 
-	public String toXML()
-	{
-		StringBuffer buf = new StringBuffer();
-		buf.append(&quot;&lt;entity&quot;);
-		if (mName != null &amp;&amp; !mName.equals(&quot;&quot;))
-		{
-			buf.append(&quot; name=\&quot;&quot; + mName + &quot;\&quot;&quot;); 
-		}
-		if (mId != null &amp;&amp; !mId.equals(&quot;&quot;))
-		{
-			buf.append(&quot; id=\&quot;&quot; + mId + &quot;\&quot;&quot;); 
-		}
-		buf.append(&quot; meshFile=\&quot;&quot; + mMeshFile + &quot;\&quot;&quot;);
-		
-		if (mCastsShadows != null)
-		{
-			if (mCastsShadows == true)
-			{
-				buf.append(&quot; castsShadows=\&quot;true\&quot;&quot;);
-			}
-			else if (mCastsShadows == false)
-			{
-				buf.append(&quot; castsShadows=\&quot;false\&quot;&quot;);
-			}
-		}
-		buf.append(&quot;/&gt;&quot;);
-		
-		return buf.toString();
-	}
-
 	public String getMeshFile()
 	{
 		return mMeshFile;
@@ -53,14 +24,14 @@
 		return mName;
 	}
 
-	public Boolean getCastsShadows()
+	public Boolean getCastShadow()
 	{
-		return mCastsShadows;
+		return mCastShadow;
 	}
 
-	public void setCastsShadows(Boolean castsShadows)
+	public void setCastShadow(Boolean castShadow)
 	{
-		mCastsShadows = castsShadows;
+		mCastShadow = castShadow;
 	}
 
 	public String getId()
@@ -72,4 +43,10 @@
 	{
 		mId = id;
 	}
+	
+	@Override
+	public String toString()
+	{
+		return super.toString() + &quot; (&quot; + mMeshFile + &quot;)&quot;;
+	}
 }

Added: tools/meshhandle/src/meshhandle/model/scene/GameObject.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/GameObject.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/GameObject.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,10 @@
+package meshhandle.model.scene;
+
+public class GameObject extends SceneNode
+{
+
+	public GameObject(String name)
+	{
+		super(name);
+	}
+}

Added: tools/meshhandle/src/meshhandle/model/scene/Light.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/Light.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/Light.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,149 @@
+package meshhandle.model.scene;
+
+import meshhandle.data.ColourValue;
+import meshhandle.data.Vector3;
+
+public class Light extends SceneNode
+{
+	public static class SpotLightSettings
+	{
+		private Float mInnerAngle;
+		private Float mOuterAngle;
+		private Float mFallOff;
+
+		public Float getInnerAngle()
+		{
+			return mInnerAngle;
+		}
+
+		public void setInnerAngle(Float innerAngle)
+		{
+			mInnerAngle = innerAngle;
+		}
+
+		public Float getOuterAngle()
+		{
+			return mOuterAngle;
+		}
+
+		public void setOuterAngle(Float outerAngle)
+		{
+			mOuterAngle = outerAngle;
+		}
+
+		public Float getFallOff()
+		{
+			return mFallOff;
+		}
+
+		public void setFallOff(Float fallOff)
+		{
+			mFallOff = fallOff;
+		}
+
+		public String toXML()
+		{
+			return &quot;&lt;spotlightrange inner=\&quot;&quot; + mInnerAngle + &quot;\&quot; outer=\&quot;&quot;
+					+ mOuterAngle + &quot;\&quot; falloff=\&quot;&quot; + mFallOff + &quot;\&quot; /&gt;&quot;;
+		}
+	}
+
+	private Boolean mCastShadows;
+	private ColourValue mDiffuseColour;
+	private ColourValue mSpecularColour;
+	private String mType;
+	private SpotLightSettings mSpotLightSettings;
+	private Vector3 mDirection;
+	private LightAttenuation mAttenuation;
+	private Boolean mVisible;
+
+	public Light(String name)
+	{
+		super(name);
+	}
+
+	public void setCastShadows(boolean cast)
+	{
+		mCastShadows = cast;
+	}
+
+	public Boolean getCastShadows()
+	{
+		return mCastShadows;
+	}
+
+	public ColourValue getDiffuseColour()
+	{
+		return mDiffuseColour;
+	}
+
+	public void setDiffuseColour(ColourValue diffuseColour)
+	{
+		mDiffuseColour = diffuseColour;
+	}
+
+	public ColourValue getSpecularColour()
+	{
+		return mSpecularColour;
+	}
+
+	public void setSpecularColour(ColourValue specularColour)
+	{
+		mSpecularColour = specularColour;
+	}
+
+	public String getType()
+	{
+		return mType;
+	}
+
+	public void setType(String type)
+	{
+		mType = type;
+	}
+
+	public SpotLightSettings getSpotLightSettings()
+	{
+		return mSpotLightSettings;
+	}
+
+	public void setSpotLightSettings(SpotLightSettings spotLightSettings)
+	{
+		mSpotLightSettings = spotLightSettings;
+	}
+
+	public Vector3 getDirection()
+	{
+		return mDirection;
+	}
+
+	public void setDirection(Vector3 direction)
+	{
+		mDirection = direction;
+	}
+
+	public void setCastShadows(Boolean castShadows)
+	{
+		mCastShadows = castShadows;
+	}
+
+	public LightAttenuation getAttenuation()
+	{
+		return mAttenuation;
+	}
+
+	public void setAttenuation(LightAttenuation att)
+	{
+		mAttenuation = att;
+	}
+
+	public void setVisible(boolean visible)
+	{
+		mVisible = visible;		
+	}
+	
+	public Boolean getVisible()
+	{
+		return mVisible;
+	}
+}

Added: tools/meshhandle/src/meshhandle/model/scene/LightAttenuation.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/LightAttenuation.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/LightAttenuation.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,63 @@
+package meshhandle.model.scene;
+
+public class LightAttenuation
+{
+	private Float mRange;
+	private Float mConstantParameter;
+	private Float mLinearParameter;
+	private Float mQuadraticParameter;
+
+	public Float getRange()
+	{
+		return mRange;
+	}
+
+	public void setRange(Float range)
+	{
+		mRange = range;
+	}
+
+	public Float getConstantParameter()
+	{
+		return mConstantParameter;
+	}
+
+	public void setConstantParameter(Float constantParameter)
+	{
+		mConstantParameter = constantParameter;
+	}
+
+	public Float getLinearParameter()
+	{
+		return mLinearParameter;
+	}
+
+	public void setLinearParameter(Float linearParameter)
+	{
+		mLinearParameter = linearParameter;
+	}
+
+	public Float getQuadraticParameter()
+	{
+		return mQuadraticParameter;
+	}
+
+	public void setQuadraticParameter(Float quadraticParameter)
+	{
+		mQuadraticParameter = quadraticParameter;
+	}
+
+	public String toXML(String nodename)
+	{
+		StringBuffer buf = new StringBuffer();
+		buf.append(&quot;&lt;lightAttenuation&quot;);
+		buf.append(&quot; range=\&quot;&quot; + mRange + &quot;\&quot;&quot;);
+		buf.append(&quot; constant=\&quot;&quot; + mConstantParameter + &quot;\&quot;&quot;);
+		buf.append(&quot; linear=\&quot;&quot; + mLinearParameter + &quot;\&quot;&quot;);
+		buf.append(&quot; quadratic=\&quot;&quot; + mQuadraticParameter + &quot;\&quot;&quot;);
+		buf.append(&quot;/&gt;&quot;);
+		return buf.toString();
+	}
+	
+
+}

Modified: tools/meshhandle/src/meshhandle/model/scene/NodeUserData.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/NodeUserData.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/NodeUserData.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -12,7 +12,6 @@
 
 	public String toXML() {
 		StringBuffer buf = new StringBuffer();
-		buf.append(&quot;            &lt;userdata&gt;\n&quot;);
 		if (mStaticGeomGroup != null) {
 			buf
 					.append(
@@ -31,7 +30,6 @@
 							&quot;                &lt;property type=\&quot;FLOAT\&quot; name=\&quot;renderingdistance\&quot; data=\&quot;&quot;)
 					.append(mRenderingDistance).append(&quot;\&quot;/&gt;\n&quot;);
 		}
-		buf.append(&quot;            &lt;/userdata&gt;\n&quot;);
 		return buf.toString();
 	}
 

Modified: tools/meshhandle/src/meshhandle/model/scene/Scene.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/Scene.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/Scene.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -2,55 +2,51 @@
 
 import java.util.ArrayList;
 
-public class Scene {
-    private String mFormatVersion;
+public class Scene
+{
+	private ArrayList&lt;SceneNode&gt; mNodes;
+	private SceneUserData mUserData;
 
-    private ArrayList&lt;SceneNode&gt; mNodes;
+	public Scene()
+	{
+		mNodes = new ArrayList&lt;SceneNode&gt;();
+	}
 
-    private SceneUserData mUserData;
+	public void scale(float factor)
+	{
+		for (SceneNode node : mNodes)
+		{
+			node.scale(factor);
+		}
+		if (mUserData != null)
+			mUserData.scale(factor);
+	}
 
-    public Scene(String formatVersion) {
-        mFormatVersion = formatVersion;
-        mNodes = new ArrayList&lt;SceneNode&gt;();
-    }
+	public void addNode(SceneNode scenenode)
+	{
+		mNodes.add(scenenode);
+	}
 
-    public String toXML() {
-        StringBuffer buf = new StringBuffer();
-        buf.append(&quot;&lt;scene formatVersion=\&quot;&quot; + mFormatVersion + &quot;\&quot;&gt;\n&quot;);
-        buf.append(&quot;    &lt;nodes&gt;\n&quot;);
-        for (SceneNode node : mNodes) {
-            buf.append(node.toXML() + &quot;\n&quot;);
-        }
-        buf.append(&quot;    &lt;/nodes&gt;\n&quot;);
-        if (mUserData != null)
-            buf.append(mUserData.toXML());
-        buf.append(&quot;&lt;/scene&gt;&quot;);
-        return buf.toString();
-    }
+	public void addUserData(SceneUserData sceneUserData)
+	{
+		mUserData = sceneUserData;
+	}
 
-    public void scale(float factor) {
-        for (SceneNode node : mNodes) {
-            node.scale(factor);
-        }
-        if (mUserData != null)
-            mUserData.scale(factor);
-    }
-
-    public void addNode(SceneNode scenenode) {
-        mNodes.add(scenenode);
-    }
-
-    public void addUserData(SceneUserData sceneUserData) {
-        mUserData = sceneUserData;
-    }
-
-	public ArrayList&lt;SceneNode&gt; getNodes() {
+	public ArrayList&lt;SceneNode&gt; getNodes()
+	{
 		return mNodes;
 	}
 
-	public void removeNode(SceneNode node) {
-		if (mNodes.contains(node)) {
+	public void removeNode(SceneNode node)
+	{
+		if (mNodes.contains(node))
+		{
 			mNodes.remove(node);
 		}
 	}
+
+	public SceneUserData getUserData()
+	{
+		return mUserData;
+	}
 }

Modified: tools/meshhandle/src/meshhandle/model/scene/SceneNode.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/SceneNode.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/SceneNode.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -9,8 +9,8 @@
 	private Vector3 mPosition;
 	private Quaternion mRotation;
 	private Vector3 mScale;
-	private Entity mEntity;
 	private NodeUserData mUserData;
+	private String mId;
 
 	public NodeUserData getUserData()
 	{
@@ -27,16 +27,6 @@
 		mName = name;
 	}
 
-	public Entity getEntity()
-	{
-		return mEntity;
-	}
-
-	public void setEntity(Entity entity)
-	{
-		mEntity = entity;
-	}
-
 	public String getName()
 	{
 		return mName;
@@ -77,27 +67,6 @@
 		mScale = scale;
 	}
 
-	public String toXML()
-	{
-		StringBuffer buf = new StringBuffer();
-		if (mName != null &amp;&amp; !mName.equals(&quot;&quot;))
-			buf.append(&quot;        &lt;node name=\&quot;&quot; + mName + &quot;\&quot;&gt;\n&quot;);
-		else
-			buf.append(&quot;        &lt;node&gt;\n&quot;);
-		if (mPosition != null)
-			buf.append(&quot;            &quot; + mPosition.toXML(&quot;position&quot;) + &quot;\n&quot;);
-		if (mRotation != null)
-			buf.append(&quot;            &quot; + mRotation.toXML(&quot;rotation&quot;) + &quot;\n&quot;);
-		if (mScale != null)
-			buf.append(&quot;            &quot; + mScale.toXML(&quot;scale&quot;) + &quot;\n&quot;);
-		if (mEntity != null)
-			buf.append(&quot;            &quot; + mEntity.toXML() + &quot;\n&quot;);
-		if (mUserData != null)
-			buf.append(mUserData.toXML());
-		buf.append(&quot;        &lt;/node&gt;&quot;);
-		return buf.toString();
-	}
-
 	public void scale(float factor)
 	{
 		if (mPosition != null)
@@ -109,14 +78,14 @@
 	@Override
 	public String toString()
 	{
-		StringBuffer buf = new StringBuffer();
 		if (mName != null &amp;&amp; !mName.equals(&quot;&quot;))
-			buf.append(mName);
+		{
+			return mName;
+		}
 		else
-			buf.append(&quot;n.n.&quot;);
-		if (mEntity != null)
-			buf.append(&quot;, &quot; + mEntity.getMeshFile());
-		return buf.toString();
+		{
+			return &quot;n.n.&quot;;
+		}
 	}
 
 	public void setPhysicsProxy(String proxyType)
@@ -127,4 +96,14 @@
 		}
 		mUserData.setPhysicalBody(proxyType);
 	}
+
+	public String getId()
+	{
+		return mId;
+	}
+
+	public void setId(String id)
+	{
+		mId = id;
+	}
 }

Added: tools/meshhandle/src/meshhandle/model/scene/Sound.java
===================================================================
--- tools/meshhandle/src/meshhandle/model/scene/Sound.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/model/scene/Sound.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -0,0 +1,11 @@
+package meshhandle.model.scene;
+
+public class Sound extends SceneNode
+{
+
+	public Sound(String name)
+	{
+		super(name);
+		// TODO Auto-generated constructor stub
+	}
+}

Modified: tools/meshhandle/src/meshhandle/sceneeditor/SceneEditor.java
===================================================================
--- tools/meshhandle/src/meshhandle/sceneeditor/SceneEditor.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/sceneeditor/SceneEditor.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -11,7 +11,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
-
 import javax.swing.JButton;
 import javax.swing.JFileChooser;
 import javax.swing.JFrame;
@@ -24,11 +23,10 @@
 import javax.swing.tree.DefaultTreeModel;
 import javax.swing.tree.TreePath;
 import javax.xml.parsers.ParserConfigurationException;
-
-import meshhandle.io.xml.SceneLoader;
+import meshhandle.io.xml.scene.SceneFormat2Loader;
+import meshhandle.io.xml.scene.SceneFormat2Writer;
 import meshhandle.model.scene.Scene;
 import meshhandle.model.scene.SceneNode;
-
 import org.xml.sax.SAXException;
 
 public class SceneEditor extends JFrame implements ActionListener {
@@ -193,7 +191,7 @@
 			{
 				try 
 				{
-					mScene = SceneLoader.readScene(mDotsceneChooser.getSelectedFile().getAbsolutePath());
+					mScene = new SceneFormat2Loader().readScene(mDotsceneChooser.getSelectedFile().getAbsolutePath());
 					mSceneTree.setModel(new DefaultTreeModel(SceneTreeCreator.createSceneTree(mScene)));
 				} 
 				catch (ParserConfigurationException e) 
@@ -217,7 +215,7 @@
 				try 
 				{
 					FileWriter outFile = new FileWriter(mDotsceneChooser.getSelectedFile(), false);
-			        outFile.write(mScene.toXML());
+					new SceneFormat2Writer(outFile).write(mScene);
 			        outFile.flush();
 			        outFile.close();
 				}

Modified: tools/meshhandle/src/meshhandle/sceneeditor/SceneTreeCreator.java
===================================================================
--- tools/meshhandle/src/meshhandle/sceneeditor/SceneTreeCreator.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/sceneeditor/SceneTreeCreator.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -34,7 +34,12 @@
 		{
 			DefaultMutableTreeNode meshFileNode = null;
 
-			Entity ent = node.getEntity();
+			Entity ent = null;
+			if (node instanceof Entity)
+			{
+				ent = (Entity)node;
+			}
+			
 			if (ent == null) 
 			{
 				meshFileNode = new DefaultMutableTreeNode(&quot;No meshfile&quot;);
@@ -43,14 +48,14 @@
 			else 
 			{
 				meshFileNode = entityMap.get(ent.getMeshFile());
+				if (meshFileNode == null)
+				{
+					meshFileNode = new DefaultMutableTreeNode(ent.getMeshFile());
+					root.add(meshFileNode);
+					entityMap.put(ent.getMeshFile(), meshFileNode);
+				}
 			}
 			
-			if (meshFileNode == null)
-			{
-				meshFileNode = new DefaultMutableTreeNode(node.getEntity().getMeshFile());
-				root.add(meshFileNode);
-				entityMap.put(node.getEntity().getMeshFile(), meshFileNode);
-			}
 			meshFileNode.add(new DefaultMutableTreeNode(node));
 		}
 		

Modified: tools/meshhandle/src/meshhandle/ui/MeshHandlerWindow.java
===================================================================
--- tools/meshhandle/src/meshhandle/ui/MeshHandlerWindow.java	2007-04-26 06:48:10 UTC (rev 3330)
+++ tools/meshhandle/src/meshhandle/ui/MeshHandlerWindow.java	2007-04-26 07:03:53 UTC (rev 3331)
@@ -365,7 +365,7 @@
 			}
 			try {
 				String modelPath = oldModel.getAbsolutePath() + &quot;.xml&quot;;
-				model = MeshLoader.readMesh(modelPath);
+				model = new MeshLoader().readMesh(modelPath);
 			} catch (Exception e1) {
 				loggen(&quot;Fehler beim Einlesen der .mesh.xml. (Siehe Konsole)&quot;);
 				e1.printStackTrace();
@@ -386,7 +386,7 @@
 									+ model.getSkeletonLink())) {
 				loggen(&quot; .skeleton.xml erzeugt.&quot;);
 				try {
-					skeleton = SkeletonLoader
+					skeleton = new SkeletonLoader()
 							.readSkeleton(oldModel.getAbsolutePath()
 									.substring(
 											0,


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000407.html">[Dsa-hl-svn] r3330 - modules/regressiontest/maps	modules/regressiontest/scripts modules/techdemo/maps	modules/techdemo/scripts rl/trunk/docs/documents	rl/trunk/engine/common/include rl/trunk/engine/rules	rl/trunk/engine/rules/include rl/trunk/engine/rules/src	rl/trunk/engine/script/swig
</A></li>
	<LI>Next message: <A HREF="000402.html">[Dsa-hl-svn] r3332 - tools/meshhandle
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#401">[ date ]</a>
              <a href="thread.html#401">[ thread ]</a>
              <a href="subject.html#401">[ subject ]</a>
              <a href="author.html#401">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
