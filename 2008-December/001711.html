<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4654 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler/src	editors/Lockenwickler/src/media engine/ai engine/ai/include	engine/ai/src engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules/include engine/rules/src	engine/ui engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4654%20-%20in%20rl/branches/newton20%3A%20.%0A%09Mac/Rastullah.xcodeproj%20cmake%20editors/Lockenwickler/src%0A%09editors/Lockenwickler/src/media%20engine/ai%20engine/ai/include%0A%09engine/ai/src%20engine/common%20engine/common/include%0A%09engine/common/src%20engine/core%20engine/core/include%0A%09engine/core/src%20engine/rules/include%20engine/rules/src%0A%09engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200812172011.mBHKBWFw012914%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001710.html">
   <LINK REL="Next"  HREF="001712.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4654 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler/src	editors/Lockenwickler/src/media engine/ai engine/ai/include	engine/ai/src engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules/include engine/rules/src	engine/ui engine/ui/include engine/ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4654%20-%20in%20rl/branches/newton20%3A%20.%0A%09Mac/Rastullah.xcodeproj%20cmake%20editors/Lockenwickler/src%0A%09editors/Lockenwickler/src/media%20engine/ai%20engine/ai/include%0A%09engine/ai/src%20engine/common%20engine/common/include%0A%09engine/common/src%20engine/core%20engine/core/include%0A%09engine/core/src%20engine/rules/include%20engine/rules/src%0A%09engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200812172011.mBHKBWFw012914%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4654 - in rl/branches/newton20: .	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler/src	editors/Lockenwickler/src/media engine/ai engine/ai/include	engine/ai/src engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules/include engine/rules/src	engine/ui engine/ui/include engine/ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Wed Dec 17 21:11:32 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001710.html">[Dsa-hl-svn] r4653 - modules/kanalisation/materials
</A></li>
        <LI>Next message: <A HREF="001712.html">[Dsa-hl-svn] r4655 - rl/branches/newton20/engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1711">[ date ]</a>
              <a href="thread.html#1711">[ thread ]</a>
              <a href="subject.html#1711">[ subject ]</a>
              <a href="author.html#1711">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2008-12-17 21:11:09 +0100 (Wed, 17 Dec 2008)
New Revision: 4654

Added:
   rl/branches/newton20/cmake/FindOgreNewt.cmake
   rl/branches/newton20/editors/Lockenwickler/src/media/UniCube.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/UniSphere.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.blend
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.png
   rl/branches/newton20/engine/ai/CMakeLists.txt
   rl/branches/newton20/engine/ai/include/DialogLoaderImpl.h
   rl/branches/newton20/engine/ai/src/DialogLoaderImpl.cpp
   rl/branches/newton20/engine/common/CMakeLists.txt
   rl/branches/newton20/engine/core/CMakeLists.txt
Removed:
   rl/branches/newton20/editors/Lockenwickler/src/media/Barrel.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/Example.material
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
Modified:
   rl/branches/newton20/CMakeLists.txt
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/newton20/engine/ai/RlAI2005.vcproj
   rl/branches/newton20/engine/ai/include/DialogImplication.h
   rl/branches/newton20/engine/ai/include/DialogLoader.h
   rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h
   rl/branches/newton20/engine/ai/include/Makefile.am
   rl/branches/newton20/engine/ai/src/DialogImplication.cpp
   rl/branches/newton20/engine/ai/src/DialogLoader.cpp
   rl/branches/newton20/engine/ai/src/Makefile.am
   rl/branches/newton20/engine/common/include/MathUtil.h
   rl/branches/newton20/engine/common/include/WriteableDataStream.h
   rl/branches/newton20/engine/common/src/MathUtil.cpp
   rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/newton20/engine/core/include/ConfigurationManager.h
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/ContentLoader.cpp
   rl/branches/newton20/engine/core/src/CoreSubsystem.cpp
   rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp
   rl/branches/newton20/engine/rules/include/ApplyDamageJob.h
   rl/branches/newton20/engine/rules/include/Combat.h
   rl/branches/newton20/engine/rules/include/Combatant.h
   rl/branches/newton20/engine/rules/include/Creature.h
   rl/branches/newton20/engine/rules/include/RulesPrerequisites.h
   rl/branches/newton20/engine/rules/include/Slot.h
   rl/branches/newton20/engine/rules/include/Weapon.h
   rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp
   rl/branches/newton20/engine/rules/src/Combat.cpp
   rl/branches/newton20/engine/rules/src/Combatant.cpp
   rl/branches/newton20/engine/rules/src/Creature.cpp
   rl/branches/newton20/engine/rules/src/GoToJob.cpp
   rl/branches/newton20/engine/rules/src/Weapon.cpp
   rl/branches/newton20/engine/ui/RlUI2005.vcproj
   rl/branches/newton20/engine/ui/include/AbstractWindow.h
   rl/branches/newton20/engine/ui/include/GameSettings.h
   rl/branches/newton20/engine/ui/include/WindowManager.h
   rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
   rl/branches/newton20/engine/ui/src/GameSettings.cpp
   rl/branches/newton20/engine/ui/src/MovementControlState.cpp
   rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
   rl/branches/newton20/engine/ui/src/WindowManager.cpp
Log:
merged changes from trunk


Modified: rl/branches/newton20/CMakeLists.txt
===================================================================
--- rl/branches/newton20/CMakeLists.txt	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/CMakeLists.txt	2008-12-17 20:11:09 UTC (rev 4654)
@@ -3,11 +3,16 @@
 CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
 
 # Cmake handles escaping of preprocessor directives
-CMAKE_POLICY(SET CMP0005 NEW)
+CMAKE_POLICY(SET CMP0005 OLD)
 
 # Include required cmake macros
 INCLUDE(FeatureSummary)
 
+# Version information
+SET(RL_MAJOR_VERSION 0)
+SET(RL_MINOR_VERSION 3)
+SET(RL_PATCH_VERSION 0)
+
 # Add directory with RL's own macro definitions
 # (checked before ${CMAKE_ROOT}/Modules)
 SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
@@ -21,7 +26,9 @@
 SET(RL_UI_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/ui/include INTERNAL)
 
 # Check for required components
+FIND_PACKAGE(PkgConfig)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
+FIND_PACKAGE(OgreNewt REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
 FIND_PACKAGE(SWIG REQUIRED)
@@ -39,8 +46,7 @@
 SET(ENABLE_OPENAL &quot;Enable OpenAL sound support (unsupported)&quot; OFF)
 
 # Handle options
-SET(DATADIR ${DATAROOTDIR}/${DATADIRNAME})
-ADD_DEFINITIONS(-DDATADIR=${DATADIR})
+ADD_DEFINITIONS(-DRL_MODULEDIR=\\&quot;${DATAROOTDIR}/${DATADIRNAME}/modules\\&quot;)
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -478,7 +478,6 @@
 		48389C290D867B1A00AFAB66 /* Trigger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05860D71EDF20024198D /* Trigger.cpp */; };
 		48389C2C0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */; };
 		48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */; };
-		483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31100D85B1AF003477A0 /* NullSoundStitching.h */; };
 		483D31130D85B1C2003477A0 /* NullSoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */; };
 		483D31200D85B215003477A0 /* Combatant.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31150D85B215003477A0 /* Combatant.h */; };
 		483D31210D85B215003477A0 /* EffectManagementTask.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31160D85B215003477A0 /* EffectManagementTask.h */; };
@@ -562,6 +561,7 @@
 		484FE6C10E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		48500B790D906A1000EAD8DB /* RlScriptExportsMac.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */; };
+		4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */; };
 		48570C210D8A6C9000096E35 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
 		48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
 		48570C230D8A6C9000096E35 /* AbstractMapNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */; };
@@ -619,6 +619,8 @@
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
 		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
+		4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */ = {isa = PBXBuildFile; fileRef = 4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */; };
+		4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -884,14 +886,14 @@
 		1870340FFE93FCAF11CA0CD7 /* English */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = English; path = English.lproj/main.nib; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = stdinc.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		440785DD0C09D231006E496D /* libmeshmagick.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libmeshmagick.dylib; path = /usr/local/lib/libmeshmagick.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
-		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
+		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightFadeJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MergeableMeshObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MergeableMeshObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = &quot;RlScript-Info.plist&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
@@ -952,117 +954,116 @@
 		444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Tripel.h; path = ../engine/common/include/Tripel.h; sourceTree = SOURCE_ROOT; };
 		444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResource.h; path = ../engine/common/include/XmlResource.h; sourceTree = SOURCE_ROOT; };
 		444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResourceManager.h; path = ../engine/common/include/XmlResourceManager.h; sourceTree = SOURCE_ROOT; };
-		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Actor.cpp; path = ../engine/core/src/Actor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorControlledObject.cpp; path = ../engine/core/src/ActorControlledObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorManager.cpp; path = ../engine/core/src/ActorManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AnimationManager.cpp; path = ../engine/core/src/AnimationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BaseAnimation.cpp; path = ../engine/core/src/BaseAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BoxPrimitive.cpp; path = ../engine/core/src/BoxPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CameraObject.cpp; path = ../engine/core/src/CameraObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigurationManager.cpp; path = ../engine/core/src/ConfigurationManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentModule.cpp; path = ../engine/core/src/ContentModule.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CoreSubsystem.cpp; path = ../engine/core/src/CoreSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualisable.cpp; path = ../engine/core/src/DebugVisualisable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualsManager.cpp; path = ../engine/core/src/DebugVisualsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneLoader.cpp; path = ../engine/core/src/DotSceneLoader.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneOctreeWorld.cpp; path = ../engine/core/src/DotSceneOctreeWorld.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FadeAnimation.cpp; path = ../engine/core/src/FadeAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEvent.cpp; path = ../engine/core/src/GameAreaEvent.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEventSource.cpp; path = ../engine/core/src/GameAreaEventSource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaListener.cpp; path = ../engine/core/src/GameAreaListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaTypes.cpp; path = ../engine/core/src/GameAreaTypes.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameEventManager.cpp; path = ../engine/core/src/GameEventManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoop.cpp; path = ../engine/core/src/GameLoop.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Job.cpp; path = ../engine/core/src/Job.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobScheduler.cpp; path = ../engine/core/src/JobScheduler.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightObject.cpp; path = ../engine/core/src/LightObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LineSetPrimitive.cpp; path = ../engine/core/src/LineSetPrimitive.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerMovable.cpp; path = ../engine/core/src/ListenerMovable.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerObject.cpp; path = ../engine/core/src/ListenerObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshAnimation.cpp; path = ../engine/core/src/MeshAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshObject.cpp; path = ../engine/core/src/MeshObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovableText.cpp; path = ../engine/core/src/MovableText.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB420BD0E2B600C6D4A0 /* nulldriver */ = {isa = PBXFileReference; lastKnownFileType = folder; name = nulldriver; path = ../engine/core/src/nulldriver; sourceTree = SOURCE_ROOT; };
-		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = ../engine/core/src/nulldriver/NullDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = ../engine/core/src/nulldriver/NullListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = ../engine/core/src/nulldriver/NullSound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ParticleSystemObject.cpp; path = ../engine/core/src/ParticleSystemObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicalThing.cpp; path = ../engine/core/src/PhysicalThing.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsContactListener.cpp; path = ../engine/core/src/PhysicsContactListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsGenericContactCallback.cpp; path = ../engine/core/src/PhysicsGenericContactCallback.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsManager.cpp; path = ../engine/core/src/PhysicsManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsMaterialRaycast.cpp; path = ../engine/core/src/PhysicsMaterialRaycast.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlayAnimationJob.cpp; path = ../engine/core/src/PlayAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaySoundJob.cpp; path = ../engine/core/src/PlaySoundJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PrimitiveObject.cpp; path = ../engine/core/src/PrimitiveObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RubyInterpreter.cpp; path = ../engine/core/src/RubyInterpreter.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneQuery.cpp; path = ../engine/core/src/SceneQuery.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Sound.cpp; path = ../engine/core/src/Sound.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriver.cpp; path = ../engine/core/src/SoundDriver.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundEvents.cpp; path = ../engine/core/src/SoundEvents.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundManager.cpp; path = ../engine/core/src/SoundManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundObject.cpp; path = ../engine/core/src/SoundObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundResource.cpp; path = ../engine/core/src/SoundResource.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TrackAnimation.cpp; path = ../engine/core/src/TrackAnimation.cpp; sourceTree = SOURCE_ROOT; };
-		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = World.cpp; path = ../engine/core/src/World.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Actor.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorControlledObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActorManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AnimationManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BaseAnimation.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = BoxPrimitive.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CameraObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ConfigurationManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentModule.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CoreSubsystem.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualisable.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualsManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneLoader.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneOctreeWorld.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FadeAnimation.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEvent.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEventSource.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaListener.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaTypes.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameEventManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameLoop.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Job.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobScheduler.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LightObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LineSetPrimitive.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerMovable.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListenerObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshAnimation.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MeshObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MovableText.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = nulldriver/NullDriver.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = nulldriver/NullListener.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = nulldriver/NullSound.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ParticleSystemObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicalThing.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsContactListener.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsGenericContactCallback.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsMaterialRaycast.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlayAnimationJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlaySoundJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PrimitiveObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RubyInterpreter.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SceneQuery.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Sound.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundDriver.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundEvents.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundResource.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TrackAnimation.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = World.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlCore.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Actor.h; path = ../engine/core/include/Actor.h; sourceTree = SOURCE_ROOT; };
-		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorControlledObject.h; path = ../engine/core/include/ActorControlledObject.h; sourceTree = SOURCE_ROOT; };
-		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorManager.h; path = ../engine/core/include/ActorManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AnimationManager.h; path = ../engine/core/include/AnimationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BaseAnimation.h; path = ../engine/core/include/BaseAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BoxPrimitive.h; path = ../engine/core/include/BoxPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CameraObject.h; path = ../engine/core/include/CameraObject.h; sourceTree = SOURCE_ROOT; };
-		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigurationManager.h; path = ../engine/core/include/ConfigurationManager.h; sourceTree = SOURCE_ROOT; };
-		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentModule.h; path = ../engine/core/include/ContentModule.h; sourceTree = SOURCE_ROOT; };
-		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CorePrerequisites.h; path = ../engine/core/include/CorePrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreSubsystem.h; path = ../engine/core/include/CoreSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualisable.h; path = ../engine/core/include/DebugVisualisable.h; sourceTree = SOURCE_ROOT; };
-		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualsManager.h; path = ../engine/core/include/DebugVisualsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneLoader.h; path = ../engine/core/include/DotSceneLoader.h; sourceTree = SOURCE_ROOT; };
-		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneOctreeWorld.h; path = ../engine/core/include/DotSceneOctreeWorld.h; sourceTree = SOURCE_ROOT; };
-		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FadeAnimation.h; path = ../engine/core/include/FadeAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEvent.h; path = ../engine/core/include/GameAreaEvent.h; sourceTree = SOURCE_ROOT; };
-		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEventSource.h; path = ../engine/core/include/GameAreaEventSource.h; sourceTree = SOURCE_ROOT; };
-		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaListener.h; path = ../engine/core/include/GameAreaListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaTypes.h; path = ../engine/core/include/GameAreaTypes.h; sourceTree = SOURCE_ROOT; };
-		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameEventManager.h; path = ../engine/core/include/GameEventManager.h; sourceTree = SOURCE_ROOT; };
-		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoop.h; path = ../engine/core/include/GameLoop.h; sourceTree = SOURCE_ROOT; };
-		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Job.h; path = ../engine/core/include/Job.h; sourceTree = SOURCE_ROOT; };
-		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobListener.h; path = ../engine/core/include/JobListener.h; sourceTree = SOURCE_ROOT; };
-		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobScheduler.h; path = ../engine/core/include/JobScheduler.h; sourceTree = SOURCE_ROOT; };
-		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightObject.h; path = ../engine/core/include/LightObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LineSetPrimitive.h; path = ../engine/core/include/LineSetPrimitive.h; sourceTree = SOURCE_ROOT; };
-		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerMovable.h; path = ../engine/core/include/ListenerMovable.h; sourceTree = SOURCE_ROOT; };
-		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerObject.h; path = ../engine/core/include/ListenerObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshAnimation.h; path = ../engine/core/include/MeshAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshObject.h; path = ../engine/core/include/MeshObject.h; sourceTree = SOURCE_ROOT; };
-		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovableText.h; path = ../engine/core/include/MovableText.h; sourceTree = SOURCE_ROOT; };
-		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = ../engine/core/include/nulldriver/NullDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = ../engine/core/include/nulldriver/NullListener.h; sourceTree = SOURCE_ROOT; };
-		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = ../engine/core/include/nulldriver/NullSound.h; sourceTree = SOURCE_ROOT; };
-		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ParticleSystemObject.h; path = ../engine/core/include/ParticleSystemObject.h; sourceTree = SOURCE_ROOT; };
-		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalObject.h; path = ../engine/core/include/PhysicalObject.h; sourceTree = SOURCE_ROOT; };
-		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalThing.h; path = ../engine/core/include/PhysicalThing.h; sourceTree = SOURCE_ROOT; };
-		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsContactListener.h; path = ../engine/core/include/PhysicsContactListener.h; sourceTree = SOURCE_ROOT; };
-		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsController.h; path = ../engine/core/include/PhysicsController.h; sourceTree = SOURCE_ROOT; };
-		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsGenericContactCallback.h; path = ../engine/core/include/PhysicsGenericContactCallback.h; sourceTree = SOURCE_ROOT; };
-		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsManager.h; path = ../engine/core/include/PhysicsManager.h; sourceTree = SOURCE_ROOT; };
-		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsMaterialRaycast.h; path = ../engine/core/include/PhysicsMaterialRaycast.h; sourceTree = SOURCE_ROOT; };
-		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlayAnimationJob.h; path = ../engine/core/include/PlayAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaySoundJob.h; path = ../engine/core/include/PlaySoundJob.h; sourceTree = SOURCE_ROOT; };
-		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PrimitiveObject.h; path = ../engine/core/include/PrimitiveObject.h; sourceTree = SOURCE_ROOT; };
-		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuadTree.h; path = ../engine/core/include/QuadTree.h; sourceTree = SOURCE_ROOT; };
-		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RubyInterpreter.h; path = ../engine/core/include/RubyInterpreter.h; sourceTree = SOURCE_ROOT; };
-		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneQuery.h; path = ../engine/core/include/SceneQuery.h; sourceTree = SOURCE_ROOT; };
-		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Sound.h; path = ../engine/core/include/Sound.h; sourceTree = SOURCE_ROOT; };
-		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriver.h; path = ../engine/core/include/SoundDriver.h; sourceTree = SOURCE_ROOT; };
-		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundEvents.h; path = ../engine/core/include/SoundEvents.h; sourceTree = SOURCE_ROOT; };
-		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundManager.h; path = ../engine/core/include/SoundManager.h; sourceTree = SOURCE_ROOT; };
-		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundObject.h; path = ../engine/core/include/SoundObject.h; sourceTree = SOURCE_ROOT; };
-		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundResource.h; path = ../engine/core/include/SoundResource.h; sourceTree = SOURCE_ROOT; };
-		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TrackAnimation.h; path = ../engine/core/include/TrackAnimation.h; sourceTree = SOURCE_ROOT; };
-		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = World.h; path = ../engine/core/include/World.h; sourceTree = SOURCE_ROOT; };
+		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Actor.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorControlledObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActorManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AnimationManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BaseAnimation.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BoxPrimitive.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CameraObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConfigurationManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentModule.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CorePrerequisites.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreSubsystem.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualisable.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualsManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneLoader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneOctreeWorld.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FadeAnimation.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEvent.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEventSource.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaListener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaTypes.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameLoop.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Job.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobListener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobScheduler.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LineSetPrimitive.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerMovable.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListenerObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshAnimation.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MovableText.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = nulldriver/NullDriver.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = nulldriver/NullListener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = nulldriver/NullSound.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ParticleSystemObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicalThing.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsContactListener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsController.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsGenericContactCallback.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsMaterialRaycast.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlayAnimationJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlaySoundJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PrimitiveObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuadTree.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RubyInterpreter.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SceneQuery.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Sound.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundDriver.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundEvents.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundResource.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TrackAnimation.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = World.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlAi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlRules.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlUi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -1259,12 +1260,12 @@
 		444EB0880BD1153500C6D4A0 /* OgreNewt.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreNewt.framework; path = /Library/Frameworks/OgreNewt.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenSteer.framework; path = /Library/Frameworks/OpenSteer.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreCEGUIRenderer.framework; path = /Library/Frameworks/OgreCEGUIRenderer.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LinearSoundFadeFunctor.h; path = ../engine/core/include/LinearSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeFunctor.h; path = ../engine/core/include/SoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeJob.h; path = ../engine/core/include/SoundFadeJob.h; sourceTree = SOURCE_ROOT; };
-		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LinearSoundFadeFunctor.cpp; path = ../engine/core/src/LinearSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeFunctor.cpp; path = ../engine/core/src/SoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeJob.cpp; path = ../engine/core/src/SoundFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinearSoundFadeFunctor.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeFunctor.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundFadeJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinearSoundFadeFunctor.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeFunctor.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundFadeJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureController.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureControllerManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectFactory.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1300,21 +1301,21 @@
 		44D814680BF7B5C700534175 /* LandmarkPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LandmarkPath.cpp; path = ../engine/ai/src/LandmarkPath.cpp; sourceTree = SOURCE_ROOT; };
 		44D8146B0BF7B5E800534175 /* Landmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Landmark.h; path = ../engine/ai/include/Landmark.h; sourceTree = SOURCE_ROOT; };
 		44D8146C0BF7B5E800534175 /* LandmarkPath.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LandmarkPath.h; path = ../engine/ai/include/LandmarkPath.h; sourceTree = SOURCE_ROOT; };
-		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Zone.cpp; path = ../engine/core/src/Zone.cpp; sourceTree = SOURCE_ROOT; };
-		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZoneManager.cpp; path = ../engine/core/src/ZoneManager.cpp; sourceTree = SOURCE_ROOT; };
-		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreDefines.h; path = ../engine/core/include/CoreDefines.h; sourceTree = SOURCE_ROOT; };
-		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightFadeJob.h; path = ../engine/core/include/LightFadeJob.h; sourceTree = SOURCE_ROOT; };
-		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
-		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
-		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
-		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
-		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
-		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentLoader.cpp; path = ../engine/core/src/ContentLoader.cpp; sourceTree = SOURCE_ROOT; };
-		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitching.cpp; path = ../engine/core/src/SoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Zone.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ZoneManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreDefines.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LightFadeJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Trigger.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Zone.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentLoader.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitching.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646A10D83D57800912FEC /* libruby.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libruby.dylib; path = /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/libruby.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Xerces.framework; path = /Library/Frameworks/Xerces.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StartAnimationJob.cpp; path = ../engine/core/src/StartAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
+		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StartAnimationJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatGui.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameSaveLoadWindow.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuLoadWindow.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1349,12 +1350,11 @@
 		48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlPropertyKeys.swig; path = ../engine/script/swig/TypeRlPropertyKeys.swig; sourceTree = SOURCE_ROOT; };
 		48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeStdPairIntInt.swig; path = ../engine/script/swig/TypeStdPairIntInt.swig; sourceTree = SOURCE_ROOT; };
 		48389C020D86787900AFAB66 /* RlExports.i */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.interfacer; name = RlExports.i; path = ../engine/script/swig/RlExports.i; sourceTree = SOURCE_ROOT; };
-		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitchingObject.h; path = ../engine/core/include/SoundStitchingObject.h; sourceTree = SOURCE_ROOT; };
-		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitchingObject.cpp; path = ../engine/core/src/SoundStitchingObject.cpp; sourceTree = SOURCE_ROOT; };
+		48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitchingObject.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundStitchingObject.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48389C190D867AA900AFAB66 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/script/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
 		48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TriggerFactory.cpp; path = ../engine/script/src/TriggerFactory.cpp; sourceTree = SOURCE_ROOT; };
-		483D31100D85B1AF003477A0 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = ../engine/core/include/nulldriver/NullSoundStitching.h; sourceTree = SOURCE_ROOT; };
-		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = ../engine/core/src/nulldriver/NullSoundStitching.cpp; sourceTree = SOURCE_ROOT; };
+		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = nulldriver/NullSoundStitching.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483D31150D85B215003477A0 /* Combatant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Combatant.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483D31160D85B215003477A0 /* EffectManagementTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectManagementTask.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483D31170D85B215003477A0 /* GameEventLog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventLog.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1421,28 +1421,29 @@
 		483D87C90D8C55E500F3629E /* RlScript.bundle */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = RlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
 		484FE6B90E17BC8800FA880F /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlScriptExportsMac.cpp; path = ../engine/script/swig/RlScriptExportsMac.cpp; sourceTree = SOURCE_ROOT; };
+		4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = nulldriver/NullSoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48570C1B0D8A6C5400096E35 /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		4857E4E40D46A664009D376D /* OIS.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OIS.framework; path = /Library/Frameworks/OIS.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreMessages.h; path = ../engine/core/include/CoreMessages.h; sourceTree = SOURCE_ROOT; };
-		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobQueue.h; path = ../engine/core/include/JobQueue.h; sourceTree = SOURCE_ROOT; };
+		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreMessages.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05690D71EDC40024198D /* JobQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JobQueue.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		485A056A0D71EDC40024198D /* MessageObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageObject.h; path = ../engine/core/include/MessageObject.h; sourceTree = SOURCE_ROOT; };
 		485A056B0D71EDC40024198D /* MessagePump.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessagePump.h; path = ../engine/core/include/MessagePump.h; sourceTree = SOURCE_ROOT; };
 		485A056C0D71EDC40024198D /* MessageType.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageType.h; path = ../engine/core/include/MessageType.h; sourceTree = SOURCE_ROOT; };
-		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PolynomicSoundFadeFunctor.h; path = ../engine/core/include/PolynomicSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
-		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFile.h; path = ../engine/core/include/SaveGameFile.h; sourceTree = SOURCE_ROOT; };
-		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileReader.h; path = ../engine/core/include/SaveGameFileReader.h; sourceTree = SOURCE_ROOT; };
-		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameFileWriter.h; path = ../engine/core/include/SaveGameFileWriter.h; sourceTree = SOURCE_ROOT; };
-		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameManager.h; path = ../engine/core/include/SaveGameManager.h; sourceTree = SOURCE_ROOT; };
-		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimeSource.h; path = ../engine/core/include/TimeSource.h; sourceTree = SOURCE_ROOT; };
-		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobQueue.cpp; path = ../engine/core/src/JobQueue.cpp; sourceTree = SOURCE_ROOT; };
+		485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PolynomicSoundFadeFunctor.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A056E0D71EDC40024198D /* SaveGameFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFile.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A056F0D71EDC40024198D /* SaveGameFileReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileReader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05700D71EDC40024198D /* SaveGameFileWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameFileWriter.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05710D71EDC40024198D /* SaveGameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05720D71EDC40024198D /* TimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TimeSource.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A057D0D71EDF20024198D /* JobQueue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JobQueue.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		485A057E0D71EDF20024198D /* MessagePump.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MessagePump.cpp; path = ../engine/core/src/MessagePump.cpp; sourceTree = SOURCE_ROOT; };
-		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PolynomicSoundFadeFunctor.cpp; path = ../engine/core/src/PolynomicSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
-		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFile.cpp; path = ../engine/core/src/SaveGameFile.cpp; sourceTree = SOURCE_ROOT; };
-		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileReader.cpp; path = ../engine/core/src/SaveGameFileReader.cpp; sourceTree = SOURCE_ROOT; };
-		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameFileWriter.cpp; path = ../engine/core/src/SaveGameFileWriter.cpp; sourceTree = SOURCE_ROOT; };
-		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameManager.cpp; path = ../engine/core/src/SaveGameManager.cpp; sourceTree = SOURCE_ROOT; };
-		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimeSource.cpp; path = ../engine/core/src/TimeSource.cpp; sourceTree = SOURCE_ROOT; };
-		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Trigger.cpp; path = ../engine/core/src/Trigger.cpp; sourceTree = SOURCE_ROOT; };
+		485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PolynomicSoundFadeFunctor.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05800D71EDF20024198D /* SaveGameFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFile.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05810D71EDF20024198D /* SaveGameFileReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileReader.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameFileWriter.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TimeSource.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Trigger.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		485B89510E15794A00D5B19C /* Scene.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Scene.h; path = ../engine/script/include/Scene.h; sourceTree = SOURCE_ROOT; };
 		485B89520E15794A00D5B19C /* SceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneLoader.h; path = ../engine/script/include/SceneLoader.h; sourceTree = SOURCE_ROOT; };
 		485B89530E15794A00D5B19C /* SceneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneManager.h; path = ../engine/script/include/SceneManager.h; sourceTree = SOURCE_ROOT; };
@@ -1457,6 +1458,8 @@
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
 		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
+		4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoaderImpl.h; path = ai/include/DialogLoaderImpl.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoaderImpl.cpp; path = ai/src/DialogLoaderImpl.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbstractMovement.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FallDownMovement.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogBackwardsMovement.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1505,24 +1508,24 @@
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
 		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
-		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleCollection.h; path = ../engine/core/include/SaveAbleCollection.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleFactory.h; path = ../engine/core/include/SaveAbleFactory.h; sourceTree = SOURCE_ROOT; };
-		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleManager.h; path = ../engine/core/include/SaveAbleManager.h; sourceTree = SOURCE_ROOT; };
+		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAble.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleCollection.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleFactory.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48D0BE300E273C8000863824 /* WriteableDataStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStream.h; path = ../engine/common/include/WriteableDataStream.h; sourceTree = SOURCE_ROOT; };
 		48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStreamFormatTarget.h; path = ../engine/common/include/WriteableDataStreamFormatTarget.h; sourceTree = SOURCE_ROOT; };
 		48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableFileSystemArchiv.h; path = ../engine/common/include/WriteableFileSystemArchiv.h; sourceTree = SOURCE_ROOT; };
 		48D0BE360E273C9700863824 /* WriteableDataStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStream.cpp; path = ../engine/common/src/WriteableDataStream.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStreamFormatTarget.cpp; path = ../engine/common/src/WriteableDataStreamFormatTarget.cpp; sourceTree = SOURCE_ROOT; };
 		48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableFileSystemArchiv.cpp; path = ../engine/common/src/WriteableFileSystemArchiv.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAble.cpp; path = ../engine/core/src/SaveAble.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleCollection.cpp; path = ../engine/core/src/SaveAbleCollection.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleFactory.cpp; path = ../engine/core/src/SaveAbleFactory.cpp; sourceTree = SOURCE_ROOT; };
-		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleManager.cpp; path = ../engine/core/src/SaveAbleManager.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAble.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleCollection.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleFactory.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveAbleManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48D0BE680E273FF400863824 /* DialogLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoader.h; path = ../engine/ai/include/DialogLoader.h; sourceTree = SOURCE_ROOT; };
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
-		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
-		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
+		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveGameData.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SaveGameData.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1823,171 +1826,11 @@
 		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
 			isa = PBXGroup;
 			children = (
-				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
-				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
-				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
-				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
-				48D0BE280E273C5E00863824 /* SaveAble.h */,
-				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
-				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
-				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
-				485A05860D71EDF20024198D /* Trigger.cpp */,
-				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
-				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
-				485A05690D71EDC40024198D /* JobQueue.h */,
-				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
-				485A05720D71EDC40024198D /* TimeSource.h */,
-				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
-				48D34A610D90F5D500C89477 /* SaveGameData.h */,
-				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
-				483D31100D85B1AF003477A0 /* NullSoundStitching.h */,
-				485A05850D71EDF20024198D /* TimeSource.cpp */,
-				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
-				483646960D83D13700912FEC /* ContentLoader.h */,
-				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
-				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
-				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
-				485A056E0D71EDC40024198D /* SaveGameFile.h */,
-				485A05670D71ED8D0024198D /* CoreMessages.h */,
-				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
-				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
-				485A05710D71EDC40024198D /* SaveGameManager.h */,
-				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
-				483646970D83D13700912FEC /* SoundStitching.h */,
-				483646980D83D13700912FEC /* StartAnimationJob.h */,
-				485A057D0D71EDF20024198D /* JobQueue.cpp */,
-				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
-				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
-				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
-				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
-				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
-				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
-				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
-				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
-				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
-				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
-				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
-				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
-				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
-				44D814730BF7B62F00534175 /* CoreDefines.h */,
-				44D814740BF7B62F00534175 /* LightFadeJob.h */,
-				44D814750BF7B62F00534175 /* Trigger.h */,
-				44D814760BF7B62F00534175 /* Zone.h */,
-				44D814770BF7B62F00534175 /* ZoneManager.h */,
-				44D8146F0BF7B61500534175 /* Zone.cpp */,
-				44D814700BF7B61500534175 /* ZoneManager.cpp */,
-				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
-				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
-				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
-				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
-				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
-				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
-				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
-				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
-				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
-				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
-				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
-				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
-				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
-				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
-				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
-				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
-				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
-				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
-				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
-				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
-				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
-				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
-				444EABB50BD0E33300C6D4A0 /* Job.h */,
-				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
-				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
-				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
-				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
-				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
-				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
-				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
-				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
-				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
-				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
-				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
-				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
-				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
-				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
-				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
-				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
-				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
-				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
-				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
-				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
-				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
-				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
-				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
-				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
-				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
-				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
-				444EABD60BD0E33300C6D4A0 /* Sound.h */,
-				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
-				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
-				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
-				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
-				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
-				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
-				444EABDD0BD0E33300C6D4A0 /* World.h */,
-				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
-				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
-				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
-				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
-				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
-				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
-				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
-				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
-				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
-				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
-				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
-				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
-				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
-				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
-				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
-				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
-				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
-				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
-				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
-				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
-				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
-				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
-				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
-				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
-				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
-				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
-				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
-				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
-				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
-				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
-				444EAB420BD0E2B600C6D4A0 /* nulldriver */,
-				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
-				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
-				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
-				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
-				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
-				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
-				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
-				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
-				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
-				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
-				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
-				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
-				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
-				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
-				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
-				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
-				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
-				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
-				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
-				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
-				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
-				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+				4851EA4C0EDDC82400AB79E9 /* Source */,
+				4851EA4D0EDDC8CA00AB79E9 /* Header */,
 			);
 			name = RlCore;
+			path = core;
 			sourceTree = &quot;&lt;group&gt;&quot;;
 		};
 		444EAC220BD0E3E000C6D4A0 /* RlAi */ = {
@@ -2066,7 +1909,9 @@
 				444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */,
 				444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */,
 				48D0BE680E273FF400863824 /* DialogLoader.h */,
+				4887FE6E0EE7C7B9007674DC /* DialogLoaderImpl.h */,
 				48D0BE6B0E27401E00863824 /* DialogLoader.cpp */,
+				4887FE700EE7C7D9007674DC /* DialogLoaderImpl.cpp */,
 			);
 			name = RlAi;
 			sourceTree = &quot;&lt;group&gt;&quot;;
@@ -2174,6 +2019,184 @@
 			path = src;
 			sourceTree = &quot;&lt;group&gt;&quot;;
 		};
+		4851EA4C0EDDC82400AB79E9 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
+				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
+				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
+				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
+				485A05860D71EDF20024198D /* Trigger.cpp */,
+				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
+				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
+				48D34A620D90F5D500C89477 /* SaveGameData.cpp */,
+				485A05850D71EDF20024198D /* TimeSource.cpp */,
+				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
+				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
+				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
+				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
+				485A057D0D71EDF20024198D /* JobQueue.cpp */,
+				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
+				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
+				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
+				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
+				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
+				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
+				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
+				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
+				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
+				44D8146F0BF7B61500534175 /* Zone.cpp */,
+				44D814700BF7B61500534175 /* ZoneManager.cpp */,
+				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
+				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
+				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
+				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
+				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
+				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
+				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
+				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
+				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
+				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
+				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
+				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
+				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
+				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
+				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
+				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
+				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
+				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
+				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
+				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
+				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
+				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
+				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
+				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
+				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
+				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
+				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
+				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
+				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
+				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
+				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
+				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
+				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
+				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
+				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
+				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
+				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
+				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
+				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
+				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
+				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
+				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
+				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
+				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
+				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
+				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
+				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
+				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
+				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
+				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
+				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
+				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+			);
+			name = Source;
+			path = src;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		4851EA4D0EDDC8CA00AB79E9 /* Header */ = {
+			isa = PBXGroup;
+			children = (
+				48D0BE280E273C5E00863824 /* SaveAble.h */,
+				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
+				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
+				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
+				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
+				485A05690D71EDC40024198D /* JobQueue.h */,
+				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
+				485A05720D71EDC40024198D /* TimeSource.h */,
+				48D34A610D90F5D500C89477 /* SaveGameData.h */,
+				483646960D83D13700912FEC /* ContentLoader.h */,
+				485A056E0D71EDC40024198D /* SaveGameFile.h */,
+				485A05670D71ED8D0024198D /* CoreMessages.h */,
+				485A056F0D71EDC40024198D /* SaveGameFileReader.h */,
+				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
+				485A05710D71EDC40024198D /* SaveGameManager.h */,
+				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
+				483646970D83D13700912FEC /* SoundStitching.h */,
+				483646980D83D13700912FEC /* StartAnimationJob.h */,
+				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
+				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
+				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
+				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
+				44D814730BF7B62F00534175 /* CoreDefines.h */,
+				44D814740BF7B62F00534175 /* LightFadeJob.h */,
+				44D814750BF7B62F00534175 /* Trigger.h */,
+				44D814760BF7B62F00534175 /* Zone.h */,
+				44D814770BF7B62F00534175 /* ZoneManager.h */,
+				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
+				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
+				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
+				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
+				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
+				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
+				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
+				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
+				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
+				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
+				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
+				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
+				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
+				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
+				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
+				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
+				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
+				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
+				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
+				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
+				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
+				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
+				444EABB50BD0E33300C6D4A0 /* Job.h */,
+				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
+				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
+				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
+				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
+				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
+				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
+				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
+				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
+				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
+				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
+				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
+				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
+				4851EA4E0EDDC93300AB79E9 /* NullSoundStitching.h */,
+				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
+				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
+				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
+				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
+				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
+				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
+				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
+				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
+				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
+				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
+				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
+				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
+				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
+				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
+				444EABD60BD0E33300C6D4A0 /* Sound.h */,
+				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
+				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
+				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
+				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
+				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
+				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
+				444EABDD0BD0E33300C6D4A0 /* World.h */,
+			);
+			name = Header;
+			path = include;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
 		48B006C30ECABFB0008141C2 /* windows */ = {
 			isa = PBXGroup;
 			children = (
@@ -2651,7 +2674,6 @@
 				483646990D83D13700912FEC /* ContentLoader.h in Headers */,
 				4836469A0D83D13700912FEC /* SoundStitching.h in Headers */,
 				4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */,
-				483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */,
 				48389C0F0D86797000AFAB66 /* SoundStitchingObject.h in Headers */,
 				48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */,
 				48D34A630D90F5D500C89477 /* SaveGameData.h in Headers */,
@@ -2664,6 +2686,7 @@
 				48D0BE2D0E273C5E00863824 /* SaveAbleCollection.h in Headers */,
 				48D0BE2E0E273C5E00863824 /* SaveAbleFactory.h in Headers */,
 				48D0BE2F0E273C5E00863824 /* SaveAbleManager.h in Headers */,
+				4851EA4F0EDDC93300AB79E9 /* NullSoundStitching.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2710,6 +2733,7 @@
 				483D31630D85B398003477A0 /* SimpleVehicle.h in Headers */,
 				483D31640D85B398003477A0 /* WalkPathBehaviour.h in Headers */,
 				48D0BE690E273FF400863824 /* DialogLoader.h in Headers */,
+				4887FE6F0EE7C7B9007674DC /* DialogLoaderImpl.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3317,6 +3341,7 @@
 				48389BC10D8675E700AFAB66 /* DialogResponse.cpp in Sources */,
 				48389BC20D8675E700AFAB66 /* DialogVariable.cpp in Sources */,
 				48D0BE6D0E27401E00863824 /* DialogLoader.cpp in Sources */,
+				4887FE710EE7C7D9007674DC /* DialogLoaderImpl.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/cmake/FindOGRE.cmake
===================================================================
--- rl/branches/newton20/cmake/FindOGRE.cmake	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/cmake/FindOGRE.cmake	2008-12-17 20:11:09 UTC (rev 4654)
@@ -47,6 +47,9 @@
 	CACHE STRING &quot;&quot;
 )
 
+# Allow to set Ogre plugin path manually
+SET(OGRE_PLUGINDIR &quot;&quot; CACHE STRING &quot;Ogre plugin directory&quot;)
+
 #Search for the headers and libraries
 IF (WIN32) #Windows
 	MESSAGE(STATUS &quot;Looking for OGRE&quot;)
@@ -57,6 +60,10 @@
 	IF(PKG_CONFIG_FOUND)
 		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
 		PKG_SEARCH_MODULE(OGRE OGRE)
+		IF(NOT PKGCONFIG_FAILED)
+			_PKGCONFIG_INVOKE(OGRE &quot;OGRE&quot; PLUGINDIR &quot;&quot; --variable=plugindir)
+			ADD_DEFINITIONS(-DOGRE_PLUGINDIR=\\&quot;${OGRE_PLUGINDIR}\\&quot;)
+		ENDIF(NOT PKGCONFIG_FAILED)
 		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
 		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
 		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING &quot;&quot;)

Copied: rl/branches/newton20/cmake/FindOgreNewt.cmake (from rev 4644, rl/trunk/cmake/FindOgreNewt.cmake)

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -124,6 +124,7 @@
         self.gocName = gameObjectClass
         self.node = node
         self.meshFile = meshFile
+        self.state = &quot;IN_SCENE&quot;
 
     def getType(self):
         return &quot;GAME_OBJECT_REPRESENTATION&quot;

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -59,6 +59,8 @@
         self.objectPropertyWin = ObjectPropertyWin(self)
         self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
         self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
         self.createDockWindows()
@@ -273,6 +275,9 @@
         og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+        self.moduleManager.pivot.hide()
+
         oglog = og.LogManager.getSingleton().getDefaultLog()
         oglog.addListener(self.consoleWindow.lockenLog)
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -97,9 +97,8 @@
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
-        QObject.connect(self.modelSearchBox,SIGNAL(&quot;textChanged(QString)&quot;),self.listWidget.clearSelection)
-        QMetaObject.connectSlotsByName(self)
 
+
     def retranslateUi(self):
         self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
 
@@ -115,14 +114,14 @@
         self.node.setScale(og.Vector3(1,1,1))
         bb = self.ent.getBoundingBox()
 
-    def scanDirForModels(self, dir, name):
+    def scanDirForModels(self, dir):
         for file in os.listdir(dir):
             curFile = dir + &quot;/&quot; + file
 
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
             if isdir(curFile):
-                self.scanDirForModels(curFile, file)
+                self.scanDirForModels(curFile)
                 continue
             if isfile(curFile):
                 if file.endswith(&quot;.mesh&quot;):
@@ -143,6 +142,7 @@
         if event.type() == 5:
             self.startDrag()
             event.accept()
+            return True
 
         return False
 
@@ -152,6 +152,7 @@
                 self.ogreModelPrevWindow.zoomCamera(-5)
             else:
                 self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
 
         if event.type() == 5: #mouse moved while button down
             rotX = (event.globalX() - self.lastMousePosX) * 0.01
@@ -162,10 +163,12 @@
 
             self.lastMousePosX = event.globalX()
             self.lastMousePosY = event.globalY()
+            return True
 
         if event.type() == 3: # mouse released
             self.lastMousePosX = 0
             self.lastMousePosY = 0
+            return True
 
         return False
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -35,32 +35,77 @@
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
 
+#                &lt;zone name=&quot;Testzone&quot;&gt;
+#                        &lt;area type=&quot;sphere&quot;&gt;
+#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
+#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
+#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
+#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
+#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
+#                        &lt;/area&gt;
+#                        &lt;light name=&quot;red pointlight&quot;/&gt;
+#                        &lt;light name=&quot;green spotlight&quot;/&gt;
+#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
+#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
+#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
+#                        &lt;/trigger&gt;
+#                &lt;/zone&gt;
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
         self.pathToMapFile = pathToFile
         self.sceneManager = sceneManager
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
 
         xmlTree = xml.parse(pathToFile)
         root = xmlTree.getroot()
 
         if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
-            self.parseMap(root)
+            self.parseMapNodes(root.find(&quot;nodes&quot;))
+            #self.parseMapZones(root.find(&quot;zones&quot;))
         else:
             print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
             return
 
-    def parseMap(self, rootElement):
-        nodes = rootElement.getiterator(&quot;entity&quot;)
-        for n in nodes:
-            entityName = n.attrib[&quot;name&quot;]
-            meshFile = n.attrib[&quot;meshfile&quot;]
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;entity&quot;)
+        if len(nodes) &gt; 0:
+            self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator(&quot;light&quot;)
+        if len(nodes) &gt; 0:
+            self.createLights(nodes)
+
+        nodes = nodeElement.getiterator(&quot;sound&quot;)
+        if len(nodes) &gt; 0:
+            self.createSound(nodes)
+
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        if len(nodes) &gt; 0:
+            self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
+        if len(nodes) &gt; 0:
+            self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib[&quot;name&quot;]
+            print entityName
+            meshFile = nodes.attrib[&quot;meshfile&quot;]
             nodePosition = None
             nodeRotation = None
             nodeScale = None
 
-            transformations = n.getiterator()
+            transformations = nodes.getiterator()
             for t in transformations:
                 if t.tag == &quot;position&quot;:
                     x = float(t.attrib[&quot;x&quot;])
@@ -83,7 +128,7 @@
                 e = self.sceneManager.createEntity(entityName, meshFile)
             except:
                 print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                return
+                continue
 
             n = self.mapNode.createChild(entityName + &quot;_node&quot;)
             n.attachObject(e)
@@ -91,17 +136,113 @@
             n.setOrientation(nodeRotation)
             n.setScale(nodeScale)
 
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib[&quot;name&quot;]
+            lightType = l.attrib[&quot;type&quot;]
+            lightVisible = bool(l.attrib[&quot;visible&quot;])
+            castShadows = bool(l.attrib[&quot;castShadows&quot;])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationlinear = None
+            lightAttenuationQuadratic = None
 
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;colourDiffuse&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == &quot;colourSpecular&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == &quot;lightAttenuation&quot;:
+                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
+                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
+                    lightAttenuationlinear = float(t.attrib[&quot;linear&quot;])
+                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
 
+            e = self.sceneManager.createEntity(lightName, &quot;lightbulp.mesh&quot;)
+            n = self.mapNode.createChild(lightName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(lightPosition)
 
+    def createSound(self, soundNodes):
+        raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib[&quot;class&quot;]
+            id = int(g.attrib[&quot;id&quot;])
+            state = g.attrib[&quot;state&quot;]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == &quot;scale&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
+                dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        raise NotImplementedError
+        return
+
 class Scene():
     def __init__(self):
         return
 
 class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
 
         self.name = name
         self.moduleRoot = join(modulePath, name)
@@ -164,11 +305,15 @@
         self.setResourcePaths()
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
         if not self.isCommon():
             cmd = join(self.moduleRoot, &quot;maps/*.rlmap.xml&quot;)
             maps = glob.glob(cmd)
             for m in maps:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
 
             cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
             sceneFile = glob.glob(cmd)
@@ -191,7 +336,7 @@
 
 
             if file.startswith('.'): #ignore dot files (hidden)
-                pass
+                continue
             if os.path.isdir(curFile):
                 og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
                 self.setResourcePaths(curFile)
@@ -202,10 +347,17 @@
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
         self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
 
         self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
 
+
         self.mainModule = []
         self.mainModuledependencieList =[]
         self.moduleList = []
@@ -213,16 +365,12 @@
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
 
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
         self.listenerDings = MyRaySceneQueryListener()
 
         self.lastRay = None
 #        self.rayLine = None
 
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
         self.pivot = None
         self.movingPivot = False
 
@@ -253,7 +401,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
 
         self.moduleConfigIsParsed = True
 
@@ -280,20 +428,33 @@
         if dlg.exec_():
             self.loadModule(str(list.currentItem().text()))
 
+    # I'm sorry for this
     def loadModule(self, moduleName):
         for m in self.moduleList:
             if m.name == moduleName:
-                if m.hasDependencies:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
                     for moduleDependencie in m.moduleDependencies:
                         for m2 in self.moduleList:
                             if m2.name == moduleDependencie:
                                 m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
                 m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
                 self.mainModule = m
 
+        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
+        e.setMaterialName(&quot;Lockenwickler_Area&quot;)
 
+        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
+        e2.setMaterialName(&quot;Lockenwickler_Area&quot;)
+
+        n.attachObject(e)
+        n.attachObject(e2)
+        n.setScale(og.Vector3(10, 5, 20))
+
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
         self.listenerDings.reset()
@@ -496,9 +657,9 @@
 
     def startDropGameObjectAction(self, classid, ray):
         go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
 
         if go is not None:
+            meshFile = go.getMeshFileName()
             dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
             dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
             dropNode.attachObject(dropEntity)

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-12-17 20:11:09 UTC (rev 4654)
@@ -150,6 +150,7 @@
 
     def eventFilter(self, obj, event):
         if event.type() == 2:
+            self.ogreRenderWindow.setFocus()
             if event.button() == 1: # left mouse button is pressed
                 self.leftMouseDown = True
                 self.moduleManager.leftMouseDown = True

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/Barrel.mesh
===================================================================
(Binary files differ)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/Example.material
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/media/Example.material	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/media/Example.material	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,18 +0,0 @@
-material RustyBarrel
-{
-	technique
-	{
-		pass
-		{
-			ambient 0.5 0.5 0.5 1.0
-			diffuse 1.0 1.0 1.0 1.0
-			specular 0.0 0.0 0.0 1.0 12.5
-			emissive 0.0 0.0 0.0 1.0
-			texture_unit
-			{
-				texture RustyBarrel.png
-				filtering trilinear
-			}
-		}
-	}
-}

Modified: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2008-12-17 20:11:09 UTC (rev 4654)
@@ -4,8 +4,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 1.0 0.0 0.0 0.5
 			diffuse 1.0 0.0 0.0 0.5
 			specular 1.0 0.0 0.0 0.5 12.5
@@ -21,8 +19,6 @@
 
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -37,8 +33,6 @@
 	{
 		pass
 		{
-                        depth_check off
-                        depth_write off
 			ambient 0.0 1.0 0.0 0.5
 			diffuse 0.0 1.0 0.0 0.5
 			specular 0.0 1.0 0.0 0.5 12.5
@@ -60,4 +54,44 @@
 		}
 	}
 }
+
+material SOLID/TEX/lightbulp.png
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+				texture lightbulp.png
+			}
+		}
+	}
+}
+
+material Lockenwickler_Area
+{
+	technique
+	{
+                pass
+		{
+                        depth_write off
+                        scene_blend alpha_blend
+                        
+			ambient 0.0 1.0 0.0 0.2
+			diffuse 0.0 1.0 0.0 0.2
+			emissive 0.0 1.0 0.0 0.2
+		}
+
+		pass
+		{
+                        polygon_mode wireframe
+
+			ambient 0.0 1.0 0.0 1.0
+			diffuse 0.0 1.0 0.0 1.0
+			emissive 0.0 1.0 0.0 1.0
+		}
+	}
+}
+
  

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/UniCube.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/UniCube.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/UniSphere.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/UniSphere.mesh)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.blend (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.blend)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.mesh (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulp.png (from rev 4653, rl/trunk/editors/Lockenwickler/src/media/lightbulp.png)

Copied: rl/branches/newton20/engine/ai/CMakeLists.txt (from rev 4644, rl/trunk/engine/ai/CMakeLists.txt)

Modified: rl/branches/newton20/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ai/RlAI2005.vcproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/RlAI2005.vcproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -367,6 +367,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\DialogLoaderImpl.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\DialogManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -541,6 +545,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\DialogLoaderImpl.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\DialogManager.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/branches/newton20/engine/ai/include/DialogImplication.h
===================================================================
--- rl/branches/newton20/engine/ai/include/DialogImplication.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/DialogImplication.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,96 +1,103 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DialogImplication_H__
-#define __DialogImplication_H__
-
-#include &quot;AiPrerequisites.h&quot;
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport DialogImplication
-    {
-    public:
-        DialogImplication();
-        virtual ~DialogImplication();
-        
-        virtual void apply(Dialog* dialog) = 0;
-    };
-
-    class DialogVariableAssignment : public DialogImplication
-    {
-    public:
-        DialogVariableAssignment(const Ogre::String&amp; variableName, 
-                                 const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-
-    protected:
-        Ogre::String mVariableName; 
-        CeGuiString mValue;
-    };
-
-    class DialogVariableIncrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableIncrease(const Ogre::String&amp; variableName, 
-                               const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogVariableDecrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableDecrease(const Ogre::String&amp; variableName, 
-                               const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogElementActivation : public DialogImplication
-    {
-    public:
-        DialogElementActivation(const CeGuiString&amp; id, bool value, bool isOption);
-        virtual void apply(Dialog* dialog);
-    private:
-        CeGuiString mElementId;
-        bool mValue;
-        bool mIsOption;
-    };
-
-	class DialogExit : public DialogImplication
-	{
-	public:
-		virtual void apply(Dialog* dialog);
-	};
-
-    class QuestPropertyAssignment : public DialogImplication
-    {
-    public:
-        QuestPropertyAssignment(const Ogre::String&amp; questId, const Ogre::String&amp; prop, const CeGuiString&amp; newValue);
-        virtual void apply(Dialog* dialog);
-
-    private:
-        Ogre::String mQuestId;
-        Ogre::String mProperty;
-        CeGuiString mNewValue;
-    };
-}
-
-#endif //__DialogImplication_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String&amp; variableName, 
+                                 const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+
+    protected:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+
+    class DialogVariableIncrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableIncrease(const Ogre::String&amp; variableName, 
+                               const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogVariableDecrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableDecrease(const Ogre::String&amp; variableName, 
+                               const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogElementActivation : public DialogImplication
+    {
+    public:
+        DialogElementActivation(const CeGuiString&amp; id, bool value, bool isOption);
+        virtual void apply(Dialog* dialog);
+    private:
+        CeGuiString mElementId;
+        bool mValue;
+        bool mIsOption;
+    };
+
+	class DialogExit : public DialogImplication
+	{
+	public:
+		virtual void apply(Dialog* dialog);
+	};
+
+    class QuestPropertyAssignment : public DialogImplication
+    {
+    public:
+        QuestPropertyAssignment(const Ogre::String&amp; questId, const Ogre::String&amp; prop, const CeGuiString&amp; newValue);
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mQuestId;
+        Ogre::String mProperty;
+        CeGuiString mNewValue;
+    };
+    
+    class CombatStart : public DialogImplication
+    {
+    public:
+        CombatStart();
+        virtual void apply(Dialog* dialog);
+    };
+}
+
+#endif //__DialogImplication_H__

Modified: rl/branches/newton20/engine/ai/include/DialogLoader.h
===================================================================
--- rl/branches/newton20/engine/ai/include/DialogLoader.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/DialogLoader.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,24 +18,13 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
-#include &quot;Properties.h&quot;
-#include &quot;XmlProcessor.h&quot;
- 
 namespace rl 
 {
 	class Creature;
     class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-	class Property;
+    class DialogLoaderImpl;
 
-
-	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	class DialogLoader : public Ogre::ScriptLoader
 	{
 	public:
 		DialogLoader();
@@ -48,48 +37,9 @@
 		Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
 
 	private: 
-		class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString&amp; id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString&amp; id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
-            void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-
-        private:
-            std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
-            std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-		
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
-
         Ogre::StringVector mScriptPatterns;
-        std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
-
-	};
+        DialogLoaderImpl* mLoaderImplementation;
+    };
 }
 
 #endif //__DialogLoader_H__

Copied: rl/branches/newton20/engine/ai/include/DialogLoaderImpl.h (from rev 4644, rl/trunk/engine/ai/include/DialogLoaderImpl.h)

Modified: rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/FuzzyStateMachine.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,167 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __RlAI_FuzzyStateMachine_H__
-#define __RlAI_FuzzyStateMachine_H__
-#include &lt;list&gt;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;FuzzyState.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-
-namespace rl
-{
-	/** manages a set of FuzzyState objects 
-	 */
-	template &lt;class Controller&gt; class FuzzyStateMachine :
-		public FuzzyState&lt;Controller&gt;
-	{
-	public:
-		//! typedefinition for pointer to a FuzzyState
-		typedef FuzzyState&lt;Controller&gt;* FuzzyStatePtr;
-
-		/** Constructor
-		 * sets parent and controller for the FuzzyStateMachine
-		 * @param parent gives the parent FuzzyState object
-		 * @param controller sets the controller object
-		 */
-		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
-			: FuzzyState&lt;Controller&gt;(parent, controller), mMaxActiveStates(), mStates() {}
-
-		/** destructor.
-		 * removes internally stored Fuzzystate objects
-		 */
-		virtual ~FuzzyStateMachine(void)
-		{
-			clearStates();
-		}
-
-		/** adds a FuzzyState object
-		 * @param state a FuzzyState object to add.
-		 */
-		virtual void addState(FuzzyStatePtr state)
-		{
-			mStates.push_back(State(false, state));
-            ScriptWrapper::getSingleton().owned( state );
-		}
-		/** removes all stored FuzzyState objects
-		 */
-        virtual void clearStates()
-		{
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.begin(); ++itr)
-			{
-                ScriptWrapper::getSingleton().disowned( itr-&gt;second );
-				delete itr-&gt;second;
-			}
-			mStates.clear();
-		}
-
-		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
-		 * So always return false (no).
-		 * @returns false
-		 */
-		virtual bool isActive(FuzzyStatePtr state)
-		{
-			return false; 
-		}
-		/** reset function for resetting the FuzzyStateMachine
-		 */
-		virtual void reset(){}
-
-		/** sets the maximum number of concurrently active states.
-		 * @param count maximum number of concurrently active states.
-		 */
-		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
-		/** fetches the maximum number of concurrently active states.
-		 * @param int returns the maximum number of concurrently active states.
-		 */
-		virtual int getMaxActivity() { return mMaxActiveStates; }
-
-		/** calculates the activation value.
-		 * @returns float containing the calculated activation value.
-		 */
-		float calculateActivation(void){ return 0.0f; }
-
-		/** initializes the fuzzy state.
-		 */
-		virtual void init(){}
-		/** should activate the fuzzy state.
-		 */
-		virtual void activate(){}
-		/** deactivates fuzzy state.
-		 */
-		virtual void deactivate(){}
-		/** tells the fuzzy state machine to update for the elapsed time.
-		 * For each stored FuzzyState the activation is calculated and
-		 * testified whether it activates the state or not. When a state
-		 * is active its update function is called with the elapsed time.
-		 * @param elapsedtime gives the elapsed time as a float
-		 */
-		virtual void update(const float elapsedTime)
-		{
-			if(mStates.empty())
-				return;
-
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.end(); ++itr)
-			{
-				bool isActive = (itr-&gt;second-&gt;calculateActivation() &gt; 0);
-				if(isActive)
-				{
-				//  if state is already active, update it, otherwise activate it
-					if(itr-&gt;first)
-					{
-						itr-&gt;second-&gt;update(elapsedTime);
-					}
-					else
-					{
-						itr-&gt;second-&gt;activate();
-						itr-&gt;first = true;
-						// maybe call update here, too
-					}
-				}
-				else
-				{
-				//	if state was active, deactivate it, otherwise do nothing
-					if(itr-&gt;first)
-					{
-						itr-&gt;second-&gt;deactivate();
-						itr-&gt;first = false;
-					}	
-				}
-			}
-		}
-
-
-	protected:
-		//! maximum number of active states
-		int mMaxActiveStates;
-		/** typedefinition for active/inactive and FuzzyState objects.
-		 * When the boolean is true, the state is active, otherwise not
-		 */
-		typedef std::pair&lt;bool, FuzzyStatePtr&gt; State;
-		//! defines a double linked list of states
-		typedef std::list&lt;State&gt; StateList;
-		//! the double linked list of stored FuzzyState objects
-		StateList mStates;
-	};
-
-/*	template &lt;class Controller&gt; void FuzzyStateMachine&lt;Controller&gt;::update(float elapsedTime)
-	{
-
-	}
-*/
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __RlAI_FuzzyStateMachine_H__
+#define __RlAI_FuzzyStateMachine_H__
+#include &lt;list&gt;
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;FuzzyState.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+
+namespace rl
+{
+	/** manages a set of FuzzyState objects 
+	 */
+	template &lt;class Controller&gt; class FuzzyStateMachine :
+		public FuzzyState&lt;Controller&gt;
+	{
+	public:
+		//! typedefinition for pointer to a FuzzyState
+		typedef FuzzyState&lt;Controller&gt;* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
+		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
+			: FuzzyState&lt;Controller&gt;(parent, controller), mMaxActiveStates(), mStates() {}
+
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
+		virtual ~FuzzyStateMachine(void)
+		{
+			clearStates();
+		}
+
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
+		virtual void addState(FuzzyStatePtr state)
+		{
+			mStates.push_back(State(false, state));
+            ScriptWrapper::getSingleton().owned( state );
+		}
+		/** removes all stored FuzzyState objects
+		 */
+        virtual void clearStates()
+		{
+			for(typename StateList::iterator itr = mStates.begin(); itr != mStates.end(); ++itr)
+			{
+                FuzzyStatePtr state = itr-&gt;second;
+                ScriptWrapper::getSingleton().disowned( state );
+				delete state;
+			}
+			mStates.clear();
+		}
+
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
+		virtual bool isActive(FuzzyStatePtr state)
+		{
+			return false; 
+		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
+		virtual void reset(){}
+
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
+		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
+		virtual int getMaxActivity() { return mMaxActiveStates; }
+
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
+		float calculateActivation(void){ return 0.0f; }
+
+		/** initializes the fuzzy state.
+		 */
+		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
+		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
+		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
+		virtual void update(const float elapsedTime)
+		{
+			if(mStates.empty())
+				return;
+
+			typename StateList::iterator itr = mStates.begin();
+			for(; itr != mStates.end(); ++itr)
+			{
+				bool isActive = (itr-&gt;second-&gt;calculateActivation() &gt; 0);
+				if(isActive)
+				{
+				//  if state is already active, update it, otherwise activate it
+					if(itr-&gt;first)
+					{
+						itr-&gt;second-&gt;update(elapsedTime);
+					}
+					else
+					{
+						itr-&gt;second-&gt;activate();
+						itr-&gt;first = true;
+						// maybe call update here, too
+					}
+				}
+				else
+				{
+				//	if state was active, deactivate it, otherwise do nothing
+					if(itr-&gt;first)
+					{
+						itr-&gt;second-&gt;deactivate();
+						itr-&gt;first = false;
+					}	
+				}
+			}
+		}
+
+
+	protected:
+		//! maximum number of active states
+		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
+		typedef std::pair&lt;bool, FuzzyStatePtr&gt; State;
+		//! defines a double linked list of states
+		typedef std::list&lt;State&gt; StateList;
+		//! the double linked list of stored FuzzyState objects
+		StateList mStates;
+	};
+
+/*	template &lt;class Controller&gt; void FuzzyStateMachine&lt;Controller&gt;::update(float elapsedTime)
+	{
+
+	}
+*/
+}
+#endif

Modified: rl/branches/newton20/engine/ai/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ai/include/Makefile.am	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/include/Makefile.am	2008-12-17 20:11:09 UTC (rev 4654)
@@ -20,6 +20,7 @@
 	DialogElementSelection.h \
 	DialogImplication.h \
 	DialogLoader.h \
+	DialogLoaderImpl.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/branches/newton20/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/DialogImplication.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/DialogImplication.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,137 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;DialogImplication.h&quot;
-
-#include &quot;Dialog.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;Property.h&quot;
-#include &quot;QuestBook.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    DialogImplication::DialogImplication()
-    {
-    }
-
-    DialogImplication::~DialogImplication()
-    {
-    }
-
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
-                                                       const CeGuiString&amp; value)
-        : mVariableName(variableName), mValue(value)
-    {
-    }
-
-    void DialogVariableAssignment::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        prop.getFromString(mValue);
-        dialog-&gt;setProperty(mVariableName, prop);
-    }
-
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
-                                                   const CeGuiString&amp; value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableIncrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog-&gt;getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
-            prop.setValue(value);
-            dialog-&gt;setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
-                                      + mVariableName
-                                      + &quot;'. The variable's type is not a number&quot;);
-        }
-    }
-
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
-                                                   const CeGuiString&amp; value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableDecrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog-&gt;getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
-            prop.setValue(value);
-            dialog-&gt;setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
-                                      + mVariableName
-                                      + &quot;'. The variable's type is not a number&quot;);
-        }
-    }
-
-    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
-                                                     bool value,
-                                                     bool isOption)
-        : mElementId(id), mValue(value), mIsOption(isOption)
-    {
-    }
-
-    void DialogElementActivation::apply(Dialog* dialog)
-    {
-        Property prop;
-        if(mIsOption)
-        {
-            dialog-&gt;setProperty(&quot;option&quot; + mElementId + &quot;isActive&quot;, mValue);
-        }
-        else
-        {
-            dialog-&gt;setProperty(&quot;response&quot; + mElementId + &quot;isActive&quot;, mValue);
-        }
-    }
-
-	void DialogExit::apply(rl::Dialog *dialog)
-	{
-		dialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, true);
-	}
-
-    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &amp;questId, const Ogre::String &amp;prop, const rl::CeGuiString &amp;newValue)
-        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
-    {
-    }
-
-    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
-    {
-        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
-        quest-&gt;setPropertyAsString(mProperty, mNewValue);
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogImplication.h&quot;
+
+#include &quot;Combat.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;Property.h&quot;
+#include &quot;QuestBook.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
+                                                       const CeGuiString&amp; value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog-&gt;setProperty(mVariableName, prop);
+    }
+
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
+                                                   const CeGuiString&amp; value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableIncrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog-&gt;getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
+            prop.setValue(value);
+            dialog-&gt;setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
+                                      + mVariableName
+                                      + &quot;'. The variable's type is not a number&quot;);
+        }
+    }
+
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
+                                                   const CeGuiString&amp; value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableDecrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog-&gt;getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
+            prop.setValue(value);
+            dialog-&gt;setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
+                                      + mVariableName
+                                      + &quot;'. The variable's type is not a number&quot;);
+        }
+    }
+
+    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
+                                                     bool value,
+                                                     bool isOption)
+        : mElementId(id), mValue(value), mIsOption(isOption)
+    {
+    }
+
+    void DialogElementActivation::apply(Dialog* dialog)
+    {
+        Property prop;
+        if(mIsOption)
+        {
+            dialog-&gt;setProperty(&quot;option&quot; + mElementId + &quot;isActive&quot;, mValue);
+        }
+        else
+        {
+            dialog-&gt;setProperty(&quot;response&quot; + mElementId + &quot;isActive&quot;, mValue);
+        }
+    }
+
+	void DialogExit::apply(rl::Dialog *dialog)
+	{
+		dialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, true);
+	}
+
+    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &amp;questId, const Ogre::String &amp;prop, const rl::CeGuiString &amp;newValue)
+        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
+    {
+    }
+
+    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
+    {
+        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
+        quest-&gt;setPropertyAsString(mProperty, mNewValue);
+    }
+    
+    CombatStart::CombatStart()
+    {
+    }
+    
+    void CombatStart::apply(Dialog* dialog)
+    {
+        Combat* combat = CombatManager::getSingleton().startCombat();
+        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
+        for (std::vector&lt;Creature*&gt;::iterator it = allies.begin(); it != allies.end(); ++it)
+        {
+            combat-&gt;addAlly(*it);            
+        }
+        std::vector&lt;Creature*&gt; enemies = dialog-&gt;getNonPlayerCharacters();
+        for (std::vector&lt;Creature*&gt;::iterator it = enemies.begin(); it != enemies.end(); ++it)
+        {
+            combat-&gt;addOpponent(*it);
+        }
+        combat-&gt;start();
+    }
+
+}

Modified: rl/branches/newton20/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/DialogLoader.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/DialogLoader.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,57 +1,38 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
 
 #include &quot;stdinc.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;DialogLoader.h&quot;
+#include &quot;DialogLoaderImpl.h&quot;
 
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;Dialog.h&quot;
-#include &quot;DialogCondition.h&quot;
-#include &quot;DialogElement.h&quot;
-#include &quot;DialogImplication.h&quot;
-#include &quot;DialogOption.h&quot;
-#include &quot;DialogParagraph.h&quot;
-#include &quot;DialogResponse.h&quot;
-#include &quot;DialogVariable.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
 	DialogLoader::DialogLoader()
-	      : XmlProcessor(), ScriptLoader()
+	      : ScriptLoader()
     {
+        mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back(&quot;*.dialog&quot;);
   	}
 	
     DialogLoader::~DialogLoader()
     {
-		std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
-        std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
-        {
-			DialogPrototype* p = itr-&gt;second;
-			delete p;
-		}
-        mDialogs.clear();
+        delete mLoaderImplementation;
 	}
  
     const StringVector&amp; DialogLoader::getScriptPatterns() const
@@ -63,692 +44,16 @@
     {
         return 1000;
     }
-
-    void DialogLoader::parseScript(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
+    
+    void DialogLoader::parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-
-            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes-&gt;item(i);
-                processDialog(static_cast&lt;DOMElement*&gt;(cur));
-            }
-        }
-
-        shutdownXml();
+        mLoaderImplementation-&gt;parseDialog(stream, groupName);
     }
-	
-	Dialog* DialogLoader::createDialog(const String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, 
-		const std::vector&lt;Creature*&gt;&amp; npcs) const
-	{
-		std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
-			mDialogs.find(name);
-			
-		if (it == mDialogs.end())
-		{
-			return NULL;
-		}
-		
-		return it-&gt;second-&gt;createDialog(pcs, npcs);
-	}
-	
-    void DialogLoader::processDialog(DOMElement* dialogElem)
+    
+    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const
     {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
-        {
-            if (hasNodeName(curChild, &quot;variable&quot;))
-            {
-                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;option&quot;))
-            {
-                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchoption&quot;))
-            {
-                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;response&quot;))
-            {
-                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchresponse&quot;))
-            {
-                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;start&quot;))
-            {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild-&gt;getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype-&gt;setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
+        return mLoaderImplementation-&gt;createDialog(name, pcs, npcs);
     }
 
-    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
-            if (!hasAttribute(dialogElemXml, &quot;id&quot;))
-            {
-                Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
-            CeGuiString text = getValueAsString(dialogElemXml);
+}
 
-            if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
-            {
-                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
-                option-&gt;setLabel(text);
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;option&quot;))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, &quot;autoSelect&quot;);
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, &quot;label&quot;))
-                {
-                    option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
-                }
-                else
-                {
-                    option-&gt;setLabel(text);
-                }
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;response&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, &quot;response&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;gotoresponse&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchresponse&quot;))
-        {
-            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
-
-        DialogResponse* response = dialogPrototype-&gt;getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response-&gt;addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response-&gt;addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, &quot;gotoresponse&quot;))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
-                    response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response-&gt;addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
-        DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                response-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response-&gt;addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, &quot;option&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;optionref&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchoption&quot;))
-        {
-            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
-
-        DialogOption* option = dialogPrototype-&gt;getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option-&gt;setResponse(response);
-                }
-                else if (hasNodeName(cur, &quot;if&quot;))
-                {
-                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
-                }
-                else if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                        if(!label.empty())
-                        {
-                            option-&gt;setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option-&gt;addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
-            if(!label.empty())
-            {
-                option-&gt;setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
-        DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                option-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option-&gt;addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, &quot;t&quot;))
-            {
-                DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
-                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                    if(!label.empty())
-                    {
-                        option-&gt;setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype-&gt;setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond-&gt;setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = &quot;&quot;;
-        if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    DialogLoader::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogLoader::DialogPrototype::~DialogPrototype()
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it-&gt;second != NULL )
-                delete it-&gt;second;
-
-        std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1-&gt;second != NULL )
-                delete it1-&gt;second;
-    }
-
-    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
-        }
-        mOptionCache[option-&gt;getId()] = option;
-    }
-
-    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
-        }
-        mResponseCache[response-&gt;getId()] = response;
-    }
-
-    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogResponse*&gt;::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog-&gt;setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
-        }
-
-        return dialog;
-    }
-
-    void DialogLoader::DialogPrototype::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-
-    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, &quot;equals&quot;))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;inrange&quot;))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, &quot;from&quot;),
-                getAttributeValueAsReal(conditionXml, &quot;to&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lower&quot;))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lowereq&quot;))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greater&quot;))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greatereq&quot;))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, &quot;name&quot;));
-        }
-        else if (hasNodeName(variableXml, &quot;queststate&quot;))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, &quot;quest&quot;);
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, &quot;property&quot;);
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, &quot;attributecheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;attribute&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, &quot;talentcheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;talent&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-		else if (hasNodeName(variableXml, &quot;random&quot;))
-		{
-			int maximum = getAttributeValueAsInteger(variableXml, &quot;maximum&quot;);
-			return new RandomVariable(maximum);
-		}
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
-
-            if (hasNodeName(implicationElem, &quot;setvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;incvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;decvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;setoptionactive&quot;))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, &quot;id&quot;);
-                bool value = getAttributeValueAsBool(implicationElem, &quot;value&quot;);
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, &quot;exit&quot;))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, &quot;changequest&quot;))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, &quot;quest&quot;);
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, &quot;property&quot;);
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, &quot;newvalue&quot;);
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (hasNodeName(cur, &quot;p&quot;))
-            {
-                element-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-            }
-        }
-    }
-
-}
\ No newline at end of file

Copied: rl/branches/newton20/engine/ai/src/DialogLoaderImpl.cpp (from rev 4644, rl/trunk/engine/ai/src/DialogLoaderImpl.cpp)

Modified: rl/branches/newton20/engine/ai/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ai/src/Makefile.am	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ai/src/Makefile.am	2008-12-17 20:11:09 UTC (rev 4654)
@@ -22,6 +22,7 @@
 	DialogElement.cpp \
 	DialogImplication.cpp \
 	DialogLoader.cpp \
+	DialogLoaderImpl.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \

Copied: rl/branches/newton20/engine/common/CMakeLists.txt (from rev 4644, rl/trunk/engine/common/CMakeLists.txt)

Modified: rl/branches/newton20/engine/common/include/MathUtil.h
===================================================================
--- rl/branches/newton20/engine/common/include/MathUtil.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/include/MathUtil.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,39 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __MathUtil_H__
-#define __MathUtil_H__
-
-#include &quot;CommonPrerequisites.h&quot;
-
-namespace rl {
-
-class _RlCommonExport MathUtil
-{
-    public:
-        static const Ogre::Real EPSILON;
-
-        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
-            Ogre::Radian azimuth, Ogre::Radian altitude);
-
-        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real&amp; r,
-            Ogre::Radian&amp; azimuth, Ogre::Radian&amp; altitude);
-        static Ogre::Real normaliseAngle(Ogre::Real angle);
-
-		static Ogre::Real distance(const Ogre::AxisAlignedBox&amp; b1, const Ogre::AxisAlignedBox&amp; b2);
-};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __MathUtil_H__
+#define __MathUtil_H__
+
+#include &quot;CommonPrerequisites.h&quot;
+
+namespace rl 
+{
+    
+    class _RlCommonExport MathUtil
+    {
+    public:
+        static const Ogre::Real EPSILON;
+        
+        static Ogre::Vector3 sphericalToCartesian(Ogre::Real r,
+                                                  Ogre::Radian azimuth, Ogre::Radian altitude);
+        
+        static void cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real&amp; r,
+                                         Ogre::Radian&amp; azimuth, Ogre::Radian&amp; altitude);
+        static Ogre::Real normaliseAngle(Ogre::Real angle);
+        
+		static Ogre::Real distance(const Ogre::AxisAlignedBox&amp; b1, const Ogre::AxisAlignedBox&amp; b2);
+        static Ogre::Real distance(const Ogre::Vector3&amp; v, const Ogre::AxisAlignedBox&amp; b);
+        static Ogre::Real distance(const Ogre::AxisAlignedBox&amp; b, const Ogre::Vector3&amp; v);
+    };
+    
+}
+#endif

Modified: rl/branches/newton20/engine/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/newton20/engine/common/include/WriteableDataStream.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/include/WriteableDataStream.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -71,4 +71,5 @@
     };
 
     typedef Ogre::SharedPtr&lt;WriteableFileStreamDataStream&gt; WriteableFileStreamDataStreamPtr;
-}
\ No newline at end of file
+}
+

Modified: rl/branches/newton20/engine/common/src/MathUtil.cpp
===================================================================
--- rl/branches/newton20/engine/common/src/MathUtil.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/src/MathUtil.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,78 +1,104 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;MathUtil.h&quot;
-
-
-using namespace Ogre;
-
-namespace rl
-{
-    const Ogre::Real MathUtil::EPSILON = 0.00001f;
-
-    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
-        Ogre::Radian azimuth, Ogre::Radian altitude)
-    {
-        Vector3 rval;
-        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
-        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
-        return rval;
-    }
-
-    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real&amp; r,
-        Ogre::Radian&amp; azimuth, Ogre::Radian&amp; altitude)
-    {
-        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
-        azimuth = Math::ATan2(cartesian.x, cartesian.z);
-        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
-    }
-
-    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
-	{
-        Ogre::Real ang = angle;
-
-		while (ang &lt; 0) ang += 360;
-		while (ang &gt; 360) ang -= 360;
-
-		return ang;
-	}	
-
-	Real MathUtil::distance(const AxisAlignedBox&amp; b1, const AxisAlignedBox&amp; b2)
-	{
-		if (b1.intersects(b2))
-		{
-			return 0.0f;
-		}
-		else
-		{
-			Vector3 dv;
-
-			const Vector3&amp; min1 = b1.getMinimum();
-			const Vector3&amp; min2 = b2.getMinimum();
-			const Vector3&amp; max1 = b1.getMaximum();
-			const Vector3&amp; max2 = b2.getMaximum();
-
-			dv.x = min1.x &gt; max2.x ? min1.x - max2.x : min2.x &gt; max1.x ? min2.x - max1.x : 0.0f;
-			dv.y = min1.y &gt; max2.y ? min1.y - max2.y : min2.y &gt; max1.y ? min2.y - max1.y : 0.0f;
-			dv.z = min1.z &gt; max2.z ? min1.z - max2.z : min2.z &gt; max1.z ? min2.z - max1.z : 0.0f;
-
-			return dv.length();
-		}
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;MathUtil.h&quot;
+
+
+using namespace Ogre;
+
+namespace rl
+{
+    const Ogre::Real MathUtil::EPSILON = 0.00001f;
+
+    Ogre::Vector3 MathUtil::sphericalToCartesian(Ogre::Real r,
+        Ogre::Radian azimuth, Ogre::Radian altitude)
+    {
+        Vector3 rval;
+        rval.x = r*Math::Sin(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        rval.y = r*Math::Cos(altitude + Radian(Math::HALF_PI));
+        rval.z = r*Math::Cos(azimuth)*Math::Sin(altitude + Radian(Math::HALF_PI));
+        return rval;
+    }
+
+    void MathUtil::cartesianToSpherical(Ogre::Vector3 cartesian, Ogre::Real&amp; r,
+        Ogre::Radian&amp; azimuth, Ogre::Radian&amp; altitude)
+    {
+        r = Math::Sqrt(Math::Sqr(cartesian.x)*Math::Sqr(cartesian.y)*Math::Sqr(cartesian.z));
+        azimuth = Math::ATan2(cartesian.x, cartesian.z);
+        altitude = Math::ACos(cartesian.y/r) - Radian(Math::HALF_PI);
+    }
+
+    Ogre::Real MathUtil::normaliseAngle(Ogre::Real angle)
+	{
+        Ogre::Real ang = angle;
+
+		while (ang &lt; 0) ang += 360;
+		while (ang &gt; 360) ang -= 360;
+
+		return ang;
+	}	
+
+	Real MathUtil::distance(const AxisAlignedBox&amp; b1, const AxisAlignedBox&amp; b2)
+	{
+		if (b1.intersects(b2))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+
+			const Vector3&amp; min1 = b1.getMinimum();
+			const Vector3&amp; min2 = b2.getMinimum();
+			const Vector3&amp; max1 = b1.getMaximum();
+			const Vector3&amp; max2 = b2.getMaximum();
+
+			dv.x = min1.x &gt; max2.x ? min1.x - max2.x : min2.x &gt; max1.x ? min2.x - max1.x : 0.0f;
+			dv.y = min1.y &gt; max2.y ? min1.y - max2.y : min2.y &gt; max1.y ? min2.y - max1.y : 0.0f;
+			dv.z = min1.z &gt; max2.z ? min1.z - max2.z : min2.z &gt; max1.z ? min2.z - max1.z : 0.0f;
+
+			return dv.length();
+		}
+	}
+    
+	Real MathUtil::distance(const Vector3&amp; v, const AxisAlignedBox&amp; b)
+    {
+        return MathUtil::distance(b, v);
+    }
+    
+	Real MathUtil::distance(const AxisAlignedBox&amp; b, const Vector3&amp; v)
+	{
+		if (b.contains(v))
+		{
+			return 0.0f;
+		}
+		else
+		{
+			Vector3 dv;
+            
+			const Vector3&amp; min1 = b.getMinimum();
+			const Vector3&amp; max1 = b.getMaximum();
+            
+			dv.x = min1.x &gt; v.x ? min1.x - v.x : v.x &gt; max1.x ? v.x - max1.x : 0.0f;
+			dv.y = min1.y &gt; v.y ? min1.y - v.y : v.y &gt; max1.y ? v.y - max1.y : 0.0f;
+			dv.z = min1.z &gt; v.z ? min1.z - v.z : v.z &gt; max1.z ? v.z - max1.z : 0.0f;
+            
+			return dv.length();
+		}
+	}
+}

Modified: rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -34,4 +34,5 @@
     {
         mStream-&gt;flush();
     }
-}
\ No newline at end of file
+}
+

Copied: rl/branches/newton20/engine/core/CMakeLists.txt (from rev 4644, rl/trunk/engine/core/CMakeLists.txt)

Modified: rl/branches/newton20/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/ConfigurationManager.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/include/ConfigurationManager.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -190,6 +190,13 @@
             Ogre::StringVector getModuleList() const;
 
             /**
+             * Remove modules from the module list (e.g. because they are broken)
+             *
+             * @param modules the modules to remove
+             */
+            void removeModules(const Ogre::StringVector&amp; modules);
+
+            /**
              * Returns the filename of the current keymap file used by
              * Rastullah
              *

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -184,6 +184,21 @@
         return mModuleList;
     }
 
+    void ConfigurationManager::removeModules(const Ogre::StringVector&amp; modules)
+    {
+        for (Ogre::StringVector::const_iterator it = modules.begin(), end = modules.end(); it != end; ++it)
+        {
+            for (Ogre::StringVector::iterator itDel = mModuleList.begin(), endDel = mModuleList.end(); itDel != endDel; ++itDel)
+            {
+                if (*itDel == *it)
+                {
+                    mModuleList.erase(itDel);
+                    break;
+                }
+            }
+        }
+    }
+
     void ConfigurationManager::loadConfig()
     {
         setRastullahCfgPath();

Modified: rl/branches/newton20/engine/core/src/ContentLoader.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ContentLoader.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/ContentLoader.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,33 +1,33 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot;
-
-#include &quot;ContentLoader.h&quot;
-
-namespace rl
-{
-    ContentLoader::ContentLoader(const Ogre::String&amp; resourceGroup)
-    {
-    }
-
-    ContentLoader::~ContentLoader()
-    {
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;ContentLoader.h&quot;
+
+namespace rl
+{
+    ContentLoader::ContentLoader(const Ogre::String&amp; resourceGroup)
+    {
+    }
+
+    ContentLoader::~ContentLoader()
+    {
+    }
+
     const Property ContentLoader::getProperty(const CeGuiString&amp; key) const
     {
         LOG_WARNING(Logger::CORE, key + &quot; is not a property of this ContentLoader&quot;);
@@ -38,9 +38,10 @@
     {
     }
 
-    PropertyKeys ContentLoader::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-}
\ No newline at end of file
+    PropertyKeys ContentLoader::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        return keys;
+    }
+}
+

Modified: rl/branches/newton20/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/CoreSubsystem.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/CoreSubsystem.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -329,6 +329,8 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
+        Ogre::StringVector brokenModules;
+
         for (size_t i = 0; i &lt; modulesList.size(); i++)
         {
             mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
@@ -337,8 +339,9 @@
 
             if (module == NULL)
             {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;'&quot;);
+                LOG_WARNING(&quot;CoreSubsystem&quot;,
+                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;', removed.&quot;);
+                brokenModules.push_back(modulesList[i]);
             }
             //else
             //{
@@ -349,6 +352,8 @@
             //    }
             //}
         }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
     }
 
     ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const

Modified: rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/core/src/PlayAnimationJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,114 +1,122 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;PlayAnimationJob.h&quot;
-#include &quot;MeshAnimation.h&quot;
-#include &quot;MeshObject.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mDuration(duration),
-          mReplaceAllAnims(replaceAllAnims),
-          mLoops(-1),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops,
-        bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
-          mActor(actor),
-          mAnimName(anim),
-          mLoops(loops),
-          mDuration(-1),
-          mReplaceAllAnims(replaceAllAnims),
-          mTimeToGo(0.0),
-          mAnimation(NULL),
-          mAnimationRunning(false),
-          mHoldOnEnd(false)
-    {
-    }
-
-    PlayAnimationJob::~PlayAnimationJob()
-    {
-    }
-
-    void PlayAnimationJob::setHoldOnEnd(bool hold)
-    {
-        mHoldOnEnd = hold;
-    }
-
-    bool PlayAnimationJob::execute(Ogre::Real time)
-    {
-        if (mActor &amp;&amp; !mAnimationRunning)
-        {
-            MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(mActor-&gt;getControlledObject());
-
-            if (mReplaceAllAnims)
-            {
-                mo-&gt;stopAllAnimationsExcept(mAnimName);
-            }                
-
-            if (mDuration &gt; 0)
-            {
-                mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
-                mTimeToGo = mDuration;
-                mAnimationRunning = true;
-            }
-            else
-            {
-                MeshAnimation* animation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
-                mTimeToGo = animation-&gt;getLength() * (float)mLoops;
-                mAnimationRunning = true;
-            }
-        }
-
-        mTimeToGo -= time;
-
-        if (mTimeToGo &lt;= 0.0f)
-        {
-            if (mAnimationRunning &amp;&amp; mAnimation) 
-            {
-                mAnimationRunning = false;
-                if (mHoldOnEnd) 
-                {
-                    mAnimation-&gt;pause();
-                }
-                else
-                {
-                    mAnimation-&gt;stop();
-                    delete mAnimation;
-                }
-                mAnimation = NULL;
-            }
-            return true;
-        }
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;PlayAnimationJob.h&quot;
+#include &quot;MeshAnimation.h&quot;
+#include &quot;MeshObject.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mDuration(duration),
+          mReplaceAllAnims(replaceAllAnims),
+          mLoops(-1),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops,
+        bool replaceAllAnims)
+        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+          mActor(actor),
+          mAnimName(anim),
+          mLoops(loops),
+          mDuration(-1),
+          mReplaceAllAnims(replaceAllAnims),
+          mTimeToGo(0.0),
+          mAnimation(NULL),
+          mAnimationRunning(false),
+          mHoldOnEnd(false)
+    {
+    }
+
+    PlayAnimationJob::~PlayAnimationJob()
+    {
+    }
+
+    void PlayAnimationJob::setHoldOnEnd(bool hold)
+    {
+        mHoldOnEnd = hold;
+    }
+
+    bool PlayAnimationJob::execute(Ogre::Real time)
+    {
+        if (mActor &amp;&amp; !mAnimationRunning)
+        {
+            MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(mActor-&gt;getControlledObject());
+
+            if (mReplaceAllAnims)
+            {
+                mo-&gt;stopAllAnimationsExcept(mAnimName);
+            }                
+            
+            if (mo-&gt;hasAnimation(mAnimName))
+            {
+                if (mDuration &gt; 0)
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation-&gt;getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
+            }
+            else 
+            {
+                mAnimation = NULL;
+                mTimeToGo = 0;
+            }
+        }
+
+        mTimeToGo -= time;
+
+        if (mTimeToGo &lt;= 0.0f)
+        {
+            if (mAnimationRunning &amp;&amp; mAnimation) 
+            {
+                mAnimationRunning = false;
+                if (mHoldOnEnd) 
+                {
+                    mAnimation-&gt;pause();
+                }
+                else
+                {
+                    mAnimation-&gt;stop();
+                    delete mAnimation;
+                }
+                mAnimation = NULL;
+            }
+            return true;
+        }
+
+        return false;
+    }
+}

Modified: rl/branches/newton20/engine/rules/include/ApplyDamageJob.h
===================================================================
--- rl/branches/newton20/engine/rules/include/ApplyDamageJob.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/ApplyDamageJob.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Job.h&quot;
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Job.h&quot;
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/branches/newton20/engine/rules/include/Combat.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combat.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Combat.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;set&gt;
-#include &lt;vector&gt;
-#include &lt;boost/tuple/tuple.hpp&gt;
-
-#include &quot;JobListener.h&quot;
-#include &quot;Kampfaktion.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set&lt;Combatant*&gt; CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet&amp; getAllPlayerOpponents() const;
-        const CombatantSet&amp; getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
-		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
-		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
-        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set&lt;int&gt; mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &lt;set&gt;
+#include &lt;vector&gt;
+#include &lt;boost/tuple/tuple.hpp&gt;
+
+#include &quot;Creature.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;Kampfaktion.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesConstants.h&quot;
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set&lt;Combatant*&gt; CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet&amp; getAllPlayerOpponents() const;
+        const CombatantSet&amp; getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
+		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
+		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
+        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set&lt;int&gt; mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/Combatant.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combatant.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Combatant.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Creature.h&quot;
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/Creature.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Creature.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Creature.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,870 +1,877 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __CREATURE_H__
-#define __CREATURE_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Date.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;Eigenschaft.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;ZauberStateSet.h&quot;
-#include &quot;SonderfertigkeitenStateSet.h&quot;
-
-namespace rl
-{
-    class Container;
-    class Inventory;
-    class Item;
-    class Weapon;
-
-///////////////////////////////////////////////////////////////////////////////
-// Konstanten
-
-    /**
-    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
-    /**
-    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
-
-    /// Eine Doppel-1
-    static const int RESULT_AUTOERFOLG = 100;
-    /// Eine Dreifach-1
-    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
-    /// Eine Doppel-20
-    static const int RESULT_AUTOMISSERFOLG = -100;
-    /// Eine Dreifach-20
-    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
-    /**
-     *  Eine bestaetigte 1 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
-     *  eine einfache 1 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_GLUECKLICH = 100;
-    /**
-     *  Eine bestaetigte 20 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
-     *  eine einfache 20 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_PATZER = -100;
-    /// Eine normal gelungene Attacke oder Parade
-    static const int RESULT_ERFOLG = 1;
-    /// Eine normal misslungene Attacke oder Parade
-    static const int RESULT_MISSERFOLG = -1;
-
-
-    /// Basistalente
-    /// @todo Passenderen Ort suchen
-    static const CeGuiString TALENT_ART_BASIS = &quot;Basis&quot;;
-    /// Spezialtalente
-    static const CeGuiString TALENT_ART_SPEZIAL = &quot;Spezial&quot;;
-    /// Berufstalente
-    static const CeGuiString TALENT_ART_BERUF = &quot;Beruf&quot;;
-
-    /**
-     *  @defgroup CreatureRubyExports Creature
-     *  @ingroup RulesRubyExports
-     **/
-
-    /**
-    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
-    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
-    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
-    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
-    * Spielwelt noetig ist (z.B. Proben).
-    */
-    class _RlRulesExport Creature : public GameObject
-    {
-        public:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  List of all talents. Consists of the (german) name of the talent
-             *  (e.g. &quot;Athletik&quot;) as key and its value (TaW)
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; TalentMap;
-
-            static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_AI;
-            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
-			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
-            static const Ogre::String PROPERTY_CURRENT_LE;
-            static const Ogre::String PROPERTY_CURRENT_AE;
-            static const Ogre::String PROPERTY_CURRENT_AU;
-            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
-            static const Ogre::String PROPERTY_EFFECTS;
-            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
-            static const Ogre::String PROPERTY_TALENTE;
-            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
-            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
-            static const Ogre::String PROPERTY_VORTEILE;
-            static const Ogre::String PROPERTY_NACHTEILE;
-            static const Ogre::String PROPERTY_SF;
-            static const Ogre::String PROPERTY_WERTE;
-            static const Ogre::String PROPERTY_AP;
-            static const Ogre::String PROPERTY_INVENTORY;
-            static const Ogre::String PROPERTY_ANIMATIONS;
-            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
-
-            typedef Ogre::String Wert;
-
-            // some targets
-			static const std::string ALL_EIGENSCHAFTEN;
-			static const std::string ALL_TALENTE;
-
-            static const Wert WERT_MOD_AE;
-            static const Wert WERT_MOD_LE;
-            static const Wert WERT_MOD_AU;
-            static const Wert WERT_MOD_MR;
-            static const Wert WERT_MOD_AT;
-            static const Wert WERT_MOD_PA;
-            static const Wert WERT_MOD_FK;
-            static const Wert WERT_GS;
-            static const Wert WERT_SOZIALSTATUS;
-            static const Wert WERT_BE;
-            static const Wert WERT_RS;
-            static const Wert WERT_INI;
-            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
-            static const Wert WERT_REGENERATION;
-    			
-			Creature(unsigned int id);
-
-            /// Der Standarddestruktor.
-            virtual ~Creature();
-
-///////////////////////////////////////////////////////////////////////////////
-// Enums
-            /// Alignment of a Creature towards the player. This determines
-            /// whether a combat is entered.
-            enum Alignment
-            {
-                ALIGNMENT_ALLY    = 1, ///&lt; Creature fights with the player.
-                ALIGNMENT_NEUTRAL = 2, ///&lt; Creature doesn't fight for either side.
-                ALIGNMENT_ENEMY   = 4  ///&lt; Creature fights against the player.
-            };
-
-            /// Determines the damage type
-            enum DamageTag
-            {
-                DAMAGETAG_NORMAL = 1,
-                DAMAGETAG_PIERCING, ///&lt; Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 &lt; SP
-                DAMAGETAG_FIRE
-            };
-            /// The differente states a @ref abbdes &quot;SF&quot; can be in.
-             enum SfStatus
-            {
-                SFSTATUS_IN_TRAINING = 1,
-                SFSTATUS_OK,
-                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Werte
-
-            /**
-             *  Modifies the current @ref abbdel &quot;LE&quot; of the creature.
-             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
-             *  value).
-             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
-             **/
-            virtual void modifyLe(int mod, bool ignoreMax = false);
-            /**
-             *  Returns the current @ref abbdel &quot;LE&quot; of the creature.
-             **/
-            virtual int getLe() const;
-            /**
-             *  Returns the maximum @ref abbdel &quot;LE&quot; the creature can have.
-             **/
-            virtual int getLeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea &quot;AE&quot; der Kreatur.
-             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAe(int mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea &quot;AE&quot; der Kreatur zurueck.
-             **/
-            virtual int getAe() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea &quot;AU&quot; der Kreatur.
-             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAu(float mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea &quot;AU&quot; der Kreatur zurueck.
-             **/
-            virtual float getAu() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAuMax() const;
-
-            /**
-             *  Berechnet den @ref abbdea &quot;AT&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getAttackeBasis() const;
-            /**
-             *  Berechnet den @ref abbdep &quot;PA&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getParadeBasis() const;
-            /**
-             *  Berechnet den @ref abbdef &quot;FK&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getFernkampfBasis() const;
-            /**
-             *  Berechnet den @ref abbdei &quot;INI&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getInitiativeBasis() const;
-
-            /**
-             *  Setzt den Basiswert \a wertId auf \a value.
-             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
-             *  @param value Der neue wert des Basiswerts.
-             *  @see Wert
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void setWert(Wert wertId, int value);
-            /**
-                   *  Liefert den Basiswert \a wertId zurueck.
-             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
-                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
-                   *   zurueckgegeben.
-             *  @return Der Wert des Basiswerts.
-             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
-             *    gefunden werden.
-             **/
-            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
-
-            /**
-             *  Gibt der Kreatur @ref abbddea &quot;AP&quot;.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyAp(int modifier);
-            /**
-             *  Liefert die Gesamtzahl der @ref abbdea &quot;AP&quot; zurueck.
-             **/
-            int getAp() const;
-            /**
-             *  Veraendert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
-             *  aufgerufen.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyUsedAp(int modifier);
-            /**
-             *  Liefert die verbrauchten @refabbdea &quot;AP&quot; zurueck.
-             **/
-            int getUsedAp() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Eigenschaften
-
-            /**
-             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @abbdef &quot;FF&quot;, etc.).
-             *  @return Der Wert der Eigenschaft.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
-            /**
-             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @ref abbdef &quot;FF&quot;, etc.).
-             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
-            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @ref abbdef &quot;FF&quot;, etc.).
-             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
-
-///////////////////////////////////////////////////////////////////////////////
-// Talente
-
-            /**
-                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
-             *  Das neue Talent wird mit @ref abbdet &quot;TaW&quot; 0 initialisiert.
-             *  @param talentName Bezeichnet das Talent.
-                   *  @param value Startwert des Talents.
-             *  @throws InvalidArgumentException Das Talent konnte nicht
-             *    gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            void addTalent(const CeGuiString talentName, int value = 0);
-            /**
-                   *  Liefert den Wert des Talents \a talentName zurueck.
-             *  @param talentName Bezeichnet das Talent.
-             *  @return @ref abbdet &quot;TaW&quot;
-                   *  @ingroup CreatureRubyExports
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-             */
-
-            /**
-                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
-              * @param talentName Bezeichnet das Talent
-              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
-            */
-            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
-
-            virtual int getTalent(const CeGuiString talentName) const;
-            /**
-                   *  Setzt den Wert des Talents \a talentName.
-             *  @param talentName Bezeichnet das zu veraendernde Talent.
-             *  @param value Der neue @ref abbdet TaW.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void setTalent(const CeGuiString talentName, int value);
-            /**
-                   *  Erhoeht das Talent \a talentName um \a mod.
-             *  @param talentName Bezeichnet das zu steigernde Talent.
-             *  @param mod Der Wert um den das Talent gesteigert werden soll.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void modifyTalent(const CeGuiString talentName, int mod);
-            /**
-             * Liefert eine Liste mit allen Talenten und @ref abbdet &quot;TaW&quot;s zurueck.
-             * Dies wird auch der komplette Talentspiegel genannt.
-             **/
-            virtual const Creature::TalentMap&amp; getAllTalents() const;
-            /**
-                   *  Markiert ein Talent mit einer @ref abbdes &quot;SE&quot;. Siehe 
-                   *  Spezielle Erfahrungen, MFF 47.
-             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void addSe(const CeGuiString talentName);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampftechniken
-
-            /**
-             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
-             *  @param kampftechnikName Bezeichnet die Kampftechnik.
-             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
-             *  (0,0).
-             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
-                   *  @ingroup CreatureRubyExports
-             **/
-            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value = std::make_pair(0, 0));
-            /**
-                   *  Liefert die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer 
-                   *  bestimmten Kampftechnik zurueck.
-             *  @param kampftechnikName Beszeichnet die Kampftechnik.
-             *  @return Ein std::pair&lt;AT, PA&gt;.
-             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
-             *   \c mKampftechniken gefunden werden.
-             **/
-            virtual std::pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
-            /**
-                   *  Setzt die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer bestimmten 
-                   *  Kampftechnik.
-             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
-             *  @param value Die neuen AT/PA Werte.
-             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
-             *    konnte nicht in \c mKampftechniken gefunden werden.
-             **/
-            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampfaktionen (Attacke, Parade, etc..)
-
-            void addKampfaktion(const CeGuiString&amp; kampfaktionName);
-            bool hasKampfaktion(const CeGuiString&amp; kampfaktionName) const;
-			const std::set&lt;CeGuiString&gt;&amp; getAllKampfaktionen() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Vorteile
-            /**
-             *  Fuegt einen Vorteil hinzu.
-             *  @param vorteilName Der Name des Vorteils.
-             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
-             *   Vorteils (z.B. Astrale Regeneration 3).
-             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
-             **/
-            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
-
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
-             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
-             **/
-            virtual bool hasVorteil(const CeGuiString vorteilName) const;
- 
-///////////////////////////////////////////////////////////////////////////////
-// Nachteile
-            /**
-             *  Fuegt einen Nachteil hinzu.
-             *  @param nachteilName Der Name des Nachteils.
-             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
-             *   die Stufe des Nachteils.
-             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
-             **/
-            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
-             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
-             **/
-            virtual bool hasNachteil(const CeGuiString nachteilName) const;
-            /**
-             *  Liefert das StateSet des Nachteils zurueck.
-             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
-             *  abzufragen.
-             *  @param nachteilName Der Name der Schlechten Eigenschaft.
-             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
-             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
-             *   nicht gefunden werden.
-             **/
-            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Sonderfertigkeiten
-
-            /**
-                    *  Fuegt der Kreatur eine @ref abbdes &quot;SF&quot; hinzu.
-             *  @param sfName Bezeichnet die SF.
-                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
-             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
-             *    werden.
-                    *  @see SfStatus
-             */
-            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-            /**
-                   *  Liefert den Wert der @ref abbdes &quot;SF&quot; zurueck.
-             *  @param sfName Bezeichnet die SF
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual int getSf(const CeGuiString sfName) const;
-            /**
-                   *  Setzt den Wert der @ref abbdes &quot;SF&quot;.
-             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
-             *   werden soll.
-             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
-             *   soll.
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual void setSf(const CeGuiString sfName, SfStatus value);
-
-            /**
-             *  Liefert einen Zeiger auf das StateSet der @ref abbdes &quot;SF&quot; zurueck.
-             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
-            *  @throws InvalidArgumentException \a sfName kann nicht in 
-            *   \c mSonderfertigkeiten gefunden werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Status
-            /**
-             * Gets the status of a creature.
-             **/
-			Effect::LifeState getLifeState() const;
-
-
-            bool isMagic() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Inventory
-
-
-            /**
-             *  Gibt das Inventar der Kreatur zurueck.
-             *  @return Liefert einen Zeiger auf Inventar der Kreatur
-             **/
-            Inventory* getInventory() const;
-
-        const Ogre::String&amp; getInventoryWindowType() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Aktionen
-            /**
-            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
-            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
-            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
-            *  die Angabe einer Spezialisierung.
-            *  @param talentName Bezeichnet das Talent
-            *  @param spezialisierungId Bezeichnet die Spezialisierung
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
-            *     gewuerfelt werden soll
-            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
-            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
-            *  @return uebrig gebliebene Talentpunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
-            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
-            */
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int,int)
-             *  This is the function that should be used in most cases.
-             **/
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int);
-             *  This is the function you should usually use, if there is no fitting
-             *  specialization for the task.
-             *  @ingroup CreatureRubyExports
-             **/
-            /**
-             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
-             **/
-		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
-                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
-                                                 CeGuiString eigenschaft3Name);
-            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
-
-			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-                                      int modifier);
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
-
-            /**
-            *  Durchfuehren einer Eigenschaftsprobe.
-            *  @param eigenschaftName Bezeichnet die Eigenschaft
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
-            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
-            *  @ingroup CreatureRubyExports
-            */
-			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-            /**
-            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Attacke ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Attacke.
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   mKampftechniken gefunden.
-            **/
-            int doAttacke(const CeGuiString kampftechnikName, int modifier);
-            /**
-            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Parade ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Parade.
-            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-            *  @retval RESULT_GLUECKLICH Eine gute Parade.
-            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   \c mKampftechniken gefunden.
-            **/
-            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
-
-            /**
-             *  Fuehrt einen Initiativewurf durch.
-             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
-             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
-             *    'Orientieren'.
-             **/
-            int doInitiativeWurf(bool getMaxInitiative = false);
-
-			int doTrefferpunkteWurf(Weapon* weapon) const;
-
-            /**
-             *  Fuegt der Kreatur \a tp @ref abbdet &quot;Trefferpunkte&quot; zu.
-             *  @param tp die Trefferpunkte
-                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
-                   *   etc. korrekt zu beruecksichtigen.
-             **/
-            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-            static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
-
-            /**
-             *  Zieht der Kreatur \a asp @ref abbdea &quot;Astralpunkte&quot; ab.
-             *  @param aup die Trefferpunkte
-             **/
-            void damageAe(int asp);
-
-            /**
-            *  Zieht der Kreatur \a aup @ref abbdea &quot;Ausdauerpunkte&quot; ab.
-            *  @param aup die Trefferpunkte
-             *  @param damageType Typ des Schadens, um Resistenzen
-             *   etc. korrekt zu beruecksichtigen.
-            **/
-            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
-            static const int AUDAMAGE_NORMAL = 0;
-            static const int AUDAMAGE_HEAT = 1;
-            static const int AUDAMAGE_COLD = 2;
-            static const int AUDAMAGE_CHOKE = 4;
-            static const int AUDAMAGE_DROWN = 8;
-
-            /**
-             *  Regeneriert die @reg appdel &quot;LE&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateLe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea &quot;AE&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateAe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea &quot;AU&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
-             *  Parameter time aufgerufen werden.
-             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
-             *   selten eingesetzt werden.
-             *  @param time Sollte nur benutzt werden, falls es nicht m&#239;&#191;&#189;lich ist
-             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
-             **/
-            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
-
-
-            virtual const Property getProperty(const CeGuiString&amp; key) const;
-            virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-            virtual PropertyKeys getAllPropertyKeys() const;
-
-            void setAlignment(Alignment);
-            Alignment getAlignment() const;
-
-
-
-            /**
-             * Gibt an, ob die Creature mit den H&#195;&#164;nden an den Gegenstand herankommt,
-             * ihn also ber&#195;&#188;hren kann, mit ihm interagieren etc
-            **/
-            virtual bool canReachItem(const Item* item) const;
-
-            /**
-             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
-             * den CreatureController
-            **/
-            typedef std::pair&lt;Ogre::String, Ogre::Real&gt; AnimationSpeedPair;
-            /**
-             * Gibt die Animation aus der AnimationsMap f&#195;&#188;r den CreatureController zur&#195;&#188;ck
-             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
-             * der Schl&#195;&#188;sse name und eine Geschwindigkeit von 1 zurueckgegeben
-            **/
-            AnimationSpeedPair getAnimation(const CeGuiString&amp; name) const;
-
-        protected:
-           /**
-             *  Berechnet den Basiswert von der @ref abbdea &quot;Astralenergie&quot;.
-             **/
-            virtual int getAeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdea &quot;Ausdauer&quot;.
-             **/
-            virtual int getAuBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdel &quot;Lebensenergie&quot;.
-             **/
-            virtual int getLeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdem &quot;Magieresistenz&quot;.
-             **/
-            virtual int getMrBasis() const;
-            /**
-             *  Liefert die derzeitge @ref abbdeb &quot;BE&quot; der Kreatur zurueck.
-             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
-             **/
-            virtual int getCurrentBe() const;
-
-            /// inherited from GameObject
-            virtual void doPlaceIntoScene();
-
-            /// inherited from GameObject
-            virtual void doRemoveFromScene();
-
-
-
-
-        private:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  Liste der Werte.
-             *  @see Wert
-             **/
-            typedef std::map&lt;const Wert, int&gt; WertMap;
-            /**
-                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
-                   *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 
-                   *  und einem Zeiger auf ihr StateSet.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; EigenschaftMap;
-            /**
-             *  Liste der Kampftechniken und ihrer @ref abbdea &quot;AT&quot;/@ref abbdep &quot;PA2 Werte.
-             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
-             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
-                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
-             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
-             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
-             *  Kampftalent entsprechen.
-             **/
-            typedef std::map&lt;const CeGuiString, std::pair&lt;int, int&gt; &gt; KampftechnikMap;
-            /**
-             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
-             *  den Vorteilen, verhalten sich aber wie Talente.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; VorteilMap;
-            /**
-             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
-             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; NachteilMap;
-            /**
-                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
-                   *  Sonderfertigkeit als Schluessel und ihrem Status.
-             */
-            typedef std::map&lt;const CeGuiString , SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
-            /**
-                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
-                    * an.
-            **/
-            typedef std::map&lt;const CeGuiString, CeGuiString&gt; AnimationsMap;
-            /**
-                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
-                    * CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner, der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird.
-            **/
-            typedef std::map&lt;const CeGuiString, Ogre::Real&gt; AnimationSpeedsMap;
-            struct Ap
-            {
-                int total;
-                int used;
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Membervariablen
-            /// Die aktuelle @ref abbdel &quot;Lebensenergie&quot; der Kreatur.
-            int mCurrentLe;
-            /// Die aktuelle @ref abbdea &quot;Astralenergie&quot; der Kreatur.
-            int mCurrentAe;
-            /// Die aktuelle @ref abbdea &quot;Ausdauer&quot; der Kreatur.
-            float mCurrentAu;
-            /// Die aktuelle Erschoepfung der Kreatur.
-            int mErschoepfung;
-            /// Zuletzt zugewiesene Bewegungsart
-            int mMovementType;
-
-            /// Zeigt auf die gerade aktive Waffe.
-            EigenschaftMap mEigenschaften;
-            TalentMap mTalente;
-            KampftechnikMap mKampftechniken;
-			std::set&lt;CeGuiString&gt; mKampfaktionen;
-            VorteilMap mVorteile;
-            NachteilMap mNachteile;
-            SonderfertigkeitMap mSonderfertigkeiten;
-            WertMap mWerte;
-            AnimationsMap mAnimations;
-            AnimationSpeedsMap mAnimationSpeeds;
-            Ap mAp;
-            /// Zeigt auf das Inventar der Kreatur.
-            Inventory* mInventory;
-            Ogre::String mInventoryWindowType;
-
-            Property mAiProperties;
-
-            Alignment mAlignment;
-
-            /// this variable is only used in regenerateAu
-            float mTimeSinceLastRegeneration;
-            /// this variable is only used in regenerateAu (must be initialized with 3W6)
-            int mLastCalculatedAuToRegenerate;
-
-            /**
-             *  Sets a the status \a statusVariable. It uses a reference counting
-             *  System to do this, so if for example severeal effects put the creature
-             *  to sleep, and one effect ends the creature doesn't awake until all
-             *  the other effects end too. 
-             *  @param statusVariable is a reference to the status to be set, such as
-             *   \c mBlind.
-             *  @param value If true, the reference is increased, if false it is decreased.
-             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
-             *   than it was with \c true (i.e. the status is removed more often than
-             *   it was applied), \c setStatus throws an exception with \a errorMessage as
-             *   text.
-             *  @throw InvalidArgumentException see \a errorMessage.
-             **/
-            void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
-    };
-}
-#endif //__CREATURE_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __CREATURE_H__
+#define __CREATURE_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Date.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;Eigenschaft.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;ZauberStateSet.h&quot;
+#include &quot;SonderfertigkeitenStateSet.h&quot;
+
+namespace rl
+{
+    class Container;
+    class Inventory;
+    class Item;
+    class Weapon;
+
+///////////////////////////////////////////////////////////////////////////////
+// Konstanten
+
+    /**
+    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
+    /**
+    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
+
+    /// Eine Doppel-1
+    static const int RESULT_AUTOERFOLG = 100;
+    /// Eine Dreifach-1
+    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
+    /// Eine Doppel-20
+    static const int RESULT_AUTOMISSERFOLG = -100;
+    /// Eine Dreifach-20
+    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
+    /**
+     *  Eine bestaetigte 1 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
+     *  eine einfache 1 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_GLUECKLICH = 100;
+    /**
+     *  Eine bestaetigte 20 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
+     *  eine einfache 20 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_PATZER = -100;
+    /// Eine normal gelungene Attacke oder Parade
+    static const int RESULT_ERFOLG = 1;
+    /// Eine normal misslungene Attacke oder Parade
+    static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
+
+    /// Basistalente
+    /// @todo Passenderen Ort suchen
+    static const CeGuiString TALENT_ART_BASIS = &quot;Basis&quot;;
+    /// Spezialtalente
+    static const CeGuiString TALENT_ART_SPEZIAL = &quot;Spezial&quot;;
+    /// Berufstalente
+    static const CeGuiString TALENT_ART_BERUF = &quot;Beruf&quot;;
+
+    /**
+     *  @defgroup CreatureRubyExports Creature
+     *  @ingroup RulesRubyExports
+     **/
+
+    /**
+    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
+    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
+    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
+    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
+    * Spielwelt noetig ist (z.B. Proben).
+    */
+    class _RlRulesExport Creature : public GameObject
+    {
+        public:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  List of all talents. Consists of the (german) name of the talent
+             *  (e.g. &quot;Athletik&quot;) as key and its value (TaW)
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; TalentMap;
+
+            static const Ogre::String CLASS_NAME;
+            static const Ogre::String PROPERTY_AI;
+            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
+			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+            static const Ogre::String PROPERTY_CURRENT_LE;
+            static const Ogre::String PROPERTY_CURRENT_AE;
+            static const Ogre::String PROPERTY_CURRENT_AU;
+            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
+            static const Ogre::String PROPERTY_EFFECTS;
+            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
+            static const Ogre::String PROPERTY_TALENTE;
+            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
+            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
+            static const Ogre::String PROPERTY_VORTEILE;
+            static const Ogre::String PROPERTY_NACHTEILE;
+            static const Ogre::String PROPERTY_SF;
+            static const Ogre::String PROPERTY_WERTE;
+            static const Ogre::String PROPERTY_AP;
+            static const Ogre::String PROPERTY_INVENTORY;
+            static const Ogre::String PROPERTY_ANIMATIONS;
+            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
+
+            typedef Ogre::String Wert;
+
+            // some targets
+			static const std::string ALL_EIGENSCHAFTEN;
+			static const std::string ALL_TALENTE;
+
+            static const Wert WERT_MOD_AE;
+            static const Wert WERT_MOD_LE;
+            static const Wert WERT_MOD_AU;
+            static const Wert WERT_MOD_MR;
+            static const Wert WERT_MOD_AT;
+            static const Wert WERT_MOD_PA;
+            static const Wert WERT_MOD_FK;
+            static const Wert WERT_GS;
+            static const Wert WERT_SOZIALSTATUS;
+            static const Wert WERT_BE;
+            static const Wert WERT_RS;
+            static const Wert WERT_INI;
+            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
+            static const Wert WERT_REGENERATION;
+    			
+			Creature(unsigned int id);
+
+            /// Der Standarddestruktor.
+            virtual ~Creature();
+
+///////////////////////////////////////////////////////////////////////////////
+// Enums
+            /// Alignment of a Creature towards the player. This determines
+            /// whether a combat is entered.
+            enum Alignment
+            {
+                ALIGNMENT_ALLY    = 1, ///&lt; Creature fights with the player.
+                ALIGNMENT_NEUTRAL = 2, ///&lt; Creature doesn't fight for either side.
+                ALIGNMENT_ENEMY   = 4  ///&lt; Creature fights against the player.
+            };
+
+            /// Determines the damage type
+            enum DamageTag
+            {
+                DAMAGETAG_NORMAL = 1,
+                DAMAGETAG_PIERCING, ///&lt; Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 &lt; SP
+                DAMAGETAG_FIRE
+            };
+            /// The differente states a @ref abbdes &quot;SF&quot; can be in.
+             enum SfStatus
+            {
+                SFSTATUS_IN_TRAINING = 1,
+                SFSTATUS_OK,
+                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Werte
+
+            /**
+             *  Modifies the current @ref abbdel &quot;LE&quot; of the creature.
+             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
+             *  value).
+             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
+             **/
+            virtual void modifyLe(int mod, bool ignoreMax = false);
+            /**
+             *  Returns the current @ref abbdel &quot;LE&quot; of the creature.
+             **/
+            virtual int getLe() const;
+            /**
+             *  Returns the maximum @ref abbdel &quot;LE&quot; the creature can have.
+             **/
+            virtual int getLeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea &quot;AE&quot; der Kreatur.
+             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAe(int mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea &quot;AE&quot; der Kreatur zurueck.
+             **/
+            virtual int getAe() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea &quot;AU&quot; der Kreatur.
+             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAu(float mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea &quot;AU&quot; der Kreatur zurueck.
+             **/
+            virtual float getAu() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAuMax() const;
+
+            /**
+             *  Berechnet den @ref abbdea &quot;AT&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getAttackeBasis() const;
+            /**
+             *  Berechnet den @ref abbdep &quot;PA&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getParadeBasis() const;
+            /**
+             *  Berechnet den @ref abbdef &quot;FK&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getFernkampfBasis() const;
+            /**
+             *  Berechnet den @ref abbdei &quot;INI&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getInitiativeBasis() const;
+
+            /**
+             *  Setzt den Basiswert \a wertId auf \a value.
+             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
+             *  @param value Der neue wert des Basiswerts.
+             *  @see Wert
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void setWert(Wert wertId, int value);
+            /**
+                   *  Liefert den Basiswert \a wertId zurueck.
+             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
+                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
+                   *   zurueckgegeben.
+             *  @return Der Wert des Basiswerts.
+             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
+             *    gefunden werden.
+             **/
+            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
+
+            /**
+             *  Gibt der Kreatur @ref abbddea &quot;AP&quot;.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyAp(int modifier);
+            /**
+             *  Liefert die Gesamtzahl der @ref abbdea &quot;AP&quot; zurueck.
+             **/
+            int getAp() const;
+            /**
+             *  Veraendert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
+             *  aufgerufen.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyUsedAp(int modifier);
+            /**
+             *  Liefert die verbrauchten @refabbdea &quot;AP&quot; zurueck.
+             **/
+            int getUsedAp() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Eigenschaften
+
+            /**
+             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @abbdef &quot;FF&quot;, etc.).
+             *  @return Der Wert der Eigenschaft.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
+            /**
+             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @ref abbdef &quot;FF&quot;, etc.).
+             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
+            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @ref abbdef &quot;FF&quot;, etc.).
+             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
+
+///////////////////////////////////////////////////////////////////////////////
+// Talente
+
+            /**
+                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
+             *  Das neue Talent wird mit @ref abbdet &quot;TaW&quot; 0 initialisiert.
+             *  @param talentName Bezeichnet das Talent.
+                   *  @param value Startwert des Talents.
+             *  @throws InvalidArgumentException Das Talent konnte nicht
+             *    gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            void addTalent(const CeGuiString talentName, int value = 0);
+            /**
+                   *  Liefert den Wert des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent.
+             *  @return @ref abbdet &quot;TaW&quot;
+                   *  @ingroup CreatureRubyExports
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+             */
+
+            /**
+                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
+              * @param talentName Bezeichnet das Talent
+              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
+            */
+            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
+
+            virtual int getTalent(const CeGuiString talentName) const;
+            /**
+                   *  Setzt den Wert des Talents \a talentName.
+             *  @param talentName Bezeichnet das zu veraendernde Talent.
+             *  @param value Der neue @ref abbdet TaW.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void setTalent(const CeGuiString talentName, int value);
+            /**
+                   *  Erhoeht das Talent \a talentName um \a mod.
+             *  @param talentName Bezeichnet das zu steigernde Talent.
+             *  @param mod Der Wert um den das Talent gesteigert werden soll.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void modifyTalent(const CeGuiString talentName, int mod);
+            /**
+             * Liefert eine Liste mit allen Talenten und @ref abbdet &quot;TaW&quot;s zurueck.
+             * Dies wird auch der komplette Talentspiegel genannt.
+             **/
+            virtual const Creature::TalentMap&amp; getAllTalents() const;
+            /**
+                   *  Markiert ein Talent mit einer @ref abbdes &quot;SE&quot;. Siehe 
+                   *  Spezielle Erfahrungen, MFF 47.
+             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void addSe(const CeGuiString talentName);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampftechniken
+
+            /**
+             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
+             *  @param kampftechnikName Bezeichnet die Kampftechnik.
+             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
+             *  (0,0).
+             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
+                   *  @ingroup CreatureRubyExports
+             **/
+            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value = std::make_pair(0, 0));
+            /**
+                   *  Liefert die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer 
+                   *  bestimmten Kampftechnik zurueck.
+             *  @param kampftechnikName Beszeichnet die Kampftechnik.
+             *  @return Ein std::pair&lt;AT, PA&gt;.
+             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
+             *   \c mKampftechniken gefunden werden.
+             **/
+            virtual std::pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
+            /**
+                   *  Setzt die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer bestimmten 
+                   *  Kampftechnik.
+             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
+             *  @param value Die neuen AT/PA Werte.
+             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
+             *    konnte nicht in \c mKampftechniken gefunden werden.
+             **/
+            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampfaktionen (Attacke, Parade, etc..)
+
+            void addKampfaktion(const CeGuiString&amp; kampfaktionName);
+            bool hasKampfaktion(const CeGuiString&amp; kampfaktionName) const;
+			const std::set&lt;CeGuiString&gt;&amp; getAllKampfaktionen() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Vorteile
+            /**
+             *  Fuegt einen Vorteil hinzu.
+             *  @param vorteilName Der Name des Vorteils.
+             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
+             *   Vorteils (z.B. Astrale Regeneration 3).
+             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
+             **/
+            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
+
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
+             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
+             **/
+            virtual bool hasVorteil(const CeGuiString vorteilName) const;
+ 
+///////////////////////////////////////////////////////////////////////////////
+// Nachteile
+            /**
+             *  Fuegt einen Nachteil hinzu.
+             *  @param nachteilName Der Name des Nachteils.
+             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
+             *   die Stufe des Nachteils.
+             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
+             **/
+            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
+             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
+             **/
+            virtual bool hasNachteil(const CeGuiString nachteilName) const;
+            /**
+             *  Liefert das StateSet des Nachteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
+             *  abzufragen.
+             *  @param nachteilName Der Name der Schlechten Eigenschaft.
+             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
+             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Sonderfertigkeiten
+
+            /**
+                    *  Fuegt der Kreatur eine @ref abbdes &quot;SF&quot; hinzu.
+             *  @param sfName Bezeichnet die SF.
+                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
+             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
+             *    werden.
+                    *  @see SfStatus
+             */
+            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+            /**
+                   *  Liefert den Wert der @ref abbdes &quot;SF&quot; zurueck.
+             *  @param sfName Bezeichnet die SF
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual int getSf(const CeGuiString sfName) const;
+            /**
+                   *  Setzt den Wert der @ref abbdes &quot;SF&quot;.
+             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
+             *   werden soll.
+             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
+             *   soll.
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual void setSf(const CeGuiString sfName, SfStatus value);
+
+            /**
+             *  Liefert einen Zeiger auf das StateSet der @ref abbdes &quot;SF&quot; zurueck.
+             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
+            *  @throws InvalidArgumentException \a sfName kann nicht in 
+            *   \c mSonderfertigkeiten gefunden werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Status
+            /**
+             * Gets the status of a creature.
+             **/
+			Effect::LifeState getLifeState() const;
+
+
+            bool isMagic() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Inventory
+
+
+            /**
+             *  Gibt das Inventar der Kreatur zurueck.
+             *  @return Liefert einen Zeiger auf Inventar der Kreatur
+             **/
+            Inventory* getInventory() const;
+
+        const Ogre::String&amp; getInventoryWindowType() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Aktionen
+            /**
+            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
+            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
+            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
+            *  die Angabe einer Spezialisierung.
+            *  @param talentName Bezeichnet das Talent
+            *  @param spezialisierungId Bezeichnet die Spezialisierung
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
+            *     gewuerfelt werden soll
+            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
+            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
+            *  @return uebrig gebliebene Talentpunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
+            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
+            */
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int,int)
+             *  This is the function that should be used in most cases.
+             **/
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int);
+             *  This is the function you should usually use, if there is no fitting
+             *  specialization for the task.
+             *  @ingroup CreatureRubyExports
+             **/
+            /**
+             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
+             **/
+		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
+                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
+                                                 CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
+
+			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+                                      int modifier);
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
+
+            /**
+            *  Durchfuehren einer Eigenschaftsprobe.
+            *  @param eigenschaftName Bezeichnet die Eigenschaft
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
+            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
+            *  @ingroup CreatureRubyExports
+            */
+			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+            /**
+            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Attacke ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Attacke.
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   mKampftechniken gefunden.
+            **/
+            int doAttacke(const CeGuiString kampftechnikName, int modifier);
+            /**
+            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Parade ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Parade.
+            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+            *  @retval RESULT_GLUECKLICH Eine gute Parade.
+            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   \c mKampftechniken gefunden.
+            **/
+            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
+
+            /**
+             *  Fuehrt einen Initiativewurf durch.
+             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
+             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
+             *    'Orientieren'.
+             **/
+            int doInitiativeWurf(bool getMaxInitiative = false);
+
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
+
+            /**
+             *  Fuegt der Kreatur \a tp @ref abbdet &quot;Trefferpunkte&quot; zu.
+             *  @param tp die Trefferpunkte
+                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
+                   *   etc. korrekt zu beruecksichtigen.
+             **/
+            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+            static const int LEDAMAGE_NORMAL = 0;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
+
+            /**
+             *  Zieht der Kreatur \a asp @ref abbdea &quot;Astralpunkte&quot; ab.
+             *  @param aup die Trefferpunkte
+             **/
+            void damageAe(int asp);
+
+            /**
+            *  Zieht der Kreatur \a aup @ref abbdea &quot;Ausdauerpunkte&quot; ab.
+            *  @param aup die Trefferpunkte
+             *  @param damageType Typ des Schadens, um Resistenzen
+             *   etc. korrekt zu beruecksichtigen.
+            **/
+            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
+            static const int AUDAMAGE_NORMAL = 0;
+            static const int AUDAMAGE_HEAT = 1;
+            static const int AUDAMAGE_COLD = 2;
+            static const int AUDAMAGE_CHOKE = 4;
+            static const int AUDAMAGE_DROWN = 8;
+
+            /**
+             *  Regeneriert die @reg appdel &quot;LE&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateLe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea &quot;AE&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateAe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea &quot;AU&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+             *  Parameter time aufgerufen werden.
+             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
+             *   selten eingesetzt werden.
+             *  @param time Sollte nur benutzt werden, falls es nicht m&#239;&#191;&#189;lich ist
+             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
+             **/
+            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
+
+
+            virtual const Property getProperty(const CeGuiString&amp; key) const;
+            virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+            virtual PropertyKeys getAllPropertyKeys() const;
+
+            void setAlignment(Alignment);
+            Alignment getAlignment() const;
+
+
+
+            /**
+             * Gibt an, ob die Creature mit den H&#195;&#164;nden an den Gegenstand herankommt,
+             * ihn also ber&#195;&#188;hren kann, mit ihm interagieren etc
+            **/
+            virtual bool canReachItem(const Item* item) const;
+
+            /**
+             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
+             * den CreatureController
+            **/
+            typedef std::pair&lt;Ogre::String, Ogre::Real&gt; AnimationSpeedPair;
+            /**
+             * Gibt die Animation aus der AnimationsMap f&#195;&#188;r den CreatureController zur&#195;&#188;ck
+             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
+             * der Schl&#195;&#188;sse name und eine Geschwindigkeit von 1 zurueckgegeben
+            **/
+            AnimationSpeedPair getAnimation(const CeGuiString&amp; name) const;
+
+        protected:
+           /**
+             *  Berechnet den Basiswert von der @ref abbdea &quot;Astralenergie&quot;.
+             **/
+            virtual int getAeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea &quot;Ausdauer&quot;.
+             **/
+            virtual int getAuBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdel &quot;Lebensenergie&quot;.
+             **/
+            virtual int getLeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdem &quot;Magieresistenz&quot;.
+             **/
+            virtual int getMrBasis() const;
+            /**
+             *  Liefert die derzeitge @ref abbdeb &quot;BE&quot; der Kreatur zurueck.
+             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
+             **/
+            virtual int getCurrentBe() const;
+
+            /// inherited from GameObject
+            virtual void doPlaceIntoScene();
+
+            /// inherited from GameObject
+            virtual void doRemoveFromScene();
+
+
+
+
+        private:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  Liste der Werte.
+             *  @see Wert
+             **/
+            typedef std::map&lt;const Wert, int&gt; WertMap;
+            /**
+                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
+                   *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 
+                   *  und einem Zeiger auf ihr StateSet.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; EigenschaftMap;
+            /**
+             *  Liste der Kampftechniken und ihrer @ref abbdea &quot;AT&quot;/@ref abbdep &quot;PA2 Werte.
+             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
+             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
+                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
+             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
+             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
+             *  Kampftalent entsprechen.
+             **/
+            typedef std::map&lt;const CeGuiString, std::pair&lt;int, int&gt; &gt; KampftechnikMap;
+            /**
+             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
+             *  den Vorteilen, verhalten sich aber wie Talente.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; VorteilMap;
+            /**
+             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
+             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; NachteilMap;
+            /**
+                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
+                   *  Sonderfertigkeit als Schluessel und ihrem Status.
+             */
+            typedef std::map&lt;const CeGuiString , SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
+            /**
+                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
+                    * an.
+            **/
+            typedef std::map&lt;const CeGuiString, CeGuiString&gt; AnimationsMap;
+            /**
+                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
+                    * CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner, der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird.
+            **/
+            typedef std::map&lt;const CeGuiString, Ogre::Real&gt; AnimationSpeedsMap;
+            struct Ap
+            {
+                int total;
+                int used;
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Membervariablen
+            /// Die aktuelle @ref abbdel &quot;Lebensenergie&quot; der Kreatur.
+            int mCurrentLe;
+            /// Die aktuelle @ref abbdea &quot;Astralenergie&quot; der Kreatur.
+            int mCurrentAe;
+            /// Die aktuelle @ref abbdea &quot;Ausdauer&quot; der Kreatur.
+            float mCurrentAu;
+            /// Die aktuelle Erschoepfung der Kreatur.
+            int mErschoepfung;
+            /// Zuletzt zugewiesene Bewegungsart
+            int mMovementType;
+
+            /// Zeigt auf die gerade aktive Waffe.
+            EigenschaftMap mEigenschaften;
+            TalentMap mTalente;
+            KampftechnikMap mKampftechniken;
+			std::set&lt;CeGuiString&gt; mKampfaktionen;
+            VorteilMap mVorteile;
+            NachteilMap mNachteile;
+            SonderfertigkeitMap mSonderfertigkeiten;
+            WertMap mWerte;
+            AnimationsMap mAnimations;
+            AnimationSpeedsMap mAnimationSpeeds;
+            Ap mAp;
+            /// Zeigt auf das Inventar der Kreatur.
+            Inventory* mInventory;
+            Ogre::String mInventoryWindowType;
+
+            Property mAiProperties;
+
+            Alignment mAlignment;
+
+            /// this variable is only used in regenerateAu
+            float mTimeSinceLastRegeneration;
+            /// this variable is only used in regenerateAu (must be initialized with 3W6)
+            int mLastCalculatedAuToRegenerate;
+
+            /**
+             *  Sets a the status \a statusVariable. It uses a reference counting
+             *  System to do this, so if for example severeal effects put the creature
+             *  to sleep, and one effect ends the creature doesn't awake until all
+             *  the other effects end too. 
+             *  @param statusVariable is a reference to the status to be set, such as
+             *   \c mBlind.
+             *  @param value If true, the reference is increased, if false it is decreased.
+             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
+             *   than it was with \c true (i.e. the status is removed more often than
+             *   it was applied), \c setStatus throws an exception with \a errorMessage as
+             *   text.
+             *  @throw InvalidArgumentException see \a errorMessage.
+             **/
+            void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
+    };
+}
+#endif //__CREATURE_H__

Modified: rl/branches/newton20/engine/rules/include/RulesPrerequisites.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesPrerequisites.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/RulesPrerequisites.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -91,6 +91,7 @@
 
 	typedef std::vector&lt;Action*&gt; ActionVector;
 	
-	ActionVector::iterator findAction(ActionVector::iterator&amp; begin, ActionVector::iterator&amp; end, const CeGuiString actionName);
+	ActionVector::iterator findAction(ActionVector::iterator&amp; begin, ActionVector::iterator&amp; end, const CeGuiString&amp; actionName);
+	ActionVector::const_iterator findAction(ActionVector::const_iterator&amp; begin, ActionVector::const_iterator&amp; end, const CeGuiString&amp; actionName);
 }
 #endif

Modified: rl/branches/newton20/engine/rules/include/Slot.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Slot.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Slot.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,92 +1,224 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __SLOT_H__
-#define __SLOT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-namespace rl {
-
-class Creature;
-class Item;
-
-class _RlRulesExport Slot
-{
-public:
-    Slot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask);
-    virtual ~Slot();
-
-    // provides standard behaviour, sets
-    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
-    // subclasses MUST call this method when overriding
-    virtual bool setItem(Item* item);
-    virtual void update(); // this must only be called from creature::doPlaceIntoScene
-    Item* getItem() const;
-    bool isAllowed(const Item* item) const;
-    bool isEmpty() const {return mItem == NULL;}
-    bool canReady(const Item* item) const;
-	bool isReady() { return mItem != NULL &amp;&amp; canReady(mItem); }
-    CeGuiString getName() const {return mName;}
-
-protected:
-
-    Creature* mOwner;
-    Item* mItem;
-
-private:
-    CeGuiString mName;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemHeldMask;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemReadyMask;
-};
-
-class BoneSlot : public Slot
-{
-public:
-    BoneSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; bone);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mBone;
-};
-
-class SubmeshSlot : public Slot
-{
-public:
-    SubmeshSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-class MaterialSlot : public Slot
-{
-public:
-    MaterialSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-} // namespace rl
-
-#endif //__SLOT_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __SLOT_H__
+#define __SLOT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+namespace rl {
+    
+    class Creature;
+    class Item;
+    
+    /**
+     * A class to represent a place where an Item can be attached to a creature
+     *
+     */
+    class _RlRulesExport Slot
+    {
+    public:
+        
+        /**
+         * Creates a slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         */
+        Slot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask);
+        virtual ~Slot();
+        
+        /**
+         * Puts an item into the slot, may depend on the actual slot type
+         *
+         * Note: this method provides standard behaviour, sets item-state etc
+         * subclasses MUST call this method when overriding
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * Updates the slot to match the owner's state
+         *
+         * Note: this must only be called from Creature::doPlaceIntoScene
+         */
+        virtual void update();
+        
+        /**
+         * Gets the item in the slot
+         *
+         * @returns the item, NULL if the slot is empty
+         */
+        Item* getItem() const;
+        
+        /**
+         * Check if an item can be held in this slot
+         *
+         * @param item an item
+         * @returns true if the item can be put into this slot, false otherwise
+         */
+        bool isAllowed(const Item* item) const;
+        
+        /** 
+         * Check if the slot is empty
+         *
+         * @returns true if the slot is empty, false otherwise
+         */
+        bool isEmpty() const {return mItem == NULL;}
+        
+        /**
+         * Check if an item is readied in this slot (e.g. trousers in the legs slot) or not (e.g. trousers in the left hand slot)
+         *
+         * @param item an item
+         * @returns true if the item is readied in this slot, false otherwise
+         */
+        bool canReady(const Item* item) const;
+        
+        /**
+         * Check if the slot holds a ready item
+         *
+         */
+        bool isReady() { return mItem != NULL &amp;&amp; canReady(mItem); }
+        
+        /**
+         * Get the slot's name
+         *
+         * @returns the name
+         */
+        CeGuiString getName() const {return mName;}
+        
+    protected:
+        
+        Creature* mOwner;
+        Item* mItem;
+        
+    private:
+        CeGuiString mName;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemHeldMask;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemReadyMask;
+    };
+    
+    /**
+     * A slot implemented by a model bone, if objects are put into the slot, their models are attached at the bone
+     */
+    class BoneSlot : public Slot
+    {
+    public:
+        
+        /**
+         * Creates a bone slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param bone the bone name
+         */
+        BoneSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; bone);
+        
+        /**
+         * Puts an item into the slot by attaching its mesh to the bone of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mBone;
+    };
+    
+    /**
+     * A slot implemented by a submesh &quot;baked&quot; into the owner mesh. If an item is put into that slot it creates or 
+     * replaces a specified submesh, this is used for armor to be able to animate the armor meshes on an easy way
+     *
+     * Note: the item meshes must have the same skeleton as the owner mesh
+     */
+    class SubmeshSlot : public Slot
+    {
+    public:
+
+        /**
+         * Creates a submesh slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        SubmeshSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
+
+        /**
+         * Puts an item into the slot by creating or replacing a submesh in the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+    /**
+     * A slot implemented by changing a material on a specified submesh of the owner mesh. This is used for clothes.
+     */
+    class MaterialSlot : public Slot
+    {
+    public:
+        /**
+         * Creates a material slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        MaterialSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
+
+        /**
+         * Puts an item into the slot by replacing the material in one submesh of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+} // namespace rl
+
+#endif //__SLOT_H__

Modified: rl/branches/newton20/engine/rules/include/Weapon.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Weapon.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/include/Weapon.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (unsigned int id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString&amp; getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/ApplyDamageJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,41 +1,42 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot;
-#include &quot;ApplyDamageJob.h&quot;
-
-#include &quot;Creature.h&quot;
-
-namespace rl 
-{
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
-:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
-    mTarget(target), 
-    mTp(tp)
-{
-}
-
-ApplyDamageJob::~ApplyDamageJob()
-{
-}
-
-bool ApplyDamageJob::execute(Ogre::Real time)
-{
-    mTarget-&gt;damageLe(mTp);
-    return true;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot;
+#include &quot;ApplyDamageJob.h&quot;
+
+#include &quot;Creature.h&quot;
+
+namespace rl 
+{
+
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
+:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
+    mTarget(target), 
+    mDamage(damage),
+    mType(damageType)
+{
+}
+
+ApplyDamageJob::~ApplyDamageJob()
+{
+}
+
+bool ApplyDamageJob::execute(Ogre::Real time)
+{
+    mTarget-&gt;damageLe(mDamage, mType);
+    return true;
+}
+
+} // namespace rl

Modified: rl/branches/newton20/engine/rules/src/Combat.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combat.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Combat.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft nach &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft nach &quot;
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant-&gt;doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft zu &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft zu &quot;
 							    + entry.target-&gt;getName(), GET_COMBAT);
 						    combatant-&gt;doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor-&gt;getName() + &quot; attackiert &quot; + target-&gt;getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor-&gt;rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult &gt;= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent(&quot;Erfolg, aber pariert.&quot;, GET_COMBAT);
-                        if (target-&gt;getActiveWeapon()-&gt;isNatural())
+                        if (target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; !actor-&gt;getActiveWeapon()-&gt;isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; actor-&gt;getActiveWeapon()-&gt;isNatural())
+                        {
+                            doDamage(jobSetAnims, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target-&gt;getActiveWeapon()-&gt;isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target-&gt;doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetAnims, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor-&gt;rollTrefferpunkte();
-            jobSetAnims-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp));
-
-			CeGuiString msg = actor-&gt;getName() + &quot; trifft f&#252;r &quot;
+			int tp = actor-&gt;rollTrefferpunkte(damageStrength);
+            jobSet-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor-&gt;getName() + &quot; trifft fuer &quot;
             + CeGuiString(StringConverter::toString(tp))
             + &quot; Trefferpunkte&quot;;
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature-&gt;getName() + &quot; ist jetzt &quot;;
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += &quot;kampfunf&#228;hig.&quot;;
+						msg += &quot;kampfunf&#226;&#128;&#176;hig.&quot;;
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/branches/newton20/engine/rules/src/Combatant.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combatant.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Combatant.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -85,9 +85,9 @@
 		return getCreature()-&gt;doParade(weapon-&gt;getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/branches/newton20/engine/rules/src/Creature.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Creature.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Creature.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -1,1304 +1,1323 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Creature.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;Eigenschaft.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;EffectManager.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Kampftechnik.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;StateSet.h&quot;
-#include &quot;Slot.h&quot;
-#include &quot;Talent.h&quot;
-#include &quot;Weapon.h&quot;
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
-
-    const Ogre::String Creature::PROPERTY_AI = &quot;ai&quot;;
-    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = &quot;behaviours&quot;;
-    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_LE = &quot;current_le&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_AE = &quot;current_ae&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_AU = &quot;current_au&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = &quot;current_fatigue&quot;;
-    const Ogre::String Creature::PROPERTY_EFFECTS = &quot;effects&quot;;
-    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = &quot;eigenschaften&quot;;
-    const Ogre::String Creature::PROPERTY_TALENTE = &quot;talente&quot;;
-    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = &quot;kampftechniken&quot;;
-    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = &quot;kampfaktionen&quot;;
-    const Ogre::String Creature::PROPERTY_VORTEILE = &quot;vorteile&quot;;
-    const Ogre::String Creature::PROPERTY_NACHTEILE = &quot;nachteile&quot;;
-    const Ogre::String Creature::PROPERTY_SF = &quot;sonderfertigkeiten&quot;;
-    const Ogre::String Creature::PROPERTY_WERTE = &quot;werte&quot;;
-    const Ogre::String Creature::PROPERTY_AP = &quot;ap&quot;;
-    const Ogre::String Creature::PROPERTY_INVENTORY = &quot;inventory&quot;;
-    const Ogre::String Creature::PROPERTY_ANIMATIONS = &quot;animations&quot;;
-    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = &quot;animationspeeds&quot;;
-
-    // some targets
-	const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-	const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
-	const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
-    const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
-    const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
-    const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
-    const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
-    const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
-    const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
-    const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
-    const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
-    const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
-    const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
-    const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
-    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;;
-    const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
-
-
-
-    Creature::Creature(unsigned int id)
-        : GameObject(id),
-		mCurrentLe(0),
-        mCurrentAu(0),
-        mCurrentAe(0),
-		mInventory(NULL),
-		mEigenschaften(),
-		mWerte(),
-		mTalente(),
-        mKampftechniken(),
-		mKampfaktionen(),
-        mSonderfertigkeiten(),
-        mErschoepfung(0),
-        mMovementType(0),
-        mAlignment(ALIGNMENT_NEUTRAL),
-        mTimeSinceLastRegeneration(0),
-        mLastCalculatedAuToRegenerate(
-                  DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6())
-    {
-        mQueryFlags |= QUERYFLAG_CREATURE;
-
-		setWert(WERT_MOD_AE, 0);
-		setWert(WERT_MOD_LE, 0);
-		setWert(WERT_MOD_AU, 0);
-		setWert(WERT_MOD_MR, 0);
-		setWert(WERT_GS, 8);
-        setWert(WERT_RS, 0);
-        setWert(WERT_BE, 0);
-        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
-		mEigenschaften[E_MUT] = 0;
-		mEigenschaften[E_KLUGHEIT] = 0;
-		mEigenschaften[E_INTUITION] = 0;
-		mEigenschaften[E_CHARISMA] = 0;
-		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
-		mEigenschaften[E_GEWANDTHEIT] = 0;
-		mEigenschaften[E_KONSTITUTION] = 0;
-		mEigenschaften[E_KOERPERKRAFT] = 0;
-
-		mInventory = new Inventory(this);
-    }
-
-	Creature::~Creature()
-    {
-        delete mInventory;
-
-        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
-            delete it-&gt;second;
-        mSonderfertigkeiten.clear();
-        CreatureControllerManager::getSingleton().detachController(this);
-    }
-
-    int Creature::getAttackeBasis() const
-    {
-		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getParadeBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getFernkampfBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getInitiativeBasis() const
-    {
-      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getMrBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getLeBasis() const
-    {
-      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-    int Creature::getAuBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-	int Creature::getAeBasis() const
-	{
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-	int Creature::getWert(Wert wertId, bool getUnmodified) const
-	{
-		WertMap::const_iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + &quot;: Wert &quot; + wertId.c_str() + &quot; nicht gefunden.&quot;).c_str());
-            return 0;
-        }
-        int rval = it-&gt;second;
-        if (!getUnmodified)
-        {
-          rval += mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_SUM);
-          rval *= mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_MULT);
-        }
-		return rval;
-	}
-
-	int Creature::getCurrentBe() const
-	{
-		pair&lt;int,int&gt; be = mInventory-&gt;getOverallBe();
-        ///@todo Ruestungsgewoehnung?
-		return be.first+be.second;
-	}
-
-	void Creature::setWert(Wert wertId, int value)
-	{
-		WertMap::iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-			mWerte.insert(make_pair(wertId, value));
-        }
-		else
-		{
-			it-&gt;second = value;
-		}
-	}
-
-   void Creature::modifyLe(int mod, bool ignoreMax)
-    {
-        int oldLe = mCurrentLe;
-        mCurrentLe += mod;
-		if (!ignoreMax)
-		{
-			mCurrentLe = min(mCurrentLe, getLeMax());
-		}
-
-        if (mCurrentLe &lt;= -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &gt; -getEigenschaft(&quot;KO&quot;))
-        {
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;DeadEffect&quot;));
-        }
-        else if (mCurrentLe &gt; -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &lt;= -getEigenschaft(&quot;KO&quot;))
-        {
-            mEffectManager-&gt;removeEffect(&quot;DeadEffect&quot;);
-        }
-        else if (mCurrentLe &lt;= 0 &amp;&amp; oldLe &gt; 0)
-        {
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;UnconsciousEffect&quot;));
-        }
-        else if (mCurrentLe &gt; 0 &amp;&amp; oldLe &lt;= 0)
-        {
-            mEffectManager-&gt;removeEffect(&quot;UnconciousEffect&quot;);
-        }
-		else if (mCurrentLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
-            oldLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;IncapacitatedEffect&quot;));
-		}
-		else if (mCurrentLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
-            oldLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager-&gt;removeEffect(&quot;IncapacitatedEffect&quot;);
-		}
-
-        fireObjectStateChangeEvent();
-
-    }
-
-    int Creature::getLe() const
-    {
-        return mCurrentLe;
-    }
-
-    int Creature::getLeMax() const
-    {
-		return getLeBasis() + getWert(WERT_MOD_LE);
-    }
-
-    void Creature::modifyAe(int mod, bool ignoreMax)
-    {
-        mCurrentAe += mod;
-		if (!ignoreMax)
-			mCurrentAe = min(mCurrentAe, getAeMax());
-		fireObjectStateChangeEvent();
-    }
-
-    int Creature::getAe() const
-    {
-        return mCurrentAe;
-    }
-
-    int Creature::getAeMax() const
-    {
-		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
-    }
-
-    void Creature::modifyAu(float mod, bool ignoreMax)
-    {
-        mCurrentAu = max(mCurrentAu + mod, 0.0f);
-		if (!ignoreMax)
-			mCurrentAu = min(mCurrentAu, float(getAuMax()));
-        if (getAu() &lt;= 0)
-        {
-            ///@todo set incapacitated
-        }
-		fireObjectStateChangeEvent();
-    }
-
-    float Creature::getAu() const
-    {
-        return mCurrentAu;
-    }
-
-    int Creature::getAuMax() const
-    {
-		return getAuBasis() + getWert(WERT_MOD_AU);
-    }
-
-    void Creature::modifyAp(int modifier)
-    {
-        mAp.total += modifier;
-    }
-
-    int Creature::getAp() const
-    {
-        return mAp.total;
-    }
-
-    void Creature::modifyUsedAp(int modifier)
-    {
-        mAp.used += modifier;
-    }
-
-    int Creature::getUsedAp() const
-    {
-        return mAp.used;
-    }
-
-    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
-    {
-		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-		if (it == mEigenschaften.end())
-		{
-			Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
-		}
-		int result = it-&gt;second;
-        result += mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
-        return result;
-    }
-
-    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
-    {
-        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
-        if (it == mEigenschaften.end())
-        {
-            Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
-        }
-		it-&gt;second = value;
-        fireObjectStateChangeEvent();
-    }
-
-    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
-    {
-		mEigenschaften[eigenschaftName] += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
-    {
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-            return true;
-        /*
-        if( ausweich )
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt != ausweichTalente.end())
-            {
-                return true;
-            }
-        }
-        */
-		
-        return false;
-    }
-
-    int Creature::getTalent(const CeGuiString talentName) const
-    {
-        LOG_DEBUG(Logger::RULES, &quot;Using talent &quot; + talentName);
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt == ausweichTalente.end())
-            {
-                Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-            }
-            int rval = getTalent(ausweichIt-&gt;first) - ausweichIt-&gt;second;
-            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
-            {
-                int tempAusweichTaw = getTalent(ausweichIt-&gt;first)
-                    - ausweichIt-&gt;second;
-                if (tempAusweichTaw &gt; rval) rval = tempAusweichTaw;
-            }
-            return rval;
-        } //if (it == mTalente.end())
-		return it-&gt;second;
-    }
-
-	void Creature::addTalent(const CeGuiString talentName, int value)
-	{
-		TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-        {
-			Throw(IllegalArgumentException, &quot;Talent schon in mTalente enthalten.&quot;);
-        }
-	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
-		mTalente[talentName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::modifyTalent(const CeGuiString talentName, int mod)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		it-&gt;second += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-	const Creature::TalentMap&amp; Creature::getAllTalents() const
-	{
-		return mTalente;
-	}
-
-    void Creature::setTalent(const CeGuiString talentName, int value)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		it-&gt;second = value;
-		fireObjectStateChangeEvent();
-    }
-
-	void Creature::addSe(const CeGuiString talentName)
-	{
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		//it-&gt;second-&gt;setSe( true );
-        /// @todo Implement SEs
-	}
-
-	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int,int&gt;&amp; value)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it != mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException,
-				&quot;Kampftechnik schon in mKampftechniken enthalten.&quot;);
-		}
-		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
-		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
-		mKampftechniken[kampftechnikName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    pair&lt;int, int&gt; Creature::getKampftechnik(const CeGuiString kampftechnikName) const
-    {
-        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
-        }
-        return (*it).second;
-    }
-
-    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int, int&gt;&amp; value)
-    {
-        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
-        }
-        (*it).second = value;
-		fireObjectStateChangeEvent();
-    }
-
-    void Creature::addKampfaktion(const CeGuiString&amp; kampfaktionName)
-	{
-		mKampfaktionen.insert(kampfaktionName);
-	}
-
-    bool Creature::hasKampfaktion(const CeGuiString&amp; kampfaktionName) const
-	{
-		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
-	}
-
-	const std::set&lt;CeGuiString&gt;&amp; Creature::getAllKampfaktionen() const
-	{
-		return mKampfaktionen;
-	}
-
-    void Creature::addVorteil(const CeGuiString vorteilName, int value)
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Vorteil schon in mVorteile enthalten&quot;);
-        }
-        mVorteile[vorteilName] = value;
-    }
-
-    bool Creature::hasVorteil(const CeGuiString vorteilName) const
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    void Creature::addNachteil(const CeGuiString nachteilName, int value)
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Nachteil schon in mNachteile enthalten&quot;);
-        }
-        mNachteile[nachteilName] = value;
-    }
-
-    bool Creature::hasNachteil(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it == mNachteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Nachteil nicht gefunden.&quot;);
-        }
-		else return it-&gt;second + mEffectManager-&gt;getMod(nachteilName, Effect::MODTYPE_SUM);
-    }
-
-    int Creature::getSf(const CeGuiString sfName) const
-    {
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		return it-&gt;second-&gt;getValue();
-    }
-
-	void Creature::addSf(const CeGuiString sfName, SfStatus value)
-	{
-		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-		if (it != mSonderfertigkeiten.end())
-		{
-			Throw(IllegalArgumentException, &quot;Sonderfertigkeit schon in mSonderfertigkeiten enthalten.&quot;);
-		}
-		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
-        /// @todo
-		//DsaManager::getSingleton().getSf(sfName);
-		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
-		mSonderfertigkeiten[sfName]-&gt;setOriginalValue( value );
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::setSf(const CeGuiString sfName, SfStatus value)
-    {
-        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		it-&gt;second-&gt;setOriginalValue( value );
-		fireObjectStateChangeEvent();
-    }
-
-	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
-	{
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		return it-&gt;second;
-	}
-
-    Effect::LifeState Creature::getLifeState() const
-    {
-      return mEffectManager-&gt;getLifeState();
-    }
-
-	bool Creature::isMagic() const
-	{
-		return getWert(WERT_MOD_AE) &gt; 0;
-	}
-
-    void Creature::setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage)
-    {
-        if (value == true)
-        {
-            statusVariable++;
-        }
-        else //value == false
-        {
-            if (statusVariable &gt; 0)
-            {
-                statusVariable--;
-            }
-            else
-            {
-                LOG_MESSAGE(Logger::RULES, errorMessage);
-            }
-        } //value == false
-    }
-
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-		if (((talent-&gt;getArt() == TALENT_ART_SPEZIAL) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_SPEZIAL)) ||
-			((talent-&gt;getArt() == TALENT_ART_BERUF) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_BERUF)))
-		{
-          /// @todo Find proper return value. Prompt an error message?
-			//Throw(OutOfRangeException, &quot;TaW zu niedrig&quot;);
-          return -1;
-		}
-        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
-
-        // Der Probenwurf
-        Tripel&lt;int&gt; probe(DsaManager::getSingleton().roll3D20());
-
-		// Glueckliche
-		if ( (probe.first == 1) &amp;&amp; (probe.second == 1) &amp;&amp; (probe.third == 1) )
-		{
-			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
-			modifyTalent(talentName, +1);
-			return RESULT_SPEKT_AUTOERFOLG;
-		}
-		if ( ((probe.first == 1) &amp;&amp; (probe.second == 1)) ||
-			 ((probe.first == 1) &amp;&amp; (probe.third == 1)) ||
-			 ((probe.second == 1) &amp;&amp; (probe.third == 1)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOERFOLG;
-		}
-		// Patzer
-		if ((probe.first == 20) &amp;&amp; (probe.second == 20) &amp;&amp; (probe.third == 20))
-		{
-			addSe(talentName);
-			return RESULT_SPEKT_AUTOMISSERFOLG;
-		}
-		if ( ((probe.first == 20) &amp;&amp; (probe.second == 20)) ||
-			 ((probe.first == 20) &amp;&amp; (probe.third == 20)) ||
-			 ((probe.second == 20) &amp;&amp; (probe.third == 20)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOMISSERFOLG;
-		}
-
-
-        // Vor dem Vergleich hat man den Talentwert &#195;&#188;brig.
-		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM));
-		int taW = getTalent(talentName);
-		int rval = taW - modifier - mEffectManager-&gt;getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
-            - mEffectManager-&gt;getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
-		// Bei negativen TaP*
-		int handicap = 0;
-		if (rval &lt; 0)
-		{
-			handicap = -rval;
-			rval = 0;
-		}
-
-        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
-        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
-        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
-
-        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
-        // wird die Differenz vom Talentwert abgezogen.
-        rval = diff1 &lt; 0 ? rval + diff1 : rval;
-        rval = diff2 &lt; 0 ? rval + diff2 : rval;
-        rval = diff3 &lt; 0 ? rval + diff3 : rval;
-
-		// TaP* niemals gr&#195;&#182;&#195;&#159;er als TaW (MFF14)
-		if (rval &gt; taW) rval = taW;
-        return rval;
-    }
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
-			eigenschaft2Name, eigenschaft3Name);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent-&gt;getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
-			et.first, et. second, et.third);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent-&gt;getEigenschaften());
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
-			et. second, et.third);
-	}
-
-    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
-    {
-        int rval;
-
-        int probe = DsaManager::getSingleton().rollD20();
-        if (probe == 1)
-        {
-            rval = RESULT_GLUECKLICH;
-        }
-        else if (probe == 20)
-        {
-            rval = RESULT_PATZER;
-        }
-        else
-        {
-			rval = getEigenschaft(eigenschaftName) -
-                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
-        }
-        return rval;
-    }
-
-
-	Inventory* Creature::getInventory() const
-	{
-		return mInventory;
-	}
-
-    const Ogre::String&amp; Creature::getInventoryWindowType() const
-    {
-        return mInventoryWindowType;
-    }
-
-	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
-		}
-		int rval;
-		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_PATZER;
-		}
-		else
-		{
-			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
-                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval &lt; 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
-		}
-		int rval;
-		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20)
-		{
-			rval = RESULT_PATZER; /// @todo Best&#195;&#164;tigen
-		}
-		else
-		{
-			/// @todo Gute Parade
-			rval = getParadeBasis() + (*it).second.second - (probe + modifier
-                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval &lt; 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doInitiativeWurf(bool getMaxInitiave)
-	{
-		int rval = getInitiativeBasis();
-		rval += mEffectManager-&gt;getMod(WERT_INI, Effect::MODTYPE_SUM);
-		rval -= mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM);
-		if (getMaxInitiave)
-        {
-            rval += 6;
-        }
-        else
-        {
-            rval += DsaManager::getSingleton().rollD6();
-        }
-		return rval;
-	}
-
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
-	{
-		// Roll dice
-		const Tripel&lt;int&gt;&amp; weaponTp = weapon-&gt;getTp();
-		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
-		rval += weaponTp.third;
-
-		// Apply TP/KK
-
-		int kk = getEigenschaft(E_KOERPERKRAFT);
-		std::pair&lt;int, int&gt; tpkk = weapon-&gt;getTpKk();
-		
-		int bonus = (kk - tpkk.first) / tpkk.second;
-		rval += bonus;
-
-		return rval;
-	}
-
-	/// @todo Implement correctly
-	void Creature::damageLe(int tp, int damageType)
-	{
-        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-        if (tp &lt; 0)
-        {
-            tp = 0;
-        }
-
-        ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType &amp; LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Fire damage not handled!&quot;); ///@todo implement
-        }
-        if ((damageType &amp; LEDAMAGE_WATER) == LEDAMAGE_WATER)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Water damage not handled!&quot;); ///@todo implement
-        }
-        if ((damageType &amp; LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Demonic damage not handled!&quot;); ///@todo implement
-        }
-
-        if ((damageType &amp; LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
-        {
-            damageAu(tp, AUDAMAGE_NORMAL);
-            tp = (int)floor(tp/2.);
-        }
-
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
-		modifyLe(sp);
-
-        if (sp &gt;= getEigenschaft(&quot;KO&quot;))
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;TODO: Add a wound.&quot;); ///@todo implement
-        }
-	}
-
-    void Creature::damageAe(int asp)
-    {
-        if (asp &lt; 0)
-        {
-         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           asp = 0;
-        }
-        modifyAe(-asp);
-    }
-
-    void Creature::damageAu(float aup, int damageType)
-    {
-        if (aup &lt; 0)
-        {
-         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           aup = 0;
-           ///@todo evtl. eine modifyErschoepfung()?
-           mErschoepfung += DsaManager::getSingleton().rollD6();
-           ///@todo set incapacitated
-        }
-        // bei &#195;&#156;beranstrengung, kostet alles doppelte Au!!!!!
-        if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
-            aup *= 2;
-        modifyAu(-aup);
-    }
-
-    void Creature::regenerateLe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedLe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedLe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
-            0, Effect::MODTAG_REGENERATION_LE))
-        {
-            regeneratedLe++;
-        }
-        //modifiziere die aktuellen LE
-        modifyLe(regeneratedLe);
-    }
-
-    void Creature::regenerateAe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedAe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedAe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;IN&quot;,
-            0, Effect::MODTAG_REGENERATION_AE))
-        {
-            regeneratedAe++;
-        }
-        //modifiziere die aktuellen AE
-        modifyAe(regeneratedAe);
-    }
-
-    void Creature::regenerateAu(int modifier, float factor, float time)
-    {
-        // das Ganze nur jede Spielrunde machen
-        mTimeSinceLastRegeneration += time;
-
-
-        if( getAu() == getAuMax() )
-        {
-            mTimeSinceLastRegeneration = 0;
-            return;
-        }
-
-
-        while( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE )
-        {
-            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
-
-
-            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
-            //Grundregeneration von 3W6
-            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6();
-            //Addiere eventuelle Modifikatoren hinzu
-            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
-            //Bei gelungener KO Probe addiere 1
-            if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
-                0, mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
-            {
-                modifyAu(6*factor);
-            }
-
-            if( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
-            {
-                //modifiziere die aktuellen AU
-                time -= Date::ONE_SPIELRUNDE;
-                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
-            }
-
-            if( getAu() == getAuMax() )
-            {
-                mTimeSinceLastRegeneration = 0;
-                return;
-            }
-        }
-
-        // Restbetrag regenerieren:
-        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
-        modifyAu(regeneratedAuPerTime*factor);
-    }
-
-    void Creature::setAlignment(Creature::Alignment alignment)
-    {
-        mAlignment = alignment;
-    }
-
-    Creature::Alignment Creature::getAlignment() const
-    {
-        return mAlignment;
-    }
-
-    void Creature::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            mAiProperties = value;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            mInventoryWindowType = value.toString().c_str();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            mCurrentLe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            mCurrentAe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            mCurrentAu = value.toReal();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            mErschoepfung = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            mEigenschaften.clear();
-            convertToMap(value.toMap(), mEigenschaften);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            mTalente.clear();
-            convertToMap(value.toMap(), mTalente);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            mKampftechniken.clear();
-            convertToMap(value.toMap(), mKampftechniken);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            mKampfaktionen.clear();
-            convertToSet(value.toArray(), mKampfaktionen);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            mVorteile.clear();
-            convertToMap(value.toMap(), mVorteile);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            mNachteile.clear();
-            convertToMap(value.toMap(), mNachteile);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            mWerte.clear();
-            convertToMap(value.toMap(), mWerte);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            IntPair ip = value.toIntPair();
-            mAp.total = ip.first;
-            mAp.used = ip.second;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            mInventory-&gt;setProperties(value.toMap());
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            mAnimations.clear();
-            convertToMap(value.toMap(), mAnimations);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            mAnimationSpeeds.clear();
-            convertToMap(value.toMap(), mAnimationSpeeds);
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Creature::getProperty(const CeGuiString&amp; key) const
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            return mAiProperties;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            return Property(mInventoryWindowType);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            return Property(mCurrentLe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            return Property(mCurrentAe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            return Property(mCurrentAu);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            return Property(mErschoepfung);
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            return mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mTalente);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
-            return Property(vec);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mVorteile);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mNachteile);
-            return Property(map);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mWerte);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            return Property(make_pair(mAp.total, mAp.used));
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-			return mInventory-&gt;getAllProperties()-&gt;toPropertyMap();
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimations);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
-            return Property(map);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Creature::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Creature::PROPERTY_AI);
-        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
-        keys.insert(Creature::PROPERTY_CURRENT_LE);
-        keys.insert(Creature::PROPERTY_CURRENT_AE);
-        keys.insert(Creature::PROPERTY_CURRENT_AU);
-        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
-        keys.insert(Creature::PROPERTY_TALENTE);
-        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
-        keys.insert(Creature::PROPERTY_VORTEILE);
-        keys.insert(Creature::PROPERTY_NACHTEILE);
-        //keys.insert(Creature::PROPERTY_SF);
-        keys.insert(Creature::PROPERTY_WERTE);
-        keys.insert(Creature::PROPERTY_AP);
-        keys.insert(Creature::PROPERTY_INVENTORY);
-        keys.insert(Creature::PROPERTY_ANIMATIONS);
-        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
-
-        return keys;
-    }
-
-    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString&amp; name) const
-    {
-        AnimationSpeedPair ret;
-        AnimationsMap::const_iterator itName = mAnimations.find(name);
-        if( itName != mAnimations.end() )
-            ret.first = itName-&gt;second.c_str();
-        else
-            ret.first = name.c_str();
-
-        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
-        if( itSpeed != mAnimationSpeeds.end() )
-            ret.second = itSpeed-&gt;second;
-        else
-            ret.second = 1;
-
-        return ret;
-    }
-
-    bool Creature::canReachItem(const Item* item) const
-    {
-        return (item-&gt;getPosition() - getPosition()).length() &lt;= 3.0f;
-    }
-
-    void Creature::doPlaceIntoScene()
-    {
-        GameObject::doPlaceIntoScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it-&gt;second-&gt;update();
-        }
-    }
-
-    void Creature::doRemoveFromScene()
-    {
-        GameObject::doRemoveFromScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it-&gt;second-&gt;update();
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Creature.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;Eigenschaft.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;EffectManager.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;Kampftechnik.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;StateSet.h&quot;
+#include &quot;Slot.h&quot;
+#include &quot;Talent.h&quot;
+#include &quot;Weapon.h&quot;
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
+
+    const Ogre::String Creature::PROPERTY_AI = &quot;ai&quot;;
+    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = &quot;behaviours&quot;;
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_LE = &quot;current_le&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_AE = &quot;current_ae&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_AU = &quot;current_au&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = &quot;current_fatigue&quot;;
+    const Ogre::String Creature::PROPERTY_EFFECTS = &quot;effects&quot;;
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = &quot;eigenschaften&quot;;
+    const Ogre::String Creature::PROPERTY_TALENTE = &quot;talente&quot;;
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = &quot;kampftechniken&quot;;
+    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = &quot;kampfaktionen&quot;;
+    const Ogre::String Creature::PROPERTY_VORTEILE = &quot;vorteile&quot;;
+    const Ogre::String Creature::PROPERTY_NACHTEILE = &quot;nachteile&quot;;
+    const Ogre::String Creature::PROPERTY_SF = &quot;sonderfertigkeiten&quot;;
+    const Ogre::String Creature::PROPERTY_WERTE = &quot;werte&quot;;
+    const Ogre::String Creature::PROPERTY_AP = &quot;ap&quot;;
+    const Ogre::String Creature::PROPERTY_INVENTORY = &quot;inventory&quot;;
+    const Ogre::String Creature::PROPERTY_ANIMATIONS = &quot;animations&quot;;
+    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = &quot;animationspeeds&quot;;
+
+    // some targets
+	const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+	const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
+	const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
+    const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
+    const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
+    const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
+    const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
+    const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
+    const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
+    const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
+    const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
+    const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
+    const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
+    const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;;
+    const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
+
+
+
+    Creature::Creature(unsigned int id)
+        : GameObject(id),
+		mCurrentLe(0),
+        mCurrentAu(0),
+        mCurrentAe(0),
+		mInventory(NULL),
+		mEigenschaften(),
+		mWerte(),
+		mTalente(),
+        mKampftechniken(),
+		mKampfaktionen(),
+        mSonderfertigkeiten(),
+        mErschoepfung(0),
+        mMovementType(0),
+        mAlignment(ALIGNMENT_NEUTRAL),
+        mTimeSinceLastRegeneration(0),
+        mLastCalculatedAuToRegenerate(
+                  DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6())
+    {
+        mQueryFlags |= QUERYFLAG_CREATURE;
+
+		setWert(WERT_MOD_AE, 0);
+		setWert(WERT_MOD_LE, 0);
+		setWert(WERT_MOD_AU, 0);
+		setWert(WERT_MOD_MR, 0);
+		setWert(WERT_GS, 8);
+        setWert(WERT_RS, 0);
+        setWert(WERT_BE, 0);
+        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
+		mEigenschaften[E_MUT] = 0;
+		mEigenschaften[E_KLUGHEIT] = 0;
+		mEigenschaften[E_INTUITION] = 0;
+		mEigenschaften[E_CHARISMA] = 0;
+		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
+		mEigenschaften[E_GEWANDTHEIT] = 0;
+		mEigenschaften[E_KONSTITUTION] = 0;
+		mEigenschaften[E_KOERPERKRAFT] = 0;
+
+		mInventory = new Inventory(this);
+    }
+
+	Creature::~Creature()
+    {
+        delete mInventory;
+
+        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
+            delete it-&gt;second;
+        mSonderfertigkeiten.clear();
+        CreatureControllerManager::getSingleton().detachController(this);
+    }
+
+    int Creature::getAttackeBasis() const
+    {
+		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getParadeBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getFernkampfBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getInitiativeBasis() const
+    {
+      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getMrBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getLeBasis() const
+    {
+      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+    int Creature::getAuBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+	int Creature::getAeBasis() const
+	{
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+	int Creature::getWert(Wert wertId, bool getUnmodified) const
+	{
+		WertMap::const_iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + &quot;: Wert &quot; + wertId.c_str() + &quot; nicht gefunden.&quot;).c_str());
+            return 0;
+        }
+        int rval = it-&gt;second;
+        if (!getUnmodified)
+        {
+          rval += mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_SUM);
+          rval *= mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_MULT);
+        }
+		return rval;
+	}
+
+	int Creature::getCurrentBe() const
+	{
+		pair&lt;int,int&gt; be = mInventory-&gt;getOverallBe();
+        ///@todo Ruestungsgewoehnung?
+		return be.first+be.second;
+	}
+
+	void Creature::setWert(Wert wertId, int value)
+	{
+		WertMap::iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+			mWerte.insert(make_pair(wertId, value));
+        }
+		else
+		{
+			it-&gt;second = value;
+		}
+	}
+
+   void Creature::modifyLe(int mod, bool ignoreMax)
+    {
+        int oldLe = mCurrentLe;
+        mCurrentLe += mod;
+		if (!ignoreMax)
+		{
+			mCurrentLe = min(mCurrentLe, getLeMax());
+		}
+
+        if (mCurrentLe &lt;= -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &gt; -getEigenschaft(&quot;KO&quot;))
+        {
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;DeadEffect&quot;));
+        }
+        else if (mCurrentLe &gt; -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &lt;= -getEigenschaft(&quot;KO&quot;))
+        {
+            mEffectManager-&gt;removeEffect(&quot;DeadEffect&quot;);
+        }
+        else if (mCurrentLe &lt;= 0 &amp;&amp; oldLe &gt; 0)
+        {
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;UnconsciousEffect&quot;));
+        }
+        else if (mCurrentLe &gt; 0 &amp;&amp; oldLe &lt;= 0)
+        {
+            mEffectManager-&gt;removeEffect(&quot;UnconciousEffect&quot;);
+        }
+		else if (mCurrentLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
+            oldLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;IncapacitatedEffect&quot;));
+		}
+		else if (mCurrentLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
+            oldLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager-&gt;removeEffect(&quot;IncapacitatedEffect&quot;);
+		}
+
+        fireObjectStateChangeEvent();
+
+    }
+
+    int Creature::getLe() const
+    {
+        return mCurrentLe;
+    }
+
+    int Creature::getLeMax() const
+    {
+		return getLeBasis() + getWert(WERT_MOD_LE);
+    }
+
+    void Creature::modifyAe(int mod, bool ignoreMax)
+    {
+        mCurrentAe += mod;
+		if (!ignoreMax)
+			mCurrentAe = min(mCurrentAe, getAeMax());
+		fireObjectStateChangeEvent();
+    }
+
+    int Creature::getAe() const
+    {
+        return mCurrentAe;
+    }
+
+    int Creature::getAeMax() const
+    {
+		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
+    }
+
+    void Creature::modifyAu(float mod, bool ignoreMax)
+    {
+        mCurrentAu = max(mCurrentAu + mod, 0.0f);
+		if (!ignoreMax)
+			mCurrentAu = min(mCurrentAu, float(getAuMax()));
+        if (getAu() &lt;= 0)
+        {
+            ///@todo set incapacitated
+        }
+		fireObjectStateChangeEvent();
+    }
+
+    float Creature::getAu() const
+    {
+        return mCurrentAu;
+    }
+
+    int Creature::getAuMax() const
+    {
+		return getAuBasis() + getWert(WERT_MOD_AU);
+    }
+
+    void Creature::modifyAp(int modifier)
+    {
+        mAp.total += modifier;
+    }
+
+    int Creature::getAp() const
+    {
+        return mAp.total;
+    }
+
+    void Creature::modifyUsedAp(int modifier)
+    {
+        mAp.used += modifier;
+    }
+
+    int Creature::getUsedAp() const
+    {
+        return mAp.used;
+    }
+
+    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
+    {
+		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
+		if (it == mEigenschaften.end())
+		{
+			Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
+		}
+		int result = it-&gt;second;
+        result += mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
+        return result;
+    }
+
+    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
+    {
+        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
+        if (it == mEigenschaften.end())
+        {
+            Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
+        }
+		it-&gt;second = value;
+        fireObjectStateChangeEvent();
+    }
+
+    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
+    {
+		mEigenschaften[eigenschaftName] += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
+    {
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+            return true;
+        /*
+        if( ausweich )
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt != ausweichTalente.end())
+            {
+                return true;
+            }
+        }
+        */
+		
+        return false;
+    }
+
+    int Creature::getTalent(const CeGuiString talentName) const
+    {
+        LOG_DEBUG(Logger::RULES, &quot;Using talent &quot; + talentName);
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt == ausweichTalente.end())
+            {
+                Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+            }
+            int rval = getTalent(ausweichIt-&gt;first) - ausweichIt-&gt;second;
+            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
+            {
+                int tempAusweichTaw = getTalent(ausweichIt-&gt;first)
+                    - ausweichIt-&gt;second;
+                if (tempAusweichTaw &gt; rval) rval = tempAusweichTaw;
+            }
+            return rval;
+        } //if (it == mTalente.end())
+		return it-&gt;second;
+    }
+
+	void Creature::addTalent(const CeGuiString talentName, int value)
+	{
+		TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+        {
+			Throw(IllegalArgumentException, &quot;Talent schon in mTalente enthalten.&quot;);
+        }
+	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
+		mTalente[talentName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::modifyTalent(const CeGuiString talentName, int mod)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		it-&gt;second += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+	const Creature::TalentMap&amp; Creature::getAllTalents() const
+	{
+		return mTalente;
+	}
+
+    void Creature::setTalent(const CeGuiString talentName, int value)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		it-&gt;second = value;
+		fireObjectStateChangeEvent();
+    }
+
+	void Creature::addSe(const CeGuiString talentName)
+	{
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		//it-&gt;second-&gt;setSe( true );
+        /// @todo Implement SEs
+	}
+
+	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int,int&gt;&amp; value)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it != mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException,
+				&quot;Kampftechnik schon in mKampftechniken enthalten.&quot;);
+		}
+		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
+		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
+		mKampftechniken[kampftechnikName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    pair&lt;int, int&gt; Creature::getKampftechnik(const CeGuiString kampftechnikName) const
+    {
+        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
+        }
+        return (*it).second;
+    }
+
+    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int, int&gt;&amp; value)
+    {
+        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
+        }
+        (*it).second = value;
+		fireObjectStateChangeEvent();
+    }
+
+    void Creature::addKampfaktion(const CeGuiString&amp; kampfaktionName)
+	{
+		mKampfaktionen.insert(kampfaktionName);
+	}
+
+    bool Creature::hasKampfaktion(const CeGuiString&amp; kampfaktionName) const
+	{
+		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
+	}
+
+	const std::set&lt;CeGuiString&gt;&amp; Creature::getAllKampfaktionen() const
+	{
+		return mKampfaktionen;
+	}
+
+    void Creature::addVorteil(const CeGuiString vorteilName, int value)
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Vorteil schon in mVorteile enthalten&quot;);
+        }
+        mVorteile[vorteilName] = value;
+    }
+
+    bool Creature::hasVorteil(const CeGuiString vorteilName) const
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    void Creature::addNachteil(const CeGuiString nachteilName, int value)
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Nachteil schon in mNachteile enthalten&quot;);
+        }
+        mNachteile[nachteilName] = value;
+    }
+
+    bool Creature::hasNachteil(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it == mNachteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Nachteil nicht gefunden.&quot;);
+        }
+		else return it-&gt;second + mEffectManager-&gt;getMod(nachteilName, Effect::MODTYPE_SUM);
+    }
+
+    int Creature::getSf(const CeGuiString sfName) const
+    {
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		return it-&gt;second-&gt;getValue();
+    }
+
+	void Creature::addSf(const CeGuiString sfName, SfStatus value)
+	{
+		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+		if (it != mSonderfertigkeiten.end())
+		{
+			Throw(IllegalArgumentException, &quot;Sonderfertigkeit schon in mSonderfertigkeiten enthalten.&quot;);
+		}
+		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
+        /// @todo
+		//DsaManager::getSingleton().getSf(sfName);
+		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
+		mSonderfertigkeiten[sfName]-&gt;setOriginalValue( value );
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::setSf(const CeGuiString sfName, SfStatus value)
+    {
+        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		it-&gt;second-&gt;setOriginalValue( value );
+		fireObjectStateChangeEvent();
+    }
+
+	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
+	{
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		return it-&gt;second;
+	}
+
+    Effect::LifeState Creature::getLifeState() const
+    {
+      return mEffectManager-&gt;getLifeState();
+    }
+
+	bool Creature::isMagic() const
+	{
+		return getWert(WERT_MOD_AE) &gt; 0;
+	}
+
+    void Creature::setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage)
+    {
+        if (value == true)
+        {
+            statusVariable++;
+        }
+        else //value == false
+        {
+            if (statusVariable &gt; 0)
+            {
+                statusVariable--;
+            }
+            else
+            {
+                LOG_MESSAGE(Logger::RULES, errorMessage);
+            }
+        } //value == false
+    }
+
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+		if (((talent-&gt;getArt() == TALENT_ART_SPEZIAL) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_SPEZIAL)) ||
+			((talent-&gt;getArt() == TALENT_ART_BERUF) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_BERUF)))
+		{
+          /// @todo Find proper return value. Prompt an error message?
+			//Throw(OutOfRangeException, &quot;TaW zu niedrig&quot;);
+          return -1;
+		}
+        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
+
+        // Der Probenwurf
+        Tripel&lt;int&gt; probe(DsaManager::getSingleton().roll3D20());
+
+		// Glueckliche
+		if ( (probe.first == 1) &amp;&amp; (probe.second == 1) &amp;&amp; (probe.third == 1) )
+		{
+			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
+			modifyTalent(talentName, +1);
+			return RESULT_SPEKT_AUTOERFOLG;
+		}
+		if ( ((probe.first == 1) &amp;&amp; (probe.second == 1)) ||
+			 ((probe.first == 1) &amp;&amp; (probe.third == 1)) ||
+			 ((probe.second == 1) &amp;&amp; (probe.third == 1)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOERFOLG;
+		}
+		// Patzer
+		if ((probe.first == 20) &amp;&amp; (probe.second == 20) &amp;&amp; (probe.third == 20))
+		{
+			addSe(talentName);
+			return RESULT_SPEKT_AUTOMISSERFOLG;
+		}
+		if ( ((probe.first == 20) &amp;&amp; (probe.second == 20)) ||
+			 ((probe.first == 20) &amp;&amp; (probe.third == 20)) ||
+			 ((probe.second == 20) &amp;&amp; (probe.third == 20)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOMISSERFOLG;
+		}
+
+
+        // Vor dem Vergleich hat man den Talentwert &#195;&#188;brig.
+		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM));
+		int taW = getTalent(talentName);
+		int rval = taW - modifier - mEffectManager-&gt;getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
+            - mEffectManager-&gt;getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
+		// Bei negativen TaP*
+		int handicap = 0;
+		if (rval &lt; 0)
+		{
+			handicap = -rval;
+			rval = 0;
+		}
+
+        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
+        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
+        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
+
+        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
+        // wird die Differenz vom Talentwert abgezogen.
+        rval = diff1 &lt; 0 ? rval + diff1 : rval;
+        rval = diff2 &lt; 0 ? rval + diff2 : rval;
+        rval = diff3 &lt; 0 ? rval + diff3 : rval;
+
+		// TaP* niemals gr&#195;&#182;&#195;&#159;er als TaW (MFF14)
+		if (rval &gt; taW) rval = taW;
+        return rval;
+    }
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
+			eigenschaft2Name, eigenschaft3Name);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent-&gt;getEigenschaften());
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
+			et.first, et. second, et.third);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent-&gt;getEigenschaften());
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
+			et. second, et.third);
+	}
+
+    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
+    {
+        int rval;
+
+        int probe = DsaManager::getSingleton().rollD20();
+        if (probe == 1)
+        {
+            rval = RESULT_GLUECKLICH;
+        }
+        else if (probe == 20)
+        {
+            rval = RESULT_PATZER;
+        }
+        else
+        {
+			rval = getEigenschaft(eigenschaftName) -
+                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
+        }
+        return rval;
+    }
+
+
+	Inventory* Creature::getInventory() const
+	{
+		return mInventory;
+	}
+
+    const Ogre::String&amp; Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
+
+	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
+		}
+		int rval;
+		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_PATZER;
+		}
+		else
+		{
+			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval &lt; 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
+		}
+		int rval;
+		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20)
+		{
+			rval = RESULT_PATZER; /// @todo Best&#195;&#164;tigen
+		}
+		else
+		{
+			/// @todo Gute Parade
+			rval = getParadeBasis() + (*it).second.second - (probe + modifier
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval &lt; 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doInitiativeWurf(bool getMaxInitiave)
+	{
+		int rval = getInitiativeBasis();
+		rval += mEffectManager-&gt;getMod(WERT_INI, Effect::MODTYPE_SUM);
+		rval -= mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM);
+		if (getMaxInitiave)
+        {
+            rval += 6;
+        }
+        else
+        {
+            rval += DsaManager::getSingleton().rollD6();
+        }
+		return rval;
+	}
+
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
+	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
+		// Roll dice
+		const Tripel&lt;int&gt;&amp; weaponTp = weapon-&gt;getTp();
+		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
+		rval += weaponTp.third;
+
+		// Apply TP/KK
+
+		int kk = getEigenschaft(E_KOERPERKRAFT);
+		std::pair&lt;int, int&gt; tpkk = weapon-&gt;getTpKk();
+		
+		int bonus = (kk - tpkk.first) / tpkk.second;
+		rval += bonus;
+        
+        if (damage == DMG_HALF)
+        {
+            rval = (rval + 1) / 2;
+        }
+        else if (damage == DMG_DOUBLE)
+        {
+            rval *= 2; ///@TODO check if correct
+        }
+
+		return rval;
+	}
+
+	/// @todo Implement correctly
+	void Creature::damageLe(int tp, int damageType)
+	{
+        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+        if (tp &lt; 0)
+        {
+            tp = 0;
+        }
+
+        ///@todo auf Verletzlichkeiten und Immunitaeten achten
+        if (damageType &amp; LEDAMAGE_FIRE)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Fire damage not handled!&quot;); ///@todo implement
+        }
+        if (damageType &amp; LEDAMAGE_WATER)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Water damage not handled!&quot;); ///@todo implement
+        }
+        if (damageType &amp; LEDAMAGE_DEMONIC)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Demonic damage not handled!&quot;); ///@todo implement
+        }
+
+        if (damageType &amp; LEDAMAGE_TP_A)
+        {
+            damageAu(tp, AUDAMAGE_NORMAL);
+            tp = (int)floor(tp/2.);
+        }
+
+        int sp = -tp;
+        if (!(damageType &amp; LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
+		modifyLe(sp);
+
+        if (sp &gt;= getEigenschaft(&quot;KO&quot;))
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;TODO: Add a wound.&quot;); ///@todo implement
+        }
+	}
+
+    void Creature::damageAe(int asp)
+    {
+        if (asp &lt; 0)
+        {
+         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           asp = 0;
+        }
+        modifyAe(-asp);
+    }
+
+    void Creature::damageAu(float aup, int damageType)
+    {
+        if (aup &lt; 0)
+        {
+         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           aup = 0;
+           ///@todo evtl. eine modifyErschoepfung()?
+           mErschoepfung += DsaManager::getSingleton().rollD6();
+           ///@todo set incapacitated
+        }
+        // bei &#195;&#156;beranstrengung, kostet alles doppelte Au!!!!!
+        if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
+            aup *= 2;
+        modifyAu(-aup);
+    }
+
+    void Creature::regenerateLe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedLe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedLe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
+            0, Effect::MODTAG_REGENERATION_LE))
+        {
+            regeneratedLe++;
+        }
+        //modifiziere die aktuellen LE
+        modifyLe(regeneratedLe);
+    }
+
+    void Creature::regenerateAe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedAe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedAe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;IN&quot;,
+            0, Effect::MODTAG_REGENERATION_AE))
+        {
+            regeneratedAe++;
+        }
+        //modifiziere die aktuellen AE
+        modifyAe(regeneratedAe);
+    }
+
+    void Creature::regenerateAu(int modifier, float factor, float time)
+    {
+        // das Ganze nur jede Spielrunde machen
+        mTimeSinceLastRegeneration += time;
+
+
+        if( getAu() == getAuMax() )
+        {
+            mTimeSinceLastRegeneration = 0;
+            return;
+        }
+
+
+        while( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE )
+        {
+            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
+
+
+            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
+            //Grundregeneration von 3W6
+            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6();
+            //Addiere eventuelle Modifikatoren hinzu
+            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
+            //Bei gelungener KO Probe addiere 1
+            if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
+                0, mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
+            {
+                modifyAu(6*factor);
+            }
+
+            if( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            {
+                //modifiziere die aktuellen AU
+                time -= Date::ONE_SPIELRUNDE;
+                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
+            }
+
+            if( getAu() == getAuMax() )
+            {
+                mTimeSinceLastRegeneration = 0;
+                return;
+            }
+        }
+
+        // Restbetrag regenerieren:
+        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        modifyAu(regeneratedAuPerTime*factor);
+    }
+
+    void Creature::setAlignment(Creature::Alignment alignment)
+    {
+        mAlignment = alignment;
+    }
+
+    Creature::Alignment Creature::getAlignment() const
+    {
+        return mAlignment;
+    }
+
+    void Creature::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            mAiProperties = value;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            mCurrentLe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toReal();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            mKampfaktionen.clear();
+            convertToSet(value.toArray(), mKampfaktionen);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory-&gt;setProperties(value.toMap());
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            mAnimations.clear();
+            convertToMap(value.toMap(), mAnimations);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            mAnimationSpeeds.clear();
+            convertToMap(value.toMap(), mAnimationSpeeds);
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Creature::getProperty(const CeGuiString&amp; key) const
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            return mAiProperties;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            return Property(mCurrentLe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            return Property(mCurrentAe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            return Property(mCurrentAu);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            return Property(mErschoepfung);
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
+            return Property(vec);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+            return Property(map);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            return Property(make_pair(mAp.total, mAp.used));
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+			return mInventory-&gt;getAllProperties()-&gt;toPropertyMap();
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimations);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
+            return Property(map);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Creature::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Creature::PROPERTY_AI);
+        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
+        keys.insert(Creature::PROPERTY_CURRENT_LE);
+        keys.insert(Creature::PROPERTY_CURRENT_AE);
+        keys.insert(Creature::PROPERTY_CURRENT_AU);
+        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
+        keys.insert(Creature::PROPERTY_TALENTE);
+        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
+        keys.insert(Creature::PROPERTY_VORTEILE);
+        keys.insert(Creature::PROPERTY_NACHTEILE);
+        //keys.insert(Creature::PROPERTY_SF);
+        keys.insert(Creature::PROPERTY_WERTE);
+        keys.insert(Creature::PROPERTY_AP);
+        keys.insert(Creature::PROPERTY_INVENTORY);
+        keys.insert(Creature::PROPERTY_ANIMATIONS);
+        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
+
+        return keys;
+    }
+
+    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString&amp; name) const
+    {
+        AnimationSpeedPair ret;
+        AnimationsMap::const_iterator itName = mAnimations.find(name);
+        if( itName != mAnimations.end() )
+            ret.first = itName-&gt;second.c_str();
+        else
+            ret.first = name.c_str();
+
+        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
+        if( itSpeed != mAnimationSpeeds.end() )
+            ret.second = itSpeed-&gt;second;
+        else
+            ret.second = 1;
+
+        return ret;
+    }
+
+    bool Creature::canReachItem(const Item* item) const
+    {
+        return (item-&gt;getPosition() - getPosition()).length() &lt;= 3.0f;
+    }
+
+    void Creature::doPlaceIntoScene()
+    {
+        GameObject::doPlaceIntoScene();
+
+        // check items in inventory
+        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
+        Inventory::SlotMap::iterator it = slots.begin();
+        for( ; it != slots.end(); it++ )
+        {
+            it-&gt;second-&gt;update();
+        }
+    }
+
+    void Creature::doRemoveFromScene()
+    {
+        GameObject::doRemoveFromScene();
+
+        ///@todo check if this is really necessary
+        // check items in inventory
+        //Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it-&gt;second-&gt;update();
+        //}
+    }
+}

Modified: rl/branches/newton20/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GoToJob.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/GoToJob.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -36,8 +36,6 @@
 		  mTimeLeft(duration)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
-                if( mActor == NULL )
-                    Throw(NullPointerException, &quot;Couldn't get a CreatureController!&quot;);
 	}
 
 	GoToJob::GoToJob(Creature* actor, GameObject* target, Real maxDistance, Real duration)
@@ -49,10 +47,6 @@
 		  mTimeLeft(duration)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
-                if( mActor == NULL )
-                    Throw(NullPointerException, &quot;Couldn't get a CreatureController!&quot;);
-                if( mTarget == NULL )
-                    Throw(NullPointerException, &quot;Argument GameObject* target cannot be NULL!&quot;);
 	}
 
     GoToJob::~GoToJob()
@@ -68,25 +62,22 @@
 			mActor-&gt;setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
-
-                Ogre::Real distance = 0;
-
+        
+        Ogre::Real distance;
+        
 		// update target position
 		if (mTarget)
 		{
 			mTargetPos = mTarget-&gt;getPosition();
-		        // Are we there now?
-		        distance = MathUtil::distance(mTarget-&gt;getWorldBoundingBox(),
-			    mActor-&gt;getCreature()-&gt;getWorldBoundingBox());
-		}
-                else
-                {
-                    if( mActor-&gt;getCreature()-&gt;getWorldBoundingBox().intersects(mTargetPos) )
-                        distance = 0;
-                    else
-                        distance = (mTargetPos - mActor-&gt;getCreature()-&gt;getPosition()).length();
-                }
-
+            distance = MathUtil::distance(mTarget-&gt;getWorldBoundingBox(),
+                                                     mActor-&gt;getCreature()-&gt;getWorldBoundingBox());
+        }
+        else 
+        {
+            distance = MathUtil::distance(mTargetPos, mActor-&gt;getCreature()-&gt;getWorldBoundingBox());
+        }
+        
+		// Are we there now?
 		if (distance &lt; mMaxDistance)
 		{
 			// Stay put where ever we are.
@@ -94,8 +85,6 @@
 			return true;
 		}
 
-
-                /*
 		// Hard set orientation.
 		/// @todo Use CreatureController properly to turn smoothly
 		Vector3 pos = mActor-&gt;getCreature()-&gt;getPosition();
@@ -104,13 +93,8 @@
 		targetPos.y = 0;
 		mActor-&gt;getCreature()-&gt;setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
 		mActor-&gt;setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
-                */
-		Vector3 pos = mActor-&gt;getCreature()-&gt;getPosition();
-                Radian yawDiff = Vector3::NEGATIVE_UNIT_Z.getRotationTo(mTargetPos-pos, Vector3::UNIT_Y).getYaw() - mActor-&gt;getYaw();
-                Vector3 rotation = Vector3::UNIT_Y*yawDiff.valueRadians();
-		mActor-&gt;setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, rotation);
 
-                mTimeLeft  -= time;
+		mTimeLeft  -= time;
 		return false;
 	}
 }

Modified: rl/branches/newton20/engine/rules/src/Weapon.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Weapon.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/rules/src/Weapon.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -36,7 +36,8 @@
     const Ogre::String Weapon::PROPERTY_TP_DK = &quot;DK&quot;;
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = &quot;kampftechnik&quot;;
     const Ogre::String Weapon::PROPERTY_NATURAL = &quot;natural&quot;;
-
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = &quot;avoidarmor&quot;;
+    
 	Weapon::Weapon(unsigned int id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +47,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(&quot;&quot;),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +186,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString&amp; key, const Property&amp; value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +251,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +312,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +333,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }

Modified: rl/branches/newton20/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-12-17 20:11:09 UTC (rev 4654)
@@ -432,6 +432,10 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;.\include\CharacterSelectionWindow.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;.\include\CharacterSheetWindow.h&quot;
 					&gt;
 				&lt;/File&gt;
@@ -677,6 +681,10 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;.\src\CharacterSelectionWindow.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;.\src\CharacterSheetWindow.cpp&quot;
 					&gt;
 				&lt;/File&gt;

Modified: rl/branches/newton20/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -22,6 +22,7 @@
 
 #include &lt;CEGUIWindow.h&gt;
 #include &lt;elements/CEGUICheckbox.h&gt;
+#include &lt;elements/CEGUIRadioButton.h&gt;
 #include &lt;elements/CEGUIEditbox.h&gt;
 #include &lt;elements/CEGUIListbox.h&gt;
 #include &lt;elements/CEGUIMultiColumnList.h&gt;
@@ -77,6 +78,7 @@
 		CEGUI::MenuBase* getMenu(const char* name);
 		CEGUI::MenuItem* getMenuItem(const char* name);
 		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::RadioButton* getRadioButton(const char* name);
 		CEGUI::Combobox* getCombobox(const char* name);
 		CEGUI::ComboDropList* getComboDropList(const char* name);
         CEGUI::ScrollablePane* getScrollablePane(const char* name);

Modified: rl/branches/newton20/engine/ui/include/GameSettings.h
===================================================================
--- rl/branches/newton20/engine/ui/include/GameSettings.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/GameSettings.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -84,7 +84,12 @@
 		bool onRenderSystemChanged();
         
         void update();
-
+        
+        void setOption(const Ogre::ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, CEGUI::Checkbox* checkbox);
+        void setOption(const Ogre::ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, CEGUI::Combobox* combobox);
+        void setOption(const Ogre::ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, std::vector&lt;CEGUI::RadioButton*&gt; radioGroup);
+        void createElements(CEGUI::Combobox* combobox, size_t count);
+        
 		std::list&lt;SoundDriverConfigComponent*&gt; mSoundDriverConfigs;   //!&lt; List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!&lt; Configuration component of currently selected sound driver
 		std::list&lt;RenderSystemConfigComponent*&gt; mRenderSystemConfigs; //!&lt; List of registered rendersystem configuration components
@@ -93,6 +98,9 @@
         CEGUI::Combobox* mVideoRenderer;
         CEGUI::Combobox* mVideoResolution;
         CEGUI::Checkbox* mVideoFullscreen;
+        CEGUI::RadioButton* mVideoColorDepth32, *mVideoColorDepth16;
+        CEGUI::RadioButton* mVideoFsaa0, *mVideoFsaa2, *mVideoFsaa4, *mVideoFsaa8;
+        CEGUI::RadioButton* mVideoRttModeFBO, *mVideoRttModePBuffer, *mVideoRttModeCopy;
 	};
 }
 

Modified: rl/branches/newton20/engine/ui/include/WindowManager.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowManager.h	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/include/WindowManager.h	2008-12-17 20:11:09 UTC (rev 4654)
@@ -19,6 +19,8 @@
 
 #include &quot;UiPrerequisites.h&quot;
 
+#include &quot;MessagePump.h&quot;
+
 namespace rl {
 
 	class AbstractWindow;
@@ -33,6 +35,7 @@
 		void registerWindow(AbstractWindow* window);
 		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
+        bool destroyAllWindows();
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
@@ -47,6 +50,7 @@
 
 	private:
 		std::list&lt;AbstractWindow*&gt; mWindowList;
+        MessagePump::ScopedConnection mSceneClearConnection;
 
         unsigned short mNumActiveWindowsMouseInput;
         unsigned short mNumActiveWindowsKeyboardInput;

Modified: rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -232,7 +232,12 @@
 	{
 		return static_cast&lt;PushButton*&gt;(getWindow(name, &quot;PushButton&quot;));
 	}
-
+    
+	RadioButton* AbstractWindow::getRadioButton(const char* name)
+	{
+		return static_cast&lt;RadioButton*&gt;(getWindow(name, &quot;RadioButton&quot;));
+	}
+    
 	Combobox* AbstractWindow::getCombobox(const char* name)
 	{
 		return static_cast&lt;Combobox*&gt;(getWindow(name, &quot;Combobox&quot;));

Modified: rl/branches/newton20/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,14 +18,22 @@
 #include &quot;GameSettings.h&quot;
 
 #include &lt;boost/bind.hpp&gt;
+#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#include &lt;CEGUI/elements/CEGUIFrameWindow.h&gt;
+#include &lt;CEGUI/elements/CEGUIListboxTextItem.h&gt;
+#else
 #include &lt;elements/CEGUIFrameWindow.h&gt;
 #include &lt;elements/CEGUIListboxTextItem.h&gt;
+#endif
+
 #include &lt;iostream&gt;
 
 #include &quot;SoundManager.h&quot;
 #include &quot;SoundDriver.h&quot;
 
 using namespace Ogre;
+using namespace CEGUI;
+using namespace std;
 
 namespace rl
 {
@@ -51,6 +59,37 @@
         mVideoRenderer = getCombobox(&quot;GameOptionsWindow/Video/Renderer&quot;);
         mVideoResolution = getCombobox(&quot;GameOptionsWindow/Video/Resolution&quot;);
         mVideoFullscreen = getCheckbox(&quot;GameOptionsWindow/Video/Fullscreen&quot;);
+        
+        mVideoColorDepth32 = getRadioButton(&quot;GameOptionsWindow/Video/ColorDepth/32&quot;);
+        mVideoColorDepth32-&gt;setUserData(new Ogre::String(&quot;32&quot;));
+        mVideoColorDepth32-&gt;setGroupID(1);
+        mVideoColorDepth16 = getRadioButton(&quot;GameOptionsWindow/Video/ColorDepth/16&quot;);
+        mVideoColorDepth16-&gt;setUserData(new Ogre::String(&quot;16&quot;));
+        mVideoColorDepth16-&gt;setGroupID(1);
+        
+        mVideoFsaa0 = getRadioButton(&quot;GameOptionsWindow/Video/FSAA/Off&quot;);
+        mVideoFsaa0-&gt;setUserData(new Ogre::String(&quot;0&quot;));
+        mVideoFsaa0-&gt;setGroupID(2);
+        mVideoFsaa2 = getRadioButton(&quot;GameOptionsWindow/Video/FSAA/2x&quot;);
+        mVideoFsaa2-&gt;setUserData(new Ogre::String(&quot;2&quot;));
+        mVideoFsaa2-&gt;setGroupID(2);
+        mVideoFsaa4 = getRadioButton(&quot;GameOptionsWindow/Video/FSAA/4x&quot;);
+        mVideoFsaa4-&gt;setUserData(new Ogre::String(&quot;4&quot;));
+        mVideoFsaa4-&gt;setGroupID(2);
+        mVideoFsaa8 = getRadioButton(&quot;GameOptionsWindow/Video/FSAA/8x&quot;);
+        mVideoFsaa8-&gt;setUserData(new Ogre::String(&quot;8&quot;));
+        mVideoFsaa8-&gt;setGroupID(2);
+        
+        mVideoRttModeFBO = getRadioButton(&quot;GameOptionsWindow/Video/RTT/FBO&quot;);
+        mVideoRttModeFBO-&gt;setUserData(new Ogre::String(&quot;FBO&quot;));
+        mVideoRttModeFBO-&gt;setGroupID(3);
+        mVideoRttModePBuffer = getRadioButton(&quot;GameOptionsWindow/Video/RTT/PBuffer&quot;);
+        mVideoRttModePBuffer-&gt;setUserData(new Ogre::String(&quot;PBuffer&quot;));
+        mVideoRttModePBuffer-&gt;setGroupID(3);
+        mVideoRttModeCopy = getRadioButton(&quot;GameOptionsWindow/Video/RTT/Copy&quot;);
+        mVideoRttModeCopy-&gt;setUserData(new Ogre::String(&quot;Copy&quot;));
+        mVideoRttModeCopy-&gt;setGroupID(3);
+        
         centerWindow();
         setVisible(false);
         update();
@@ -137,50 +176,124 @@
     void GameSettings::update()
     {
         Root* root = Ogre::Root::getSingletonPtr();
+        
+        RenderSystemList* renderers = root-&gt;getAvailableRenderers();
         RenderSystem* renderer = root-&gt;getRenderSystem();
         
+        createElements(mVideoRenderer, renderers-&gt;size());
+
+        for (int i = 0; i &lt; renderers-&gt;size(); ++i)
+        {
+            RenderSystem* cur = renderers-&gt;operator[](i);
+            ListboxItem* item = mVideoRenderer-&gt;getListboxItemFromIndex(i);
+            item-&gt;setText(cur-&gt;getName());
+            if (cur == renderer)
+            {
+                mVideoRenderer-&gt;setItemSelectState(item, true);
+            }
+        }
+        
         ConfigOptionMap config = renderer-&gt;getConfigOptions();
         
-		ConfigOptionMap::iterator cfi;
-		
-		cfi = config.find( &quot;Full Screen&quot; );
-		if( cfi != config.end() )
-		{
-			mVideoFullscreen-&gt;setSelected(cfi-&gt;second.currentValue == &quot;Yes&quot;);
-		}
+        setOption(config, &quot;Full Screen&quot;, mVideoFullscreen);
+        vector&lt;RadioButton*&gt; videoColorDepth;
+        videoColorDepth.push_back(mVideoColorDepth32);
+        videoColorDepth.push_back(mVideoColorDepth16);
         
-/*		cfi = config.find( &quot;FSAA&quot; );
-		if( cfi != config.end() )
-		{
-			if( cfi-&gt;second.currentValue == &quot;0&quot; )
-			{
-				SetControlValue( iFSAARef, 1 );
-			}
-			else if( cfi-&gt;second.currentValue == &quot;2&quot; )
-			{
-				SetControlValue( iFSAARef, 2 );
-			}
-			else if( cfi-&gt;second.currentValue == &quot;4&quot; )
-			{
-				SetControlValue( iFSAARef, 3 );
-			}
-			else if( cfi-&gt;second.currentValue == &quot;6&quot; )
-			{
-				SetControlValue( iFSAARef, 4 );
-			}
-		}
+        setOption(config, &quot;Colour Depth&quot;, videoColorDepth);
+        vector&lt;RadioButton*&gt; videoAntiAliasing;
+        videoAntiAliasing.push_back(mVideoFsaa0);
+        videoAntiAliasing.push_back(mVideoFsaa2);
+        videoAntiAliasing.push_back(mVideoFsaa4);
+        videoAntiAliasing.push_back(mVideoFsaa8);
+        setOption(config, &quot;FSAA&quot;, videoAntiAliasing);
         
-		cfi = config.find( &quot;Colour Depth&quot; );
-		if( cfi != config.end() )
-		{
-			if( cfi-&gt;second.currentValue == &quot;32&quot; )
-			{
-				SetControlValue( iColorDepthRef, 1 );
-			}
-			else
-			{
-				SetControlValue( iColorDepthRef, 2 );
-			}
-		}*/
+        vector&lt;RadioButton*&gt; videoRttMode;
+        videoRttMode.push_back(mVideoRttModeFBO);
+        videoRttMode.push_back(mVideoRttModePBuffer);
+        videoRttMode.push_back(mVideoRttModeCopy);
+        setOption(config, &quot;RTT Preferred Mode&quot;, videoRttMode);
+        
+        setOption(config, &quot;Video Mode&quot;, mVideoResolution);
     }
+    
+    void GameSettings::setOption(const ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, Checkbox* checkbox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            checkbox-&gt;setSelected(cfi-&gt;second.currentValue == &quot;Yes&quot;);            
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, Combobox* combobox)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi-&gt;second;
+            int delta = curOption.possibleValues.size() - combobox-&gt;getItemCount();
+            if (delta &gt; 0)
+            {
+                for (int i = 0; i &lt; delta; ++i)
+                {
+                    combobox-&gt;addItem(new ListboxTextItem(&quot;&quot;));
+                }
+            }
+            else if (delta &lt; 0)
+            {
+                for (int i = 0; i &lt; -delta; ++i)
+                {
+                    ListboxItem* item = combobox-&gt;getListboxItemFromIndex(combobox-&gt;getItemCount() - 1);
+                    combobox-&gt;removeItem(item);
+                    delete item;
+                }
+            }
+            
+            for (int i = 0; i &lt; combobox-&gt;getItemCount(); ++i)
+            {
+                ListboxItem* item = combobox-&gt;getListboxItemFromIndex(i);
+                item-&gt;setText(curOption.possibleValues[i]);
+            }
+        }
+    }
+
+    void GameSettings::setOption(const ConfigOptionMap&amp; configuration, const Ogre::String&amp; option, std::vector&lt;RadioButton*&gt; radioGroup)
+    {
+        ConfigOptionMap::const_iterator cfi = configuration.find(option);
+        if (cfi != configuration.end()) 
+        {
+            ConfigOption curOption = cfi-&gt;second;
+            for (std::vector&lt;RadioButton*&gt;::const_iterator it = radioGroup.begin(); it != radioGroup.end(); ++it)
+            {
+                Ogre::String* value = static_cast&lt;Ogre::String*&gt;((*it)-&gt;getUserData());
+                if (value &amp;&amp; (*value == curOption.currentValue))
+                {
+                    (*it)-&gt;setSelected(true);
+                    break;
+                }
+            }
+        }
+    }
+    
+    void GameSettings::createElements(CEGUI::Combobox* combobox, size_t count)
+    {
+        int delta = count - combobox-&gt;getItemCount();
+        if (delta &gt; 0)
+        {
+            for (int i = 0; i &lt; delta; ++i)
+            {
+                combobox-&gt;addItem(new ListboxTextItem(&quot;&quot;));
+            }
+        }
+        else if (delta &lt; 0)
+        {
+            for (int i = 0; i &lt; -delta; ++i)
+            {
+                ListboxItem* item = combobox-&gt;getListboxItemFromIndex(combobox-&gt;getItemCount() - 1);
+                combobox-&gt;removeItem(item);
+                delete item;
+            }
+        }
+    }    
 }

Modified: rl/branches/newton20/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -268,7 +268,7 @@
 
         mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
 
-        if (isEnemyNear())
+        if (isEnemyNear() &amp;&amp; !(mCharacter-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT))
         {
             InputManager::getSingleton().pushControlState(CST_COMBAT);
         }

Modified: rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -166,6 +166,7 @@
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
         mWindowFactory-&gt;initialize();
+        LOG_MESSAGE2(Logger::UI, &quot;WindowFactory initialized.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
     }
 
     CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()

Modified: rl/branches/newton20/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowManager.cpp	2008-12-16 00:26:55 UTC (rev 4653)
+++ rl/branches/newton20/engine/ui/src/WindowManager.cpp	2008-12-17 20:11:09 UTC (rev 4654)
@@ -18,8 +18,9 @@
 #include &quot;WindowManager.h&quot;
 #include &lt;CEGUIWindowManager.h&gt;
 
+#include &quot;AbstractWindow.h&quot;
+#include &quot;CoreMessages.h&quot;
 #include &quot;CoreSubsystem.h&quot;
-#include &quot;AbstractWindow.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;GameLoop.h&quot;
 #include &quot;UiSubsystem.h&quot;
@@ -35,6 +36,8 @@
           mNumActiveWindowsMouseInput(0),
           mNumActiveWindowsKeyboardInput(0)
 	{
+        mSceneClearConnection = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneClearing&gt;(
+            boost::bind(&amp;WindowManager::destroyAllWindows, this));
 	}
 
 	WindowManager::~WindowManager()
@@ -123,10 +126,9 @@
     AbstractWindow* WindowManager::getActiveWindow()
     {
         // iterate through windows
-        std::list&lt;AbstractWindow*&gt;::iterator it;
-        for( it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        for (std::list&lt;AbstractWindow*&gt;::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
         {
-            if( (*it)-&gt;getWindow()-&gt;isActive() )
+            if ( (*it)-&gt;getWindow()-&gt;isActive() )
             {
                 return *it;
             }
@@ -134,4 +136,23 @@
 
         return NULL;
     }
+
+    bool WindowManager::destroyAllWindows()
+    {
+        for (std::list&lt;AbstractWindow*&gt;::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        {
+            AbstractWindow* cur = *it;
+//			if (cur-&gt;isVisible())
+//			{
+				cur-&gt;setVisible(false, true);
+//			}
+//          else 
+//          {
+//              delete cur;
+//          }
+        }
+
+        mWindowList.clear();
+        return true;
+    }
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001710.html">[Dsa-hl-svn] r4653 - modules/kanalisation/materials
</A></li>
	<LI>Next message: <A HREF="001712.html">[Dsa-hl-svn] r4655 - rl/branches/newton20/engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1711">[ date ]</a>
              <a href="thread.html#1711">[ thread ]</a>
              <a href="subject.html#1711">[ subject ]</a>
              <a href="author.html#1711">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
