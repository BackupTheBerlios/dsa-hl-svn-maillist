<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4623 - in rl/trunk/engine/rules: include src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4623%20-%20in%20rl/trunk/engine/rules%3A%20include%20src&In-Reply-To=%3C200812012118.mB1LIvWD011120%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001679.html">
   <LINK REL="Next"  HREF="001681.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4623 - in rl/trunk/engine/rules: include src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4623%20-%20in%20rl/trunk/engine/rules%3A%20include%20src&In-Reply-To=%3C200812012118.mB1LIvWD011120%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4623 - in rl/trunk/engine/rules: include src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Mon Dec  1 22:18:57 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001679.html">[Dsa-hl-svn] r4622 - modules/common/dsa
</A></li>
        <LI>Next message: <A HREF="001681.html">[Dsa-hl-svn] r4624 - modules/common/dsa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1680">[ date ]</a>
              <a href="thread.html#1680">[ thread ]</a>
              <a href="subject.html#1680">[ subject ]</a>
              <a href="author.html#1680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-12-01 22:18:53 +0100 (Mon, 01 Dec 2008)
New Revision: 4623

Modified:
   rl/trunk/engine/rules/include/ApplyDamageJob.h
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/include/Combatant.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Weapon.h
   rl/trunk/engine/rules/src/ApplyDamageJob.cpp
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/rules/src/Combatant.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Weapon.cpp
Log:
Rules for natural weapons

Modified: rl/trunk/engine/rules/include/ApplyDamageJob.h
===================================================================
--- rl/trunk/engine/rules/include/ApplyDamageJob.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/ApplyDamageJob.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Job.h&quot;
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Job.h&quot;
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Combat.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;set&gt;
-#include &lt;vector&gt;
-#include &lt;boost/tuple/tuple.hpp&gt;
-
-#include &quot;JobListener.h&quot;
-#include &quot;Kampfaktion.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set&lt;Combatant*&gt; CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet&amp; getAllPlayerOpponents() const;
-        const CombatantSet&amp; getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
-		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
-		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
-        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set&lt;int&gt; mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &lt;set&gt;
+#include &lt;vector&gt;
+#include &lt;boost/tuple/tuple.hpp&gt;
+
+#include &quot;Creature.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;Kampfaktion.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesConstants.h&quot;
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set&lt;Combatant*&gt; CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet&amp; getAllPlayerOpponents() const;
+        const CombatantSet&amp; getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
+		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
+		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
+        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set&lt;int&gt; mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Combatant.h
===================================================================
--- rl/trunk/engine/rules/include/Combatant.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Combatant.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Creature.h&quot;
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Creature.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,870 +1,877 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __CREATURE_H__
-#define __CREATURE_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Date.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;Eigenschaft.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;ZauberStateSet.h&quot;
-#include &quot;SonderfertigkeitenStateSet.h&quot;
-
-namespace rl
-{
-    class Container;
-    class Inventory;
-    class Item;
-    class Weapon;
-
-///////////////////////////////////////////////////////////////////////////////
-// Konstanten
-
-    /**
-    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
-    /**
-    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
-    *  duerfen.
-    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
-    *   und SuH.
-    **/
-    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
-
-    /// Eine Doppel-1
-    static const int RESULT_AUTOERFOLG = 100;
-    /// Eine Dreifach-1
-    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
-    /// Eine Doppel-20
-    static const int RESULT_AUTOMISSERFOLG = -100;
-    /// Eine Dreifach-20
-    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
-    /**
-     *  Eine bestaetigte 1 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
-     *  eine einfache 1 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_GLUECKLICH = 100;
-    /**
-     *  Eine bestaetigte 20 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
-     *  eine einfache 20 bei einer Eigenschaftsprobe.
-     **/
-    static const int RESULT_PATZER = -100;
-    /// Eine normal gelungene Attacke oder Parade
-    static const int RESULT_ERFOLG = 1;
-    /// Eine normal misslungene Attacke oder Parade
-    static const int RESULT_MISSERFOLG = -1;
-
-
-    /// Basistalente
-    /// @todo Passenderen Ort suchen
-    static const CeGuiString TALENT_ART_BASIS = &quot;Basis&quot;;
-    /// Spezialtalente
-    static const CeGuiString TALENT_ART_SPEZIAL = &quot;Spezial&quot;;
-    /// Berufstalente
-    static const CeGuiString TALENT_ART_BERUF = &quot;Beruf&quot;;
-
-    /**
-     *  @defgroup CreatureRubyExports Creature
-     *  @ingroup RulesRubyExports
-     **/
-
-    /**
-    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
-    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
-    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
-    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
-    * Spielwelt noetig ist (z.B. Proben).
-    */
-    class _RlRulesExport Creature : public GameObject
-    {
-        public:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  List of all talents. Consists of the (german) name of the talent
-             *  (e.g. &quot;Athletik&quot;) as key and its value (TaW)
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; TalentMap;
-
-            static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_AI;
-            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
-			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
-            static const Ogre::String PROPERTY_CURRENT_LE;
-            static const Ogre::String PROPERTY_CURRENT_AE;
-            static const Ogre::String PROPERTY_CURRENT_AU;
-            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
-            static const Ogre::String PROPERTY_EFFECTS;
-            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
-            static const Ogre::String PROPERTY_TALENTE;
-            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
-            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
-            static const Ogre::String PROPERTY_VORTEILE;
-            static const Ogre::String PROPERTY_NACHTEILE;
-            static const Ogre::String PROPERTY_SF;
-            static const Ogre::String PROPERTY_WERTE;
-            static const Ogre::String PROPERTY_AP;
-            static const Ogre::String PROPERTY_INVENTORY;
-            static const Ogre::String PROPERTY_ANIMATIONS;
-            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
-
-            typedef Ogre::String Wert;
-
-            // some targets
-			static const std::string ALL_EIGENSCHAFTEN;
-			static const std::string ALL_TALENTE;
-
-            static const Wert WERT_MOD_AE;
-            static const Wert WERT_MOD_LE;
-            static const Wert WERT_MOD_AU;
-            static const Wert WERT_MOD_MR;
-            static const Wert WERT_MOD_AT;
-            static const Wert WERT_MOD_PA;
-            static const Wert WERT_MOD_FK;
-            static const Wert WERT_GS;
-            static const Wert WERT_SOZIALSTATUS;
-            static const Wert WERT_BE;
-            static const Wert WERT_RS;
-            static const Wert WERT_INI;
-            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
-            static const Wert WERT_REGENERATION;
-    			
-			Creature(unsigned int id);
-
-            /// Der Standarddestruktor.
-            virtual ~Creature();
-
-///////////////////////////////////////////////////////////////////////////////
-// Enums
-            /// Alignment of a Creature towards the player. This determines
-            /// whether a combat is entered.
-            enum Alignment
-            {
-                ALIGNMENT_ALLY    = 1, ///&lt; Creature fights with the player.
-                ALIGNMENT_NEUTRAL = 2, ///&lt; Creature doesn't fight for either side.
-                ALIGNMENT_ENEMY   = 4  ///&lt; Creature fights against the player.
-            };
-
-            /// Determines the damage type
-            enum DamageTag
-            {
-                DAMAGETAG_NORMAL = 1,
-                DAMAGETAG_PIERCING, ///&lt; Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 &lt; SP
-                DAMAGETAG_FIRE
-            };
-            /// The differente states a @ref abbdes &quot;SF&quot; can be in.
-             enum SfStatus
-            {
-                SFSTATUS_IN_TRAINING = 1,
-                SFSTATUS_OK,
-                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Werte
-
-            /**
-             *  Modifies the current @ref abbdel &quot;LE&quot; of the creature.
-             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
-             *  value).
-             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
-             **/
-            virtual void modifyLe(int mod, bool ignoreMax = false);
-            /**
-             *  Returns the current @ref abbdel &quot;LE&quot; of the creature.
-             **/
-            virtual int getLe() const;
-            /**
-             *  Returns the maximum @ref abbdel &quot;LE&quot; the creature can have.
-             **/
-            virtual int getLeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea &quot;AE&quot; der Kreatur.
-             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAe(int mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea &quot;AE&quot; der Kreatur zurueck.
-             **/
-            virtual int getAe() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAeMax() const;
-
-            /**
-             *  Veraendert die aktuelle @ref abbdea &quot;AU&quot; der Kreatur.
-             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
-             *   negativem Wert) werden soll
-             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
-             *   hinaus erhoeht werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyAu(float mod,  bool ignoreMax = false);
-            /**
-             *  Gibt die aktuelle @ref abbdea &quot;AU&quot; der Kreatur zurueck.
-             **/
-            virtual float getAu() const;
-            /**
-             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
-             **/
-            virtual int getAuMax() const;
-
-            /**
-             *  Berechnet den @ref abbdea &quot;AT&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getAttackeBasis() const;
-            /**
-             *  Berechnet den @ref abbdep &quot;PA&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getParadeBasis() const;
-            /**
-             *  Berechnet den @ref abbdef &quot;FK&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getFernkampfBasis() const;
-            /**
-             *  Berechnet den @ref abbdei &quot;INI&quot;-Basiswert der Kreatur.
-             **/
-            virtual int getInitiativeBasis() const;
-
-            /**
-             *  Setzt den Basiswert \a wertId auf \a value.
-             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
-             *  @param value Der neue wert des Basiswerts.
-             *  @see Wert
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual void setWert(Wert wertId, int value);
-            /**
-                   *  Liefert den Basiswert \a wertId zurueck.
-             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
-                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
-                   *   zurueckgegeben.
-             *  @return Der Wert des Basiswerts.
-             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
-             *    gefunden werden.
-             **/
-            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
-
-            /**
-             *  Gibt der Kreatur @ref abbddea &quot;AP&quot;.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyAp(int modifier);
-            /**
-             *  Liefert die Gesamtzahl der @ref abbdea &quot;AP&quot; zurueck.
-             **/
-            int getAp() const;
-            /**
-             *  Veraendert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
-             *  aufgerufen.
-             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
-             **/
-            void modifyUsedAp(int modifier);
-            /**
-             *  Liefert die verbrauchten @refabbdea &quot;AP&quot; zurueck.
-             **/
-            int getUsedAp() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Eigenschaften
-
-            /**
-             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @abbdef &quot;FF&quot;, etc.).
-             *  @return Der Wert der Eigenschaft.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
-            /**
-             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @ref abbdef &quot;FF&quot;, etc.).
-             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
-            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
-             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
-                   *   @ref abbdef &quot;FF&quot;, etc.).
-             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
-             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
-             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
-             *   Gross/Kleinschreibung beachtet?).
-                   *  @ingroup CreatureRubyExports
-             **/
-            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
-
-///////////////////////////////////////////////////////////////////////////////
-// Talente
-
-            /**
-                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
-             *  Das neue Talent wird mit @ref abbdet &quot;TaW&quot; 0 initialisiert.
-             *  @param talentName Bezeichnet das Talent.
-                   *  @param value Startwert des Talents.
-             *  @throws InvalidArgumentException Das Talent konnte nicht
-             *    gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            void addTalent(const CeGuiString talentName, int value = 0);
-            /**
-                   *  Liefert den Wert des Talents \a talentName zurueck.
-             *  @param talentName Bezeichnet das Talent.
-             *  @return @ref abbdet &quot;TaW&quot;
-                   *  @ingroup CreatureRubyExports
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-             */
-
-            /**
-                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
-              * @param talentName Bezeichnet das Talent
-              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
-            */
-            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
-
-            virtual int getTalent(const CeGuiString talentName) const;
-            /**
-                   *  Setzt den Wert des Talents \a talentName.
-             *  @param talentName Bezeichnet das zu veraendernde Talent.
-             *  @param value Der neue @ref abbdet TaW.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void setTalent(const CeGuiString talentName, int value);
-            /**
-                   *  Erhoeht das Talent \a talentName um \a mod.
-             *  @param talentName Bezeichnet das zu steigernde Talent.
-             *  @param mod Der Wert um den das Talent gesteigert werden soll.
-             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
-             *   nicht gefunden werden.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void modifyTalent(const CeGuiString talentName, int mod);
-            /**
-             * Liefert eine Liste mit allen Talenten und @ref abbdet &quot;TaW&quot;s zurueck.
-             * Dies wird auch der komplette Talentspiegel genannt.
-             **/
-            virtual const Creature::TalentMap&amp; getAllTalents() const;
-            /**
-                   *  Markiert ein Talent mit einer @ref abbdes &quot;SE&quot;. Siehe 
-                   *  Spezielle Erfahrungen, MFF 47.
-             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
-                   *  @ingroup CreatureRubyExports
-             */
-            virtual void addSe(const CeGuiString talentName);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampftechniken
-
-            /**
-             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
-             *  @param kampftechnikName Bezeichnet die Kampftechnik.
-             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
-             *  (0,0).
-             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
-                   *  @ingroup CreatureRubyExports
-             **/
-            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value = std::make_pair(0, 0));
-            /**
-                   *  Liefert die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer 
-                   *  bestimmten Kampftechnik zurueck.
-             *  @param kampftechnikName Beszeichnet die Kampftechnik.
-             *  @return Ein std::pair&lt;AT, PA&gt;.
-             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
-             *   \c mKampftechniken gefunden werden.
-             **/
-            virtual std::pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
-            /**
-                   *  Setzt die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer bestimmten 
-                   *  Kampftechnik.
-             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
-             *  @param value Die neuen AT/PA Werte.
-             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
-             *    konnte nicht in \c mKampftechniken gefunden werden.
-             **/
-            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value);
-
-///////////////////////////////////////////////////////////////////////////////
-// Kampfaktionen (Attacke, Parade, etc..)
-
-            void addKampfaktion(const CeGuiString&amp; kampfaktionName);
-            bool hasKampfaktion(const CeGuiString&amp; kampfaktionName) const;
-			const std::set&lt;CeGuiString&gt;&amp; getAllKampfaktionen() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Vorteile
-            /**
-             *  Fuegt einen Vorteil hinzu.
-             *  @param vorteilName Der Name des Vorteils.
-             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
-             *   Vorteils (z.B. Astrale Regeneration 3).
-             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
-             **/
-            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
-
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
-             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
-             **/
-            virtual bool hasVorteil(const CeGuiString vorteilName) const;
- 
-///////////////////////////////////////////////////////////////////////////////
-// Nachteile
-            /**
-             *  Fuegt einen Nachteil hinzu.
-             *  @param nachteilName Der Name des Nachteils.
-             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
-             *   die Stufe des Nachteils.
-             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
-             **/
-            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
-            /**
-             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
-             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
-             **/
-            virtual bool hasNachteil(const CeGuiString nachteilName) const;
-            /**
-             *  Liefert das StateSet des Nachteils zurueck.
-             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
-             *  abzufragen.
-             *  @param nachteilName Der Name der Schlechten Eigenschaft.
-             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
-             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
-             *   nicht gefunden werden.
-             **/
-            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Sonderfertigkeiten
-
-            /**
-                    *  Fuegt der Kreatur eine @ref abbdes &quot;SF&quot; hinzu.
-             *  @param sfName Bezeichnet die SF.
-                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
-             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
-             *    werden.
-                    *  @see SfStatus
-             */
-            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-            /**
-                   *  Liefert den Wert der @ref abbdes &quot;SF&quot; zurueck.
-             *  @param sfName Bezeichnet die SF
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual int getSf(const CeGuiString sfName) const;
-            /**
-                   *  Setzt den Wert der @ref abbdes &quot;SF&quot;.
-             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
-             *   werden soll.
-             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
-             *   soll.
-             *  @throws InvalidArgumentException \a sfName kann nicht in 
-             *   \c mSonderfertigkeiten gefunden werden.
-             *  @see SonderfertigkeitMap
-             */
-            virtual void setSf(const CeGuiString sfName, SfStatus value);
-
-            /**
-             *  Liefert einen Zeiger auf das StateSet der @ref abbdes &quot;SF&quot; zurueck.
-             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
-            *  @throws InvalidArgumentException \a sfName kann nicht in 
-            *   \c mSonderfertigkeiten gefunden werden.
-             *  @ingroup CreatureRubyExports
-             **/
-            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Status
-            /**
-             * Gets the status of a creature.
-             **/
-			Effect::LifeState getLifeState() const;
-
-
-            bool isMagic() const;
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Inventory
-
-
-            /**
-             *  Gibt das Inventar der Kreatur zurueck.
-             *  @return Liefert einen Zeiger auf Inventar der Kreatur
-             **/
-            Inventory* getInventory() const;
-
-        const Ogre::String&amp; getInventoryWindowType() const;
-
-///////////////////////////////////////////////////////////////////////////////
-// Aktionen
-            /**
-            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
-            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
-            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
-            *  die Angabe einer Spezialisierung.
-            *  @param talentName Bezeichnet das Talent
-            *  @param spezialisierungId Bezeichnet die Spezialisierung
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
-            *     gewuerfelt werden soll
-            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
-            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
-            *  @return uebrig gebliebene Talentpunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
-            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
-            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
-            */
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int,int)
-             *  This is the function that should be used in most cases.
-             **/
-            /**
-             *  @overload doTalentprobe(const CeGuiString,int);
-             *  This is the function you should usually use, if there is no fitting
-             *  specialization for the task.
-             *  @ingroup CreatureRubyExports
-             **/
-            /**
-             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
-             **/
-		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
-                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
-                                                 CeGuiString eigenschaft3Name);
-            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
-
-			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-                                      int modifier);
-            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
-
-            /**
-            *  Durchfuehren einer Eigenschaftsprobe.
-            *  @param eigenschaftName Bezeichnet die Eigenschaft
-            *  @param modifier Modifikator der Probe, dabei
-            *     ist ein positiver Wert eine Erschwernis,
-            *     ein negativer Wert eine Erleichterung.
-            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
-            *     negativer Wert bedeutet die Probe ist nicht bestanden.
-            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
-            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
-            *  @ingroup CreatureRubyExports
-            */
-			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-            /**
-            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Attacke ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Attacke.
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   mKampftechniken gefunden.
-            **/
-            int doAttacke(const CeGuiString kampftechnikName, int modifier);
-            /**
-            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-                  *  aufgerufen.
-            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
-            *   Parade ausgefuehrt wird.
-            *  @param modifier Erschwert oder erleichtert die Parade.
-            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-            *  @retval RESULT_GLUECKLICH Eine gute Parade.
-            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-            *  @throws InvalidArgumentException Kampftechnik nicht in 
-            *   \c mKampftechniken gefunden.
-            **/
-            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
-
-            /**
-             *  Fuehrt einen Initiativewurf durch.
-             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
-             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
-             *    'Orientieren'.
-             **/
-            int doInitiativeWurf(bool getMaxInitiative = false);
-
-			int doTrefferpunkteWurf(Weapon* weapon) const;
-
-            /**
-             *  Fuegt der Kreatur \a tp @ref abbdet &quot;Trefferpunkte&quot; zu.
-             *  @param tp die Trefferpunkte
-                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
-                   *   etc. korrekt zu beruecksichtigen.
-             **/
-            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-            static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
-
-            /**
-             *  Zieht der Kreatur \a asp @ref abbdea &quot;Astralpunkte&quot; ab.
-             *  @param aup die Trefferpunkte
-             **/
-            void damageAe(int asp);
-
-            /**
-            *  Zieht der Kreatur \a aup @ref abbdea &quot;Ausdauerpunkte&quot; ab.
-            *  @param aup die Trefferpunkte
-             *  @param damageType Typ des Schadens, um Resistenzen
-             *   etc. korrekt zu beruecksichtigen.
-            **/
-            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
-            static const int AUDAMAGE_NORMAL = 0;
-            static const int AUDAMAGE_HEAT = 1;
-            static const int AUDAMAGE_COLD = 2;
-            static const int AUDAMAGE_CHOKE = 4;
-            static const int AUDAMAGE_DROWN = 8;
-
-            /**
-             *  Regeneriert die @reg appdel &quot;LE&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateLe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea &quot;AE&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 6 stuendigen Ruhephase.
-             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
-             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
-             *   bei Sturm und Hagel...)
-             **/
-            void regenerateAe(int modifier = 0);
-            /**
-             *  Regeneriert die @reg appdea &quot;AU&quot; einer Kreatur, ueblicherweise nach
-             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
-             *  Parameter time aufgerufen werden.
-             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
-             *   selten eingesetzt werden.
-             *  @param time Sollte nur benutzt werden, falls es nicht m&#239;&#191;&#189;lich ist
-             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
-             **/
-            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
-
-
-            virtual const Property getProperty(const CeGuiString&amp; key) const;
-            virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-            virtual PropertyKeys getAllPropertyKeys() const;
-
-            void setAlignment(Alignment);
-            Alignment getAlignment() const;
-
-
-
-            /**
-             * Gibt an, ob die Creature mit den H&#195;&#164;nden an den Gegenstand herankommt,
-             * ihn also ber&#195;&#188;hren kann, mit ihm interagieren etc
-            **/
-            virtual bool canReachItem(const Item* item) const;
-
-            /**
-             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
-             * den CreatureController
-            **/
-            typedef std::pair&lt;Ogre::String, Ogre::Real&gt; AnimationSpeedPair;
-            /**
-             * Gibt die Animation aus der AnimationsMap f&#195;&#188;r den CreatureController zur&#195;&#188;ck
-             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
-             * der Schl&#195;&#188;sse name und eine Geschwindigkeit von 1 zurueckgegeben
-            **/
-            AnimationSpeedPair getAnimation(const CeGuiString&amp; name) const;
-
-        protected:
-           /**
-             *  Berechnet den Basiswert von der @ref abbdea &quot;Astralenergie&quot;.
-             **/
-            virtual int getAeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdea &quot;Ausdauer&quot;.
-             **/
-            virtual int getAuBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdel &quot;Lebensenergie&quot;.
-             **/
-            virtual int getLeBasis() const;
-            /**
-             *  Berechnet den Basiswert von der @ref abbdem &quot;Magieresistenz&quot;.
-             **/
-            virtual int getMrBasis() const;
-            /**
-             *  Liefert die derzeitge @ref abbdeb &quot;BE&quot; der Kreatur zurueck.
-             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
-             **/
-            virtual int getCurrentBe() const;
-
-            /// inherited from GameObject
-            virtual void doPlaceIntoScene();
-
-            /// inherited from GameObject
-            virtual void doRemoveFromScene();
-
-
-
-
-        private:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
-            /**
-             *  Liste der Werte.
-             *  @see Wert
-             **/
-            typedef std::map&lt;const Wert, int&gt; WertMap;
-            /**
-                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
-                   *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 
-                   *  und einem Zeiger auf ihr StateSet.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; EigenschaftMap;
-            /**
-             *  Liste der Kampftechniken und ihrer @ref abbdea &quot;AT&quot;/@ref abbdep &quot;PA2 Werte.
-             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
-             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
-                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
-             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
-             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
-             *  Kampftalent entsprechen.
-             **/
-            typedef std::map&lt;const CeGuiString, std::pair&lt;int, int&gt; &gt; KampftechnikMap;
-            /**
-             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
-             *  den Vorteilen, verhalten sich aber wie Talente.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; VorteilMap;
-            /**
-             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
-             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
-             **/
-            typedef std::map&lt;const CeGuiString, int&gt; NachteilMap;
-            /**
-                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
-                   *  Sonderfertigkeit als Schluessel und ihrem Status.
-             */
-            typedef std::map&lt;const CeGuiString , SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
-            /**
-                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
-                    * an.
-            **/
-            typedef std::map&lt;const CeGuiString, CeGuiString&gt; AnimationsMap;
-            /**
-                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
-                    * CreatureController bei einer Bewegung der Kreatur
-                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner, der von einer Bewegungsart des
-                    * CreatureControllers verwendet wird.
-            **/
-            typedef std::map&lt;const CeGuiString, Ogre::Real&gt; AnimationSpeedsMap;
-            struct Ap
-            {
-                int total;
-                int used;
-            };
-
-///////////////////////////////////////////////////////////////////////////////
-// Membervariablen
-            /// Die aktuelle @ref abbdel &quot;Lebensenergie&quot; der Kreatur.
-            int mCurrentLe;
-            /// Die aktuelle @ref abbdea &quot;Astralenergie&quot; der Kreatur.
-            int mCurrentAe;
-            /// Die aktuelle @ref abbdea &quot;Ausdauer&quot; der Kreatur.
-            float mCurrentAu;
-            /// Die aktuelle Erschoepfung der Kreatur.
-            int mErschoepfung;
-            /// Zuletzt zugewiesene Bewegungsart
-            int mMovementType;
-
-            /// Zeigt auf die gerade aktive Waffe.
-            EigenschaftMap mEigenschaften;
-            TalentMap mTalente;
-            KampftechnikMap mKampftechniken;
-			std::set&lt;CeGuiString&gt; mKampfaktionen;
-            VorteilMap mVorteile;
-            NachteilMap mNachteile;
-            SonderfertigkeitMap mSonderfertigkeiten;
-            WertMap mWerte;
-            AnimationsMap mAnimations;
-            AnimationSpeedsMap mAnimationSpeeds;
-            Ap mAp;
-            /// Zeigt auf das Inventar der Kreatur.
-            Inventory* mInventory;
-            Ogre::String mInventoryWindowType;
-
-            Property mAiProperties;
-
-            Alignment mAlignment;
-
-            /// this variable is only used in regenerateAu
-            float mTimeSinceLastRegeneration;
-            /// this variable is only used in regenerateAu (must be initialized with 3W6)
-            int mLastCalculatedAuToRegenerate;
-
-            /**
-             *  Sets a the status \a statusVariable. It uses a reference counting
-             *  System to do this, so if for example severeal effects put the creature
-             *  to sleep, and one effect ends the creature doesn't awake until all
-             *  the other effects end too. 
-             *  @param statusVariable is a reference to the status to be set, such as
-             *   \c mBlind.
-             *  @param value If true, the reference is increased, if false it is decreased.
-             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
-             *   than it was with \c true (i.e. the status is removed more often than
-             *   it was applied), \c setStatus throws an exception with \a errorMessage as
-             *   text.
-             *  @throw InvalidArgumentException see \a errorMessage.
-             **/
-            void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
-    };
-}
-#endif //__CREATURE_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __CREATURE_H__
+#define __CREATURE_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Date.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;Eigenschaft.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;ZauberStateSet.h&quot;
+#include &quot;SonderfertigkeitenStateSet.h&quot;
+
+namespace rl
+{
+    class Container;
+    class Inventory;
+    class Item;
+    class Weapon;
+
+///////////////////////////////////////////////////////////////////////////////
+// Konstanten
+
+    /**
+    *  Der minimale Wert mit dem Proben Spezialtalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_SPEZIAL = 0;
+    /**
+    *  Der minimale Wert mit dem Proben Berufstalente durchfuehrt werden
+    *  duerfen.
+    *  @note Es gibt da verschiedene Angaben zwischen dem Basisregelwerk 
+    *   und SuH.
+    **/
+    static const int TALENT_MIN_TAW_FOR_BERUF = 0;
+
+    /// Eine Doppel-1
+    static const int RESULT_AUTOERFOLG = 100;
+    /// Eine Dreifach-1
+    static const int RESULT_SPEKT_AUTOERFOLG = 1000;
+    /// Eine Doppel-20
+    static const int RESULT_AUTOMISSERFOLG = -100;
+    /// Eine Dreifach-20
+    static const int RESULT_SPEKT_AUTOMISSERFOLG = -1000;
+    /**
+     *  Eine bestaetigte 1 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
+     *  eine einfache 1 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_GLUECKLICH = 100;
+    /**
+     *  Eine bestaetigte 20 bei einer @ref abbdea &quot;AT&quot; oder @ref abbdep &quot;PA&quot;,
+     *  eine einfache 20 bei einer Eigenschaftsprobe.
+     **/
+    static const int RESULT_PATZER = -100;
+    /// Eine normal gelungene Attacke oder Parade
+    static const int RESULT_ERFOLG = 1;
+    /// Eine normal misslungene Attacke oder Parade
+    static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
+
+    /// Basistalente
+    /// @todo Passenderen Ort suchen
+    static const CeGuiString TALENT_ART_BASIS = &quot;Basis&quot;;
+    /// Spezialtalente
+    static const CeGuiString TALENT_ART_SPEZIAL = &quot;Spezial&quot;;
+    /// Berufstalente
+    static const CeGuiString TALENT_ART_BERUF = &quot;Beruf&quot;;
+
+    /**
+     *  @defgroup CreatureRubyExports Creature
+     *  @ingroup RulesRubyExports
+     **/
+
+    /**
+    * Basisklasse aller spielrelevanten Objekte in RL. Die Klasse kapselt alle 
+    * Wesen, die aktiv im Spiel agieren, sei es computer- oder spielergesteuert. 
+    * Klasse enthaelt Methoden und Daten fuer die DSA-Spielwerte (Lebensenergie,
+    * Eigenschaften) und Methoden fuer alles was fuer die Interaktion mit der 
+    * Spielwelt noetig ist (z.B. Proben).
+    */
+    class _RlRulesExport Creature : public GameObject
+    {
+        public:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  List of all talents. Consists of the (german) name of the talent
+             *  (e.g. &quot;Athletik&quot;) as key and its value (TaW)
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; TalentMap;
+
+            static const Ogre::String CLASS_NAME;
+            static const Ogre::String PROPERTY_AI;
+            static const Ogre::String PROPERTY_AI_BEHAVIOURS;
+			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+            static const Ogre::String PROPERTY_CURRENT_LE;
+            static const Ogre::String PROPERTY_CURRENT_AE;
+            static const Ogre::String PROPERTY_CURRENT_AU;
+            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
+            static const Ogre::String PROPERTY_EFFECTS;
+            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
+            static const Ogre::String PROPERTY_TALENTE;
+            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
+            static const Ogre::String PROPERTY_KAMPFAKTIONEN;
+            static const Ogre::String PROPERTY_VORTEILE;
+            static const Ogre::String PROPERTY_NACHTEILE;
+            static const Ogre::String PROPERTY_SF;
+            static const Ogre::String PROPERTY_WERTE;
+            static const Ogre::String PROPERTY_AP;
+            static const Ogre::String PROPERTY_INVENTORY;
+            static const Ogre::String PROPERTY_ANIMATIONS;
+            static const Ogre::String PROPERTY_ANIMATIONSPEEDS;
+
+            typedef Ogre::String Wert;
+
+            // some targets
+			static const std::string ALL_EIGENSCHAFTEN;
+			static const std::string ALL_TALENTE;
+
+            static const Wert WERT_MOD_AE;
+            static const Wert WERT_MOD_LE;
+            static const Wert WERT_MOD_AU;
+            static const Wert WERT_MOD_MR;
+            static const Wert WERT_MOD_AT;
+            static const Wert WERT_MOD_PA;
+            static const Wert WERT_MOD_FK;
+            static const Wert WERT_GS;
+            static const Wert WERT_SOZIALSTATUS;
+            static const Wert WERT_BE;
+            static const Wert WERT_RS;
+            static const Wert WERT_INI;
+            static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
+            static const Wert WERT_REGENERATION;
+    			
+			Creature(unsigned int id);
+
+            /// Der Standarddestruktor.
+            virtual ~Creature();
+
+///////////////////////////////////////////////////////////////////////////////
+// Enums
+            /// Alignment of a Creature towards the player. This determines
+            /// whether a combat is entered.
+            enum Alignment
+            {
+                ALIGNMENT_ALLY    = 1, ///&lt; Creature fights with the player.
+                ALIGNMENT_NEUTRAL = 2, ///&lt; Creature doesn't fight for either side.
+                ALIGNMENT_ENEMY   = 4  ///&lt; Creature fights against the player.
+            };
+
+            /// Determines the damage type
+            enum DamageTag
+            {
+                DAMAGETAG_NORMAL = 1,
+                DAMAGETAG_PIERCING, ///&lt; Wie Pfeile, Bolzen oder gezielte Stiche, verletzen schon bei KO/2 &lt; SP
+                DAMAGETAG_FIRE
+            };
+            /// The differente states a @ref abbdes &quot;SF&quot; can be in.
+             enum SfStatus
+            {
+                SFSTATUS_IN_TRAINING = 1,
+                SFSTATUS_OK,
+                SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Is this even needed?
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Werte
+
+            /**
+             *  Modifies the current @ref abbdel &quot;LE&quot; of the creature.
+             *  @param mod The value to be added to the LE (so to lower the LE, pass a negative 
+             *  value).
+             *  @param ignoreMax If ture, the LE can be increased beayond the maximum.
+             **/
+            virtual void modifyLe(int mod, bool ignoreMax = false);
+            /**
+             *  Returns the current @ref abbdel &quot;LE&quot; of the creature.
+             **/
+            virtual int getLe() const;
+            /**
+             *  Returns the maximum @ref abbdel &quot;LE&quot; the creature can have.
+             **/
+            virtual int getLeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea &quot;AE&quot; der Kreatur.
+             *  @param mod Der Wert um den die AE erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AE auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAe(int mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea &quot;AE&quot; der Kreatur zurueck.
+             **/
+            virtual int getAe() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAeMax() const;
+
+            /**
+             *  Veraendert die aktuelle @ref abbdea &quot;AU&quot; der Kreatur.
+             *  @param mod Der Wert um den die AU erhoeht (erniedrigt bei 
+             *   negativem Wert) werden soll
+             *  @param ignoreMax Wenn true kann die AU auch ueber das Maximum
+             *   hinaus erhoeht werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyAu(float mod,  bool ignoreMax = false);
+            /**
+             *  Gibt die aktuelle @ref abbdea &quot;AU&quot; der Kreatur zurueck.
+             **/
+            virtual float getAu() const;
+            /**
+             *  Gibt die maximale Anzahl an @ref abbdea &quot;AE&quot; zurueck, die die Kreatur haben kann.
+             **/
+            virtual int getAuMax() const;
+
+            /**
+             *  Berechnet den @ref abbdea &quot;AT&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getAttackeBasis() const;
+            /**
+             *  Berechnet den @ref abbdep &quot;PA&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getParadeBasis() const;
+            /**
+             *  Berechnet den @ref abbdef &quot;FK&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getFernkampfBasis() const;
+            /**
+             *  Berechnet den @ref abbdei &quot;INI&quot;-Basiswert der Kreatur.
+             **/
+            virtual int getInitiativeBasis() const;
+
+            /**
+             *  Setzt den Basiswert \a wertId auf \a value.
+             *  @param wertId Bezeichnet welcher Basiswert veraendert werden soll.
+             *  @param value Der neue wert des Basiswerts.
+             *  @see Wert
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual void setWert(Wert wertId, int value);
+            /**
+                   *  Liefert den Basiswert \a wertId zurueck.
+             *  @param wertId Bezeichnet welcher Basiswert zurueckgeliefert werden soll.
+                   *  @param getUnmodified Wenn true wird der unmodifizierte Wert 
+                   *   zurueckgegeben.
+             *  @return Der Wert des Basiswerts.
+             *  @throws InvalidArgumentException wertId konnte in mWerte nicht
+             *    gefunden werden.
+             **/
+            virtual int getWert(Wert wertId, bool getUnmodified = false) const;
+
+            /**
+             *  Gibt der Kreatur @ref abbddea &quot;AP&quot;.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyAp(int modifier);
+            /**
+             *  Liefert die Gesamtzahl der @ref abbdea &quot;AP&quot; zurueck.
+             **/
+            int getAp() const;
+            /**
+             *  Veraendert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
+             *  aufgerufen.
+             *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
+             **/
+            void modifyUsedAp(int modifier);
+            /**
+             *  Liefert die verbrauchten @refabbdea &quot;AP&quot; zurueck.
+             **/
+            int getUsedAp() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Eigenschaften
+
+            /**
+             *  Liefert den Wert der Eigenschaft \a eigenschaftName zurueck.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @abbdef &quot;FF&quot;, etc.).
+             *  @return Der Wert der Eigenschaft.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+			virtual int getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE) const;
+            /**
+             *  Setzt den Wert der Eigenschaft \a eigenschaftName auf \a value.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @ref abbdef &quot;FF&quot;, etc.).
+             *  @param value Der Wert auf den die Eigenschaft gesetzt werden soll.
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void setEigenschaft(const CeGuiString eigenschaftName, int value);
+            /** Addiert \a mod auf den Wert der Eigenschaft \a eigenschaftName.
+             *  @param eigenschaftName Der Name als Abkuerzung (z.B. @ref abbdem &quot;MU&quot;, 
+                   *   @ref abbdef &quot;FF&quot;, etc.).
+             *  @param mod Wird auf den Wert addiert (kann auch negativ sein).
+             *  @throws InvalidArgumentException Die Eigenschaft konnte nicht
+             *   gefunden werden (Name ausgeschrieben statt abgekuerzt? 
+             *   Gross/Kleinschreibung beachtet?).
+                   *  @ingroup CreatureRubyExports
+             **/
+            virtual void modifyEigenschaft(const CeGuiString eigenschaftName, int mod);
+
+///////////////////////////////////////////////////////////////////////////////
+// Talente
+
+            /**
+                   *  Fuegt das Talent \a talentName zu \c mTalente hinzu.
+             *  Das neue Talent wird mit @ref abbdet &quot;TaW&quot; 0 initialisiert.
+             *  @param talentName Bezeichnet das Talent.
+                   *  @param value Startwert des Talents.
+             *  @throws InvalidArgumentException Das Talent konnte nicht
+             *    gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            void addTalent(const CeGuiString talentName, int value = 0);
+            /**
+                   *  Liefert den Wert des Talents \a talentName zurueck.
+             *  @param talentName Bezeichnet das Talent.
+             *  @return @ref abbdet &quot;TaW&quot;
+                   *  @ingroup CreatureRubyExports
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+             */
+
+            /**
+                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
+              * @param talentName Bezeichnet das Talent
+              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
+            */
+            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true) const;
+
+            virtual int getTalent(const CeGuiString talentName) const;
+            /**
+                   *  Setzt den Wert des Talents \a talentName.
+             *  @param talentName Bezeichnet das zu veraendernde Talent.
+             *  @param value Der neue @ref abbdet TaW.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void setTalent(const CeGuiString talentName, int value);
+            /**
+                   *  Erhoeht das Talent \a talentName um \a mod.
+             *  @param talentName Bezeichnet das zu steigernde Talent.
+             *  @param mod Der Wert um den das Talent gesteigert werden soll.
+             *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
+             *   nicht gefunden werden.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void modifyTalent(const CeGuiString talentName, int mod);
+            /**
+             * Liefert eine Liste mit allen Talenten und @ref abbdet &quot;TaW&quot;s zurueck.
+             * Dies wird auch der komplette Talentspiegel genannt.
+             **/
+            virtual const Creature::TalentMap&amp; getAllTalents() const;
+            /**
+                   *  Markiert ein Talent mit einer @ref abbdes &quot;SE&quot;. Siehe 
+                   *  Spezielle Erfahrungen, MFF 47.
+             *  @param talentName Bezeichnet das Talent in dem die SE erhalten wurde.
+                   *  @ingroup CreatureRubyExports
+             */
+            virtual void addSe(const CeGuiString talentName);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampftechniken
+
+            /**
+             *  Fuegt eine neue Kampftechnik zu \c mKampftechniken hinzu.
+             *  @param kampftechnikName Bezeichnet die Kampftechnik.
+             *  @param value Initialisiert die Kampftechnik mit value. Standard ist
+             *  (0,0).
+             *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
+                   *  @ingroup CreatureRubyExports
+             **/
+            void addKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value = std::make_pair(0, 0));
+            /**
+                   *  Liefert die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer 
+                   *  bestimmten Kampftechnik zurueck.
+             *  @param kampftechnikName Beszeichnet die Kampftechnik.
+             *  @return Ein std::pair&lt;AT, PA&gt;.
+             *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
+             *   \c mKampftechniken gefunden werden.
+             **/
+            virtual std::pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
+            /**
+                   *  Setzt die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer bestimmten 
+                   *  Kampftechnik.
+             *  @param kampftechnikName Bestimmt die zu setzende Kampftechnik.
+             *  @param value Die neuen AT/PA Werte.
+             *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
+             *    konnte nicht in \c mKampftechniken gefunden werden.
+             **/
+            virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value);
+
+///////////////////////////////////////////////////////////////////////////////
+// Kampfaktionen (Attacke, Parade, etc..)
+
+            void addKampfaktion(const CeGuiString&amp; kampfaktionName);
+            bool hasKampfaktion(const CeGuiString&amp; kampfaktionName) const;
+			const std::set&lt;CeGuiString&gt;&amp; getAllKampfaktionen() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Vorteile
+            /**
+             *  Fuegt einen Vorteil hinzu.
+             *  @param vorteilName Der Name des Vorteils.
+             *  @param value Der Wert einer eventuellen Gabe oder die Stufe des
+             *   Vorteils (z.B. Astrale Regeneration 3).
+             *  @throws InvalidArgumentException Vorteil schon in \c mVorteile enthalten.
+             **/
+            virtual void addVorteil(const CeGuiString vorteilName, int value = 0);
+
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Vorteil hat.
+             *  @param vorteilName Der Name des zu ueberpruefenden Vorteils.
+             **/
+            virtual bool hasVorteil(const CeGuiString vorteilName) const;
+ 
+///////////////////////////////////////////////////////////////////////////////
+// Nachteile
+            /**
+             *  Fuegt einen Nachteil hinzu.
+             *  @param nachteilName Der Name des Nachteils.
+             *  @param value Der Wert einer eventuellen Schlechten Eigenschaft oder
+             *   die Stufe des Nachteils.
+             *  @throws InvalidArgumentException Nachteil schon in \c mNachteile enthalten.
+             **/
+            virtual void addNachteil(const CeGuiString nachteilName, int value = 0);
+            /**
+             *  Ueberprueft ob die Kreatur einen bestimmten Nachteil hat.
+             *  @param nachteilName Der Name des zu ueberpruefenden Nachteils.
+             **/
+            virtual bool hasNachteil(const CeGuiString nachteilName) const;
+            /**
+             *  Liefert das StateSet des Nachteils zurueck.
+             *  Gedacht um die erforderlichen Daten von Schlechten Eigenschaften
+             *  abzufragen.
+             *  @param nachteilName Der Name der Schlechten Eigenschaft.
+             *  @return Ein Zeiger auf das StateSet der Schlechten Eigenschaft.
+             *  @throws InvalidArgumentException Der Nachteil \a nachteilName konnte
+             *   nicht gefunden werden.
+             **/
+            virtual int getSchlechteEigenschaft(const CeGuiString nachteilName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Sonderfertigkeiten
+
+            /**
+                    *  Fuegt der Kreatur eine @ref abbdes &quot;SF&quot; hinzu.
+             *  @param sfName Bezeichnet die SF.
+                    *  @param value Der Status der SF. Standardmaessig SFSTATUS_IN_TRAINING.
+             *  @throws InvalidArgumentException \a sfName kann nicht gefunden
+             *    werden.
+                    *  @see SfStatus
+             */
+            virtual void addSf(const CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+            /**
+                   *  Liefert den Wert der @ref abbdes &quot;SF&quot; zurueck.
+             *  @param sfName Bezeichnet die SF
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual int getSf(const CeGuiString sfName) const;
+            /**
+                   *  Setzt den Wert der @ref abbdes &quot;SF&quot;.
+             *  @param sfName Bezeichnet die Sonderfertigkeit deren Wert gesetzt
+             *   werden soll.
+             *  @param value Der Wert auf den die Sonderfertigkeit gesetzt werden 
+             *   soll.
+             *  @throws InvalidArgumentException \a sfName kann nicht in 
+             *   \c mSonderfertigkeiten gefunden werden.
+             *  @see SonderfertigkeitMap
+             */
+            virtual void setSf(const CeGuiString sfName, SfStatus value);
+
+            /**
+             *  Liefert einen Zeiger auf das StateSet der @ref abbdes &quot;SF&quot; zurueck.
+             *  @param sfName Bezeichnet die SF deren StateSet zurueckgelifert werden soll.
+            *  @throws InvalidArgumentException \a sfName kann nicht in 
+            *   \c mSonderfertigkeiten gefunden werden.
+             *  @ingroup CreatureRubyExports
+             **/
+            virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const CeGuiString sfName) const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Status
+            /**
+             * Gets the status of a creature.
+             **/
+			Effect::LifeState getLifeState() const;
+
+
+            bool isMagic() const;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Inventory
+
+
+            /**
+             *  Gibt das Inventar der Kreatur zurueck.
+             *  @return Liefert einen Zeiger auf Inventar der Kreatur
+             **/
+            Inventory* getInventory() const;
+
+        const Ogre::String&amp; getInventoryWindowType() const;
+
+///////////////////////////////////////////////////////////////////////////////
+// Aktionen
+            /**
+            *  Durchfuehren einer Talentprobe mit alternativen Eigenschaften.
+            *  Siehe dazu auch MFF S.14. Wird nur der Korrektheit halber angeboten,
+            *  sollte eher selten eingesetzt werden. Diese Talentprobe erlaubt auch
+            *  die Angabe einer Spezialisierung.
+            *  @param talentName Bezeichnet das Talent
+            *  @param spezialisierungId Bezeichnet die Spezialisierung
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @param eigenschaft1Name Bezeichnet die erste Eigenschaft auf die 
+            *     gewuerfelt werden soll
+            *  @param eigenschaft2Name Bezeichnet die zweite Eigenschaft
+            *  @param eigenschaft3Name Bezeichnet die dritte Eigenschaft
+            *  @return uebrig gebliebene Talentpunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval   RESULT_AUTOERFOLG bedeutet 2*1 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOERFOLG bedeutet 3*1 gewuerfelt.
+            *  @retval   RESULT_AUTOMISSERFOLG bedeutet 2*20 gewuerfelt.
+            *  @retval   RESULT_SPEKT_AUTOMISSERFOLG bedeutet 3*20 gewuerfelt.
+            */
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int,int)
+             *  This is the function that should be used in most cases.
+             **/
+            /**
+             *  @overload doTalentprobe(const CeGuiString,int);
+             *  This is the function you should usually use, if there is no fitting
+             *  specialization for the task.
+             *  @ingroup CreatureRubyExports
+             **/
+            /**
+             *  @overload doAlternativeTalentprobe(const CeGuiString,int,CeGuiString,CeGuiString,CeGuiString)
+             **/
+		virtual int doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag  spezialisierung,
+                                                 int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name,
+                                                 CeGuiString eigenschaft3Name);
+            virtual int doTalentprobe(const CeGuiString talentName, int modifier);
+
+			virtual int doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+                                      int modifier);
+            virtual int doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+                                                 CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name);
+
+            /**
+            *  Durchfuehren einer Eigenschaftsprobe.
+            *  @param eigenschaftName Bezeichnet die Eigenschaft
+            *  @param modifier Modifikator der Probe, dabei
+            *     ist ein positiver Wert eine Erschwernis,
+            *     ein negativer Wert eine Erleichterung.
+            *  @return Uebrig gebliebene Eigenschaftspunkte, ein
+            *     negativer Wert bedeutet die Probe ist nicht bestanden.
+            *  @retval RESULT_GLUECKLICH bedeutet 1 gewuerfelt.
+            *  @retval RESULT_PATZER bedeutet 20 gewuerfelt.
+            *  @ingroup CreatureRubyExports
+            */
+			virtual int doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier = 0, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+            /**
+            *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Attacke ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Attacke.
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+            *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+            *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   mKampftechniken gefunden.
+            **/
+            int doAttacke(const CeGuiString kampftechnikName, int modifier);
+            /**
+            *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+                  *  aufgerufen.
+            *  @param kampftechnikName Bezeichnet die Kampftechnik in dem die 
+            *   Parade ausgefuehrt wird.
+            *  @param modifier Erschwert oder erleichtert die Parade.
+            *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+            *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+            *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+            *  @retval RESULT_GLUECKLICH Eine gute Parade.
+            *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+            *  @throws InvalidArgumentException Kampftechnik nicht in 
+            *   \c mKampftechniken gefunden.
+            **/
+            int doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade = false);
+
+            /**
+             *  Fuehrt einen Initiativewurf durch.
+             *  @param getMaxInitiative Wenn true wird ein Wert zurueckgeliefert,
+             *    als ob eine 6 gewuerfelt worden waere, z.B. fuer das Manoever
+             *    'Orientieren'.
+             **/
+            int doInitiativeWurf(bool getMaxInitiative = false);
+
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
+
+            /**
+             *  Fuegt der Kreatur \a tp @ref abbdet &quot;Trefferpunkte&quot; zu.
+             *  @param tp die Trefferpunkte
+                   *  @param damageType Typ des Schadens, um Immunitaeten, Verletzlichkeiten
+                   *   etc. korrekt zu beruecksichtigen.
+             **/
+            void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+            static const int LEDAMAGE_NORMAL = 0;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
+
+            /**
+             *  Zieht der Kreatur \a asp @ref abbdea &quot;Astralpunkte&quot; ab.
+             *  @param aup die Trefferpunkte
+             **/
+            void damageAe(int asp);
+
+            /**
+            *  Zieht der Kreatur \a aup @ref abbdea &quot;Ausdauerpunkte&quot; ab.
+            *  @param aup die Trefferpunkte
+             *  @param damageType Typ des Schadens, um Resistenzen
+             *   etc. korrekt zu beruecksichtigen.
+            **/
+            void damageAu(float aup, int damageType = AUDAMAGE_NORMAL);
+            static const int AUDAMAGE_NORMAL = 0;
+            static const int AUDAMAGE_HEAT = 1;
+            static const int AUDAMAGE_COLD = 2;
+            static const int AUDAMAGE_CHOKE = 4;
+            static const int AUDAMAGE_DROWN = 8;
+
+            /**
+             *  Regeneriert die @reg appdel &quot;LE&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateLe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea &quot;AE&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 6 stuendigen Ruhephase.
+             *  @param modifier Ein situationsabhaengiger Modifikator, vor allem
+             *   abhaengig von der Qualitaet der Unterbringung (1-A Hotel vs. draussen
+             *   bei Sturm und Hagel...)
+             **/
+            void regenerateAe(int modifier = 0);
+            /**
+             *  Regeneriert die @reg appdea &quot;AU&quot; einer Kreatur, ueblicherweise nach
+             *  einer mind. 5 minuetigen Ruhephase. Andernfalls kann die Funktion mit dem
+             *  Parameter time aufgerufen werden.
+             *  @param modifier Ein situationsabhaengiger Modifikator, sollte eher
+             *   selten eingesetzt werden.
+             *  @param time Sollte nur benutzt werden, falls es nicht m&#239;&#191;&#189;lich ist
+             *   die Funktion wirklich nur alle 5 Minuten aufzurufen
+             **/
+            void regenerateAu(int modifier = 0, float factor = 1, float time = Date::ONE_SPIELRUNDE);
+
+
+            virtual const Property getProperty(const CeGuiString&amp; key) const;
+            virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+            virtual PropertyKeys getAllPropertyKeys() const;
+
+            void setAlignment(Alignment);
+            Alignment getAlignment() const;
+
+
+
+            /**
+             * Gibt an, ob die Creature mit den H&#195;&#164;nden an den Gegenstand herankommt,
+             * ihn also ber&#195;&#188;hren kann, mit ihm interagieren etc
+            **/
+            virtual bool canReachItem(const Item* item) const;
+
+            /**
+             * Animations-Name und relative/absolute Abspielgeschwindigkeit fuer
+             * den CreatureController
+            **/
+            typedef std::pair&lt;Ogre::String, Ogre::Real&gt; AnimationSpeedPair;
+            /**
+             * Gibt die Animation aus der AnimationsMap f&#195;&#188;r den CreatureController zur&#195;&#188;ck
+             * @return Wenn kein spezieller Wert gefunden wurde, wird als Animationsname
+             * der Schl&#195;&#188;sse name und eine Geschwindigkeit von 1 zurueckgegeben
+            **/
+            AnimationSpeedPair getAnimation(const CeGuiString&amp; name) const;
+
+        protected:
+           /**
+             *  Berechnet den Basiswert von der @ref abbdea &quot;Astralenergie&quot;.
+             **/
+            virtual int getAeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdea &quot;Ausdauer&quot;.
+             **/
+            virtual int getAuBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdel &quot;Lebensenergie&quot;.
+             **/
+            virtual int getLeBasis() const;
+            /**
+             *  Berechnet den Basiswert von der @ref abbdem &quot;Magieresistenz&quot;.
+             **/
+            virtual int getMrBasis() const;
+            /**
+             *  Liefert die derzeitge @ref abbdeb &quot;BE&quot; der Kreatur zurueck.
+             *  Eventuelle Ruestungsgewoehnung schon beruecksichtigt
+             **/
+            virtual int getCurrentBe() const;
+
+            /// inherited from GameObject
+            virtual void doPlaceIntoScene();
+
+            /// inherited from GameObject
+            virtual void doRemoveFromScene();
+
+
+
+
+        private:
+///////////////////////////////////////////////////////////////////////////////
+// Typedefs
+            /**
+             *  Liste der Werte.
+             *  @see Wert
+             **/
+            typedef std::map&lt;const Wert, int&gt; WertMap;
+            /**
+                   *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
+                   *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 
+                   *  und einem Zeiger auf ihr StateSet.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; EigenschaftMap;
+            /**
+             *  Liste der Kampftechniken und ihrer @ref abbdea &quot;AT&quot;/@ref abbdep &quot;PA2 Werte.
+             *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
+             *  oder Raufen, bei Tieren sowas wie Biss oder Prankenhieb. Der erste 
+                   *  Wert ist der Name der Kampftechnik, das pair den AT und PA Werten.
+             *  Die Werte werden auf den AT/PA Basiswert addiert bevor sie die fertige
+             *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
+             *  Kampftalent entsprechen.
+             **/
+            typedef std::map&lt;const CeGuiString, std::pair&lt;int, int&gt; &gt; KampftechnikMap;
+            /**
+             *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
+             *  den Vorteilen, verhalten sich aber wie Talente.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; VorteilMap;
+            /**
+             *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
+             *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
+             **/
+            typedef std::map&lt;const CeGuiString, int&gt; NachteilMap;
+            /**
+                   *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
+                   *  Sonderfertigkeit als Schluessel und ihrem Status.
+             */
+            typedef std::map&lt;const CeGuiString , SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
+            /**
+                    * Die Animationen, die der CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird, der Wert gibt den echten Namen der Animation
+                    * an.
+            **/
+            typedef std::map&lt;const CeGuiString, CeGuiString&gt; AnimationsMap;
+            /**
+                    * Die (relative oder absolute) Geschwindigkeit einer Animationen, die der
+                    * CreatureController bei einer Bewegung der Kreatur
+                    * abspielt. Der Schl&#195;&#188;ssel ist Bezeichner, der von einer Bewegungsart des
+                    * CreatureControllers verwendet wird.
+            **/
+            typedef std::map&lt;const CeGuiString, Ogre::Real&gt; AnimationSpeedsMap;
+            struct Ap
+            {
+                int total;
+                int used;
+            };
+
+///////////////////////////////////////////////////////////////////////////////
+// Membervariablen
+            /// Die aktuelle @ref abbdel &quot;Lebensenergie&quot; der Kreatur.
+            int mCurrentLe;
+            /// Die aktuelle @ref abbdea &quot;Astralenergie&quot; der Kreatur.
+            int mCurrentAe;
+            /// Die aktuelle @ref abbdea &quot;Ausdauer&quot; der Kreatur.
+            float mCurrentAu;
+            /// Die aktuelle Erschoepfung der Kreatur.
+            int mErschoepfung;
+            /// Zuletzt zugewiesene Bewegungsart
+            int mMovementType;
+
+            /// Zeigt auf die gerade aktive Waffe.
+            EigenschaftMap mEigenschaften;
+            TalentMap mTalente;
+            KampftechnikMap mKampftechniken;
+			std::set&lt;CeGuiString&gt; mKampfaktionen;
+            VorteilMap mVorteile;
+            NachteilMap mNachteile;
+            SonderfertigkeitMap mSonderfertigkeiten;
+            WertMap mWerte;
+            AnimationsMap mAnimations;
+            AnimationSpeedsMap mAnimationSpeeds;
+            Ap mAp;
+            /// Zeigt auf das Inventar der Kreatur.
+            Inventory* mInventory;
+            Ogre::String mInventoryWindowType;
+
+            Property mAiProperties;
+
+            Alignment mAlignment;
+
+            /// this variable is only used in regenerateAu
+            float mTimeSinceLastRegeneration;
+            /// this variable is only used in regenerateAu (must be initialized with 3W6)
+            int mLastCalculatedAuToRegenerate;
+
+            /**
+             *  Sets a the status \a statusVariable. It uses a reference counting
+             *  System to do this, so if for example severeal effects put the creature
+             *  to sleep, and one effect ends the creature doesn't awake until all
+             *  the other effects end too. 
+             *  @param statusVariable is a reference to the status to be set, such as
+             *   \c mBlind.
+             *  @param value If true, the reference is increased, if false it is decreased.
+             *  @param errorMessage If \c setStatus is called with \a value = \c false more often
+             *   than it was with \c true (i.e. the status is removed more often than
+             *   it was applied), \c setStatus throws an exception with \a errorMessage as
+             *   text.
+             *  @throw InvalidArgumentException see \a errorMessage.
+             **/
+            void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
+    };
+}
+#endif //__CREATURE_H__

Modified: rl/trunk/engine/rules/include/Weapon.h
===================================================================
--- rl/trunk/engine/rules/include/Weapon.h	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/include/Weapon.h	2008-12-01 21:18:53 UTC (rev 4623)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (unsigned int id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString&amp; getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/trunk/engine/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/ApplyDamageJob.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/ApplyDamageJob.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,41 +1,42 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot;
-#include &quot;ApplyDamageJob.h&quot;
-
-#include &quot;Creature.h&quot;
-
-namespace rl 
-{
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
-:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
-    mTarget(target), 
-    mTp(tp)
-{
-}
-
-ApplyDamageJob::~ApplyDamageJob()
-{
-}
-
-bool ApplyDamageJob::execute(Ogre::Real time)
-{
-    mTarget-&gt;damageLe(mTp);
-    return true;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot;
+#include &quot;ApplyDamageJob.h&quot;
+
+#include &quot;Creature.h&quot;
+
+namespace rl 
+{
+
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
+:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
+    mTarget(target), 
+    mDamage(damage),
+    mType(damageType)
+{
+}
+
+ApplyDamageJob::~ApplyDamageJob()
+{
+}
+
+bool ApplyDamageJob::execute(Ogre::Real time)
+{
+    mTarget-&gt;damageLe(mDamage, mType);
+    return true;
+}
+
+} // namespace rl

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Combat.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft nach &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft nach &quot;
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant-&gt;doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft zu &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft zu &quot;
 							    + entry.target-&gt;getName(), GET_COMBAT);
 						    combatant-&gt;doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor-&gt;getName() + &quot; attackiert &quot; + target-&gt;getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor-&gt;rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult &gt;= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent(&quot;Erfolg, aber pariert.&quot;, GET_COMBAT);
-                        if (target-&gt;getActiveWeapon()-&gt;isNatural())
+                        if (target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; !actor-&gt;getActiveWeapon()-&gt;isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; actor-&gt;getActiveWeapon()-&gt;isNatural())
+                        {
+                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target-&gt;getActiveWeapon()-&gt;isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target-&gt;doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetDamage, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor-&gt;rollTrefferpunkte();
-            jobSetAnims-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp));
-
-			CeGuiString msg = actor-&gt;getName() + &quot; trifft f&#252;r &quot;
+			int tp = actor-&gt;rollTrefferpunkte(damageStrength);
+            jobSet-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor-&gt;getName() + &quot; trifft fuer &quot;
             + CeGuiString(StringConverter::toString(tp))
             + &quot; Trefferpunkte&quot;;
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature-&gt;getName() + &quot; ist jetzt &quot;;
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += &quot;kampfunf&#228;hig.&quot;;
+						msg += &quot;kampfunf&#226;&#128;&#176;hig.&quot;;
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/trunk/engine/rules/src/Combatant.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combatant.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Combatant.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -85,9 +85,9 @@
 		return getCreature()-&gt;doParade(weapon-&gt;getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Creature.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -1,1304 +1,1314 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Creature.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;Eigenschaft.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;EffectManager.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Kampftechnik.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;StateSet.h&quot;
-#include &quot;Slot.h&quot;
-#include &quot;Talent.h&quot;
-#include &quot;Weapon.h&quot;
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
-
-    const Ogre::String Creature::PROPERTY_AI = &quot;ai&quot;;
-    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = &quot;behaviours&quot;;
-    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_LE = &quot;current_le&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_AE = &quot;current_ae&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_AU = &quot;current_au&quot;;
-    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = &quot;current_fatigue&quot;;
-    const Ogre::String Creature::PROPERTY_EFFECTS = &quot;effects&quot;;
-    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = &quot;eigenschaften&quot;;
-    const Ogre::String Creature::PROPERTY_TALENTE = &quot;talente&quot;;
-    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = &quot;kampftechniken&quot;;
-    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = &quot;kampfaktionen&quot;;
-    const Ogre::String Creature::PROPERTY_VORTEILE = &quot;vorteile&quot;;
-    const Ogre::String Creature::PROPERTY_NACHTEILE = &quot;nachteile&quot;;
-    const Ogre::String Creature::PROPERTY_SF = &quot;sonderfertigkeiten&quot;;
-    const Ogre::String Creature::PROPERTY_WERTE = &quot;werte&quot;;
-    const Ogre::String Creature::PROPERTY_AP = &quot;ap&quot;;
-    const Ogre::String Creature::PROPERTY_INVENTORY = &quot;inventory&quot;;
-    const Ogre::String Creature::PROPERTY_ANIMATIONS = &quot;animations&quot;;
-    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = &quot;animationspeeds&quot;;
-
-    // some targets
-	const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-	const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
-	const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
-    const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
-    const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
-    const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
-    const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
-    const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
-    const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
-    const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
-    const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
-    const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
-    const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
-    const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
-    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;;
-    const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
-
-
-
-    Creature::Creature(unsigned int id)
-        : GameObject(id),
-		mCurrentLe(0),
-        mCurrentAu(0),
-        mCurrentAe(0),
-		mInventory(NULL),
-		mEigenschaften(),
-		mWerte(),
-		mTalente(),
-        mKampftechniken(),
-		mKampfaktionen(),
-        mSonderfertigkeiten(),
-        mErschoepfung(0),
-        mMovementType(0),
-        mAlignment(ALIGNMENT_NEUTRAL),
-        mTimeSinceLastRegeneration(0),
-        mLastCalculatedAuToRegenerate(
-                  DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6())
-    {
-        mQueryFlags |= QUERYFLAG_CREATURE;
-
-		setWert(WERT_MOD_AE, 0);
-		setWert(WERT_MOD_LE, 0);
-		setWert(WERT_MOD_AU, 0);
-		setWert(WERT_MOD_MR, 0);
-		setWert(WERT_GS, 8);
-        setWert(WERT_RS, 0);
-        setWert(WERT_BE, 0);
-        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
-		mEigenschaften[E_MUT] = 0;
-		mEigenschaften[E_KLUGHEIT] = 0;
-		mEigenschaften[E_INTUITION] = 0;
-		mEigenschaften[E_CHARISMA] = 0;
-		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
-		mEigenschaften[E_GEWANDTHEIT] = 0;
-		mEigenschaften[E_KONSTITUTION] = 0;
-		mEigenschaften[E_KOERPERKRAFT] = 0;
-
-		mInventory = new Inventory(this);
-    }
-
-	Creature::~Creature()
-    {
-        delete mInventory;
-
-        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
-            delete it-&gt;second;
-        mSonderfertigkeiten.clear();
-        CreatureControllerManager::getSingleton().detachController(this);
-    }
-
-    int Creature::getAttackeBasis() const
-    {
-		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getParadeBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getFernkampfBasis() const
-    {
-      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
-            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getInitiativeBasis() const
-    {
-      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getMrBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
-    }
-
-    int Creature::getLeBasis() const
-    {
-      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-    int Creature::getAuBasis() const
-    {
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-	int Creature::getAeBasis() const
-	{
-      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
-          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
-
-        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
-    }
-
-	int Creature::getWert(Wert wertId, bool getUnmodified) const
-	{
-		WertMap::const_iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + &quot;: Wert &quot; + wertId.c_str() + &quot; nicht gefunden.&quot;).c_str());
-            return 0;
-        }
-        int rval = it-&gt;second;
-        if (!getUnmodified)
-        {
-          rval += mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_SUM);
-          rval *= mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_MULT);
-        }
-		return rval;
-	}
-
-	int Creature::getCurrentBe() const
-	{
-		pair&lt;int,int&gt; be = mInventory-&gt;getOverallBe();
-        ///@todo Ruestungsgewoehnung?
-		return be.first+be.second;
-	}
-
-	void Creature::setWert(Wert wertId, int value)
-	{
-		WertMap::iterator it = mWerte.find(wertId);
-        if (it == mWerte.end())
-        {
-			mWerte.insert(make_pair(wertId, value));
-        }
-		else
-		{
-			it-&gt;second = value;
-		}
-	}
-
-   void Creature::modifyLe(int mod, bool ignoreMax)
-    {
-        int oldLe = mCurrentLe;
-        mCurrentLe += mod;
-		if (!ignoreMax)
-		{
-			mCurrentLe = min(mCurrentLe, getLeMax());
-		}
-
-        if (mCurrentLe &lt;= -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &gt; -getEigenschaft(&quot;KO&quot;))
-        {
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;DeadEffect&quot;));
-        }
-        else if (mCurrentLe &gt; -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &lt;= -getEigenschaft(&quot;KO&quot;))
-        {
-            mEffectManager-&gt;removeEffect(&quot;DeadEffect&quot;);
-        }
-        else if (mCurrentLe &lt;= 0 &amp;&amp; oldLe &gt; 0)
-        {
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;UnconsciousEffect&quot;));
-        }
-        else if (mCurrentLe &gt; 0 &amp;&amp; oldLe &lt;= 0)
-        {
-            mEffectManager-&gt;removeEffect(&quot;UnconciousEffect&quot;);
-        }
-		else if (mCurrentLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
-            oldLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;IncapacitatedEffect&quot;));
-		}
-		else if (mCurrentLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
-            oldLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
-		{
-            mEffectManager-&gt;removeEffect(&quot;IncapacitatedEffect&quot;);
-		}
-
-        fireObjectStateChangeEvent();
-
-    }
-
-    int Creature::getLe() const
-    {
-        return mCurrentLe;
-    }
-
-    int Creature::getLeMax() const
-    {
-		return getLeBasis() + getWert(WERT_MOD_LE);
-    }
-
-    void Creature::modifyAe(int mod, bool ignoreMax)
-    {
-        mCurrentAe += mod;
-		if (!ignoreMax)
-			mCurrentAe = min(mCurrentAe, getAeMax());
-		fireObjectStateChangeEvent();
-    }
-
-    int Creature::getAe() const
-    {
-        return mCurrentAe;
-    }
-
-    int Creature::getAeMax() const
-    {
-		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
-    }
-
-    void Creature::modifyAu(float mod, bool ignoreMax)
-    {
-        mCurrentAu = max(mCurrentAu + mod, 0.0f);
-		if (!ignoreMax)
-			mCurrentAu = min(mCurrentAu, float(getAuMax()));
-        if (getAu() &lt;= 0)
-        {
-            ///@todo set incapacitated
-        }
-		fireObjectStateChangeEvent();
-    }
-
-    float Creature::getAu() const
-    {
-        return mCurrentAu;
-    }
-
-    int Creature::getAuMax() const
-    {
-		return getAuBasis() + getWert(WERT_MOD_AU);
-    }
-
-    void Creature::modifyAp(int modifier)
-    {
-        mAp.total += modifier;
-    }
-
-    int Creature::getAp() const
-    {
-        return mAp.total;
-    }
-
-    void Creature::modifyUsedAp(int modifier)
-    {
-        mAp.used += modifier;
-    }
-
-    int Creature::getUsedAp() const
-    {
-        return mAp.used;
-    }
-
-    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
-    {
-		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
-		if (it == mEigenschaften.end())
-		{
-			Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
-		}
-		int result = it-&gt;second;
-        result += mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
-        return result;
-    }
-
-    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
-    {
-        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
-        if (it == mEigenschaften.end())
-        {
-            Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
-        }
-		it-&gt;second = value;
-        fireObjectStateChangeEvent();
-    }
-
-    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
-    {
-		mEigenschaften[eigenschaftName] += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
-    {
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-            return true;
-        /*
-        if( ausweich )
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt != ausweichTalente.end())
-            {
-                return true;
-            }
-        }
-        */
-		
-        return false;
-    }
-
-    int Creature::getTalent(const CeGuiString talentName) const
-    {
-        LOG_DEBUG(Logger::RULES, &quot;Using talent &quot; + talentName);
-        TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Talent::AusweichTalente ausweichTalente;
-            ausweichTalente =
-                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
-            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
-            if (ausweichIt == ausweichTalente.end())
-            {
-                Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-            }
-            int rval = getTalent(ausweichIt-&gt;first) - ausweichIt-&gt;second;
-            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
-            {
-                int tempAusweichTaw = getTalent(ausweichIt-&gt;first)
-                    - ausweichIt-&gt;second;
-                if (tempAusweichTaw &gt; rval) rval = tempAusweichTaw;
-            }
-            return rval;
-        } //if (it == mTalente.end())
-		return it-&gt;second;
-    }
-
-	void Creature::addTalent(const CeGuiString talentName, int value)
-	{
-		TalentMap::const_iterator it = mTalente.find(talentName);
-        if (it != mTalente.end())
-        {
-			Throw(IllegalArgumentException, &quot;Talent schon in mTalente enthalten.&quot;);
-        }
-	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
-		mTalente[talentName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::modifyTalent(const CeGuiString talentName, int mod)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		it-&gt;second += mod ;
-		fireObjectStateChangeEvent();
-    }
-
-	const Creature::TalentMap&amp; Creature::getAllTalents() const
-	{
-		return mTalente;
-	}
-
-    void Creature::setTalent(const CeGuiString talentName, int value)
-    {
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		it-&gt;second = value;
-		fireObjectStateChangeEvent();
-    }
-
-	void Creature::addSe(const CeGuiString talentName)
-	{
-        TalentMap::iterator it = mTalente.find(talentName);
-        if (it == mTalente.end())
-        {
-            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
-        }
-		//it-&gt;second-&gt;setSe( true );
-        /// @todo Implement SEs
-	}
-
-	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int,int&gt;&amp; value)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it != mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException,
-				&quot;Kampftechnik schon in mKampftechniken enthalten.&quot;);
-		}
-		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
-		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
-		mKampftechniken[kampftechnikName] = value;
-		fireObjectStateChangeEvent();
-	}
-
-    pair&lt;int, int&gt; Creature::getKampftechnik(const CeGuiString kampftechnikName) const
-    {
-        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
-        }
-        return (*it).second;
-    }
-
-    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int, int&gt;&amp; value)
-    {
-        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
-        if (it == mKampftechniken.end())
-        {
-            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
-        }
-        (*it).second = value;
-		fireObjectStateChangeEvent();
-    }
-
-    void Creature::addKampfaktion(const CeGuiString&amp; kampfaktionName)
-	{
-		mKampfaktionen.insert(kampfaktionName);
-	}
-
-    bool Creature::hasKampfaktion(const CeGuiString&amp; kampfaktionName) const
-	{
-		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
-	}
-
-	const std::set&lt;CeGuiString&gt;&amp; Creature::getAllKampfaktionen() const
-	{
-		return mKampfaktionen;
-	}
-
-    void Creature::addVorteil(const CeGuiString vorteilName, int value)
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Vorteil schon in mVorteile enthalten&quot;);
-        }
-        mVorteile[vorteilName] = value;
-    }
-
-    bool Creature::hasVorteil(const CeGuiString vorteilName) const
-    {
-        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
-        if (it != mVorteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    void Creature::addNachteil(const CeGuiString nachteilName, int value)
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Nachteil schon in mNachteile enthalten&quot;);
-        }
-        mNachteile[nachteilName] = value;
-    }
-
-    bool Creature::hasNachteil(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it != mNachteile.end())
-        {
-            return true;
-        }
-        else return false;
-    }
-
-    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
-    {
-        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
-        if (it == mNachteile.end())
-        {
-            Throw(IllegalArgumentException, &quot;Nachteil nicht gefunden.&quot;);
-        }
-		else return it-&gt;second + mEffectManager-&gt;getMod(nachteilName, Effect::MODTYPE_SUM);
-    }
-
-    int Creature::getSf(const CeGuiString sfName) const
-    {
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		return it-&gt;second-&gt;getValue();
-    }
-
-	void Creature::addSf(const CeGuiString sfName, SfStatus value)
-	{
-		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-		if (it != mSonderfertigkeiten.end())
-		{
-			Throw(IllegalArgumentException, &quot;Sonderfertigkeit schon in mSonderfertigkeiten enthalten.&quot;);
-		}
-		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
-        /// @todo
-		//DsaManager::getSingleton().getSf(sfName);
-		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
-		mSonderfertigkeiten[sfName]-&gt;setOriginalValue( value );
-		fireObjectStateChangeEvent();
-	}
-
-    void Creature::setSf(const CeGuiString sfName, SfStatus value)
-    {
-        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		it-&gt;second-&gt;setOriginalValue( value );
-		fireObjectStateChangeEvent();
-    }
-
-	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
-	{
-        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
-        if (it == mSonderfertigkeiten.end())
-        {
-            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
-        }
-		return it-&gt;second;
-	}
-
-    Effect::LifeState Creature::getLifeState() const
-    {
-      return mEffectManager-&gt;getLifeState();
-    }
-
-	bool Creature::isMagic() const
-	{
-		return getWert(WERT_MOD_AE) &gt; 0;
-	}
-
-    void Creature::setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage)
-    {
-        if (value == true)
-        {
-            statusVariable++;
-        }
-        else //value == false
-        {
-            if (statusVariable &gt; 0)
-            {
-                statusVariable--;
-            }
-            else
-            {
-                LOG_MESSAGE(Logger::RULES, errorMessage);
-            }
-        } //value == false
-    }
-
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
-		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-		if (((talent-&gt;getArt() == TALENT_ART_SPEZIAL) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_SPEZIAL)) ||
-			((talent-&gt;getArt() == TALENT_ART_BERUF) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_BERUF)))
-		{
-          /// @todo Find proper return value. Prompt an error message?
-			//Throw(OutOfRangeException, &quot;TaW zu niedrig&quot;);
-          return -1;
-		}
-        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
-
-        // Der Probenwurf
-        Tripel&lt;int&gt; probe(DsaManager::getSingleton().roll3D20());
-
-		// Glueckliche
-		if ( (probe.first == 1) &amp;&amp; (probe.second == 1) &amp;&amp; (probe.third == 1) )
-		{
-			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
-			modifyTalent(talentName, +1);
-			return RESULT_SPEKT_AUTOERFOLG;
-		}
-		if ( ((probe.first == 1) &amp;&amp; (probe.second == 1)) ||
-			 ((probe.first == 1) &amp;&amp; (probe.third == 1)) ||
-			 ((probe.second == 1) &amp;&amp; (probe.third == 1)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOERFOLG;
-		}
-		// Patzer
-		if ((probe.first == 20) &amp;&amp; (probe.second == 20) &amp;&amp; (probe.third == 20))
-		{
-			addSe(talentName);
-			return RESULT_SPEKT_AUTOMISSERFOLG;
-		}
-		if ( ((probe.first == 20) &amp;&amp; (probe.second == 20)) ||
-			 ((probe.first == 20) &amp;&amp; (probe.third == 20)) ||
-			 ((probe.second == 20) &amp;&amp; (probe.third == 20)))
-		{
-			addSe(talentName);
-			return RESULT_AUTOMISSERFOLG;
-		}
-
-
-        // Vor dem Vergleich hat man den Talentwert &#195;&#188;brig.
-		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM));
-		int taW = getTalent(talentName);
-		int rval = taW - modifier - mEffectManager-&gt;getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
-            - mEffectManager-&gt;getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
-		// Bei negativen TaP*
-		int handicap = 0;
-		if (rval &lt; 0)
-		{
-			handicap = -rval;
-			rval = 0;
-		}
-
-        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
-        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
-        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
-
-        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
-        // wird die Differenz vom Talentwert abgezogen.
-        rval = diff1 &lt; 0 ? rval + diff1 : rval;
-        rval = diff2 &lt; 0 ? rval + diff2 : rval;
-        rval = diff3 &lt; 0 ? rval + diff3 : rval;
-
-		// TaP* niemals gr&#195;&#182;&#195;&#159;er als TaW (MFF14)
-		if (rval &gt; taW) rval = taW;
-        return rval;
-    }
-
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
-		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
-    {
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
-			eigenschaft2Name, eigenschaft3Name);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent-&gt;getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
-			et.first, et. second, et.third);
-	}
-
-    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
-    {
-        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-        EigenschaftTripel et(talent-&gt;getEigenschaften());
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
-			et. second, et.third);
-	}
-
-    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
-    {
-        int rval;
-
-        int probe = DsaManager::getSingleton().rollD20();
-        if (probe == 1)
-        {
-            rval = RESULT_GLUECKLICH;
-        }
-        else if (probe == 20)
-        {
-            rval = RESULT_PATZER;
-        }
-        else
-        {
-			rval = getEigenschaft(eigenschaftName) -
-                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
-        }
-        return rval;
-    }
-
-
-	Inventory* Creature::getInventory() const
-	{
-		return mInventory;
-	}
-
-    const Ogre::String&amp; Creature::getInventoryWindowType() const
-    {
-        return mInventoryWindowType;
-    }
-
-	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
-		}
-		int rval;
-		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_PATZER;
-		}
-		else
-		{
-			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
-                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval &lt; 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
-	{
-		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
-		if (it == mKampftechniken.end())
-		{
-			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
-		}
-		int rval;
-		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
-
-		int probe = DsaManager::getSingleton().rollD20();
-		if (probe == 1) /// @todo Best&#195;&#164;tigen
-		{
-			rval = RESULT_GLUECKLICH;
-		}
-		else if (probe == 20)
-		{
-			rval = RESULT_PATZER; /// @todo Best&#195;&#164;tigen
-		}
-		else
-		{
-			/// @todo Gute Parade
-			rval = getParadeBasis() + (*it).second.second - (probe + modifier
-                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
-		}
-		if (rval &lt; 0)
-			return RESULT_MISSERFOLG;
-		else
-			return RESULT_ERFOLG;
-	}
-
-	int Creature::doInitiativeWurf(bool getMaxInitiave)
-	{
-		int rval = getInitiativeBasis();
-		rval += mEffectManager-&gt;getMod(WERT_INI, Effect::MODTYPE_SUM);
-		rval -= mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM);
-		if (getMaxInitiave)
-        {
-            rval += 6;
-        }
-        else
-        {
-            rval += DsaManager::getSingleton().rollD6();
-        }
-		return rval;
-	}
-
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
-	{
-		// Roll dice
-		const Tripel&lt;int&gt;&amp; weaponTp = weapon-&gt;getTp();
-		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
-		rval += weaponTp.third;
-
-		// Apply TP/KK
-
-		int kk = getEigenschaft(E_KOERPERKRAFT);
-		std::pair&lt;int, int&gt; tpkk = weapon-&gt;getTpKk();
-		
-		int bonus = (kk - tpkk.first) / tpkk.second;
-		rval += bonus;
-
-		return rval;
-	}
-
-	/// @todo Implement correctly
-	void Creature::damageLe(int tp, int damageType)
-	{
-        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-        if (tp &lt; 0)
-        {
-            tp = 0;
-        }
-
-        ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType &amp; LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Fire damage not handled!&quot;); ///@todo implement
-        }
-        if ((damageType &amp; LEDAMAGE_WATER) == LEDAMAGE_WATER)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Water damage not handled!&quot;); ///@todo implement
-        }
-        if ((damageType &amp; LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;Demonic damage not handled!&quot;); ///@todo implement
-        }
-
-        if ((damageType &amp; LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
-        {
-            damageAu(tp, AUDAMAGE_NORMAL);
-            tp = (int)floor(tp/2.);
-        }
-
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
-		modifyLe(sp);
-
-        if (sp &gt;= getEigenschaft(&quot;KO&quot;))
-        {
-            LOG_ERROR(&quot;Creature&quot;, &quot;TODO: Add a wound.&quot;); ///@todo implement
-        }
-	}
-
-    void Creature::damageAe(int asp)
-    {
-        if (asp &lt; 0)
-        {
-         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           asp = 0;
-        }
-        modifyAe(-asp);
-    }
-
-    void Creature::damageAu(float aup, int damageType)
-    {
-        if (aup &lt; 0)
-        {
-         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
-             auf 0 setzen?*/
-           aup = 0;
-           ///@todo evtl. eine modifyErschoepfung()?
-           mErschoepfung += DsaManager::getSingleton().rollD6();
-           ///@todo set incapacitated
-        }
-        // bei &#195;&#156;beranstrengung, kostet alles doppelte Au!!!!!
-        if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
-            aup *= 2;
-        modifyAu(-aup);
-    }
-
-    void Creature::regenerateLe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedLe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedLe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
-            0, Effect::MODTAG_REGENERATION_LE))
-        {
-            regeneratedLe++;
-        }
-        //modifiziere die aktuellen LE
-        modifyLe(regeneratedLe);
-    }
-
-    void Creature::regenerateAe(int modifier)
-    {
-        //Grundregeneration von 1W6
-        int regeneratedAe = DsaManager::getSingleton().rollD6();
-        //Addiere eventuelle Modifikatoren hinzu
-        regeneratedAe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
-        //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;IN&quot;,
-            0, Effect::MODTAG_REGENERATION_AE))
-        {
-            regeneratedAe++;
-        }
-        //modifiziere die aktuellen AE
-        modifyAe(regeneratedAe);
-    }
-
-    void Creature::regenerateAu(int modifier, float factor, float time)
-    {
-        // das Ganze nur jede Spielrunde machen
-        mTimeSinceLastRegeneration += time;
-
-
-        if( getAu() == getAuMax() )
-        {
-            mTimeSinceLastRegeneration = 0;
-            return;
-        }
-
-
-        while( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE )
-        {
-            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
-
-
-            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
-            //Grundregeneration von 3W6
-            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6();
-            //Addiere eventuelle Modifikatoren hinzu
-            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
-            //Bei gelungener KO Probe addiere 1
-            if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
-                0, mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
-            {
-                modifyAu(6*factor);
-            }
-
-            if( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
-            {
-                //modifiziere die aktuellen AU
-                time -= Date::ONE_SPIELRUNDE;
-                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
-            }
-
-            if( getAu() == getAuMax() )
-            {
-                mTimeSinceLastRegeneration = 0;
-                return;
-            }
-        }
-
-        // Restbetrag regenerieren:
-        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
-        modifyAu(regeneratedAuPerTime*factor);
-    }
-
-    void Creature::setAlignment(Creature::Alignment alignment)
-    {
-        mAlignment = alignment;
-    }
-
-    Creature::Alignment Creature::getAlignment() const
-    {
-        return mAlignment;
-    }
-
-    void Creature::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            mAiProperties = value;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            mInventoryWindowType = value.toString().c_str();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            mCurrentLe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            mCurrentAe = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            mCurrentAu = value.toReal();
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            mErschoepfung = value.toInt();
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            mEigenschaften.clear();
-            convertToMap(value.toMap(), mEigenschaften);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            mTalente.clear();
-            convertToMap(value.toMap(), mTalente);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            mKampftechniken.clear();
-            convertToMap(value.toMap(), mKampftechniken);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            mKampfaktionen.clear();
-            convertToSet(value.toArray(), mKampfaktionen);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            mVorteile.clear();
-            convertToMap(value.toMap(), mVorteile);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            mNachteile.clear();
-            convertToMap(value.toMap(), mNachteile);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            mWerte.clear();
-            convertToMap(value.toMap(), mWerte);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            IntPair ip = value.toIntPair();
-            mAp.total = ip.first;
-            mAp.used = ip.second;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-            mInventory-&gt;setProperties(value.toMap());
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            mAnimations.clear();
-            convertToMap(value.toMap(), mAnimations);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            mAnimationSpeeds.clear();
-            convertToMap(value.toMap(), mAnimationSpeeds);
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Creature::getProperty(const CeGuiString&amp; key) const
-    {
-        if (key == Creature::PROPERTY_AI)
-        {
-            return mAiProperties;
-        }
-        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
-        {
-            return Property(mInventoryWindowType);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_LE)
-        {
-            return Property(mCurrentLe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AE)
-        {
-            return Property(mCurrentAe);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_AU)
-        {
-            return Property(mCurrentAu);
-        }
-        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
-        {
-            return Property(mErschoepfung);
-        }
-        else if (key == Creature::PROPERTY_EFFECTS)
-        {
-            return mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS);
-        }
-        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_TALENTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mTalente);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
-        {
-            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
-            return Property(vec);
-        }
-        else if (key == Creature::PROPERTY_VORTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mVorteile);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_NACHTEILE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mNachteile);
-            return Property(map);
-        }
-//        else if (key == Creature::PROPERTY_SF)
-//        {
-            ///@todo Sonderfertigkeiten
-//        }
-        else if (key == Creature::PROPERTY_WERTE)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mWerte);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_AP)
-        {
-            return Property(make_pair(mAp.total, mAp.used));
-        }
-        else if (key == Creature::PROPERTY_INVENTORY)
-        {
-			return mInventory-&gt;getAllProperties()-&gt;toPropertyMap();
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimations);
-            return Property(map);
-        }
-        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
-        {
-            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
-            return Property(map);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Creature::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Creature::PROPERTY_AI);
-        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
-        keys.insert(Creature::PROPERTY_CURRENT_LE);
-        keys.insert(Creature::PROPERTY_CURRENT_AE);
-        keys.insert(Creature::PROPERTY_CURRENT_AU);
-        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
-        keys.insert(Creature::PROPERTY_TALENTE);
-        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
-        keys.insert(Creature::PROPERTY_VORTEILE);
-        keys.insert(Creature::PROPERTY_NACHTEILE);
-        //keys.insert(Creature::PROPERTY_SF);
-        keys.insert(Creature::PROPERTY_WERTE);
-        keys.insert(Creature::PROPERTY_AP);
-        keys.insert(Creature::PROPERTY_INVENTORY);
-        keys.insert(Creature::PROPERTY_ANIMATIONS);
-        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
-
-        return keys;
-    }
-
-    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString&amp; name) const
-    {
-        AnimationSpeedPair ret;
-        AnimationsMap::const_iterator itName = mAnimations.find(name);
-        if( itName != mAnimations.end() )
-            ret.first = itName-&gt;second.c_str();
-        else
-            ret.first = name.c_str();
-
-        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
-        if( itSpeed != mAnimationSpeeds.end() )
-            ret.second = itSpeed-&gt;second;
-        else
-            ret.second = 1;
-
-        return ret;
-    }
-
-    bool Creature::canReachItem(const Item* item) const
-    {
-        return (item-&gt;getPosition() - getPosition()).length() &lt;= 3.0f;
-    }
-
-    void Creature::doPlaceIntoScene()
-    {
-        GameObject::doPlaceIntoScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it-&gt;second-&gt;update();
-        }
-    }
-
-    void Creature::doRemoveFromScene()
-    {
-        GameObject::doRemoveFromScene();
-
-        // check items in inventory
-        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it-&gt;second-&gt;update();
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Creature.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;Eigenschaft.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;EffectManager.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;Kampftechnik.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;StateSet.h&quot;
+#include &quot;Slot.h&quot;
+#include &quot;Talent.h&quot;
+#include &quot;Weapon.h&quot;
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
+
+    const Ogre::String Creature::PROPERTY_AI = &quot;ai&quot;;
+    const Ogre::String Creature::PROPERTY_AI_BEHAVIOURS = &quot;behaviours&quot;;
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_LE = &quot;current_le&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_AE = &quot;current_ae&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_AU = &quot;current_au&quot;;
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE = &quot;current_fatigue&quot;;
+    const Ogre::String Creature::PROPERTY_EFFECTS = &quot;effects&quot;;
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN = &quot;eigenschaften&quot;;
+    const Ogre::String Creature::PROPERTY_TALENTE = &quot;talente&quot;;
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN = &quot;kampftechniken&quot;;
+    const Ogre::String Creature::PROPERTY_KAMPFAKTIONEN = &quot;kampfaktionen&quot;;
+    const Ogre::String Creature::PROPERTY_VORTEILE = &quot;vorteile&quot;;
+    const Ogre::String Creature::PROPERTY_NACHTEILE = &quot;nachteile&quot;;
+    const Ogre::String Creature::PROPERTY_SF = &quot;sonderfertigkeiten&quot;;
+    const Ogre::String Creature::PROPERTY_WERTE = &quot;werte&quot;;
+    const Ogre::String Creature::PROPERTY_AP = &quot;ap&quot;;
+    const Ogre::String Creature::PROPERTY_INVENTORY = &quot;inventory&quot;;
+    const Ogre::String Creature::PROPERTY_ANIMATIONS = &quot;animations&quot;;
+    const Ogre::String Creature::PROPERTY_ANIMATIONSPEEDS = &quot;animationspeeds&quot;;
+
+    // some targets
+	const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+	const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
+	const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
+    const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
+    const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
+    const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
+    const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
+    const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
+    const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
+    const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
+    const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
+    const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
+    const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
+    const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;;
+    const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
+
+
+
+    Creature::Creature(unsigned int id)
+        : GameObject(id),
+		mCurrentLe(0),
+        mCurrentAu(0),
+        mCurrentAe(0),
+		mInventory(NULL),
+		mEigenschaften(),
+		mWerte(),
+		mTalente(),
+        mKampftechniken(),
+		mKampfaktionen(),
+        mSonderfertigkeiten(),
+        mErschoepfung(0),
+        mMovementType(0),
+        mAlignment(ALIGNMENT_NEUTRAL),
+        mTimeSinceLastRegeneration(0),
+        mLastCalculatedAuToRegenerate(
+                  DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6())
+    {
+        mQueryFlags |= QUERYFLAG_CREATURE;
+
+		setWert(WERT_MOD_AE, 0);
+		setWert(WERT_MOD_LE, 0);
+		setWert(WERT_MOD_AU, 0);
+		setWert(WERT_MOD_MR, 0);
+		setWert(WERT_GS, 8);
+        setWert(WERT_RS, 0);
+        setWert(WERT_BE, 0);
+        setWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE, 0);
+		mEigenschaften[E_MUT] = 0;
+		mEigenschaften[E_KLUGHEIT] = 0;
+		mEigenschaften[E_INTUITION] = 0;
+		mEigenschaften[E_CHARISMA] = 0;
+		mEigenschaften[E_FINGERFERTIGKEIT] = 0;
+		mEigenschaften[E_GEWANDTHEIT] = 0;
+		mEigenschaften[E_KONSTITUTION] = 0;
+		mEigenschaften[E_KOERPERKRAFT] = 0;
+
+		mInventory = new Inventory(this);
+    }
+
+	Creature::~Creature()
+    {
+        delete mInventory;
+
+        for( SonderfertigkeitMap::iterator it=mSonderfertigkeiten.begin();it!=mSonderfertigkeiten.end(); it++ )
+            delete it-&gt;second;
+        mSonderfertigkeiten.clear();
+        CreatureControllerManager::getSingleton().detachController(this);
+    }
+
+    int Creature::getAttackeBasis() const
+    {
+		double es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+              getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getParadeBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getFernkampfBasis() const
+    {
+      double es = getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_FINGERFERTIGKEIT, Effect::MODTAG_RECALCULATE) +
+            getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getInitiativeBasis() const
+    {
+      int es = 2 * getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getMrBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KLUGHEIT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 5.0 + 0.5);
+    }
+
+    int Creature::getLeBasis() const
+    {
+      int es =  2 * getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KOERPERKRAFT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+    int Creature::getAuBasis() const
+    {
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_KONSTITUTION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_GEWANDTHEIT, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+	int Creature::getAeBasis() const
+	{
+      int es = getEigenschaft(E_MUT, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_INTUITION, Effect::MODTAG_RECALCULATE) +
+          getEigenschaft(E_CHARISMA, Effect::MODTAG_RECALCULATE);
+
+        return static_cast&lt;int&gt;(es / 2.0 + 0.5);
+    }
+
+	int Creature::getWert(Wert wertId, bool getUnmodified) const
+	{
+		WertMap::const_iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+            LOG_ERROR(Logger::RULES, (string(mName.c_str()) + &quot;: Wert &quot; + wertId.c_str() + &quot; nicht gefunden.&quot;).c_str());
+            return 0;
+        }
+        int rval = it-&gt;second;
+        if (!getUnmodified)
+        {
+          rval += mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_SUM);
+          rval *= mEffectManager-&gt;getMod(wertId, Effect::MODTYPE_MULT);
+        }
+		return rval;
+	}
+
+	int Creature::getCurrentBe() const
+	{
+		pair&lt;int,int&gt; be = mInventory-&gt;getOverallBe();
+        ///@todo Ruestungsgewoehnung?
+		return be.first+be.second;
+	}
+
+	void Creature::setWert(Wert wertId, int value)
+	{
+		WertMap::iterator it = mWerte.find(wertId);
+        if (it == mWerte.end())
+        {
+			mWerte.insert(make_pair(wertId, value));
+        }
+		else
+		{
+			it-&gt;second = value;
+		}
+	}
+
+   void Creature::modifyLe(int mod, bool ignoreMax)
+    {
+        int oldLe = mCurrentLe;
+        mCurrentLe += mod;
+		if (!ignoreMax)
+		{
+			mCurrentLe = min(mCurrentLe, getLeMax());
+		}
+
+        if (mCurrentLe &lt;= -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &gt; -getEigenschaft(&quot;KO&quot;))
+        {
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;DeadEffect&quot;));
+        }
+        else if (mCurrentLe &gt; -getEigenschaft(&quot;KO&quot;) &amp;&amp; oldLe &lt;= -getEigenschaft(&quot;KO&quot;))
+        {
+            mEffectManager-&gt;removeEffect(&quot;DeadEffect&quot;);
+        }
+        else if (mCurrentLe &lt;= 0 &amp;&amp; oldLe &gt; 0)
+        {
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;UnconsciousEffect&quot;));
+        }
+        else if (mCurrentLe &gt; 0 &amp;&amp; oldLe &lt;= 0)
+        {
+            mEffectManager-&gt;removeEffect(&quot;UnconciousEffect&quot;);
+        }
+		else if (mCurrentLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
+            oldLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager-&gt;addEffect(EffectFactoryManager::getSingleton().createEffect(&quot;IncapacitatedEffect&quot;));
+		}
+		else if (mCurrentLe &gt; getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE) &amp;&amp;
+            oldLe &lt;= getWert(WERT_KAMPFUNFAEHIGKEITSSCHWELLE))
+		{
+            mEffectManager-&gt;removeEffect(&quot;IncapacitatedEffect&quot;);
+		}
+
+        fireObjectStateChangeEvent();
+
+    }
+
+    int Creature::getLe() const
+    {
+        return mCurrentLe;
+    }
+
+    int Creature::getLeMax() const
+    {
+		return getLeBasis() + getWert(WERT_MOD_LE);
+    }
+
+    void Creature::modifyAe(int mod, bool ignoreMax)
+    {
+        mCurrentAe += mod;
+		if (!ignoreMax)
+			mCurrentAe = min(mCurrentAe, getAeMax());
+		fireObjectStateChangeEvent();
+    }
+
+    int Creature::getAe() const
+    {
+        return mCurrentAe;
+    }
+
+    int Creature::getAeMax() const
+    {
+		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
+    }
+
+    void Creature::modifyAu(float mod, bool ignoreMax)
+    {
+        mCurrentAu = max(mCurrentAu + mod, 0.0f);
+		if (!ignoreMax)
+			mCurrentAu = min(mCurrentAu, float(getAuMax()));
+        if (getAu() &lt;= 0)
+        {
+            ///@todo set incapacitated
+        }
+		fireObjectStateChangeEvent();
+    }
+
+    float Creature::getAu() const
+    {
+        return mCurrentAu;
+    }
+
+    int Creature::getAuMax() const
+    {
+		return getAuBasis() + getWert(WERT_MOD_AU);
+    }
+
+    void Creature::modifyAp(int modifier)
+    {
+        mAp.total += modifier;
+    }
+
+    int Creature::getAp() const
+    {
+        return mAp.total;
+    }
+
+    void Creature::modifyUsedAp(int modifier)
+    {
+        mAp.used += modifier;
+    }
+
+    int Creature::getUsedAp() const
+    {
+        return mAp.used;
+    }
+
+    int Creature::getEigenschaft(const CeGuiString eigenschaftName, Effect::ModTag tag) const
+    {
+		EigenschaftMap::const_iterator it = mEigenschaften.find(eigenschaftName);
+		if (it == mEigenschaften.end())
+		{
+			Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
+		}
+		int result = it-&gt;second;
+        result += mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_SUM, tag);
+        return result;
+    }
+
+    void Creature::setEigenschaft(const CeGuiString eigenschaftName, int value)
+    {
+        EigenschaftMap::iterator it = mEigenschaften.find(eigenschaftName);
+        if (it == mEigenschaften.end())
+        {
+            Throw(IllegalArgumentException, &quot;Eigenschaft nicht gefunden.&quot;);
+        }
+		it-&gt;second = value;
+        fireObjectStateChangeEvent();
+    }
+
+    void Creature::modifyEigenschaft(const CeGuiString eigenschaftName, int mod)
+    {
+		mEigenschaften[eigenschaftName] += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich) const
+    {
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+            return true;
+        /*
+        if( ausweich )
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt != ausweichTalente.end())
+            {
+                return true;
+            }
+        }
+        */
+		
+        return false;
+    }
+
+    int Creature::getTalent(const CeGuiString talentName) const
+    {
+        LOG_DEBUG(Logger::RULES, &quot;Using talent &quot; + talentName);
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt == ausweichTalente.end())
+            {
+                Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+            }
+            int rval = getTalent(ausweichIt-&gt;first) - ausweichIt-&gt;second;
+            for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
+            {
+                int tempAusweichTaw = getTalent(ausweichIt-&gt;first)
+                    - ausweichIt-&gt;second;
+                if (tempAusweichTaw &gt; rval) rval = tempAusweichTaw;
+            }
+            return rval;
+        } //if (it == mTalente.end())
+		return it-&gt;second;
+    }
+
+	void Creature::addTalent(const CeGuiString talentName, int value)
+	{
+		TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+        {
+			Throw(IllegalArgumentException, &quot;Talent schon in mTalente enthalten.&quot;);
+        }
+	    DsaManager::getSingleton().getTalent(talentName); //ueberpruefe ob es das Talent ueberhaupt gibt
+		mTalente[talentName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::modifyTalent(const CeGuiString talentName, int mod)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		it-&gt;second += mod ;
+		fireObjectStateChangeEvent();
+    }
+
+	const Creature::TalentMap&amp; Creature::getAllTalents() const
+	{
+		return mTalente;
+	}
+
+    void Creature::setTalent(const CeGuiString talentName, int value)
+    {
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		it-&gt;second = value;
+		fireObjectStateChangeEvent();
+    }
+
+	void Creature::addSe(const CeGuiString talentName)
+	{
+        TalentMap::iterator it = mTalente.find(talentName);
+        if (it == mTalente.end())
+        {
+            Throw(IllegalArgumentException, &quot;Talent nicht gefunden.&quot;);
+        }
+		//it-&gt;second-&gt;setSe( true );
+        /// @todo Implement SEs
+	}
+
+	void Creature::addKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int,int&gt;&amp; value)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it != mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException,
+				&quot;Kampftechnik schon in mKampftechniken enthalten.&quot;);
+		}
+		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
+		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
+		mKampftechniken[kampftechnikName] = value;
+		fireObjectStateChangeEvent();
+	}
+
+    pair&lt;int, int&gt; Creature::getKampftechnik(const CeGuiString kampftechnikName) const
+    {
+        KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
+        }
+        return (*it).second;
+    }
+
+    void Creature::setKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int, int&gt;&amp; value)
+    {
+        KampftechnikMap::iterator it = mKampftechniken.find(kampftechnikName);
+        if (it == mKampftechniken.end())
+        {
+            Throw(IllegalArgumentException, &quot;Kampftechnik nicht gefunden.&quot;);
+        }
+        (*it).second = value;
+		fireObjectStateChangeEvent();
+    }
+
+    void Creature::addKampfaktion(const CeGuiString&amp; kampfaktionName)
+	{
+		mKampfaktionen.insert(kampfaktionName);
+	}
+
+    bool Creature::hasKampfaktion(const CeGuiString&amp; kampfaktionName) const
+	{
+		return mKampfaktionen.find(kampfaktionName) != mKampfaktionen.end();
+	}
+
+	const std::set&lt;CeGuiString&gt;&amp; Creature::getAllKampfaktionen() const
+	{
+		return mKampfaktionen;
+	}
+
+    void Creature::addVorteil(const CeGuiString vorteilName, int value)
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Vorteil schon in mVorteile enthalten&quot;);
+        }
+        mVorteile[vorteilName] = value;
+    }
+
+    bool Creature::hasVorteil(const CeGuiString vorteilName) const
+    {
+        VorteilMap::const_iterator it = mVorteile.find(vorteilName);
+        if (it != mVorteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    void Creature::addNachteil(const CeGuiString nachteilName, int value)
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Nachteil schon in mNachteile enthalten&quot;);
+        }
+        mNachteile[nachteilName] = value;
+    }
+
+    bool Creature::hasNachteil(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it != mNachteile.end())
+        {
+            return true;
+        }
+        else return false;
+    }
+
+    int Creature::getSchlechteEigenschaft(const CeGuiString nachteilName) const
+    {
+        NachteilMap::const_iterator it = mNachteile.find(nachteilName);
+        if (it == mNachteile.end())
+        {
+            Throw(IllegalArgumentException, &quot;Nachteil nicht gefunden.&quot;);
+        }
+		else return it-&gt;second + mEffectManager-&gt;getMod(nachteilName, Effect::MODTYPE_SUM);
+    }
+
+    int Creature::getSf(const CeGuiString sfName) const
+    {
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		return it-&gt;second-&gt;getValue();
+    }
+
+	void Creature::addSf(const CeGuiString sfName, SfStatus value)
+	{
+		SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+		if (it != mSonderfertigkeiten.end())
+		{
+			Throw(IllegalArgumentException, &quot;Sonderfertigkeit schon in mSonderfertigkeiten enthalten.&quot;);
+		}
+		//ueberpruefe ob es die Sonderfertigkeit ueberhaupt gib
+        /// @todo
+		//DsaManager::getSingleton().getSf(sfName);
+		mSonderfertigkeiten[sfName] = new SonderfertigkeitenStateSet();
+		mSonderfertigkeiten[sfName]-&gt;setOriginalValue( value );
+		fireObjectStateChangeEvent();
+	}
+
+    void Creature::setSf(const CeGuiString sfName, SfStatus value)
+    {
+        SonderfertigkeitMap::iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		it-&gt;second-&gt;setOriginalValue( value );
+		fireObjectStateChangeEvent();
+    }
+
+	SonderfertigkeitenStateSet* Creature::getSonderfertigkeitenStateSet(const CeGuiString sfName) const
+	{
+        SonderfertigkeitMap::const_iterator it = mSonderfertigkeiten.find(sfName);
+        if (it == mSonderfertigkeiten.end())
+        {
+            Throw(IllegalArgumentException, &quot;Sonderfertigkeit nicht gefunden.&quot;);
+        }
+		return it-&gt;second;
+	}
+
+    Effect::LifeState Creature::getLifeState() const
+    {
+      return mEffectManager-&gt;getLifeState();
+    }
+
+	bool Creature::isMagic() const
+	{
+		return getWert(WERT_MOD_AE) &gt; 0;
+	}
+
+    void Creature::setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage)
+    {
+        if (value == true)
+        {
+            statusVariable++;
+        }
+        else //value == false
+        {
+            if (statusVariable &gt; 0)
+            {
+                statusVariable--;
+            }
+            else
+            {
+                LOG_MESSAGE(Logger::RULES, errorMessage);
+            }
+        } //value == false
+    }
+
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung,
+		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+		if (((talent-&gt;getArt() == TALENT_ART_SPEZIAL) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_SPEZIAL)) ||
+			((talent-&gt;getArt() == TALENT_ART_BERUF) &amp;&amp; (getTalent(talentName) &lt; TALENT_MIN_TAW_FOR_BERUF)))
+		{
+          /// @todo Find proper return value. Prompt an error message?
+			//Throw(OutOfRangeException, &quot;TaW zu niedrig&quot;);
+          return -1;
+		}
+        EigenschaftTripel et(eigenschaft1Name, eigenschaft2Name, eigenschaft3Name);
+
+        // Der Probenwurf
+        Tripel&lt;int&gt; probe(DsaManager::getSingleton().roll3D20());
+
+		// Glueckliche
+		if ( (probe.first == 1) &amp;&amp; (probe.second == 1) &amp;&amp; (probe.third == 1) )
+		{
+			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
+			modifyTalent(talentName, +1);
+			return RESULT_SPEKT_AUTOERFOLG;
+		}
+		if ( ((probe.first == 1) &amp;&amp; (probe.second == 1)) ||
+			 ((probe.first == 1) &amp;&amp; (probe.third == 1)) ||
+			 ((probe.second == 1) &amp;&amp; (probe.third == 1)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOERFOLG;
+		}
+		// Patzer
+		if ((probe.first == 20) &amp;&amp; (probe.second == 20) &amp;&amp; (probe.third == 20))
+		{
+			addSe(talentName);
+			return RESULT_SPEKT_AUTOMISSERFOLG;
+		}
+		if ( ((probe.first == 20) &amp;&amp; (probe.second == 20)) ||
+			 ((probe.first == 20) &amp;&amp; (probe.third == 20)) ||
+			 ((probe.second == 20) &amp;&amp; (probe.third == 20)))
+		{
+			addSe(talentName);
+			return RESULT_AUTOMISSERFOLG;
+		}
+
+
+        // Vor dem Vergleich hat man den Talentwert &#195;&#188;brig.
+		int eBe = DsaManager::getSingleton().getTalent(talentName)-&gt;calculateEbe(mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM));
+		int taW = getTalent(talentName);
+		int rval = taW - modifier - mEffectManager-&gt;getMod(talentName, Effect::MODTYPE_PROBENMOD, spezialisierung)
+            - mEffectManager-&gt;getMod(ALL_TALENTE, Effect::MODTYPE_PROBENMOD, spezialisierung) - eBe;
+		// Bei negativen TaP*
+		int handicap = 0;
+		if (rval &lt; 0)
+		{
+			handicap = -rval;
+			rval = 0;
+		}
+
+        int diff1 = getEigenschaft(et.first) - probe.first - handicap;
+        int diff2 = getEigenschaft(et.second) - probe.second - handicap;
+        int diff3 = getEigenschaft(et.third) - probe.third - handicap;
+
+        // Falls man in einer Eigenschaft hoeher gewurfelt hat,
+        // wird die Differenz vom Talentwert abgezogen.
+        rval = diff1 &lt; 0 ? rval + diff1 : rval;
+        rval = diff2 &lt; 0 ? rval + diff2 : rval;
+        rval = diff3 &lt; 0 ? rval + diff3 : rval;
+
+		// TaP* niemals gr&#195;&#182;&#195;&#159;er als TaW (MFF14)
+		if (rval &gt; taW) rval = taW;
+        return rval;
+    }
+
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
+		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
+    {
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
+			eigenschaft2Name, eigenschaft3Name);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, Effect::ModTag spezialisierung, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent-&gt;getEigenschaften());
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
+			et.first, et. second, et.third);
+	}
+
+    int Creature::doTalentprobe(const CeGuiString talentName, int modifier)
+    {
+        Talent* talent = DsaManager::getSingleton().getTalent(talentName);
+        EigenschaftTripel et(talent-&gt;getEigenschaften());
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
+			et. second, et.third);
+	}
+
+    int Creature::doEigenschaftsprobe(const CeGuiString eigenschaftName, int modifier, Effect::ModTag tag)
+    {
+        int rval;
+
+        int probe = DsaManager::getSingleton().rollD20();
+        if (probe == 1)
+        {
+            rval = RESULT_GLUECKLICH;
+        }
+        else if (probe == 20)
+        {
+            rval = RESULT_PATZER;
+        }
+        else
+        {
+			rval = getEigenschaft(eigenschaftName) -
+                (probe + modifier + mEffectManager-&gt;getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
+        }
+        return rval;
+    }
+
+
+	Inventory* Creature::getInventory() const
+	{
+		return mInventory;
+	}
+
+    const Ogre::String&amp; Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
+
+	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
+		}
+		int rval;
+		int eBe = (int)floor(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_PATZER;
+		}
+		else
+		{
+			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval &lt; 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doParade(const CeGuiString kampftechnikName, int modifier, bool guteParade)
+	{
+		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
+		if (it == mKampftechniken.end())
+		{
+			Throw(IllegalArgumentException, &quot;kampftechnikName nicht in mKampftechniken gefunden&quot;);
+		}
+		int rval;
+		int eBe = (int)ceil(float(DsaManager::getSingleton().getKampftechnik(kampftechnikName)-&gt;calculateEbe(getWert(WERT_BE))) / 2.0);
+
+		int probe = DsaManager::getSingleton().rollD20();
+		if (probe == 1) /// @todo Best&#195;&#164;tigen
+		{
+			rval = RESULT_GLUECKLICH;
+		}
+		else if (probe == 20)
+		{
+			rval = RESULT_PATZER; /// @todo Best&#195;&#164;tigen
+		}
+		else
+		{
+			/// @todo Gute Parade
+			rval = getParadeBasis() + (*it).second.second - (probe + modifier
+                + mEffectManager-&gt;getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
+		}
+		if (rval &lt; 0)
+			return RESULT_MISSERFOLG;
+		else
+			return RESULT_ERFOLG;
+	}
+
+	int Creature::doInitiativeWurf(bool getMaxInitiave)
+	{
+		int rval = getInitiativeBasis();
+		rval += mEffectManager-&gt;getMod(WERT_INI, Effect::MODTYPE_SUM);
+		rval -= mEffectManager-&gt;getMod(WERT_BE, Effect::MODTYPE_SUM);
+		if (getMaxInitiave)
+        {
+            rval += 6;
+        }
+        else
+        {
+            rval += DsaManager::getSingleton().rollD6();
+        }
+		return rval;
+	}
+
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
+	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
+		// Roll dice
+		const Tripel&lt;int&gt;&amp; weaponTp = weapon-&gt;getTp();
+		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
+		rval += weaponTp.third;
+
+		// Apply TP/KK
+
+		int kk = getEigenschaft(E_KOERPERKRAFT);
+		std::pair&lt;int, int&gt; tpkk = weapon-&gt;getTpKk();
+		
+		int bonus = (kk - tpkk.first) / tpkk.second;
+		rval += bonus;
+
+		return rval;
+	}
+
+	/// @todo Implement correctly
+	void Creature::damageLe(int tp, int damageType)
+	{
+        /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+        if (tp &lt; 0)
+        {
+            tp = 0;
+        }
+
+        ///@todo auf Verletzlichkeiten und Immunitaeten achten
+        if (damageType &amp; LEDAMAGE_FIRE)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Fire damage not handled!&quot;); ///@todo implement
+        }
+        if (damageType &amp; LEDAMAGE_WATER)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Water damage not handled!&quot;); ///@todo implement
+        }
+        if (damageType &amp; LEDAMAGE_DEMONIC)
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;Demonic damage not handled!&quot;); ///@todo implement
+        }
+
+        if (damageType &amp; LEDAMAGE_TP_A)
+        {
+            damageAu(tp, AUDAMAGE_NORMAL);
+            tp = (int)floor(tp/2.);
+        }
+
+        int sp = -tp;
+        if (!(damageType &amp; LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
+		modifyLe(sp);
+
+        if (sp &gt;= getEigenschaft(&quot;KO&quot;))
+        {
+            LOG_ERROR(&quot;Creature&quot;, &quot;TODO: Add a wound.&quot;); ///@todo implement
+        }
+	}
+
+    void Creature::damageAe(int asp)
+    {
+        if (asp &lt; 0)
+        {
+         /**@todo Was tun bei negativen AsP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           asp = 0;
+        }
+        modifyAe(-asp);
+    }
+
+    void Creature::damageAu(float aup, int damageType)
+    {
+        if (aup &lt; 0)
+        {
+         /**@todo Was tun bei negativen AuP? Exception? Fehlermeldung? Stillschweigend
+             auf 0 setzen?*/
+           aup = 0;
+           ///@todo evtl. eine modifyErschoepfung()?
+           mErschoepfung += DsaManager::getSingleton().rollD6();
+           ///@todo set incapacitated
+        }
+        // bei &#195;&#156;beranstrengung, kostet alles doppelte Au!!!!!
+        if( mErschoepfung &gt; getEigenschaft(&quot;KO&quot;) )
+            aup *= 2;
+        modifyAu(-aup);
+    }
+
+    void Creature::regenerateLe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedLe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedLe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
+            0, Effect::MODTAG_REGENERATION_LE))
+        {
+            regeneratedLe++;
+        }
+        //modifiziere die aktuellen LE
+        modifyLe(regeneratedLe);
+    }
+
+    void Creature::regenerateAe(int modifier)
+    {
+        //Grundregeneration von 1W6
+        int regeneratedAe = DsaManager::getSingleton().rollD6();
+        //Addiere eventuelle Modifikatoren hinzu
+        regeneratedAe += mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
+        //Bei gelungener KO Probe addiere 1
+        if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;IN&quot;,
+            0, Effect::MODTAG_REGENERATION_AE))
+        {
+            regeneratedAe++;
+        }
+        //modifiziere die aktuellen AE
+        modifyAe(regeneratedAe);
+    }
+
+    void Creature::regenerateAu(int modifier, float factor, float time)
+    {
+        // das Ganze nur jede Spielrunde machen
+        mTimeSinceLastRegeneration += time;
+
+
+        if( getAu() == getAuMax() )
+        {
+            mTimeSinceLastRegeneration = 0;
+            return;
+        }
+
+
+        while( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE )
+        {
+            mTimeSinceLastRegeneration -= Date::ONE_SPIELRUNDE;
+
+
+            ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
+            //Grundregeneration von 3W6
+            mLastCalculatedAuToRegenerate = DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6()
+                + DsaManager::getSingleton().rollD6();
+            //Addiere eventuelle Modifikatoren hinzu
+            //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
+            //Bei gelungener KO Probe addiere 1
+            if (RESULT_ERFOLG &lt;= doEigenschaftsprobe(&quot;KO&quot;,
+                0, mEffectManager-&gt;getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
+            {
+                modifyAu(6*factor);
+            }
+
+            if( mTimeSinceLastRegeneration &gt;= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
+            {
+                //modifiziere die aktuellen AU
+                time -= Date::ONE_SPIELRUNDE;
+                modifyAu((mLastCalculatedAuToRegenerate-modifier)*factor);
+            }
+
+            if( getAu() == getAuMax() )
+            {
+                mTimeSinceLastRegeneration = 0;
+                return;
+            }
+        }
+
+        // Restbetrag regenerieren:
+        float regeneratedAuPerTime = float(mLastCalculatedAuToRegenerate-modifier)/Date::ONE_SPIELRUNDE * Date::ONE_SECOND * time;
+        modifyAu(regeneratedAuPerTime*factor);
+    }
+
+    void Creature::setAlignment(Creature::Alignment alignment)
+    {
+        mAlignment = alignment;
+    }
+
+    Creature::Alignment Creature::getAlignment() const
+    {
+        return mAlignment;
+    }
+
+    void Creature::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            mAiProperties = value;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            mCurrentLe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toReal();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            mKampfaktionen.clear();
+            convertToSet(value.toArray(), mKampfaktionen);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory-&gt;setProperties(value.toMap());
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            mAnimations.clear();
+            convertToMap(value.toMap(), mAnimations);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            mAnimationSpeeds.clear();
+            convertToMap(value.toMap(), mAnimationSpeeds);
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Creature::getProperty(const CeGuiString&amp; key) const
+    {
+        if (key == Creature::PROPERTY_AI)
+        {
+            return mAiProperties;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            return Property(mCurrentLe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            return Property(mCurrentAe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            return Property(mCurrentAu);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            return Property(mErschoepfung);
+        }
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS);
+        }
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFAKTIONEN)
+        {
+            PropertyArray vec = rl::convertToPropertyArray(mKampfaktionen);
+            return Property(vec);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+            return Property(map);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            return Property(make_pair(mAp.total, mAp.used));
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+			return mInventory-&gt;getAllProperties()-&gt;toPropertyMap();
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimations);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_ANIMATIONSPEEDS)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mAnimationSpeeds);
+            return Property(map);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Creature::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Creature::PROPERTY_AI);
+        keys.insert(Creature::PROPERTY_INVENTORY_WINDOW_TYPE);
+        keys.insert(Creature::PROPERTY_CURRENT_LE);
+        keys.insert(Creature::PROPERTY_CURRENT_AE);
+        keys.insert(Creature::PROPERTY_CURRENT_AU);
+        keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
+        keys.insert(Creature::PROPERTY_TALENTE);
+        keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);
+        keys.insert(Creature::PROPERTY_VORTEILE);
+        keys.insert(Creature::PROPERTY_NACHTEILE);
+        //keys.insert(Creature::PROPERTY_SF);
+        keys.insert(Creature::PROPERTY_WERTE);
+        keys.insert(Creature::PROPERTY_AP);
+        keys.insert(Creature::PROPERTY_INVENTORY);
+        keys.insert(Creature::PROPERTY_ANIMATIONS);
+        keys.insert(Creature::PROPERTY_ANIMATIONSPEEDS);
+
+        return keys;
+    }
+
+    Creature::AnimationSpeedPair Creature::getAnimation(const CeGuiString&amp; name) const
+    {
+        AnimationSpeedPair ret;
+        AnimationsMap::const_iterator itName = mAnimations.find(name);
+        if( itName != mAnimations.end() )
+            ret.first = itName-&gt;second.c_str();
+        else
+            ret.first = name.c_str();
+
+        AnimationSpeedsMap::const_iterator itSpeed = mAnimationSpeeds.find(name);
+        if( itSpeed != mAnimationSpeeds.end() )
+            ret.second = itSpeed-&gt;second;
+        else
+            ret.second = 1;
+
+        return ret;
+    }
+
+    bool Creature::canReachItem(const Item* item) const
+    {
+        return (item-&gt;getPosition() - getPosition()).length() &lt;= 3.0f;
+    }
+
+    void Creature::doPlaceIntoScene()
+    {
+        GameObject::doPlaceIntoScene();
+
+        // check items in inventory
+        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
+        Inventory::SlotMap::iterator it = slots.begin();
+        for( ; it != slots.end(); it++ )
+        {
+            it-&gt;second-&gt;update();
+        }
+    }
+
+    void Creature::doRemoveFromScene()
+    {
+        GameObject::doRemoveFromScene();
+
+        ///@todo check if this is really necessary
+        // check items in inventory
+        //Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it-&gt;second-&gt;update();
+        //}
+    }
+}

Modified: rl/trunk/engine/rules/src/Weapon.cpp
===================================================================
--- rl/trunk/engine/rules/src/Weapon.cpp	2008-12-01 21:14:14 UTC (rev 4622)
+++ rl/trunk/engine/rules/src/Weapon.cpp	2008-12-01 21:18:53 UTC (rev 4623)
@@ -36,7 +36,8 @@
     const Ogre::String Weapon::PROPERTY_TP_DK = &quot;DK&quot;;
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = &quot;kampftechnik&quot;;
     const Ogre::String Weapon::PROPERTY_NATURAL = &quot;natural&quot;;
-
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = &quot;avoidarmor&quot;;
+    
 	Weapon::Weapon(unsigned int id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +47,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(&quot;&quot;),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +186,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString&amp; key, const Property&amp; value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +251,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +312,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +333,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001679.html">[Dsa-hl-svn] r4622 - modules/common/dsa
</A></li>
	<LI>Next message: <A HREF="001681.html">[Dsa-hl-svn] r4624 - modules/common/dsa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1680">[ date ]</a>
              <a href="thread.html#1680">[ thread ]</a>
              <a href="subject.html#1680">[ subject ]</a>
              <a href="author.html#1680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
