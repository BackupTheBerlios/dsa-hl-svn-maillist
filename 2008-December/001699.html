<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4642 - in rl/branches/persistence: ai/include	core/include core/src rules/include rules/src ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4642%20-%20in%20rl/branches/persistence%3A%20ai/include%0A%09core/include%20core/src%20rules/include%20rules/src%20ui/src&In-Reply-To=%3C200812061439.mB6EdK40000281%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001698.html">
   <LINK REL="Next"  HREF="001700.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4642 - in rl/branches/persistence: ai/include	core/include core/src rules/include rules/src ui/src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4642%20-%20in%20rl/branches/persistence%3A%20ai/include%0A%09core/include%20core/src%20rules/include%20rules/src%20ui/src&In-Reply-To=%3C200812061439.mB6EdK40000281%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4642 - in rl/branches/persistence: ai/include	core/include core/src rules/include rules/src ui/src">timm at mail.berlios.de
       </A><BR>
    <I>Sat Dec  6 15:39:20 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001698.html">[Dsa-hl-svn] r4641 - modules/regressiontest/scripts/maps
</A></li>
        <LI>Next message: <A HREF="001700.html">[Dsa-hl-svn] r4643 - in rl/branches/persistence: common/include	core/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1699">[ date ]</a>
              <a href="thread.html#1699">[ thread ]</a>
              <a href="subject.html#1699">[ subject ]</a>
              <a href="author.html#1699">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2008-12-06 15:39:04 +0100 (Sat, 06 Dec 2008)
New Revision: 4642

Modified:
   rl/branches/persistence/ai/include/FuzzyStateMachine.h
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/src/PlayAnimationJob.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/rules/include/RulesPrerequisites.h
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/ui/src/MovementControlState.cpp
Log:
merged from trunk

Modified: rl/branches/persistence/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/branches/persistence/ai/include/FuzzyStateMachine.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/ai/include/FuzzyStateMachine.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -1,167 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __RlAI_FuzzyStateMachine_H__
-#define __RlAI_FuzzyStateMachine_H__
-#include &lt;list&gt;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;FuzzyState.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-
-namespace rl
-{
-	/** manages a set of FuzzyState objects 
-	 */
-	template &lt;class Controller&gt; class FuzzyStateMachine :
-		public FuzzyState&lt;Controller&gt;
-	{
-	public:
-		//! typedefinition for pointer to a FuzzyState
-		typedef FuzzyState&lt;Controller&gt;* FuzzyStatePtr;
-
-		/** Constructor
-		 * sets parent and controller for the FuzzyStateMachine
-		 * @param parent gives the parent FuzzyState object
-		 * @param controller sets the controller object
-		 */
-		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
-			: FuzzyState&lt;Controller&gt;(parent, controller), mMaxActiveStates(), mStates() {}
-
-		/** destructor.
-		 * removes internally stored Fuzzystate objects
-		 */
-		virtual ~FuzzyStateMachine(void)
-		{
-			clearStates();
-		}
-
-		/** adds a FuzzyState object
-		 * @param state a FuzzyState object to add.
-		 */
-		virtual void addState(FuzzyStatePtr state)
-		{
-			mStates.push_back(State(false, state));
-            ScriptWrapper::getSingleton().owned( state );
-		}
-		/** removes all stored FuzzyState objects
-		 */
-        virtual void clearStates()
-		{
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.begin(); ++itr)
-			{
-                ScriptWrapper::getSingleton().disowned( itr-&gt;second );
-				delete itr-&gt;second;
-			}
-			mStates.clear();
-		}
-
-		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
-		 * So always return false (no).
-		 * @returns false
-		 */
-		virtual bool isActive(FuzzyStatePtr state)
-		{
-			return false; 
-		}
-		/** reset function for resetting the FuzzyStateMachine
-		 */
-		virtual void reset(){}
-
-		/** sets the maximum number of concurrently active states.
-		 * @param count maximum number of concurrently active states.
-		 */
-		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
-		/** fetches the maximum number of concurrently active states.
-		 * @param int returns the maximum number of concurrently active states.
-		 */
-		virtual int getMaxActivity() { return mMaxActiveStates; }
-
-		/** calculates the activation value.
-		 * @returns float containing the calculated activation value.
-		 */
-		float calculateActivation(void){ return 0.0f; }
-
-		/** initializes the fuzzy state.
-		 */
-		virtual void init(){}
-		/** should activate the fuzzy state.
-		 */
-		virtual void activate(){}
-		/** deactivates fuzzy state.
-		 */
-		virtual void deactivate(){}
-		/** tells the fuzzy state machine to update for the elapsed time.
-		 * For each stored FuzzyState the activation is calculated and
-		 * testified whether it activates the state or not. When a state
-		 * is active its update function is called with the elapsed time.
-		 * @param elapsedtime gives the elapsed time as a float
-		 */
-		virtual void update(const float elapsedTime)
-		{
-			if(mStates.empty())
-				return;
-
-			typename StateList::iterator itr = mStates.begin();
-			for(; itr != mStates.end(); ++itr)
-			{
-				bool isActive = (itr-&gt;second-&gt;calculateActivation() &gt; 0);
-				if(isActive)
-				{
-				//  if state is already active, update it, otherwise activate it
-					if(itr-&gt;first)
-					{
-						itr-&gt;second-&gt;update(elapsedTime);
-					}
-					else
-					{
-						itr-&gt;second-&gt;activate();
-						itr-&gt;first = true;
-						// maybe call update here, too
-					}
-				}
-				else
-				{
-				//	if state was active, deactivate it, otherwise do nothing
-					if(itr-&gt;first)
-					{
-						itr-&gt;second-&gt;deactivate();
-						itr-&gt;first = false;
-					}	
-				}
-			}
-		}
-
-
-	protected:
-		//! maximum number of active states
-		int mMaxActiveStates;
-		/** typedefinition for active/inactive and FuzzyState objects.
-		 * When the boolean is true, the state is active, otherwise not
-		 */
-		typedef std::pair&lt;bool, FuzzyStatePtr&gt; State;
-		//! defines a double linked list of states
-		typedef std::list&lt;State&gt; StateList;
-		//! the double linked list of stored FuzzyState objects
-		StateList mStates;
-	};
-
-/*	template &lt;class Controller&gt; void FuzzyStateMachine&lt;Controller&gt;::update(float elapsedTime)
-	{
-
-	}
-*/
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __RlAI_FuzzyStateMachine_H__
+#define __RlAI_FuzzyStateMachine_H__
+#include &lt;list&gt;
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;FuzzyState.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+
+namespace rl
+{
+	/** manages a set of FuzzyState objects 
+	 */
+	template &lt;class Controller&gt; class FuzzyStateMachine :
+		public FuzzyState&lt;Controller&gt;
+	{
+	public:
+		//! typedefinition for pointer to a FuzzyState
+		typedef FuzzyState&lt;Controller&gt;* FuzzyStatePtr;
+
+		/** Constructor
+		 * sets parent and controller for the FuzzyStateMachine
+		 * @param parent gives the parent FuzzyState object
+		 * @param controller sets the controller object
+		 */
+		FuzzyStateMachine(FuzzyStatePtr parent, Controller* controller)
+			: FuzzyState&lt;Controller&gt;(parent, controller), mMaxActiveStates(), mStates() {}
+
+		/** destructor.
+		 * removes internally stored Fuzzystate objects
+		 */
+		virtual ~FuzzyStateMachine(void)
+		{
+			clearStates();
+		}
+
+		/** adds a FuzzyState object
+		 * @param state a FuzzyState object to add.
+		 */
+		virtual void addState(FuzzyStatePtr state)
+		{
+			mStates.push_back(State(false, state));
+            ScriptWrapper::getSingleton().owned( state );
+		}
+		/** removes all stored FuzzyState objects
+		 */
+        virtual void clearStates()
+		{
+			for(typename StateList::iterator itr = mStates.begin(); itr != mStates.end(); ++itr)
+			{
+                FuzzyStatePtr state = itr-&gt;second;
+                ScriptWrapper::getSingleton().disowned( state );
+				delete state;
+			}
+			mStates.clear();
+		}
+
+		/** Tests if the FuzzyStateMachine is an active FuzzyState object.
+		 * So always return false (no).
+		 * @returns false
+		 */
+		virtual bool isActive(FuzzyStatePtr state)
+		{
+			return false; 
+		}
+		/** reset function for resetting the FuzzyStateMachine
+		 */
+		virtual void reset(){}
+
+		/** sets the maximum number of concurrently active states.
+		 * @param count maximum number of concurrently active states.
+		 */
+		virtual void setMaxActivity(int count){ mMaxActiveStates = count; }
+		/** fetches the maximum number of concurrently active states.
+		 * @param int returns the maximum number of concurrently active states.
+		 */
+		virtual int getMaxActivity() { return mMaxActiveStates; }
+
+		/** calculates the activation value.
+		 * @returns float containing the calculated activation value.
+		 */
+		float calculateActivation(void){ return 0.0f; }
+
+		/** initializes the fuzzy state.
+		 */
+		virtual void init(){}
+		/** should activate the fuzzy state.
+		 */
+		virtual void activate(){}
+		/** deactivates fuzzy state.
+		 */
+		virtual void deactivate(){}
+		/** tells the fuzzy state machine to update for the elapsed time.
+		 * For each stored FuzzyState the activation is calculated and
+		 * testified whether it activates the state or not. When a state
+		 * is active its update function is called with the elapsed time.
+		 * @param elapsedtime gives the elapsed time as a float
+		 */
+		virtual void update(const float elapsedTime)
+		{
+			if(mStates.empty())
+				return;
+
+			typename StateList::iterator itr = mStates.begin();
+			for(; itr != mStates.end(); ++itr)
+			{
+				bool isActive = (itr-&gt;second-&gt;calculateActivation() &gt; 0);
+				if(isActive)
+				{
+				//  if state is already active, update it, otherwise activate it
+					if(itr-&gt;first)
+					{
+						itr-&gt;second-&gt;update(elapsedTime);
+					}
+					else
+					{
+						itr-&gt;second-&gt;activate();
+						itr-&gt;first = true;
+						// maybe call update here, too
+					}
+				}
+				else
+				{
+				//	if state was active, deactivate it, otherwise do nothing
+					if(itr-&gt;first)
+					{
+						itr-&gt;second-&gt;deactivate();
+						itr-&gt;first = false;
+					}	
+				}
+			}
+		}
+
+
+	protected:
+		//! maximum number of active states
+		int mMaxActiveStates;
+		/** typedefinition for active/inactive and FuzzyState objects.
+		 * When the boolean is true, the state is active, otherwise not
+		 */
+		typedef std::pair&lt;bool, FuzzyStatePtr&gt; State;
+		//! defines a double linked list of states
+		typedef std::list&lt;State&gt; StateList;
+		//! the double linked list of stored FuzzyState objects
+		StateList mStates;
+	};
+
+/*	template &lt;class Controller&gt; void FuzzyStateMachine&lt;Controller&gt;::update(float elapsedTime)
+	{
+
+	}
+*/
+}
+#endif

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -34,6 +34,7 @@
 
 		typedef std::map&lt;int, SaveGameFile*&gt; SaveGameEntryMap;
 
+		void updateFileList();
 		SaveGameEntryMap listSaveGames() const;
 		SaveGameEntryMap listSaveGames(const CeGuiString &amp;moduleId) const;
 		bool SaveGameExists(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
@@ -43,9 +44,13 @@
         virtual void parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
         virtual Ogre::Real getLoadingOrder(void) const;
 
-		void createNewSaveGame();
+		SaveGameFile* createNewSaveGame();
+		void deleteSaveGame(int fileId);
+		void deleteSaveGame(SaveGameFile* save);
 		void writeSaveGame(int fileId);
+		void writeSaveGame(SaveGameFile* save);
 		void readSaveGame(int fileId);
+		void readSaveGame(SaveGameFile* save);
 
 		int getHighestSaveGameNumber();
 	protected:

Modified: rl/branches/persistence/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -73,26 +73,26 @@
             {
                 mo-&gt;stopAllAnimationsExcept(mAnimName);
             }                
-            
-            if (mo-&gt;hasAnimation(mAnimName))
+            
+            if (mo-&gt;hasAnimation(mAnimName))
             {
-                if (mDuration &gt; 0)
-                {
-                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
-                    mTimeToGo = mDuration;
-                    mAnimationRunning = true;
-                }
-                else
-                {
-                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
-                    mTimeToGo = mAnimation-&gt;getLength() * (float)mLoops;
-                    mAnimationRunning = true;
-                }
+                if (mDuration &gt; 0)
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation-&gt;getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
             }
-            else 
+            else 
             {
-                mAnimation = NULL;
-                mTimeToGo = 0;
+                mAnimation = NULL;
+                mTimeToGo = 0;
             }
         }
 
@@ -119,4 +119,4 @@
 
         return false;
     }
-}
+}
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -68,6 +68,7 @@
 		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream-&gt;getName()),
 			WriteableDataStreamPtr(dynamic_cast&lt;WriteableDataStream*&gt;(stream.get())));
 		mReader.parseSaveGameFileHeader(file);
+		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream-&gt;getName()) &gt; mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream-&gt;getName()) : mHighestSaveGameNumber;
 		mSaveGameFiles[Ogre::StringConverter::parseInt(stream-&gt;getName())] = file;
 	}
 
@@ -126,4 +127,57 @@
 		}
 		return NULL;
 	}
+
+	void SaveAbleSerializer::updateFileList()
+	{
+		Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup(&quot;SaveGameFiles&quot;);
+
+		SaveGameEntryMap::iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			delete iter-&gt;second;
+		}
+
+		mSaveGameFiles.clear();
+
+		Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(&quot;SaveGameFiles&quot;);
+	}
+
+
+///---------------------------------------------------------------
+
+
+	SaveGameFile* SaveAbleSerializer::createNewSaveGame()
+	{
+		return NULL;
+	}
+
+	void SaveAbleSerializer::deleteSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::deleteSaveGame(SaveGameFile* save)
+	{
+	}
+
+	void SaveAbleSerializer::writeSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::writeSaveGame(SaveGameFile* save)
+	{
+	}
+
+	void SaveAbleSerializer::readSaveGame(int fileId)
+	{
+	}
+
+	void SaveAbleSerializer::readSaveGame(SaveGameFile* save)
+	{
+	}
+
+	int SaveAbleSerializer::getHighestSaveGameNumber()
+	{
+		return mHighestSaveGameNumber;
+	}
 }

Modified: rl/branches/persistence/rules/include/RulesPrerequisites.h
===================================================================
--- rl/branches/persistence/rules/include/RulesPrerequisites.h	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/rules/include/RulesPrerequisites.h	2008-12-06 14:39:04 UTC (rev 4642)
@@ -91,6 +91,7 @@
 
 	typedef std::vector&lt;Action*&gt; ActionVector;
 	
-	ActionVector::iterator findAction(ActionVector::iterator&amp; begin, ActionVector::iterator&amp; end, const CeGuiString actionName);
+	ActionVector::iterator findAction(ActionVector::iterator&amp; begin, ActionVector::iterator&amp; end, const CeGuiString&amp; actionName);
+	ActionVector::const_iterator findAction(ActionVector::const_iterator&amp; begin, ActionVector::const_iterator&amp; end, const CeGuiString&amp; actionName);
 }
 #endif

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -486,7 +486,7 @@
                         }
                         else if (!target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; actor-&gt;getActiveWeapon()-&gt;isNatural())
                         {
-                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            doDamage(jobSetAnims, DMG_HALF, target, actor);
                             rollDamage = DMG_NONE;
                         }
                         else
@@ -522,7 +522,7 @@
 			target-&gt;doGetroffen(jobSetAnims);
 		}
 		
-        doDamage(jobSetDamage, rollDamage, actor, target);
+        doDamage(jobSetAnims, rollDamage, actor, target);
 	}
     
     void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)

Modified: rl/branches/persistence/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence/ui/src/MovementControlState.cpp	2008-12-06 14:26:40 UTC (rev 4641)
+++ rl/branches/persistence/ui/src/MovementControlState.cpp	2008-12-06 14:39:04 UTC (rev 4642)
@@ -1,1535 +1,1535 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot;
-
-#include &quot;MovementControlState.h&quot;
-
-#include &lt;utility&gt;
-
-#include &quot;AbstractMovement.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;MeshAnimation.h&quot;
-#include &quot;MovementControlState.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;PhysicsMaterialRaycast.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;World.h&quot;
-#include &quot;LineSetPrimitive.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowManager.h&quot;
-
-#include &lt;numeric&gt;
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = &quot;MovementControlState&quot;;
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
-            mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
-            boost::bind(&amp;MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SaveGameLoading&gt;(
-            boost::bind(&amp;MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()-&gt;unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL &amp;&amp; mSceneNode-&gt;getParent() != NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
-        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-        // cam&lt;-&gt;Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        // cam&lt;-&gt;Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL &amp;&amp; go-&gt;isHighlighted())
-        {
-            go-&gt;setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
-        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-            if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor-&gt;getWorldPosition();
-        Quaternion charOri = mCharacterActor-&gt;getWorldOrientation();
-        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear())
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement &amp; MOVE_RIGHT || movement &amp; MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement &amp; TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement &amp; TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement &amp; TURN_LEFT || movement &amp; TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im-&gt;getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  &amp;&amp; mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw &lt;= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
-                             ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw &gt;= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw &gt; Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw &lt;= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw &lt; Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw &gt;= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController-&gt;getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement &amp; MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement &amp; MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController-&gt;setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement &amp; MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement &amp; MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController-&gt;setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_JUMP &amp;&amp; 
-                    mController-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement &amp; MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController-&gt;setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement &amp; MOVE_RUN_LOCK )
-                    {
-                        if( movement &amp; MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement &amp; MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement &amp; MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement &amp; MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement &amp; MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController-&gt;setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController-&gt;setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement &amp; MOVE_FORWARD || movement &amp; MOVE_BACKWARD || movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement &amp; (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement &amp; MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement &amp; MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement &amp; (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController-&gt;getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement &amp; MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement &amp; MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance &lt; mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance &gt; mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr&#65533;e beziehen
-        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-        AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode-&gt;lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode-&gt;lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor-&gt;getPosition() - charPos).length();
-            cameraNode-&gt;lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody-&gt;getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody-&gt;getCollision(), camOri, camPos,
-                    mCharBody-&gt;getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor-&gt;setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor-&gt;setVisible(true);
-            }
-        }
-        mCameraActor-&gt;setOrientation(cameraNode-&gt;getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody &amp;&amp; m_body1 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) ||
-            ( m_body1 == mCamBody &amp;&amp; m_body0 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor-&gt;_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node-&gt;getPosition();
-        Quaternion egal;
-        mCamBody-&gt;getPositionOrientation(bodpos,egal);
-        ss
-            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
-            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mController-&gt;getVelocity().z &lt;&lt; std::endl
-            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mController-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
-            &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mLastDistance &lt;&lt; &quot; ( &quot; &lt;&lt; mDesiredDistance &lt;&lt; &quot; ) &quot; &lt;&lt; std::endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mController-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real&amp; timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr&#65533;e beziehen
-        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-            mCameraActor-&gt;getControlledObject());
-        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody-&gt;getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody-&gt;getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr&#65533;e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr&#65533;e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() &gt; maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime &gt; 0.500f &amp;&amp; mCharacterOccludedFrameCount &gt; 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
-                // und durch &quot;Geraden&quot; miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte jetzt anfangen!&quot;);
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta &lt; buffSize )
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta &gt;= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, &quot; Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! &quot;);
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta &gt; 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody-&gt;getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody-&gt;getMassMatrix(mass, inertia);
-
-            //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
-            mCamBody-&gt;setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &amp;timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        //Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion charOri (mController-&gt;getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr&#65533;e beziehen
-            CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-            AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody-&gt;getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i &lt; 6; i++ )
-            {
-                RaycastInfo info = mRaycast-&gt;execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody &amp;&amp; info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() &lt; diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() &lt; radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &amp;&amp;
-                desiredDistance &gt; mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision &lt;= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision &gt; mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance &gt; desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
-        {
-            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
-            if (creature &amp;&amp;
-				creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY &amp;&amp;
-				(creature-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL &amp;&amp; oldGo != newGo)
-        {
-            oldGo-&gt;setHighlighted(false);
-        }
-
-        if (newGo != NULL &amp;&amp; newGo != oldGo)
-        {
-            newGo-&gt;setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im-&gt;isMouseButtonDown(OIS::MB_Right) &amp;&amp; newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im-&gt;isMouseButtonDown(OIS::MB_Left) &amp;&amp; newGo != NULL)
-        {
-            newGo-&gt;doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh-&gt;getPoseSize(mCharacter-&gt;getAnimation(&quot;stehen&quot;).first);
-        }
-        catch(...)
-        {
-            aabb = charMesh-&gt;getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, &quot;Switch to pnyx mode movementcontroller&quot;);
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr&#65533;e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        aab = mesh-&gt;getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh-&gt;getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr&#65533;e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor-&gt;setVisible(false);
-        else
-            mCharacterActor-&gt;setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, &quot;Camera resetted.&quot;);
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper-&gt;getControlStateAction(code, mType);
-            if (command == &quot;&quot;)
-            {
-                // No. So try global actions.
-                command = mCommandMapper-&gt;getGlobalAction(code);
-            }
-            else if (command == &quot;freeflight_mode&quot;)
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == &quot;reset_camera&quot;)
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == &quot;toggle_view_mode&quot;)
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper-&gt;getMovement(evt.key);
-
-                if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &amp;= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper-&gt;getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
-            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL &amp;&amp; !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo-&gt;getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo-&gt;doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
-            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode-&gt;getParent() == NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-        lineSet-&gt;addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()-&gt;setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;MovementControlState.h&quot;
+
+#include &lt;utility&gt;
+
+#include &quot;AbstractMovement.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;MeshAnimation.h&quot;
+#include &quot;MovementControlState.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;PhysicsMaterialRaycast.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;World.h&quot;
+#include &quot;LineSetPrimitive.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;AnimationManager.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowManager.h&quot;
+
+#include &lt;numeric&gt;
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = &quot;MovementControlState&quot;;
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mObstractedFrameCount(0),
+        mObstractedTime(0.0f),
+        mCameraJammedFrameCount(0),
+        mCameraJammedTime(0.0f),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(20),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
+            mCharacterActor-&gt;getControlledObject());
+        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
+            boost::bind(&amp;MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SaveGameLoading&gt;(
+            boost::bind(&amp;MovementControlState::beforeLoadingSaveGame, this));
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()-&gt;unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL &amp;&amp; mSceneNode-&gt;getParent() != NULL)
+        {
+            mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
+        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+        // cam&lt;-&gt;Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        // cam&lt;-&gt;Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL &amp;&amp; go-&gt;isHighlighted())
+        {
+            go-&gt;setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
+        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
+        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
+            if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+
+
+        // Do we need to reset the Camera?
+        Vector3 charPos = mCharacterActor-&gt;getWorldPosition();
+        Quaternion charOri = mCharacterActor-&gt;getWorldOrientation();
+        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+
+        float maxdistance;
+        if (mViewMode == VM_FIRST_PERSON)
+            maxdistance = 0.25;
+        else
+            maxdistance = 1.3f * mDesiredDistance + 1.4f;
+
+        // if we have more than 250ms and at least five frames with camera distance higher
+        // than desired distance, reset camera
+        if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
+        {
+            mCameraJammedTime += elapsedTime;
+            ++mCameraJammedFrameCount;
+        }
+        else
+        {
+            mCameraJammedTime = 0.0f;
+            mCameraJammedFrameCount = 0;
+        }
+
+        if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
+        {
+            mCameraJammedFrameCount = 0;
+            resetCamera();
+        }
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() &amp;&amp; !(mCharacter-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement &amp; MOVE_RIGHT || movement &amp; MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement &amp; TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement &amp; TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement &amp; TURN_LEFT || movement &amp; TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im-&gt;getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  &amp;&amp; mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw &lt;= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
+                             ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw &gt;= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw &gt; Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw &lt;= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw &lt; Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw &gt;= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController-&gt;getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement &amp; MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement &amp; MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController-&gt;setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement &amp; MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement &amp; MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController-&gt;setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_JUMP &amp;&amp; 
+                    mController-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement &amp; MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController-&gt;setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement &amp; MOVE_RUN_LOCK )
+                    {
+                        if( movement &amp; MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement &amp; MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement &amp; MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement &amp; MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement &amp; MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController-&gt;setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController-&gt;setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement &amp; MOVE_FORWARD || movement &amp; MOVE_BACKWARD || movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement &amp; (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement &amp; MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement &amp; MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement &amp; (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController-&gt;getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement &amp; MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement &amp; MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance &lt; mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance &gt; mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr&#65533;e beziehen
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+                mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode-&gt;lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode-&gt;lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor-&gt;getPosition() - charPos).length();
+            cameraNode-&gt;lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody-&gt;getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody-&gt;getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody-&gt;getCollision(), camOri, camPos,
+                    mCharBody-&gt;getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor-&gt;setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor-&gt;setVisible(true);
+            }
+        }
+        mCameraActor-&gt;setOrientation(cameraNode-&gt;getOrientation());
+    }
+
+    // -------------------------------------------------------------
+    // character collision moved to CreatureController(Manager)
+    int MovementControlState::userProcess()
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( m_body0 == mCamBody &amp;&amp; m_body1 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) ||
+            ( m_body1 == mCamBody &amp;&amp; m_body0 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) )
+        {
+            return 0;
+        }
+
+        setContactSoftness(0.8f);
+        setContactElasticity(0.0f);
+        mLastCameraCollision = 0;
+
+        return 1;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+        Real timestep = world-&gt;getTimeStep();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor-&gt;_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node-&gt;getPosition();
+        Quaternion egal;
+        mCamBody-&gt;getPositionOrientation(bodpos,egal);
+        ss
+            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
+            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mController-&gt;getVelocity().z &lt;&lt; std::endl
+            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mController-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
+                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
+            &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mLastDistance &lt;&lt; &quot; ( &quot; &lt;&lt; mDesiredDistance &lt;&lt; &quot; ) &quot; &lt;&lt; std::endl
+            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mController-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real&amp; timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr&#65533;e beziehen
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+            mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody-&gt;getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody-&gt;getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
+                world,
+                &amp;materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr&#65533;e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr&#65533;e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast-&gt;execute(
+                world,
+                &amp;materialVector,
+                camPos,
+                charPos,
+                true);
+
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() &gt; maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime &gt; 0.500f &amp;&amp; mCharacterOccludedFrameCount &gt; 10 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+                mCharacterOccludedTime = 0;
+
+            if( infoCastOptPos.mBody )
+            {
+                if( !infoCastChar.mBody ) // Character noch im Blickfeld
+                {
+                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                    // und erreichbar ist
+                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                    RaycastInfo infoCastNewPos;
+                    Real delta = lenToOptCamPos/2.0f;
+                    Vector3 temp = charPos + delta * normToOptCamPos;
+                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
+                    {
+                        infoCastNewPos = mRaycast-&gt;execute(
+                            world,
+                            &amp;materialVector,
+                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                            temp,
+                            true);
+                        delta = delta/2.0f;
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                        {
+                            temp = temp - delta * normToOptCamPos;
+                        }
+                        else // kein Hindernis gefunden, weiter von Char weg
+                        {
+                            temp = temp + delta * normToOptCamPos;
+                        }
+                    }
+
+                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                    temp = temp - 0.05 * normToOptCamPos;
+                    // Groesse der Kamera einbeziehen
+                    optimalCamPos = temp - camRadius * normToOptCamPos;
+                    // so ab hier kann ganz normal weiter gerechnet werden!
+                }
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
+                // und durch &quot;Geraden&quot; miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte jetzt anfangen!&quot;);
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta &lt; buffSize )
+                    {
+                        RaycastInfo info = mRaycast-&gt;execute(
+                            world,
+                            &amp;materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta &gt;= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, &quot; Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! &quot;);
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta &gt; 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast-&gt;execute(
+                            world,
+                            &amp;materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody-&gt;getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody-&gt;getMassMatrix(mass, inertia);
+
+            //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
+            mCamBody-&gt;setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &amp;timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        //Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion charOri (mController-&gt;getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+
+            // Kamera-Gr&#65533;e beziehen
+            CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+                mCameraActor-&gt;getControlledObject());
+            AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
+            // Radius berechnen
+            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
+            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
+            // unds eigentlich ne kugel ist!
+
+
+
+            Vector3 startRay[6], endRay[6];
+
+            Real sinPitchRad = Math::Sin(mPitch) * radius;
+            Real cosPitchRad = Math::Cos(mPitch) * radius;
+            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
+
+            startRay[0] = charPos;
+            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
+                                      // dadurch kann aber sichergestellt
+                                      // werden, dass kein Objekt direkt
+                                      // hinter dem Helden bersehen wird
+            startRay[1] = charPos + radiusOffset;
+            endRay[1] = targetCamPos + radiusOffset;
+            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
+            startRay[2] = charPos + radiusOffset;
+            endRay[2] = targetCamPos + radiusOffset;
+            startRay[3] = charPos - radiusOffset;
+            endRay[3] = targetCamPos - radiusOffset;
+            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
+            startRay[4] = charPos + radiusOffset;
+            endRay[4] = targetCamPos + radiusOffset;
+            startRay[5] = charPos - radiusOffset;
+            endRay[5] = targetCamPos - radiusOffset;
+
+            const OgreNewt::MaterialID* materialId =
+                mCharBody-&gt;getMaterialGroupID();
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 diff = targetCamPos - charPos;
+            bool CollisionFound = false;
+            for( int i = 0; i &lt; 6; i++ )
+            {
+                RaycastInfo info = mRaycast-&gt;execute(
+                    world,
+                    materialId,
+                    startRay[i],
+                    endRay[i],
+                    true);
+
+                if( info.mBody &amp;&amp; info.mBody != mCamBody )
+                {
+                    CollisionFound = true;
+                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
+                    if( newdiff.squaredLength() &lt; diff.squaredLength() )
+                        diff = newdiff;
+                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
+                    {
+                        if( diff.squaredLength() &lt; radius*radius )
+                        {
+                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
+                            break;
+                        }
+                    }
+                }
+            }
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody-&gt;getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &amp;&amp;
+                desiredDistance &gt; mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision &lt;= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision &gt; mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance &gt; desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
+        {
+            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
+            if (creature &amp;&amp;
+				creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY &amp;&amp;
+				(creature-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        //InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL &amp;&amp; oldGo != newGo)
+        {
+            oldGo-&gt;setHighlighted(false);
+        }
+
+        if (newGo != NULL &amp;&amp; newGo != oldGo)
+        {
+            newGo-&gt;setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im-&gt;isMouseButtonDown(OIS::MB_Right) &amp;&amp; newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im-&gt;isMouseButtonDown(OIS::MB_Left) &amp;&amp; newGo != NULL)
+        {
+            newGo-&gt;doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh-&gt;getPoseSize(mCharacter-&gt;getAnimation(&quot;stehen&quot;).first);
+        }
+        catch(...)
+        {
+            aabb = charMesh-&gt;getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, &quot;Switch to pnyx mode movementcontroller&quot;);
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr&#65533;e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        aab = mesh-&gt;getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh-&gt;getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr&#65533;e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor-&gt;setVisible(false);
+        else
+            mCharacterActor-&gt;setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, &quot;Camera resetted.&quot;);
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper-&gt;getControlStateAction(code, mType);
+            if (command == &quot;&quot;)
+            {
+                // No. So try global actions.
+                command = mCommandMapper-&gt;getGlobalAction(code);
+            }
+            else if (command == &quot;freeflight_mode&quot;)
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == &quot;reset_camera&quot;)
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == &quot;toggle_view_mode&quot;)
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper-&gt;getMovement(evt.key);
+
+                if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &amp;= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper-&gt;getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
+            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent&amp; evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL &amp;&amp; !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo-&gt;getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo-&gt;doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
+            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode-&gt;getParent() == NULL)
+        {
+            mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+        lineSet-&gt;addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()-&gt;setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001698.html">[Dsa-hl-svn] r4641 - modules/regressiontest/scripts/maps
</A></li>
	<LI>Next message: <A HREF="001700.html">[Dsa-hl-svn] r4643 - in rl/branches/persistence: common/include	core/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1699">[ date ]</a>
              <a href="thread.html#1699">[ thread ]</a>
              <a href="subject.html#1699">[ subject ]</a>
              <a href="author.html#1699">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
