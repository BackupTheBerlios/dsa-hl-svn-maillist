<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4635 - in rl/branches/persistence: ai ai/include	ai/src common common/include common/src core core/include	core/src rules/include rules/src ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4635%20-%20in%20rl/branches/persistence%3A%20ai%20ai/include%0A%09ai/src%20common%20common/include%20common/src%20core%20core/include%0A%09core/src%20rules/include%20rules/src%20ui/include%20ui/src&In-Reply-To=%3C200812051816.mB5IGn4G021964%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001691.html">
   <LINK REL="Next"  HREF="001693.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4635 - in rl/branches/persistence: ai ai/include	ai/src common common/include common/src core core/include	core/src rules/include rules/src ui/include ui/src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4635%20-%20in%20rl/branches/persistence%3A%20ai%20ai/include%0A%09ai/src%20common%20common/include%20common/src%20core%20core/include%0A%09core/src%20rules/include%20rules/src%20ui/include%20ui/src&In-Reply-To=%3C200812051816.mB5IGn4G021964%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4635 - in rl/branches/persistence: ai ai/include	ai/src common common/include common/src core core/include	core/src rules/include rules/src ui/include ui/src">timm at mail.berlios.de
       </A><BR>
    <I>Fri Dec  5 19:16:49 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001691.html">[Dsa-hl-svn] r4634 - in modules/regressiontest: dialogs dsa scripts
</A></li>
        <LI>Next message: <A HREF="001693.html">[Dsa-hl-svn] r4636 - in rl/branches/persistence: core/include	core/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1692">[ date ]</a>
              <a href="thread.html#1692">[ thread ]</a>
              <a href="subject.html#1692">[ subject ]</a>
              <a href="author.html#1692">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2008-12-05 19:15:18 +0100 (Fri, 05 Dec 2008)
New Revision: 4635

Added:
   rl/branches/persistence/ai/CMakeLists.txt
   rl/branches/persistence/ai/include/DialogLoaderImpl.h
   rl/branches/persistence/ai/src/DialogLoaderImpl.cpp
   rl/branches/persistence/common/CMakeLists.txt
   rl/branches/persistence/core/CMakeLists.txt
Modified:
   rl/branches/persistence/ai/RlAI2005.vcproj
   rl/branches/persistence/ai/include/DialogImplication.h
   rl/branches/persistence/ai/include/DialogLoader.h
   rl/branches/persistence/ai/include/Makefile.am
   rl/branches/persistence/ai/src/DialogImplication.cpp
   rl/branches/persistence/ai/src/DialogLoader.cpp
   rl/branches/persistence/ai/src/Makefile.am
   rl/branches/persistence/common/include/WriteableDataStream.h
   rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
   rl/branches/persistence/common/src/WriteableDataStream.cpp
   rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence/core/include/ConfigurationManager.h
   rl/branches/persistence/core/include/SaveAbleFactory.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/include/SaveGameFile.h
   rl/branches/persistence/core/src/ConfigurationManager.cpp
   rl/branches/persistence/core/src/ContentLoader.cpp
   rl/branches/persistence/core/src/CoreSubsystem.cpp
   rl/branches/persistence/core/src/PlayAnimationJob.cpp
   rl/branches/persistence/core/src/SaveAbleFactory.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/core/src/SaveGameFile.cpp
   rl/branches/persistence/core/src/SaveGameFileReader.cpp
   rl/branches/persistence/core/src/SaveGameFileWriter.cpp
   rl/branches/persistence/core/src/SaveGameManager.cpp
   rl/branches/persistence/rules/include/ApplyDamageJob.h
   rl/branches/persistence/rules/include/Combat.h
   rl/branches/persistence/rules/include/Combatant.h
   rl/branches/persistence/rules/include/Creature.h
   rl/branches/persistence/rules/include/QuestBook.h
   rl/branches/persistence/rules/include/Slot.h
   rl/branches/persistence/rules/include/Weapon.h
   rl/branches/persistence/rules/src/ApplyDamageJob.cpp
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/rules/src/Combatant.cpp
   rl/branches/persistence/rules/src/Creature.cpp
   rl/branches/persistence/rules/src/QuestBook.cpp
   rl/branches/persistence/rules/src/Weapon.cpp
   rl/branches/persistence/ui/include/WindowManager.h
   rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
   rl/branches/persistence/ui/src/WindowManager.cpp
Log:
- completing write able data stream
- rewrite of save game file
- added new methodes to save able manager
- changes on save able factory
- started with writing features of save able serializer
- WIP save game window
- merged from trunk

Copied: rl/branches/persistence/ai/CMakeLists.txt (from rev 4634, rl/trunk/engine/ai/CMakeLists.txt)

Modified: rl/branches/persistence/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/persistence/ai/RlAI2005.vcproj	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/RlAI2005.vcproj	2008-12-05 18:15:18 UTC (rev 4635)
@@ -367,6 +367,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\DialogLoaderImpl.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\DialogManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -541,6 +545,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\DialogLoaderImpl.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\DialogManager.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/branches/persistence/ai/include/DialogImplication.h
===================================================================
--- rl/branches/persistence/ai/include/DialogImplication.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/DialogImplication.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,96 +1,103 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DialogImplication_H__
-#define __DialogImplication_H__
-
-#include &quot;AiPrerequisites.h&quot;
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport DialogImplication
-    {
-    public:
-        DialogImplication();
-        virtual ~DialogImplication();
-        
-        virtual void apply(Dialog* dialog) = 0;
-    };
-
-    class DialogVariableAssignment : public DialogImplication
-    {
-    public:
-        DialogVariableAssignment(const Ogre::String&amp; variableName, 
-                                 const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-
-    protected:
-        Ogre::String mVariableName; 
-        CeGuiString mValue;
-    };
-
-    class DialogVariableIncrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableIncrease(const Ogre::String&amp; variableName, 
-                               const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogVariableDecrease : public DialogVariableAssignment
-    {
-    public:
-        DialogVariableDecrease(const Ogre::String&amp; variableName, 
-                               const CeGuiString&amp; value);
-
-        virtual void apply(Dialog* dialog);
-    };
-
-    class DialogElementActivation : public DialogImplication
-    {
-    public:
-        DialogElementActivation(const CeGuiString&amp; id, bool value, bool isOption);
-        virtual void apply(Dialog* dialog);
-    private:
-        CeGuiString mElementId;
-        bool mValue;
-        bool mIsOption;
-    };
-
-	class DialogExit : public DialogImplication
-	{
-	public:
-		virtual void apply(Dialog* dialog);
-	};
-
-    class QuestPropertyAssignment : public DialogImplication
-    {
-    public:
-        QuestPropertyAssignment(const Ogre::String&amp; questId, const Ogre::String&amp; prop, const CeGuiString&amp; newValue);
-        virtual void apply(Dialog* dialog);
-
-    private:
-        Ogre::String mQuestId;
-        Ogre::String mProperty;
-        CeGuiString mNewValue;
-    };
-}
-
-#endif //__DialogImplication_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String&amp; variableName, 
+                                 const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+
+    protected:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+
+    class DialogVariableIncrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableIncrease(const Ogre::String&amp; variableName, 
+                               const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogVariableDecrease : public DialogVariableAssignment
+    {
+    public:
+        DialogVariableDecrease(const Ogre::String&amp; variableName, 
+                               const CeGuiString&amp; value);
+
+        virtual void apply(Dialog* dialog);
+    };
+
+    class DialogElementActivation : public DialogImplication
+    {
+    public:
+        DialogElementActivation(const CeGuiString&amp; id, bool value, bool isOption);
+        virtual void apply(Dialog* dialog);
+    private:
+        CeGuiString mElementId;
+        bool mValue;
+        bool mIsOption;
+    };
+
+	class DialogExit : public DialogImplication
+	{
+	public:
+		virtual void apply(Dialog* dialog);
+	};
+
+    class QuestPropertyAssignment : public DialogImplication
+    {
+    public:
+        QuestPropertyAssignment(const Ogre::String&amp; questId, const Ogre::String&amp; prop, const CeGuiString&amp; newValue);
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mQuestId;
+        Ogre::String mProperty;
+        CeGuiString mNewValue;
+    };
+    
+    class CombatStart : public DialogImplication
+    {
+    public:
+        CombatStart();
+        virtual void apply(Dialog* dialog);
+    };
+}
+
+#endif //__DialogImplication_H__

Modified: rl/branches/persistence/ai/include/DialogLoader.h
===================================================================
--- rl/branches/persistence/ai/include/DialogLoader.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/DialogLoader.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -18,24 +18,13 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
-#include &quot;Properties.h&quot;
-#include &quot;XmlProcessor.h&quot;
- 
 namespace rl 
 {
 	class Creature;
     class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-	class Property;
+    class DialogLoaderImpl;
 
-
-	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	class DialogLoader : public Ogre::ScriptLoader
 	{
 	public:
 		DialogLoader();
@@ -48,48 +37,9 @@
 		Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
 
 	private: 
-		class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString&amp; id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString&amp; id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
-            void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-
-        private:
-            std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
-            std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-		
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
-
         Ogre::StringVector mScriptPatterns;
-        std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
-
-	};
+        DialogLoaderImpl* mLoaderImplementation;
+    };
 }
 
 #endif //__DialogLoader_H__

Copied: rl/branches/persistence/ai/include/DialogLoaderImpl.h (from rev 4634, rl/trunk/engine/ai/include/DialogLoaderImpl.h)

Modified: rl/branches/persistence/ai/include/Makefile.am
===================================================================
--- rl/branches/persistence/ai/include/Makefile.am	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/include/Makefile.am	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,6 +20,7 @@
 	DialogElementSelection.h \
 	DialogImplication.h \
 	DialogLoader.h \
+	DialogLoaderImpl.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/branches/persistence/ai/src/DialogImplication.cpp
===================================================================
--- rl/branches/persistence/ai/src/DialogImplication.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/DialogImplication.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,137 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;DialogImplication.h&quot;
-
-#include &quot;Dialog.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;Property.h&quot;
-#include &quot;QuestBook.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    DialogImplication::DialogImplication()
-    {
-    }
-
-    DialogImplication::~DialogImplication()
-    {
-    }
-
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
-                                                       const CeGuiString&amp; value)
-        : mVariableName(variableName), mValue(value)
-    {
-    }
-
-    void DialogVariableAssignment::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        prop.getFromString(mValue);
-        dialog-&gt;setProperty(mVariableName, prop);
-    }
-
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
-                                                   const CeGuiString&amp; value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableIncrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog-&gt;getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
-            prop.setValue(value);
-            dialog-&gt;setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
-                                      + mVariableName
-                                      + &quot;'. The variable's type is not a number&quot;);
-        }
-    }
-
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
-                                                   const CeGuiString&amp; value)
-        : DialogVariableAssignment(variableName, value)
-    {
-    }
-
-    void DialogVariableDecrease::apply(Dialog* dialog)
-    {
-        Property prop = dialog-&gt;getProperty(mVariableName);
-        if(prop.isInt() || prop.isReal())
-        {
-            Property mod = dialog-&gt;getProperty(mVariableName);
-            mod.getFromString(mValue);
-            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
-            prop.setValue(value);
-            dialog-&gt;setProperty(mVariableName, prop);
-        }
-        else
-        {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
-                                      + mVariableName
-                                      + &quot;'. The variable's type is not a number&quot;);
-        }
-    }
-
-    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
-                                                     bool value,
-                                                     bool isOption)
-        : mElementId(id), mValue(value), mIsOption(isOption)
-    {
-    }
-
-    void DialogElementActivation::apply(Dialog* dialog)
-    {
-        Property prop;
-        if(mIsOption)
-        {
-            dialog-&gt;setProperty(&quot;option&quot; + mElementId + &quot;isActive&quot;, mValue);
-        }
-        else
-        {
-            dialog-&gt;setProperty(&quot;response&quot; + mElementId + &quot;isActive&quot;, mValue);
-        }
-    }
-
-	void DialogExit::apply(rl::Dialog *dialog)
-	{
-		dialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, true);
-	}
-
-    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &amp;questId, const Ogre::String &amp;prop, const rl::CeGuiString &amp;newValue)
-        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
-    {
-    }
-
-    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
-    {
-        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
-        quest-&gt;setPropertyAsString(mProperty, mNewValue);
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogImplication.h&quot;
+
+#include &quot;Combat.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;Property.h&quot;
+#include &quot;QuestBook.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
+                                                       const CeGuiString&amp; value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog-&gt;setProperty(mVariableName, prop);
+    }
+
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
+                                                   const CeGuiString&amp; value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableIncrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog-&gt;getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() + mod.getAsNumber();
+            prop.setValue(value);
+            dialog-&gt;setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
+                                      + mVariableName
+                                      + &quot;'. The variable's type is not a number&quot;);
+        }
+    }
+
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
+                                                   const CeGuiString&amp; value)
+        : DialogVariableAssignment(variableName, value)
+    {
+    }
+
+    void DialogVariableDecrease::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        if(prop.isInt() || prop.isReal())
+        {
+            Property mod = dialog-&gt;getProperty(mVariableName);
+            mod.getFromString(mValue);
+            Ogre::Real value = prop.getAsNumber() - mod.getAsNumber();
+            prop.setValue(value);
+            dialog-&gt;setProperty(mVariableName, prop);
+        }
+        else
+        {
+            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
+                                      + mVariableName
+                                      + &quot;'. The variable's type is not a number&quot;);
+        }
+    }
+
+    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
+                                                     bool value,
+                                                     bool isOption)
+        : mElementId(id), mValue(value), mIsOption(isOption)
+    {
+    }
+
+    void DialogElementActivation::apply(Dialog* dialog)
+    {
+        Property prop;
+        if(mIsOption)
+        {
+            dialog-&gt;setProperty(&quot;option&quot; + mElementId + &quot;isActive&quot;, mValue);
+        }
+        else
+        {
+            dialog-&gt;setProperty(&quot;response&quot; + mElementId + &quot;isActive&quot;, mValue);
+        }
+    }
+
+	void DialogExit::apply(rl::Dialog *dialog)
+	{
+		dialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, true);
+	}
+
+    QuestPropertyAssignment::QuestPropertyAssignment(const Ogre::String &amp;questId, const Ogre::String &amp;prop, const rl::CeGuiString &amp;newValue)
+        : mQuestId(questId), mProperty(prop), mNewValue(newValue)
+    {
+    }
+
+    void QuestPropertyAssignment::apply(rl::Dialog *dialog)
+    {
+        Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
+        quest-&gt;setPropertyAsString(mProperty, mNewValue);
+    }
+    
+    CombatStart::CombatStart()
+    {
+    }
+    
+    void CombatStart::apply(Dialog* dialog)
+    {
+        Combat* combat = CombatManager::getSingleton().startCombat();
+        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
+        for (std::vector&lt;Creature*&gt;::iterator it = allies.begin(); it != allies.end(); ++it)
+        {
+            combat-&gt;addAlly(*it);            
+        }
+        std::vector&lt;Creature*&gt; enemies = dialog-&gt;getNonPlayerCharacters();
+        for (std::vector&lt;Creature*&gt;::iterator it = enemies.begin(); it != enemies.end(); ++it)
+        {
+            combat-&gt;addOpponent(*it);
+        }
+        combat-&gt;start();
+    }
+
+}

Modified: rl/branches/persistence/ai/src/DialogLoader.cpp
===================================================================
--- rl/branches/persistence/ai/src/DialogLoader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/DialogLoader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,57 +1,38 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
 
 #include &quot;stdinc.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;DialogLoader.h&quot;
+#include &quot;DialogLoaderImpl.h&quot;
 
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;Dialog.h&quot;
-#include &quot;DialogCondition.h&quot;
-#include &quot;DialogElement.h&quot;
-#include &quot;DialogImplication.h&quot;
-#include &quot;DialogOption.h&quot;
-#include &quot;DialogParagraph.h&quot;
-#include &quot;DialogResponse.h&quot;
-#include &quot;DialogVariable.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
 	DialogLoader::DialogLoader()
-	      : XmlProcessor(), ScriptLoader()
+	      : ScriptLoader()
     {
+        mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back(&quot;*.dialog&quot;);
   	}
 	
     DialogLoader::~DialogLoader()
     {
-		std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
-        std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
-        {
-			DialogPrototype* p = itr-&gt;second;
-			delete p;
-		}
-        mDialogs.clear();
+        delete mLoaderImplementation;
 	}
  
     const StringVector&amp; DialogLoader::getScriptPatterns() const
@@ -63,692 +44,16 @@
     {
         return 1000;
     }
-
-    void DialogLoader::parseScript(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
+    
+    void DialogLoader::parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-
-            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes-&gt;item(i);
-                processDialog(static_cast&lt;DOMElement*&gt;(cur));
-            }
-        }
-
-        shutdownXml();
+        mLoaderImplementation-&gt;parseDialog(stream, groupName);
     }
-	
-	Dialog* DialogLoader::createDialog(const String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, 
-		const std::vector&lt;Creature*&gt;&amp; npcs) const
-	{
-		std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
-			mDialogs.find(name);
-			
-		if (it == mDialogs.end())
-		{
-			return NULL;
-		}
-		
-		return it-&gt;second-&gt;createDialog(pcs, npcs);
-	}
-	
-    void DialogLoader::processDialog(DOMElement* dialogElem)
+    
+    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const
     {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
-        {
-            if (hasNodeName(curChild, &quot;variable&quot;))
-            {
-                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;option&quot;))
-            {
-                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchoption&quot;))
-            {
-                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;response&quot;))
-            {
-                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchresponse&quot;))
-            {
-                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;start&quot;))
-            {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild-&gt;getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype-&gt;setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
+        return mLoaderImplementation-&gt;createDialog(name, pcs, npcs);
     }
 
-    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
-            if (!hasAttribute(dialogElemXml, &quot;id&quot;))
-            {
-                Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
-            CeGuiString text = getValueAsString(dialogElemXml);
+}
 
-            if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
-            {
-                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
-                option-&gt;setLabel(text);
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;option&quot;))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, &quot;autoSelect&quot;);
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, &quot;label&quot;))
-                {
-                    option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
-                }
-                else
-                {
-                    option-&gt;setLabel(text);
-                }
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;response&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, &quot;response&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;gotoresponse&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchresponse&quot;))
-        {
-            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
-
-        DialogResponse* response = dialogPrototype-&gt;getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response-&gt;addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response-&gt;addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, &quot;gotoresponse&quot;))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
-                    response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response-&gt;addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
-        DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                response-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response-&gt;addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, &quot;option&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;optionref&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchoption&quot;))
-        {
-            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
-
-        DialogOption* option = dialogPrototype-&gt;getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option-&gt;setResponse(response);
-                }
-                else if (hasNodeName(cur, &quot;if&quot;))
-                {
-                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
-                }
-                else if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                        if(!label.empty())
-                        {
-                            option-&gt;setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option-&gt;addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
-            if(!label.empty())
-            {
-                option-&gt;setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
-        DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                option-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option-&gt;addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, &quot;t&quot;))
-            {
-                DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
-                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                    if(!label.empty())
-                    {
-                        option-&gt;setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype-&gt;setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond-&gt;setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = &quot;&quot;;
-        if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    DialogLoader::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogLoader::DialogPrototype::~DialogPrototype()
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it-&gt;second != NULL )
-                delete it-&gt;second;
-
-        std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1-&gt;second != NULL )
-                delete it1-&gt;second;
-    }
-
-    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
-        }
-        mOptionCache[option-&gt;getId()] = option;
-    }
-
-    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
-        }
-        mResponseCache[response-&gt;getId()] = response;
-    }
-
-    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogResponse*&gt;::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog-&gt;setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
-        }
-
-        return dialog;
-    }
-
-    void DialogLoader::DialogPrototype::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-
-    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, &quot;equals&quot;))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;inrange&quot;))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, &quot;from&quot;),
-                getAttributeValueAsReal(conditionXml, &quot;to&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lower&quot;))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lowereq&quot;))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greater&quot;))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greatereq&quot;))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, &quot;name&quot;));
-        }
-        else if (hasNodeName(variableXml, &quot;queststate&quot;))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, &quot;quest&quot;);
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, &quot;property&quot;);
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, &quot;attributecheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;attribute&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, &quot;talentcheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;talent&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-		else if (hasNodeName(variableXml, &quot;random&quot;))
-		{
-			int maximum = getAttributeValueAsInteger(variableXml, &quot;maximum&quot;);
-			return new RandomVariable(maximum);
-		}
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
-
-            if (hasNodeName(implicationElem, &quot;setvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;incvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;decvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;setoptionactive&quot;))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, &quot;id&quot;);
-                bool value = getAttributeValueAsBool(implicationElem, &quot;value&quot;);
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, &quot;exit&quot;))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, &quot;changequest&quot;))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, &quot;quest&quot;);
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, &quot;property&quot;);
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, &quot;newvalue&quot;);
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (hasNodeName(cur, &quot;p&quot;))
-            {
-                element-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-            }
-        }
-    }
-
-}
\ No newline at end of file

Copied: rl/branches/persistence/ai/src/DialogLoaderImpl.cpp (from rev 4634, rl/trunk/engine/ai/src/DialogLoaderImpl.cpp)

Modified: rl/branches/persistence/ai/src/Makefile.am
===================================================================
--- rl/branches/persistence/ai/src/Makefile.am	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ai/src/Makefile.am	2008-12-05 18:15:18 UTC (rev 4635)
@@ -22,6 +22,7 @@
 	DialogElement.cpp \
 	DialogImplication.cpp \
 	DialogLoader.cpp \
+	DialogLoaderImpl.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \

Copied: rl/branches/persistence/common/CMakeLists.txt (from rev 4634, rl/trunk/engine/common/CMakeLists.txt)

Modified: rl/branches/persistence/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/include/WriteableDataStream.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -14,6 +14,9 @@
 *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
 
+#ifndef _H_WriteableDataStream
+#define _H_WriteableDataStream
+
 #include &quot;CommonPrerequisites.h&quot;
 
 #include &lt;iostream&gt;
@@ -23,6 +26,8 @@
     class _RlCommonExport WriteableDataStream : public Ogre::DataStream
     {
     public:
+		WriteableDataStream() : Ogre::DataStream() {}
+		WriteableDataStream(const Ogre::String &amp;name) : Ogre::DataStream(name) {}
         virtual void write(void* buf, size_t count) = 0;
         virtual void flush() = 0;
     };
@@ -71,4 +76,7 @@
     };
 
     typedef Ogre::SharedPtr&lt;WriteableFileStreamDataStream&gt; WriteableFileStreamDataStreamPtr;
-}
\ No newline at end of file
+}
+
+#endif
+

Modified: rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/include/WriteableDataStreamFormatTarget.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,7 +20,7 @@
 
 namespace rl
 {
-    class WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
+    class _RlCommonExport WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
     {
     public:
         WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);

Modified: rl/branches/persistence/common/src/WriteableDataStream.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStream.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/src/WriteableDataStream.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -24,7 +24,7 @@
 namespace rl
 {
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(std::fstream* s, 
-            bool freeOnClose)
+		bool freeOnClose) : WriteableDataStream(), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mpStream-&gt;seekg(0, std::ios_base::end);
         mSize = mpStream-&gt;tellg();
@@ -33,7 +33,7 @@
 
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(const Ogre::String&amp; name, 
             std::fstream* s, 
-            bool freeOnClose)
+			bool freeOnClose) : WriteableDataStream(name), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mpStream-&gt;seekg(0, std::ios_base::end);
         mSize = mpStream-&gt;tellg();
@@ -43,7 +43,7 @@
     WriteableFileStreamDataStream::WriteableFileStreamDataStream(const Ogre::String&amp; name, 
             std::fstream* s, 
             size_t size, 
-            bool freeOnClose)
+			bool freeOnClose) : WriteableDataStream(name), mpStream(s), mFreeOnClose(freeOnClose)
     {
         mSize = size;
     }

Modified: rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/common/src/WriteableDataStreamFormatTarget.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -34,4 +34,5 @@
     {
         mStream-&gt;flush();
     }
-}
\ No newline at end of file
+}
+

Copied: rl/branches/persistence/core/CMakeLists.txt (from rev 4634, rl/trunk/engine/core/CMakeLists.txt)

Modified: rl/branches/persistence/core/include/ConfigurationManager.h
===================================================================
--- rl/branches/persistence/core/include/ConfigurationManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/ConfigurationManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -190,6 +190,13 @@
             Ogre::StringVector getModuleList() const;
 
             /**
+             * Remove modules from the module list (e.g. because they are broken)
+             *
+             * @param modules the modules to remove
+             */
+            void removeModules(const Ogre::StringVector&amp; modules);
+
+            /**
              * Returns the filename of the current keymap file used by
              * Rastullah
              *

Modified: rl/branches/persistence/core/include/SaveAbleFactory.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleFactory.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -25,7 +25,8 @@
 	class _RlCoreExport SaveAbleFactory : public Ogre::Singleton&lt;SaveAbleFactory&gt;, PropertyHolder
 	{
 	public:
-		virtual SaveAblePtr createSaveAble(PropertyRecordPtr params) = 0;
+		virtual SaveAblePtr createSaveAble(const CeGuiString &amp;id, PropertyRecordPtr params) = 0;
+		virtual void removeSaveAble(const CeGuiString &amp;id) = 0;
 	};
 
 	class _RlCoreExport SaveAbleFactoryPool : public Ogre::Singleton&lt;SaveAbleFactoryPool&gt;

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,6 +20,7 @@
 #include &quot;CorePrerequisites.h&quot;
 #include &quot;SaveAble.h&quot;
 #include &quot;SaveAbleCollection.h&quot;
+#include &quot;SaveAbleFactory.h&quot;
 
 namespace rl
 {
@@ -28,21 +29,32 @@
 	protected:
 		typedef std::map&lt;CeGuiString, SaveAbleCollection*&gt; SaveAbleCollectionMap;
 	public:
+		typedef std::map&lt;CeGuiString, SaveAblePtr&gt; SaveAbleMap;
+		typedef std::map&lt;CeGuiString, PropertyRecordPtr&gt; SaveAbleStateMap;
 		void saveState();
-		void addSaveAble(SaveAblePtr save);
+		void loadState();
+		void addSaveAble(SaveAblePtr save, const CeGuiString &amp;collectionId);
+		void moveSaveAbleToCollection(SaveAblePtr save, const CeGuiString &amp;collectionId);
+		void moveSaveAbleToCollection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId);
 		void removeSaveAble(SaveAblePtr save);
 		void removeSaveAble(const CeGuiString &amp;id);
 		void removeAllSaveAbles();
-		void attachSaveAbleToCollection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId);
-		void deattachSaveAbleFromColltection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId);
-		void restoreState();
-		void restoreSaveAble(const CeGuiString &amp;id);
+		//void attachSaveAbleToCollection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId);
+		//void deattachSaveAbleFromColltection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId);
+		
 		SaveAbleCollectionMap getCollections();
+		SaveAbleStateMap getSaveAbleStates();
+
+		SaveAbleFactory* getFactory(SaveAblePtr saveAble);
+		SaveAbleFactory* getFactory(const CeGuiString &amp;id);
 	protected:
-		std::map&lt;CeGuiString, PropertyRecordPtr&gt; mSaveAbleStates;
-		std::map&lt;CeGuiString, SaveAblePtr&gt; mSaveAbles;
-		
+		SaveAbleStateMap mSaveAbleStates;
+		SaveAbleMap mSaveAbles;
 		SaveAbleCollectionMap mSaveAbleCollections;
+
+		void storeSaveAbleStates();
+		void restoreSaveAblesFromStates();
+		void restoreSaveAbleFromState(const CeGuiString &amp;id);		
 	};
 }
 

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -36,6 +36,8 @@
 
 		SaveGameEntryMap listSaveGames();
 		SaveGameEntryMap listSaveGames(const CeGuiString &amp;moduleId);
+		bool SaveGameExists(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
+		SaveGameFile* getSaveGame(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
 
 		virtual const Ogre::StringVector&amp;  getScriptPatterns(void) const;
         virtual void parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
@@ -50,7 +52,7 @@
 		void writeToSaveGameFile(SaveGameFile* file);
 		void readFromSaveGameFile(SaveGameFile* file);
 
-		SaveGameEntryMap mSaveGameFile;
+		SaveGameEntryMap mSaveGameFiles;
 		SaveGameFileReader mReader;
 		SaveGameFileWriter mWriter;
 

Modified: rl/branches/persistence/core/include/SaveGameFile.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameFile.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/include/SaveGameFile.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -31,7 +31,7 @@
 
 namespace rl
 {
-    class _RlCoreExport SaveGameFile : public PropertyHolder, public ScriptSerializer
+    class _RlCoreExport SaveGameFile : public PropertyHolder
     {
     public:
         static const Ogre::String PROPERTY_MODULEID;
@@ -39,25 +39,17 @@
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_MODULENAME;
 
-        SaveGameFile(const CeGuiString &amp;name, int id = 0);
+        SaveGameFile(int id, WriteableDataStreamPtr stream);
         ~SaveGameFile();
-        CeGuiString buildFilename();
         CeGuiString getName() const;
 		CeGuiString getModuleId() const;
-        int getId();
-        bool saveGameExists();
+		int getId() const;
 
         //access to file
         WriteableDataStreamPtr &amp;getDataStream();
-        void closeDataStream();
         XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
-        void deleteFileFromStorage();
+        void deleteFileFromStorage(); //erwuenscht?
 
-        //data to be saved
-        virtual const Ogre::StringVector&amp;  getScriptPatterns(void) const;
-        virtual void parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
-        virtual Ogre::Real getLoadingOrder(void) const;
-
         //propertyholder
         virtual const Property getProperty(const CeGuiString&amp; key) const;
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);

Modified: rl/branches/persistence/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -184,6 +184,21 @@
         return mModuleList;
     }
 
+    void ConfigurationManager::removeModules(const Ogre::StringVector&amp; modules)
+    {
+        for (Ogre::StringVector::const_iterator it = modules.begin(), end = modules.end(); it != end; ++it)
+        {
+            for (Ogre::StringVector::iterator itDel = mModuleList.begin(), endDel = mModuleList.end(); itDel != endDel; ++itDel)
+            {
+                if (*itDel == *it)
+                {
+                    mModuleList.erase(itDel);
+                    break;
+                }
+            }
+        }
+    }
+
     void ConfigurationManager::loadConfig()
     {
         setRastullahCfgPath();

Modified: rl/branches/persistence/core/src/ContentLoader.cpp
===================================================================
--- rl/branches/persistence/core/src/ContentLoader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/ContentLoader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,33 +1,33 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot;
-
-#include &quot;ContentLoader.h&quot;
-
-namespace rl
-{
-    ContentLoader::ContentLoader(const Ogre::String&amp; resourceGroup)
-    {
-    }
-
-    ContentLoader::~ContentLoader()
-    {
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;ContentLoader.h&quot;
+
+namespace rl
+{
+    ContentLoader::ContentLoader(const Ogre::String&amp; resourceGroup)
+    {
+    }
+
+    ContentLoader::~ContentLoader()
+    {
+    }
+
     const Property ContentLoader::getProperty(const CeGuiString&amp; key) const
     {
         LOG_WARNING(Logger::CORE, key + &quot; is not a property of this ContentLoader&quot;);
@@ -38,9 +38,10 @@
     {
     }
 
-    PropertyKeys ContentLoader::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-}
\ No newline at end of file
+    PropertyKeys ContentLoader::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        return keys;
+    }
+}
+

Modified: rl/branches/persistence/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -334,6 +334,8 @@
         // Initialise the modules
         Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
 
+        Ogre::StringVector brokenModules;
+
         for (size_t i = 0; i &lt; modulesList.size(); i++)
         {
             mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
@@ -342,8 +344,9 @@
 
             if (module == NULL)
             {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;'&quot;);
+                LOG_WARNING(&quot;CoreSubsystem&quot;,
+                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;', removed.&quot;);
+                brokenModules.push_back(modulesList[i]);
             }
             //else
             //{
@@ -354,6 +357,8 @@
             //    }
             //}
         }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
     }
 
     ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const

Modified: rl/branches/persistence/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -73,18 +73,26 @@
             {
                 mo-&gt;stopAllAnimationsExcept(mAnimName);
             }                
-
-            if (mDuration &gt; 0)
+            
+            if (mo-&gt;hasAnimation(mAnimName))
             {
-                mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
-                mTimeToGo = mDuration;
-                mAnimationRunning = true;
+                if (mDuration &gt; 0)
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, 0);
+                    mTimeToGo = mDuration;
+                    mAnimationRunning = true;
+                }
+                else
+                {
+                    mAnimation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
+                    mTimeToGo = mAnimation-&gt;getLength() * (float)mLoops;
+                    mAnimationRunning = true;
+                }
             }
-            else
+            else 
             {
-                MeshAnimation* animation = mo-&gt;startAnimation(mAnimName, 1.0f, mLoops);
-                mTimeToGo = animation-&gt;getLength() * (float)mLoops;
-                mAnimationRunning = true;
+                mAnimation = NULL;
+                mTimeToGo = 0;
             }
         }
 

Modified: rl/branches/persistence/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -39,6 +39,15 @@
 
 	void SaveAbleFactoryPool::unregisterFactory(rl::SaveAbleFactory *fac)
 	{
+		std::map&lt;Ogre::String,SaveAbleFactory*&gt;::iterator it;
+		for(it = mFactories.begin(); it != mFactories.end(); it++)
+		{
+			if(it-&gt;second == fac)
+			{
+				mFactories.erase(it);
+				return;
+			}
+		}
 	}
 
 	SaveAbleFactory* SaveAbleFactoryPool::getFactory(const Ogre::String &amp;key)

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -26,7 +26,7 @@
 	{
 	}
 
-	void SaveAbleManager::addSaveAble(SaveAblePtr save)
+	void SaveAbleManager::addSaveAble(SaveAblePtr save, const CeGuiString &amp;collectionId)
 	{
 	}
 
@@ -42,15 +42,36 @@
 	{
 	}
 		
-	void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId)
+	/*void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId)
 	{
-	}
+	}*/
 		
-	void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId)
+	/*void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &amp;saveAbleId, const CeGuiString &amp;collectionId)
 	{
-	}
+	}*/
 		
-	void SaveAbleManager::restoreState()
+	void SaveAbleManager::restoreSaveAblesFromStates()
 	{
 	}
+
+	void SaveAbleManager::restoreSaveAbleFromState(const CeGuiString &amp;id)
+	{
+	}
+
+	void SaveAbleManager::storeSaveAbleStates()
+	{
+		mSaveAbleStates.clear();
+
+		SaveAbleMap::const_iterator it;
+		for(it = mSaveAbles.begin(); it != mSaveAbles.end(); it++)
+		{
+			PropertyRecordPtr Properties;
+			Properties-&gt;setProperty(&quot;Properties&quot;, it-&gt;second-&gt;getAllProperties()-&gt;toPropertyMap());
+
+			// Ein dickes TODO ------
+			Properties-&gt;setProperty(&quot;CreationProperties&quot;, Property());
+			Properties-&gt;setProperty(&quot;Factory&quot;, Property(&quot;ID der Factory&quot;));
+			mSaveAbleStates[it-&gt;first] = Properties;
+		}
+	}
 }

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -64,6 +64,10 @@
 
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
 	{
+		LOG_MESSAGE(Logger::CORE, &quot;Parsing headers of save game file: &quot; + stream-&gt;getName() + &quot; Resource group: &quot; + groupName);
+		mSaveGameFiles[Ogre::StringConverter::parseInt(stream-&gt;getName())] = 
+			new SaveGameFile(Ogre::StringConverter::parseInt(stream-&gt;getName()),
+			WriteableDataStreamPtr(dynamic_cast&lt;WriteableDataStream*&gt;(stream.get())));
 	}
 
 	const Ogre::StringVector&amp; SaveAbleSerializer::getScriptPatterns() const
@@ -75,6 +79,50 @@
     {
         return 2000.0f;
     }
+	
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames()
+	{
+		return mSaveGameFiles;
+	}
 
+	SaveAbleSerializer::SaveGameEntryMap SaveAbleSerializer::listSaveGames(const CeGuiString &amp;moduleId)
+	{
+		SaveGameEntryMap files;
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			if(iter-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+				files[iter-&gt;first] = iter-&gt;second;
+		}
+		return files;
+	}
 
+	bool SaveAbleSerializer::SaveGameExists(const CeGuiString &amp;name, const CeGuiString &amp;moduleId)
+	{
+		bool exists = false;
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end() &amp;&amp; !exists; iter++)
+		{
+			if(iter-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+			{
+				if(iter-&gt;second-&gt;getName() == name)
+					exists = true;
+			}
+		}
+		return exists;
+	}
+
+	SaveGameFile* SaveAbleSerializer::getSaveGame(const CeGuiString &amp;name, const CeGuiString &amp;moduleId)
+	{
+		SaveGameEntryMap::const_iterator iter;
+		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)
+		{
+			if(iter-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
+			{
+				if(iter-&gt;second-&gt;getName() == name)
+					return iter-&gt;second;
+			}
+		}
+		return NULL;
+	}
 }

Modified: rl/branches/persistence/core/src/SaveGameFile.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFile.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -19,6 +19,7 @@
 #include &quot;SaveGameFile.h&quot;
 #include &quot;SaveGameManager.h&quot;
 #include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;
+#include &quot;WriteableDataStreamFormatTarget.h&quot;
 
 #include &lt;ConfigurationManager.h&gt;
 #include &lt;CoreSubsystem.h&gt;
@@ -32,27 +33,15 @@
     const Ogre::String SaveGameFile::PROPERTY_MODULENAME = &quot;modulename&quot;;
 
 
-    SaveGameFile::SaveGameFile(const CeGuiString &amp;name, int id) : mStream((WriteableDataStream*)NULL)
+    SaveGameFile::SaveGameFile(int id, WriteableDataStreamPtr stream) : mStream(stream)
     {
-        setProperty(PROPERTY_NAME,name);
-        mSaveGameId = id;
+		mSaveGameId = id;  
     }
 
     SaveGameFile::~SaveGameFile()
     {
     }
 
-    CeGuiString SaveGameFile::buildFilename()
-    {
-#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        return Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/saves/&quot; 
-            + Ogre::StringConverter::toString(mSaveGameId) + &quot;.save&quot;;
-#       else
-        return ConfigurationManager::getSingleton().getModulesRootDirectory() + &quot;/saves/&quot; 
-            + Ogre::StringConverter::toString(mSaveGameId) + &quot;.save&quot;;
-#       endif        
-    }
-
     CeGuiString SaveGameFile::getName() const
     {
         return getProperty(PROPERTY_NAME);
@@ -63,54 +52,30 @@
 		return mModuleID;
 	}
 
-    int SaveGameFile::getId()
+    int SaveGameFile::getId() const
     {
         return mSaveGameId;
     }
 
     WriteableDataStreamPtr &amp;SaveGameFile::getDataStream()
     {
-        Ogre::ResourceGroupManager::getSingleton().createResourceGroup(&quot;SaveGame&quot;);
-
-        mScriptPatterns.push_back((Ogre::StringConverter::toString(mSaveGameId) + &quot;.save&quot;).c_str());
-
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-
-        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
-            + &quot;/saves&quot;, &quot;FileSystem&quot;, &quot;SaveGame&quot;);
-        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(&quot;SaveGame&quot;);
-
-        ///@todo: decryption
-        return mStream;
+		return mStream;
     }
 
-    void SaveGameFile::closeDataStream()
-    {
-        Ogre::ResourceGroupManager::getSingleton().clearResourceGroup(&quot;SaveGame&quot;); //close all resource files -&gt; make them writable
-        Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup(&quot;SaveGame&quot;);
-
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-    }
-
     XERCES_CPP_NAMESPACE::XMLFormatTarget* SaveGameFile::getFormatTarget()
     {
         ///@todo: encryption
-        return new XERCES_CPP_NAMESPACE::LocalFileFormatTarget(this-&gt;buildFilename().c_str());
+		return new WriteableDataStreamFormatTarget(mStream);
     }
 
     void SaveGameFile::deleteFileFromStorage()
     {
-        if(remove(buildFilename().c_str()))
+        /*if(remove(buildFilename().c_str()))
             LOG_ERROR(Logger::RULES, &quot;SaveGameFile is not removed from filesystem. The file doesn't exists!&quot;);
         else 
-            LOG_MESSAGE(Logger::RULES,&quot;SaveGameFile successfully removed from filesystem&quot;);
+            LOG_MESSAGE(Logger::RULES,&quot;SaveGameFile successfully removed from filesystem&quot;);*/
     }
 
-    bool SaveGameFile::saveGameExists()
-    {
-        return !Ogre::DataStreamPtr( new Ogre::FileHandleDataStream(fopen(this-&gt;buildFilename().c_str(), &quot;r&quot;))).isNull();
-    }
-
     const Property SaveGameFile::getProperty(const CeGuiString&amp; key) const
     {
         if(key == PROPERTY_MODULEID)
@@ -158,19 +123,4 @@
         set.insert(PROPERTY_MODULENAME);
         return set;
     }
-
-    const Ogre::StringVector&amp; SaveGameFile::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SaveGameFile::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
-    {
-		mStream.bind(static_cast&lt;WriteableDataStream*&gt;(stream.get()));
-    }
-
-    Ogre::Real SaveGameFile::getLoadingOrder() const
-    {
-        return 1000.0f;
-    }
 }

Modified: rl/branches/persistence/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFileReader.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -34,60 +34,60 @@
 
     void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &amp;map)
     {
-        initializeXml();
+        //initializeXml();
 
-        mDocument = loadDocument(file-&gt;getDataStream());
+        //mDocument = loadDocument(file-&gt;getDataStream());
 
-        int version = getAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;);
-        if(version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
-            LOG_MESSAGE(Logger::CORE, &quot;Loading save game: Engine version is ok&quot;);
-        else
-            LOG_ERROR(Logger::CORE, &quot;Loading save game: Save game version is newer then engine version! Loading save game could crash&quot;);
+        //int version = getAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;);
+        //if(version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
+        //    LOG_MESSAGE(Logger::CORE, &quot;Loading save game: Engine version is ok&quot;);
+        //else
+        //    LOG_ERROR(Logger::CORE, &quot;Loading save game: Save game version is newer then engine version! Loading save game could crash&quot;);
 
-        for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
-        {
-            data_iter-&gt;second-&gt;readData(this);
-        }
+        //for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
+        //{
+        //    data_iter-&gt;second-&gt;readData(this);
+        //}
 
 
-        file-&gt;closeDataStream(); //make the save game writable
+        //file-&gt;closeDataStream(); //make the save game writable
 
-        mDocument = NULL;
+        //mDocument = NULL;
 
-        shutdownXml();
+        //shutdownXml();
     }
 
     void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName, SaveGameFile* file)
     {
-        initializeXml();
+        //initializeXml();
 
-        if(stream-&gt;size())
-        {
-            DOMDocument* doc = loadDocument(stream);
+        //if(stream-&gt;size())
+        //{
+        //    DOMDocument* doc = loadDocument(stream);
 
-             DOMNodeList* headerDefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;header&quot;).data());
-             if(headerDefsXml-&gt;getLength())
-             {
-                 DOMElement* elem = static_cast&lt;DOMElement*&gt;(headerDefsXml-&gt;item(0));
-                 /*DOMNodeList* headerDefChildren = elem-&gt;getChildNodes();
-                 for(XMLSize_t childIdx = 0; childIdx &lt; headerDefChildren-&gt;getLength(); childIdx++)
-                 {
-                     DOMNode* curChild = headerDefChildren-&gt;item(childIdx);
-                     if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                     {
-                         PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
-                         if(entry.first != &quot;&quot;)
-                         {
-                            file-&gt;setProperty(entry.first, entry.second);
-                         }
-                     }
-                 }*/
-                 PropertyRecordPtr set = getPropertiesAsRecord(elem);
-                 file-&gt;setProperties(set);
-             }
-        }
+        //     DOMNodeList* headerDefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;header&quot;).data());
+        //     if(headerDefsXml-&gt;getLength())
+        //     {
+        //         DOMElement* elem = static_cast&lt;DOMElement*&gt;(headerDefsXml-&gt;item(0));
+        //         /*DOMNodeList* headerDefChildren = elem-&gt;getChildNodes();
+        //         for(XMLSize_t childIdx = 0; childIdx &lt; headerDefChildren-&gt;getLength(); childIdx++)
+        //         {
+        //             DOMNode* curChild = headerDefChildren-&gt;item(childIdx);
+        //             if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+        //             {
+        //                 PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
+        //                 if(entry.first != &quot;&quot;)
+        //                 {
+        //                    file-&gt;setProperty(entry.first, entry.second);
+        //                 }
+        //             }
+        //         }*/
+        //         PropertyRecordPtr set = getPropertiesAsRecord(elem);
+        //         file-&gt;setProperties(set);
+        //     }
+        //}
 
-        shutdownXml();
+        //shutdownXml();
     }
 
     PropertyRecordPtr SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)

Modified: rl/branches/persistence/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -48,8 +48,31 @@
 	{
 		initializeXml();
 
+		XMLCh tempStr[100];
+        XMLString::transcode(&quot;LS&quot;, tempStr, 99);
+        mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
+		mTarget = file-&gt;getFormatTarget();
+		mWriter = static_cast&lt;DOMImplementationLS*&gt;(mImplementation)-&gt;createDOMWriter();
+		mDocument = static_cast&lt;DOMImplementation*&gt;(mImplementation)-&gt;createDocument(0, XMLString::transcode(&quot;SaveGameFile&quot;), 0);
 
+		 if (mWriter-&gt;canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
+            mWriter-&gt;setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
 
+        if (mWriter-&gt;canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
+             mWriter-&gt;setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
+
+		mDocument-&gt;setNodeValue(XMLString::transcode(&quot;SaveGameFile&quot;)); //Set name of document root node
+
+		setAttributeValueAsString(mDocument-&gt;getDocumentElement(), &quot;SaveGameFormatVersion&quot;, &quot;0.6&quot;);
+		setAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;, CoreSubsystem::getSingleton().getEngineBuildNumber());
+
+
+        mWriter-&gt;writeNode(mTarget, *mDocument);
+
+        mWriter-&gt;release();
+
+        delete mDocument;
+
 		shutdownXml();
 	}
 

Modified: rl/branches/persistence/core/src/SaveGameManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/core/src/SaveGameManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -56,15 +56,15 @@
 
     SaveGameManager::SaveGameManager() : mHighestSaveGameNumber(0)
     { 
-        Ogre::ResourceGroupManager::getSingleton().createResourceGroup(&quot;SaveGames&quot;);
+        //Ogre::ResourceGroupManager::getSingleton().createResourceGroup(&quot;SaveGames&quot;);
 
-        mScriptPatterns.push_back(&quot;*.save&quot;);
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+        //mScriptPatterns.push_back(&quot;*.save&quot;);
+        //Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
 
-        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
-            + &quot;/saves&quot;, &quot;FileSystem&quot;, &quot;SaveGames&quot;);
-        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(&quot;SaveGames&quot;);
-        Ogre::ResourceGroupManager::getSingleton().clearResourceGroup(&quot;SaveGames&quot;); //close all resource files -&gt; make them writable
+        //Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
+        //    + &quot;/saves&quot;, &quot;FileSystem&quot;, &quot;SaveGames&quot;);
+        //Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(&quot;SaveGames&quot;);
+        //Ogre::ResourceGroupManager::getSingleton().clearResourceGroup(&quot;SaveGames&quot;); //close all resource files -&gt; make them writable
     }
 
     SaveGameManager::~SaveGameManager()
@@ -92,33 +92,33 @@
 
     void SaveGameManager::saveSaveGameFile(const CeGuiString &amp;name)
     {
-        MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameSaving&gt;();
+    //    MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameSaving&gt;();
 
-        time_t rawTime;
-        tm* localTime; 
-        time(&amp;rawTime);
-        localTime = localtime(&amp;rawTime);
+    //    time_t rawTime;
+    //    tm* localTime; 
+    //    time(&amp;rawTime);
+    //    localTime = localtime(&amp;rawTime);
 
-        SaveGameFile* file = NULL;
+    //    SaveGameFile* file = NULL;
 
-        if(SaveGameFileExists(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()))
-        {
-             file = getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
-             //new SaveGameFile(name,getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId())-&gt;getId());
-        }
-        else
-        {
-            mHighestSaveGameNumber++;
-            file = new SaveGameFile(name, mHighestSaveGameNumber);
-        }
-        
-        file-&gt;setProperty(SaveGameFile::PROPERTY_TIME, Property(printTimeAsString(localTime)));
-        file-&gt;setProperty(SaveGameFile::PROPERTY_MODULEID, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()));
-        file-&gt;setProperty(SaveGameFile::PROPERTY_MODULENAME, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getName()));
+    //    if(SaveGameFileExists(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()))
+    //    {
+    //         file = getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
+    //         //new SaveGameFile(name,getSaveGameFile(name, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId())-&gt;getId());
+    //    }
+    //    else
+    //    {
+    //        mHighestSaveGameNumber++;
+    //        file = new SaveGameFile(name, mHighestSaveGameNumber);
+    //    }
+    //    
+    //    file-&gt;setProperty(SaveGameFile::PROPERTY_TIME, Property(printTimeAsString(localTime)));
+    //    file-&gt;setProperty(SaveGameFile::PROPERTY_MODULEID, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()));
+    //    file-&gt;setProperty(SaveGameFile::PROPERTY_MODULENAME, Property(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getName()));
 
-        mSaveGames[file-&gt;getId()] = file;
+    //    mSaveGames[file-&gt;getId()] = file;
 
-        SaveGameFileWriter writer;
+    //    SaveGameFileWriter writer;
         //writer.buildSaveGameFile(file, mSaveGameDataOrderMap);
 
         //freeSaveGameMap();
@@ -126,12 +126,12 @@
         //Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(&quot;SaveGames&quot;);
         //Ogre::ResourceGroupManager::getSingleton().clearResourceGroup(&quot;SaveGames&quot;); //close all resource files -&gt; make them writable
 
-        MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameSaved&gt;();
+        //MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameSaved&gt;();
     }
 
     void SaveGameManager::loadSaveGameFile(const CeGuiString &amp;name, const CeGuiString &amp;moduleId)
     {
-        if(SaveGameFileExists(name, moduleId))
+     /*   if(SaveGameFileExists(name, moduleId))
         {
             MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameLoading&gt;();
 
@@ -144,7 +144,7 @@
             ///@todo: SaveGameReader
 
             MessagePump::getSingleton().sendMessage&lt;MessageType_SaveGameLoaded&gt;();
-        }
+        }*/
     }
 
     void SaveGameManager::loadSaveGameFile(int id)
@@ -235,24 +235,24 @@
 
     void SaveGameManager::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
     {
-        Ogre::String name = stream-&gt;getName();
-        name = name.substr(0, name.length()-5); //delete &quot;.save&quot; at the and of the name
-        int pointpos = name.find_last_of(&quot;.&quot;);
-        name = name.substr(0, pointpos);
+        //Ogre::String name = stream-&gt;getName();
+        //name = name.substr(0, name.length()-5); //delete &quot;.save&quot; at the and of the name
+        //int pointpos = name.find_last_of(&quot;.&quot;);
+        //name = name.substr(0, pointpos);
 
-        if(Ogre::StringConverter::isNumber(name))
-        {
-            mHighestSaveGameNumber = std::max(mHighestSaveGameNumber, Ogre::StringConverter::parseInt(name));
+        //if(Ogre::StringConverter::isNumber(name))
+        //{
+        //    mHighestSaveGameNumber = std::max(mHighestSaveGameNumber, Ogre::StringConverter::parseInt(name));
 
-            SaveGameFile* file = new SaveGameFile(&quot;&quot;, Ogre::StringConverter::parseInt(name));        
-            
-            LOG_MESSAGE(Logger::RULES, &quot;Parsing header of save game: &quot; + name + &quot;.save&quot;);
-            SaveGameFileReader reader;
-            reader.parseSaveGameFileHeader(stream, groupName, file);
-            
-            if(file-&gt;getProperty(SaveGameFile::PROPERTY_MODULEID) != &quot;&quot;) // broken save game
-                mSaveGames[Ogre::StringConverter::parseInt(name)] = file;
-        }
+        //    SaveGameFile* file = new SaveGameFile(&quot;&quot;, Ogre::StringConverter::parseInt(name));        
+        //    
+        //    LOG_MESSAGE(Logger::RULES, &quot;Parsing header of save game: &quot; + name + &quot;.save&quot;);
+        //    SaveGameFileReader reader;
+        //    reader.parseSaveGameFileHeader(stream, groupName, file);
+        //    
+        //    if(file-&gt;getProperty(SaveGameFile::PROPERTY_MODULEID) != &quot;&quot;) // broken save game
+        //        mSaveGames[Ogre::StringConverter::parseInt(name)] = file;
+        //}
     }
 
     void SaveGameManager::registerSaveGameData(SaveGameData* data)

Modified: rl/branches/persistence/rules/include/ApplyDamageJob.h
===================================================================
--- rl/branches/persistence/rules/include/ApplyDamageJob.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/ApplyDamageJob.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,42 +1,43 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#ifndef __ApplyDamageJob__
-#define __ApplyDamageJob__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Job.h&quot;
-
-namespace rl
-{
-    class Creature;
-
-    class _RlRulesExport ApplyDamageJob : public Job
-    {
-    public:
-        ApplyDamageJob(Creature* target, int tp);
-        ~ApplyDamageJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-        Creature* mTarget;
-        int mTp;
-    };
-
-}
-
-#endif //__ApplyDamageJob__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#ifndef __ApplyDamageJob__
+#define __ApplyDamageJob__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Job.h&quot;
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport ApplyDamageJob : public Job
+    {
+    public:
+        ApplyDamageJob(Creature* target, int damage, int damageType);
+        ~ApplyDamageJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+        Creature* mTarget;
+        int mDamage;
+        int mType;
+    };
+
+}
+
+#endif //__ApplyDamageJob__

Modified: rl/branches/persistence/rules/include/Combat.h
===================================================================
--- rl/branches/persistence/rules/include/Combat.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Combat.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,153 +1,154 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBAT_H__
-#define __RL_COMBAT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;set&gt;
-#include &lt;vector&gt;
-#include &lt;boost/tuple/tuple.hpp&gt;
-
-#include &quot;JobListener.h&quot;
-#include &quot;Kampfaktion.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-    class Combatant;
-	class Creature;
-	class GameObject;
-	class JobSet;
-
-	class _RlRulesExport Combat : public JobListener
-    {
-    public:
-        typedef std::set&lt;Combatant*&gt; CombatantSet;
-
-        Combat(Ogre::Real maxDistance = 10.0f);
-        ~Combat();
-
-        void addOpponent(Combatant*);
-        Combatant* addOpponent(Creature*);
-
-        void removeOpponent(Combatant*);
-
-        void addAlly(Combatant*);
-        Combatant* addAlly(Creature*);
-
-        void removeAlly(Combatant*);
-
-        const CombatantSet getAllOpponents(Combatant* combatant) const;
-        const CombatantSet&amp; getAllPlayerOpponents() const;
-        const CombatantSet&amp; getAllPlayerAllies() const;
-
-        void start();
-        void pause();
-        void stop();
-
-        // Called by combatants in response to a request by the Combat object.
-        // With calling one of these functions combatants register their actions for this round.
-
-		void registerAttacke(Combatant* actor, Combatant* target);
-        void registerParade(Combatant* actor);
-        void registerAusweichen(Combatant* actor);
-		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
-		void registerFolgen(Combatant* actor, Combatant* target);
-		void registerCombatantRoundDone(Combatant* actor);
-
-		bool canAttack(Combatant* actor, Combatant* target) const;
-
-		// JobListener overrides
-
-        virtual void jobFinished(unsigned long ticket);
-
-
-    private:
-		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
-		typedef enum {PARADE, AUSWEICHEN} Reaktion;
-		struct ActionEntry
-		{
-			int id;
-			Aktion aktion;
-			Combatant* actor;
-			Combatant* target;
-			Ogre::Vector3 targetPos;
-		};
-		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
-		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
-		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
-        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
-
-        /// Combatants owned by this Combat are also stored here.
-		/// This is needed, in order to destroy removed combatant instances properly.
-		CombatantSet mOwnedCombatants;
-
-		CombatantSet mOpponents;
-        CombatantSet mAllies;
-        /// Combatants in order of their initiative for the current round.
-        CombatantQueue mCombatantQueue;
-        CombatantActionsMap mCombatantActions;
-		CombatantReactionsMap mCombatantReactions;
-		/// If a combatant is removed from combat it becomes invalid.
-		/// And thus can't be neither actors nor targets of actions.
-		/// This set stores such action ids.
-		std::set&lt;int&gt; mCancelledActions;
-		/// Store combatants that are removed in current round.
-		/// Instead of destroying them the moment they are out of combat,
-		/// we destroy them at the end of the current combat round.
-		/// This prevents all kinds of problems that dangling pointers would cause else.
-		CombatantSet mRemovedCombatants;
-		// Combatants who have registered all their actions for this round
-		CombatantSet mFinishedCombatants;
-		unsigned long mAnimationSequenceTicket;
-
-        unsigned short mCurrentRound;
-		unsigned short mNextActionId;
-		
-		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
-		/// he is considered fleeing
-		Ogre::Real mMaxDistance;
-
-		MessagePump::ScopedConnection mLifeStateChangeConnection;
-
-        void beginRound();
-        void executeRound();
-        void endRound();
-
-		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
-
-		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
-
-		/// Mark any action regarding this combatant as invalid.
-		/// Mark combatant as removed.
-		void checkAndMarkCombatant(Combatant* combatant);
-
-		/// Clear combatant list of removed combatants,
-		/// destroy combatants owned by this combat instance.
-		void clearRemovedCombatantSet();
-
-		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
-
-        // Message handlers
-        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBAT_H__
+#define __RL_COMBAT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &lt;set&gt;
+#include &lt;vector&gt;
+#include &lt;boost/tuple/tuple.hpp&gt;
+
+#include &quot;Creature.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;Kampfaktion.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesConstants.h&quot;
+
+namespace rl
+{
+    class Combatant;
+	class GameObject;
+	class JobSet;
+
+	class _RlRulesExport Combat : public JobListener
+    {
+    public:
+        typedef std::set&lt;Combatant*&gt; CombatantSet;
+
+        Combat(Ogre::Real maxDistance = 10.0f);
+        ~Combat();
+
+        void addOpponent(Combatant*);
+        Combatant* addOpponent(Creature*);
+
+        void removeOpponent(Combatant*);
+
+        void addAlly(Combatant*);
+        Combatant* addAlly(Creature*);
+
+        void removeAlly(Combatant*);
+
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet&amp; getAllPlayerOpponents() const;
+        const CombatantSet&amp; getAllPlayerAllies() const;
+
+        void start();
+        void pause();
+        void stop();
+
+        // Called by combatants in response to a request by the Combat object.
+        // With calling one of these functions combatants register their actions for this round.
+
+		void registerAttacke(Combatant* actor, Combatant* target);
+        void registerParade(Combatant* actor);
+        void registerAusweichen(Combatant* actor);
+		void registerBewegen(Combatant* actor, const Ogre::Vector3&amp; targetPos);
+		void registerFolgen(Combatant* actor, Combatant* target);
+		void registerCombatantRoundDone(Combatant* actor);
+
+		bool canAttack(Combatant* actor, Combatant* target) const;
+
+		// JobListener overrides
+
+        virtual void jobFinished(unsigned long ticket);
+
+
+    private:
+		typedef enum {ATTACKE, BEWEGEN, FOLGEN} Aktion;
+		typedef enum {PARADE, AUSWEICHEN} Reaktion;
+		struct ActionEntry
+		{
+			int id;
+			Aktion aktion;
+			Combatant* actor;
+			Combatant* target;
+			Ogre::Vector3 targetPos;
+		};
+		typedef std::vector&lt;ActionEntry&gt; ActionEntryVector;
+		typedef std::map&lt;Combatant*, ActionEntryVector&gt; CombatantActionsMap;
+		typedef std::map&lt;Combatant*, Reaktion&gt; CombatantReactionsMap;
+        typedef std::vector&lt;std::pair&lt;int, Combatant*&gt; &gt; CombatantQueue;
+
+        /// Combatants owned by this Combat are also stored here.
+		/// This is needed, in order to destroy removed combatant instances properly.
+		CombatantSet mOwnedCombatants;
+
+		CombatantSet mOpponents;
+        CombatantSet mAllies;
+        /// Combatants in order of their initiative for the current round.
+        CombatantQueue mCombatantQueue;
+        CombatantActionsMap mCombatantActions;
+		CombatantReactionsMap mCombatantReactions;
+		/// If a combatant is removed from combat it becomes invalid.
+		/// And thus can't be neither actors nor targets of actions.
+		/// This set stores such action ids.
+		std::set&lt;int&gt; mCancelledActions;
+		/// Store combatants that are removed in current round.
+		/// Instead of destroying them the moment they are out of combat,
+		/// we destroy them at the end of the current combat round.
+		/// This prevents all kinds of problems that dangling pointers would cause else.
+		CombatantSet mRemovedCombatants;
+		// Combatants who have registered all their actions for this round
+		CombatantSet mFinishedCombatants;
+		unsigned long mAnimationSequenceTicket;
+
+        unsigned short mCurrentRound;
+		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, if a combatant is exceeding this distance to all its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
+
+		MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        void beginRound();
+        void executeRound();
+        void endRound();
+
+		void doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target);
+        void doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target);
+
+		Ogre::Real getMaximumAttackeDistance(Combatant* actor) const;
+
+		/// Mark any action regarding this combatant as invalid.
+		/// Mark combatant as removed.
+		void checkAndMarkCombatant(Combatant* combatant);
+
+		/// Clear combatant list of removed combatants,
+		/// destroy combatants owned by this combat instance.
+		void clearRemovedCombatantSet();
+
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet&amp; enemies) const;
+
+        // Message handlers
+        bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
+    };
+}
+
+#endif

Modified: rl/branches/persistence/rules/include/Combatant.h
===================================================================
--- rl/branches/persistence/rules/include/Combatant.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Combatant.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,111 +1,112 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_COMBATANT_H__
-#define __RL_COMBATANT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-namespace rl
-{
-    class Combat;
-    class Creature;
-    class CreatureController;
-	class Kampfaktion;
-	class JobSet;
-	class Weapon;
-
-    /// Base class of combat participiants. This defines the interface Combat uses
-	/// to communicate with Combatants. Be it AI bots or actual users.
-	class _RlRulesExport Combatant
-    {
-    public:
-        Combatant(Combat* combat, CreatureController* controller);
-        virtual ~Combatant();
-
-        /// This function is called by the Combat the Combatantant is taking part in,
-        /// in order to request it to register actions for the next round.
-        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
-        /// The call is not required to be done immediatly,
-        /// it can be done synchronously or asynchronously.
-        virtual void requestCombatantAction() = 0;
-
-        /// Type name used by factory
-		virtual Ogre::String getCombatantTypeName() const = 0;
-
-        CreatureController* getCreatureController() const;
-
-		// convenience getters
-
-        Creature* getCreature() const;
-		CeGuiString getName() const;
-		Ogre::Vector3 getPosition() const;
-
-		Weapon* getActiveWeapon() const;
-
-        /**
-        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
-        *  aufgerufen.
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
-        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
-        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
-        **/
-        int rollAttacke();
-
-        /**
-        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
-              *  aufgerufen.
-        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
-        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
-        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
-        *  @retval RESULT_GLUECKLICH Eine gute Parade.
-        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
-        *  @throws InvalidArgumentException Kampftechnik nicht in 
-        *   \c mKampftechniken gefunden.
-        **/
-		int rollParade(bool gluecklich);
-
-		int rollTrefferpunkte() const;
-		int applyTrefferpunkte(int tp);
-
-		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
-			int paradeResult = 0);
-		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
-		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
-		void doFolgen(JobSet* jobSet, Combatant* target);
-		void doGetroffen(JobSet* jobSet);
-
-    protected:
-        Combat* mCombat;
-        CreatureController* mController;
-
-		/// Converts canonic animation to actual animation name inside the skeleton
-		/// According to the mapping defined in Creature gof.
-		Ogre::String getMeshAnimationName(const Ogre::String animationName);
-    };
-
-    class _RlRulesExport CombatantFactory
-    {
-    public:
-        virtual ~CombatantFactory() {}
-
-        virtual Combatant* createCombatant(Creature* creature) = 0;
-        virtual void destroyCombatant(Combatant*) = 0;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Creature.h&quot;
+
+namespace rl
+{
+    class Combat;
+    class CreatureController;
+	class Kampfaktion;
+	class JobSet;
+	class Weapon;
+
+    /// Base class of combat participiants. This defines the interface Combat uses
+	/// to communicate with Combatants. Be it AI bots or actual users.
+	class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(Combat* combat, CreatureController* controller);
+        virtual ~Combatant();
+
+        /// This function is called by the Combat the Combatantant is taking part in,
+        /// in order to request it to register actions for the next round.
+        /// In response to this call Combatant is supposed to call Combat#registerCombatantAction.
+        /// The call is not required to be done immediatly,
+        /// it can be done synchronously or asynchronously.
+        virtual void requestCombatantAction() = 0;
+
+        /// Type name used by factory
+		virtual Ogre::String getCombatantTypeName() const = 0;
+
+        CreatureController* getCreatureController() const;
+
+		// convenience getters
+
+        Creature* getCreature() const;
+		CeGuiString getName() const;
+		Ogre::Vector3 getPosition() const;
+
+		Weapon* getActiveWeapon() const;
+
+        /**
+        *  Fuehrt eine Attacke aus. Die Funktion wird von einem Angriffsmanoever 
+        *  aufgerufen.
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Attacke.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Attacke.
+        *  @retval RESULT_GLUECKLICH Eine gute Attacke.
+        *  @retval RESULT_PATZER Ein bestaetigter Attackepatzer.
+        **/
+        int rollAttacke();
+
+        /**
+        *  Fuehrt eine Parade aus. Die Funktion wird von einem Parademanoever 
+              *  aufgerufen.
+        *  @param guteParade Versucht eine gute Parade (bei einem gluecklichen Treffer)
+        *  @retval RESULT_ERFOLG Eine erfolgreiche Parade.
+        *  @retval RESULT_MISSERFOLG Eine fehlgeschlagene Parade.
+        *  @retval RESULT_GLUECKLICH Eine gute Parade.
+        *  @retval RESULT_PATZER Ein bestaetigter Paradepatzer.
+        *  @throws InvalidArgumentException Kampftechnik nicht in 
+        *   \c mKampftechniken gefunden.
+        **/
+		int rollParade(bool gluecklich);
+
+		int rollTrefferpunkte(DamageStrength damage) const;
+		int applyTrefferpunkte(int tp);
+
+		void doAttacke(JobSet* jobSet, Combatant* target, int attackeResult, bool parade,
+			int paradeResult = 0);
+		void doParade(JobSet* jobSet, Combatant* target, int paradeResult);
+		void doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos);
+		void doFolgen(JobSet* jobSet, Combatant* target);
+		void doGetroffen(JobSet* jobSet);
+
+    protected:
+        Combat* mCombat;
+        CreatureController* mController;
+
+		/// Converts canonic animation to actual animation name inside the skeleton
+		/// According to the mapping defined in Creature gof.
+		Ogre::String getMeshAnimationName(const Ogre::String animationName);
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/branches/persistence/rules/include/Creature.h
===================================================================
--- rl/branches/persistence/rules/include/Creature.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Creature.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -73,8 +73,14 @@
     static const int RESULT_ERFOLG = 1;
     /// Eine normal misslungene Attacke oder Parade
     static const int RESULT_MISSERFOLG = -1;
+   
+    enum DamageStrength {
+        DMG_NONE,
+        DMG_HALF,
+        DMG_NORMAL,
+        DMG_DOUBLE
+    };
 
-
     /// Basistalente
     /// @todo Passenderen Ort suchen
     static const CeGuiString TALENT_ART_BASIS = &quot;Basis&quot;;
@@ -632,7 +638,7 @@
              **/
             int doInitiativeWurf(bool getMaxInitiative = false);
 
-			int doTrefferpunkteWurf(Weapon* weapon) const;
+			int doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const;
 
             /**
              *  Fuegt der Kreatur \a tp @ref abbdet &quot;Trefferpunkte&quot; zu.
@@ -642,10 +648,11 @@
              **/
             void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
             static const int LEDAMAGE_NORMAL = 0;
-            static const int LEDAMAGE_FIRE = 1;
-            static const int LEDAMAGE_WATER = 2;
-            static const int LEDAMAGE_DEMONIC = 4;
-            static const int LEDAMAGE_TP_A = 8;
+            static const int LEDAMAGE_SP = 1;
+            static const int LEDAMAGE_FIRE = 2;
+            static const int LEDAMAGE_WATER = 4;
+            static const int LEDAMAGE_DEMONIC = 8;
+            static const int LEDAMAGE_TP_A = 16;
 
             /**
              *  Zieht der Kreatur \a asp @ref abbdea &quot;Astralpunkte&quot; ab.

Modified: rl/branches/persistence/rules/include/QuestBook.h
===================================================================
--- rl/branches/persistence/rules/include/QuestBook.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/QuestBook.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -67,7 +67,8 @@
 	 *@param params Params needed for creation
 	 *@return SaveAble which has been created
 	 */
-	SaveAblePtr createSaveAble(PropertyRecordPtr params);
+	SaveAblePtr createSaveAble(const CeGuiString &amp;id, PropertyRecordPtr params);
+	virtual void removeSaveAble(const CeGuiString &amp;id);
 
     /**
      *  Adds a journal entry to the quest book.

Modified: rl/branches/persistence/rules/include/Slot.h
===================================================================
--- rl/branches/persistence/rules/include/Slot.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Slot.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -1,92 +1,224 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __SLOT_H__
-#define __SLOT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-namespace rl {
-
-class Creature;
-class Item;
-
-class _RlRulesExport Slot
-{
-public:
-    Slot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask);
-    virtual ~Slot();
-
-    // provides standard behaviour, sets
-    // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
-    // subclasses MUST call this method when overriding
-    virtual bool setItem(Item* item);
-    virtual void update(); // this must only be called from creature::doPlaceIntoScene
-    Item* getItem() const;
-    bool isAllowed(const Item* item) const;
-    bool isEmpty() const {return mItem == NULL;}
-    bool canReady(const Item* item) const;
-	bool isReady() { return mItem != NULL &amp;&amp; canReady(mItem); }
-    CeGuiString getName() const {return mName;}
-
-protected:
-
-    Creature* mOwner;
-    Item* mItem;
-
-private:
-    CeGuiString mName;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemHeldMask;
-    /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
-    int mItemReadyMask;
-};
-
-class BoneSlot : public Slot
-{
-public:
-    BoneSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; bone);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mBone;
-};
-
-class SubmeshSlot : public Slot
-{
-public:
-    SubmeshSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-class MaterialSlot : public Slot
-{
-public:
-    MaterialSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
-    virtual bool setItem(Item* item);
-    virtual void update();
-
-private:
-    Ogre::String mSubmesh;
-};
-
-} // namespace rl
-
-#endif //__SLOT_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __SLOT_H__
+#define __SLOT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+namespace rl {
+    
+    class Creature;
+    class Item;
+    
+    /**
+     * A class to represent a place where an Item can be attached to a creature
+     *
+     */
+    class _RlRulesExport Slot
+    {
+    public:
+        
+        /**
+         * Creates a slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         */
+        Slot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask);
+        virtual ~Slot();
+        
+        /**
+         * Puts an item into the slot, may depend on the actual slot type
+         *
+         * Note: this method provides standard behaviour, sets item-state etc
+         * subclasses MUST call this method when overriding
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * Updates the slot to match the owner's state
+         *
+         * Note: this must only be called from Creature::doPlaceIntoScene
+         */
+        virtual void update();
+        
+        /**
+         * Gets the item in the slot
+         *
+         * @returns the item, NULL if the slot is empty
+         */
+        Item* getItem() const;
+        
+        /**
+         * Check if an item can be held in this slot
+         *
+         * @param item an item
+         * @returns true if the item can be put into this slot, false otherwise
+         */
+        bool isAllowed(const Item* item) const;
+        
+        /** 
+         * Check if the slot is empty
+         *
+         * @returns true if the slot is empty, false otherwise
+         */
+        bool isEmpty() const {return mItem == NULL;}
+        
+        /**
+         * Check if an item is readied in this slot (e.g. trousers in the legs slot) or not (e.g. trousers in the left hand slot)
+         *
+         * @param item an item
+         * @returns true if the item is readied in this slot, false otherwise
+         */
+        bool canReady(const Item* item) const;
+        
+        /**
+         * Check if the slot holds a ready item
+         *
+         */
+        bool isReady() { return mItem != NULL &amp;&amp; canReady(mItem); }
+        
+        /**
+         * Get the slot's name
+         *
+         * @returns the name
+         */
+        CeGuiString getName() const {return mName;}
+        
+    protected:
+        
+        Creature* mOwner;
+        Item* mItem;
+        
+    private:
+        CeGuiString mName;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemHeldMask;
+        /// die mItemReadyMask hat Vorrang vor der mItemHeldMask
+        int mItemReadyMask;
+    };
+    
+    /**
+     * A slot implemented by a model bone, if objects are put into the slot, their models are attached at the bone
+     */
+    class BoneSlot : public Slot
+    {
+    public:
+        
+        /**
+         * Creates a bone slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param bone the bone name
+         */
+        BoneSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; bone);
+        
+        /**
+         * Puts an item into the slot by attaching its mesh to the bone of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mBone;
+    };
+    
+    /**
+     * A slot implemented by a submesh &quot;baked&quot; into the owner mesh. If an item is put into that slot it creates or 
+     * replaces a specified submesh, this is used for armor to be able to animate the armor meshes on an easy way
+     *
+     * Note: the item meshes must have the same skeleton as the owner mesh
+     */
+    class SubmeshSlot : public Slot
+    {
+    public:
+
+        /**
+         * Creates a submesh slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        SubmeshSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
+
+        /**
+         * Puts an item into the slot by creating or replacing a submesh in the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+    /**
+     * A slot implemented by changing a material on a specified submesh of the owner mesh. This is used for clothes.
+     */
+    class MaterialSlot : public Slot
+    {
+    public:
+        /**
+         * Creates a material slot
+         *
+         * @param owner the slot's owner
+         * @param name the slot's name, it is used to find the slot when adding or removing items
+         * @param itemReadyMask an item type mask for items to be readied automatically when put into the slot
+         * @param itemHeldMask an item type mask for the items the slot is able to hold
+         * @param submesh the submesh name
+         */
+        MaterialSlot(Creature* owner, const CeGuiString&amp; name, int itemReadyMask, int itemHeldMask, const Ogre::String&amp; submesh);
+
+        /**
+         * Puts an item into the slot by replacing the material in one submesh of the slot owner mesh
+         *
+         * @returns true, if succeeded to set item, false indicates to to nothing
+         */
+        virtual bool setItem(Item* item);
+        
+        /**
+         * @copydoc Slot::update
+         */
+        virtual void update();
+        
+    private:
+        Ogre::String mSubmesh;
+    };
+    
+} // namespace rl
+
+#endif //__SLOT_H__

Modified: rl/branches/persistence/rules/include/Weapon.h
===================================================================
--- rl/branches/persistence/rules/include/Weapon.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/include/Weapon.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -49,6 +49,7 @@
         static const Ogre::String PROPERTY_TP_DK;
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
+        static const Ogre::String PROPERTY_AVOID_ARMOR;
 
 		Weapon (const CeGuiString &amp;id);
         virtual ~Weapon(void);
@@ -70,6 +71,8 @@
 		const CeGuiString&amp; getKampftechnik() const;
         void setNatural(bool natural);
         bool isNatural() const;
+        void setAvoidArmor(bool avoid);
+        bool isAvoidingArmor() const;
 
 		/// Return minimum distance in meters where weapon can be used without penalty.
 		Ogre::Real getMinimumDistance() const;
@@ -89,6 +92,7 @@
 		int mDk;
 		CeGuiString mKampftechnik;
         bool mNatural;
+        bool mAvoidArmor;
 	};
 }
 

Modified: rl/branches/persistence/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -20,11 +20,11 @@
 
 namespace rl 
 {
-
-ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
+ApplyDamageJob::ApplyDamageJob(Creature* target, int damage, int damageType)
 :   Job(&quot;&quot;,false, true, TimeSource::GAMETIME, Job::PERSISTENT),
     mTarget(target), 
-    mTp(tp)
+    mDamage(damage),
+    mType(damageType)
 {
 }
 
@@ -34,7 +34,7 @@
 
 bool ApplyDamageJob::execute(Ogre::Real time)
 {
-    mTarget-&gt;damageLe(mTp);
+    mTarget-&gt;damageLe(mDamage, mType);
     return true;
 }
 

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -377,13 +377,13 @@
 					    }
 					    else if (entry.aktion == BEWEGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft nach &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft nach &quot;
 							    + CeGuiString(StringConverter::toString(entry.targetPos)), GET_COMBAT);
 						    combatant-&gt;doBewegen(jobSetAnims, entry.targetPos);
 					    }
 					    else if (entry.aktion == FOLGEN)
 					    {
-						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#228;uft zu &quot;
+						    GameEventLog::getSingleton().logEvent(combatant-&gt;getName() + &quot; l&#226;&#128;&#176;uft zu &quot;
 							    + entry.target-&gt;getName(), GET_COMBAT);
 						    combatant-&gt;doFolgen(jobSetAnims, entry.target);
 					    }
@@ -401,24 +401,35 @@
     {
 		clearRemovedCombatantSet();
 
+        CombatantSet removedAllies, removedOpponents;
+        
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mOpponents))
             {
-                removeAlly(*it);
+                removedAllies.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedAllies.begin(); it != removedAllies.end(); ++it)
+        {
+            removeAlly(*it);
+        }
+        
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
             if (isOutOfCombatRange(*it, mAllies))
             {
-                removeOpponent(*it);
+                removedOpponents.insert(*it);
             }
         }
+        for (CombatantSet::iterator it = removedOpponents.begin(); it != removedOpponents.end(); ++it)
+        {
+            removeOpponent(*it);
+        }
+        
+        clearRemovedCombatantSet();
 
-		clearRemovedCombatantSet();
-
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -437,17 +448,12 @@
 
     void Combat::doAttacke(JobSet* jobSetAnims, JobSet* jobSetDamage, Combatant* actor, Combatant* target)
 	{
-        enum Damage {
-            DMG_NONE,
-            DMG_HALF,
-            DMG_NORMAL,
-            DMG_DOUBLE
-        };
+        bool damageSp = false;
         
         GameEventLog::getSingleton().logEvent(
             actor-&gt;getName() + &quot; attackiert &quot; + target-&gt;getName(), GET_COMBAT);
         
-        Damage rollDamage = DMG_NONE;
+        DamageStrength rollDamage = DMG_NONE;
 		// Make an attack roll.
 		int aresult = actor-&gt;rollAttacke();
         
@@ -474,14 +480,20 @@
 					if (presult &gt;= RESULT_ERFOLG)
 					{
 						GameEventLog::getSingleton().logEvent(&quot;Erfolg, aber pariert.&quot;, GET_COMBAT);
-                        if (target-&gt;getActiveWeapon()-&gt;isNatural())
+                        if (target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; !actor-&gt;getActiveWeapon()-&gt;isNatural())
                         {
                             rollDamage = DMG_HALF;
                         }
+                        else if (!target-&gt;getActiveWeapon()-&gt;isNatural() &amp;&amp; actor-&gt;getActiveWeapon()-&gt;isNatural())
+                        {
+                            doDamage(jobSetDamage, DMG_HALF, target, actor);
+                            rollDamage = DMG_NONE;
+                        }
                         else
                         {
                             rollDamage = DMG_NONE;
                         }
+                        damageSp = target-&gt;getActiveWeapon()-&gt;isAvoidingArmor();
 					}
 					else
 					{
@@ -510,18 +522,23 @@
 			target-&gt;doGetroffen(jobSetAnims);
 		}
 		
-		if (rollDamage != DMG_NONE) ///@todo half/double damage
+        doDamage(jobSetDamage, rollDamage, actor, target);
+	}
+    
+    void Combat::doDamage(JobSet* jobSet, DamageStrength damageStrength, Combatant* actor, Combatant* target)
+    {
+        if (damageStrength != DMG_NONE) ///@todo half/double damage
 		{
-			int tp = actor-&gt;rollTrefferpunkte();
-            jobSetAnims-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp));
-
-			CeGuiString msg = actor-&gt;getName() + &quot; trifft f&#252;r &quot;
+			int tp = actor-&gt;rollTrefferpunkte(damageStrength);
+            jobSet-&gt;add(new ApplyDamageJob(target-&gt;getCreature(), tp, Creature::LEDAMAGE_SP));
+            
+			CeGuiString msg = actor-&gt;getName() + &quot; trifft fuer &quot;
             + CeGuiString(StringConverter::toString(tp))
             + &quot; Trefferpunkte&quot;;
 			GameEventLog::getSingleton().logEvent(msg, GET_COMBAT);
 		}
-	}
-    
+        
+    }
 
     void Combat::jobFinished(unsigned long ticket)
 	{
@@ -546,7 +563,7 @@
 					CeGuiString msg = curCreature-&gt;getName() + &quot; ist jetzt &quot;;
 					if (newstate == Effect::LS_INCAPACITATED)
 					{
-						msg += &quot;kampfunf&#228;hig.&quot;;
+						msg += &quot;kampfunf&#226;&#128;&#176;hig.&quot;;
 					}
                     else if (newstate == Effect::LS_UNCONSCIOUS)
 					{

Modified: rl/branches/persistence/rules/src/Combatant.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combatant.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Combatant.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -85,9 +85,9 @@
 		return getCreature()-&gt;doParade(weapon-&gt;getKampftechnik(), 0, gluecklich);
 	}
 
-	int Combatant::rollTrefferpunkte() const
+	int Combatant::rollTrefferpunkte(DamageStrength damage) const
 	{
-		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon());
+		return getCreature()-&gt;doTrefferpunkteWurf(getActiveWeapon(), damage);
 	}
 
 	int Combatant::applyTrefferpunkte(int tp)

Modified: rl/branches/persistence/rules/src/Creature.cpp
===================================================================
--- rl/branches/persistence/rules/src/Creature.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Creature.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -861,8 +861,13 @@
 		return rval;
 	}
 
-	int Creature::doTrefferpunkteWurf(Weapon* weapon) const
+	int Creature::doTrefferpunkteWurf(Weapon* weapon, DamageStrength damage) const
 	{
+        if (damage == DMG_NONE)
+        {
+            return 0;
+        }
+        
 		// Roll dice
 		const Tripel&lt;int&gt;&amp; weaponTp = weapon-&gt;getTp();
 		int rval = DsaManager::getSingleton().roll(weaponTp.first, weaponTp.second);
@@ -875,6 +880,15 @@
 		
 		int bonus = (kk - tpkk.first) / tpkk.second;
 		rval += bonus;
+        
+        if (damage == DMG_HALF)
+        {
+            rval = (rval + 1) / 2;
+        }
+        else if (damage == DMG_DOUBLE)
+        {
+            rval *= 2; ///@TODO check if correct
+        }
 
 		return rval;
 	}
@@ -890,27 +904,31 @@
         }
 
         ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType &amp; LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
+        if (damageType &amp; LEDAMAGE_FIRE)
         {
             LOG_ERROR(&quot;Creature&quot;, &quot;Fire damage not handled!&quot;); ///@todo implement
         }
-        if ((damageType &amp; LEDAMAGE_WATER) == LEDAMAGE_WATER)
+        if (damageType &amp; LEDAMAGE_WATER)
         {
             LOG_ERROR(&quot;Creature&quot;, &quot;Water damage not handled!&quot;); ///@todo implement
         }
-        if ((damageType &amp; LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
+        if (damageType &amp; LEDAMAGE_DEMONIC)
         {
             LOG_ERROR(&quot;Creature&quot;, &quot;Demonic damage not handled!&quot;); ///@todo implement
         }
 
-        if ((damageType &amp; LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
+        if (damageType &amp; LEDAMAGE_TP_A)
         {
             damageAu(tp, AUDAMAGE_NORMAL);
             tp = (int)floor(tp/2.);
         }
 
-        int rs = getWert(WERT_RS);
-        int sp = -tp + rs;
+        int sp = -tp;
+        if (!(damageType &amp; LEDAMAGE_SP))
+        {
+            int rs = getWert(WERT_RS);
+            sp += rs;            
+        }
 		modifyLe(sp);
 
         if (sp &gt;= getEigenschaft(&quot;KO&quot;))
@@ -1293,12 +1311,13 @@
     {
         GameObject::doRemoveFromScene();
 
+        ///@todo check if this is really necessary
         // check items in inventory
-        Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
-        Inventory::SlotMap::iterator it = slots.begin();
-        for( ; it != slots.end(); it++ )
-        {
-            it-&gt;second-&gt;update();
-        }
+        //Inventory::SlotMap slots = mInventory-&gt;getAllSlots();
+        //Inventory::SlotMap::iterator it = slots.begin();
+        //for( ; it != slots.end(); it++ )
+        //{
+        //    it-&gt;second-&gt;update();
+        //}
     }
 }

Modified: rl/branches/persistence/rules/src/QuestBook.cpp
===================================================================
--- rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/QuestBook.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -84,13 +84,18 @@
 	    mRootQuest-&gt;addSubquest(quest);
     }
 
-	SaveAblePtr QuestBook::createSaveAble(PropertyRecordPtr params)
+	SaveAblePtr QuestBook::createSaveAble(const CeGuiString &amp;id, PropertyRecordPtr params)
 	{
 		SaveAblePtr ptr;
 		ptr.bind(static_cast&lt;SaveAble*&gt;(new Quest(&quot;&quot;))); //TODO !!!!!
+		_fireQuestBookChanged(static_cast&lt;Quest*&gt;(ptr.get()), 0);
 		return ptr; // TODO
 	}
 
+	void QuestBook::removeSaveAble(const CeGuiString &amp;id)
+	{
+	}
+
     void QuestBook::_fireQuestBookChanged(Quest *quest, int reason)
     {
 	    QuestEvent* evt = new QuestEvent(this, reason);

Modified: rl/branches/persistence/rules/src/Weapon.cpp
===================================================================
--- rl/branches/persistence/rules/src/Weapon.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/rules/src/Weapon.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -37,6 +37,8 @@
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = &quot;kampftechnik&quot;;
     const Ogre::String Weapon::PROPERTY_NATURAL = &quot;natural&quot;;
 
+    const Ogre::String Weapon::PROPERTY_AVOID_ARMOR = &quot;avoidarmor&quot;;
+    
 	Weapon::Weapon(const CeGuiString &amp;id)
 		: Item(id),
         mTp(0, 0, 0),
@@ -46,7 +48,8 @@
 		mWm(0, 0),
         mDk(DK_H),
         mKampftechnik(&quot;&quot;),
-        mNatural(false)
+        mNatural(false),
+        mAvoidArmor(false)
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 		mItemType = ITEMTYPE_WEAPON;
@@ -184,7 +187,17 @@
     {
         mNatural = natural;
     }
-
+    
+    bool Weapon::isAvoidingArmor() const
+    {
+        return mAvoidArmor;
+    }
+    
+    void Weapon::setAvoidArmor(bool avoid)
+    {
+        mAvoidArmor = avoid;
+    }
+    
     void Weapon::setProperty(const CeGuiString&amp; key, const Property&amp; value)
     {
         if (key == Weapon::PROPERTY_TP)
@@ -239,6 +252,10 @@
         {
             mNatural = value.toBool();
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            mAvoidArmor = value.toBool();
+        }
         else
         {
             Item::setProperty(key, value);
@@ -296,6 +313,10 @@
         {
             return Property(mNatural);
         }
+        else if (key == Weapon::PROPERTY_AVOID_ARMOR)
+        {
+            return Property(mAvoidArmor);
+        }
         else
         {
             return Item::getProperty(key);
@@ -313,6 +334,7 @@
         keys.insert(Weapon::PROPERTY_TP_DK);
         keys.insert(Weapon::PROPERTY_TP_KAMPFTECHNIK);
         keys.insert(Weapon::PROPERTY_NATURAL);
+        keys.insert(Weapon::PROPERTY_AVOID_ARMOR);
         return keys;
     }
 }

Modified: rl/branches/persistence/ui/include/WindowManager.h
===================================================================
--- rl/branches/persistence/ui/include/WindowManager.h	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/include/WindowManager.h	2008-12-05 18:15:18 UTC (rev 4635)
@@ -19,6 +19,8 @@
 
 #include &quot;UiPrerequisites.h&quot;
 
+#include &quot;MessagePump.h&quot;
+
 namespace rl {
 
 	class AbstractWindow;
@@ -33,6 +35,7 @@
 		void registerWindow(AbstractWindow* window);
 		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
+        bool destroyAllWindows();
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);
 		bool handleMovedToBack(AbstractWindow* window);
@@ -47,6 +50,7 @@
 
 	private:
 		std::list&lt;AbstractWindow*&gt; mWindowList;
+        MessagePump::ScopedConnection mSceneClearConnection;
 
         unsigned short mNumActiveWindowsMouseInput;
         unsigned short mNumActiveWindowsKeyboardInput;

Modified: rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/src/GameSaveLoadWindow.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -35,6 +35,7 @@
 #include &quot;WindowFactory.h&quot;
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;SaveGameManager.h&quot;
+#include &quot;SaveAbleSerializer.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;ContentModule.h&quot;
 
@@ -104,8 +105,7 @@
 
     void GameSaveLoadWindow::initialize()
     {
-        //mSaveGameTable-&gt;autoSizeColumnHeader(0);
-        //mSaveGameTable-&gt;autoSizeColumnHeader(1);
+		listSaveGames();
     }
 
     //------------------------------------------------------- LoadEvent
@@ -137,7 +137,7 @@
 
         if(filename != &quot;&quot;)
         {
-
+			if(SaveAbleSerializer::getSingleton().SaveGameExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()));
         }
         else
         {
@@ -159,8 +159,23 @@
 
     void GameSaveLoadWindow::listSaveGames()
     {
-        //mSaveGameTable-&gt;autoSizeColumnHeader(0);
-        //mSaveGameTable-&gt;autoSizeColumnHeader(1);
+		mSaveGameTable-&gt;clearAllSelections();
+
+		while(mSaveGameTable-&gt;getRowCount() &gt; 0)
+			mSaveGameTable-&gt;removeRow(0);
+
+		SaveGameEntryMap saveGames = SaveAbleSerializer::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
+		int count = saveGames.size();
+
+		for(int i = 0; i &lt; count; i++)
+		{
+			mSaveGameTable-&gt;addRow(i);
+			mSaveGameTable-&gt;setItem(new ListboxTextItem(saveGames[i]-&gt;getName(),0,saveGames[i]),0,i); 
+			mSaveGameTable-&gt;setItem(new ListboxTextItem(saveGames[i]-&gt;getProperty(SaveGameFile::PROPERTY_TIME).toString()),1,i);
+		}
+
+        mSaveGameTable-&gt;autoSizeColumnHeader(0);
+        mSaveGameTable-&gt;autoSizeColumnHeader(1);
     }
 
     bool GameSaveLoadWindow::handleSelectSaveGame()

Modified: rl/branches/persistence/ui/src/WindowManager.cpp
===================================================================
--- rl/branches/persistence/ui/src/WindowManager.cpp	2008-12-04 21:35:17 UTC (rev 4634)
+++ rl/branches/persistence/ui/src/WindowManager.cpp	2008-12-05 18:15:18 UTC (rev 4635)
@@ -18,8 +18,9 @@
 #include &quot;WindowManager.h&quot;
 #include &lt;CEGUIWindowManager.h&gt;
 
+#include &quot;AbstractWindow.h&quot;
+#include &quot;CoreMessages.h&quot;
 #include &quot;CoreSubsystem.h&quot;
-#include &quot;AbstractWindow.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;GameLoop.h&quot;
 #include &quot;UiSubsystem.h&quot;
@@ -35,6 +36,8 @@
           mNumActiveWindowsMouseInput(0),
           mNumActiveWindowsKeyboardInput(0)
 	{
+        mSceneClearConnection = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneClearing&gt;(
+            boost::bind(&amp;WindowManager::destroyAllWindows, this));
 	}
 
 	WindowManager::~WindowManager()
@@ -123,10 +126,9 @@
     AbstractWindow* WindowManager::getActiveWindow()
     {
         // iterate through windows
-        std::list&lt;AbstractWindow*&gt;::iterator it;
-        for( it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        for (std::list&lt;AbstractWindow*&gt;::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
         {
-            if( (*it)-&gt;getWindow()-&gt;isActive() )
+            if ( (*it)-&gt;getWindow()-&gt;isActive() )
             {
                 return *it;
             }
@@ -134,4 +136,23 @@
 
         return NULL;
     }
+
+    bool WindowManager::destroyAllWindows()
+    {
+        for (std::list&lt;AbstractWindow*&gt;::iterator it = mWindowList.begin(); it != mWindowList.end(); it++ )
+        {
+            AbstractWindow* cur = *it;
+//			if (cur-&gt;isVisible())
+//			{
+				cur-&gt;setVisible(false, true);
+//			}
+//          else 
+//          {
+//              delete cur;
+//          }
+        }
+
+        mWindowList.clear();
+        return true;
+    }
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001691.html">[Dsa-hl-svn] r4634 - in modules/regressiontest: dialogs dsa scripts
</A></li>
	<LI>Next message: <A HREF="001693.html">[Dsa-hl-svn] r4636 - in rl/branches/persistence: core/include	core/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1692">[ date ]</a>
              <a href="thread.html#1692">[ thread ]</a>
              <a href="subject.html#1692">[ subject ]</a>
              <a href="author.html#1692">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
