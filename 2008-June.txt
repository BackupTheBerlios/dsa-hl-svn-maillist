From josch at mail.berlios.de  Sun Jun  1 15:21:40 2008
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Sun, 1 Jun 2008 15:21:40 +0200
Subject: [Dsa-hl-svn] r4392 - in rl/trunk/engine/script: include src
Message-ID: <200806011321.m51DLegZ017177@sheep.berlios.de>

Author: josch
Date: 2008-06-01 15:21:35 +0200 (Sun, 01 Jun 2008)
New Revision: 4392

Modified:
   rl/trunk/engine/script/include/SceneLoader.h
   rl/trunk/engine/script/src/SceneManager.cpp
Log:
Fixed Singleton declaration of SceneManager to make GCC happy

Modified: rl/trunk/engine/script/include/SceneLoader.h
===================================================================
--- rl/trunk/engine/script/include/SceneLoader.h	2008-05-31 09:22:14 UTC (rev 4391)
+++ rl/trunk/engine/script/include/SceneLoader.h	2008-06-01 13:21:35 UTC (rev 4392)
@@ -31,4 +31,4 @@
     };
 }
 
-#endif // __SceneLoader_H__
\ No newline at end of file
+#endif // __SceneLoader_H__

Modified: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2008-05-31 09:22:14 UTC (rev 4391)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2008-06-01 13:21:35 UTC (rev 4392)
@@ -24,7 +24,7 @@
 #include "SceneLoader.h"
 #include "UiSubsystem.h"
 
-rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
+template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
 
 namespace rl 
 {



From kamui at mail.berlios.de  Mon Jun  2 20:30:42 2008
From: kamui at mail.berlios.de (kamui at mail.berlios.de)
Date: Mon, 2 Jun 2008 20:30:42 +0200
Subject: [Dsa-hl-svn] r4393 - in modules: common/gui common/gui/fonts
	common/gui/imagesets common/gui/schemes common/gui/windows config
Message-ID: <200806021830.m52IUgbJ029745@sheep.berlios.de>

Author: kamui
Date: 2008-06-02 20:29:48 +0200 (Mon, 02 Jun 2008)
New Revision: 4393

Added:
   modules/common/gui/fonts/DefaultFont.font
   modules/common/gui/fonts/GenBasB.ttf
   modules/common/gui/fonts/GenBasBI.ttf
   modules/common/gui/fonts/GenBasI.ttf
   modules/common/gui/fonts/GenBasR.ttf
   modules/common/gui/fonts/GenBkBasB.ttf
   modules/common/gui/fonts/GenBkBasBI.ttf
   modules/common/gui/fonts/GenBkBasI.ttf
   modules/common/gui/fonts/GenBkBasR.ttf
Modified:
   modules/common/gui/cegui.config
   modules/common/gui/imagesets/
   modules/common/gui/imagesets/RastullahLook.imageset
   modules/common/gui/imagesets/RastullahLook.png
   modules/common/gui/schemes/RastullahLook.looknfeel
   modules/common/gui/schemes/RastullahLook.scheme
   modules/common/gui/windows/gamesettings.xml
   modules/common/gui/windows/mainmenuwindow.xml
   modules/config/
Log:
Started a new looknfeel
- Repaired the menubar and popupmenu
- Added Gentium fonts

Modified: modules/common/gui/cegui.config
===================================================================
--- modules/common/gui/cegui.config	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/cegui.config	2008-06-02 18:29:48 UTC (rev 4393)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <CEGUIConfig 
-    DefaultFont="Vera Serif-8" 
+    DefaultFont="DefaultFont" 
     Scheme="common/gui/schemes/RastullahLook.scheme" 
 />

Added: modules/common/gui/fonts/DefaultFont.font
===================================================================
--- modules/common/gui/fonts/DefaultFont.font	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/fonts/DefaultFont.font	2008-06-02 18:29:48 UTC (rev 4393)
@@ -0,0 +1,10 @@
+<?xml version="1.0" ?>
+<Font 
+    Name="DefaultFont" 
+    Filename="GenBkBasR.ttf" 
+    Type="FreeType" 
+    Size="11" 
+    NativeHorzRes="800" 
+    NativeVertRes="600" 
+    AutoScaled="false"
+/>

Added: modules/common/gui/fonts/GenBasB.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBasB.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBasBI.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBasBI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBasI.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBasI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBasR.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBasR.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBkBasB.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBkBasB.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBkBasBI.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBkBasBI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBkBasI.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBkBasI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/gui/fonts/GenBkBasR.ttf
===================================================================
(Binary files differ)


Property changes on: modules/common/gui/fonts/GenBkBasR.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


Property changes on: modules/common/gui/imagesets
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
RastullahLook.tif


Modified: modules/common/gui/imagesets/RastullahLook.imageset
===================================================================
--- modules/common/gui/imagesets/RastullahLook.imageset	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/imagesets/RastullahLook.imageset	2008-06-02 18:29:48 UTC (rev 4393)
@@ -350,17 +350,21 @@
     <Image Name="MenuTop" XPos="2" YPos="1" Width="4" Height="4" />
     <Image Name="MenuBottom" XPos="2" YPos="1" Width="4" Height="4" />
     <Image Name="MenuMiddle" XPos="2" YPos="1" Width="4" Height="4" />
+	
     <Image Name="PopupMenuArrowLeft" XPos="2" YPos="1" Width="4" Height="4" />
     <Image Name="PopupMenuArrowRight" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameTopLeft" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameTopRight" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameBottomLeft" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameBottomRight" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameLeft" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameRight" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameTop" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuFrameBottom" XPos="2" YPos="1" Width="4" Height="4" />
-    <Image Name="PopupMenuMiddle" XPos="2" YPos="1" Width="4" Height="4" />
+	
+    <Image Name="PopupMenuFrameTopLeft" XPos="1" YPos="257" Width="5" Height="4" />
+    <Image Name="PopupMenuFrameTopRight" XPos="19" YPos="257" Width="6" Height="4" />
+    <Image Name="PopupMenuFrameBottomLeft" XPos="1" YPos="273" Width="5" Height="4" />
+    <Image Name="PopupMenuFrameBottomRight" XPos="19" YPos="273" Width="6" Height="4" />
+    <Image Name="PopupMenuFrameLeft" XPos="1" YPos="265" Width="5" Height="4" />
+    <Image Name="PopupMenuFrameRight" XPos="19" YPos="265" Width="6" Height="4" />
+    <Image Name="PopupMenuFrameTop" XPos="9" YPos="257" Width="6" Height="4" />
+    <Image Name="PopupMenuFrameBottom" XPos="9" YPos="273" Width="6" Height="4" />
+    <Image Name="PopupMenuMiddle" XPos="9" YPos="265" Width="6" Height="4" />
+	
+	<Image Name="MenuBar" XPos="325" YPos="260" Width="1" Height="26" />
 
     <Image Name="TooltipLeftEdge" XPos="1" YPos="265" Width="5" Height="4" />
     <Image Name="TooltipTopLeft" XPos="1" YPos="257" Width="5" Height="4" />

Modified: modules/common/gui/imagesets/RastullahLook.png
===================================================================
(Binary files differ)

Modified: modules/common/gui/schemes/RastullahLook.looknfeel
===================================================================
--- modules/common/gui/schemes/RastullahLook.looknfeel	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/schemes/RastullahLook.looknfeel	2008-06-02 18:29:48 UTC (rev 4393)
@@ -4374,12 +4374,14 @@
     ***************************************************
     -->
     <WidgetLook name="RastullahLook/MenuItem">
-        <PropertyDefinition name="NormalTextColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+        <PropertyDefinition name="NormalTextColour" initialValue="FF292a2e" redrawOnWrite="true" />
         <PropertyDefinition name="DisabledTextColour" initialValue="FF7F7F7F" redrawOnWrite="true" />
-        <PropertyDefinition name="HoverColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
-        <PropertyDefinition name="PushedColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
-        <PropertyDefinition name="OpenedColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+        <PropertyDefinition name="HoverTextColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+        <PropertyDefinition name="PushedTextColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+        <PropertyDefinition name="OpenTextColour" initialValue="FFFFFFFF" redrawOnWrite="true" />
+		
         <Property name="WantsMultiClickEvents" value="False" />
+		
         <NamedArea name="ContentSize">
             <Area>
                 <Dim type="LeftEdge"><AbsoluteDim value="0" /></Dim>
@@ -4468,25 +4470,6 @@
                 <HorzFormat type="LeftAligned" />
             </TextComponent>
         </ImagerySection>
-        <ImagerySection name="frame">
-            <FrameComponent>
-                <Area>
-                    <Dim type="LeftEdge" ><AbsoluteDim value="0" /></Dim>
-                    <Dim type="TopEdge" ><AbsoluteDim value="0" /></Dim>
-                    <Dim type="Width" ><UnifiedDim scale="1" type="Width" /></Dim>
-                    <Dim type="Height" ><UnifiedDim scale="1" type="Height" /></Dim>
-                </Area>
-                <Image type="TopLeftCorner" imageset="RastullahLook-Images" image="MenuTopLeft" />
-                <Image type="TopRightCorner" imageset="RastullahLook-Images" image="MenuTopRight" />
-                <Image type="BottomLeftCorner" imageset="RastullahLook-Images" image="MenuBottomLeft" />
-                <Image type="BottomRightCorner" imageset="RastullahLook-Images" image="MenuBottomRight" />
-                <Image type="LeftEdge" imageset="RastullahLook-Images" image="MenuLeft" />
-                <Image type="RightEdge" imageset="RastullahLook-Images" image="MenuRight" />
-                <Image type="TopEdge" imageset="RastullahLook-Images" image="MenuTop" />
-                <Image type="BottomEdge" imageset="RastullahLook-Images" image="MenuBottom" />
-                <Image type="Background" imageset="RastullahLook-Images" image="MenuMiddle" />
-            </FrameComponent>
-        </ImagerySection>
         <ImagerySection name="popup_arrow_right">
             <ImageryComponent>
                 <Area>
@@ -4525,6 +4508,7 @@
                 <HorzFormat type="RightAligned" />
             </ImageryComponent>
         </ImagerySection>
+		
         <StateImagery name="EnabledNormal">
             <Layer>
                 <Section section="label">
@@ -4534,31 +4518,22 @@
         </StateImagery>
         <StateImagery name="EnabledHover">
             <Layer>
-                <Section section="frame">
-                    <ColourProperty name="HoverColour" />
-                </Section>
                 <Section section="label">
-                    <ColourProperty name="NormalTextColour" />
+                    <ColourProperty name="HoverTextColour" />
                 </Section>
             </Layer>
         </StateImagery>
         <StateImagery name="EnabledPushed">
             <Layer>
-                <Section section="frame">
-                    <ColourProperty name="PushedColour" />
-                </Section>
                 <Section section="label">
-                    <ColourProperty name="NormalTextColour" />
+                    <ColourProperty name="PushedTextColour" />
                 </Section>
             </Layer>
         </StateImagery>
         <StateImagery name="EnabledPopupOpen">
             <Layer>
-                <Section section="frame">
-                    <ColourProperty name="OpenedColour" />
-                </Section>
                 <Section section="label">
-                    <ColourProperty name="NormalTextColour" />
+                    <ColourProperty name="OpenTextColour" />
                 </Section>
             </Layer>
         </StateImagery>
@@ -4571,9 +4546,6 @@
         </StateImagery>
         <StateImagery name="DisabledHover">
             <Layer>
-                <Section section="frame">
-                    <Colours topLeft="FF7F7F7F" topRight="FF7F7F7F" bottomLeft="FF7F7F7F" bottomRight="FF7F7F7F" />
-                </Section>
                 <Section section="label">
                     <ColourProperty name="DisabledTextColour" />
                 </Section>
@@ -4581,9 +4553,6 @@
         </StateImagery>
         <StateImagery name="DisabledPushed">
             <Layer>
-                <Section section="frame">
-                    <Colours topLeft="FF7F7F7F" topRight="FF7F7F7F" bottomLeft="FF7F7F7F" bottomRight="FF7F7F7F" />
-                </Section>
                 <Section section="label">
                     <ColourProperty name="DisabledTextColour" />
                 </Section>
@@ -4591,9 +4560,6 @@
         </StateImagery>
         <StateImagery name="DisabledPopupOpen">
             <Layer>
-                <Section section="frame">
-                    <Colours topLeft="FF7F7F7F" topRight="FF7F7F7F" bottomLeft="FF7F7F7F" bottomRight="FF7F7F7F" />
-                </Section>
                 <Section section="label">
                     <ColourProperty name="DisabledTextColour" />
                 </Section>
@@ -4702,45 +4668,22 @@
     -->
     <WidgetLook name="RastullahLook/Menubar">
         <PropertyDefinition name="BackgroundColours" initialValue="tl:FFFFFFFF tr:FFFFFFFF bl:FFFFFFFF br:FFFFFFFF" redrawOnWrite="true" />
-        <PropertyDefinition name="BorderWidth" initialValue="5" layoutOnWrite="true" />
+        <PropertyDefinition name="BorderWidth" initialValue="9" layoutOnWrite="true" />
         <NamedArea name="ItemRenderArea">
             <Area>
                 <Dim type="LeftEdge" >
-                    <ImageDim imageset="RastullahLook-Images" image="PopupMenuFrameLeft" dimension="Width">
-                        <DimOperator op="Add">
-                            <PropertyDim name="BorderWidth" />
+					<AbsoluteDim value="0">
+						<DimOperator op="Add">
+							<PropertyDim name="BorderWidth" />
                         </DimOperator>
+					</AbsoluteDim>
+				</Dim>
+                <Dim type="TopEdge" ><AbsoluteDim value="0" /></Dim>
+                <Dim type="Width" ><UnifiedDim scale="1" type="Width" /></Dim>
+                <Dim type="Height" >
+					<ImageDim imageset="RastullahLook-Images" image="MenuBar" dimension="Height">
                     </ImageDim>
-                </Dim>
-                <Dim type="TopEdge" >
-                    <ImageDim imageset="RastullahLook-Images" image="PopupMenuFrameTop" dimension="Height">
-                        <DimOperator op="Add">
-                            <PropertyDim name="BorderWidth" />
-                        </DimOperator>
-                    </ImageDim>
-                </Dim>
-                <Dim type="RightEdge" >
-                    <UnifiedDim scale="1" type="RightEdge">
-                        <DimOperator op="Subtract">
-                            <ImageDim imageset="RastullahLook-Images" image="PopupMenuFrameRight" dimension="Width">
-                                <DimOperator op="Add">
-                                    <PropertyDim name="BorderWidth" />
-                                </DimOperator>
-                            </ImageDim>
-                        </DimOperator>
-                    </UnifiedDim>
-                </Dim>
-                <Dim type="BottomEdge" >
-                    <UnifiedDim scale="1" type="BottomEdge">
-                        <DimOperator op="Subtract">
-                            <ImageDim imageset="RastullahLook-Images" image="PopupMenuFrameBottom" dimension="Height">
-                                <DimOperator op="Add">
-                                    <PropertyDim name="BorderWidth" />
-                                </DimOperator>
-                            </ImageDim>
-                        </DimOperator>
-                    </UnifiedDim>
-                </Dim>
+				</Dim>
             </Area>
         </NamedArea>
         <ImagerySection name="frame">
@@ -4749,17 +4692,12 @@
                     <Dim type="LeftEdge" ><AbsoluteDim value="0" /></Dim>
                     <Dim type="TopEdge" ><AbsoluteDim value="0" /></Dim>
                     <Dim type="Width" ><UnifiedDim scale="1" type="Width" /></Dim>
-                    <Dim type="Height" ><UnifiedDim scale="1" type="Height" /></Dim>
+                    <Dim type="Height" >
+							<ImageDim imageset="RastullahLook-Images" image="MenuBar" dimension="Height">
+                            </ImageDim>
+					</Dim>
                 </Area>
-                <Image type="TopLeftCorner" imageset="RastullahLook-Images" image="PopupMenuFrameTopLeft" />
-                <Image type="TopRightCorner" imageset="RastullahLook-Images" image="PopupMenuFrameTopRight" />
-                <Image type="BottomLeftCorner" imageset="RastullahLook-Images" image="PopupMenuFrameBottomLeft" />
-                <Image type="BottomRightCorner" imageset="RastullahLook-Images" image="PopupMenuFrameBottomRight" />
-                <Image type="LeftEdge" imageset="RastullahLook-Images" image="PopupMenuFrameLeft" />
-                <Image type="RightEdge" imageset="RastullahLook-Images" image="PopupMenuFrameRight" />
-                <Image type="TopEdge" imageset="RastullahLook-Images" image="PopupMenuFrameTop" />
-                <Image type="BottomEdge" imageset="RastullahLook-Images" image="PopupMenuFrameBottom" />
-                <Image type="Background" imageset="RastullahLook-Images" image="PopupMenuMiddle" />
+                <Image type="Background" imageset="RastullahLook-Images" image="MenuBar" />
             </FrameComponent>
         </ImagerySection>
         <StateImagery name="Enabled">

Modified: modules/common/gui/schemes/RastullahLook.scheme
===================================================================
--- modules/common/gui/schemes/RastullahLook.scheme	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/schemes/RastullahLook.scheme	2008-06-02 18:29:48 UTC (rev 4393)
@@ -9,7 +9,8 @@
     <Imageset Name="InventorySymbols" Filename="InventorySymbols.imageset" />
     <Imageset Name="Logos" Filename="Logos.imageset" />
 
-    <Font Name="Vera Serif-8" Filename="vera_serif-8.font" />
+    <Font Name="DefaultFont" Filename="DefaultFont.font" />
+	<Font Name="Vera Serif-8" Filename="vera_serif-8.font" />
     <Font Name="Vera Serif-10" Filename="vera_serif-10.font" />
     <Font Name="Vera Serif Bold-8" Filename="vera_serif_bold-8.font" />
     <Font Name="Vera Serif Bold-18" Filename="vera_serif_bold-18.font" />

Modified: modules/common/gui/windows/gamesettings.xml
===================================================================
--- modules/common/gui/windows/gamesettings.xml	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/windows/gamesettings.xml	2008-06-02 18:29:48 UTC (rev 4393)
@@ -109,6 +109,12 @@
             <Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
             <Property Name="Text" Value="Input"/>
          </Window>
+		 
+		<Window Type="DefaultGUISheet" Name="GameOptionsWindow/GuiDemo">
+            <Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+            <Property Name="UnifiedSize" Value="{{1,0},{1,0}}"/>
+            <Property Name="Text" Value="GuiDemo"/>
+         </Window>
       </Window>
    </Window>
 </GUILayout>

Modified: modules/common/gui/windows/mainmenuwindow.xml
===================================================================
--- modules/common/gui/windows/mainmenuwindow.xml	2008-06-01 13:21:35 UTC (rev 4392)
+++ modules/common/gui/windows/mainmenuwindow.xml	2008-06-02 18:29:48 UTC (rev 4393)
@@ -1,6 +1,6 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
 	<Window Type="DefaultWindow" Name="MainMenu">
-		<Property Name="UnifiedSize" Value="{{1.0, 0.0},{0.0,20.0}}"/>
+		<Property Name="UnifiedSize" Value="{{1.0, 0.0},{0.0,26.0}}"/>
 		<Property Name="UnifiedPosition" Value="{{0.0,0.0},{0.0,0.0}}"/>
 		<Window Type="RastullahLook/Menubar" Name="MainMenu/Menubar">
 			<Property Name="UnifiedSize" Value="{{1.0, 0.0},{1.0,0.0}}"/>


Property changes on: modules/config
___________________________________________________________________
Name: svn:ignore
   - rastullah_ogre.cfg

   + rastullah_ogre.cfg
console_history
rastullah.conf




From blakharaz at mail.berlios.de  Wed Jun  4 13:23:42 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 4 Jun 2008 13:23:42 +0200
Subject: [Dsa-hl-svn] r4394 - in modules/regressiontest: maps materials
	materials/textures models scripts scripts/maps
Message-ID: <200806041123.m54BNgdB016357@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-04 13:21:46 +0200 (Wed, 04 Jun 2008)
New Revision: 4394

Added:
   modules/regressiontest/maps/combatarena.rlmap
   modules/regressiontest/materials/textures/boden_kana.png
   modules/regressiontest/materials/textures/gras_kana.png
   modules/regressiontest/materials/textures/ruchin_atlasmap.png
   modules/regressiontest/materials/zaun_boden.material
   modules/regressiontest/models/boden.mesh
   modules/regressiontest/models/zaun.mesh
   modules/regressiontest/scripts/CombatTest.rb
Modified:
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
Added combat to regressiontest module
TBD: Turn off the wolf's movement

Added: modules/regressiontest/maps/combatarena.rlmap
===================================================================
--- modules/regressiontest/maps/combatarena.rlmap	2008-06-02 18:29:48 UTC (rev 4393)
+++ modules/regressiontest/maps/combatarena.rlmap	2008-06-04 11:21:46 UTC (rev 4394)
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<rastullahmap formatVersion="0.4.0">
+  <nodes>
+    <entity name="zaun" meshfile="zaun.mesh">
+      <position x="32" y="0" z="-10"/>
+    </entity>
+	<gameobject id="100" class="Wolf" state="IN_SCENE">
+		<position x="25" y="0" z="0"/>
+		<property name="ai" type="MAP">
+			<property name="behaviours" type="ARRAY">
+			</property>
+		</property>
+	</gameobject>
+  </nodes>
+</rastullahmap>

Added: modules/regressiontest/materials/textures/boden_kana.png
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/materials/textures/boden_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/materials/textures/gras_kana.png
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/materials/textures/gras_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/materials/textures/ruchin_atlasmap.png
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/materials/textures/ruchin_atlasmap.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/materials/zaun_boden.material
===================================================================
--- modules/regressiontest/materials/zaun_boden.material	2008-06-02 18:29:48 UTC (rev 4393)
+++ modules/regressiontest/materials/zaun_boden.material	2008-06-04 11:21:46 UTC (rev 4394)
@@ -0,0 +1,42 @@
+material boden/SOLID/TEX/boden_kana.png
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture boden_kana.png
+			}
+		}
+	}
+}
+material boden/SOLID/TEX/gras_kana2.png
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture gras_kana2.png
+			}
+		}
+	}
+}
+material zaun/SOLID/TEX/ruchin_atlasmap.png
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture ruchin_atlasmap.png
+			}
+		}
+	}
+}

Added: modules/regressiontest/models/boden.mesh
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/models/boden.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/models/zaun.mesh
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/models/zaun.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/scripts/CombatTest.rb
===================================================================
--- modules/regressiontest/scripts/CombatTest.rb	2008-06-02 18:29:48 UTC (rev 4393)
+++ modules/regressiontest/scripts/CombatTest.rb	2008-06-04 11:21:46 UTC (rev 4394)
@@ -0,0 +1,15 @@
+require 'testcase.rb'
+
+class CombatTest < TestCase
+    def execute()
+		MapLoader.new().loadMap("combatarena.rlmap");
+		
+		wolf = $GOM.getGameObject(100);
+		wolf.setAlignment(Creature::ALIGNMENT_ENEMY);
+		wolf.modifyAu(1000)
+
+		schnauze = $GOM.createGameObject("Wolfsschnauze");
+		wolf.getInventory().ready(schnauze, "Snout");
+
+	end
+end
\ No newline at end of file

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2008-06-02 18:29:48 UTC (rev 4393)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2008-06-04 11:21:46 UTC (rev 4394)
@@ -35,10 +35,10 @@
 require 'SelectorTest.rb'
 require 'SoundTest.rb'
 require 'TimeTest.rb'
-
+require 'CombatTest.rb'
 require 'WalkJobTest.rb'
 
-class RegressionTest
+class RegressionTestSuite
 	def initialize
 		@mErrors = 0
 		@mTests = 0
@@ -73,6 +73,7 @@
 		runTest(SoundTest, [ 10, 0, 10])
 		runTest(TimeTest, [ -5, 0, -5])
 		runTest(WalkJobTest, [  0, 0, -3])
+		runTest(CombatTest, [15, 0, 15])
 
 		if @mErrors > 0
 		  MessageBox.showModal(
@@ -85,5 +86,5 @@
 	end
 end
 
-RegressionTest.new().runTests()
+RegressionTestSuite.new().runTests()
 $SCRIPT.log("map 'regressiontest' initialisiert.")



From blakharaz at mail.berlios.de  Thu Jun  5 22:48:41 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Jun 2008 22:48:41 +0200
Subject: [Dsa-hl-svn] r4395 - rl/trunk/engine/script/src
Message-ID: <200806052048.m55Kmfxq020278@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-05 22:48:39 +0200 (Thu, 05 Jun 2008)
New Revision: 4395

Modified:
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
Log:
Fix bug preventing setting properties in rlmap files


Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2008-06-04 11:21:46 UTC (rev 4394)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2008-06-05 20:48:39 UTC (rev 4395)
@@ -70,7 +70,7 @@
             for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
             {
                 DOMNode* cur = goElChildNodes->item(idx);
-                if (cur->getNodeType() == DOMNode::ENTITY_NODE
+                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
                     && hasNodeName(cur, "property"))
                 {
                     PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
@@ -81,6 +81,7 @@
                 }
             } 		    
         }
+
         GameObjectState state = GOS_IN_SCENE;
         if (hasAttribute(nodeElem, "state"))
 	    {



From blakharaz at mail.berlios.de  Thu Jun  5 22:49:21 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Jun 2008 22:49:21 +0200
Subject: [Dsa-hl-svn] r4396 - rl/trunk/engine/core/src
Message-ID: <200806052049.m55KnLTB020290@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-05 22:49:20 +0200 (Thu, 05 Jun 2008)
New Revision: 4396

Modified:
   rl/trunk/engine/core/src/Actor.cpp
Log:



Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2008-06-05 20:48:39 UTC (rev 4395)
+++ rl/trunk/engine/core/src/Actor.cpp	2008-06-05 20:49:20 UTC (rev 4396)
@@ -683,9 +683,12 @@
 
     void Actor::detach(Actor* actor)
     {
-        doDetach(actor);
-        actor->mParent = NULL;
-        mChildren.erase(actor);
+        if (actor) 
+        {
+            doDetach(actor);
+            actor->mParent = NULL;
+            mChildren.erase(actor);
+        }
     }
 
     void Actor::doDetach(Actor* actor)



From blakharaz at mail.berlios.de  Thu Jun  5 22:49:57 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Jun 2008 22:49:57 +0200
Subject: [Dsa-hl-svn] r4397 - rl/trunk/engine/ai/src
Message-ID: <200806052049.m55Knvp9020337@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-05 22:49:56 +0200 (Thu, 05 Jun 2008)
New Revision: 4397

Modified:
   rl/trunk/engine/ai/src/AgentManager.cpp
Log:
Clear behaviours before setting new


Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2008-06-05 20:49:20 UTC (rev 4396)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2008-06-05 20:49:56 UTC (rev 4397)
@@ -150,6 +150,7 @@
                     // Nevertheless see above comment for how to improve this situation.
                     AgentSteeringState* ass =
                         dynamic_cast<AgentSteeringState*>(agent->getCurrentState());
+                    ass->clearSteeringBehaviours();
                     for (PropertyArray::const_iterator it = behaviours.begin(),
                         end = behaviours.end(); it != end; ++it)
                     {



From blakharaz at mail.berlios.de  Fri Jun  6 11:00:11 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Jun 2008 11:00:11 +0200
Subject: [Dsa-hl-svn] r4398 - in modules/regressiontest: maps models
Message-ID: <200806060900.m5690Br5031006@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-06 11:00:04 +0200 (Fri, 06 Jun 2008)
New Revision: 4398

Modified:
   modules/regressiontest/maps/combatarena.rlmap
   modules/regressiontest/models/zaun.mesh
Log:
Resized wolf kennel and repositioned wolf.

Modified: modules/regressiontest/maps/combatarena.rlmap
===================================================================
--- modules/regressiontest/maps/combatarena.rlmap	2008-06-05 20:49:56 UTC (rev 4397)
+++ modules/regressiontest/maps/combatarena.rlmap	2008-06-06 09:00:04 UTC (rev 4398)
@@ -5,7 +5,7 @@
       <position x="32" y="0" z="-10"/>
     </entity>
 	<gameobject id="100" class="Wolf" state="IN_SCENE">
-		<position x="25" y="0" z="0"/>
+		<position x="32" y="0" z="-10"/>
 		<property name="ai" type="MAP">
 			<property name="behaviours" type="ARRAY">
 			</property>

Modified: modules/regressiontest/models/zaun.mesh
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Fri Jun  6 11:02:41 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Jun 2008 11:02:41 +0200
Subject: [Dsa-hl-svn] r4399 - rl/trunk/engine/common/include
Message-ID: <200806060902.m5692fgG031192@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-06 11:02:40 +0200 (Fri, 06 Jun 2008)
New Revision: 4399

Modified:
   rl/trunk/engine/common/include/Exception.h
Log:
Changed exception to hold the what() message in a member variable: Fixes std::exception messages throw in ruby-exported methods


Modified: rl/trunk/engine/common/include/Exception.h
===================================================================
--- rl/trunk/engine/common/include/Exception.h	2008-06-06 09:00:04 UTC (rev 4398)
+++ rl/trunk/engine/common/include/Exception.h	2008-06-06 09:02:40 UTC (rev 4399)
@@ -104,21 +104,35 @@
       std::string mMessage;
       std::string mFile;
       std::string mFunction;
+      std::string mWhat;
       int mLine;
 
    public:
       Exception(const char* message,
          const std::string& file, const std::string& function, int line)
          : mMessage(message), mFile(file), mFunction(function), mLine(line), 
-         std::exception() {}
+         mWhat(""),
+         std::exception()
+      {
+          update();
+      }
       Exception(const std::string& message,
          const std::string& file, const std::string& function, int line)
          : mMessage(message), mFile(file), mFunction(function), mLine(line), 
-         std::exception() {}
+         mWhat(""),
+         std::exception()
+      {
+          update();
+      }
       Exception(const CeGuiString& message,
          const std::string& file, const std::string& function, int line)
-         : mMessage(message.c_str()), mFile(file), mFunction(function), mLine(line), 
-         std::exception() {}
+         : mMessage(message.c_str()), mFile(file), mFunction(function), mLine(line),
+         mWhat(""),
+         std::exception()
+      {
+          update();
+      }
+
       
       Exception(const Exception& rhs) 
           :
@@ -126,7 +140,11 @@
          mFile(rhs.mFile),
          mFunction(rhs.mFunction),
          mLine(rhs.mLine),
-         std::exception() {}
+         mWhat(""),
+         std::exception() 
+      {
+          update();
+      }
 
       virtual ~Exception() throw() {}
 
@@ -137,6 +155,7 @@
             mFile = rhs.mFile;
             mFunction = rhs.mFunction;
             mLine = rhs.mLine;
+            update();
          }
          return *this;
       }      
@@ -147,22 +166,22 @@
       virtual std::string getType() const { return "Exception"; }
       virtual int getLine() const { return mLine; }
 
-	  const char* what() const throw() { return toString().c_str(); }
+	  const char* what() const throw() { return mWhat.c_str(); }
 
-      virtual std::string toString() const
+      void update()
       {
          std::stringstream lineStream;
 
          lineStream 
-             << "In Datei " 
+             << "In file " 
              << getFile().c_str() 
-             << ",  Zeile " << getLine()
-             << ", Funktion " << getFunction().c_str()
-             << "\ntrat folgende Ausnahme vom Typ " << getType().c_str() 
-             << " auf\n-----------------------------------------------------------------------\n"
+             << ",  line " << getLine()
+             << ", function " << getFunction().c_str()
+             << "\nan exception of type " << getType().c_str() 
+             << " was raised.\n-----------------------------------------------------------------------\n"
              << getMessage().c_str();
 
-         return lineStream.str();
+         mWhat = lineStream.str();
       }
    };
 



From blakharaz at mail.berlios.de  Fri Jun  6 19:04:13 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Jun 2008 19:04:13 +0200
Subject: [Dsa-hl-svn] r4400 - rl/trunk/engine/core/src
Message-ID: <200806061704.m56H4DhR009318@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-06 19:04:08 +0200 (Fri, 06 Jun 2008)
New Revision: 4400

Modified:
   rl/trunk/engine/core/src/ZoneManager.cpp
Log:
Really delete the Zones in deleteAllZones to avoid crash when quitting

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2008-06-06 09:02:40 UTC (rev 4399)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2008-06-06 17:04:08 UTC (rev 4400)
@@ -63,9 +63,9 @@
 		for (std::map<long, Zone*>::iterator it = mZonesIdMap.begin(); it != mZonesIdMap.end(); ++it)
 		{
 			Zone* curZone = (*it).second;
-            delete curZone;
+            doDestroyZone(curZone);
 		}
-		delete mDefaultZone;
+		doDestroyZone(mDefaultZone);
 	}
 
 	Zone* ZoneManager::getDefaultZone()
@@ -134,20 +134,16 @@
 
     void ZoneManager::destroyAllZones()
     {
-        for(ZoneMap::iterator it = mZones.begin(); it != mZones.end();)
+        for(ZoneMap::iterator it = mZones.begin(); it != mZones.end(); )
         {
-            // remove from active zones
-            if( isZoneActive(it->second) )
-                mActiveZones.remove(it->second);
-
-            std::map<long, Zone*>::iterator it_ = mZonesIdMap.find(it->second->getId());
-            if( it_ != mZonesIdMap.end() )
-                mZonesIdMap.erase(it_);
-
-
-            mZonesToDelete.push_back(it->second);
-            mZones.erase(it++);
+            destroyZone((it++)->first);
         }
+        mZones.clear();
+
+        std::list<Zone*>::iterator it = mZonesToDelete.begin();
+        for( ; it != mZonesToDelete.end(); it++)
+            doDestroyZone(*it);
+        mZonesToDelete.clear();
     }
 
     void ZoneManager::doDestroyZone(Zone *zone)



From melven at mail.berlios.de  Tue Jun 10 00:01:11 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 10 Jun 2008 00:01:11 +0200
Subject: [Dsa-hl-svn] r4401 - modules/common/scripts/triggers
Message-ID: <200806092201.m59M1Bjl003258@sheep.berlios.de>

Author: melven
Date: 2008-06-10 00:01:10 +0200 (Tue, 10 Jun 2008)
New Revision: 4401

Modified:
   modules/common/scripts/triggers/limitedtimestrigger.rb
Log:
= instead of == in conditional


Modified: modules/common/scripts/triggers/limitedtimestrigger.rb
===================================================================
--- modules/common/scripts/triggers/limitedtimestrigger.rb	2008-06-06 17:04:08 UTC (rev 4400)
+++ modules/common/scripts/triggers/limitedtimestrigger.rb	2008-06-09 22:01:10 UTC (rev 4401)
@@ -80,7 +80,7 @@
       @_prop_zone = value;
     elsif (name == "enter_code")
       setEnterCode(value);
-    elsif (name = "leave_code")
+    elsif (name == "leave_code")
       setLeaveCode(value);
     else
       super(name, value)



From melven at mail.berlios.de  Tue Jun 10 00:18:55 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 10 Jun 2008 00:18:55 +0200
Subject: [Dsa-hl-svn] r4402 - modules/persistenztest/scripts
Message-ID: <200806092218.m59MItQC005571@sheep.berlios.de>

Author: melven
Date: 2008-06-10 00:18:54 +0200 (Tue, 10 Jun 2008)
New Revision: 4402

Modified:
   modules/persistenztest/scripts/moduleconfig.rb
Log:
error in linux because filenames are case sensitive here


Modified: modules/persistenztest/scripts/moduleconfig.rb
===================================================================
--- modules/persistenztest/scripts/moduleconfig.rb	2008-06-09 22:01:10 UTC (rev 4401)
+++ modules/persistenztest/scripts/moduleconfig.rb	2008-06-09 22:18:54 UTC (rev 4402)
@@ -25,7 +25,7 @@
         require "mckhero.rb"
         require "hero.rb"
 		require "MapChange.rb"
-		require "Clothing.rb"
+		require "clothing.rb"
 		SceneManager::getSingleton().loadScene("scene01", false);
     end
 end



From timm at mail.berlios.de  Wed Jun 11 00:12:04 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 11 Jun 2008 00:12:04 +0200
Subject: [Dsa-hl-svn] r4403 - in rl/trunk/engine: core/include core/src
	startup/src
Message-ID: <200806102212.m5AMC47P008557@sheep.berlios.de>

Author: timm
Date: 2008-06-11 00:12:00 +0200 (Wed, 11 Jun 2008)
New Revision: 4403

Modified:
   rl/trunk/engine/core/include/ContentLoader.h
   rl/trunk/engine/core/src/ContentLoader.cpp
   rl/trunk/engine/core/src/SaveGameManager.cpp
   rl/trunk/engine/startup/src/RastullahMain.cpp
Log:
some fixes

Modified: rl/trunk/engine/core/include/ContentLoader.h
===================================================================
--- rl/trunk/engine/core/include/ContentLoader.h	2008-06-09 22:18:54 UTC (rev 4402)
+++ rl/trunk/engine/core/include/ContentLoader.h	2008-06-10 22:12:00 UTC (rev 4403)
@@ -22,8 +22,6 @@
 
 namespace rl
 {
-    class ContentModule;
-
     class _RlCoreExport ContentLoader : public PropertyHolder
     {
     public:
@@ -39,8 +37,6 @@
         PropertyKeys getAllPropertyKeys() const;
 
         virtual const CeGuiString getClassName() const = 0;
-    protected:
-        ContentModule* mContentModule;
     };
 }
 

Modified: rl/trunk/engine/core/src/ContentLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentLoader.cpp	2008-06-09 22:18:54 UTC (rev 4402)
+++ rl/trunk/engine/core/src/ContentLoader.cpp	2008-06-10 22:12:00 UTC (rev 4403)
@@ -17,7 +17,6 @@
 #include "stdinc.h"
 
 #include "ContentLoader.h"
-#include "ContentModule.h"
 
 namespace rl
 {

Modified: rl/trunk/engine/core/src/SaveGameManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameManager.cpp	2008-06-09 22:18:54 UTC (rev 4402)
+++ rl/trunk/engine/core/src/SaveGameManager.cpp	2008-06-10 22:12:00 UTC (rev 4403)
@@ -137,6 +137,9 @@
 
             SaveGameFile* file = getSaveGameFile(name, moduleId);
             SaveGameFileReader reader;
+            
+            CoreSubsystem::getSingleton().getActiveAdventureModule()->unload();
+
             reader.parseSaveGameFile(file, mSaveGameDataOrderMap);
             ///@todo: SaveGameReader
 
@@ -152,6 +155,9 @@
 
             SaveGameFile* file = getSaveGameFile(id);
             SaveGameFileReader reader;
+
+            CoreSubsystem::getSingleton().getActiveAdventureModule()->unload();
+
             reader.parseSaveGameFile(file, mSaveGameDataOrderMap);
             ///@todo: SaveGameReader
 

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2008-06-09 22:18:54 UTC (rev 4402)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2008-06-10 22:12:00 UTC (rev 4403)
@@ -92,7 +92,7 @@
         rl::showError(oe.getFullDescription());
     }
     catch(rl::Exception& re) {
-        rl::showError(re.toString());
+        rl::showError(re.what());
     }
     catch(CEGUI::Exception& ce) {
         rl::showError(ce.getMessage().c_str());
@@ -133,7 +133,7 @@
         rl::showError(oe.getFullDescription());
     }
     catch(rl::Exception& re) {
-        rl::showError(re.toString());
+        rl::showError(re.what());
     }
     catch(std::runtime_error& rte) {
         rl::showError(rte.what());



From timm at mail.berlios.de  Sun Jun 15 23:02:29 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 15 Jun 2008 23:02:29 +0200
Subject: [Dsa-hl-svn] r4404 - modules/persistenztest/scripts
Message-ID: <200806152102.m5FL2TRV002318@sheep.berlios.de>

Author: timm
Date: 2008-06-15 23:02:27 +0200 (Sun, 15 Jun 2008)
New Revision: 4404

Modified:
   modules/persistenztest/scripts/moduleconfig.rb
Log:
enable physics after loading scene


Modified: modules/persistenztest/scripts/moduleconfig.rb
===================================================================
--- modules/persistenztest/scripts/moduleconfig.rb	2008-06-10 22:12:00 UTC (rev 4403)
+++ modules/persistenztest/scripts/moduleconfig.rb	2008-06-15 21:02:27 UTC (rev 4404)
@@ -27,6 +27,7 @@
 		require "MapChange.rb"
 		require "clothing.rb"
 		SceneManager::getSingleton().loadScene("scene01", false);
+		$PM.setEnabled(true)
     end
 end
 



From timm at mail.berlios.de  Sun Jun 15 23:03:28 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 15 Jun 2008 23:03:28 +0200
Subject: [Dsa-hl-svn] r4405 - in rl/trunk/engine: core/include core/src
	script/src
Message-ID: <200806152103.m5FL3S2N002426@sheep.berlios.de>

Author: timm
Date: 2008-06-15 23:03:20 +0200 (Sun, 15 Jun 2008)
New Revision: 4405

Modified:
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/script/src/MapLoader.cpp
Log:
don't execute game tasks while loading map

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2008-06-15 21:02:27 UTC (rev 4404)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2008-06-15 21:03:20 UTC (rev 4405)
@@ -66,7 +66,7 @@
     void startCore();
 
     /** Renders one frame (for internal use) */
-    void renderOneFrame();
+    void renderOneFrame(bool executeTasks = true);
 
     World* getWorld();
     void loadMap(const Ogre::String type, const Ogre::String filename,

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2008-06-15 21:02:27 UTC (rev 4404)
+++ rl/trunk/engine/core/include/GameLoop.h	2008-06-15 21:03:20 UTC (rev 4405)
@@ -71,7 +71,7 @@
 
     /// Execute the render loop for one frame (for internal use only)
     /// @see CoreSubsystem
-    void _executeOneRenderLoop();
+    void _executeOneRenderLoop(bool executeTasks = true);
 
     void setTimeFactor(Ogre::Real timeFactor);
       

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-06-15 21:02:27 UTC (rev 4404)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-06-15 21:03:20 UTC (rev 4405)
@@ -134,9 +134,9 @@
         //mRubyInterpreter->finalizeInterpreter();
     }
 
-    void CoreSubsystem::renderOneFrame()
+    void CoreSubsystem::renderOneFrame(bool executeTasks)
     {
-        mGameLoop->_executeOneRenderLoop();
+        mGameLoop->_executeOneRenderLoop(executeTasks);
     }
 
     void CoreSubsystem::setDeveloperMode(bool developerMode)

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2008-06-15 21:02:27 UTC (rev 4404)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2008-06-15 21:03:20 UTC (rev 4405)
@@ -128,7 +128,7 @@
         }
     }
 
-    void GameLoop::_executeOneRenderLoop()
+    void GameLoop::_executeOneRenderLoop(bool executeTasks)
     {
         // Calculate frame time. This time is smoothed and capped.
         unsigned long elapsedTime = mTimer->getMilliseconds();
@@ -153,7 +153,7 @@
         Root::getSingleton().renderOneFrame();
 
         // Execute all tasks in order.
-        for (size_t i = 0; i < mTaskLists.size(); ++i)
+        for (size_t i = 0; i < mTaskLists.size() && executeTasks; ++i)
         {
             GameTaskList* tasks = mTaskLists[i];
             for (GameTaskList::iterator it = tasks->begin(); it != tasks->end(); ++it)

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2008-06-15 21:02:27 UTC (rev 4404)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2008-06-15 21:03:20 UTC (rev 4405)
@@ -321,7 +321,7 @@
             mPercentageWindow->setText(text);
         }
 
-        CoreSubsystem::getSingleton().renderOneFrame();
+        CoreSubsystem::getSingleton().renderOneFrame(false);
 
         if (percentage == 1)
         {



From melven at mail.berlios.de  Mon Jun 23 15:45:32 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 23 Jun 2008 15:45:32 +0200
Subject: [Dsa-hl-svn] r4406 - in rl/trunk/engine: ai/src rules/include
	rules/src script/swig ui/src
Message-ID: <200806231345.m5NDjWHN008949@sheep.berlios.de>

Author: melven
Date: 2008-06-23 15:45:18 +0200 (Mon, 23 Jun 2008)
New Revision: 4406

Added:
   rl/trunk/engine/rules/include/AbstractMovement.h
   rl/trunk/engine/rules/include/FallDownMovement.h
   rl/trunk/engine/rules/include/JogBackwardsMovement.h
   rl/trunk/engine/rules/include/JogFastMovement.h
   rl/trunk/engine/rules/include/JogMovement.h
   rl/trunk/engine/rules/include/JumpHighMovement.h
   rl/trunk/engine/rules/include/JumpLongMovement.h
   rl/trunk/engine/rules/include/JumpToTargetMovement.h
   rl/trunk/engine/rules/include/LieDownMovement.h
   rl/trunk/engine/rules/include/RotateMovement.h
   rl/trunk/engine/rules/include/SneakMovement.h
   rl/trunk/engine/rules/include/SprintMovement.h
   rl/trunk/engine/rules/include/StandAroundMovement.h
   rl/trunk/engine/rules/include/StepRecognitionMovement.h
   rl/trunk/engine/rules/include/StrafeMovement.h
   rl/trunk/engine/rules/include/WalkBackwardsMovement.h
   rl/trunk/engine/rules/include/WalkMovement.h
   rl/trunk/engine/rules/src/FallDownMovement.cpp
   rl/trunk/engine/rules/src/JogFastMovement.cpp
   rl/trunk/engine/rules/src/JogMovement.cpp
   rl/trunk/engine/rules/src/JumpHighMovement.cpp
   rl/trunk/engine/rules/src/JumpLongMovement.cpp
   rl/trunk/engine/rules/src/JumpToTargetMovement.cpp
   rl/trunk/engine/rules/src/LieDownMovement.cpp
   rl/trunk/engine/rules/src/RotateMovement.cpp
   rl/trunk/engine/rules/src/SneakMovement.cpp
   rl/trunk/engine/rules/src/SprintMovement.cpp
   rl/trunk/engine/rules/src/StandAroundMovement.cpp
   rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
   rl/trunk/engine/rules/src/StrafeMovement.cpp
   rl/trunk/engine/rules/src/WalkMovement.cpp
Modified:
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Put each movement (from CreatureController.cpp) in an own class with .cpp- and .h-file


Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -52,7 +52,7 @@
 
     void AgentDialogState::update(const Ogre::Real elapsedTime)
     {
-        static CreatureController* ctrl = 
+        CreatureController* ctrl = 
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent->getControlledCreature());
 

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -17,6 +17,7 @@
 
 #include "SteeringVehicle.h"
 
+#include "AbstractMovement.h"
 #include "AiSubsystem.h"
 #include "AiWorld.h" 
 #include "Agent.h"

Added: rl/trunk/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/trunk/engine/rules/include/AbstractMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/AbstractMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,125 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+
+#ifndef __AbstractMovement_H__
+#define __AbstractMovement_H__
+
+#include "RulesPrerequisites.h"
+#include "CreatureController.h"
+
+
+
+namespace rl
+{
+    /// this is the base class of all movements and provides a general interface for movements
+    class AbstractMovement : 
+        public OgreNewt::ContactCallback
+    {
+    public:
+        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
+        virtual ~AbstractMovement() {}
+
+        /// returns the id of this movement
+        virtual CreatureController::MovementType getId() const = 0;
+
+        /// returns the id of the movement that is used, if this movement isn't possible (any more)
+        virtual CreatureController::MovementType getFallBackMovement() const = 0;
+
+        /**
+         * this method calculates the basis velocity (without any changes due to Talentproben etc)
+         * @param velocity this parameter returns the calculated "velocity" ( m/s, rpm, or width/height of a jump)
+         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
+         */
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity) = 0;
+
+        /**
+         * this method specifies, if the movement is possible
+         */
+        virtual bool isPossible() const = 0;
+
+        /**
+         * this method is called, when this movement is currently used to enable 
+         * an individual procession of collisions contacts for each movement
+         */
+        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+
+        /**
+         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
+         * the PhysicalThing can be acquired via the Creature
+         */
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep) = 0;
+
+        /**
+         * this method indicates if it is possible to change to the specified movement at this moment
+         */
+        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
+
+        /**
+         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
+         */
+        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
+
+        /**
+         * here all the stuff not (directly) relating the physics should be done
+         * this function is called every frame if this movement is activated and the
+         * Creature is in an active moving state. It is important to handle all 
+         * "Talentproben" etc here and not in the physics function!
+         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
+         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
+         */
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
+
+        /**
+         * this function is called if this movement is activated.
+         * it can be used to determine if a new "Talentprobe" is needed
+         * if you ovveride it, please make sure to call the base class method
+         */
+        virtual void activate() {mActive = true;}
+
+        /**
+         * this function is called every time this movement is deactivated.
+         * if you ovveride it, please make sure to call the base class method
+         */
+        virtual void deactivate() {mActive = false;}
+
+        /**
+         * this method is used to get to know if a movement can be used with a certain direction
+         * @retval true if this movement can be used with the direction, false otherwise
+         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
+         */
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const = 0;
+
+        /**
+         * this method is used to get to know if the given rotation can be used with this movement
+         * @retval true if the creature can perform this rotation with this movement
+         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
+         */
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const = 0;
+
+
+        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
+        bool isActive() const {return mActive;}
+
+        /// this method is used to return the yaw value of rotation movemenrts etc
+        virtual Ogre::Real getMovementDefinedValue() {return 0;}
+    protected:
+        CreatureController *mMovingCreature;
+        bool mActive;
+    };
+}
+#endif
+

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/CreatureController.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -80,9 +80,10 @@
             MT_SCHLEICHEN,
             MT_HOCHSPRUNG,
             MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
             // these movements are only for internal purposes and should not be used directly
             // instead use one of the movements above
-            MT_DREHEN,
+            MT_DREHEN = 100,  // if new movements are added, the old numbers can stay the same
             MT_STUFENERKENNUNG,
             MT_FALLEN,
 	    MT_LIEGEN
@@ -192,100 +193,6 @@
         MessagePump::ScopedConnection mMessageType_GameObjectsLoaded_Handler;
         MessagePump::ScopedConnection mLifeStateChangedHandler;
     };
-
-    /// this is the base class of all movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
-    {
-    public:
-        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
-
-        /// returns the id of this movement
-        virtual CreatureController::MovementType getId() const = 0;
-
-        /// returns the id of the movement that is used, if this movement isn't possible (any more)
-        virtual CreatureController::MovementType getFallBackMovement() const = 0;
-
-        /**
-         * this method calculates the basis velocity (without any changes due to Talentproben etc)
-         * @param velocity this parameter returns the calculated "velocity" ( m/s, rpm, or width/height of a jump)
-         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
-         */
-        virtual bool calculateBaseVelocity(Ogre::Real &velocity) = 0;
-
-        /**
-         * this method specifies, if the movement is possible
-         */
-        virtual bool isPossible() const = 0;
-
-        /**
-         * this method is called, when this movement is currently used to enable 
-         * an individual procession of collisions contacts for each movement
-         */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
-
-        /**
-         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
-         * the PhysicalThing can be acquired via the Creature
-         */
-        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep) = 0;
-
-        /**
-         * this method indicates if it is possible to change to the specified movement at this moment
-         */
-        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
-
-        /**
-         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
-         */
-        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
-
-        /**
-         * here all the stuff not (directly) relating the physics should be done
-         * this function is called every frame if this movement is activated and the
-         * Creature is in an active moving state. It is important to handle all 
-         * "Talentproben" etc here and not in the physics function!
-         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
-         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
-         */
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
-
-        /**
-         * this function is called if this movement is activated.
-         * it can be used to determine if a new "Talentprobe" is needed
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void activate() {mActive = true;}
-
-        /**
-         * this function is called every time this movement is deactivated.
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void deactivate() {mActive = false;}
-
-        /**
-         * this method is used to get to know if a movement can be used with a certain direction
-         * @retval true if this movement can be used with the direction, false otherwise
-         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
-         */
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const = 0;
-
-        /**
-         * this method is used to get to know if the given rotation can be used with this movement
-         * @retval true if the creature can perform this rotation with this movement
-         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
-         */
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const = 0;
-
-
-        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
-        bool isActive() const {return mActive;}
-
-        /// this method is used to return the yaw value of rotation movemenrts etc
-        virtual Ogre::Real getMovementDefinedValue() {return 0;}
-    protected:
-        CreatureController *mMovingCreature;
-        bool mActive;
-    };
 }
 #endif
+

Added: rl/trunk/engine/rules/include/FallDownMovement.h
===================================================================
--- rl/trunk/engine/rules/include/FallDownMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/FallDownMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __FallDownMovement_H__
+#define __FallDownMovement_H__
+
+#include "AbstractMovement.h"
+
+
+namespace rl
+{
+    class FallDownMovement : public AbstractMovement
+    {
+    public:
+        FallDownMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_FALLEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+        Ogre::Real mVel;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogBackwardsMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogBackwardsMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogBackwardsMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __JogBackwardsMovement_H__
+#define __JogBackwardsMovement_H__
+
+#include "JogMovement.h"
+
+
+namespace rl
+{
+    class JogBackwardsMovement : public JogMovement
+    {
+    public:
+        JogBackwardsMovement(CreatureController *creature) : JogMovement(creature)
+        {
+            mAnim = creature->getCreature()->getAnimation("joggen_rueckwaerts");
+        }
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 3.2;
+            return isPossible();
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogFastMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogFastMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogFastMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __JogFastMovement_H__
+#define __JogFastMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class JogFastMovement : public WalkMovement
+    {
+    public:
+        JogFastMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual void doTalentProbeIfNecessary();
+    protected:
+        Ogre::Real mTimePerAu;
+        Date mLastProbe;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JogMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JogMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JogMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,39 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __JogMovement_H__
+#define __JogMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class JogMovement : public WalkMovement
+    {
+    public:
+        JogMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JumpHighMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpHighMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpHighMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+
+#ifndef __JumpHighMovement_H__
+#define __JumpHighMovement_H__
+
+#include "AbstractMovement.h"
+
+
+
+namespace rl
+{
+    class JumpHighMovement : public AbstractMovement
+    {
+    public:
+        JumpHighMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mHeight;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+        Ogre::Real mMoveForward;
+        Creature::AnimationSpeedPair mAnimation;
+        Creature::AnimationSpeedPair mAnimationAbsprung;
+        Creature::AnimationSpeedPair mAnimationLandung;
+        Creature::AnimationSpeedPair mAnimationForCollision;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/JumpLongMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpLongMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpLongMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,59 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __JumpLongMovement_H__
+#define __JumpLongMovement_H__
+
+
+#include "AbstractMovement.h"
+
+
+
+namespace rl
+{
+    class JumpLongMovement : public AbstractMovement
+    {
+    public:
+        JumpLongMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mWidth;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+        Ogre::Real mApplyForceTime;
+        Ogre::Real mApplyForceTimer;
+        Ogre::Vector3 mLastForce;
+        Ogre::Real mVelocityBeforeJump;
+        Ogre::Real mTanJumpAngle;
+        Creature::AnimationSpeedPair mAnimation;
+        Creature::AnimationSpeedPair mAnimationAbsprung;
+        Creature::AnimationSpeedPair mAnimationLandung;
+        Creature::AnimationSpeedPair mAnimationForCollision;
+    };
+}
+
+#endif

Added: rl/trunk/engine/rules/include/JumpToTargetMovement.h
===================================================================
--- rl/trunk/engine/rules/include/JumpToTargetMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/JumpToTargetMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,38 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __JumpToTargetMovement_H__
+#define __JumpToTargetMovement_H__
+
+#include "JumpLongMovement.h"
+
+
+namespace rl
+{
+    class JumpToTargetMovement : public JumpLongMovement
+    {
+    public:
+        JumpToTargetMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_ZIELSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual void activate();
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/LieDownMovement.h
===================================================================
--- rl/trunk/engine/rules/include/LieDownMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/LieDownMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __LieDownMovement_H__
+#define __LieDownMovement_H__
+
+#include "AbstractMovement.h"
+
+
+namespace rl
+{
+    // auch wenn Fallen nicht m?glich ist (auf dem Boden und bewusstlos / Tod)
+    class LieDownMovement : public AbstractMovement
+    {
+    public:
+	LieDownMovement(CreatureController *creature);
+	virtual CreatureController::MovementType getId() const {return CreatureController::MT_LIEGEN;}
+	virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+	virtual void activate();
+	virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+        Creature::AnimationSpeedPair mAnim1;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/Makefile.am	2008-06-23 13:45:18 UTC (rev 4406)
@@ -48,10 +48,28 @@
 	TalentStateSet.h \
 	WaitJob.h \
 	Weapon.h \
-	ZauberStateSet.h
+	ZauberStateSet.h \
+	AbstractMovement.h \
+	FallDownMovement.h \
+	JogBackwardsMovement.h \
+	JogFastMovement.h \
+	JogMovement.h \
+	JumpHighMovement.h \
+	JumpLongMovement.h \
+	JumpToTargetMovement.h \
+	LieDownMovement.h \
+	RotateMovement.h \
+	SneakMovement.h \
+	SprintMovement.h \
+	StandAroundMovement.h \
+	StepRecognitionMovement.h \
+	StrafeMovement.h \
+	WalkBackwardsMovement.h \
+	WalkMovement.h
 
 CLEANFILES = stdinc.h.gch
 all-local: stdinc.h.gch
 stdinc.h.gch: $(noinst_HEADERS) stdinc.h
 	@echo Creating GCH file
 	g++ -I. stdinc.h
+

Added: rl/trunk/engine/rules/include/RotateMovement.h
===================================================================
--- rl/trunk/engine/rules/include/RotateMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/RotateMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RotateMovement_H__
+#define __RotateMovement_H__
+
+#include "AbstractMovement.h"
+
+
+namespace rl
+{
+    class RotateMovement : public AbstractMovement
+    {
+    public:
+        RotateMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void activate();
+        virtual void deactivate();
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+    protected:
+        Ogre::Radian mYaw;
+        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
+        virtual Ogre::Real getMovementDefinedValue() {return mYaw.valueRadians();}
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/SneakMovement.h
===================================================================
--- rl/trunk/engine/rules/include/SneakMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/SneakMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __SneakMovement_H__
+#define __SneakMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class SneakMovement : public WalkMovement
+    {
+    public:
+        SneakMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual bool canChangeToMovement(CreatureController::MovementType id);
+        virtual void requestChangeToMovement(CreatureController::MovementType id);
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mTimer;
+        Creature::AnimationSpeedPair mAnim1;
+        Creature::AnimationSpeedPair mAnim2;
+        Creature::AnimationSpeedPair mAnim3;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/SprintMovement.h
===================================================================
--- rl/trunk/engine/rules/include/SprintMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/SprintMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __SprintMovement_H__
+#define __SprintMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class SprintMovement : public WalkMovement
+    {
+    public:
+        SprintMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void activate();
+        virtual void doTalentProbeIfNecessary();
+    protected:
+        Ogre::Real mVelocityImprovement;
+        Date mLastProbe;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StandAroundMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StandAroundMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StandAroundMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,83 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __StandAroundMovement_H__
+#define __StandAroundMovement_H__
+
+#include "AbstractMovement.h"
+
+
+namespace rl
+{
+    class StandAroundMovement : public AbstractMovement
+    {
+    public:
+        StandAroundMovement(CreatureController *creature);
+        virtual ~StandAroundMovement();
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const
+        {
+            if( mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR )
+                return CreatureController::MT_LIEGEN;
+
+            return CreatureController::MT_FALLEN;
+        }
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+    protected:
+        Ogre::Vector3 mVelocity;
+        Creature::AnimationSpeedPair mAnimStehenRechts;
+        Creature::AnimationSpeedPair mAnimStehenLinks;
+        Creature::AnimationSpeedPair mAnimStehen;
+        mutable AbstractMovement *mRotationMovement;
+        mutable AbstractMovement *mStepRecognitionMovement;
+        virtual AbstractMovement* getRotationMovement() const
+        {
+            if( mRotationMovement == NULL)
+            {
+                mRotationMovement = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
+            }
+            if( mRotationMovement == NULL )
+            {
+                Throw(NullPointerException, "Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.");
+            }
+            return mRotationMovement;
+        }
+        virtual AbstractMovement* getStepRecognitionMovement() const
+        {
+            if( mStepRecognitionMovement == NULL )
+            {
+                mStepRecognitionMovement = mMovingCreature->getMovementFromId(CreatureController::MT_STUFENERKENNUNG);
+            }
+            if( mStepRecognitionMovement == NULL )
+            {
+                Throw(NullPointerException, "Konnte Movement mit der Id MT_STUFENERKENNUNG nicht finden.");
+            }
+            return mStepRecognitionMovement;
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StepRecognitionMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StepRecognitionMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StepRecognitionMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,50 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __StepRecognitionMovement_H__
+#define __StepRecognitionMovement_H__
+
+#include "AbstractMovement.h"
+
+
+namespace rl
+{
+    class StepRecognitionMovement : public AbstractMovement
+    {
+    public:
+        StepRecognitionMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STUFENERKENNUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
+        virtual void activate();
+        virtual void deactivate();
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep);
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const;
+    protected:
+        bool mMoveToNextTarget;
+        Ogre::Vector3 mNextTarget;
+        Ogre::Real mLastSquaredDistance;
+        Ogre::Real mLinearSpringK, mLinearDampingK;
+        PhysicsMaterialRaycast mRaycast;
+    };
+
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/StrafeMovement.h
===================================================================
--- rl/trunk/engine/rules/include/StrafeMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/StrafeMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __StrafeMovement_H__
+#define __StrafeMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class StrafeMovement : public WalkMovement
+    {
+    public:
+        StrafeMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    protected:
+        bool mLeft;
+        Creature::AnimationSpeedPair mAnim1;
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/WalkBackwardsMovement.h
===================================================================
--- rl/trunk/engine/rules/include/WalkBackwardsMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/WalkBackwardsMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __WalkBackwardsMovement_H__
+#define __WalkBackwardsMovement_H__
+
+#include "WalkMovement.h"
+
+
+namespace rl
+{
+    class WalkBackwardsMovement : public WalkMovement
+    {
+    public:
+        WalkBackwardsMovement(CreatureController *creature) : WalkMovement(creature)
+        {
+            mAnim = creature->getCreature()->getAnimation("gehen_rueckwaerts");
+        }
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 4.0;
+            return isPossible();
+        }
+    };
+}
+
+#endif
+

Added: rl/trunk/engine/rules/include/WalkMovement.h
===================================================================
--- rl/trunk/engine/rules/include/WalkMovement.h	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/include/WalkMovement.h	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __WalkMovement_H__
+#define __WalkMovement_H__
+
+#include "StandAroundMovement.h"
+
+
+namespace rl
+{
+    class WalkMovement : public StandAroundMovement
+    {
+    public:
+        WalkMovement(CreatureController *creature);
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity);
+        virtual bool isPossible() const;
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const;
+        virtual void applyAuChanges(Ogre::Real elapsedTime);
+        virtual void setAnimation(Ogre::Real elapsedTime);
+    protected:
+        Creature::AnimationSpeedPair mAnim;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -15,6 +15,7 @@
 */
 #include "stdinc.h" //precompiled header
 
+#include "AbstractMovement.h"
 #include "Actor.h"
 #include "Creature.h"
 #include "DsaManager.h"
@@ -28,6 +29,24 @@
 #include "GameObjectManager.h"
 #include "RulesMessages.h"
 
+// included Movements
+#include "AbstractMovement.h"
+#include "FallDownMovement.h"
+#include "JogBackwardsMovement.h"
+#include "JogFastMovement.h"
+#include "JogMovement.h"
+#include "JumpHighMovement.h"
+#include "JumpLongMovement.h"
+#include "JumpToTargetMovement.h"
+#include "LieDownMovement.h"
+#include "RotateMovement.h"
+#include "SneakMovement.h"
+#include "SprintMovement.h"
+#include "StandAroundMovement.h"
+#include "StepRecognitionMovement.h"
+#include "StrafeMovement.h"
+#include "WalkBackwardsMovement.h"
+#include "WalkMovement.h"
 
 
 using namespace Ogre;
@@ -37,1625 +56,7 @@
 {
     const Ogre::String CreatureController::PROPERTY_CREATUREID = "creature_id";
 
-    const Real minSquaredSpeed = 0.6;
 
-    // auch wenn Fallen nicht m?glich ist (auf dem Boden und bewusstlos / Tod)
-    class Liegen : public AbstractMovement
-    {
-    public:
-	Liegen(CreatureController *creature) :
-	    AbstractMovement(creature)
-	{
-	    mAnim = mMovingCreature->getCreature()->getAnimation("liegen");
-            mAnim1 = mMovingCreature->getCreature()->getAnimation("sterben");
-	}
-	virtual CreatureController::MovementType getId() const {return CreatureController::MT_LIEGEN;}
-	virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-	virtual void activate()
-	{
-	    LOG_MESSAGE(Logger::RULES, "Creature '"+mMovingCreature->getCreature()->getName()+"' liegt (evt bewusstlos) auf dem Boden.");
-	}
-	virtual void deactivate()
-	{
-	}
-        virtual bool calculateBaseVelocity(Real &velocity)
-	{
-	    velocity = 0.0f;
-	    return isPossible();
-	}
-        virtual bool isPossible() const
-	{
-	    return true;
-	}
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-	{
-	}
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-	{
-            // todo: wieder aufstehen
-            if( mMovingCreature->getCreature()->getLifeState() & (Effect::LS_DEAD | Effect::LS_UNCONSCIOUS) )
-                mMovingCreature->setAnimation(mAnim1.first, mAnim1.second, 1);
-            else
-                mMovingCreature->setAnimation(mAnim.first, mAnim.second, 1);
-	    return true;
-	}
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-	{
-	}
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-	{
-	    direction = Vector3::ZERO;
-		return false;
-	}
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-	{
-	    rotation = Vector3::ZERO;
-		return false;
-	}
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-        Creature::AnimationSpeedPair mAnim1;
-    };
-
-
-
-
-    class Fallen : public AbstractMovement
-    {
-    public:
-        Fallen(CreatureController *creature) :
-          AbstractMovement(creature)
-          {
-              mAnim = mMovingCreature->getCreature()->getAnimation("fallen");
-              //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_anfang");
-              //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_landung_aufgefangen");
-              //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_landung_verletzt");
-          }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_FALLEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual void activate()
-        {
-	    mVel = 0;
-        }
-        virtual void deactivate()
-        {
-            std::ostringstream oss;
-            oss << "Fallen v: " << mVel << "   ermittelte Hoehe: " << mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y));
-            int h = int(mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y)));
-	    oss << "    verwendete Hoehe: " << h << "m";
-
-	    if( h < 6 && h > 0 ) // nicht in den Regeln, aber angenehmer, bei gelunger GE-Probe noch aufgefangen
-	    {
-		int probe = mMovingCreature->getCreature()->doEigenschaftsprobe("GE", 2*h-6);
-		if( probe == RESULT_PATZER )
-		{
-		    h++;
-		    oss << "    GE-Patzer!";
-		}
-		else if( probe >= 0 )
-		{
-		    h = 0;
-		    oss << "    Nochmal geschickt gelandet!";
-		}
-	    }
-
-
-            if( h > 0 )
-            {
-
-                std::multiset<int> wuerfel;
-                for(int i = 0; i < h; i++)
-                    wuerfel.insert( DsaManager::getSingleton().rollD6() );
-                int probenErschwernis = h;
-                if( probenErschwernis > 10 )
-                    probenErschwernis = 10;
-
-                int taw = 0;
-                if( mMovingCreature->getCreature()->hasTalent("K???rperbeherrschung") )
-                {
-                    taw = mMovingCreature->getCreature()->doTalentprobe("K???rperbeherrschung", probenErschwernis);
-                }
-
-		int abgefangenerSchaden = 0;
-                for( int i = 0; i < taw; i++)
-                {
-                    if( wuerfel.size() <= 0 )
-                        break;
-		    abgefangenerSchaden += *(--(wuerfel.end()));
-                    wuerfel.erase(--(wuerfel.end()));
-                }
-
-
-                int sum = 0;
-                for( std::multiset<int>::iterator it = wuerfel.begin(); it != wuerfel.end(); it++)
-                    sum += *it;
-
-                mMovingCreature->getCreature()->damageLe(sum, Creature::LEDAMAGE_TP_A);
-
-                oss << "    Schaden: " << sum << "    abgefangener Schaden: " << abgefangenerSchaden;
-            }
-            LOG_MESSAGE(Logger::RULES, oss.str());
-
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE
-                && !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mVel = max(-mMovingCreature->getVelocity().y,mVel);
-            mMovingCreature->setAnimation(mAnim.first, mAnim.second, 0);
-            return true;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            direction = Vector3::ZERO;
-            return false;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-        Real mVel;
-    };
-
-
-
-
-    class Stehen : public AbstractMovement
-    {
-    public:
-        Stehen(CreatureController *creature) : 
-            AbstractMovement(creature), 
-            mVelocity(Vector3::ZERO), 
-            mRotationMovement(NULL), 
-            mStepRecognitionMovement(NULL)
-            {
-                mAnimStehenLinks = creature->getCreature()->getAnimation("stehen_links");
-                mAnimStehenRechts = creature->getCreature()->getAnimation("stehen_rechts");
-                mAnimStehen = creature->getCreature()->getAnimation("stehen");
-            }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const
-	{
-	    if( mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR )
-		return CreatureController::MT_LIEGEN;
-
-	    return CreatureController::MT_FALLEN;
-	}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            getRotationMovement()->activate();
-            getStepRecognitionMovement()->activate();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-            getRotationMovement()->deactivate();
-            getStepRecognitionMovement()->deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 0 &&
-                !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-            getRotationMovement()->calculateForceAndTorque(force, torque, timestep);
-
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            Vector3 vel = mMovingCreature->getVelocity();
-            vel.y = 0;
-            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
-            //if(vel.squaredLength() > mVelocity.squaredLength())
-            //    delay *= 1.5;
-            Vector3 diff = (mVelocity - vel);
-            force = mass * diff / delay;
-            // additional remove movement in wrong direction
-            force += mass * (mVelocity.normalisedCopy() * vel.length() - vel) / delay; // do we need this, does this improve the movement behaviour
-            // (changing direction during slow movement makes char slide sideways)
-            force.y = 0;
-
-            getStepRecognitionMovement()->calculateForceAndTorque(force, torque, timestep);
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            direction.normalise();
-            Real velocity;
-            calculateBaseVelocity(velocity);
-            mVelocity = direction * velocity;
-            applyAuChanges(elapsedTime);
-            setAnimation(elapsedTime);
-            bool ret = false;
-            if( getRotationMovement()->isPossible() )
-                if( getRotationMovement()->run(elapsedTime, direction, rotation) )
-                    ret = true;
-            if( getStepRecognitionMovement()->isPossible() )
-                if (getStepRecognitionMovement()->run(elapsedTime, direction, rotation) )
-                    ret = true;
-            return ret;
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real omegaY = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega().y;
-            if( omegaY > Degree(20).valueRadians() )
-                mMovingCreature->setAnimation(mAnimStehenRechts.first, mAnimStehenRechts.second);
-            else
-            {
-                if( omegaY < Degree(-20).valueRadians() )
-                    mMovingCreature->setAnimation(mAnimStehenLinks.first, mAnimStehenLinks.second);
-                else
-                    mMovingCreature->setAnimation(mAnimStehen.first, mAnimStehen.second);
-            }
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            return getRotationMovement()->isRotationPossible(rotation);
-        }
-    protected:
-        Ogre::Vector3 mVelocity;
-        Creature::AnimationSpeedPair mAnimStehenRechts;
-        Creature::AnimationSpeedPair mAnimStehenLinks;
-        Creature::AnimationSpeedPair mAnimStehen;
-        mutable AbstractMovement *mRotationMovement;
-        mutable AbstractMovement *mStepRecognitionMovement;
-        virtual AbstractMovement* getRotationMovement() const
-        {
-            if( mRotationMovement == NULL)
-            {
-                mRotationMovement = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
-            }
-            if( mRotationMovement == NULL )
-            {
-                Throw(NullPointerException, "Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.");
-            }
-            return mRotationMovement;
-        }
-        virtual AbstractMovement* getStepRecognitionMovement() const
-        {
-            if( mStepRecognitionMovement == NULL )
-            {
-                mStepRecognitionMovement = mMovingCreature->getMovementFromId(CreatureController::MT_STUFENERKENNUNG);
-            }
-            if( mStepRecognitionMovement == NULL )
-            {
-                Throw(NullPointerException, "Konnte Movement mit der Id MT_STUFENERKENNUNG nicht finden.");
-            }
-            return mStepRecognitionMovement;
-        }
-    };
-
-    class Drehen : public AbstractMovement
-    {
-    public:
-        Drehen(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
-        {
-            mRotLinearSpringK = 600.0f;
-            Real relationCoefficient = 1.0f;
-            mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.3f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 1 &&
-                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-        }
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mYaw = mMovingCreature->getCreature()->getActor()->getWorldOrientation().getYaw();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            Quaternion orientation;
-            Vector3 position;
-            body->getPositionOrientation(position, orientation);
-            // Calculate angular velocity
-            // We first need the yaw rotation from actual yaw to desired yaw
-            Vector3 src = orientation*Vector3::UNIT_Z;
-            src.y = 0;
-            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
-            dst.y = 0;
-            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
-
-            // using a spring system to apply the rotation
-            Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
-            Vector3 omega = body->getOmega();
-            omega.x = omega.z = 0;
-            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-
-            torque = springAcc * inertia;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mYaw += Radian(rotation.y);
-            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            Quaternion orientation;
-            Vector3 position;
-            body->getPositionOrientation(position, orientation);
-
-            Real diff = (orientation.getYaw() - mYaw).valueDegrees();
-            return diff <= 0.5f && diff >= -0.5f;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            Vector3 oldRotation(rotation);
-            rotation.x = rotation.z = 0;
-            return oldRotation.x == 0 && oldRotation.z == 0;
-        }
-    protected:
-        Ogre::Radian mYaw;
-        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
-        virtual Real getMovementDefinedValue() {return mYaw.valueRadians();}
-    };
-
-
-    class Gehen : public Stehen
-    {
-    public:
-        Gehen(CreatureController *creature) : Stehen(creature)
-        {
-            mAnim = creature->getCreature()->getAnimation("gehen");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 1 &&
-                !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            Stehen::run(elapsedTime, direction, rotation);
-            return true;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = direction.y = 0;
-            if( direction.z > 0 )
-                direction.z = 0;
-            return oldDirection.x == 0 && oldDirection.y == 0 && oldDirection.z > 0;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real speed =  -mMovingCreature->getVelocity().z;
-            if( fabs(speed) < 0.1 )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_JOGGEN:
-            case CreatureController::MT_LAUFEN:
-            case CreatureController::MT_RENNEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 1.0f )
-                    weight = mMovingCreature->getLastMovementChange() / 1.0f;
-                break;
-            default:
-                break;
-            }
-
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, speed * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL && relTimeOffset != 0 )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-    protected:
-        Creature::AnimationSpeedPair mAnim;
-    };
-
-    class Joggen : public Gehen
-    {
-    public:
-        Joggen(CreatureController *creature) : Gehen(creature)
-        {
-            mAnim = creature->getCreature()->getAnimation("joggen");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 2.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return Gehen::isPossible() &&
-                mMovingCreature->getCreature()->getAu() > 6;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed)
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, -mMovingCreature->getVelocity().z * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL && relTimeOffset != 0)
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-    };
-
-    class Laufen : public Gehen
-    {
-    public:
-        Laufen(CreatureController *creature) : Gehen(creature), mTimePerAu(1L), mLastProbe(0)
-        {
-            mAnim = creature->getCreature()->getAnimation("laufen");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 1.6f; // was 2.0
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > 6;
-            else
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength()< minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-            else
-                mMovingCreature->getCreature()->damageAu(elapsedTime/mTimePerAu);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, -mMovingCreature->getVelocity().z * mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL && relTimeOffset != 0)
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-        virtual void activate()
-        {
-            Gehen::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + Date::ONE_SPIELRUNDE >= now || mLastProbe == 0 )
-            {
-                mTimePerAu = 120; // was 180
-                if( mMovingCreature->getCreature()->hasTalent("Athletik") )
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 5;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 10;
-                    }
-                    else
-                    {
-                        mTimePerAu += taw * 5;
-                    }
-                }
-                else
-                {
-                    mTimePerAu = 120; // was 180
-                }
-            }
-        }
-    protected:
-        Real mTimePerAu;
-        Date mLastProbe;
-    };
-
-
-    class Rennen : public Gehen
-    {
-    public:
-        Rennen(CreatureController *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0)
-        {
-            mAnim = creature->getCreature()->getAnimation("rennen");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS();
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.3 &&
-                    mMovingCreature->getCreature()->getAu() > 6;
-            else
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.5 &&
-                    mMovingCreature->getCreature()->getAu() > 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            bool ret = Gehen::run(elapsedTime, direction, rotation);
-            mVelocity += mVelocityImprovement;
-            return ret;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
-                Stehen::applyAuChanges(elapsedTime);
-            else
-                mMovingCreature->getCreature()->damageAu(elapsedTime/1.5);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
-            {
-                Stehen::setAnimation(elapsedTime);
-                return;
-            }
-
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case CreatureController::MT_NONE:
-                break;
-            case CreatureController::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case CreatureController::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, fabs(mMovingCreature->getVelocity().z) *mAnim.second, 0, mAnim.first, weight );
-            if( meshAnim != NULL && relTimeOffset )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-        virtual void activate()
-        {
-            Gehen::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + mMovingCreature->getCreature()->getAuMax() * Date::ONE_SECOND >= now || mLastProbe == 0)
-            {
-                mVelocityImprovement = 0;
-                if( mMovingCreature->getCreature()->hasTalent("Athletik") )
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.2;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.3;
-                    }
-                    else
-                    {
-                        mVelocityImprovement += taw * 0.1;
-                    }
-                }
-                else
-                {
-                    mVelocityImprovement = 0;
-                }
-            }
-        }
-    protected:
-        Real mVelocityImprovement;
-        Date mLastProbe;
-    };
-
-    class RueckwaertsGehen : public Gehen
-    {
-    public:
-        RueckwaertsGehen(CreatureController *creature) : Gehen(creature)
-        {
-            mAnim = creature->getCreature()->getAnimation("gehen_rueckwaerts");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 4.0;
-            return isPossible();
-        }
-    };
-
-    class RueckwaertsJoggen : public Joggen
-    {
-    public:
-        RueckwaertsJoggen(CreatureController *creature) : Joggen(creature)
-        {
-            mAnim = creature->getCreature()->getAnimation("joggen_rueckwaerts");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 3.2;
-            return isPossible();
-        }
-    };
-
-
-    class SeitwaertsGehen : public Gehen
-    {
-    public:
-        SeitwaertsGehen(CreatureController *creature) : Gehen(creature), mLeft(true)
-        {
-            mAnim1 = creature->getCreature()->getAnimation("seitwaerts_rechts");
-            mAnim = creature->getCreature()->getAnimation("seitwaerts_links");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 4.0;
-            return isPossible();
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.z = direction.y = 0;
-            return oldDirection.z == 0 && oldDirection.y == 0;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mLeft = direction.x < 0;
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mLeft )
-                mMovingCreature->setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature->getVelocity().x);
-            else
-                mMovingCreature->setAnimation(mAnim.first, mAnim.second * -mMovingCreature->getVelocity().x);
-        }
-    protected:
-        bool mLeft;
-        Creature::AnimationSpeedPair mAnim1;
-    };
-
-    class Schleichen : public Gehen
-    {
-    public:
-        Schleichen(CreatureController *creature) : Gehen(creature), mState(UP), mTimer(0)
-        {
-            mAnim = creature->getCreature()->getAnimation("schleichen");
-            mAnim1= creature->getCreature()->getAnimation("schleichen_vorwaerts");
-            mAnim2 = creature->getCreature()->getAnimation("stehen_zu_schleichen");
-            mAnim3= creature->getCreature()->getAnimation("schleichen_zu_stehen");
-            mAnimStehen= creature->getCreature()->getAnimation("stehen");
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 6.0;
-            return isPossible();
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer > 0.5f )
-                    mState = DOWN;
-            }
-            if( mState == UP )
-            {
-                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer > 0.5f )
-                    mState = UP;
-            }
-            if( mState == DOWN )
-            {
-                //setAnimation(elapsedTime);
-                direction.normalise();
-                Real velocity;
-                calculateBaseVelocity(velocity);
-                mVelocity = direction * velocity;
-                if( direction == Vector3::ZERO || (-mMovingCreature->getVelocity().z) < 0.1)
-                    mMovingCreature->setAnimation(mAnim.first, mAnim.second);
-                else
-                    mMovingCreature->setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature->getVelocity().z);
-                applyAuChanges(elapsedTime);
-                if( getRotationMovement()->isPossible() )
-                    getRotationMovement()->run(elapsedTime, direction, rotation);
-            }
-            else
-                mVelocity = Vector3::ZERO;
-            return true;
-        }
-        void applyAuChanges(Ogre::Real elapsedTime) {}
-        virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
-        virtual void activate()
-        {
-            Gehen::activate();
-            mState = UPTODOWN;
-            mMovingCreature->setAnimation(mAnim2.first,mAnim2.second,1,mAnimStehen.first);
-            mTimer = 0;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == UP;
-        }
-        virtual void requestChangeToMovement(CreatureController::MovementType id)
-        {
-            if( mState == DOWN )
-            {
-                mState = DOWNTOUP;
-                mMovingCreature->setAnimation(mAnim3.first,mAnim3.second,1,mAnimStehen.first);
-                mTimer = 0;
-            }
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Real mTimer;
-        Creature::AnimationSpeedPair mAnim1;
-        Creature::AnimationSpeedPair mAnim2;
-        Creature::AnimationSpeedPair mAnim3;
-    };
-
-
-    class Hochsprung : public AbstractMovement
-    {
-    public:
-        Hochsprung(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0), mMoveForward(0)
-        {
-            mAnimation = creature->getCreature()->getAnimation("hochsprung");
-            mAnimationAbsprung = creature->getCreature()->getAnimation("hochsprung_absprung");
-            mAnimationLandung = creature->getCreature()->getAnimation("hochsprung_landung");
-            mAnimationForCollision = creature->getCreature()->getAnimation("stehen");  // wird das hier gebraucht?
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature->setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
-            mTimer = 0;
-            calculateBaseVelocity(mHeight);
-
-            if( mMovingCreature->getCreature()->hasTalent("Athletik") )
-            {
-                int tap = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
-                if( tap > 0 )
-                {
-                    if( tap == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 12.5;
-                    }
-                    else if( tap == RESULT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
-                    }
-                    else
-                    {
-                        mHeight += tap / 25.0;
-                    }
-                }
-            }
-            else
-            {
-            }
-            mMovingCreature->getCreature()->damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
-                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 4.0 / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch???pfung ein KK abziehen
-            //if( mErschoepfung > getEigenschaft("KO") )
-            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() < getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return
-                    (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
-                    mMovingCreature->getCreature()->getAu() > 6 &&
-                    !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-            else
-                return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 8 &&
-                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
-                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            if( mJumpNow )
-            {
-                mJumpNow = false;
-
-                Real m = mass;
-                Real g = PhysicsManager::getSingleton().getGravity().length();
-                Real t = timestep;
-                Real h = mHeight;
-                Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
-                force = Vector3(0,
-                    jumpForce,
-                    0);
-                mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
-            }
-            else if (mState == UP && mMoveForward != 0) // try to move forward, if wanted
-            {
-                // low velocity towards this direction
-                if(mMoveForward > 0)
-                    mMoveForward = 1.0;
-                else
-                    mMoveForward = -1.0;
-
-
-
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-                body->getMassMatrix(mass, inertia);
-
-                Vector3 vel = mMovingCreature->getVelocity();
-                Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
-                Real diff = (mMoveForward - vel.z);
-                force.z += mass * diff / delay;
-            }
-
-            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mMoveForward = direction.z;
-
-            if( mState == DOWN )
-            {
-                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.5f )
-                {
-                    mState = DOWN;
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer < 0.5f )
-                {
-                    mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
-                }
-                else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature->setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
-                    mTimer = 0;
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.25f )
-                {
-                    mState = UP;
-                    mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
-                    mMovingCreature->setAnimation(mAnimation.first, mAnimation.second);
-                    mJumpNow = true;
-                    mTimer = 0;
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = 0;
-            if(direction.y < 0)
-                direction.y = 0;
-            return oldDirection.x == 0 && oldDirection.y > 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mHeight;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-        Ogre::Real mMoveForward;
-        Creature::AnimationSpeedPair mAnimation;
-        Creature::AnimationSpeedPair mAnimationAbsprung;
-        Creature::AnimationSpeedPair mAnimationLandung;
-        Creature::AnimationSpeedPair mAnimationForCollision;
-    };
-
-
-    class Weitsprung : public AbstractMovement
-    {
-    public:
-        Weitsprung(CreatureController *creature) :
-          AbstractMovement(creature), mState(DOWN), mWidth(0),
-              mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
-              mApplyForceTimer(0), mLastForce(Vector3::ZERO),
-              mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17)))
-        {
-            mAnimation = creature->getCreature()->getAnimation("weitsprung");
-            mAnimationAbsprung = creature->getCreature()->getAnimation("weitsprung_absprung");
-            mAnimationLandung = creature->getCreature()->getAnimation("weitsprung_landung");
-            mAnimationForCollision = creature->getCreature()->getAnimation("rennen"); // wird das hier gebraucht?
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature->setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
-            mTimer = 0;
-            calculateBaseVelocity(mWidth);
-
-
-            // the person will only achieve this width if it is running
-            // retrieve run movement
-            AbstractMovement *run = mMovingCreature->getMovementFromId(CreatureController::MT_RENNEN);
-            if( run != NULL )
-            {
-                Real vel(0);
-                run->calculateBaseVelocity(vel);
-                Real factor = -mMovingCreature->getVelocity().z / vel;
-                factor = std::max(Real(0),factor);
-                // without moving before, the width will be 1/3
-                mWidth = mWidth/3. + mWidth * 2./3. * factor;
-            }
-
-            if( mMovingCreature->getCreature()->hasTalent("Athletik") )
-            {
-                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
-                if( taw > 0 )
-                {
-                    if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
-                    }
-                    else if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 50.0;
-                    }
-                    else
-                    {
-                        mWidth += taw / 50.0;
-                    }
-                }
-            }
-
-            mMovingCreature->getCreature()->damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
-                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch???pfung ein KK abziehen
-            //if( mErschoepfung > getEigenschaft("KO") )
-            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() < getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return
-                    (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
-                    mMovingCreature->getCreature()->getAu() > 6 &&
-                    !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-            else
-                return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 8 &&
-                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
-                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-
-            if( mJumpNow && timestep != 0 )
-            {
-                mApplyForceTimer += timestep;
-
-                if( mApplyForceTimer == timestep // first time
-                    && mApplyForceTimer < mApplyForceTime )// this is handled below
-                {
-                    Real t1 = mApplyForceTime;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx >= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-                        ax =  (v1x - v0) / t1;
-                        ay = v1y/t1 + g;
-                    }
-
-                    mLastForce.x = 0;
-                    mLastForce.y = ay * mass;
-                    mLastForce.z = -ax * mass;
-                }
-
-                if( mApplyForceTimer < mApplyForceTime )
-                {
-                    force = mLastForce;
-                }
-                else
-                {
-                    mJumpNow = false;
-                    // adoption of the formula to our real jump time
-                    Real t1 = mApplyForceTimer;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx >= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-
-                        Vector3 v_now = mMovingCreature->getVelocity();
-                        ax =  (v1x - -v_now.z) / timestep;
-                        ay = (v1y- v_now.y)/timestep + g;
-                    }
-
-                    force.x = 0;
-                    force.y = ay * mass;
-                    force.z = -ax * mass;
-                }
-            }
-
-            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == DOWN )
-            {
-                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.2f )
-                {
-                    mState = DOWN;
-LOG_MESSAGE(Logger::RULES, "Weitsprung: DOWN");
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer < 0.2f )
-                {
-                    mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
-                }
-                else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature->setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
-                    mTimer = 0;
-LOG_MESSAGE(Logger::RULES, "Weitsprung: UPTODOWN");
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.3f )
-                {
-                    mState = UP;
-                    mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
-                    mMovingCreature->setAnimation(mAnimation.first, mAnimation.second, 1, mAnimationForCollision.first);
-                    mJumpNow = true;
-                    mApplyForceTimer = 0;
-                    mVelocityBeforeJump = -mMovingCreature->getVelocity().z;
-                    mTimer = 0;
-LOG_MESSAGE(Logger::RULES, "Weitsprung: UP");
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = 0;
-            if(direction.y <= 0 || direction.z >= 0)
-                direction.y = direction.z = 0;
-            return oldDirection.x == 0 && oldDirection.z < 0 && oldDirection.y > 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(CreatureController::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mWidth;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-        Ogre::Real mApplyForceTime;
-        Ogre::Real mApplyForceTimer;
-        Ogre::Vector3 mLastForce;
-        Ogre::Real mVelocityBeforeJump;
-        Ogre::Real mTanJumpAngle;
-        Creature::AnimationSpeedPair mAnimation;
-        Creature::AnimationSpeedPair mAnimationAbsprung;
-        Creature::AnimationSpeedPair mAnimationLandung;
-        Creature::AnimationSpeedPair mAnimationForCollision;
-    };
-
-
-    class StepRecognition : public AbstractMovement
-    {
-    public:
-        StepRecognition(CreatureController *creature) : 
-            AbstractMovement(creature), 
-            mMoveToNextTarget(false)
-        {
-            mLinearSpringK = 600.0f;
-            Real relationCoefficient = 1.2f;
-            mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-        }
-        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STUFENERKENNUNG;}
-        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mMoveToNextTarget = false;
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.0f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 0 &&
-                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
-        {
-            // move to nextTarget
-            if( mMoveToNextTarget )
-            {
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-                body->getMassMatrix(mass, inertia);
-
-                Vector3 pos = mMovingCreature->getCreature()->getPosition();
-                Vector3 diff = mNextTarget - pos;
-
-                Vector3 vel = body->getVelocity();
-
-                force.y = mass*( mLinearSpringK*diff.y - mLinearDampingK*vel.y );
-                std::ostringstream oss;
-                oss << "Step-Recognition: diff: " << diff.y << "    vel: " << vel.y << "    Step force: " << force.y;
-		oss << "    DiffToTarget: " << 
-		    mMovingCreature->getCreature()->getOrientation().Inverse() * 
-		    (mNextTarget - mMovingCreature->getCreature()->getPosition());
-                LOG_MESSAGE(Logger::RULES, oss.str());
-            }
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            Vector3 vel = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->getVelocity();
-	    Real velY = vel.y;
-            vel.y = 0;
-
-            if( !mMoveToNextTarget ) // check if we need to move up for a step
-            {
-                // raycast in the direction we should move to
-                Vector3 globalDir = mMovingCreature->getCreature()->getOrientation() * direction; // the direction in global space
-                if( globalDir == Vector3::ZERO )
-                    return true;
-
-                Real raylen = vel.length() / 3;  // use longer ray, if higher velocity
-                if ( raylen < 0.5 )
-                    raylen = 0.4;
-
-                //std::ostringstream oss;
-                //oss << "StepRecognition Raylen: " << raylen;
-                //LOG_MESSAGE(Logger::RULES, oss.str());
-
-
-                // raycasts
-                PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
-
-                Vector3 start = mMovingCreature->getCreature()->getPosition() + Vector3::UNIT_Y * 0.1f;
-                globalDir.y = 0;
-                globalDir.normalise();
-                Vector3 end = start + globalDir*raylen;
-
-                bool foundbody = false;
-                Real foundDistance = 0;
-
-                RaycastInfo info;
-                do
-                {
-                    info = 
-                        mRaycast.execute(
-                            PhysicsManager::getSingleton()._getNewtonWorld(),
-                            &materialVector,
-                            start, end);
-
-                    // do we need to check bodies left and right of this ray? (step width?)
-
-
-                    // already found nearer body
-                    if( foundbody )
-                    {
-                        if( info.mBody && (info.mDistance*raylen >= foundDistance*raylen + 0.19) || // step deep enough
-                            !info.mBody )
-                        {
-                            // found a step
-                            mMoveToNextTarget = true;
-                            mNextTarget = start + globalDir*raylen*foundDistance + 0.1 * globalDir;
-                            std::ostringstream oss;
-			    Vector3 stepInLocalCoords = mNextTarget - mMovingCreature->getCreature()->getPosition();
-			    Quaternion ori = mMovingCreature->getCreature()->getOrientation();
-			    stepInLocalCoords = ori.Inverse() * stepInLocalCoords;
-                            oss << "Step-Recognition: Next Step: " << stepInLocalCoords;
-                            LOG_MESSAGE(Logger::RULES, oss.str());
-                            break;
-                        }
-                    }
-
-                    if( info.mBody )
-                    {
-                        foundbody = true;
-                        foundDistance = info.mDistance;
-                    }
-
-
-                    start += Vector3::UNIT_Y * 0.05f;
-                    end += Vector3::UNIT_Y * 0.05f;
-                }
-                while( info.mBody && (start - mMovingCreature->getCreature()->getPosition()).y <= 0.5 );
-            }
-
-
-            // check if the target is still needed
-            // perform check also to verify found step
-            if( mMoveToNextTarget )
-            {
-                Vector3 diffToTarget = mNextTarget - mMovingCreature->getCreature()->getPosition();
-		Real diffToTargetY = diffToTarget.y;
-                diffToTarget.y = 0;
-                
-                // different direction
-                Vector3 globalDir = mMovingCreature->getCreature()->getOrientation() * direction; // the direction in global space
-		globalDir.y = 0;
-
-
-                if( globalDir == Vector3::ZERO )
-                {
-                    mMoveToNextTarget = false;
-                    LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step direction null");
-                    return false;
-                }
-
-                // target reached
-                if( diffToTarget.squaredLength() < 0.01)
-                {
-                    mMoveToNextTarget = false;
-                    LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step reached");
-                    return false;
-                }
-
-                // different direction
-                Quaternion oriDiff = diffToTarget.getRotationTo(globalDir, Vector3::UNIT_Y);
-                Degree angleDiff;
-                Vector3 axis = Vector3::UNIT_Y;
-                oriDiff.ToAngleAxis(angleDiff, axis);
-                Real f = angleDiff.valueDegrees();
-                //std::ostringstream oss;
-                //oss << "Step-Recognition: angle: " << f << "    axis: " << axis;
-                //LOG_MESSAGE(Logger::RULES, oss.str());
-               //if( !diffToTarget.directionEquals(globalDir, Degree(15)) )
-		if( f > 2.0f )
-                {
-                    mMoveToNextTarget = false;
-                    //LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step direction wrong");
-                    return false;
-                }
-
-
-		// already above target, but slow velocity
-		if( diffToTargetY < 0 && fabs(velY) < 0.01 )
-		{
-                    mMoveToNextTarget = false;
-                    //LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: slow and abov target-height!");
-                    return false;
-		}
-            }
-
-            return mMoveToNextTarget;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            Vector3 oldRotation(rotation);
-            rotation = Vector3::ZERO;
-            return oldRotation == Vector3::ZERO;
-        }
-    protected:
-        bool mMoveToNextTarget;
-        Vector3 mNextTarget;
-        Real mLastSquaredDistance;
-        Real mLinearSpringK, mLinearDampingK;
-        PhysicsMaterialRaycast mRaycast;
-    };
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-// ---------------------------- CreatureController -----------------------------
-
     CreatureController::CreatureController(Creature *creature) :
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),
@@ -1685,49 +86,52 @@
         movementPair.second = NULL;
         mMovementMap.insert(movementPair);
         movementPair.first = MT_LIEGEN;
-        movementPair.second = new Liegen (this);
+        movementPair.second = new LieDownMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_FALLEN;
-        movementPair.second = new Fallen (this);
+        movementPair.second = new FallDownMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_DREHEN;
-        movementPair.second = new Drehen (this);
+        movementPair.second = new RotateMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_STEHEN;
-        movementPair.second = new Stehen (this);
+        movementPair.second = new StandAroundMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_GEHEN;
-        movementPair.second = new Gehen (this);
+        movementPair.second = new WalkMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_JOGGEN;
-        movementPair.second = new Joggen (this);
+        movementPair.second = new JogMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_LAUFEN;
-        movementPair.second = new Laufen (this);
+        movementPair.second = new JogFastMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RENNEN;
-        movementPair.second = new Rennen (this);
+        movementPair.second = new SprintMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RUECKWAERTS_GEHEN;
-        movementPair.second = new RueckwaertsGehen (this);
+        movementPair.second = new WalkBackwardsMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_RUECKWAERTS_JOGGEN;
-        movementPair.second = new RueckwaertsJoggen (this);
+        movementPair.second = new JogBackwardsMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_SEITWAERTS_GEHEN;
-        movementPair.second = new SeitwaertsGehen (this);
+        movementPair.second = new StrafeMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_SCHLEICHEN;
-        movementPair.second = new Schleichen (this);
+        movementPair.second = new SneakMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_HOCHSPRUNG;
-        movementPair.second = new Hochsprung (this);
+        movementPair.second = new JumpHighMovement (this);
         mMovementMap.insert(movementPair);
         movementPair.first = MT_WEITSPRUNG;
-        movementPair.second = new Weitsprung (this);
+        movementPair.second = new JumpLongMovement (this);
         mMovementMap.insert(movementPair);
+        movementPair.first = MT_ZIELSPRUNG;
+        movementPair.second = new JumpToTargetMovement (this);
+        mMovementMap.insert(movementPair);
         movementPair.first = MT_STUFENERKENNUNG;
-        movementPair.second = new StepRecognition (this);
+        movementPair.second = new StepRecognitionMovement (this);
         mMovementMap.insert(movementPair);
 
         mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
@@ -2184,8 +588,5 @@
         }
 	mAbstractLocation = location;
     }
-    
-
-
 }
 

Added: rl/trunk/engine/rules/src/FallDownMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/FallDownMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/FallDownMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,147 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+
+#include "FallDownMovement.h"
+#include "DsaManager.h"
+
+
+using namespace std;
+using namespace Ogre;
+
+namespace rl
+{
+    FallDownMovement::FallDownMovement(CreatureController *creature) :
+        AbstractMovement(creature)
+    {
+        mAnim = mMovingCreature->getCreature()->getAnimation("fallen");
+        //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_anfang");
+        //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_landung_aufgefangen");
+        //mAnim = mMovingCreature->getCreature()->getAnimation("fallen_landung_verletzt");
+    }
+    
+        
+    void FallDownMovement::activate()
+    {
+        mVel = 0;
+    }
+        
+    void FallDownMovement::deactivate()
+    {    
+        std::ostringstream oss;
+        oss << "Fallen v: " << mVel << "   ermittelte Hoehe: " << mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y));
+        int h = int(mVel*mVel/(2* fabs(PhysicsManager::getSingleton().getGravity().y)));
+        oss << "    verwendete Hoehe: " << h << "m";
+
+        if( h < 6 && h > 0 ) // nicht in den Regeln, aber angenehmer, bei gelunger GE-Probe noch aufgefangen
+        {
+            int probe = mMovingCreature->getCreature()->doEigenschaftsprobe("GE", 2*h-6);
+	
+            if( probe == RESULT_PATZER )
+            {
+                h++;
+                oss << "    GE-Patzer!";
+            }
+            else if( probe >= 0 )
+            {
+                h = 0;
+                oss << "    Nochmal geschickt gelandet!";
+            }
+        }
+
+        
+        if( h > 0 )
+        {
+            std::multiset<int> wuerfel;
+            for(int i = 0; i < h; i++)
+                wuerfel.insert( DsaManager::getSingleton().rollD6() );
+
+            int probenErschwernis = h;
+            if( probenErschwernis > 10 )
+                probenErschwernis = 10;
+
+            int taw = 0;
+            if( mMovingCreature->getCreature()->hasTalent("K???rperbeherrschung") )
+            {
+                taw = mMovingCreature->getCreature()->doTalentprobe("K???rperbeherrschung", probenErschwernis);
+            }
+
+            int abgefangenerSchaden = 0;
+            for( int i = 0; i < taw; i++)
+            {
+                if( wuerfel.size() <= 0 )
+                    break;
+                abgefangenerSchaden += *(--(wuerfel.end()));
+                wuerfel.erase(--(wuerfel.end()));
+            }
+
+
+            int sum = 0;
+            for( std::multiset<int>::iterator it = wuerfel.begin(); it != wuerfel.end(); it++)
+                sum += *it;
+
+            mMovingCreature->getCreature()->damageLe(sum, Creature::LEDAMAGE_TP_A);
+
+            oss << "    Schaden: " << sum << "    abgefangener Schaden: " << abgefangenerSchaden;
+        }
+        LOG_MESSAGE(Logger::RULES, oss.str());
+
+    }
+    
+    bool FallDownMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+        
+    
+    bool FallDownMovement::isPossible() const
+    {
+        return
+            mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE
+            && !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
+    }
+
+    
+    void FallDownMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+    }
+    
+    bool FallDownMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mVel = max(-mMovingCreature->getVelocity().y,mVel);
+        mMovingCreature->setAnimation(mAnim.first, mAnim.second, 0);
+        return true;
+    }
+    
+    void FallDownMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+    
+    bool FallDownMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        direction = Vector3::ZERO;
+        return false;
+    }
+    
+    bool FallDownMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+}
+

Added: rl/trunk/engine/rules/src/JogFastMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JogFastMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JogFastMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,149 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+
+#include "JogFastMovement.h"
+#include "DsaManager.h"
+#include "MeshAnimation.h"
+
+
+using namespace std;
+using namespace Ogre;
+
+
+const Real minSquaredSpeed = 0.6f;
+
+namespace rl
+{
+    JogFastMovement::JogFastMovement(CreatureController *creature) : WalkMovement(creature), mTimePerAu(1L), mLastProbe(0)
+    {
+        mAnim = creature->getCreature()->getAnimation("laufen");
+    }
+    
+    
+    
+    bool JogFastMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS() / 1.6f; // was 2.0
+        return isPossible();
+    }
+    
+    bool JogFastMovement::isPossible() const
+    {
+        if( mMovingCreature->getMovement() == this )
+            return WalkMovement::isPossible() &&
+                mMovingCreature->getCreature()->getAu() > 6;
+        else
+            return WalkMovement::isPossible() &&
+                mMovingCreature->getCreature()->getAu() > 8;
+    }
+
+
+    
+    bool JogFastMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        doTalentProbeIfNecessary();
+        return WalkMovement::run(elapsedTime, direction, rotation);
+    }
+        
+    void JogFastMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength()< minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+        else
+            mMovingCreature->getCreature()->damageAu(elapsedTime/mTimePerAu);
+    }
+
+    
+    void JogFastMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature->getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+
+        // apply relTimeOffset only once
+        if( mMovingCreature->getLastMovementChange() > elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, -mMovingCreature->getVelocity().z * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL && relTimeOffset != 0)
+            meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
+    }
+
+    
+    void JogFastMovement::activate()
+    {
+        WalkMovement::activate();
+        doTalentProbeIfNecessary();
+    }
+    
+    void JogFastMovement::doTalentProbeIfNecessary()
+    {
+        Date now = DsaManager::getSingleton().getCurrentDate();
+        if( mLastProbe + Date::ONE_SPIELRUNDE >= now || mLastProbe == 0 )
+        {
+            mTimePerAu = 120; // was 180
+            if( mMovingCreature->getCreature()->hasTalent("Athletik") )
+            {
+                mLastProbe = now;
+                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
+                if( taw == RESULT_AUTOERFOLG )
+                {
+                    mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 5;
+                }
+                else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 10;
+                }
+                else
+                {
+                    mTimePerAu += taw * 5;
+                }
+            }
+            else
+            {
+                mTimePerAu = 120; // was 180
+            }
+        }
+    }
+}
+

Added: rl/trunk/engine/rules/src/JogMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JogMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JogMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,93 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JogMovement.h"
+#include "MeshAnimation.h"
+
+
+using namespace std;
+using namespace Ogre;
+
+
+const Real minSquaredSpeed = 0.6f;
+
+
+namespace rl
+{
+    JogMovement::JogMovement(CreatureController *creature) : WalkMovement(creature)
+    {
+        mAnim = creature->getCreature()->getAnimation("joggen");
+    }
+        
+    bool JogMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS() / 2.0f;
+        return isPossible();
+    }
+    
+    bool JogMovement::isPossible() const
+    {
+        return WalkMovement::isPossible() &&
+            mMovingCreature->getCreature()->getAu() > 6;
+    }
+
+    void JogMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+    }
+    
+    void JogMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed)
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature->getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+        // apply relTimeOffset only once
+        if( mMovingCreature->getLastMovementChange() > elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, -mMovingCreature->getVelocity().z * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL && relTimeOffset != 0)
+            meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/JumpHighMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpHighMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpHighMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,219 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JumpHighMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+
+namespace rl
+{
+    JumpHighMovement::JumpHighMovement(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0), mMoveForward(0)
+    {
+        mAnimation = creature->getCreature()->getAnimation("hochsprung");
+        mAnimationAbsprung = creature->getCreature()->getAnimation("hochsprung_absprung");
+        mAnimationLandung = creature->getCreature()->getAnimation("hochsprung_landung");
+        mAnimationForCollision = creature->getCreature()->getAnimation("stehen");  // wird das hier gebraucht?
+    }
+
+    void JumpHighMovement::activate()
+    {
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature->setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mHeight);
+
+        if( mMovingCreature->getCreature()->hasTalent("Athletik") )
+        {
+            int tap = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
+            if( tap > 0 )
+            {
+                if( tap == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 12.5;
+                }
+                else if( tap == RESULT_AUTOERFOLG )
+                {
+                    mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
+                }
+                else
+                {
+                    mHeight += tap / 25.0;
+                }
+            }
+        }
+        else
+        {
+        }
+        mMovingCreature->getCreature()->damageAu(2./3);
+    }
+
+    void JumpHighMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool JumpHighMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
+                mMovingCreature->getCreature()->getEigenschaft("KK")) / 4.0 / 5.0;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch???pfung ein KK abziehen
+        //if( mErschoepfung > getEigenschaft("KO") )
+        //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() < getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
+        return isPossible();
+    }
+
+    bool JumpHighMovement::isPossible() const
+    {
+        if( mMovingCreature->getMovement() == this )
+            return
+                (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
+                 mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
+                mMovingCreature->getCreature()->getAu() > 6 &&
+                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+        else
+            return
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 8 &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
+                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+    }
+
+    void JumpHighMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+        body->getMassMatrix(mass, inertia);
+
+        if( mJumpNow )
+        {
+            mJumpNow = false;
+
+            Real m = mass;
+            Real g = PhysicsManager::getSingleton().getGravity().length();
+            Real t = timestep;
+            Real h = mHeight;
+            Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
+            force = Vector3(0,
+                    jumpForce,
+                    0);
+            mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
+        }
+        else if (mState == UP && mMoveForward != 0) // try to move forward, if wanted
+        {
+            // low velocity towards this direction
+            if(mMoveForward > 0)
+                mMoveForward = 1.0;
+            else
+                mMoveForward = -1.0;
+
+
+
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
+            Vector3 vel = mMovingCreature->getVelocity();
+            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
+            Real diff = (mMoveForward - vel.z);
+            force.z += mass * diff / delay;
+        }
+
+        Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+    }
+
+    bool JumpHighMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mMoveForward = direction.z;
+
+        if( mState == DOWN )
+        {
+            mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer >= 0.5f )
+            {
+                mState = DOWN;
+            }
+        }
+        if( mState == UP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer < 0.5f )
+            {
+                mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
+            }
+            else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
+            {
+                mState = UPTODOWN;
+                mMovingCreature->setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
+                mTimer = 0;
+            }
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer >= 0.25f )
+            {
+                mState = UP;
+                mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
+                mMovingCreature->setAnimation(mAnimation.first, mAnimation.second);
+                mJumpNow = true;
+                mTimer = 0;
+            }
+        }
+        return false;
+    }
+
+    bool JumpHighMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = 0;
+        if(direction.y < 0)
+            direction.y = 0;
+        return oldDirection.x == 0 && oldDirection.y > 0;
+    }
+
+    bool JumpHighMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+
+    bool JumpHighMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == DOWN;
+    }
+}
+
+

Added: rl/trunk/engine/rules/src/JumpLongMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpLongMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpLongMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,260 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JumpLongMovement.h"
+
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    JumpLongMovement::JumpLongMovement(CreatureController *creature) :
+        AbstractMovement(creature), mState(DOWN), mWidth(0),
+        mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
+        mApplyForceTimer(0), mLastForce(Vector3::ZERO),
+        mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(27)))
+    {
+        mAnimation = creature->getCreature()->getAnimation("weitsprung");
+        mAnimationAbsprung = creature->getCreature()->getAnimation("weitsprung_absprung");
+        mAnimationLandung = creature->getCreature()->getAnimation("weitsprung_landung");
+        mAnimationForCollision = creature->getCreature()->getAnimation("rennen"); // wird das hier gebraucht?
+    }
+
+    void JumpLongMovement::activate()
+    {
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature->setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mWidth);
+
+
+        // the person will only achieve this width if it is running
+        // retrieve run movement
+        AbstractMovement *run = mMovingCreature->getMovementFromId(CreatureController::MT_RENNEN);
+        if( run != NULL )
+        {
+            Real vel(0);
+            run->calculateBaseVelocity(vel);
+            Real factor = -mMovingCreature->getVelocity().z / vel;
+            factor = std::max(Real(0),factor);
+            // without moving before, the width will be 1/3
+            mWidth = mWidth/3. + mWidth * 2./3. * factor;
+        }
+
+        if( mMovingCreature->getCreature()->hasTalent("Athletik") )
+        {
+            int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
+            if( taw > 0 )
+            {
+                if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
+                }
+                else if( taw == RESULT_AUTOERFOLG )
+                {
+                    mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 50.0;
+                }
+                else
+                {
+                    mWidth += taw / 50.0;
+                }
+            }
+        }
+
+        mMovingCreature->getCreature()->damageAu(2./3);
+    }
+
+    void JumpLongMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool JumpLongMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
+                mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch???pfung ein KK abziehen
+        //if( mErschoepfung > getEigenschaft("KO") )
+        //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() < getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
+        return isPossible();
+    }
+
+    bool JumpLongMovement::isPossible() const
+    {
+        if( mMovingCreature->getMovement() == this )
+            return
+                (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
+                 mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
+                mMovingCreature->getCreature()->getAu() > 6 &&
+                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+        else
+            return
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 8 &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
+                !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+    }
+
+    void JumpLongMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+        body->getMassMatrix(mass, inertia);
+
+
+        if( mJumpNow && timestep != 0 )
+        {
+            mApplyForceTimer += timestep;
+
+            if( mApplyForceTimer == timestep // first time
+                    && mApplyForceTimer < mApplyForceTime )// this is handled below
+            {
+                Real t1 = mApplyForceTime;
+                Real sx = mWidth;
+                Real g = -PhysicsManager::getSingleton().getGravity().y;
+                Real v0 = mVelocityBeforeJump;
+                Real ax = 0;
+                Real ay = 0;
+
+                if( t1 != 0 || 2 * sx >= v0 * t1 )
+                {
+                    Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                    Real v1y = mTanJumpAngle * v1x;
+                    ax =  (v1x - v0) / t1;
+                    ay = v1y/t1 + g;
+                }
+
+                mLastForce.x = 0;
+                mLastForce.y = ay * mass;
+                mLastForce.z = -ax * mass;
+            }
+
+            if( mApplyForceTimer < mApplyForceTime )
+            {
+                force = mLastForce;
+            }
+            else
+            {
+                mJumpNow = false;
+                // adoption of the formula to our real jump time
+                Real t1 = mApplyForceTimer;
+                Real sx = mWidth;
+                Real g = -PhysicsManager::getSingleton().getGravity().y;
+                Real v0 = mVelocityBeforeJump;
+                Real ax = 0;
+                Real ay = 0;
+
+                if( t1 != 0 || 2 * sx >= v0 * t1 )
+                {
+                    Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
+                    Real v1y = mTanJumpAngle * v1x;
+
+                    Vector3 v_now = mMovingCreature->getVelocity();
+                    ax =  (v1x - -v_now.z) / timestep;
+                    ay = (v1y- v_now.y)/timestep + g;
+                }
+
+                force.x = 0;
+                force.y = ay * mass;
+                force.z = -ax * mass;
+            }
+        }
+
+        Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+    }
+
+    bool JumpLongMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        if( mState == DOWN )
+        {
+            mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer >= 0.2f )
+            {
+                mState = DOWN;
+                LOG_MESSAGE(Logger::RULES, "Weitsprung: DOWN");
+            }
+        }
+        if( mState == UP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer < 0.2f )
+            {
+                mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
+            }
+            else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
+            {
+                mState = UPTODOWN;
+                mMovingCreature->setAnimation(mAnimationLandung.first, mAnimationLandung.second, 1, mAnimationForCollision.first);
+                mTimer = 0;
+                LOG_MESSAGE(Logger::RULES, "Weitsprung: UPTODOWN");
+            }
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer >= 0.3f )
+            {
+                mState = UP;
+                mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
+                mMovingCreature->setAnimation(mAnimation.first, mAnimation.second, 1, mAnimationForCollision.first);
+                mJumpNow = true;
+                mApplyForceTimer = 0;
+                mVelocityBeforeJump = -mMovingCreature->getVelocity().z;
+                mTimer = 0;
+                LOG_MESSAGE(Logger::RULES, "Weitsprung: UP");
+            }
+        }
+        return false;
+    }
+
+    bool JumpLongMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = 0;
+        if(direction.y <= 0 || direction.z >= 0)
+            direction.y = direction.z = 0;
+        return oldDirection.x == 0 && oldDirection.z < 0 && oldDirection.y > 0;
+    }
+
+    bool JumpLongMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+
+    bool JumpLongMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == DOWN;
+    }
+}
+

Added: rl/trunk/engine/rules/src/JumpToTargetMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpToTargetMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/JumpToTargetMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,94 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JumpToTargetMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    JumpToTargetMovement::JumpToTargetMovement(CreatureController *creature) : 
+        JumpLongMovement(creature) 
+    {
+    }
+
+    bool JumpToTargetMovement::calculateBaseVelocity(Real &velocity)
+    {
+        // Code from Weitsprung but do not jump as far
+        velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
+                mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
+        velocity*=0.8f;
+
+        // steht nicht in den Regeln aber finde ich sinnvoll
+        // velocityBase *= (1 - getrageneLast/KK);
+        // steht in den Regeln: pro Ersch???pfung ein KK abziehen
+        //if( mErschoepfung > getEigenschaft("KO") )
+        //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 5.0;
+        // steht nicht in den Regeln, aber finde ich sinnvoll
+        //if( getAu() < getAuBasis() / 3.0 )
+        //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
+        return isPossible();
+    }
+
+    void JumpToTargetMovement::activate()
+    {
+        // Code from Weitsprung without Talentprobe
+        AbstractMovement::activate();
+        mState = DOWNTOUP;
+        mMovingCreature->setAnimation(mAnimationAbsprung.first,mAnimationAbsprung.second,1,mAnimationForCollision.first);
+        mTimer = 0;
+        calculateBaseVelocity(mWidth);
+
+
+        // the person will only achieve this width if it is running
+        // retrieve run movement
+        AbstractMovement *run = mMovingCreature->getMovementFromId(CreatureController::MT_RENNEN);
+        if( run != NULL )
+        {
+            Real vel(0);
+            run->calculateBaseVelocity(vel);
+            Real factor = -mMovingCreature->getVelocity().z / vel;
+            factor = std::max(Real(0),factor);
+            // without moving before, the width will be 1/3
+            mWidth = mWidth/3. + mWidth * 2./3. * factor;
+        }
+
+        mMovingCreature->getCreature()->damageAu(1./3); // not as much AU as Weitsprung
+    }
+
+    bool JumpToTargetMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        // this is the main difference to Weitsprung
+        // use direction as target in local coordinates (only in -z - direction!), so direction.z is -mWidth
+        // TODO: Talentprobe
+        LOG_MESSAGE(Logger::RULES, "Zielsprung aktiviert!");
+        std::ostringstream oss;
+        oss << "Alte Sprungweite: " << mWidth << "Zielweite: " << -direction.z;
+        if( direction.z < 0 && direction.z > -mWidth )
+        {
+            mWidth = - direction.z;
+            oss << "Zielweite: " << mWidth;
+        }
+        LOG_MESSAGE(Logger::RULES, oss.str());
+
+        return JumpLongMovement::run(elapsedTime, direction, rotation);
+    }
+}
+

Added: rl/trunk/engine/rules/src/LieDownMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/LieDownMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/LieDownMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,86 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "LieDownMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    // auch wenn Fallen nicht m?glich ist (auf dem Boden und bewusstlos / Tod)
+    LieDownMovement::LieDownMovement(CreatureController *creature) :
+        AbstractMovement(creature)
+    {
+        mAnim = mMovingCreature->getCreature()->getAnimation("liegen");
+        mAnim1 = mMovingCreature->getCreature()->getAnimation("sterben");
+    }
+
+    void LieDownMovement::activate()
+    {
+        LOG_MESSAGE(Logger::RULES, "Creature '"+mMovingCreature->getCreature()->getName()+"' liegt (evt bewusstlos) auf dem Boden.");
+    }
+
+    void LieDownMovement::deactivate()
+    {
+    }
+    
+    bool LieDownMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool LieDownMovement::isPossible() const
+    {
+        return true;
+    }
+
+    void LieDownMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+    }
+
+    bool LieDownMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        // todo: wieder aufstehen
+        if( mMovingCreature->getCreature()->getLifeState() & (Effect::LS_DEAD | Effect::LS_UNCONSCIOUS) )
+            mMovingCreature->setAnimation(mAnim1.first, mAnim1.second, 1);
+        else
+            mMovingCreature->setAnimation(mAnim.first, mAnim.second, 1);
+        return true;
+    }
+
+    void LieDownMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+
+    bool LieDownMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        direction = Vector3::ZERO;
+        return false;
+    }
+
+    bool LieDownMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        rotation = Vector3::ZERO;
+        return false;
+    }
+}
+

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/Makefile.am	2008-06-23 13:45:18 UTC (rev 4406)
@@ -52,4 +52,18 @@
 	TalentStateSet.cpp \
 	WaitJob.cpp \
 	Weapon.cpp \
-	ZauberStateSet.cpp
+	ZauberStateSet.cpp \
+	FallDownMovement.cpp \
+	JogFastMovement.cpp \
+	JogMovement.cpp \
+	JumpHighMovement.cpp \
+	JumpLongMovement.cpp \
+	JumpToTargetMovement.cpp \
+	LieDownMovement.cpp \
+	RotateMovement.cpp \
+	SneakMovement.cpp \
+	SprintMovement.cpp \
+	StandAroundMovement.cpp \
+	StepRecognitionMovement.cpp \
+	StrafeMovement.cpp \
+	WalkMovement.cpp

Added: rl/trunk/engine/rules/src/RotateMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/RotateMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/RotateMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,119 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "RotateMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    RotateMovement::RotateMovement(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
+    {
+        mRotLinearSpringK = 600.0f;
+        Real relationCoefficient = 1.0f;
+        mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
+    }
+
+    bool RotateMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = 0.3f;
+        return isPossible();
+    }
+
+    bool RotateMovement::isPossible() const
+    {
+        return
+            mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+            mMovingCreature->getCreature()->getAu() > 1 &&
+            !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+    }
+
+    void RotateMovement::activate()
+    {
+        AbstractMovement::activate();
+        mYaw = mMovingCreature->getCreature()->getActor()->getWorldOrientation().getYaw();
+    }
+
+    void RotateMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    void RotateMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+        body->getMassMatrix(mass, inertia);
+
+        Quaternion orientation;
+        Vector3 position;
+        body->getPositionOrientation(position, orientation);
+        // Calculate angular velocity
+        // We first need the yaw rotation from actual yaw to desired yaw
+        Vector3 src = orientation*Vector3::UNIT_Z;
+        src.y = 0;
+        Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
+        dst.y = 0;
+        Quaternion quatDiff = src.getRotationTo(dst, Vector3::UNIT_Y);
+        quatDiff.normalise();
+        Radian yaw = quatDiff.getYaw();
+
+        // using a spring system to apply the rotation
+        Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
+        Vector3 omega = body->getOmega();
+        omega.x = omega.z = 0;
+        Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
+
+        torque = springAcc * inertia;
+    }
+
+    bool RotateMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mYaw += Radian(rotation.y);
+        while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
+        while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
+
+        OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+        Quaternion orientation;
+        Vector3 position;
+        body->getPositionOrientation(position, orientation);
+
+        Real diff = (orientation.getYaw() - mYaw).valueDegrees();
+        return diff <= 0.5f && diff >= -0.5f;
+    }
+
+    bool RotateMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool RotateMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        Vector3 oldRotation(rotation);
+        rotation.x = rotation.z = 0;
+        return oldRotation.x == 0 && oldRotation.z == 0;
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/SneakMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/SneakMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/SneakMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,112 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SneakMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+namespace rl
+{
+    SneakMovement::SneakMovement(CreatureController *creature) : WalkMovement(creature), mState(UP), mTimer(0)
+    {
+        mAnim = creature->getCreature()->getAnimation("schleichen");
+        mAnim1= creature->getCreature()->getAnimation("schleichen_vorwaerts");
+        mAnim2 = creature->getCreature()->getAnimation("stehen_zu_schleichen");
+        mAnim3= creature->getCreature()->getAnimation("schleichen_zu_stehen");
+        mAnimStehen= creature->getCreature()->getAnimation("stehen");
+    }
+
+    bool SneakMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS() / 6.0;
+        return isPossible();
+    }
+
+    bool SneakMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        if( mState == UPTODOWN )
+        {
+            mTimer += elapsedTime;
+            if( mTimer > 0.5f )
+                mState = DOWN;
+        }
+        if( mState == UP )
+        {
+            mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
+        }
+        if( mState == DOWNTOUP )
+        {
+            mTimer += elapsedTime;
+            if( mTimer > 0.5f )
+                mState = UP;
+        }
+        if( mState == DOWN )
+        {
+            //setAnimation(elapsedTime);
+            direction.normalise();
+            Real velocity;
+            calculateBaseVelocity(velocity);
+            mVelocity = direction * velocity;
+            if( direction == Vector3::ZERO || (-mMovingCreature->getVelocity().z) < 0.1)
+                mMovingCreature->setAnimation(mAnim.first, mAnim.second);
+            else
+                mMovingCreature->setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature->getVelocity().z);
+            applyAuChanges(elapsedTime);
+            if( getRotationMovement()->isPossible() )
+                getRotationMovement()->run(elapsedTime, direction, rotation);
+        }
+        else
+            mVelocity = Vector3::ZERO;
+        return true;
+    }
+
+    void SneakMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+    }
+
+    void SneakMovement::setAnimation(Ogre::Real elapsedTime) // is not used
+    {
+    }
+
+    void SneakMovement::activate()
+    {
+        WalkMovement::activate();
+        mState = UPTODOWN;
+        mMovingCreature->setAnimation(mAnim2.first,mAnim2.second,1,mAnimStehen.first);
+        mTimer = 0;
+    }
+
+    bool SneakMovement::canChangeToMovement(CreatureController::MovementType id)
+    {
+        return mState == UP;
+    }
+
+    void SneakMovement::requestChangeToMovement(CreatureController::MovementType id)
+    {
+        if( mState == DOWN )
+        {
+            mState = DOWNTOUP;
+            mMovingCreature->setAnimation(mAnim3.first,mAnim3.second,1,mAnimStehen.first);
+            mTimer = 0;
+        }
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/SprintMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/SprintMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/SprintMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SprintMovement.h"
+#include "DsaManager.h"
+#include "MeshAnimation.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+Real minSquaredSpeed = 0.6f;
+
+
+namespace rl
+{
+    SprintMovement::SprintMovement(CreatureController *creature) : WalkMovement(creature), mVelocityImprovement(0), mLastProbe(0)
+    {
+        mAnim = creature->getCreature()->getAnimation("rennen");
+    }
+
+    bool SprintMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS();
+        return isPossible();
+    }
+
+    bool SprintMovement::isPossible() const
+    {
+        if( mMovingCreature->getMovement() == this )
+            return WalkMovement::isPossible() &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.3 &&
+                mMovingCreature->getCreature()->getAu() > 6;
+        else
+            return WalkMovement::isPossible() &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.5 &&
+                mMovingCreature->getCreature()->getAu() > 8;
+    }
+
+    bool SprintMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        doTalentProbeIfNecessary();
+        bool ret = WalkMovement::run(elapsedTime, direction, rotation);
+        mVelocity += mVelocityImprovement;
+        return ret;
+    }
+
+    void SprintMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
+            StandAroundMovement::applyAuChanges(elapsedTime);
+        else
+            mMovingCreature->getCreature()->damageAu(elapsedTime/1.5);
+    }
+
+    void SprintMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mMovingCreature->getVelocity().squaredLength() < minSquaredSpeed )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real length = 5./3.;
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+
+        switch( mMovingCreature->getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_GEHEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 0.5f )
+                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
+                break;
+            default:
+                break;
+        }
+
+        // apply relTimeOffset only once
+        if( mMovingCreature->getLastMovementChange() > elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, fabs(mMovingCreature->getVelocity().z) *mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL && relTimeOffset )
+            meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
+    }
+
+    void SprintMovement::activate()
+    {
+        WalkMovement::activate();
+        doTalentProbeIfNecessary();
+    }
+
+    void SprintMovement::doTalentProbeIfNecessary()
+    {
+        Date now = DsaManager::getSingleton().getCurrentDate();
+        if( mLastProbe + mMovingCreature->getCreature()->getAuMax() * Date::ONE_SECOND >= now || mLastProbe == 0)
+        {
+            mVelocityImprovement = 0;
+            if( mMovingCreature->getCreature()->hasTalent("Athletik") )
+            {
+                mLastProbe = now;
+                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
+                if( taw == RESULT_AUTOERFOLG )
+                {
+                    mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.2;
+                }
+                else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                {
+                    mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.3;
+                }
+                else
+                {
+                    mVelocityImprovement += taw * 0.1;
+                }
+            }
+            else
+            {
+                mVelocityImprovement = 0;
+            }
+        }
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StandAroundMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StandAroundMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StandAroundMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "StandAroundMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StandAroundMovement::StandAroundMovement(CreatureController *creature) : 
+        AbstractMovement(creature), 
+        mVelocity(Vector3::ZERO), 
+        mRotationMovement(NULL), 
+        mStepRecognitionMovement(NULL)
+    {
+        mAnimStehenLinks = creature->getCreature()->getAnimation("stehen_links");
+        mAnimStehenRechts = creature->getCreature()->getAnimation("stehen_rechts");
+        mAnimStehen = creature->getCreature()->getAnimation("stehen");
+    }
+
+    StandAroundMovement::~StandAroundMovement()
+    {
+    }
+
+    void StandAroundMovement::activate()
+    {
+        AbstractMovement::activate();
+        getRotationMovement()->activate();
+        getStepRecognitionMovement()->activate();
+    }
+
+    void StandAroundMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+        getRotationMovement()->deactivate();
+        getStepRecognitionMovement()->deactivate();
+    }
+
+    bool StandAroundMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool StandAroundMovement::isPossible() const
+    {
+        return
+            mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+            mMovingCreature->getCreature()->getAu() > 0 &&
+            !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
+    }
+
+    void StandAroundMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+        getRotationMovement()->calculateForceAndTorque(force, torque, timestep);
+
+        Real mass;
+        Vector3 inertia;
+        OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+        body->getMassMatrix(mass, inertia);
+
+        Vector3 vel = mMovingCreature->getVelocity();
+        vel.y = 0;
+        Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
+        //if(vel.squaredLength() > mVelocity.squaredLength())
+        //    delay *= 1.5;
+        Vector3 diff = (mVelocity - vel);
+        force = mass * diff / delay;
+        // additional remove movement in wrong direction
+        force += mass * (mVelocity.normalisedCopy() * vel.length() - vel) / delay; // do we need this, does this improve the movement behaviour
+        // (changing direction during slow movement makes char slide sideways)
+        force.y = 0;
+
+        getStepRecognitionMovement()->calculateForceAndTorque(force, torque, timestep);
+    }
+
+    bool StandAroundMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        direction.normalise();
+        Real velocity;
+        calculateBaseVelocity(velocity);
+        mVelocity = direction * velocity;
+        applyAuChanges(elapsedTime);
+        setAnimation(elapsedTime);
+        bool ret = false;
+        if( getRotationMovement()->isPossible() )
+            if( getRotationMovement()->run(elapsedTime, direction, rotation) )
+                ret = true;
+        if( getStepRecognitionMovement()->isPossible() )
+            if (getStepRecognitionMovement()->run(elapsedTime, direction, rotation) )
+                ret = true;
+        return ret;
+    }
+
+    void StandAroundMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        Real omegaY = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega().y;
+        if( omegaY > Degree(20).valueRadians() )
+            mMovingCreature->setAnimation(mAnimStehenRechts.first, mAnimStehenRechts.second);
+        else
+        {
+            if( omegaY < Degree(-20).valueRadians() )
+                mMovingCreature->setAnimation(mAnimStehenLinks.first, mAnimStehenLinks.second);
+            else
+                mMovingCreature->setAnimation(mAnimStehen.first, mAnimStehen.second);
+        }
+    }
+
+    void StandAroundMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
+    }
+
+    bool StandAroundMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool StandAroundMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        return getRotationMovement()->isRotationPossible(rotation);
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,263 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "StepRecognitionMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StepRecognitionMovement::StepRecognitionMovement(CreatureController *creature) : 
+        AbstractMovement(creature), 
+        mMoveToNextTarget(false)
+    {
+        mLinearSpringK = 600.0f;
+        Real relationCoefficient = 1.2f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+    }
+
+    void StepRecognitionMovement::activate()
+    {
+        AbstractMovement::activate();
+        mMoveToNextTarget = false;
+    }
+
+    void StepRecognitionMovement::deactivate()
+    {
+        AbstractMovement::deactivate();
+    }
+
+    bool StepRecognitionMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = 0.0f;
+        return isPossible();
+    }
+
+    bool StepRecognitionMovement::isPossible() const
+    {
+        return
+            mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+            mMovingCreature->getCreature()->getAu() > 0 &&
+            !(mMovingCreature->getCreature()->getLifeState() & (Effect::LS_IMMOBILE));
+    }
+
+    void StepRecognitionMovement::calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
+    {
+        // move to nextTarget
+        if( mMoveToNextTarget )
+        {
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
+            Vector3 pos = mMovingCreature->getCreature()->getPosition();
+            Vector3 diff = mNextTarget - pos;
+
+            Vector3 vel = body->getVelocity();
+
+            force.y = mass*( mLinearSpringK*diff.y - mLinearDampingK*vel.y );
+            std::ostringstream oss;
+            oss << "Step-Recognition: diff: " << diff.y << "    vel: " << vel.y << "    Step force: " << force.y;
+            oss << "    DiffToTarget: " << 
+                mMovingCreature->getCreature()->getOrientation().Inverse() * 
+                (mNextTarget - mMovingCreature->getCreature()->getPosition());
+            LOG_MESSAGE(Logger::RULES, oss.str());
+        }
+    }
+
+    bool StepRecognitionMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        Vector3 vel = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->getVelocity();
+        Real velY = vel.y;
+        vel.y = 0;
+        // raycast in the direction we should move to
+        Vector3 globalDir = mMovingCreature->getCreature()->getOrientation() * direction; // the direction in global space
+        if( globalDir == Vector3::ZERO )
+            return true;
+
+
+
+        // the materials that are triggered here
+        PhysicsMaterialRaycast::MaterialVector materialVector;
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+
+
+
+        // first of all check if we are not standing in front of a wall or sth like this
+        PhysicalThing *thing = mMovingCreature->getCreature()->getActor()->getPhysicalThing();
+        Real height = thing->_getBody()->getCollision()->getAABB().getSize().y;
+        Vector3 start = mMovingCreature->getCreature()->getPosition() + Vector3(0,height/2,0);
+        Vector3 end = start + globalDir * 0.5;
+        RaycastInfo info;
+        info = mRaycast.execute(
+                PhysicsManager::getSingleton()._getNewtonWorld(),
+                &materialVector,
+                start,
+                end);
+        if(info.mBody)
+        {
+            mMoveToNextTarget = false;
+            return false;
+        }
+
+
+
+        if( !mMoveToNextTarget ) // check if we need to move up for a step
+        {
+            Real raylen = vel.length() / 3;  // use longer ray, if higher velocity
+            if ( raylen < 0.5 )
+                raylen = 0.4;
+
+            //std::ostringstream oss;
+            //oss << "StepRecognition Raylen: " << raylen;
+            //LOG_MESSAGE(Logger::RULES, oss.str());
+
+
+            // raycasts
+            Vector3 start = mMovingCreature->getCreature()->getPosition() + Vector3::UNIT_Y * 0.1f;
+            globalDir.y = 0;
+            globalDir.normalise();
+            Vector3 end = start + globalDir*raylen;
+
+            bool foundbody = false;
+            Real foundDistance = 0;
+
+            RaycastInfo info;
+            do
+            {
+                info = 
+                    mRaycast.execute(
+                            PhysicsManager::getSingleton()._getNewtonWorld(),
+                            &materialVector,
+                            start, end);
+
+                // do we need to check bodies left and right of this ray? (step width?)
+
+
+                // already found nearer body
+                if( foundbody )
+                {
+                    if( info.mBody && (info.mDistance*raylen >= foundDistance*raylen + 0.19) || // step deep enough
+                            !info.mBody )
+                    {
+                        // found a step
+                        mMoveToNextTarget = true;
+                        mNextTarget = start + globalDir*raylen*foundDistance + 0.1 * globalDir;
+                        std::ostringstream oss;
+                        Vector3 stepInLocalCoords = mNextTarget - mMovingCreature->getCreature()->getPosition();
+                        Quaternion ori = mMovingCreature->getCreature()->getOrientation();
+                        stepInLocalCoords = ori.Inverse() * stepInLocalCoords;
+                        oss << "Step-Recognition: Next Step: " << stepInLocalCoords;
+                        LOG_MESSAGE(Logger::RULES, oss.str());
+                        break;
+                    }
+                }
+
+                if( info.mBody )
+                {
+                    foundbody = true;
+                    foundDistance = info.mDistance;
+                }
+
+
+                start += Vector3::UNIT_Y * 0.05f;
+                end += Vector3::UNIT_Y * 0.05f;
+            }
+            while( info.mBody && (start - mMovingCreature->getCreature()->getPosition()).y <= 0.5 );
+        }
+
+
+        // check if the target is still needed
+        // perform check also to verify found step
+        if( mMoveToNextTarget )
+        {
+            Vector3 diffToTarget = mNextTarget - mMovingCreature->getCreature()->getPosition();
+            Real diffToTargetY = diffToTarget.y;
+            diffToTarget.y = 0;
+
+            // different direction
+            Vector3 globalDir = mMovingCreature->getCreature()->getOrientation() * direction; // the direction in global space
+            globalDir.y = 0;
+
+
+            if( globalDir == Vector3::ZERO )
+            {
+                mMoveToNextTarget = false;
+                LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step direction null");
+                return false;
+            }
+
+            // target reached
+            if( diffToTarget.squaredLength() < 0.01)
+            {
+                mMoveToNextTarget = false;
+                LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step reached");
+                return false;
+            }
+
+            // different direction
+            Quaternion oriDiff = diffToTarget.getRotationTo(globalDir, Vector3::UNIT_Y);
+            Degree angleDiff;
+            Vector3 axis = Vector3::UNIT_Y;
+            oriDiff.ToAngleAxis(angleDiff, axis);
+            Real f = angleDiff.valueDegrees();
+            //std::ostringstream oss;
+            //oss << "Step-Recognition: angle: " << f << "    axis: " << axis;
+            //LOG_MESSAGE(Logger::RULES, oss.str());
+            //if( !diffToTarget.directionEquals(globalDir, Degree(15)) )
+            if( f > 2.0f )
+            {
+                mMoveToNextTarget = false;
+                //LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: Step direction wrong");
+                return false;
+            }
+
+
+            // already above target, but slow velocity
+            if( diffToTargetY < 0 && fabs(velY) < 0.01 )
+            {
+                mMoveToNextTarget = false;
+                //LOG_MESSAGE(Logger::RULES, "Testing Step-Recognition: slow and abov target-height!");
+                return false;
+            }
+        }
+
+        return mMoveToNextTarget;
+    }
+
+    bool StepRecognitionMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction = Vector3::ZERO;
+        return oldDirection == Vector3::ZERO;
+    }
+
+    bool StepRecognitionMovement::isRotationPossible(Ogre::Vector3 &rotation) const
+    {
+        Vector3 oldRotation(rotation);
+        rotation = Vector3::ZERO;
+        return oldRotation == Vector3::ZERO;
+    }
+
+}
+

Added: rl/trunk/engine/rules/src/StrafeMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StrafeMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/StrafeMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,62 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "StrafeMovement.h"
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    StrafeMovement::StrafeMovement(CreatureController *creature) : WalkMovement(creature), mLeft(true)
+    {
+        mAnim1 = creature->getCreature()->getAnimation("seitwaerts_rechts");
+        mAnim = creature->getCreature()->getAnimation("seitwaerts_links");
+    }
+
+    bool StrafeMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS() / 4.0;
+        return isPossible();
+    }
+    
+    bool StrafeMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.z = direction.y = 0;
+        return oldDirection.z == 0 && oldDirection.y == 0;
+    }
+
+    bool StrafeMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        mLeft = direction.x < 0;
+        return WalkMovement::run(elapsedTime, direction, rotation);
+    }
+
+    void StrafeMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        if( mLeft )
+            mMovingCreature->setAnimation(mAnim1.first, mAnim1.second * -mMovingCreature->getVelocity().x);
+        else
+            mMovingCreature->setAnimation(mAnim.first, mAnim.second * -mMovingCreature->getVelocity().x);
+    }
+}
+
+

Added: rl/trunk/engine/rules/src/WalkMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/WalkMovement.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/rules/src/WalkMovement.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -0,0 +1,109 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "WalkMovement.h"
+#include "MeshAnimation.h"
+
+
+using namespace std;
+using namespace Ogre;
+
+
+
+
+namespace rl
+{
+    WalkMovement::WalkMovement(CreatureController *creature) : StandAroundMovement(creature)
+    {
+        mAnim = creature->getCreature()->getAnimation("gehen");
+    }
+
+    bool WalkMovement::calculateBaseVelocity(Real &velocity)
+    {
+        velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f;
+        return isPossible();
+    }
+
+    bool WalkMovement::isPossible() const
+    {
+        return
+            mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
+            mMovingCreature->getCreature()->getAu() > 1 &&
+            !(mMovingCreature->getCreature()->getLifeState() & Effect::LS_IMMOBILE);
+    }
+
+    bool WalkMovement::run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+    {
+        StandAroundMovement::run(elapsedTime, direction, rotation);
+        return true;
+    }
+
+    bool WalkMovement::isDirectionPossible(Ogre::Vector3 &direction) const
+    {
+        Vector3 oldDirection(direction);
+        direction.x = direction.y = 0;
+        if( direction.z > 0 )
+            direction.z = 0;
+        return oldDirection.x == 0 && oldDirection.y == 0 && oldDirection.z > 0;
+    }
+
+    void WalkMovement::applyAuChanges(Ogre::Real elapsedTime)
+    {
+        mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
+    }
+
+    void WalkMovement::setAnimation(Ogre::Real elapsedTime)
+    {
+        Real speed =  -mMovingCreature->getVelocity().z;
+        if( fabs(speed) < 0.1 )
+        {
+            StandAroundMovement::setAnimation(elapsedTime);
+            return;
+        }
+
+        Real weight = 1;
+        Real relTimeOffset = 0;
+
+        switch( mMovingCreature->getLastMovementType() )
+        {
+            case CreatureController::MT_NONE:
+                break;
+            case CreatureController::MT_STEHEN:
+                relTimeOffset = 0.25;
+                break;
+            case CreatureController::MT_JOGGEN:
+            case CreatureController::MT_LAUFEN:
+            case CreatureController::MT_RENNEN:
+                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
+                if( mMovingCreature->getLastMovementChange() < 1.0f )
+                    weight = mMovingCreature->getLastMovementChange() / 1.0f;
+                break;
+            default:
+                break;
+        }
+
+
+        // apply relTimeOffset only once
+        if( mMovingCreature->getLastMovementChange() > elapsedTime )
+            relTimeOffset = 0;
+
+        MeshAnimation *meshAnim = mMovingCreature->setAnimation(mAnim.first, speed * mAnim.second, 0, mAnim.first, weight );
+        if( meshAnim != NULL && relTimeOffset != 0 )
+            meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
+    }
+}
+

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-06-23 13:45:18 UTC (rev 4406)
@@ -816,13 +816,17 @@
             MT_SCHLEICHEN,
             MT_HOCHSPRUNG,
             MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
             // these movements are only for internal purposes and should not be used directly
             // instead use one of the movements above
-            MT_DREHEN
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
         } MovementType;
         
         Creature *getCreature();
-        //bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
         MovementType getMovementId() const;
         Ogre::Vector3 getDirection() const;
         Ogre::Vector3 getRotation() const;

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2008-06-15 21:03:20 UTC (rev 4405)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2008-06-23 13:45:18 UTC (rev 4406)
@@ -20,6 +20,7 @@
 
 #include <utility>
 
+#include "AbstractMovement.h"
 #include "Actor.h"
 #include "ActorManager.h"
 #include "CameraObject.h"



From fusion2 at mail.berlios.de  Mon Jun 23 19:45:39 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Mon, 23 Jun 2008 19:45:39 +0200
Subject: [Dsa-hl-svn] r4407 - in rl/trunk/editors: . Lockenwickler
	Lockenwickler/src Lockenwickler/src/media Lockenwickler/ui files
Message-ID: <200806231745.m5NHjdtF021672@sheep.berlios.de>

Author: fusion2
Date: 2008-06-23 19:44:53 +0200 (Mon, 23 Jun 2008)
New Revision: 4407

Added:
   rl/trunk/editors/Lockenwickler/
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/
   rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/OdeManager.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/trunk/editors/Lockenwickler/src/Plugins-windows.cfg
   rl/trunk/editors/Lockenwickler/src/Plugins.cfg
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/trunk/editors/Lockenwickler/src/media/
   rl/trunk/editors/Lockenwickler/src/media/Barrel.mesh
   rl/trunk/editors/Lockenwickler/src/media/Example.material
   rl/trunk/editors/Lockenwickler/src/media/RustyBarrel.png
   rl/trunk/editors/Lockenwickler/src/plugins/
   rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/ui_FourPanelView.py
   rl/trunk/editors/Lockenwickler/src/ui_lw.py
   rl/trunk/editors/Lockenwickler/src/ui_model_prev.py
   rl/trunk/editors/Lockenwickler/src/ui_obj_prop.py
   rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
   rl/trunk/editors/Lockenwickler/ui files/
   rl/trunk/editors/Lockenwickler/ui files/FourPanelView.ui
   rl/trunk/editors/Lockenwickler/ui files/batch_convert_ui.py
   rl/trunk/editors/Lockenwickler/ui files/console_window.ui
   rl/trunk/editors/Lockenwickler/ui files/lockewickler.ui
   rl/trunk/editors/Lockenwickler/ui files/model_preview.ui
   rl/trunk/editors/Lockenwickler/ui files/object_property.ui
   rl/trunk/editors/Lockenwickler/ui files/preferences_dialog.ui
   rl/trunk/editors/Lockenwickler/ui files/ui_ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/ui files/ui_FourPanelView.py
   rl/trunk/editors/Lockenwickler/ui files/ui_lw.py
   rl/trunk/editors/Lockenwickler/ui files/ui_model_prev.py
   rl/trunk/editors/Lockenwickler/ui files/ui_obj_prop.py
   rl/trunk/editors/Lockenwickler/ui files/ui_pref_dialog.py
Log:
Initial commit of the Lockenwickler Editor

Added: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,161 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.2.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2008-06-23, 19:40:36 -->
+<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.2">
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>
+      <Dir>src</Dir>
+      <Name>Lockenwickler.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ConsoleWindow.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ModelSelectionDialog.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ModuleManager.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>MovePivot.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ObjectPropertyWin.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>OdeManager.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>OgreMainWindow.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>OgreWidget.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>PreferencesDialog.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>PythonOgreConfig.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_ConsoleWindow.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_FourPanelView.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_lw.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_model_prev.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_obj_prop.py</Name>
+    </Source>
+    <Source>
+      <Dir>src</Dir>
+      <Name>ui_pref_dialog.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>batch_convert_ui.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_ConsoleWindow.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_FourPanelView.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_lw.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_model_prev.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_obj_prop.py</Name>
+    </Source>
+    <Source>
+      <Dir>ui files</Dir>
+      <Name>ui_pref_dialog.py</Name>
+    </Source>
+  </Sources>
+  <Forms>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>console_window.ui</Name>
+    </Form>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>FourPanelView.ui</Name>
+    </Form>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>lockewickler.ui</Name>
+    </Form>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>model_preview.ui</Name>
+    </Form>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>object_property.ui</Name>
+    </Form>
+    <Form>
+      <Dir>ui files</Dir>
+      <Name>preferences_dialog.ui</Name>
+    </Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>
+    <Dir>src</Dir>
+    <Name>Lockenwickler.py</Name>
+  </MainScript>
+  <Vcs>
+    <VcsType>None</VcsType>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
+</Project>
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4q	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4q	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
+<!-- eric4 user project file for project Lockenwickler -->
+<!-- Saved: 2008-06-23, 19:40:36 -->
+<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
+<UserProject version="4.0">
+</UserProject>
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4t	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4t	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Tasks SYSTEM "Tasks-4.1.dtd">
+<!-- eric4 tasks file for project Lockenwickler -->
+<!-- Saved: 2008-06-23, 19:40:36 -->
+<Tasks version="4.1">
+</Tasks>
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,39 @@
+import sys
+from ui_ConsoleWindow import *
+import ogre.renderer.OGRE as og
+
+class LockenLog(og.LogListener):
+    def __init__(self, logFunction):
+        og.LogListener.__init__(self)
+        self.logFunction = logFunction
+
+    def messageLogged(self, message, level, debug, logName):
+        self.logFunction(str(message))
+
+class ConsoleWindow(QtGui.QDialog):
+    def __init__(self, filterLog, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.filterLog = filterLog
+
+        self.consoleWindow = Ui_ConsoleWindow()
+        self.consoleWindow.setupUi(self)
+        self.consoleWindow.textEdit.setReadOnly(True)
+
+        self.lockenLog = LockenLog(self.write)
+
+        sys.stdout = self
+        sys.stderr = self
+
+    def write(self, text):
+        if text.isspace():
+            return
+        if self.filterLog:
+            if text.startswith("Error"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("OGRE EXCEPTION"):
+                self.consoleWindow.textEdit.append(text)
+                return
+        else:
+            self.consoleWindow.textEdit.append(text)
+

Added: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,288 @@
+import os
+import sys
+import platform
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+from os.path import isfile
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from ConsoleWindow import *
+from ModuleManager import *
+
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+        QtCore.QObject.connect(self.actionConsole_Window, QtCore.SIGNAL("triggered()"),
+                                    self.toggleConsoleWindow)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self.loadModule, self)
+        QtCore.QObject.connect(self.actionPreferences, QtCore.SIGNAL("triggered()"),
+                                    self.togglePreferencesWindow)
+
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        QtCore.QObject.connect(self.actionProperty_Window, QtCore.SIGNAL("triggered()"),
+                                    self.togglePropertyWindow)
+
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        QtCore.QObject.connect(self.actionObject_Selection, QtCore.SIGNAL("triggered()"),
+                                    self.toggleModelPreviewWindow)
+
+        QtCore.QObject.connect(self.actionClose, QtCore.SIGNAL("triggered()"),
+                                    self.update)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(33)
+
+        QtGui.QApplication.setKeyboardInputInterval(5000)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+        self.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(self.minimumSizeHint()))
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setGeometry(QtCore.QRect(0,0,660,22))
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+        self.actionNeu = QtGui.QAction(self)
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionSceneGraph = QtGui.QAction(self)
+        self.actionSceneGraph.setCheckable(False)
+        self.actionSceneGraph.setObjectName("actionSceneGraph")
+
+        self.actionPreferences = QtGui.QAction(self)
+        self.actionPreferences.setCheckable(False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = QtGui.QAction(self)
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = QtGui.QAction(self)
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+
+        self.actionClose = QtGui.QAction(self)
+        self.actionClose.setObjectName("actionClose")
+
+        self.actionConsole_Window = QtGui.QAction(self)
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionClose)
+        self.menuView.addAction(self.actionSceneGraph)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "Neu", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneGraph.setText(QtGui.QApplication.translate("MainWindow", "SceneGraph", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        # setup resources
+        config = og.ConfigFile()
+
+        carryOn = root.showConfigDialog()
+        if not carryOn:
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr, self)
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+
+        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleWindow.isHidden():
+            self.consoleWindow.show()
+        else:
+            self.consoleWindow.hide()
+
+    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
+    # and parses them too
+    def loadModule(self, modulePath, moduleName):
+        if self.moduleName == moduleName:
+            return
+
+        self.moduleName = moduleName
+        self.workingDir = modulePath + moduleName # the module path
+        self.workingDirCommon = modulePath + "common" # the module path of the common module
+
+        import codecs
+
+        modConfig = self.workingDir + "/scripts/moduleconfig.rb"
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            pass
+
+        self.mapFiles = [] # a list in case the module has more than one map file
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+
+            # get the map file(s)
+            if lStripped.startswith("loader.loadMap("): # all loadMap commands begin with loader.loadMap(
+                spl = lStripped.split('"')
+                for a in spl:
+                    if a.endswith(".xml"):
+                        pathToMapFile = self.workingDir + "/maps/" + a
+                        self.mapFiles.append(pathToMapFile)
+
+        self.setWindowTitle(moduleName)
+
+        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
+        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
+
+        self.setResourcePaths(self.workingDir, moduleName)
+        self.setResourcePaths(self.workingDirCommon, "common")
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        self.moduleManager.load(moduleName,  self.mapFiles)
+
+    def setResourcePaths(self, path, moduleName):
+        for file in os.listdir(path):
+            curFile = path + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
+                self.setResourcePaths(curFile, moduleName)
+                continue
+            if isfile(curFile):
+                pass
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionClose)
+        self.fileToolBar.hide()
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyReleaseEvent(event)
+        pass
+
+if __name__ == "__main__":
+     app = QtGui.QApplication(sys.argv)
+     myapp = Lockenwickler()
+     myapp.show()
+
+     sys.exit(app.exec_())
+

Added: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,124 @@
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+from PyQt4 import QtGui, QtCore
+
+class ModelSelectionDialog(QtGui.QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        QtCore.QObject.connect(self.modelSearchBox, QtCore.SIGNAL("textChanged(QString)"),
+                               self.updateModelList)
+
+        QtCore.QObject.connect(self.listWidget, QtCore.SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+    def setupUi(self):
+        self.setObjectName("modelPreviewDialog")
+        self.resize(QtCore.QSize(QtCore.QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QtGui.QLineEdit(self)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QtGui.QSplitter(self)
+        self.splitter.setOrientation(QtCore.Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = QtGui.QListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
+                                                         self.splitter)
+        self.ogreModelPrevWindow.setMinimumSize(QtCore.QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+        QtCore.QObject.connect(self.modelSearchBox,QtCore.SIGNAL("textChanged(QString)"),self.listWidget.clearSelection)
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("modelPreviewDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir, name):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile, file)
+                continue
+            if isfile(curFile):
+                if file.endswith(".mesh"):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+
+        if event.type() == 5: #mouse moved while button down
+           rotX = (event.globalX() - self.lastMousePosX) * 0.01
+           rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+           if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+               self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+           self.lastMousePosX = event.globalX()
+           self.lastMousePosY = event.globalY()
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        return False

Added: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,357 @@
+import sys
+import xml.dom.minidom as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity,  distance):
+        self.entity = entity #the selected entity
+        self.distance = distance # the distance from camera at the time of selection
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
+    def __init__( self ):
+        super ( MyRaySceneQueryListener, self ).__init__()
+        self.previouseSelection = None
+        self.selectionList = []
+        self.previousSelected = -1
+        self.currentSelected = -1
+
+        self.mNormalList = []
+        self.mVertexList = []
+        self.mIndexList = []
+
+        self.lastRay = None
+    # sort algorithm for the selection list
+    def sortCompareImp(self,  x,  y):
+        if x.distance > y.distance:
+            return 1
+        elif x.distance == y.distance:
+            return 0
+        else: # x<y
+            return -1
+
+    def queryResult ( self, entity, distance ):
+        if distance == 0.0: #camera is in the bounding box, ignore this selection
+            return True
+        elif entity.getName() == "rayLine" :
+            return True
+        else:
+            so = SelectionObject(entity,  distance)
+            self.selectionList.append(so)
+
+        self.selectionList.sort(self.sortCompareImp)
+
+        return True
+
+    def reset(self):
+        for so in self.selectionList:
+            so.setSelected(False)
+
+        self.previousSelected = -1
+        self.currentSelected = -1
+
+        self.selectionList = []
+
+    def iterateEntityUnderMouse(self):
+        self.previousSelected = self.currentSelected
+        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
+            self.selectionList[self.currentSelected].setSelected(False)
+
+        self.currentSelected += 1
+
+        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
+            self.currentSelected = 0
+
+        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
+            #print str(self.selectionList[self.currentSelected].distance) + " "  + self.selectionList[self.currentSelected].entity.getName()
+            if self.rayCastToPolygonLevelOnCurrentSelection():
+                self.selectionList[self.currentSelected].setSelected(True)
+                return self.selectionList[self.currentSelected]
+
+
+    def getMeshInformation(self,  entity):
+        numVertices = 0
+        numIndices = 0
+        useSharedVertices = False
+
+        if not entity:
+            return False
+
+        pMesh = entity.getMesh()
+
+        for i in range ( pMesh.getNumSubMeshes() ):
+            pSubMesh = pMesh.getSubMesh(i)
+            if pSubMesh.useSharedVertices:
+                useSharedVertices = True
+            else:
+                numVertices += pSubMesh.vertexData.vertexCount
+            numIndices += pSubMesh.indexData.indexCount
+
+        if useSharedVertices:
+            numVertices += pMesh.sharedVertexData.vertexCount
+
+            storageclass = ctypes.c_float * 3
+            test=storageclass(1.1)
+#         mVertexList = new Point[numVertices];
+#         mIndexList = new unsigned int[numIndices];
+
+        self.mNormalList = []
+        self.mVertexList = []
+        self.mIndexList = []
+
+        ## Count the number of vertices and incides so we can Set them
+        indexCount = 0
+        vertListCount = 0
+
+        if useSharedVertices:
+            ## Real* pVertices (x, y, z order x numVertices)
+            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
+            elemNormal = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
+
+            if not elem:
+                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
+                    "mesh to be written!", "MeshSerializerImpl.writeGeometry")
+
+            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
+            vbufNormal = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
+
+            ## need space for the 3 verticies
+            storageclass = ctypes.c_float * 3
+            test=storageclass(1.1)
+
+            storageclass = ctypes.c_float * 3
+            testNormal=storageclass(1.1)
+
+            for j in range ( pMesh.sharedVertexData.vertexCount ):
+                #vbufNormal.readData(j * vbufNormal.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
+                vbufNormal.readData(j * 3, 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
+                self.mNormalList.append( og.Vector3(testNormal[0], testNormal[1],  testNormal[2]) )
+
+                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(test))
+                self.mVertexList.append( og.Vector3(test[0], test[1], test[2]) )
+                vertListCount+=1
+
+        for i in range ( pMesh.getNumSubMeshes() ):
+            pSubMesh = pMesh.getSubMesh(i)
+            if not pSubMesh.useSharedVertices:
+                ## Real* pVertices (x, y, z order x numVertices)
+                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
+                elemNormal = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
+
+                if not elem or not elemNormal:
+                    og.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
+                        "mesh to be written!", "MeshSerializerImpl.writeGeometry")
+
+                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
+                vbufNormal = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
+
+                ## need space for the verticies
+                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
+                test=storageclass(1.1)
+
+                storageclassNormal = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
+                testNormal=storageclassNormal(1.1)
+
+                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
+                                                                                ctypes.addressof(test))
+                vbufNormal.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
+                                                                                ctypes.addressof(testNormal))
+
+                for j in range ( pSubMesh.vertexData.vertexCount ):
+                    self.mVertexList.append( og.Vector3(test[j], test[j+1], test[j+2]) )
+                    self.mNormalList.append( og.Vector3(testNormal[j], testNormal[j+1], testNormal[j+2]) )
+                    vertListCount += 1
+
+            ibuf = pSubMesh.indexData.indexBuffer
+            ## need space for the verticies
+            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
+            test2=storageclass()
+
+            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
+
+            for j in range ( pSubMesh.indexData.indexCount ):
+                self.mIndexList.append (test2[j])   # unsigned short
+                indexCount += 1
+
+    # used when a new selection is made, meaning when not iterationg through the selected objects
+    def rayCastToPolygonLevel(self,  ray):
+        self.lastRay = ray
+        if len(self.selectionList) >= 1:
+            for so in self.selectionList:
+                self.getMeshInformation(so.entity)
+
+                i = 0
+                while i <= (len(self.mIndexList) - 3):
+                    globalPosition = so.entity.getParentNode().getPosition()
+                    result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+                                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
+
+                    if result.first:
+                        return so
+#                        self.previousSelected = self.currentSelected
+#
+#                        if self.previousSelected is not -1:
+#                            self.selectionList[self.previousSelected].setSelected(False)
+#
+#                        self.currentSelected = self.selectionList.index(so)
+#                        so.setSelected(True)
+#                        return
+                    i += 3
+
+#        print "fertsch #####################################################################################"
+
+    def rayCastToPolygonLevelOnCurrentSelection(self):
+        if len(self.selectionList) >= 1:
+            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
+
+            i = 0
+            while i <= (len(self.mIndexList) - 3):
+                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
+                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
+
+                if result.first:
+                   return True
+
+                i += 3
+            return False
+
+class ModuleManager(object):
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.userSelectionList = []
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.lastRay = None
+        self.rayLine = None
+
+    def load(self,  moduleName,  mapFiles):
+        self.moduleName = moduleName
+        self.mapFiles = mapFiles
+
+        for a in self.mapFiles:
+            doc = xml.parse(a)
+            node = doc.getElementsByTagName("entity")
+            if node != None:
+                self.parseSceneNodes(node)
+
+
+    def parseSceneNodes(self,  nodeList):
+        for ent in nodeList:
+            entityName = ent.attributes["name"].nodeValue # get the name of the ent
+            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            for cn in ent.childNodes:
+                if cn.nodeType == cn.ELEMENT_NODE:
+                    if cn.localName == "position":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodePosition = og.Vector3(px, py, pz)
+                        continue
+
+                    if cn.localName == "rotation":
+                        qw = float(cn.attributes["qw"].nodeValue)
+                        qx = float(cn.attributes["qx"].nodeValue)
+                        qy = float(cn.attributes["qy"].nodeValue)
+                        qz = float(cn.attributes["qz"].nodeValue)
+                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
+                        continue
+
+                    if cn.localName == "scale":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodeScale = og.Vector3(px, py, pz)
+                        continue
+
+            e = self.sceneManager.createEntity(entityName, meshFile)
+            n = self.sceneManager.getRootSceneNode().createChild()
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+        pass
+
+
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        if not controlDown and not shiftDown:
+            self.resetSelection()
+
+        self.lastRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+        if so is not None and not controlDown and not shiftDown:
+            so.setSelected(True)
+            self.userSelectionList.append(so)
+        elif so is not None and controlDown and not shiftDown:
+            so.setSelected(True)
+            self.userSelectionList.append(so)
+        elif so is not None and not controlDown and shiftDown:
+            for selo in self.userSelectionList:
+                if so.entity.getName() == selo.entity.getName():
+                    so.setSelected(False)
+                    self.userSelectionList.remove(selo)
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject("rayLine")
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+
+            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def iterateEntityUnderMouse(self):
+        self.listenerDings.iterateEntityUnderMouse()
+
+        pass
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+
+

Added: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,17 @@
+import sys
+
+class MovePivot():
+    def __init__(self,  sceneManager):
+        self.sceneManager = sceneManager
+        self.moveX = False
+        self.moveY = False
+        self.moveZ = False
+
+    # set true if the mouse input should be processed or not
+    def activated(self,  moveX,  moveY,  moveZ):
+        self.moveX = moveX
+        self.moveY = moveY
+        self.moveZ = moveZ
+
+    def move(self):
+        pass

Added: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,17 @@
+import sys
+from ui_obj_prop import *
+
+class ObjectPropertyWin(QtGui.QDialog):
+    def __init__(self, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        
+        self.propWin = Ui_ObjectPropertys()
+        self.propWin.setupUi(self)
+        
+        QtCore.QObject.connect(self.propWin.treeWidget, QtCore.SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"), 
+                               self.onItemClicked)
+        
+        
+    def onItemClicked(self, item, column):
+        print item.text(0)
+        print column
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/src/OdeManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OdeManager.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/OdeManager.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1 @@
+as

Added: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,243 @@
+import os
+import sys
+import platform
+
+from PyQt4 import QtGui, QtCore
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QtGui.QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QtGui.QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreRenderWindow = None
+        self.ogreRenderWindow2 = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.focusedWindow = None # the ogre window which has focus at the moment (activated by a click into the window), eventFilter method
+
+        self.camUpdateTimer = QtCore.QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, QtCore.SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QtCore.QSize(QtCore.QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QtGui.QSplitter(Form)
+
+        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding,QtGui.QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(QtCore.Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QtGui.QToolButton(self)
+        QtCore.QObject.connect(self.ogreWindowOptions, QtCore.SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+
+        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+        self.splitterH = QtGui.QSplitter(Form)
+        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding,QtGui.QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterH.sizePolicy().hasHeightForWidth())
+        self.splitterH.setSizePolicy(sizePolicy)
+        self.splitterH.setOrientation(QtCore.Qt.Horizontal)
+        self.splitterH.setObjectName("splitterH")
+
+
+        ##################################
+        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterH,  0)
+        self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
+
+        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
+        self.ogreRenderWindow.setSizePolicy(sizePolicy)
+        self.ogreRenderWindow.setObjectName("ogreWidget")
+        self.splitterH.addWidget(self.ogreRenderWindow)
+        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 0, 1))
+        ####################################
+
+        #################################
+        self.ogreRenderWindow2 = OgreWidget.OgreWidget("OgreMainWin2", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam2", self.splitterH,  0)
+        self.ogreRenderWindow2.setMinimumSize(QtCore.QSize(250,250))
+
+        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreRenderWindow2.sizePolicy().hasHeightForWidth())
+        self.ogreRenderWindow2.setSizePolicy(sizePolicy)
+        self.ogreRenderWindow2.setObjectName("ogreWidget2")
+        self.splitterH.addWidget(self.ogreRenderWindow2)
+        self.ogreRenderWindow2.setBackgroundColor(og.ColourValue(0, 0, 1))
+        ###################################
+
+        self.splitterV.addWidget(self.splitterH)
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreRenderWindow.installEventFilter(self)
+        self.ogreRenderWindow2.installEventFilter(self)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QtCore.QMetaObject.connectSlotsByName(Form)
+
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QtGui.QApplication.translate("Form", "Form", None, QtGui.QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QtGui.QApplication.translate("Form", "...", None, QtGui.QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(QtCore.Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == QtCore.Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == QtCore.Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == QtCore.Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == QtCore.Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == QtCore.Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == QtCore.Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == QtCore.Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == QtCore.Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.focusedWindow = obj
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.dollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.focusedWindow = obj
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.focusedWindow = obj
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+
+                if self.dollyCamera == True: #if we dolly the camera set it to false
+                    self.dollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.dollyCamera = False
+                self.camUpdateTimer.stop()
+
+        elif event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if (rotX < 0.3 and rotY < 0.3) and (rotX > -0.3 and rotY > -0.3): # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                if self.dollyCamera:
+                    self.focusedWindow.dollyCamera(og.Vector3( rotX, -rotY,  0))
+                elif self.rightMouseDown:
+                    obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        elif event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        return False
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.focusedWindow.mapFromGlobal(QtCore.QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the focused window
+
+        if self.lastSelectionClick != None:
+            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+                return
+
+        self.lastSelectionClick = relMousePos
+        mouseRay = self.focusedWindow.getCamera().getCameraToViewportRay(relMousePos.x()/float(self.focusedWindow.viewport.getActualHeight()),
+                                                                                                                                           relMousePos.y()/float(self.focusedWindow.viewport.getActualWidth()))
+
+        if event.modifiers() == QtCore.Qt.ControlModifier:
+            self.moduleManager.selectionClick(mouseRay,  True,  False)
+        elif event.modifiers() == QtCore.Qt.ShiftModifier:
+            self.moduleManager.selectionClick(mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(mouseRay)
+
+
+#        self.moduleManager.resetCurrentOgreSelection()
+
+
+
+    def updateCamera(self):
+        if self.moveCamForward:
+            self.focusedWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.focusedWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.focusedWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.focusedWindow.dollyCamera(og.Vector3( 0.2, 0, 0))

Added: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,102 @@
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            import sip
+            info = self.x11Info()
+            disp =  str(sip.unwrapinstance(info.display()))
+            scr = str(info.screen())
+            win = str(int(self.winId()))
+            winHandle = disp + ':' + scr + ':' + win
+            self.renderParameters['parentWindowHandle'] = winHandle
+
+        renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
+                                                        False, self.renderParameters)
+
+        renderWindow.active = True
+        self.renderWindow = renderWindow
+
+        self.camera = self.sceneManager.createCamera(cameraName)
+        self.camera.NearClipDistance = 0.1
+
+        # Create focus node (camera always points at this)
+        self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        self.camFocusNode.setFixedYawAxis(True, og.Vector3.UNIT_Y)
+        # camera node is offset a ways along the Z axis of focus node
+        self.camNode = self.camFocusNode.createChildSceneNode()
+        # fix yaw on this one too for when we manipulate it directly
+        self.camNode.setFixedYawAxis(True, og.Vector3.UNIT_Y)
+        self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+        self.camNode.attachObject(self.camera)
+
+        self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+        self.viewport.setClearEveryFrame(True)
+
+    def setBackgroundColor(self, colorValue):
+        self.viewport.BackgroundColour = colorValue
+
+    def resizeEvent(self, event):
+        self.renderWindow.resize(event.size().width(), event.size().height())
+        self.renderWindow.windowMovedOrResized()
+
+        if platform.system() == "Linux":
+            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+        self.renderWindow.update(True)
+        self.ogreRoot.renderOneFrame()
+
+        if self.camera:
+            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)

Added: rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,12 @@
+# Defines plugins to load
+
+# Define plugin folder
+PluginFolder=./plugins
+
+# Define plugins
+Plugin=RenderSystem_GL
+Plugin=Plugin_ParticleFX
+Plugin=Plugin_OctreeSceneManager
+Plugin=Plugin_CgProgramManager
+
+

Added: rl/trunk/editors/Lockenwickler/src/Plugins-windows.cfg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Plugins-windows.cfg	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/Plugins-windows.cfg	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,13 @@
+# Defines plugins to load
+
+# Define plugin folder
+PluginFolder=./plugins
+
+# Define plugins
+Plugin=RenderSystem_Direct3D9
+Plugin=RenderSystem_GL
+Plugin=Plugin_ParticleFX
+Plugin=Plugin_OctreeSceneManager
+Plugin=Plugin_CgProgramManager
+
+

Added: rl/trunk/editors/Lockenwickler/src/Plugins.cfg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Plugins.cfg	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/Plugins.cfg	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,13 @@
+# Defines plugins to load
+
+# Define plugin folder
+PluginFolder=./plugins
+
+# Define plugins
+Plugin=RenderSystem_Direct3D9
+Plugin=RenderSystem_GL
+Plugin=Plugin_ParticleFX
+Plugin=Plugin_OctreeSceneManager
+Plugin=Plugin_CgProgramManager
+
+

Added: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,85 @@
+import sys
+import platform
+import string
+from ui_pref_dialog import *
+
+class PreferencesDialog(QtGui.QDialog):
+    def __init__(self, loadModuleCallback, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+
+        self.loadModuleCallback = loadModuleCallback
+
+        self.prefDialog = Ui_PreferencesDialog()
+        self.prefDialog.setupUi(self)
+
+        QtCore.QObject.connect(self.prefDialog.modulConfigSelector, QtCore.SIGNAL("clicked()"),
+                               self.openModulConfigSelector)
+
+        QtCore.QObject.connect(self.prefDialog.loadModuleBtn, QtCore.SIGNAL("clicked()"),
+                               self.onLoadSelectedModule)
+
+        QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem *)"),
+                               self.onLoadSelectedModule)
+
+##        if platform.system() == "Windows" or platform.system() == "MAC":
+##            # TODO: delete this when ready
+##            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
+##            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
+##            self.moduleCfgIsSelected = True
+##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+##            self.readInModules()
+##            # end delete
+##        else:
+##            # TODO: delete this when ready
+##            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
+##            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
+##            self.moduleCfgIsSelected = True
+##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+##            self.readInModules()
+##            # end delete
+
+        #self.moduleCfgIsSelected = False
+
+        self.setModal(True)
+
+    def openModulConfigSelector(self):
+        dialog = QtGui.QFileDialog(self)
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
+        self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+
+        from os.path import isfile
+
+        if isfile(self.moduleCfgPath):
+            self.prefDialog.lineEdit.setText(self.moduleCfgPath)
+            self.moduleCfgIsSelected = True
+            self.readInModules()
+
+    def readInModules(self):
+        if self.moduleCfgIsSelected:
+            import codecs
+            f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+            for line in f:
+                if line.startswith('#'):
+                    continue
+
+                if line.startswith('module='):
+                    splines = line.split('=')
+                    str = splines[1].rstrip().rstrip()
+                    if str != "common":
+                        self.prefDialog.listWidget.addItem(str)
+
+    def onLoadSelectedModule(self):
+        item = self.prefDialog.listWidget.currentItem()
+        if item == None:
+            mbox = QtGui.QMessageBox(self)
+            mbox.setModal(True)
+            mbox.setText("Please select a module.")
+            mbox.show()
+        else:
+            tempo = str(item.text())
+            self.loadModuleCallback(self.modulePath, tempo)
+            self.hide()
+
+
+

Added: rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,41 @@
+#
+# a single config file that is imported 'first' by the Python-Ogre demos
+# this is primarly used to manage Linux demos when we have binaries in non standard (safe) locations
+
+import os,sys
+
+#########################################################################
+### Override this setting if you are using non standard locations
+
+libpath = "/home/stefan/development/root/usr/lib/"
+
+#########################################################################
+
+
+if os.name == 'nt':
+    libpath=""
+    pythonpath = ""
+else:
+    if libpath == "" :  # we need to find this ourselves
+        localpath = os.path.abspath(os.path.dirname(__file__) ) # assume that this module is in the ./demos directory
+        libpath = os.path.abspath(os.path.join(localpath,'../lib'))  # so in the binary release the lib is one path back up
+        if not os.path.exists ( libpath ):   #we must be running from the development environment
+            libpath = os.path.abspath(os.path.join(localpath,'../../root/usr/lib'))
+            if not os.path.exists ( libpath ):
+                ## should die here
+                print "**Problem finding libraries"
+                libpath=localpath
+
+    ## path to the Python-Ogre modules
+    pythonpath = os.path.abspath(os.path.join(libpath, 'python2.5/site-packages') )
+    ## and insert it into the system path
+    sys.path.insert(0,pythonpath)
+
+    ## now we need to set the library path so the shared libraries can be found
+    try:
+        ldpath = os.environ['LD_LIBRARY_PATH']
+    except:
+        ldpath=""
+    newldpath = libpath + ":" + ldpath
+    os.environ['LD_LIBRARY_PATH'] = newldpath
+

Added: rl/trunk/editors/Lockenwickler/src/media/Barrel.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/Barrel.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/Example.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Example.material	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/media/Example.material	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,18 @@
+material RustyBarrel
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.5 0.5 0.5 1.0
+			diffuse 1.0 1.0 1.0 1.0
+			specular 0.0 0.0 0.0 1.0 12.5
+			emissive 0.0 0.0 0.0 1.0
+			texture_unit
+			{
+				texture RustyBarrel.png
+				filtering trilinear
+			}
+		}
+	}
+}

Added: rl/trunk/editors/Lockenwickler/src/media/RustyBarrel.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/RustyBarrel.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'console_window.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_ConsoleWindow(object):
+    def setupUi(self, ConsoleWindow):
+        ConsoleWindow.setObjectName("ConsoleWindow")
+        ConsoleWindow.resize(QtCore.QSize(QtCore.QRect(0,0,884,225).size()).expandedTo(ConsoleWindow.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.textEdit = QtGui.QTextEdit(ConsoleWindow)
+        self.textEdit.setObjectName("textEdit")
+        self.gridlayout.addWidget(self.textEdit,0,0,1,1)
+
+        self.retranslateUi(ConsoleWindow)
+        QtCore.QMetaObject.connectSlotsByName(ConsoleWindow)
+
+    def retranslateUi(self, ConsoleWindow):
+        ConsoleWindow.setWindowTitle(QtGui.QApplication.translate("ConsoleWindow", "Form", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/src/ui_FourPanelView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_FourPanelView.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_FourPanelView.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,50 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'FourPanelView.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_FourPaneView(object):
+    def setupUi(self, FourPaneView):
+        FourPaneView.setObjectName("FourPaneView")
+        FourPaneView.resize(QtCore.QSize(QtCore.QRect(0,0,827,856).size()).expandedTo(FourPaneView.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(FourPaneView)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.splitter_3 = QtGui.QSplitter(FourPaneView)
+        self.splitter_3.setOrientation(QtCore.Qt.Horizontal)
+        self.splitter_3.setObjectName("splitter_3")
+
+        self.splitter = QtGui.QSplitter(self.splitter_3)
+        self.splitter.setOrientation(QtCore.Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.widget = QtGui.QWidget(self.splitter)
+        self.widget.setObjectName("widget")
+
+        self.widget_4 = QtGui.QWidget(self.splitter)
+        self.widget_4.setObjectName("widget_4")
+
+        self.splitter_2 = QtGui.QSplitter(self.splitter_3)
+        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
+        self.splitter_2.setObjectName("splitter_2")
+
+        self.widget_2 = QtGui.QWidget(self.splitter_2)
+        self.widget_2.setObjectName("widget_2")
+
+        self.widget_3 = QtGui.QWidget(self.splitter_2)
+        self.widget_3.setObjectName("widget_3")
+        self.gridlayout.addWidget(self.splitter_3,0,0,1,1)
+
+        self.retranslateUi(FourPaneView)
+        QtCore.QMetaObject.connectSlotsByName(FourPaneView)
+
+    def retranslateUi(self, FourPaneView):
+        FourPaneView.setWindowTitle(QtGui.QApplication.translate("FourPaneView", "Form", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/src/ui_lw.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_lw.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_lw.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1 @@
+

Added: rl/trunk/editors/Lockenwickler/src/ui_model_prev.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_model_prev.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_model_prev.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,13 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'model_preview.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_modelPreviewDialog(object):
+

Added: rl/trunk/editors/Lockenwickler/src/ui_obj_prop.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_obj_prop.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_obj_prop.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,46 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'object_property.ui'
+#
+# Created: Mon May 12 15:09:23 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_ObjectPropertys(object):
+    def setupUi(self, ObjectPropertys):
+        ObjectPropertys.setObjectName("ObjectPropertys")
+        ObjectPropertys.resize(QtCore.QSize(QtCore.QRect(0,0,761,724).size()).expandedTo(ObjectPropertys.minimumSizeHint()))
+
+        self.treeWidget = QtGui.QTreeWidget(ObjectPropertys)
+        self.treeWidget.setGeometry(QtCore.QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QtCore.QSize(400,400))
+        self.treeWidget.setObjectName("treeWidget")
+
+        self.retranslateUi(ObjectPropertys)
+        QtCore.QMetaObject.connectSlotsByName(ObjectPropertys)
+
+    def retranslateUi(self, ObjectPropertys):
+        ObjectPropertys.setWindowTitle(QtGui.QApplication.translate("ObjectPropertys", "Object Properties", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(0,QtGui.QApplication.translate("ObjectPropertys", "Property", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QtGui.QApplication.translate("ObjectPropertys", "Value", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+        item = QtGui.QTreeWidgetItem(self.treeWidget)
+        item.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Position", None, QtGui.QApplication.UnicodeUTF8))
+        item.setText(1,"")
+
+        item1 = QtGui.QTreeWidgetItem(item)
+        item1.setText(0,QtGui.QApplication.translate("ObjectPropertys", "X", None, QtGui.QApplication.UnicodeUTF8))
+        item1.setText(1,"")
+
+        item2 = QtGui.QTreeWidgetItem(item)
+        item2.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Y", None, QtGui.QApplication.UnicodeUTF8))
+        item2.setText(1,"")
+
+        item3 = QtGui.QTreeWidgetItem(item)
+        item3.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Z", None, QtGui.QApplication.UnicodeUTF8))
+        item3.setText(1,"")
+

Added: rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,85 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'preferences_dialog.ui'
+#
+# Created: Mon Jun 23 19:28:46 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_PreferencesDialog(object):
+    def setupUi(self, PreferencesDialog):
+        PreferencesDialog.setObjectName("PreferencesDialog")
+        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.toolBox = QtGui.QToolBox(PreferencesDialog)
+        self.toolBox.setObjectName("toolBox")
+
+        self.ResourcePaths = QtGui.QWidget()
+        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
+        self.ResourcePaths.setObjectName("ResourcePaths")
+
+        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
+        self.gridlayout1.setObjectName("gridlayout1")
+
+        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
+        self.listWidget.setObjectName("listWidget")
+        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
+
+        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
+        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
+        self.groupBox.setObjectName("groupBox")
+
+        self.layoutWidget = QtGui.QWidget(self.groupBox)
+        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
+        self.layoutWidget.setObjectName("layoutWidget")
+
+        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
+        self.gridlayout2.setObjectName("gridlayout2")
+
+        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
+        self.lineEdit.setObjectName("lineEdit")
+        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
+
+        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
+        self.loadModuleBtn.setObjectName("loadModuleBtn")
+        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
+
+        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
+        self.modulConfigSelector.setObjectName("modulConfigSelector")
+        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
+        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
+        self.toolBox.addItem(self.ResourcePaths,"")
+
+        self.OgreSettings = QtGui.QWidget()
+        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
+        self.OgreSettings.setObjectName("OgreSettings")
+        self.toolBox.addItem(self.OgreSettings,"")
+        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
+
+        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
+        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
+
+        self.retranslateUi(PreferencesDialog)
+        self.toolBox.setCurrentIndex(0)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
+        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
+
+    def retranslateUi(self, PreferencesDialog):
+        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
+        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/ui files/FourPanelView.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/FourPanelView.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/FourPanelView.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,41 @@
+<ui version="4.0" >
+ <class>FourPaneView</class>
+ <widget class="QWidget" name="FourPaneView" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>902</width>
+    <height>759</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Form</string>
+  </property>
+  <layout class="QGridLayout" >
+   <item row="0" column="0" >
+    <widget class="QSplitter" name="splitter_3" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <widget class="QSplitter" name="splitter" >
+      <property name="orientation" >
+       <enum>Qt::Vertical</enum>
+      </property>
+      <widget class="QWidget" native="1" name="widget" />
+      <widget class="QWidget" native="1" name="widget_4" />
+     </widget>
+     <widget class="QSplitter" name="splitter_2" >
+      <property name="orientation" >
+       <enum>Qt::Vertical</enum>
+      </property>
+      <widget class="QWidget" native="1" name="widget_2" />
+      <widget class="QWidget" native="1" name="widget_3" />
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/batch_convert_ui.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/batch_convert_ui.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/batch_convert_ui.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,72 @@
+import sys
+import os
+import platform
+
+copyCommand = "cp "
+cpDestination =  " ../src/"
+
+if platform.system() == "Windows":
+    copyCommand = "copy "
+    cpDestination = " ..\src\\"
+
+###########################################################################
+output = os.popen("pyuic4 lockewickler.ui > ui_lw.py")
+for line in output.readlines():
+    print line
+
+output = os.popen(copyCommand + "ui_lw.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 lockewickler.ui > ui_lw.py " + line
+###########################################################################
+
+###########################################################################
+output = os.popen("pyuic4 preferences_dialog.ui > ui_pref_dialog.py")
+for line in output.readlines():
+    print line
+
+output = os.popen(copyCommand + "ui_pref_dialog.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 preferences_dialog.ui > ui_pref_dialog.py " + line
+###########################################################################
+
+###########################################################################
+output = os.popen("pyuic4 object_property.ui > ui_obj_prop.py")
+for line in output.readlines():
+    print line
+
+output = os.popen(copyCommand + "ui_obj_prop.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 object_property.ui > ui_obj_prop.py " + line
+###########################################################################
+
+###########################################################################
+output = os.popen("pyuic4 model_preview.ui > ui_model_prev.py")
+for line in output.readlines():
+    print line
+
+output = os.popen(copyCommand + "ui_model_prev.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 model_preview.ui > ui_model_prev.py " + line
+###########################################################################
+
+###########################################################################
+output = os.popen("pyuic4 FourPanelView.ui > ui_FourPanelView.py")
+for line in output.readlines():
+        print line
+
+output = os.popen(copyCommand + "ui_FourPanelView.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 FourPanelView.ui > ui_FourPanelView.py " + line
+###########################################################################
+
+###########################################################################
+output = os.popen("pyuic4 console_window.ui > ui_ConsoleWindow.py")
+for line in output.readlines():
+        print line
+
+output = os.popen(copyCommand + "ui_ConsoleWindow.py" + cpDestination)
+for line in output.readlines():
+    print "pyuic4 console_window.ui > ui_ConsoleWindow.py " + line
+###########################################################################
+
+print "Fertig!"

Added: rl/trunk/editors/Lockenwickler/ui files/console_window.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/console_window.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/console_window.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,23 @@
+<ui version="4.0" >
+ <class>ConsoleWindow</class>
+ <widget class="QWidget" name="ConsoleWindow" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>884</width>
+    <height>225</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Form</string>
+  </property>
+  <layout class="QGridLayout" >
+   <item row="0" column="0" >
+    <widget class="QTextEdit" name="textEdit" />
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/lockewickler.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/lockewickler.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/lockewickler.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,108 @@
+<ui version="4.0" >
+ <author>Stefan Stammberger</author>
+ <class>MainWindow</class>
+ <widget class="QMainWindow" name="MainWindow" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>660</width>
+    <height>657</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>MainWindow</string>
+  </property>
+  <widget class="QWidget" name="centralwidget" >
+   <layout class="QHBoxLayout" >
+    <item>
+     <layout class="QGridLayout" >
+      <item row="0" column="0" >
+       <widget class="QWidget" native="1" name="ogreRenderWindow" >
+        <property name="minimumSize" >
+         <size>
+          <width>250</width>
+          <height>250</height>
+         </size>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </item>
+   </layout>
+  </widget>
+  <widget class="QMenuBar" name="menubar" >
+   <property name="geometry" >
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>660</width>
+     <height>22</height>
+    </rect>
+   </property>
+   <widget class="QMenu" name="menuFile" >
+    <property name="title" >
+     <string>File</string>
+    </property>
+    <addaction name="actionNeu" />
+    <addaction name="actionClose" />
+   </widget>
+   <widget class="QMenu" name="menuView" >
+    <property name="title" >
+     <string>View</string>
+    </property>
+    <addaction name="actionSceneGraph" />
+    <addaction name="actionPreferences" />
+    <addaction name="actionProperty_Window" />
+    <addaction name="actionObject_Selection" />
+    <addaction name="actionConsole_Window" />
+   </widget>
+   <addaction name="menuFile" />
+   <addaction name="menuView" />
+  </widget>
+  <widget class="QStatusBar" name="statusbar" />
+  <action name="actionNeu" >
+   <property name="text" >
+    <string>Neu</string>
+   </property>
+  </action>
+  <action name="actionSceneGraph" >
+   <property name="checkable" >
+    <bool>false</bool>
+   </property>
+   <property name="text" >
+    <string>SceneGraph</string>
+   </property>
+  </action>
+  <action name="actionPreferences" >
+   <property name="checkable" >
+    <bool>false</bool>
+   </property>
+   <property name="text" >
+    <string>Preferences</string>
+   </property>
+  </action>
+  <action name="actionProperty_Window" >
+   <property name="text" >
+    <string>Property Window</string>
+   </property>
+  </action>
+  <action name="actionObject_Selection" >
+   <property name="text" >
+    <string>Object Selection</string>
+   </property>
+  </action>
+  <action name="actionClose" >
+   <property name="text" >
+    <string>Quit</string>
+   </property>
+  </action>
+  <action name="actionConsole_Window" >
+   <property name="text" >
+    <string>Console Window</string>
+   </property>
+  </action>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/model_preview.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/model_preview.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/model_preview.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,56 @@
+<ui version="4.0" >
+ <class>modelPreviewDialog</class>
+ <widget class="QDialog" name="modelPreviewDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>272</width>
+    <height>744</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QGridLayout" >
+   <item row="0" column="0" >
+    <widget class="QLineEdit" name="modelSearchBox" />
+   </item>
+   <item row="1" column="0" >
+    <widget class="QSplitter" name="splitter" >
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <widget class="QListWidget" name="listWidget" />
+     <widget class="QWidget" native="1" name="modelPreviewWindow" >
+      <property name="minimumSize" >
+       <size>
+        <width>200</width>
+        <height>200</height>
+       </size>
+      </property>
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>modelSearchBox</sender>
+   <signal>textChanged(QString)</signal>
+   <receiver>listWidget</receiver>
+   <slot>clearSelection()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>115</x>
+     <y>20</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>114</x>
+     <y>48</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/object_property.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/object_property.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/object_property.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,76 @@
+<ui version="4.0" >
+ <class>ObjectPropertys</class>
+ <widget class="QDialog" name="ObjectPropertys" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>202</width>
+    <height>724</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Object Properties</string>
+  </property>
+  <widget class="QTreeWidget" name="treeWidget" >
+   <property name="geometry" >
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>901</width>
+     <height>721</height>
+    </rect>
+   </property>
+   <property name="minimumSize" >
+    <size>
+     <width>400</width>
+     <height>400</height>
+    </size>
+   </property>
+   <column>
+    <property name="text" >
+     <string>Property</string>
+    </property>
+   </column>
+   <column>
+    <property name="text" >
+     <string>Value</string>
+    </property>
+   </column>
+   <item>
+    <property name="text" >
+     <string>Position</string>
+    </property>
+    <property name="text" >
+     <string/>
+    </property>
+    <item>
+     <property name="text" >
+      <string>X</string>
+     </property>
+     <property name="text" >
+      <string/>
+     </property>
+    </item>
+    <item>
+     <property name="text" >
+      <string>Y</string>
+     </property>
+     <property name="text" >
+      <string/>
+     </property>
+    </item>
+    <item>
+     <property name="text" >
+      <string>Z</string>
+     </property>
+     <property name="text" >
+      <string/>
+     </property>
+    </item>
+   </item>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/preferences_dialog.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/preferences_dialog.ui	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/preferences_dialog.ui	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,159 @@
+<ui version="4.0" >
+ <class>PreferencesDialog</class>
+ <widget class="QDialog" name="PreferencesDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>528</width>
+    <height>626</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QGridLayout" >
+   <item row="0" column="0" >
+    <widget class="QToolBox" name="toolBox" >
+     <property name="currentIndex" >
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="ResourcePaths" >
+      <property name="geometry" >
+       <rect>
+        <x>0</x>
+        <y>0</y>
+        <width>510</width>
+        <height>505</height>
+       </rect>
+      </property>
+      <attribute name="label" >
+       <string>Resource Paths</string>
+      </attribute>
+      <layout class="QGridLayout" >
+       <item row="0" column="0" >
+        <widget class="QListWidget" name="listWidget" />
+       </item>
+       <item row="1" column="0" >
+        <widget class="QGroupBox" name="groupBox" >
+         <property name="minimumSize" >
+          <size>
+           <width>0</width>
+           <height>95</height>
+          </size>
+         </property>
+         <property name="title" >
+          <string>GroupBox</string>
+         </property>
+         <widget class="QWidget" name="layoutWidget" >
+          <property name="geometry" >
+           <rect>
+            <x>10</x>
+            <y>20</y>
+            <width>471</width>
+            <height>67</height>
+           </rect>
+          </property>
+          <layout class="QGridLayout" >
+           <item row="0" column="0" >
+            <widget class="QLineEdit" name="lineEdit" />
+           </item>
+           <item row="1" column="0" colspan="2" >
+            <widget class="QPushButton" name="loadModuleBtn" >
+             <property name="text" >
+              <string>Load Selected Module</string>
+             </property>
+            </widget>
+           </item>
+           <item row="0" column="1" >
+            <widget class="QPushButton" name="modulConfigSelector" >
+             <property name="text" >
+              <string>...</string>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="OgreSettings" >
+      <property name="geometry" >
+       <rect>
+        <x>0</x>
+        <y>0</y>
+        <width>96</width>
+        <height>26</height>
+       </rect>
+      </property>
+      <attribute name="label" >
+       <string>Ogre Settings</string>
+      </attribute>
+     </widget>
+    </widget>
+   </item>
+   <item row="1" column="0" >
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>PreferencesDialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>227</x>
+     <y>387</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>PreferencesDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>295</x>
+     <y>387</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>clicked(QAbstractButton*)</signal>
+   <receiver>PreferencesDialog</receiver>
+   <slot>close()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>467</x>
+     <y>387</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>240</x>
+     <y>0</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Added: rl/trunk/editors/Lockenwickler/ui files/ui_ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_ConsoleWindow.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_ConsoleWindow.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'console_window.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_ConsoleWindow(object):
+    def setupUi(self, ConsoleWindow):
+        ConsoleWindow.setObjectName("ConsoleWindow")
+        ConsoleWindow.resize(QtCore.QSize(QtCore.QRect(0,0,884,225).size()).expandedTo(ConsoleWindow.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.textEdit = QtGui.QTextEdit(ConsoleWindow)
+        self.textEdit.setObjectName("textEdit")
+        self.gridlayout.addWidget(self.textEdit,0,0,1,1)
+
+        self.retranslateUi(ConsoleWindow)
+        QtCore.QMetaObject.connectSlotsByName(ConsoleWindow)
+
+    def retranslateUi(self, ConsoleWindow):
+        ConsoleWindow.setWindowTitle(QtGui.QApplication.translate("ConsoleWindow", "Form", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/ui files/ui_FourPanelView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_FourPanelView.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_FourPanelView.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,50 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'FourPanelView.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_FourPaneView(object):
+    def setupUi(self, FourPaneView):
+        FourPaneView.setObjectName("FourPaneView")
+        FourPaneView.resize(QtCore.QSize(QtCore.QRect(0,0,827,856).size()).expandedTo(FourPaneView.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(FourPaneView)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.splitter_3 = QtGui.QSplitter(FourPaneView)
+        self.splitter_3.setOrientation(QtCore.Qt.Horizontal)
+        self.splitter_3.setObjectName("splitter_3")
+
+        self.splitter = QtGui.QSplitter(self.splitter_3)
+        self.splitter.setOrientation(QtCore.Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.widget = QtGui.QWidget(self.splitter)
+        self.widget.setObjectName("widget")
+
+        self.widget_4 = QtGui.QWidget(self.splitter)
+        self.widget_4.setObjectName("widget_4")
+
+        self.splitter_2 = QtGui.QSplitter(self.splitter_3)
+        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
+        self.splitter_2.setObjectName("splitter_2")
+
+        self.widget_2 = QtGui.QWidget(self.splitter_2)
+        self.widget_2.setObjectName("widget_2")
+
+        self.widget_3 = QtGui.QWidget(self.splitter_2)
+        self.widget_3.setObjectName("widget_3")
+        self.gridlayout.addWidget(self.splitter_3,0,0,1,1)
+
+        self.retranslateUi(FourPaneView)
+        QtCore.QMetaObject.connectSlotsByName(FourPaneView)
+
+    def retranslateUi(self, FourPaneView):
+        FourPaneView.setWindowTitle(QtGui.QApplication.translate("FourPaneView", "Form", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/ui files/ui_lw.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_lw.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_lw.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,94 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'lockewickler.ui'
+#
+# Created: Mon May 12 15:09:23 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_MainWindow(object):
+    def setupUi(self, MainWindow):
+        MainWindow.setObjectName("MainWindow")
+        MainWindow.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(MainWindow.minimumSizeHint()))
+
+        self.centralwidget = QtGui.QWidget(MainWindow)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.ogreRenderWindow = QtGui.QWidget(self.centralwidget)
+        self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
+        self.ogreRenderWindow.setObjectName("ogreRenderWindow")
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        MainWindow.setCentralWidget(self.centralwidget)
+
+        self.menubar = QtGui.QMenuBar(MainWindow)
+        self.menubar.setGeometry(QtCore.QRect(0,0,660,22))
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        MainWindow.setMenuBar(self.menubar)
+
+        self.statusbar = QtGui.QStatusBar(MainWindow)
+        self.statusbar.setObjectName("statusbar")
+        MainWindow.setStatusBar(self.statusbar)
+
+        self.actionNeu = QtGui.QAction(MainWindow)
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionSceneGraph = QtGui.QAction(MainWindow)
+        self.actionSceneGraph.setCheckable(False)
+        self.actionSceneGraph.setObjectName("actionSceneGraph")
+
+        self.actionPreferences = QtGui.QAction(MainWindow)
+        self.actionPreferences.setCheckable(False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = QtGui.QAction(MainWindow)
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = QtGui.QAction(MainWindow)
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+
+        self.actionClose = QtGui.QAction(MainWindow)
+        self.actionClose.setObjectName("actionClose")
+
+        self.actionConsole_Window = QtGui.QAction(MainWindow)
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionClose)
+        self.menuView.addAction(self.actionSceneGraph)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi(MainWindow)
+        QtCore.QMetaObject.connectSlotsByName(MainWindow)
+
+    def retranslateUi(self, MainWindow):
+        MainWindow.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "Neu", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneGraph.setText(QtGui.QApplication.translate("MainWindow", "SceneGraph", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/ui files/ui_model_prev.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_model_prev.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_model_prev.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,42 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'model_preview.ui'
+#
+# Created: Mon May 12 15:09:24 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_modelPreviewDialog(object):
+    def setupUi(self, modelPreviewDialog):
+        modelPreviewDialog.setObjectName("modelPreviewDialog")
+        modelPreviewDialog.resize(QtCore.QSize(QtCore.QRect(0,0,272,744).size()).expandedTo(modelPreviewDialog.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(modelPreviewDialog)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QtGui.QLineEdit(modelPreviewDialog)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QtGui.QSplitter(modelPreviewDialog)
+        self.splitter.setOrientation(QtCore.Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = QtGui.QListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.modelPreviewWindow = QtGui.QWidget(self.splitter)
+        self.modelPreviewWindow.setMinimumSize(QtCore.QSize(200,200))
+        self.modelPreviewWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi(modelPreviewDialog)
+        QtCore.QObject.connect(self.modelSearchBox,QtCore.SIGNAL("textChanged(QString)"),self.listWidget.clearSelection)
+        QtCore.QMetaObject.connectSlotsByName(modelPreviewDialog)
+
+    def retranslateUi(self, modelPreviewDialog):
+        modelPreviewDialog.setWindowTitle(QtGui.QApplication.translate("modelPreviewDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+

Added: rl/trunk/editors/Lockenwickler/ui files/ui_obj_prop.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_obj_prop.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_obj_prop.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,46 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'object_property.ui'
+#
+# Created: Mon May 12 15:09:23 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_ObjectPropertys(object):
+    def setupUi(self, ObjectPropertys):
+        ObjectPropertys.setObjectName("ObjectPropertys")
+        ObjectPropertys.resize(QtCore.QSize(QtCore.QRect(0,0,761,724).size()).expandedTo(ObjectPropertys.minimumSizeHint()))
+
+        self.treeWidget = QtGui.QTreeWidget(ObjectPropertys)
+        self.treeWidget.setGeometry(QtCore.QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QtCore.QSize(400,400))
+        self.treeWidget.setObjectName("treeWidget")
+
+        self.retranslateUi(ObjectPropertys)
+        QtCore.QMetaObject.connectSlotsByName(ObjectPropertys)
+
+    def retranslateUi(self, ObjectPropertys):
+        ObjectPropertys.setWindowTitle(QtGui.QApplication.translate("ObjectPropertys", "Object Properties", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(0,QtGui.QApplication.translate("ObjectPropertys", "Property", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QtGui.QApplication.translate("ObjectPropertys", "Value", None, QtGui.QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+        item = QtGui.QTreeWidgetItem(self.treeWidget)
+        item.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Position", None, QtGui.QApplication.UnicodeUTF8))
+        item.setText(1,"")
+
+        item1 = QtGui.QTreeWidgetItem(item)
+        item1.setText(0,QtGui.QApplication.translate("ObjectPropertys", "X", None, QtGui.QApplication.UnicodeUTF8))
+        item1.setText(1,"")
+
+        item2 = QtGui.QTreeWidgetItem(item)
+        item2.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Y", None, QtGui.QApplication.UnicodeUTF8))
+        item2.setText(1,"")
+
+        item3 = QtGui.QTreeWidgetItem(item)
+        item3.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Z", None, QtGui.QApplication.UnicodeUTF8))
+        item3.setText(1,"")
+

Added: rl/trunk/editors/Lockenwickler/ui files/ui_pref_dialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/ui_pref_dialog.py	2008-06-23 13:45:18 UTC (rev 4406)
+++ rl/trunk/editors/Lockenwickler/ui files/ui_pref_dialog.py	2008-06-23 17:44:53 UTC (rev 4407)
@@ -0,0 +1,85 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'preferences_dialog.ui'
+#
+# Created: Mon May 12 15:09:23 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_PreferencesDialog(object):
+    def setupUi(self, PreferencesDialog):
+        PreferencesDialog.setObjectName("PreferencesDialog")
+        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.toolBox = QtGui.QToolBox(PreferencesDialog)
+        self.toolBox.setObjectName("toolBox")
+
+        self.ResourcePaths = QtGui.QWidget()
+        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
+        self.ResourcePaths.setObjectName("ResourcePaths")
+
+        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
+        self.gridlayout1.setObjectName("gridlayout1")
+
+        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
+        self.listWidget.setObjectName("listWidget")
+        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
+
+        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
+        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
+        self.groupBox.setObjectName("groupBox")
+
+        self.layoutWidget = QtGui.QWidget(self.groupBox)
+        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
+        self.layoutWidget.setObjectName("layoutWidget")
+
+        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
+        self.gridlayout2.setObjectName("gridlayout2")
+
+        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
+        self.lineEdit.setObjectName("lineEdit")
+        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
+
+        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
+        self.loadModuleBtn.setObjectName("loadModuleBtn")
+        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
+
+        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
+        self.modulConfigSelector.setObjectName("modulConfigSelector")
+        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
+        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
+        self.toolBox.addItem(self.ResourcePaths,"")
+
+        self.OgreSettings = QtGui.QWidget()
+        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
+        self.OgreSettings.setObjectName("OgreSettings")
+        self.toolBox.addItem(self.OgreSettings,"")
+        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
+
+        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
+        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
+
+        self.retranslateUi(PreferencesDialog)
+        self.toolBox.setCurrentIndex(0)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
+        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
+
+    def retranslateUi(self, PreferencesDialog):
+        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
+        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
+



From timm at mail.berlios.de  Mon Jun 23 22:49:49 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 23 Jun 2008 22:49:49 +0200
Subject: [Dsa-hl-svn] r4408 - rl/trunk/engine/rules
Message-ID: <200806232049.m5NKnnTp007429@sheep.berlios.de>

Author: timm
Date: 2008-06-23 22:49:46 +0200 (Mon, 23 Jun 2008)
New Revision: 4408

Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
Log:
hopefully added every movement file to vs project

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2008-06-23 17:44:53 UTC (rev 4407)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2008-06-23 20:49:46 UTC (rev 4408)
@@ -522,6 +522,66 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="movements"
+				>
+				<File
+					RelativePath=".\src\FallDownMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\JogFastMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\JogMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\JumpHighMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\JumpLongMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\JumpToTargetMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\LieDownMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\RotateMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SneakMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SprintMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\StandAroundMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\StepRecognitionMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\StrafeMovement.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\WalkMovement.cpp"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Headerdateien"
@@ -756,6 +816,78 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="movements"
+				>
+				<File
+					RelativePath=".\include\AbstractMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\FallDownMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JogBackwardsMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JogFastMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JogMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JumpHighMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JumpLongMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\JumpToTargetMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\LieDownMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\RotateMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SneakMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SprintMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\StandAroundMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\StepRecognitionMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\StrafeMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\WalkBackwardsMovement.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\WalkMovement.h"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Ressourcendateien"



From blakharaz at mail.berlios.de  Sun Jun 29 19:16:46 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 29 Jun 2008 19:16:46 +0200
Subject: [Dsa-hl-svn] r4409 - in rl/trunk: Mac/Rastullah.xcodeproj
	engine/ai/include engine/ai/src engine/common/include
	engine/core/include engine/core/src engine/script/swig
Message-ID: <200806291716.m5THGkqa004259@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-29 19:16:24 +0200 (Sun, 29 Jun 2008)
New Revision: 4409

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/common/include/FixRubyHeaders.h
   rl/trunk/engine/common/include/RastullahPrerequisites.h
   rl/trunk/engine/core/include/DotSceneLoader.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/script/swig/RlExports.i
Log:
Make RL compile on Mac OS X again

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-06-29 17:16:24 UTC (rev 4409)
@@ -295,7 +295,6 @@
 		444EADEF0BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */; };
 		444EADF00BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */; };
 		444EADF10BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */; };
-		444EADF20BD0E64100C6D4A0 /* Person.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC80BD0E64100C6D4A0 /* Person.cpp */; };
 		444EADF30BD0E64100C6D4A0 /* Quest.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC90BD0E64100C6D4A0 /* Quest.cpp */; };
 		444EADF40BD0E64100C6D4A0 /* QuestBook.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */; };
 		444EADF50BD0E64100C6D4A0 /* QuestEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */; };
@@ -333,7 +332,6 @@
 		444EAE490BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */; };
 		444EAE4A0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */; };
 		444EAE4B0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */; };
-		444EAE4C0BD0E65B00C6D4A0 /* Person.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1E0BD0E65B00C6D4A0 /* Person.h */; };
 		444EAE4D0BD0E65B00C6D4A0 /* Quest.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1F0BD0E65B00C6D4A0 /* Quest.h */; };
 		444EAE4E0BD0E65B00C6D4A0 /* QuestBook.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE200BD0E65B00C6D4A0 /* QuestBook.h */; };
 		444EAE4F0BD0E65B00C6D4A0 /* QuestEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */; };
@@ -551,6 +549,15 @@
 		483D86A70D8C3DA200F3629E /* Fmod4Sound.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */; };
 		483D86A80D8C3DA200F3629E /* Fmod4SoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */; };
 		483D87CE0D8C564400F3629E /* libRlScript.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48570C1B0D8A6C5400096E35 /* libRlScript.dylib */; };
+		484FE6BA0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6BB0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6BC0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6BD0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6BE0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6BF0E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6C00E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6C10E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
+		484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 484FE6B90E17BC8800FA880F /* Carbon.framework */; };
 		48500B790D906A1000EAD8DB /* RlScriptExportsMac.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */; };
 		48570C210D8A6C9000096E35 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
 		48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
@@ -596,8 +603,27 @@
 		485A05750D71EDC40024198D /* MessagePump.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056B0D71EDC40024198D /* MessagePump.h */; };
 		485A05760D71EDC40024198D /* MessageType.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056C0D71EDC40024198D /* MessageType.h */; };
 		485A05880D71EDF20024198D /* MessagePump.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A057E0D71EDF20024198D /* MessagePump.cpp */; };
+		485B89540E15794A00D5B19C /* Scene.h in Headers */ = {isa = PBXBuildFile; fileRef = 485B89510E15794A00D5B19C /* Scene.h */; };
+		485B89550E15794A00D5B19C /* SceneLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 485B89520E15794A00D5B19C /* SceneLoader.h */; };
+		485B89560E15794A00D5B19C /* SceneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 485B89530E15794A00D5B19C /* SceneManager.h */; };
+		485B895A0E15796500D5B19C /* Scene.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89570E15796500D5B19C /* Scene.cpp */; };
+		485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89580E15796500D5B19C /* SceneLoader.cpp */; };
+		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		48A52B220E0EDA0E008DBDD8 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
+		48A52CB00E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CB10E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CB30E0EF577008DBDD8 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
+		48A52CB60E0EF5BD008DBDD8 /* ApplyDamageJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */; };
+		48A52CB80E0EF5D0008DBDD8 /* ApplyDamageJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */; };
+		48A52CBC0E0EF77B008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CBD0E0EF77B008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CBE0E0EF77C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CBF0E0EF77C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CC00E0EF77D008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CC20E0EF77E008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
+		48A52CC30E0EF785008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
 		48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8D0C4E960486CD37000505A6 /* Info.plist */; };
 		48B5F6520DAF4D2D00D05C95 /* libRlScript.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48570C1B0D8A6C5400096E35 /* libRlScript.dylib */; };
 		48B5F6530DAF4D3500D05C95 /* libRlFmod4Driver.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 483D86700D8C3A3300F3629E /* libRlFmod4Driver.dylib */; };
@@ -608,8 +634,6 @@
 		48B772E30D583521000A3B97 /* XmlProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E00D583521000A3B97 /* XmlProcessor.cpp */; };
 		48B772E40D583521000A3B97 /* XmlPropertyReader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */; };
 		48B772E50D583521000A3B97 /* XmlPropertyWriter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */; };
-		48D34A560D90EF1000C89477 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48D34A550D90EF1000C89477 /* libboost_filesystem.dylib */; };
-		48D34A5F0D90F4FF00C89477 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48D34A550D90EF1000C89477 /* libboost_filesystem.dylib */; };
 		48D34A630D90F5D500C89477 /* SaveGameData.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D34A610D90F5D500C89477 /* SaveGameData.h */; };
 		48D34A640D90F5D500C89477 /* SaveGameData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D34A620D90F5D500C89477 /* SaveGameData.cpp */; };
 		48D34A7D0D91C7D800C89477 /* SaveGameFile.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056E0D71EDC40024198D /* SaveGameFile.h */; };
@@ -1083,7 +1107,6 @@
 		444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEvent.cpp; path = ../engine/rules/src/ObjectStateChangeEvent.cpp; sourceTree = SOURCE_ROOT; };
 		444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEventSource.cpp; path = ../engine/rules/src/ObjectStateChangeEventSource.cpp; sourceTree = SOURCE_ROOT; };
 		444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeListener.cpp; path = ../engine/rules/src/ObjectStateChangeListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC80BD0E64100C6D4A0 /* Person.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Person.cpp; path = ../engine/rules/src/Person.cpp; sourceTree = SOURCE_ROOT; };
 		444EADC90BD0E64100C6D4A0 /* Quest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Quest.cpp; path = ../engine/rules/src/Quest.cpp; sourceTree = SOURCE_ROOT; };
 		444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestBook.cpp; path = ../engine/rules/src/QuestBook.cpp; sourceTree = SOURCE_ROOT; };
 		444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestEvent.cpp; path = ../engine/rules/src/QuestEvent.cpp; sourceTree = SOURCE_ROOT; };
@@ -1121,7 +1144,6 @@
 		444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEvent.h; path = ../engine/rules/include/ObjectStateChangeEvent.h; sourceTree = SOURCE_ROOT; };
 		444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEventSource.h; path = ../engine/rules/include/ObjectStateChangeEventSource.h; sourceTree = SOURCE_ROOT; };
 		444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeListener.h; path = ../engine/rules/include/ObjectStateChangeListener.h; sourceTree = SOURCE_ROOT; };
-		444EAE1E0BD0E65B00C6D4A0 /* Person.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Person.h; path = ../engine/rules/include/Person.h; sourceTree = SOURCE_ROOT; };
 		444EAE1F0BD0E65B00C6D4A0 /* Quest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Quest.h; path = ../engine/rules/include/Quest.h; sourceTree = SOURCE_ROOT; };
 		444EAE200BD0E65B00C6D4A0 /* QuestBook.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestBook.h; path = ../engine/rules/include/QuestBook.h; sourceTree = SOURCE_ROOT; };
 		444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestEvent.h; path = ../engine/rules/include/QuestEvent.h; sourceTree = SOURCE_ROOT; };
@@ -1307,6 +1329,7 @@
 		483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4Sound.cpp; sourceTree = "<group>"; };
 		483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4SoundStitching.cpp; sourceTree = "<group>"; };
 		483D87C90D8C55E500F3629E /* RlScript.bundle */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = RlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
+		484FE6B90E17BC8800FA880F /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
 		48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlScriptExportsMac.cpp; path = ../engine/script/swig/RlScriptExportsMac.cpp; sourceTree = SOURCE_ROOT; };
 		48570C1B0D8A6C5400096E35 /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		4857E4E40D46A664009D376D /* OIS.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OIS.framework; path = /Library/Frameworks/OIS.framework; sourceTree = "<absolute>"; };
@@ -1330,16 +1353,25 @@
 		485A05830D71EDF20024198D /* SaveGameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameManager.cpp; path = ../engine/core/src/SaveGameManager.cpp; sourceTree = SOURCE_ROOT; };
 		485A05850D71EDF20024198D /* TimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimeSource.cpp; path = ../engine/core/src/TimeSource.cpp; sourceTree = SOURCE_ROOT; };
 		485A05860D71EDF20024198D /* Trigger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Trigger.cpp; path = ../engine/core/src/Trigger.cpp; sourceTree = SOURCE_ROOT; };
+		485B89510E15794A00D5B19C /* Scene.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Scene.h; path = ../engine/script/include/Scene.h; sourceTree = SOURCE_ROOT; };
+		485B89520E15794A00D5B19C /* SceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneLoader.h; path = ../engine/script/include/SceneLoader.h; sourceTree = SOURCE_ROOT; };
+		485B89530E15794A00D5B19C /* SceneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneManager.h; path = ../engine/script/include/SceneManager.h; sourceTree = SOURCE_ROOT; };
+		485B89570E15796500D5B19C /* Scene.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Scene.cpp; path = ../engine/script/src/Scene.cpp; sourceTree = SOURCE_ROOT; };
+		485B89580E15796500D5B19C /* SceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneLoader.cpp; path = ../engine/script/src/SceneLoader.cpp; sourceTree = SOURCE_ROOT; };
+		485B89590E15796500D5B19C /* SceneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneManager.cpp; path = ../engine/script/src/SceneManager.cpp; sourceTree = SOURCE_ROOT; };
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
-		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; fileEncoding = 4; includeInIndex = 0; lastKnownFileType = sourcecode.cpp.cpp; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
+		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_filesystem.dylib; path = /usr/local/lib/libboost_filesystem.dylib; sourceTree = "<absolute>"; };
+		48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_system.lib; path = /usr/local/lib/libboost_system.lib; sourceTree = "<absolute>"; };
+		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ApplyDamageJob.h; path = ../engine/rules/include/ApplyDamageJob.h; sourceTree = SOURCE_ROOT; };
+		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ApplyDamageJob.cpp; path = ../engine/rules/src/ApplyDamageJob.cpp; sourceTree = SOURCE_ROOT; };
 		48B772DA0D58350B000A3B97 /* XmlProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlProcessor.h; path = ../engine/common/include/XmlProcessor.h; sourceTree = SOURCE_ROOT; };
 		48B772DB0D58350B000A3B97 /* XmlPropertyReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlPropertyReader.h; path = ../engine/common/include/XmlPropertyReader.h; sourceTree = SOURCE_ROOT; };
 		48B772DC0D58350B000A3B97 /* XmlPropertyWriter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlPropertyWriter.h; path = ../engine/common/include/XmlPropertyWriter.h; sourceTree = SOURCE_ROOT; };
 		48B772E00D583521000A3B97 /* XmlProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlProcessor.cpp; path = ../engine/common/src/XmlProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyReader.cpp; path = ../engine/common/src/XmlPropertyReader.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
-		48D34A550D90EF1000C89477 /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_filesystem.dylib; path = /opt/local/lib/libboost_filesystem.dylib; sourceTree = "<absolute>"; };
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
@@ -1352,10 +1384,12 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				48A52B220E0EDA0E008DBDD8 /* libboost_filesystem.dylib in Frameworks */,
 				444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */,
 				4836CBCE0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48D34A560D90EF1000C89477 /* libboost_filesystem.dylib in Frameworks */,
+				48A52CB00E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BA0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1363,6 +1397,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				48A52CB30E0EF577008DBDD8 /* libboost_filesystem.dylib in Frameworks */,
 				444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
 				483646A20D83D57800912FEC /* libruby.dylib in Frameworks */,
 				444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */,
@@ -1370,7 +1405,8 @@
 				444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */,
 				440785DE0C09D231006E496D /* libmeshmagick.dylib in Frameworks */,
 				4836CBCD0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48D34A5F0D90F4FF00C89477 /* libboost_filesystem.dylib in Frameworks */,
+				48A52CB10E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BC0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1387,6 +1423,8 @@
 				444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */,
 				444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */,
 				4836CBCC0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+				48A52CBC0E0EF77B008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BD0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1401,6 +1439,8 @@
 				444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */,
 				4836CBCB0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+				48A52CBD0E0EF77B008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BE0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1418,6 +1458,8 @@
 				444EB3730BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
 				4857E4E50D46A664009D376D /* OIS.framework in Frameworks */,
 				4836CBCA0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+				48A52CBE0E0EF77C008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BF0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1431,6 +1473,8 @@
 				48365BEC0D8D56DC00BF3313 /* libRlCommon.dylib in Frameworks */,
 				48365C950D8D56EA00BF3313 /* CEGUI.framework in Frameworks */,
 				4836CBCF0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+				48A52CC30E0EF785008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6C10E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1439,6 +1483,8 @@
 			buildActionMask = 2147483647;
 			files = (
 				483D87CE0D8C564400F3629E /* libRlScript.dylib in Frameworks */,
+				48A52CC00E0EF77D008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1456,6 +1502,8 @@
 				48570C480D8A6E9900096E35 /* libRlRules.dylib in Frameworks */,
 				48570C490D8A6E9900096E35 /* libRlUi.dylib in Frameworks */,
 				4836CBC90D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+				48A52CBF0E0EF77C008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6C00E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1475,6 +1523,8 @@
 				444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */,
 				4836F8BC0D885AAA00E3632F /* libruby.dylib in Frameworks */,
 				48570E020D8A6F8300096E35 /* libRlScript.dylib in Frameworks */,
+				48A52CC20E0EF77E008DBDD8 /* libboost_system.lib in Frameworks */,
+				484FE6BB0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1538,7 +1588,9 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
-				48D34A550D90EF1000C89477 /* libboost_filesystem.dylib */,
+				484FE6B90E17BC8800FA880F /* Carbon.framework */,
+				48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */,
+				48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */,
 				4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */,
 				4857E4E40D46A664009D376D /* OIS.framework */,
 				440785DD0C09D231006E496D /* libmeshmagick.dylib */,
@@ -1958,6 +2010,8 @@
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */,
+				48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */,
 				483D311E0D85B215003477A0 /* stdinc.h */,
 				483D312D0D85B22C003477A0 /* GameEventLog.cpp */,
 				483D312E0D85B22C003477A0 /* GameTimeSource.cpp */,
@@ -2012,7 +2066,6 @@
 				444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */,
 				444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */,
 				444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */,
-				444EAE1E0BD0E65B00C6D4A0 /* Person.h */,
 				444EAE1F0BD0E65B00C6D4A0 /* Quest.h */,
 				444EAE200BD0E65B00C6D4A0 /* QuestBook.h */,
 				444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */,
@@ -2051,7 +2104,6 @@
 				444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */,
 				444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */,
 				444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */,
-				444EADC80BD0E64100C6D4A0 /* Person.cpp */,
 				444EADC90BD0E64100C6D4A0 /* Quest.cpp */,
 				444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */,
 				444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */,
@@ -2072,6 +2124,12 @@
 		444EAE600BD0E66500C6D4A0 /* RlScript */ = {
 			isa = PBXGroup;
 			children = (
+				485B89570E15796500D5B19C /* Scene.cpp */,
+				485B89580E15796500D5B19C /* SceneLoader.cpp */,
+				485B89590E15796500D5B19C /* SceneManager.cpp */,
+				485B89510E15794A00D5B19C /* Scene.h */,
+				485B89520E15794A00D5B19C /* SceneLoader.h */,
+				485B89530E15794A00D5B19C /* SceneManager.h */,
 				48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */,
 				48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */,
 				48389C010D86783200AFAB66 /* swig */,
@@ -2378,7 +2436,6 @@
 				444EAE490BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h in Headers */,
 				444EAE4A0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h in Headers */,
 				444EAE4B0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h in Headers */,
-				444EAE4C0BD0E65B00C6D4A0 /* Person.h in Headers */,
 				444EAE4D0BD0E65B00C6D4A0 /* Quest.h in Headers */,
 				444EAE4E0BD0E65B00C6D4A0 /* QuestBook.h in Headers */,
 				444EAE4F0BD0E65B00C6D4A0 /* QuestEvent.h in Headers */,
@@ -2410,6 +2467,7 @@
 				483D31280D85B215003477A0 /* RulesMessages.h in Headers */,
 				483D31290D85B215003477A0 /* stdinc.h in Headers */,
 				483D312A0D85B215003477A0 /* WaitJob.h in Headers */,
+				48A52CB60E0EF5BD008DBDD8 /* ApplyDamageJob.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2515,6 +2573,9 @@
 				48570C3C0D8A6C9000096E35 /* ScriptPrerequisites.h in Headers */,
 				48570C3D0D8A6C9000096E35 /* ScriptSubsystem.h in Headers */,
 				48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */,
+				485B89540E15794A00D5B19C /* Scene.h in Headers */,
+				485B89550E15794A00D5B19C /* SceneLoader.h in Headers */,
+				485B89560E15794A00D5B19C /* SceneManager.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2766,7 +2827,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "pwd\ncd ../engine/script/swig\nswig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i";
+			shellScript = "pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i";
 		};
 /* End PBXShellScriptBuildPhase section */
 
@@ -2942,7 +3003,6 @@
 				444EADEF0BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp in Sources */,
 				444EADF00BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp in Sources */,
 				444EADF10BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp in Sources */,
-				444EADF20BD0E64100C6D4A0 /* Person.cpp in Sources */,
 				444EADF30BD0E64100C6D4A0 /* Quest.cpp in Sources */,
 				444EADF40BD0E64100C6D4A0 /* QuestBook.cpp in Sources */,
 				444EADF50BD0E64100C6D4A0 /* QuestEvent.cpp in Sources */,
@@ -2970,6 +3030,7 @@
 				483D31380D85B22C003477A0 /* GoToJob.cpp in Sources */,
 				483D31390D85B22C003477A0 /* Kampfaktion.cpp in Sources */,
 				483D313A0D85B22C003477A0 /* WaitJob.cpp in Sources */,
+				48A52CB80E0EF5D0008DBDD8 /* ApplyDamageJob.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3070,6 +3131,9 @@
 				48570C3A0D8A6C9000096E35 /* ScriptSubsystem.cpp in Sources */,
 				48570DFE0D8A6F3300096E35 /* TriggerFactory.cpp in Sources */,
 				48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */,
+				485B895A0E15796500D5B19C /* Scene.cpp in Sources */,
+				485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */,
+				485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3212,6 +3276,11 @@
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
@@ -3234,7 +3303,7 @@
 					/opt/local/lib,
 				);
 				MACH_O_TYPE = mh_dylib;
-				OTHER_LDFLAGS = "";
+				OTHER_LDFLAGS = "-pthread";
 				PREBINDING = NO;
 				PRODUCT_NAME = libRlCommon;
 				ZERO_LINK = YES;
@@ -3247,6 +3316,11 @@
 				COPY_PHASE_STRIP = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -3271,7 +3345,11 @@
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
-				FRAMEWORK_SEARCH_PATHS = "";
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
@@ -3309,7 +3387,11 @@
 				COPY_PHASE_STRIP = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
-				FRAMEWORK_SEARCH_PATHS = "";
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -3346,6 +3428,11 @@
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
@@ -3379,6 +3466,11 @@
 				COPY_PHASE_STRIP = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -3409,6 +3501,11 @@
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
@@ -3442,6 +3539,11 @@
 				COPY_PHASE_STRIP = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -3472,6 +3574,11 @@
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
@@ -3506,6 +3613,11 @@
 				COPY_PHASE_STRIP = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -3539,6 +3651,11 @@
 			buildSettings = {
 				COPY_PHASE_STRIP = NO;
 				EXECUTABLE_PREFIX = lib;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_MODEL_TUNING = G5;
@@ -3564,6 +3681,11 @@
 				COPY_PHASE_STRIP = YES;
 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
 				EXECUTABLE_PREFIX = lib;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_MODEL_TUNING = G5;
 				HEADER_SEARCH_PATHS = (
@@ -3589,6 +3711,11 @@
 				DYLIB_CURRENT_VERSION = "";
 				EXECUTABLE_EXTENSION = bundle;
 				EXECUTABLE_PREFIX = "";
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_MODEL_TUNING = G5;
@@ -3615,6 +3742,11 @@
 				DYLIB_CURRENT_VERSION = "";
 				EXECUTABLE_EXTENSION = bundle;
 				EXECUTABLE_PREFIX = "";
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_MODEL_TUNING = G5;
 				HEADER_SEARCH_PATHS = (
@@ -3638,6 +3770,11 @@
 				DYLIB_CURRENT_VERSION = 1;
 				EXECUTABLE_EXTENSION = dylib;
 				EXECUTABLE_PREFIX = lib;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_MODEL_TUNING = G5;
@@ -3670,6 +3807,11 @@
 				DYLIB_CURRENT_VERSION = 1;
 				EXECUTABLE_EXTENSION = dylib;
 				EXECUTABLE_PREFIX = lib;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_MODEL_TUNING = G5;
 				HEADER_SEARCH_PATHS = (
@@ -3695,6 +3837,11 @@
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				COPY_PHASE_STRIP = NO;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
 				GCC_MODEL_TUNING = G5;
@@ -3723,6 +3870,11 @@
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				ARCHS = i386;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Versions/A/Frameworks\"";
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/ai/include/AiWorld.h	2008-06-29 17:16:24 UTC (rev 4409)
@@ -16,7 +16,9 @@
 #ifndef __RlAI_World_H__
 #define __RlAI_World_H__
 
-#include "OpenSteer/Obstacle.h"
+#include "AiPrerequisites.h"
+
+#include <OpenSteer/Obstacle.h>
 #include "DebugVisualisable.h"
 #include "SimpleVehicle.h"
 

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2008-06-29 17:16:24 UTC (rev 4409)
@@ -15,13 +15,14 @@
  */
 #include "stdinc.h" //precompiled header
 
+#include "AiWorld.h"
+
 #ifdef __APPLE__
 #   include <OgreNewt/OgreNewt.h>
 #else
 #   include <OgreNewt.h>
 #endif
 
-#include "AiWorld.h"
 #include "PhysicsManager.h"
 #include "LineSetPrimitive.h"
 #include "CoreSubsystem.h"

Modified: rl/trunk/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/trunk/engine/common/include/FixRubyHeaders.h	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/common/include/FixRubyHeaders.h	2008-06-29 17:16:24 UTC (rev 4409)
@@ -1,81 +1,84 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/**
- * Einige Undefines, f?r unfreundliche defines in den Ruby-Headers.
- * Dort werden viele C-Funktionen ?berdeckt, die in Ogre aber ben?tigt werden.
- * Diese Datei muss nach einem Ruby-Header inkludiert werden, m?glicherweise auch
- * noch davor, um vorherige Makros zu l?schen.
- */
-#undef accept
-#undef bind
-#undef close
-#undef select
-#undef shutdown
-#undef snprintf
-#undef vsnprintf
-#undef Sleep
-#undef sleep
-#undef strcasecmp
-#undef rename
-#undef write
-#ifdef HAVE_CONFIG_H
-    #undef PACKAGE_VERSION
-    #undef PACKAGE_STRING
-    #undef PACKAGE_NAME
-    #undef PACKAGE_TARNAME
-#endif
-#undef max
-#undef min
-
-#undef EWOULDBLOCK	
-#undef EINPROGRESS	
-#undef EALREADY	
-#undef ENOTSOCK	
-#undef EDESTADDRREQ	
-#undef EMSGSIZE	
-#undef EPROTOTYPE	
-#undef ENOPROTOOPT	
-#undef EPROTONOSUPPORT	
-#undef ESOCKTNOSUPPORT	
-#undef EOPNOTSUPP	
-#undef EPFNOSUPPORT	
-#undef EAFNOSUPPORT	
-#undef EADDRINUSE	
-#undef EADDRNOTAVAIL	
-#undef ENETDOWN	
-#undef ENETUNREACH	
-#undef ENETRESET	
-#undef ECONNABORTED	
-#undef ECONNRESET	
-#undef ENOBUFS		
-#undef EISCONN		
-#undef ENOTCONN	
-#undef ESHUTDOWN	
-#undef ETOOMANYREFS	
-#undef ETIMEDOUT	
-#undef ECONNREFUSED	
-#undef ELOOP		
-/*#undef ENAMETOOLONG	*/
-#undef EHOSTDOWN	
-#undef EHOSTUNREACH	
-/*#undef ENOTEMPTY	*/
-#undef EPROCLIM	
-#undef EUSERS		
-#undef EDQUOT		
-#undef ESTALE		
-#undef EREMOTE		
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/**
+ * Einige Undefines, f??r unfreundliche defines in den Ruby-Headers.
+ * Dort werden viele C-Funktionen ??berdeckt, die in Ogre aber ben??tigt werden.
+ * Diese Datei muss nach einem Ruby-Header inkludiert werden, m??glicherweise auch
+ * noch davor, um vorherige Makros zu l??schen.
+ */
+#undef accept
+#undef bind
+#undef close
+#undef select
+#undef shutdown
+#undef snprintf
+#undef vsnprintf
+#undef Sleep
+#undef sleep
+#undef strcasecmp
+#undef rename
+#undef write
+#undef max
+#undef min
+
+#undef PACKAGE_VERSION
+#undef PACKAGE_STRING
+#undef PACKAGE_NAME
+#undef PACKAGE_TARNAME
+#undef HAVE_VSNPRINTF
+
+#undef EWOULDBLOCK	
+#undef EINPROGRESS	
+#undef EALREADY	
+#undef ENOTSOCK	
+#undef EDESTADDRREQ	
+#undef EMSGSIZE	
+#undef EPROTOTYPE	
+#undef ENOPROTOOPT	
+#undef EPROTONOSUPPORT	
+#undef ESOCKTNOSUPPORT	
+#undef EOPNOTSUPP	
+#undef EPFNOSUPPORT	
+#undef EAFNOSUPPORT	
+#undef EADDRINUSE	
+#undef EADDRNOTAVAIL	
+#undef ENETDOWN	
+#undef ENETUNREACH	
+#undef ENETRESET	
+#undef ECONNABORTED	
+#undef ECONNRESET	
+#undef ENOBUFS		
+#undef EISCONN		
+#undef ENOTCONN	
+#undef ESHUTDOWN	
+#undef ETOOMANYREFS	
+#undef ETIMEDOUT	
+#undef ECONNREFUSED	
+#undef ELOOP		
+/*#undef ENAMETOOLONG	*/
+#undef EHOSTDOWN	
+#undef EHOSTUNREACH	
+/*#undef ENOTEMPTY	*/
+#undef EPROCLIM	
+#undef EUSERS		
+#undef EDQUOT		
+#undef ESTALE		
+#undef EREMOTE		
+
+#undef CONNECT
+#undef T_CONNECT
+#undef T_DATA
\ No newline at end of file

Modified: rl/trunk/engine/common/include/RastullahPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/RastullahPrerequisites.h	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/common/include/RastullahPrerequisites.h	2008-06-29 17:16:24 UTC (rev 4409)
@@ -1,61 +1,62 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RastullahPrerequisites_H__
-#define __RastullahPrerequisites_H__
-
-#define OGRE_MEMORY_STRESS_TEST 1
-
-#undef max
-#undef min
-
-#ifdef __APPLE__
-#   include <Ogre/Ogre.h>
-#   include <Ogre/OgreFont.h>
-#   include <Ogre/OgreFontManager.h>
-#   include <Ogre/OgreTagPoint.h>
-#else
-#   include <Ogre.h>
-#   include <OgreFont.h>
-#   include <OgreFontManager.h>
-#   include <OgreTagPoint.h>
-#endif
-
-#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
-#   define _snprintf snprintf
-template<class T1, class T2>
-bool max(T1 m1, T2 m2) { return (m1 < m2)?m2:m1; }
-#endif
-
-#if !defined(RL_LONGLONG)
-#   if defined(_MSC_VER) && (_MSC_VER < 1300)
-#       define RL_LONGLONG _int64
-#   else
-#       define RL_LONGLONG long long
-#   endif
-#endif
-
-#if defined(_MSC_VER) && (_MSC_VER > 1300)   // MS Visual Studio 2005
-// signed / unsigned auf 1x
-#    pragma warning(once : 4018)
-// Sichere Versionen der Stringfunktionen benutzen
-#    if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES == 0
-#        undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
-#        define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
-#    endif
-#endif
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RastullahPrerequisites_H__
+#define __RastullahPrerequisites_H__
+
+#define OGRE_MEMORY_STRESS_TEST 1
+
+#undef max
+#undef min
+
+#ifdef __APPLE__
+#   include <HIToolbox/CarbonEventsCore.h>
+#   include <Ogre/Ogre.h>
+#   include <Ogre/OgreFont.h>
+#   include <Ogre/OgreFontManager.h>
+#   include <Ogre/OgreTagPoint.h>
+#else
+#   include <Ogre.h>
+#   include <OgreFont.h>
+#   include <OgreFontManager.h>
+#   include <OgreTagPoint.h>
+#endif
+
+#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
+#   define _snprintf snprintf
+template<class T1, class T2>
+bool max(T1 m1, T2 m2) { return (m1 < m2)?m2:m1; }
+#endif
+
+#if !defined(RL_LONGLONG)
+#   if defined(_MSC_VER) && (_MSC_VER < 1300)
+#       define RL_LONGLONG _int64
+#   else
+#       define RL_LONGLONG long long
+#   endif
+#endif
+
+#if defined(_MSC_VER) && (_MSC_VER > 1300)   // MS Visual Studio 2005
+// signed / unsigned auf 1x
+#    pragma warning(once : 4018)
+// Sichere Versionen der Stringfunktionen benutzen
+#    if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES == 0
+#        undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
+#        define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
+#    endif
+#endif
+
+#endif

Modified: rl/trunk/engine/core/include/DotSceneLoader.h
===================================================================
--- rl/trunk/engine/core/include/DotSceneLoader.h	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/core/include/DotSceneLoader.h	2008-06-29 17:16:24 UTC (rev 4409)
@@ -17,6 +17,8 @@
 #ifndef __DotSceneLoader_H__
 #define __DotSceneLoader_H__
 
+#include "CorePrerequisites.h"
+
 #ifdef __APPLE__
 #   include <OgreNewt/OgreNewt.h>
 #else

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2008-06-29 17:16:24 UTC (rev 4409)
@@ -17,6 +17,8 @@
 #ifndef __PhysicsManager_H__
 #define __PhysicsManager_H__
 
+#include "CorePrerequisites.h"
+
 #include <map>
 #include <vector>
 

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-06-29 17:16:24 UTC (rev 4409)
@@ -17,7 +17,6 @@
 
 #include <xercesc/dom/DOM.hpp>
 
-
 #include "DotSceneLoader.h"
 #include "World.h"
 

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2008-06-23 20:49:46 UTC (rev 4408)
+++ rl/trunk/engine/script/swig/RlExports.i	2008-06-29 17:16:24 UTC (rev 4409)
@@ -1,177 +1,176 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"	
-
-// Activate Directors and name the module RlScript
-%module(directors="1") RlScript
-/* Tell SWIG to keep track of mappings between C/C++ structs/classes. */
-%trackobjects;
-
-%{
-#undef min
-
-#if defined(_MSC_VER) && (_MSC_VER > 1300)   // MS Visual Studio 2005
-// Sichere Versionen der Stringfunktionen benutzen
-#	if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
-#		define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
-#	endif
-#endif
-
-// Has to be included before Ogre, MemoryManager issues...
-#include <xercesc/util/XMemory.hpp>	
-
-// Exporting the function for getting ruby instances
-VALUE RL_RubyInstanceFor(void* ptr) 
-{
-	return SWIG_RubyInstanceFor(ptr);
-}
-// Exporting the function for removing ruby instances
-void RL_RubyRemoveTracking(void* ptr) 
-{
-	return SWIG_RubyRemoveTracking(ptr);
-}
-
-#include "FixRubyHeaders.h"
-
-#include <CEGUIExceptions.h>
-#include <vector>
-
-%}
-
-%include "stl.i"
-
-// Header includes
-%include "RlCommon.head.swig"
-%include "RlUi.head.swig"
-%include "RlCore.head.swig"
-%include "RlRules.head.swig"
-%include "RlAi.head.swig"
-%include "RlScript.head.swig"
-
-%{
-#ifndef SWIG_FLOAT_P
-#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))
-#endif
-%}
-%include "TypeMaps.i"
-
-
-
-
-
-
-// Kopie. Falls das nochmal irgendwohin kopiert werden muss,
-// In separate Datei auslagen.
-#if !defined(RL_LONGLONG)
-#   if (_MSC_VER >= 1200) && (_MSC_VER < 1300)
-#       define RL_LONGLONG _int64
-#   else
-#       define RL_LONGLONG long long
-#   endif
-#endif
-
-
-
-
-// Handling of errors in director methods
-%feature("director:except") 
-{
-	RL_handleRubyError( error );
-	return Qnil;
-}
-
-%{
-// Error Handling for Ruby
-void RL_handleRubyError( VALUE error )
-{
-	std::stringstream stream;	
-	// get error class
-    VALUE klass = rb_class_path(CLASS_OF(error));
-    stream << RSTRING(klass)->ptr << " (\""; 
-
-    // get error message
-    VALUE message = rb_obj_as_string(error);
-    stream << RSTRING(message)->ptr << "\"), ";
-
-    // get backtrace
-    if(!NIL_P(ruby_errinfo)) 
-    {
-		stream << "Callstack: [ ";
-        VALUE ary = rb_funcall(
-            ruby_errinfo, rb_intern("backtrace"), 0);
-        int c;
-        for (c=RARRAY(ary)->len; c>0; c--) {     
-            stream <<  RSTRING(RARRAY(ary)->ptr[c-1])->ptr;
-            if( c > 1 )
-				stream << ", "; 
-        }
-        stream << "]";
-    }
-    else
-		stream << "[ No Callstack found ]";
-     
-    LOG_ERROR(rl::Logger::SCRIPT, stream.str() );
-    rl::WindowFactory::getSingleton().writeToConsole( stream.str() );  
-}
-%}
-
-
-
-// Converting C++ Exceptions to Ruby Exceptions
-%exception %{
-  try 
-  {
-    $action
-  }
-  catch (CEGUI::Exception& ce) 
-  {
-    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
-    rb_raise(ceguiException, ce.getMessage().c_str());
-  }
-  catch (std::exception& se) 
-  {
-    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
-    rb_raise(stdException, se.what());
-  }
-  catch (Swig::DirectorException& de)
-  {
-	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
-	rb_raise(swigException, de.getMessage().c_str());
-  }
-  catch (...) 
-  {
-    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
-    rb_raise(unknownException,"Unbekannte Exception");
-  }
-%}
-
-
-
-// deaktiviere Warnung ueber unreferenzierte lokale Variable, 
-// da dies in allen erzeugten Exceptionhandlern auftritt
-%{
-#pragma warning( disable : 4101 )									
-%}
-
-// Include bodies
-
-%include "RlCommon.swig"
-%include "RlCore.swig"
-%include "RlRules.swig"
-%include "RlUi.swig"
-%include "RlAi.swig"
-%include "RlScript.swig"
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"	
+
+// Activate Directors and name the module RlScript
+%module(directors="1") RlScript
+/* Tell SWIG to keep track of mappings between C/C++ structs/classes. */
+%trackobjects;
+
+%{
+#undef min
+
+#if defined(_MSC_VER) && (_MSC_VER > 1300)   // MS Visual Studio 2005
+// Sichere Versionen der Stringfunktionen benutzen
+#	if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
+#		define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
+#	endif
+#endif
+
+// Has to be included before Ogre, MemoryManager issues...
+#include <xercesc/util/XMemory.hpp>	
+
+// Exporting the function for getting ruby instances
+VALUE RL_RubyInstanceFor(void* ptr) 
+{
+	return SWIG_RubyInstanceFor(ptr);
+}
+// Exporting the function for removing ruby instances
+void RL_RubyRemoveTracking(void* ptr) 
+{
+	return SWIG_RubyRemoveTracking(ptr);
+}
+
+#include "FixRubyHeaders.h"
+
+#include <CEGUIExceptions.h>
+#include <vector>
+
+%}
+
+%include "stl.i"
+
+// Header includes
+%include "RlCommon.head.swig"
+%include "RlUi.head.swig"
+%include "RlCore.head.swig"
+%include "RlRules.head.swig"
+%include "RlAi.head.swig"
+%include "RlScript.head.swig"
+
+%{
+#ifndef SWIG_FLOAT_P
+#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))
+#endif
+%}
+%include "TypeMaps.i"
+
+
+
+
+
+
+// Kopie. Falls das nochmal irgendwohin kopiert werden muss,
+// In separate Datei auslagen.
+#if !defined(RL_LONGLONG)
+#   if (_MSC_VER >= 1200) && (_MSC_VER < 1300)
+#       define RL_LONGLONG _int64
+#   else
+#       define RL_LONGLONG long long
+#   endif
+#endif
+
+
+
+
+// Handling of errors in director methods
+%feature("director:except") 
+{
+	RL_handleRubyError( error );
+	return Qnil;
+}
+
+%{
+// Error Handling for Ruby
+void RL_handleRubyError( VALUE error )
+{
+	std::stringstream stream;	
+	// get error class
+    VALUE klass = rb_class_path(CLASS_OF(error));
+    stream << RSTRING(klass)->ptr << " (\""; 
+
+    // get error message
+    VALUE message = rb_obj_as_string(error);
+    stream << RSTRING(message)->ptr << "\"), ";
+
+    // get backtrace
+    if(!NIL_P(ruby_errinfo)) 
+    {
+		stream << "Callstack: [ ";
+        VALUE ary = rb_funcall(
+            ruby_errinfo, rb_intern("backtrace"), 0);
+        int c;
+        for (c=RARRAY(ary)->len; c>0; c--) {     
+            stream <<  RSTRING(RARRAY(ary)->ptr[c-1])->ptr;
+            if( c > 1 )
+				stream << ", "; 
+        }
+        stream << "]";
+    }
+    else
+		stream << "[ No Callstack found ]";
+     
+    LOG_ERROR(rl::Logger::SCRIPT, stream.str() );
+    rl::WindowFactory::getSingleton().writeToConsole( stream.str() );  
+}
+%}
+
+
+
+// Converting C++ Exceptions to Ruby Exceptions
+%exception %{
+  try 
+  {
+    $action
+  }
+  catch (CEGUI::Exception& ce) 
+  {
+    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
+    rb_raise(ceguiException, ce.getMessage().c_str());
+  }
+  catch (std::exception& se) 
+  {
+    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
+    rb_raise(stdException, se.what());
+  }
+  catch (Swig::DirectorException& de)
+  {
+	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
+	rb_raise(swigException, de.getMessage().c_str());
+  }
+  catch (...) 
+  {
+    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
+    rb_raise(unknownException,"Unbekannte Exception");
+  }
+%}
+
+
+
+// deaktiviere Warnung ueber unreferenzierte lokale Variable, 
+// da dies in allen erzeugten Exceptionhandlern auftritt
+%{
+#pragma warning( disable : 4101 )									
+%}
+
+// Include bodies
+
+%include "RlCommon.swig"
+%include "RlCore.swig"
+%include "RlRules.swig"
+%include "RlUi.swig"
+%include "RlAi.swig"
+%include "RlScript.swig"



From blakharaz at mail.berlios.de  Sun Jun 29 23:25:29 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 29 Jun 2008 23:25:29 +0200
Subject: [Dsa-hl-svn] r4410 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200806292125.m5TLPTcu026002@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-29 23:25:26 +0200 (Sun, 29 Jun 2008)
New Revision: 4410

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:
Add the movement classes to Mac build

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-06-29 17:16:24 UTC (rev 4409)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-06-29 21:25:26 UTC (rev 4410)
@@ -611,6 +611,37 @@
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
+		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
+		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
+		4890C0BB0E18061300BE5850 /* JogFastMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AA0E18061300BE5850 /* JogFastMovement.h */; };
+		4890C0BC0E18061300BE5850 /* JogMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AB0E18061300BE5850 /* JogMovement.h */; };
+		4890C0BD0E18061300BE5850 /* JumpHighMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AC0E18061300BE5850 /* JumpHighMovement.h */; };
+		4890C0BE0E18061300BE5850 /* JumpLongMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AD0E18061300BE5850 /* JumpLongMovement.h */; };
+		4890C0BF0E18061300BE5850 /* JumpToTargetMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AE0E18061300BE5850 /* JumpToTargetMovement.h */; };
+		4890C0C00E18061300BE5850 /* LieDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0AF0E18061300BE5850 /* LieDownMovement.h */; };
+		4890C0C10E18061300BE5850 /* RotateMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B00E18061300BE5850 /* RotateMovement.h */; };
+		4890C0C20E18061300BE5850 /* SneakMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B10E18061300BE5850 /* SneakMovement.h */; };
+		4890C0C30E18061300BE5850 /* SprintMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B20E18061300BE5850 /* SprintMovement.h */; };
+		4890C0C40E18061300BE5850 /* StandAroundMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B30E18061300BE5850 /* StandAroundMovement.h */; };
+		4890C0C50E18061300BE5850 /* StepRecognitionMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */; };
+		4890C0C60E18061300BE5850 /* StrafeMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B50E18061300BE5850 /* StrafeMovement.h */; };
+		4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */; };
+		4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0B70E18061300BE5850 /* WalkMovement.h */; };
+		4890C0D70E18062B00BE5850 /* FallDownMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */; };
+		4890C0D80E18062B00BE5850 /* JogFastMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */; };
+		4890C0D90E18062B00BE5850 /* JogMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CB0E18062B00BE5850 /* JogMovement.cpp */; };
+		4890C0DA0E18062B00BE5850 /* JumpHighMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */; };
+		4890C0DB0E18062B00BE5850 /* JumpLongMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */; };
+		4890C0DC0E18062B00BE5850 /* JumpToTargetMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */; };
+		4890C0DD0E18062B00BE5850 /* LieDownMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0CF0E18062B00BE5850 /* LieDownMovement.cpp */; };
+		4890C0DE0E18062B00BE5850 /* RotateMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D00E18062B00BE5850 /* RotateMovement.cpp */; };
+		4890C0DF0E18062B00BE5850 /* SneakMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D10E18062B00BE5850 /* SneakMovement.cpp */; };
+		4890C0E00E18062B00BE5850 /* SprintMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D20E18062B00BE5850 /* SprintMovement.cpp */; };
+		4890C0E10E18062B00BE5850 /* StandAroundMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D30E18062B00BE5850 /* StandAroundMovement.cpp */; };
+		4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */; };
+		4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */; };
+		4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D60E18062B00BE5850 /* WalkMovement.cpp */; };
 		48A52B220E0EDA0E008DBDD8 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
 		48A52CB00E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
 		48A52CB10E0EF55C008DBDD8 /* libboost_system.lib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */; };
@@ -1362,6 +1393,37 @@
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AA0E18061300BE5850 /* JogFastMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogFastMovement.h; path = ../engine/rules/include/JogFastMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AB0E18061300BE5850 /* JogMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogMovement.h; path = ../engine/rules/include/JogMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AC0E18061300BE5850 /* JumpHighMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpHighMovement.h; path = ../engine/rules/include/JumpHighMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AD0E18061300BE5850 /* JumpLongMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpLongMovement.h; path = ../engine/rules/include/JumpLongMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AE0E18061300BE5850 /* JumpToTargetMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpToTargetMovement.h; path = ../engine/rules/include/JumpToTargetMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0AF0E18061300BE5850 /* LieDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LieDownMovement.h; path = ../engine/rules/include/LieDownMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B00E18061300BE5850 /* RotateMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RotateMovement.h; path = ../engine/rules/include/RotateMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B10E18061300BE5850 /* SneakMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SneakMovement.h; path = ../engine/rules/include/SneakMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B20E18061300BE5850 /* SprintMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SprintMovement.h; path = ../engine/rules/include/SprintMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B30E18061300BE5850 /* StandAroundMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StandAroundMovement.h; path = ../engine/rules/include/StandAroundMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StepRecognitionMovement.h; path = ../engine/rules/include/StepRecognitionMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B50E18061300BE5850 /* StrafeMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StrafeMovement.h; path = ../engine/rules/include/StrafeMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WalkBackwardsMovement.h; path = ../engine/rules/include/WalkBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0B70E18061300BE5850 /* WalkMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WalkMovement.h; path = ../engine/rules/include/WalkMovement.h; sourceTree = SOURCE_ROOT; };
+		4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FallDownMovement.cpp; path = ../engine/rules/src/FallDownMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JogFastMovement.cpp; path = ../engine/rules/src/JogFastMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CB0E18062B00BE5850 /* JogMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JogMovement.cpp; path = ../engine/rules/src/JogMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpHighMovement.cpp; path = ../engine/rules/src/JumpHighMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpLongMovement.cpp; path = ../engine/rules/src/JumpLongMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpToTargetMovement.cpp; path = ../engine/rules/src/JumpToTargetMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0CF0E18062B00BE5850 /* LieDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LieDownMovement.cpp; path = ../engine/rules/src/LieDownMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D00E18062B00BE5850 /* RotateMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RotateMovement.cpp; path = ../engine/rules/src/RotateMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D10E18062B00BE5850 /* SneakMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SneakMovement.cpp; path = ../engine/rules/src/SneakMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D20E18062B00BE5850 /* SprintMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SprintMovement.cpp; path = ../engine/rules/src/SprintMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D30E18062B00BE5850 /* StandAroundMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StandAroundMovement.cpp; path = ../engine/rules/src/StandAroundMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StepRecognitionMovement.cpp; path = ../engine/rules/src/StepRecognitionMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StrafeMovement.cpp; path = ../engine/rules/src/StrafeMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0D60E18062B00BE5850 /* WalkMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WalkMovement.cpp; path = ../engine/rules/src/WalkMovement.cpp; sourceTree = SOURCE_ROOT; };
 		48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_filesystem.dylib; path = /usr/local/lib/libboost_filesystem.dylib; sourceTree = "<absolute>"; };
 		48A52CAF0E0EF55C008DBDD8 /* libboost_system.lib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_system.lib; path = /usr/local/lib/libboost_system.lib; sourceTree = "<absolute>"; };
 		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ApplyDamageJob.h; path = ../engine/rules/include/ApplyDamageJob.h; sourceTree = SOURCE_ROOT; };
@@ -2010,6 +2072,37 @@
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */,
+				4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */,
+				4890C0CB0E18062B00BE5850 /* JogMovement.cpp */,
+				4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */,
+				4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */,
+				4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */,
+				4890C0CF0E18062B00BE5850 /* LieDownMovement.cpp */,
+				4890C0D00E18062B00BE5850 /* RotateMovement.cpp */,
+				4890C0D10E18062B00BE5850 /* SneakMovement.cpp */,
+				4890C0D20E18062B00BE5850 /* SprintMovement.cpp */,
+				4890C0D30E18062B00BE5850 /* StandAroundMovement.cpp */,
+				4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */,
+				4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */,
+				4890C0D60E18062B00BE5850 /* WalkMovement.cpp */,
+				4890C0A70E18061300BE5850 /* AbstractMovement.h */,
+				4890C0A80E18061300BE5850 /* FallDownMovement.h */,
+				4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */,
+				4890C0AA0E18061300BE5850 /* JogFastMovement.h */,
+				4890C0AB0E18061300BE5850 /* JogMovement.h */,
+				4890C0AC0E18061300BE5850 /* JumpHighMovement.h */,
+				4890C0AD0E18061300BE5850 /* JumpLongMovement.h */,
+				4890C0AE0E18061300BE5850 /* JumpToTargetMovement.h */,
+				4890C0AF0E18061300BE5850 /* LieDownMovement.h */,
+				4890C0B00E18061300BE5850 /* RotateMovement.h */,
+				4890C0B10E18061300BE5850 /* SneakMovement.h */,
+				4890C0B20E18061300BE5850 /* SprintMovement.h */,
+				4890C0B30E18061300BE5850 /* StandAroundMovement.h */,
+				4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */,
+				4890C0B50E18061300BE5850 /* StrafeMovement.h */,
+				4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */,
+				4890C0B70E18061300BE5850 /* WalkMovement.h */,
 				48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */,
 				48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */,
 				483D311E0D85B215003477A0 /* stdinc.h */,
@@ -2468,6 +2561,23 @@
 				483D31290D85B215003477A0 /* stdinc.h in Headers */,
 				483D312A0D85B215003477A0 /* WaitJob.h in Headers */,
 				48A52CB60E0EF5BD008DBDD8 /* ApplyDamageJob.h in Headers */,
+				4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */,
+				4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */,
+				4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */,
+				4890C0BB0E18061300BE5850 /* JogFastMovement.h in Headers */,
+				4890C0BC0E18061300BE5850 /* JogMovement.h in Headers */,
+				4890C0BD0E18061300BE5850 /* JumpHighMovement.h in Headers */,
+				4890C0BE0E18061300BE5850 /* JumpLongMovement.h in Headers */,
+				4890C0BF0E18061300BE5850 /* JumpToTargetMovement.h in Headers */,
+				4890C0C00E18061300BE5850 /* LieDownMovement.h in Headers */,
+				4890C0C10E18061300BE5850 /* RotateMovement.h in Headers */,
+				4890C0C20E18061300BE5850 /* SneakMovement.h in Headers */,
+				4890C0C30E18061300BE5850 /* SprintMovement.h in Headers */,
+				4890C0C40E18061300BE5850 /* StandAroundMovement.h in Headers */,
+				4890C0C50E18061300BE5850 /* StepRecognitionMovement.h in Headers */,
+				4890C0C60E18061300BE5850 /* StrafeMovement.h in Headers */,
+				4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */,
+				4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3031,6 +3141,20 @@
 				483D31390D85B22C003477A0 /* Kampfaktion.cpp in Sources */,
 				483D313A0D85B22C003477A0 /* WaitJob.cpp in Sources */,
 				48A52CB80E0EF5D0008DBDD8 /* ApplyDamageJob.cpp in Sources */,
+				4890C0D70E18062B00BE5850 /* FallDownMovement.cpp in Sources */,
+				4890C0D80E18062B00BE5850 /* JogFastMovement.cpp in Sources */,
+				4890C0D90E18062B00BE5850 /* JogMovement.cpp in Sources */,
+				4890C0DA0E18062B00BE5850 /* JumpHighMovement.cpp in Sources */,
+				4890C0DB0E18062B00BE5850 /* JumpLongMovement.cpp in Sources */,
+				4890C0DC0E18062B00BE5850 /* JumpToTargetMovement.cpp in Sources */,
+				4890C0DD0E18062B00BE5850 /* LieDownMovement.cpp in Sources */,
+				4890C0DE0E18062B00BE5850 /* RotateMovement.cpp in Sources */,
+				4890C0DF0E18062B00BE5850 /* SneakMovement.cpp in Sources */,
+				4890C0E00E18062B00BE5850 /* SprintMovement.cpp in Sources */,
+				4890C0E10E18062B00BE5850 /* StandAroundMovement.cpp in Sources */,
+				4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */,
+				4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */,
+				4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};



From timm at mail.berlios.de  Mon Jun 30 15:07:26 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 30 Jun 2008 15:07:26 +0200
Subject: [Dsa-hl-svn] r4411 - modules/persistenztest/scripts/maps
Message-ID: <200806301307.m5UD7QKI015671@sheep.berlios.de>

Author: timm
Date: 2008-06-30 15:07:24 +0200 (Mon, 30 Jun 2008)
New Revision: 4411

Modified:
   modules/persistenztest/scripts/maps/map01.rb
   modules/persistenztest/scripts/maps/map02.rb
Log:
changed layout in persistence test

Modified: modules/persistenztest/scripts/maps/map01.rb
===================================================================
--- modules/persistenztest/scripts/maps/map01.rb	2008-06-29 21:25:26 UTC (rev 4410)
+++ modules/persistenztest/scripts/maps/map01.rb	2008-06-30 13:07:24 UTC (rev 4411)
@@ -1,10 +1,10 @@
 require 'embed.rb'
 require 'MapChange.rb'
 
-base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-5,0.05,-5], [5,0.3,5], "alpha_blue")
+base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "alpha_blue")
 
 base.placeIntoScene([8,0,8])
 
 CreateSceneChangeTrigger("map1", [8,0,8], [0,0,0,1], [2, 2, 2], "scene02")
 
-#puts 'Map 1 init script wurde ausgef?hrt!'
+puts 'Map 1 init script wurde ausgef?hrt!'

Modified: modules/persistenztest/scripts/maps/map02.rb
===================================================================
--- modules/persistenztest/scripts/maps/map02.rb	2008-06-29 21:25:26 UTC (rev 4410)
+++ modules/persistenztest/scripts/maps/map02.rb	2008-06-30 13:07:24 UTC (rev 4411)
@@ -1,8 +1,8 @@
 require 'embed.rb'
 
-base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-5,0.05,-5], [5,0.3,5], "alpha_blue")
+base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "alpha_blue")
 
-base.placeIntoScene([8,0,8])
+base.placeIntoScene([8,0,-8])
 
 CreateSceneChangeTrigger("map2", [8,0,-8], [0,0,0,1], [2, 2, 2], "scene01")
 



From blakharaz at mail.berlios.de  Mon Jun 30 21:40:11 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 30 Jun 2008 21:40:11 +0200
Subject: [Dsa-hl-svn] r4412 - in modules: regressiontest/dsa
	regressiontest/scripts ruchin/scripts
Message-ID: <200806301940.m5UJeBRh009656@sheep.berlios.de>

Author: blakharaz
Date: 2008-06-30 21:40:07 +0200 (Mon, 30 Jun 2008)
New Revision: 4412

Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/InventoryTest.rb
   modules/ruchin/scripts/equip.rb
Log:
Short swort was moved to common and renamed to Kurzschwert

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-06-30 13:07:24 UTC (rev 4411)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-06-30 19:40:07 UTC (rev 4412)
@@ -98,16 +98,6 @@
         <property name="geometrytype" type="STRING" data="sphere"/>
     </gameobjectclass>
 
-    <gameobjectclass classid="shortsword" baseclass="Weapon">
-        <property name="name" type="STRING" data="Kurzschwert"/>
-        <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
-        <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
-        <property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
-        <property name="mass" type="REAL" data="3.0"/>
-        <property name="size" type="INTPAIR" data="2,4"/>
-		<property name="geometrytype" type="STRING" data="box"/>
-    </gameobjectclass>
-
     <gameobjectclass classid="leather backpack" baseclass="Container">
         <property name="name" type="STRING" data="Rucksack"/>
         <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2008-06-30 13:07:24 UTC (rev 4411)
+++ modules/regressiontest/scripts/InventoryTest.rb	2008-06-30 19:40:07 UTC (rev 4412)
@@ -20,22 +20,22 @@
     hero.getInventory().getItem("Back").addItem(itemToAdd);
     
     $SCRIPT.log("InventoryTest #2: Put a loaded object into container.");
-    sword_loaded_to_inventory = $GOM.createGameObject("shortsword");
+    sword_loaded_to_inventory = $GOM.createGameObject("Kurzschwert");
     hero.getInventory().getItem("Back").addItem(sword_loaded_to_inventory);
 
     $SCRIPT.log("InventoryTest #3: Put an object from the scene into container.");
-    sword_in_scene_to_inventory = $GOM.createGameObject("shortsword");
+    sword_in_scene_to_inventory = $GOM.createGameObject("Kurzschwert");
     sword_in_scene_to_inventory.placeIntoScene();
     hero.getInventory().getItem("Back").addItem(sword_in_scene_to_inventory);
 
     $SCRIPT.log("InventoryTest #4: Put an object attached to the hero into container.");
-    sword_held_to_inventory = $GOM.createGameObject("shortsword");
+    sword_held_to_inventory = $GOM.createGameObject("Kurzschwert");
     hero.getInventory().hold(sword_held_to_inventory, "Left Hand");
     #hero.getInventory().dropItem("Left Hand")
     hero.getInventory().getItem("Back").addItem(sword_held_to_inventory);
 
     $SCRIPT.log("InventoryTest #5: Put an object from a container into the hero's hand.");
-    sword_inventory_to_hold = $GOM.createGameObject("shortsword");
+    sword_inventory_to_hold = $GOM.createGameObject("Kurzschwert");
     hero.getInventory().getItem("Back").addItem(sword_inventory_to_hold)
     #hero.getInventory().getItem("Back").removeItem(sword_inventory_to_hold)
     hero.getInventory().hold(sword_inventory_to_hold, "Right Hand");

Modified: modules/ruchin/scripts/equip.rb
===================================================================
--- modules/ruchin/scripts/equip.rb	2008-06-30 13:07:24 UTC (rev 4411)
+++ modules/ruchin/scripts/equip.rb	2008-06-30 19:40:07 UTC (rev 4412)
@@ -14,10 +14,7 @@
     
     itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
     hero.getInventory().hold(itemToAdd, "Trousers");
-    #hero.getInventory().getItem("Back").addItem(itemToAdd);
     itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
     hero.getInventory().hold(itemToAdd, "Clothes");
-    #hero.getInventory().getItem("Back").addItem(itemToAdd);
     itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
     hero.getInventory().hold(itemToAdd, "Boots");
-   # hero.getInventory().getItem("Back").addItem(itemToAdd);
\ No newline at end of file



