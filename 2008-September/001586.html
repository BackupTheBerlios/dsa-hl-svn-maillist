<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4529 - in rl/trunk/engine/rules: include src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4529%20-%20in%20rl/trunk/engine/rules%3A%20include%20src&In-Reply-To=%3C200809282056.m8SKuAI5006013%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001585.html">
   <LINK REL="Next"  HREF="001587.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4529 - in rl/trunk/engine/rules: include src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4529%20-%20in%20rl/trunk/engine/rules%3A%20include%20src&In-Reply-To=%3C200809282056.m8SKuAI5006013%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4529 - in rl/trunk/engine/rules: include src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun Sep 28 22:56:10 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001585.html">[Dsa-hl-svn] r4528 - in rl/branches/persistence: ai/include core	core/include core/src rules/include rules/src script/include	script/src script/swig ui/include ui/src
</A></li>
        <LI>Next message: <A HREF="001587.html">[Dsa-hl-svn] r4530 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/rules/include engine/rules/src engine/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1586">[ date ]</a>
              <a href="thread.html#1586">[ thread ]</a>
              <a href="subject.html#1586">[ subject ]</a>
              <a href="author.html#1586">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-09-28 22:56:08 +0200 (Sun, 28 Sep 2008)
New Revision: 4529

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/GoToJob.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GoToJob.cpp
Log:
Added hasAction() method; cleanup

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/include/GameObject.h	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,240 +1,249 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __GAMEOBJECT_H__
-#define __GAMEOBJECT_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Action.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;ObjectStateChangeEventSource.h&quot;
-#include &quot;Properties.h&quot;
-#include &quot;CoreDefines.h&quot;
-
-namespace rl
-{
-    class Creature;
-    class Effect;
-    class EffectManager;
-
-    /**
-    * \brief Base class for all game relevant objects in RL
-    * Provides methods for identification of objects within the world
-    * Abstract concepts do not inherit this class
-    */
-    class _RlRulesExport GameObject 
-        : public ActorNotifiedObject, 
-          public ObjectStateChangeEventSource,
-          public PropertyHolder
-    {
-    public:
-        typedef std::vector&lt;std::pair&lt;Action*, int&gt; &gt; ActionOptionVector;
-        static const unsigned int NO_OBJECT_ID = 0;
-        
-        static const Ogre::String CLASS_NAME;
-
-        static const Ogre::String PROPERTY_CLASS_ID;
-        static const Ogre::String PROPERTY_OBJECT_ID;
-        static const Ogre::String PROPERTY_INHERITS;
-        static const Ogre::String PROPERTY_BASE_CLASS;
-        static const Ogre::String PROPERTY_SCENE; 
-        static const Ogre::String PROPERTY_POSITION; 
-        static const Ogre::String PROPERTY_ORIENTATION; 
-        static const Ogre::String PROPERTY_NAME;
-        static const Ogre::String PROPERTY_DESCRIPTION; 
-        static const Ogre::String PROPERTY_MESHFILE; 
-  		static const Ogre::String PROPERTY_MESHPARTS;
-        static const Ogre::String PROPERTY_SUBMESHPRENAME;
-		static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
-        static const Ogre::String PROPERTY_MASS; 
-        static const Ogre::String PROPERTY_ACTIONS; 
-        static const Ogre::String PROPERTY_DEFAULT_ACTION;
-
-        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        int getId() const;
-
-        const CeGuiString&amp; getClassId() const;
-        void setClassId(const CeGuiString&amp; classId);
-        
-        const CeGuiString&amp; getName() const;
-        void setName(const CeGuiString&amp; name);
-
-        const CeGuiString&amp; getDescription() const;
-        void setDescription(const CeGuiString&amp; description);
-
-        const CeGuiString&amp; getMeshfile() const;
-        void setMeshfile(const CeGuiString&amp; meshfile);
-
-        const CeGuiString&amp; getSubmeshPreName() const;
-        void setSubmeshPreName(const CeGuiString&amp; name);
-
-		const MeshPartMap&amp; getMeshParts() const;
-
-        const GeometryType getGeometryType() const;
-        void setGeometryType(GeometryType type);
-
-        const Ogre::Real getMass() const;
-        void setMass(const Ogre::Real mass);
-
-        void addAction(Action* action, int option = Action::ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
-        void removeAction(Action* action);
-
-        void setScene(const CeGuiString&amp; scene);
-        const CeGuiString&amp; getScene() const;
-    
-        /*
-         * sets the actor of this gameobject
-         * @warning if the GameObject is destroyed or the State of the GameObject changed or this function
-         * is called with another actor, the actor will be deleted!
-         */
-        void setActor(Actor* actor);
-        Actor* getActor();
-
-        /**
-         * Get all valid actions a character can perfom on this game object
-         * 
-         * @param actor the character
-         * @return a vector of actions
-         */
-        const ActionVector getValidActions(Creature* actor) const;
-        virtual Action* getDefaultAction(Creature* actor) const;
-
-        /** Trigger an action of this game object
-         *  @param actionName the action's name
-         *  @param actor the &quot;user&quot; of this game object, can be &lt;code&gt;NULL&lt;/code&gt; sein, 
-                   if the action wasn't triggered by someone (e.g. by time)
-         *  @param target the action's target (can be &lt;code&gt;NULL&lt;/code&gt; if no other game objects are involved)
-         */
-        void doAction(const CeGuiString actionName,
-                      Creature* actor,
-                      GameObject* target);
-
-        void doAction(const CeGuiString actionName);
-
-        void doAction(Action* action,
-                      Creature* actor,
-                      GameObject* target);
-                      
-        bool activateAction(Action* action,
-                      Creature* actor,
-                      GameObject* target);
-
-        void doDefaultAction(Creature* actor, GameObject* target);
-
-        void setPosition(const Ogre::Vector3&amp; position);
-        void setOrientation(const Ogre::Quaternion&amp; orientation);
-        const Ogre::Quaternion&amp; getOrientation() const;
-        const Ogre::Vector3&amp; getPosition() const;
-        Ogre::AxisAlignedBox getWorldBoundingBox() const;
-
-        /// Soll der Aktor &#252;berhaupt leuchten?
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-
-        void setHighlighted(bool highlight);
-        bool isHighlighted() const;
-
-        virtual const Property getProperty(const CeGuiString&amp; key) const;
-        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-        GameObjectState getState() const;
-        virtual void setState(GameObjectState state);
-        void placeIntoScene();
-        void removeFromScene();
-
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-
-        /**
-         * Lets an effect affect the game object
-         * @param effect the effect
-         * @ingroup CreatureRubyExports
-         **/
-        void addEffect(Effect* effect);
-        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
-        void removeEffect(Effect* effect);
-
-        /**
-         * Returns a printable list of all effects
-         */
-        CeGuiString getEffects();
-
-        /**
-         * Checks all effects for end-of-life
-         **/
-        void _checkEffects();
-
-    protected:
-        int mId;
-        GameObjectState mState;
-        
-        CeGuiString mName;
-        CeGuiString mDescription;
-        CeGuiString mMeshfile;
-		MeshPartMap mMeshParts;
-        CeGuiString mSubmeshPreName;
-        CeGuiString mClassId;
-        
-        Actor* mActor;
-        
-        /// Query flags to be set to the actor, when placed into scene.
-        unsigned long mQueryFlags;
-
-        /// Shall the game object be selectable
-        bool mHighlightingEnabled;
-
-        /// Manages the effects affecting this game object
-        EffectManager* mEffectManager;
-
-        Actor* createActor();
-        void destroyActor();
-
-        virtual void doPlaceIntoScene();
-        virtual void doRemoveFromScene();
-        CeGuiString mScene;
-
-    private:
-        static int sNextGameObjectId;    
-
-        ActionOptionVector mActions;
-        Ogre::Vector3 mPosition;
-        Ogre::Quaternion mOrientation;
-        Ogre::Real mMass;
-        CeGuiString mDefaultAction;
-        GeometryType mGeometryType;
-
-        ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
-            ActionOptionVector::iterator end, const CeGuiString actionName);
-        ActionOptionVector::iterator findAction(ActionOptionVector::iterator
-            begin, ActionOptionVector::iterator end, const Action* action);    
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __GAMEOBJECT_H__
+#define __GAMEOBJECT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Action.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;RulesConstants.h&quot;
+#include &quot;ObjectStateChangeEventSource.h&quot;
+#include &quot;Properties.h&quot;
+#include &quot;CoreDefines.h&quot;
+
+namespace rl
+{
+    class Creature;
+    class Effect;
+    class EffectManager;
+
+    /**
+    * \brief Base class for all game relevant objects in RL
+    * Provides methods for identification of objects within the world
+    * Abstract concepts do not inherit this class
+    */
+    class _RlRulesExport GameObject 
+        : public ActorNotifiedObject, 
+          public ObjectStateChangeEventSource,
+          public PropertyHolder
+    {
+    public:
+        typedef std::vector&lt;std::pair&lt;Action*, int&gt; &gt; ActionOptionVector;
+        static const unsigned int NO_OBJECT_ID = 0;
+        
+        static const Ogre::String CLASS_NAME;
+
+        static const Ogre::String PROPERTY_CLASS_ID;
+        static const Ogre::String PROPERTY_OBJECT_ID;
+        static const Ogre::String PROPERTY_INHERITS;
+        static const Ogre::String PROPERTY_BASE_CLASS;
+        static const Ogre::String PROPERTY_SCENE; 
+        static const Ogre::String PROPERTY_POSITION; 
+        static const Ogre::String PROPERTY_ORIENTATION; 
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_DESCRIPTION; 
+        static const Ogre::String PROPERTY_MESHFILE; 
+  		static const Ogre::String PROPERTY_MESHPARTS;
+        static const Ogre::String PROPERTY_SUBMESHPRENAME;
+		static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
+        static const Ogre::String PROPERTY_MASS; 
+        static const Ogre::String PROPERTY_ACTIONS; 
+        static const Ogre::String PROPERTY_DEFAULT_ACTION;
+
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        int getId() const;
+
+        const CeGuiString&amp; getClassId() const;
+        void setClassId(const CeGuiString&amp; classId);
+        
+        const CeGuiString&amp; getName() const;
+        void setName(const CeGuiString&amp; name);
+
+        const CeGuiString&amp; getDescription() const;
+        void setDescription(const CeGuiString&amp; description);
+
+        const CeGuiString&amp; getMeshfile() const;
+        void setMeshfile(const CeGuiString&amp; meshfile);
+
+        const CeGuiString&amp; getSubmeshPreName() const;
+        void setSubmeshPreName(const CeGuiString&amp; name);
+
+		const MeshPartMap&amp; getMeshParts() const;
+
+        const GeometryType getGeometryType() const;
+        void setGeometryType(GeometryType type);
+
+        const Ogre::Real getMass() const;
+        void setMass(const Ogre::Real mass);
+
+        void addAction(Action* action, int option = Action::ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
+        void removeAction(Action* action);
+
+        void setScene(const CeGuiString&amp; scene);
+        const CeGuiString&amp; getScene() const;
+    
+        /*
+         * sets the actor of this gameobject
+         * @warning if the GameObject is destroyed or the State of the GameObject changed or this function
+         * is called with another actor, the actor will be deleted!
+         */
+        void setActor(Actor* actor);
+        Actor* getActor();
+        
+        /**
+         * Check whether a creature can perform an action on this game object
+         *
+         * @return a boolean
+         */
+        bool hasAction(const CeGuiString&amp; actionName, Creature* actor) const;
+
+        /**
+         * Get all valid actions a character can perfom on this game object
+         * 
+         * @param actor the character
+         * @return a vector of actions
+         */
+        const ActionVector getValidActions(Creature* actor) const;
+        virtual Action* getDefaultAction(Creature* actor) const;
+
+        /** Trigger an action of this game object
+         *  @param actionName the action's name
+         *  @param actor the &quot;user&quot; of this game object, can be &lt;code&gt;NULL&lt;/code&gt; sein, 
+                   if the action wasn't triggered by someone (e.g. by time)
+         *  @param target the action's target (can be &lt;code&gt;NULL&lt;/code&gt; if no other game objects are involved)
+         */
+        void doAction(const CeGuiString&amp; actionName,
+                      Creature* actor,
+                      GameObject* target);
+
+        void doAction(const CeGuiString&amp; actionName);
+
+        void doAction(Action* action,
+                      Creature* actor,
+                      GameObject* target);
+                      
+        bool activateAction(Action* action,
+                      Creature* actor,
+                      GameObject* target);
+
+        void doDefaultAction(Creature* actor, GameObject* target);
+
+        void setPosition(const Ogre::Vector3&amp; position);
+        void setOrientation(const Ogre::Quaternion&amp; orientation);
+        const Ogre::Quaternion&amp; getOrientation() const;
+        const Ogre::Vector3&amp; getPosition() const;
+        Ogre::AxisAlignedBox getWorldBoundingBox() const;
+
+        /// Soll der Aktor &#194;&#184;berhaupt leuchten?
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+
+        void setHighlighted(bool highlight);
+        bool isHighlighted() const;
+
+        virtual const Property getProperty(const CeGuiString&amp; key) const;
+        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+        GameObjectState getState() const;
+        virtual void setState(GameObjectState state);
+        void placeIntoScene();
+        void removeFromScene();
+
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+
+        /**
+         * Lets an effect affect the game object
+         * @param effect the effect
+         * @ingroup CreatureRubyExports
+         **/
+        void addEffect(Effect* effect);
+        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
+        void removeEffect(Effect* effect);
+
+        /**
+         * Returns a printable list of all effects
+         */
+        CeGuiString getEffects();
+
+        /**
+         * Checks all effects for end-of-life
+         **/
+        void _checkEffects();
+
+    protected:
+        int mId;
+        GameObjectState mState;
+        
+        CeGuiString mName;
+        CeGuiString mDescription;
+        CeGuiString mMeshfile;
+		MeshPartMap mMeshParts;
+        CeGuiString mSubmeshPreName;
+        CeGuiString mClassId;
+        
+        Actor* mActor;
+        
+        /// Query flags to be set to the actor, when placed into scene.
+        unsigned long mQueryFlags;
+
+        /// Shall the game object be selectable
+        bool mHighlightingEnabled;
+
+        /// Manages the effects affecting this game object
+        EffectManager* mEffectManager;
+
+        Actor* createActor();
+        void destroyActor();
+
+        virtual void doPlaceIntoScene();
+        virtual void doRemoveFromScene();
+        CeGuiString mScene;
+
+    private:
+        static int sNextGameObjectId;    
+
+        ActionOptionVector mActions;
+        Ogre::Vector3 mPosition;
+        Ogre::Quaternion mOrientation;
+        Ogre::Real mMass;
+        CeGuiString mDefaultAction;
+        GeometryType mGeometryType;
+
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
+            ActionOptionVector::iterator end, const CeGuiString actionName);
+        ActionOptionVector::const_iterator findAction(ActionOptionVector::const_iterator begin,
+            ActionOptionVector::const_iterator end, const CeGuiString actionName) const;
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator
+            begin, ActionOptionVector::iterator end, const Action* action);    
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/GoToJob.h
===================================================================
--- rl/trunk/engine/rules/include/GoToJob.h	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/include/GoToJob.h	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,50 +1,50 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __RL_GOTO_JOB_H__
-#define __RL_GOTO_JOB_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;Job.h&quot;
-
-namespace rl
-{
-    class MeshAnimation;
-
-    /// A rl#Job to play an animation.
-    class _RlRulesExport GoToJob : public Job
-    {
-    public:
-
-		GoToJob(Creature* actor, const Ogre::Vector3&amp; targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		GoToJob(Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-        virtual ~GoToJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-		CreatureController* mActor;
-		GameObject* mTarget;
-		Ogre::Vector3 mTargetPos;
-		Ogre::Real mMaxDistance;
-		Ogre::Real mTimeLeft;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RL_GOTO_JOB_H__
+#define __RL_GOTO_JOB_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+#include &quot;Job.h&quot;
+
+namespace rl
+{
+    class Creature;
+    class CreatureController;
+    class GameObject;
+    
+    /// A rl#Job to let a creature go to a target position
+    class _RlRulesExport GoToJob : public Job
+    {
+    public:
+
+		GoToJob(Creature* actor, const Ogre::Vector3&amp; targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		GoToJob(Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+        virtual ~GoToJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+		CreatureController* mActor;
+		GameObject* mTarget;
+		Ogre::Vector3 mTargetPos;
+		Ogre::Real mMaxDistance;
+		Ogre::Real mTimeLeft;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,835 +1,880 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;GameObject.h&quot;
-#include &lt;CEGUIPropertyHelper.h&gt;
-
-#include &quot;Action.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;EffectManager.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;ObjectStateChangeEventSource.h&quot;
-#include &quot;Property.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;PhysicsManager.h&quot;
-
-
-using namespace std;
-
-namespace rl
-{
-    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = &quot;viewobject&quot;;
-    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = &quot;viewobjectdebug&quot;;
-
-    const Ogre::String GameObject::CLASS_NAME = &quot;GameObject&quot;;
-
-    const Ogre::String GameObject::PROPERTY_CLASS_ID = &quot;classid&quot;;
-    const Ogre::String GameObject::PROPERTY_OBJECT_ID = &quot;id&quot;;
-    const Ogre::String GameObject::PROPERTY_BASE_CLASS = &quot;baseclass&quot;;
-    const Ogre::String GameObject::PROPERTY_POSITION = &quot;position&quot;;
-    const Ogre::String GameObject::PROPERTY_SCENE = &quot;scene&quot;;
-    const Ogre::String GameObject::PROPERTY_INHERITS = &quot;inherits&quot;;
-    const Ogre::String GameObject::PROPERTY_ORIENTATION = &quot;orientation&quot;;
-    const Ogre::String GameObject::PROPERTY_NAME = &quot;name&quot;;
-    const Ogre::String GameObject::PROPERTY_DESCRIPTION = &quot;description&quot;;
-    const Ogre::String GameObject::PROPERTY_MESHFILE = &quot;meshfile&quot;;
-	const Ogre::String GameObject::PROPERTY_MESHPARTS = &quot;meshparts&quot;;
-    const Ogre::String GameObject::PROPERTY_SUBMESHPRENAME = &quot;submeshprename&quot;;
-    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = &quot;geometrytype&quot;;
-    const Ogre::String GameObject::PROPERTY_MASS = &quot;mass&quot;;
-    const Ogre::String GameObject::PROPERTY_ACTIONS = &quot;actions&quot;;
-    const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = &quot;defaultaction&quot;;
-
-    GameObject::GameObject(unsigned int id)
-        :   mId(id),
-            mName(&quot;&quot;),
-            mDescription(&quot;&quot;),
-            mMeshfile(&quot;&quot;),
-			mMeshParts(),
-            mQueryFlags(QUERYFLAG_GAMEOBJECT),
-            mHighlightingEnabled(true),
-            mActor(NULL),
-            mActions(),
-            mPosition(Ogre::Vector3::ZERO),
-            mOrientation(Ogre::Quaternion::IDENTITY),
-            mMass(0),
-            mGeometryType(GT_NONE),
-            mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
-            mState(GOS_LOADED),
-            mScene(&quot;&quot;)
-    {
-        mEffectManager = new EffectManager(this);
-
-        // Standardactions registrieren
-        Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
-        if (defaultAction != NULL)
-        {
-            addAction(defaultAction);
-        }
-
-        // If game in developer mode, show GameObject debug window
-        // in the radial menu
-        //if( CoreSubsystem::getSingleton().getDeveloperMode() )
-        //{
-            defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
-            if (defaultAction != NULL)
-            {
-                addAction(defaultAction);
-            }
-        //}
-
-        // Eventsource erzeugen
-        setObject(this);
-    }
-
-    GameObject::~GameObject(void)
-    {
-        destroyActor();
-    	delete mEffectManager;
-    }
-
-    int GameObject::getId() const
-    {
-        return mId;
-    }
-
-    const CeGuiString&amp; GameObject::getClassId() const
-    {
-        return mClassId;
-    }
-
-    void GameObject::setClassId(const CeGuiString&amp; classId)
-    {
-        mClassId = classId;
-    }
-
-    const CeGuiString&amp; GameObject::getName() const
-    {
-        return mName;
-    }
-
-    void GameObject::setName(const CeGuiString&amp; name)
-    {
-        mName = name;
-    }
-
-    const CeGuiString&amp; GameObject::getDescription() const
-    {
-        return mDescription;
-    }
-
-    void GameObject::setDescription(const CeGuiString&amp; description)
-    {
-        mDescription = description;
-    }
-
-    const CeGuiString&amp; GameObject::getMeshfile() const
-    {
-        return mMeshfile;
-    }
-
-    void GameObject::setMeshfile(const CeGuiString&amp; meshfile)
-    {
-        mMeshfile = meshfile;
-    }
-
-	const MeshPartMap&amp; GameObject::getMeshParts() const
-	{
-		return mMeshParts;
-	}
-
-    const CeGuiString&amp; GameObject::getSubmeshPreName() const
-    {
-        return mSubmeshPreName;
-    }
-
-    void GameObject::setSubmeshPreName(const CeGuiString&amp; name)
-    {
-        mSubmeshPreName = name;
-    }
-
-    const CeGuiString&amp; GameObject::getScene() const
-    {
-        return mScene;
-    }
-
-    void GameObject::setScene(const CeGuiString&amp; scene)
-    {
-        mScene = scene;
-    }
-
-    void GameObject::addAction(Action* action, int option)
-    {
-        if (action == NULL)
-        {
-            Throw(NullPointerException, &quot;Parameter action ist NULL.&quot;);
-        }
-
-        mActions.push_back(make_pair(action, option));
-        LOG_MESSAGE(Logger::RULES,
-            &quot;Bei GameObject #&quot;+CEGUI::PropertyHelper::intToString(mId)+
-            &quot; (&quot;+getName()+&quot;) wurde Aktion &quot;+action-&gt;getName().c_str()+&quot; hinzugefuegt.&quot;);
-    }
-
-    void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
-    {
-        addAction(action, option);
-        action-&gt;setGroup(group);
-    }
-
-    void GameObject::removeAction(Action* action)
-    {
-        ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
-        if (it != mActions.end())
-        {
-            mActions.erase(it);
-        }
-    }
-
-    const ActionVector GameObject::getValidActions(Creature* actor) const
-    {
-        ActionVector actions;
-        for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
-        {
-            LOG_MESSAGE(Logger::RULES, &quot;Untersuche Aktion &quot;+(*it).first-&gt;getName());
-            if ((*it).second == Action::ACT_DISABLED)
-                continue;
-            //if ((*it).second &gt; ACT_NEEDS_TALENT)
-            if (actor != NULL &amp;&amp; !(*it).first-&gt;canDo(const_cast&lt;GameObject*&gt;(this), actor)) // Aktion nicht m&#239;&#191;&#189;glich
-                continue;
-
-            actions.push_back((*it).first);
-        }
-        return actions;
-    }
-
-    void GameObject::doAction( const CeGuiString actionName,
-                              Creature* actor,
-                              GameObject* target)
-    {
-        ActionOptionVector::const_iterator it =
-            findAction(mActions.begin(), mActions.end(), actionName);
-
-        if (it == mActions.end())
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                &quot;'&quot; + actionName + &quot;' ist eine dem Objekt unbekannte Aktion.&quot;);
-        }
-        else
-        {
-            doAction((*it).first, actor, target);
-        }
-    }
-
-    void GameObject::doAction(const CeGuiString actionName)
-    {
-        doAction(actionName, NULL, NULL);
-    }
-
-    void GameObject::doAction(Action* action,
-                              Creature* actor,
-                              GameObject* target)
-    {
-        action-&gt;doAction(this, actor, target);
-    }
-
-    void GameObject::doDefaultAction(Creature* actor, GameObject* target)
-    {
-        Action* action = getDefaultAction(actor);
-        if (action != NULL)
-        {
-            doAction(action, actor, target);
-        }
-        else
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                &quot;GameObject &quot; + getName() + &quot; has no valid default action set.&quot;);
-        }
-    }
-
-    bool GameObject::activateAction(Action* action,
-                      Creature* actor,
-                      GameObject* target)
-    {
-        doAction(action, actor, target);
-        return true;
-    }
-
-    GameObject::ActionOptionVector::iterator
-        GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin,
-            GameObject::ActionOptionVector::iterator end,
-            const CeGuiString actionName)
-    {
-        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-        {
-            Action* action = (*iter).first;
-
-            if (action-&gt;getName().compare(actionName) == 0)
-                return iter;
-        }
-        return end;
-    }
-
-    GameObject::ActionOptionVector::iterator
-        GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin,
-            GameObject::ActionOptionVector::iterator end,
-            const Action* action)
-    {
-        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-            if ((*iter).first == action)
-                return iter;
-
-        return end;
-    }
-
-    void GameObject::setActor(Actor* actor)
-    {
-        if (mActor != actor)
-        {
-            if (mActor != NULL)
-            {
-                mActor-&gt;setGameObject(NULL);
-                mActor-&gt;setQueryFlags(0);
-            }
-
-            if (actor != NULL)
-            {                
-                actor-&gt;setGameObject(this);
-                if (actor-&gt;isInScene())
-                {
-                    actor-&gt;setPosition(mPosition);
-                    actor-&gt;setOrientation(mOrientation);                    
-                }
-            }
-
-            mActor = actor;
-        }
-
-        if (mActor &amp;&amp; mActor-&gt;isInScene())
-        {
-            mActor-&gt;setQueryFlags(mQueryFlags);
-        }
-    }
-
-    Actor* GameObject::getActor()
-    {
-        return mActor;
-    }
-
-    bool GameObject::isHighlightingEnabled()
-    {
-        return mHighlightingEnabled;
-    }
-
-    void GameObject::setHighlightingEnabled( bool highlightenabled )
-    {
-        // Leuchtet zur Zeit, sollte aber nicht leuchten
-        if( mActor != NULL &amp;&amp; !highlightenabled &amp;&amp; mActor-&gt;isHighlighted() )
-        {
-            mActor-&gt;setHighlighted( false );
-        }
-
-        mHighlightingEnabled = highlightenabled;
-    }
-
-    Action* GameObject::getDefaultAction(Creature* actor) const
-    {
-        return ActionManager::getSingleton().getAction(mDefaultAction);
-    }
-
-    void GameObject::setHighlighted(bool highlight)
-    {
-        if (mHighlightingEnabled &amp;&amp; mActor != NULL)
-        {
-            mActor-&gt;setHighlighted(highlight, getName());
-        }
-    }
-
-    bool GameObject::isHighlighted() const
-    {
-        return mActor != NULL &amp;&amp; mActor-&gt;isHighlighted();
-    }
-
-    void GameObject::setPosition(const Ogre::Vector3&amp; position)
-    {
-        if (mActor != NULL)
-        {
-            mActor-&gt;setPosition(position);
-        }
-        else
-        {
-            mPosition = position;
-        }
-    }
-
-    const Ogre::Vector3&amp; GameObject::getPosition() const
-    {
-        if (mActor != NULL)
-        {
-            return mActor-&gt;getPosition();
-        }
-        return mPosition;
-    }
-
-	Ogre::AxisAlignedBox GameObject::getWorldBoundingBox() const
-	{
-        if (mActor != NULL)
-        {
-            return mActor-&gt;getWorldBoundingBox();
-        }
-        return Ogre::AxisAlignedBox();
-	}
-
-    void GameObject::setOrientation(const Ogre::Quaternion&amp; orientation)
-    {
-        if (mActor != NULL)
-        {
-            mActor-&gt;setOrientation(orientation);
-        }
-        else
-        {
-            mOrientation = orientation;
-        }
-    }
-
-    const Ogre::Quaternion&amp; GameObject::getOrientation() const
-    {
-        if (mActor != NULL)
-        {
-            return mActor-&gt;getOrientation();
-        }
-        return mOrientation;
-    }
-
-    const GeometryType GameObject::getGeometryType() const
-    {
-        return mGeometryType;
-    }
-
-    void GameObject::setGeometryType(GeometryType type)
-    {
-        mGeometryType = type;
-    }
-
-    const Ogre::Real GameObject::getMass() const
-    {
-        return mMass;
-    }
-
-    void GameObject::setMass(const Ogre::Real mass)
-    {
-        mMass = mass;
-    }
-
-    void GameObject::addEffect(Effect* effect)
-	{
-		mEffectManager-&gt;addEffect(effect);
-	}
-
-    void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
-    {
-      addEffect(effect);
-      mEffectManager-&gt;addTimeCheck(time, effect);
-    }
-
-    void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
-    {
-      addEffect(effect);
-      mEffectManager-&gt;addDateCheck(date, effect);
-    }
-
-	void GameObject::_checkEffects()
-	{
-		/// @todo Nur einmal pro Aktion ausfuehren
-		mEffectManager-&gt;checkEffects();
-	}
-
-    void GameObject::removeEffect(Effect* effect)
-	{
-		mEffectManager-&gt;removeEffect(effect);
-	}
-
-    CeGuiString GameObject::getEffects()
-    {
-        return mEffectManager-&gt;getEffects();
-    }
-
-    const Property GameObject::getProperty(const CeGuiString&amp; key) const
-    {
-        Property prop;
-        if (key == PROPERTY_POSITION)
-        {
-            prop.setValue(getPosition());
-        }
-        else if (key == PROPERTY_ORIENTATION)
-        {
-            prop.setValue(getOrientation());
-        }
-        else if (key == PROPERTY_NAME)
-        {
-            prop.setValue(mName);
-        }
-        else if (key == PROPERTY_DESCRIPTION)
-        {
-            prop.setValue(mDescription);
-        }
-        else if (key == PROPERTY_MESHFILE)
-        {
-            prop.setValue(mMeshfile);
-        }
-        else if (key == PROPERTY_GEOMETRY_TYPE)
-        {
-            prop.setValue(PhysicsManager::convertGeometryTypeToString(mGeometryType));
-        }
-        else if (key == PROPERTY_MASS)
-        {
-            prop.setValue(mMass);
-        }
-		else if (key == PROPERTY_MESHPARTS)
-		{
-			PropertyMap map;
-			for (MeshPartMap::const_iterator
-					it = mMeshParts.begin(); it != mMeshParts.end(); ++it)
-			{
-				map[(*it).first] = Property((*it).second);
-			}
-			prop.setValue(map);
-		}
-        else if (key == PROPERTY_SUBMESHPRENAME)
-        {
-            prop.setValue(mSubmeshPreName);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, key + &quot; is not a property of this gameobject (&quot;+mName.c_str()+&quot;)&quot;);
-        }
-
-        return prop;
-    }
-
-    void GameObject::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        try
-        {
-            if (key == PROPERTY_POSITION)
-            {
-                setPosition(value.toVector3());
-            }
-            else if (key == PROPERTY_ORIENTATION)
-            {
-                setOrientation(value.toQuaternion());
-            }
-            else if (key == PROPERTY_NAME)
-            {
-                setName(value.toString());
-            }
-            else if (key == PROPERTY_DESCRIPTION)
-            {
-                setDescription(value.toString());
-            }
-            else if (key == PROPERTY_MESHFILE)
-            {
-                setMeshfile(value.toString());
-            }
-            else if (key == PROPERTY_MESHPARTS)
-            {
-				PropertyMap map = value.toMap();
-				for (PropertyMap::const_iterator
-					it = map.begin(); it != map.end(); ++it)
-				{
-					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
-				}
-            }
-            else if (key == PROPERTY_GEOMETRY_TYPE)
-            {
-                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));
-            }
-            else if (key == PROPERTY_MASS)
-            {
-                Ogre::Real mass = 0.0;
-                if (value.isInt())
-                {
-                    mass = value.toInt();
-                }
-                else if (value.isReal())
-                {
-                    mass = value.toReal();
-                }
-                setMass(mass);
-            }
-            else if (key == PROPERTY_ACTIONS)
-            {
-                PropertyArray vecVal = value.toArray();
-                for (PropertyArray::const_iterator it = vecVal.begin(); it != vecVal.end(); it++)
-                {
-                    Ogre::String actionName = (*it).toString().c_str();
-                    Action* act = ActionManager::getSingleton().getAction(actionName);
-
-                    if (act != NULL)
-                    {
-                        addAction(act);
-                    }
-                    else
-                    {
-                        LOG_ERROR(Logger::RULES, &quot;'&quot;+actionName+&quot;' not registered at ActionManager.&quot;);
-                    }
-                }
-            }
-            else if (key == PROPERTY_DEFAULT_ACTION)
-            {
-                mDefaultAction = value.toString().c_str();
-            }
-            else if (key == PROPERTY_SUBMESHPRENAME)
-            {
-                mSubmeshPreName = value.toString();
-            }
-            else
-            {
-                if( key != PROPERTY_BASE_CLASS &amp;&amp; key != PROPERTY_CLASS_ID &amp;&amp; key != PROPERTY_INHERITS)
-                    // these two keys can be ignored, they are only given to the GameObjectFactory when creating a GOF
-                {
-                    LOG_WARNING(Logger::RULES,
-						key + &quot; is not a property of this GameObject (&quot;+mName+&quot;)&quot;);
-                }
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                &quot;property &quot; + key + &quot; has the wrong format&quot;);
-        }
-    }
-
-    PropertyKeys GameObject::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(PROPERTY_NAME);
-        keys.insert(PROPERTY_DESCRIPTION);
-        if(mState == GOS_IN_SCENE)
-        {
-            keys.insert(PROPERTY_POSITION);
-            keys.insert(PROPERTY_ORIENTATION); 
-        }
-        keys.insert(PROPERTY_MESHFILE);
-        keys.insert(PROPERTY_MESHPARTS);
-        keys.insert(PROPERTY_GEOMETRY_TYPE);
-        keys.insert(PROPERTY_MASS);
-        return keys;
-    }
-
-    Actor* GameObject::createActor()
-    {
-        if (!mActor)
-        {
-            Ogre::String actorName = Ogre::StringConverter::toString(mId);
-			Actor* actor = NULL;
-
-			if (mMeshfile.empty() &amp;&amp; mMeshParts.empty())
-			{
-				LOG_ERROR(
-					Logger::RULES,
-					&quot;Neither mesh file nor mesh parts are set on gameobject '&quot; + getName()
-					+ &quot;' (id: &quot; + getId() + &quot;). Can't create actor!&quot;);
-			}
-			else if (!mMeshParts.empty())
-			{
-				actor = ActorManager::getSingleton().createMeshActor(
-						actorName,
-						mMeshfile.c_str(),
-						mMeshParts,
-						mGeometryType,
-						mMass);
-			}
-			else
-			{
-				actor = ActorManager::getSingleton().createMeshActor(
-						actorName,
-						mMeshfile.c_str(),
-						mGeometryType,
-						mMass);
-			}
-
-			if (actor == NULL)
-			{
-				LOG_ERROR(
-					Logger::RULES,
-					&quot;Error creating actor '&quot;
-					+ actorName	+ &quot;'.&quot;);
-			}
-
-            setActor(actor);
-        }
-
-        return mActor;
-    }
-
-    void GameObject::destroyActor()
-    {
-        if (mActor != NULL)
-        {
-			Actor* actor = mActor;
-			setActor(NULL);
-            ActorManager::getSingleton().destroyActor(actor);
-		}
-    }
-
-    void GameObject::placeIntoScene()
-    {
-        setState(GOS_IN_SCENE);
-    }
-
-    void GameObject::removeFromScene()
-    {
-        setState(GOS_LOADED);
-    }
-
-    void GameObject::doPlaceIntoScene()
-    {
-        if (mState != GOS_IN_SCENE)
-        {
-            Actor* actor = createActor();
-
-            if (actor != NULL)
-            {
-                actor-&gt;placeIntoScene(mPosition, mOrientation);
-                setActor(actor);
-                mScene = CoreSubsystem::getSingleton().getCurrentScene();
-
-                // this is done in setstate now
-                //GameObjectState tmpState = mState;
-                //mState = GOS_IN_SCENE;
-                //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
-                //onStateChange(tmpState, GOS_IN_SCENE);
-            }
-            else {
-                LOG_ERROR(
-                    Logger::RULES,
-                    &quot;Error placing gameobject '&quot;
-                    + Ogre::StringConverter::toString(mId)
-                    + &quot;' into scene &quot;
-                    + mMeshfile);
-            }
-        }
-    }
-
-    void GameObject::doRemoveFromScene()
-    {
-        if (mState == GOS_IN_SCENE)
-        {
-            Actor* actor = mActor;
-            if (actor)
-            {
-                //mOrientation = actor-&gt;getWorldOrientation(); //Why world orientation?
-                //mPosition = actor-&gt;getWorldPosition(); //Why world position?
-
-                mOrientation = actor-&gt;getOrientation();
-                mPosition = actor-&gt;getPosition();
-
-                setActor(NULL);
-                actor-&gt;removeFromScene();
-                mScene = &quot;&quot;;
-            }
-
-            // give the setstate function the possibility to reuse the actor
-            //ActorManager::getSingleton().destroyActor(actor);
-
-            // this is done in setstate now
-            //GameObjectState tmpState = mState;
-            //mState = GOS_LOADED;
-            //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
-        }
-    }
-
-    void GameObject::setState(GameObjectState targetstate)
-    {
-        if (targetstate == mState)
-        {
-            return;
-        }
-
-        GameObjectState oldState = mState;
-        onBeforeStateChange(oldState, targetstate);
-
-        if (targetstate == GOS_LOADED &amp;&amp; mState == GOS_IN_SCENE)
-        {
-            doRemoveFromScene();
-            destroyActor();
-        }
-        else if (targetstate == GOS_IN_SCENE &amp;&amp; mState == GOS_LOADED)
-        {
-            doPlaceIntoScene();
-        }
-        else
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                &quot;GameObject '&quot; + getName()
-                + &quot;' could not change state from &quot;
-                + Ogre::StringConverter::toString(mState) + &quot; to &quot;
-                + Ogre::StringConverter::toString(targetstate));
-            return;
-        }
-
-        mState = targetstate;
-        onAfterStateChange(oldState, targetstate);
-        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetstate);
-    }
-
-    void GameObject::onBeforeStateChange(GameObjectState oldState, GameObjectState newState)
-    {
-    }
-
-    void GameObject::onAfterStateChange(GameObjectState oldState, GameObjectState newState)
-    {
-    }
-
-    GameObjectState GameObject::getState() const
-    {
-        return mState;
-    }
-
-    unsigned long GameObject::getQueryFlags() const
-    {
-        return mQueryFlags;
-    }
-
-    void GameObject::addQueryFlag(unsigned long queryflag)
-    {
-        mQueryFlags |= queryflag;
-
-        setQueryFlags(mQueryFlags);
-    }
-
-    void GameObject::setQueryFlags(unsigned long queryflags)
-    {
-        mQueryFlags = queryflags;
-
-        if(mActor != NULL)
-        {
-            mActor-&gt;setQueryFlags(mQueryFlags);
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;GameObject.h&quot;
+#include &lt;CEGUIPropertyHelper.h&gt;
+
+#include &quot;Action.h&quot;
+#include &quot;ActionManager.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;EffectManager.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;ObjectStateChangeEventSource.h&quot;
+#include &quot;Property.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;PhysicsManager.h&quot;
+
+
+using namespace std;
+
+namespace rl
+{
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = &quot;viewobject&quot;;
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = &quot;viewobjectdebug&quot;;
+
+    const Ogre::String GameObject::CLASS_NAME = &quot;GameObject&quot;;
+
+    const Ogre::String GameObject::PROPERTY_CLASS_ID = &quot;classid&quot;;
+    const Ogre::String GameObject::PROPERTY_OBJECT_ID = &quot;id&quot;;
+    const Ogre::String GameObject::PROPERTY_BASE_CLASS = &quot;baseclass&quot;;
+    const Ogre::String GameObject::PROPERTY_POSITION = &quot;position&quot;;
+    const Ogre::String GameObject::PROPERTY_SCENE = &quot;scene&quot;;
+    const Ogre::String GameObject::PROPERTY_INHERITS = &quot;inherits&quot;;
+    const Ogre::String GameObject::PROPERTY_ORIENTATION = &quot;orientation&quot;;
+    const Ogre::String GameObject::PROPERTY_NAME = &quot;name&quot;;
+    const Ogre::String GameObject::PROPERTY_DESCRIPTION = &quot;description&quot;;
+    const Ogre::String GameObject::PROPERTY_MESHFILE = &quot;meshfile&quot;;
+	const Ogre::String GameObject::PROPERTY_MESHPARTS = &quot;meshparts&quot;;
+    const Ogre::String GameObject::PROPERTY_SUBMESHPRENAME = &quot;submeshprename&quot;;
+    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = &quot;geometrytype&quot;;
+    const Ogre::String GameObject::PROPERTY_MASS = &quot;mass&quot;;
+    const Ogre::String GameObject::PROPERTY_ACTIONS = &quot;actions&quot;;
+    const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = &quot;defaultaction&quot;;
+
+    GameObject::GameObject(unsigned int id)
+        :   mId(id),
+            mName(&quot;&quot;),
+            mDescription(&quot;&quot;),
+            mMeshfile(&quot;&quot;),
+			mMeshParts(),
+            mQueryFlags(QUERYFLAG_GAMEOBJECT),
+            mHighlightingEnabled(true),
+            mActor(NULL),
+            mActions(),
+            mPosition(Ogre::Vector3::ZERO),
+            mOrientation(Ogre::Quaternion::IDENTITY),
+            mMass(0),
+            mGeometryType(GT_NONE),
+            mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
+            mState(GOS_LOADED),
+            mScene(&quot;&quot;)
+    {
+        mEffectManager = new EffectManager(this);
+
+        // Standardactions registrieren
+        Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
+        if (defaultAction != NULL)
+        {
+            addAction(defaultAction);
+        }
+
+        // If game in developer mode, show GameObject debug window
+        // in the radial menu
+        //if( CoreSubsystem::getSingleton().getDeveloperMode() )
+        //{
+            defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
+            if (defaultAction != NULL)
+            {
+                addAction(defaultAction);
+            }
+        //}
+
+        // Eventsource erzeugen
+        setObject(this);
+    }
+
+    GameObject::~GameObject(void)
+    {
+        destroyActor();
+    	delete mEffectManager;
+    }
+
+    int GameObject::getId() const
+    {
+        return mId;
+    }
+
+    const CeGuiString&amp; GameObject::getClassId() const
+    {
+        return mClassId;
+    }
+
+    void GameObject::setClassId(const CeGuiString&amp; classId)
+    {
+        mClassId = classId;
+    }
+
+    const CeGuiString&amp; GameObject::getName() const
+    {
+        return mName;
+    }
+
+    void GameObject::setName(const CeGuiString&amp; name)
+    {
+        mName = name;
+    }
+
+    const CeGuiString&amp; GameObject::getDescription() const
+    {
+        return mDescription;
+    }
+
+    void GameObject::setDescription(const CeGuiString&amp; description)
+    {
+        mDescription = description;
+    }
+
+    const CeGuiString&amp; GameObject::getMeshfile() const
+    {
+        return mMeshfile;
+    }
+
+    void GameObject::setMeshfile(const CeGuiString&amp; meshfile)
+    {
+        mMeshfile = meshfile;
+    }
+
+	const MeshPartMap&amp; GameObject::getMeshParts() const
+	{
+		return mMeshParts;
+	}
+
+    const CeGuiString&amp; GameObject::getSubmeshPreName() const
+    {
+        return mSubmeshPreName;
+    }
+
+    void GameObject::setSubmeshPreName(const CeGuiString&amp; name)
+    {
+        mSubmeshPreName = name;
+    }
+
+    const CeGuiString&amp; GameObject::getScene() const
+    {
+        return mScene;
+    }
+
+    void GameObject::setScene(const CeGuiString&amp; scene)
+    {
+        mScene = scene;
+    }
+
+    void GameObject::addAction(Action* action, int option)
+    {
+        if (action == NULL)
+        {
+            Throw(NullPointerException, &quot;Parameter action ist NULL.&quot;);
+        }
+
+        mActions.push_back(make_pair(action, option));
+        LOG_MESSAGE(Logger::RULES,
+            &quot;Bei GameObject #&quot;+CEGUI::PropertyHelper::intToString(mId)+
+            &quot; (&quot;+getName()+&quot;) wurde Aktion &quot;+action-&gt;getName().c_str()+&quot; hinzugefuegt.&quot;);
+    }
+
+    void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
+    {
+        addAction(action, option);
+        action-&gt;setGroup(group);
+    }
+
+    void GameObject::removeAction(Action* action)
+    {
+        ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
+        if (it != mActions.end())
+        {
+            mActions.erase(it);
+        }
+    }
+
+    const ActionVector GameObject::getValidActions(Creature* actor) const
+    {
+        ActionVector actions;
+        for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
+        {
+            LOG_DEBUG(Logger::RULES, &quot;Untersuche Aktion &quot;+(*it).first-&gt;getName());
+            if ((*it).second == Action::ACT_DISABLED)
+            {
+                continue;                
+            }
+            //if ((*it).second &gt; ACT_NEEDS_TALENT)
+            if (actor != NULL &amp;&amp; !(*it).first-&gt;canDo(const_cast&lt;GameObject*&gt;(this), actor)) // Aktion nicht m&#239;&#191;&#189;glich
+            {
+                continue;                
+            }
+            
+            actions.push_back((*it).first);
+        }
+        return actions;
+    }
+    
+    bool GameObject::hasAction(const CeGuiString&amp; actionName, Creature* actor) const
+    {
+        ActionOptionVector::const_iterator it =
+            findAction(mActions.begin(), mActions.end(), actionName);
+        
+        if (it == mActions.end())
+        {
+            return false;
+        }
+
+        LOG_DEBUG(Logger::RULES, &quot;Untersuche Aktion &quot;+(*it).first-&gt;getName());
+        if ((*it).second == Action::ACT_DISABLED)
+        {
+            return false;                
+        }
+        //if ((*it).second &gt; ACT_NEEDS_TALENT)
+        if (actor != NULL &amp;&amp; !(*it).first-&gt;canDo(const_cast&lt;GameObject*&gt;(this), actor)) // Aktion nicht m&#239;&#191;&#189;glich
+        {
+            return false;
+        }
+        
+        return true;
+    }
+    
+    
+    void GameObject::doAction( const CeGuiString&amp; actionName,
+                              Creature* actor,
+                              GameObject* target)
+    {
+        ActionOptionVector::iterator it =
+            findAction(mActions.begin(), mActions.end(), actionName);
+
+        if (it == mActions.end())
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;'&quot; + actionName + &quot;' ist eine dem Objekt unbekannte Aktion.&quot;);
+        }
+        else
+        {
+            doAction((*it).first, actor, target);
+        }
+    }
+
+    void GameObject::doAction(const CeGuiString&amp; actionName)
+    {
+        doAction(actionName, NULL, NULL);
+    }
+
+    void GameObject::doAction(Action* action,
+                              Creature* actor,
+                              GameObject* target)
+    {
+        action-&gt;doAction(this, actor, target);
+    }
+
+    void GameObject::doDefaultAction(Creature* actor, GameObject* target)
+    {
+        Action* action = getDefaultAction(actor);
+        if (action != NULL)
+        {
+            doAction(action, actor, target);
+        }
+        else
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;GameObject &quot; + getName() + &quot; has no valid default action set.&quot;);
+        }
+    }
+
+    bool GameObject::activateAction(Action* action,
+                      Creature* actor,
+                      GameObject* target)
+    {
+        doAction(action, actor, target);
+        return true;
+    }
+
+    GameObject::ActionOptionVector::iterator
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
+            const CeGuiString actionName)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
+
+            if (action-&gt;getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
+
+    GameObject::ActionOptionVector::const_iterator
+    GameObject::findAction(
+                           GameObject::ActionOptionVector::const_iterator begin,
+                           GameObject::ActionOptionVector::const_iterator end,
+                           const CeGuiString actionName) const
+    {
+        for (ActionOptionVector::const_iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
+            
+            if (action-&gt;getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
+    
+    GameObject::ActionOptionVector::iterator
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
+            const Action* action)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+            if ((*iter).first == action)
+                return iter;
+
+        return end;
+    }
+
+    void GameObject::setActor(Actor* actor)
+    {
+        if (mActor != actor)
+        {
+            if (mActor != NULL)
+            {
+                mActor-&gt;setGameObject(NULL);
+                mActor-&gt;setQueryFlags(0);
+            }
+
+            if (actor != NULL)
+            {                
+                actor-&gt;setGameObject(this);
+                if (actor-&gt;isInScene())
+                {
+                    actor-&gt;setPosition(mPosition);
+                    actor-&gt;setOrientation(mOrientation);                    
+                }
+            }
+
+            mActor = actor;
+        }
+
+        if (mActor &amp;&amp; mActor-&gt;isInScene())
+        {
+            mActor-&gt;setQueryFlags(mQueryFlags);
+        }
+    }
+
+    Actor* GameObject::getActor()
+    {
+        return mActor;
+    }
+
+    bool GameObject::isHighlightingEnabled()
+    {
+        return mHighlightingEnabled;
+    }
+
+    void GameObject::setHighlightingEnabled( bool highlightenabled )
+    {
+        // Leuchtet zur Zeit, sollte aber nicht leuchten
+        if( mActor != NULL &amp;&amp; !highlightenabled &amp;&amp; mActor-&gt;isHighlighted() )
+        {
+            mActor-&gt;setHighlighted( false );
+        }
+
+        mHighlightingEnabled = highlightenabled;
+    }
+
+    Action* GameObject::getDefaultAction(Creature* actor) const
+    {
+        return ActionManager::getSingleton().getAction(mDefaultAction);
+    }
+
+    void GameObject::setHighlighted(bool highlight)
+    {
+        if (mHighlightingEnabled &amp;&amp; mActor != NULL)
+        {
+            mActor-&gt;setHighlighted(highlight, getName());
+        }
+    }
+
+    bool GameObject::isHighlighted() const
+    {
+        return mActor != NULL &amp;&amp; mActor-&gt;isHighlighted();
+    }
+
+    void GameObject::setPosition(const Ogre::Vector3&amp; position)
+    {
+        if (mActor != NULL)
+        {
+            mActor-&gt;setPosition(position);
+        }
+        else
+        {
+            mPosition = position;
+        }
+    }
+
+    const Ogre::Vector3&amp; GameObject::getPosition() const
+    {
+        if (mActor != NULL)
+        {
+            return mActor-&gt;getPosition();
+        }
+        return mPosition;
+    }
+
+	Ogre::AxisAlignedBox GameObject::getWorldBoundingBox() const
+	{
+        if (mActor != NULL)
+        {
+            return mActor-&gt;getWorldBoundingBox();
+        }
+        return Ogre::AxisAlignedBox();
+	}
+
+    void GameObject::setOrientation(const Ogre::Quaternion&amp; orientation)
+    {
+        if (mActor != NULL)
+        {
+            mActor-&gt;setOrientation(orientation);
+        }
+        else
+        {
+            mOrientation = orientation;
+        }
+    }
+
+    const Ogre::Quaternion&amp; GameObject::getOrientation() const
+    {
+        if (mActor != NULL)
+        {
+            return mActor-&gt;getOrientation();
+        }
+        return mOrientation;
+    }
+
+    const GeometryType GameObject::getGeometryType() const
+    {
+        return mGeometryType;
+    }
+
+    void GameObject::setGeometryType(GeometryType type)
+    {
+        mGeometryType = type;
+    }
+
+    const Ogre::Real GameObject::getMass() const
+    {
+        return mMass;
+    }
+
+    void GameObject::setMass(const Ogre::Real mass)
+    {
+        mMass = mass;
+    }
+
+    void GameObject::addEffect(Effect* effect)
+	{
+		mEffectManager-&gt;addEffect(effect);
+	}
+
+    void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
+    {
+      addEffect(effect);
+      mEffectManager-&gt;addTimeCheck(time, effect);
+    }
+
+    void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
+    {
+      addEffect(effect);
+      mEffectManager-&gt;addDateCheck(date, effect);
+    }
+
+	void GameObject::_checkEffects()
+	{
+		/// @todo Nur einmal pro Aktion ausfuehren
+		mEffectManager-&gt;checkEffects();
+	}
+
+    void GameObject::removeEffect(Effect* effect)
+	{
+		mEffectManager-&gt;removeEffect(effect);
+	}
+
+    CeGuiString GameObject::getEffects()
+    {
+        return mEffectManager-&gt;getEffects();
+    }
+
+    const Property GameObject::getProperty(const CeGuiString&amp; key) const
+    {
+        Property prop;
+        if (key == PROPERTY_POSITION)
+        {
+            prop.setValue(getPosition());
+        }
+        else if (key == PROPERTY_ORIENTATION)
+        {
+            prop.setValue(getOrientation());
+        }
+        else if (key == PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == PROPERTY_DESCRIPTION)
+        {
+            prop.setValue(mDescription);
+        }
+        else if (key == PROPERTY_MESHFILE)
+        {
+            prop.setValue(mMeshfile);
+        }
+        else if (key == PROPERTY_GEOMETRY_TYPE)
+        {
+            prop.setValue(PhysicsManager::convertGeometryTypeToString(mGeometryType));
+        }
+        else if (key == PROPERTY_MASS)
+        {
+            prop.setValue(mMass);
+        }
+		else if (key == PROPERTY_MESHPARTS)
+		{
+			PropertyMap map;
+			for (MeshPartMap::const_iterator
+					it = mMeshParts.begin(); it != mMeshParts.end(); ++it)
+			{
+				map[(*it).first] = Property((*it).second);
+			}
+			prop.setValue(map);
+		}
+        else if (key == PROPERTY_SUBMESHPRENAME)
+        {
+            prop.setValue(mSubmeshPreName);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, key + &quot; is not a property of this gameobject (&quot;+mName.c_str()+&quot;)&quot;);
+        }
+
+        return prop;
+    }
+
+    void GameObject::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        try
+        {
+            if (key == PROPERTY_POSITION)
+            {
+                setPosition(value.toVector3());
+            }
+            else if (key == PROPERTY_ORIENTATION)
+            {
+                setOrientation(value.toQuaternion());
+            }
+            else if (key == PROPERTY_NAME)
+            {
+                setName(value.toString());
+            }
+            else if (key == PROPERTY_DESCRIPTION)
+            {
+                setDescription(value.toString());
+            }
+            else if (key == PROPERTY_MESHFILE)
+            {
+                setMeshfile(value.toString());
+            }
+            else if (key == PROPERTY_MESHPARTS)
+            {
+				PropertyMap map = value.toMap();
+				for (PropertyMap::const_iterator
+					it = map.begin(); it != map.end(); ++it)
+				{
+					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
+				}
+            }
+            else if (key == PROPERTY_GEOMETRY_TYPE)
+            {
+                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));
+            }
+            else if (key == PROPERTY_MASS)
+            {
+                Ogre::Real mass = 0.0;
+                if (value.isInt())
+                {
+                    mass = value.toInt();
+                }
+                else if (value.isReal())
+                {
+                    mass = value.toReal();
+                }
+                setMass(mass);
+            }
+            else if (key == PROPERTY_ACTIONS)
+            {
+                PropertyArray vecVal = value.toArray();
+                for (PropertyArray::const_iterator it = vecVal.begin(); it != vecVal.end(); it++)
+                {
+                    Ogre::String actionName = (*it).toString().c_str();
+                    Action* act = ActionManager::getSingleton().getAction(actionName);
+
+                    if (act != NULL)
+                    {
+                        addAction(act);
+                    }
+                    else
+                    {
+                        LOG_ERROR(Logger::RULES, &quot;'&quot;+actionName+&quot;' not registered at ActionManager.&quot;);
+                    }
+                }
+            }
+            else if (key == PROPERTY_DEFAULT_ACTION)
+            {
+                mDefaultAction = value.toString().c_str();
+            }
+            else if (key == PROPERTY_SUBMESHPRENAME)
+            {
+                mSubmeshPreName = value.toString();
+            }
+            else
+            {
+                if( key != PROPERTY_BASE_CLASS &amp;&amp; key != PROPERTY_CLASS_ID &amp;&amp; key != PROPERTY_INHERITS)
+                    // these two keys can be ignored, they are only given to the GameObjectFactory when creating a GOF
+                {
+                    LOG_WARNING(Logger::RULES,
+						key + &quot; is not a property of this GameObject (&quot;+mName+&quot;)&quot;);
+                }
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;property &quot; + key + &quot; has the wrong format&quot;);
+        }
+    }
+
+    PropertyKeys GameObject::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(PROPERTY_NAME);
+        keys.insert(PROPERTY_DESCRIPTION);
+        if(mState == GOS_IN_SCENE)
+        {
+            keys.insert(PROPERTY_POSITION);
+            keys.insert(PROPERTY_ORIENTATION); 
+        }
+        keys.insert(PROPERTY_MESHFILE);
+        keys.insert(PROPERTY_MESHPARTS);
+        keys.insert(PROPERTY_GEOMETRY_TYPE);
+        keys.insert(PROPERTY_MASS);
+        return keys;
+    }
+
+    Actor* GameObject::createActor()
+    {
+        if (!mActor)
+        {
+            Ogre::String actorName = Ogre::StringConverter::toString(mId);
+			Actor* actor = NULL;
+
+			if (mMeshfile.empty() &amp;&amp; mMeshParts.empty())
+			{
+				LOG_ERROR(
+					Logger::RULES,
+					&quot;Neither mesh file nor mesh parts are set on gameobject '&quot; + getName()
+					+ &quot;' (id: &quot; + getId() + &quot;). Can't create actor!&quot;);
+			}
+			else if (!mMeshParts.empty())
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mMeshParts,
+						mGeometryType,
+						mMass);
+			}
+			else
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mGeometryType,
+						mMass);
+			}
+
+			if (actor == NULL)
+			{
+				LOG_ERROR(
+					Logger::RULES,
+					&quot;Error creating actor '&quot;
+					+ actorName	+ &quot;'.&quot;);
+			}
+
+            setActor(actor);
+        }
+
+        return mActor;
+    }
+
+    void GameObject::destroyActor()
+    {
+        if (mActor != NULL)
+        {
+			Actor* actor = mActor;
+			setActor(NULL);
+            ActorManager::getSingleton().destroyActor(actor);
+		}
+    }
+
+    void GameObject::placeIntoScene()
+    {
+        setState(GOS_IN_SCENE);
+    }
+
+    void GameObject::removeFromScene()
+    {
+        setState(GOS_LOADED);
+    }
+
+    void GameObject::doPlaceIntoScene()
+    {
+        if (mState != GOS_IN_SCENE)
+        {
+            Actor* actor = createActor();
+
+            if (actor != NULL)
+            {
+                actor-&gt;placeIntoScene(mPosition, mOrientation);
+                setActor(actor);
+                mScene = CoreSubsystem::getSingleton().getCurrentScene();
+
+                // this is done in setstate now
+                //GameObjectState tmpState = mState;
+                //mState = GOS_IN_SCENE;
+                //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+                //onStateChange(tmpState, GOS_IN_SCENE);
+            }
+            else {
+                LOG_ERROR(
+                    Logger::RULES,
+                    &quot;Error placing gameobject '&quot;
+                    + Ogre::StringConverter::toString(mId)
+                    + &quot;' into scene &quot;
+                    + mMeshfile);
+            }
+        }
+    }
+
+    void GameObject::doRemoveFromScene()
+    {
+        if (mState == GOS_IN_SCENE)
+        {
+            Actor* actor = mActor;
+            if (actor)
+            {
+                //mOrientation = actor-&gt;getWorldOrientation(); //Why world orientation?
+                //mPosition = actor-&gt;getWorldPosition(); //Why world position?
+
+                mOrientation = actor-&gt;getOrientation();
+                mPosition = actor-&gt;getPosition();
+
+                setActor(NULL);
+                actor-&gt;removeFromScene();
+                mScene = &quot;&quot;;
+            }
+
+            // give the setstate function the possibility to reuse the actor
+            //ActorManager::getSingleton().destroyActor(actor);
+
+            // this is done in setstate now
+            //GameObjectState tmpState = mState;
+            //mState = GOS_LOADED;
+            //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+        }
+    }
+
+    void GameObject::setState(GameObjectState targetstate)
+    {
+        if (targetstate == mState)
+        {
+            return;
+        }
+
+        GameObjectState oldState = mState;
+        onBeforeStateChange(oldState, targetstate);
+
+        if (targetstate == GOS_LOADED &amp;&amp; mState == GOS_IN_SCENE)
+        {
+            doRemoveFromScene();
+            destroyActor();
+        }
+        else if (targetstate == GOS_IN_SCENE &amp;&amp; mState == GOS_LOADED)
+        {
+            doPlaceIntoScene();
+        }
+        else
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;GameObject '&quot; + getName()
+                + &quot;' could not change state from &quot;
+                + Ogre::StringConverter::toString(mState) + &quot; to &quot;
+                + Ogre::StringConverter::toString(targetstate));
+            return;
+        }
+
+        mState = targetstate;
+        onAfterStateChange(oldState, targetstate);
+        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetstate);
+    }
+
+    void GameObject::onBeforeStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+    }
+
+    void GameObject::onAfterStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+    }
+
+    GameObjectState GameObject::getState() const
+    {
+        return mState;
+    }
+
+    unsigned long GameObject::getQueryFlags() const
+    {
+        return mQueryFlags;
+    }
+
+    void GameObject::addQueryFlag(unsigned long queryflag)
+    {
+        mQueryFlags |= queryflag;
+
+        setQueryFlags(mQueryFlags);
+    }
+
+    void GameObject::setQueryFlags(unsigned long queryflags)
+    {
+        mQueryFlags = queryflags;
+
+        if(mActor != NULL)
+        {
+            mActor-&gt;setQueryFlags(mQueryFlags);
+        }
+    }
+}

Modified: rl/trunk/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/GoToJob.cpp	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/src/GoToJob.cpp	2008-09-28 20:56:08 UTC (rev 4529)
@@ -18,6 +18,8 @@
 
 #include &quot;GoToJob.h&quot;
 
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
 #include &quot;MathUtil.h&quot;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001585.html">[Dsa-hl-svn] r4528 - in rl/branches/persistence: ai/include core	core/include core/src rules/include rules/src script/include	script/src script/swig ui/include ui/src
</A></li>
	<LI>Next message: <A HREF="001587.html">[Dsa-hl-svn] r4530 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/rules/include engine/rules/src engine/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1586">[ date ]</a>
              <a href="thread.html#1586">[ thread ]</a>
              <a href="subject.html#1586">[ subject ]</a>
              <a href="author.html#1586">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
