<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4511 - in rl/trunk/engine: rules/include rules/src	script/src script/swig ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4511%20-%20in%20rl/trunk/engine%3A%20rules/include%20rules/src%0A%09script/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200809172224.m8HMOWl7011796%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001567.html">
   <LINK REL="Next"  HREF="001569.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4511 - in rl/trunk/engine: rules/include rules/src	script/src script/swig ui/include ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4511%20-%20in%20rl/trunk/engine%3A%20rules/include%20rules/src%0A%09script/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200809172224.m8HMOWl7011796%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4511 - in rl/trunk/engine: rules/include rules/src	script/src script/swig ui/include ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Thu Sep 18 00:24:32 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001567.html">[Dsa-hl-svn] r4510 - rl/trunk/engine/script/src
</A></li>
        <LI>Next message: <A HREF="001569.html">[Dsa-hl-svn] r4512 - in modules: aitest/scripts/maps	combattest/scripts combattest/scripts/maps common/scripts	kanalisation/scripts kanalisation/scripts/maps	persistenztest/scripts persistenztest/scripts/maps	regressiontest/scripts regressiontest/scripts/maps	ruchin/scripts ruchin/scripts/maps techdemo/scripts/maps	techdemo2/scripts techdemo2/scripts/maps teichtest/scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1568">[ date ]</a>
              <a href="thread.html#1568">[ thread ]</a>
              <a href="subject.html#1568">[ subject ]</a>
              <a href="author.html#1568">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-09-18 00:24:26 +0200 (Thu, 18 Sep 2008)
New Revision: 4511

Added:
   rl/trunk/engine/rules/include/PartyManager.h
   rl/trunk/engine/rules/src/PartyManager.cpp
Modified:
   rl/trunk/engine/rules/include/RulesMessages.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/src/SceneManager.cpp
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/UiMessages.h
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Moved current character to PartyManager class, started work on game over if all chars are dead

Added: rl/trunk/engine/rules/include/PartyManager.h
===================================================================
--- rl/trunk/engine/rules/include/PartyManager.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/PartyManager.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -0,0 +1,52 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __PartyManager_H__
+#define __PartyManager_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Effect.h&quot;
+#include &quot;MessagePump.h&quot;
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport PartyManager : public Ogre::Singleton&lt;PartyManager&gt;
+    {
+    public:
+        PartyManager();
+        
+        Creature* getActiveCharacter() const;
+        void setActiveCharacter(Creature* character);
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        std::vector&lt;Creature*&gt; getCharacters() const;
+        bool isInParty(Creature* creature) const;
+        
+    private:
+        std::vector&lt;Creature*&gt; mParty;
+        Creature* mActiveCharacter;
+	    MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        bool onGameObjectLifeStateChanged(GameObject* gameobject, Effect::LifeState oldstate,
+            Effect::LifeState newstate);
+            
+        void checkParty();
+   };
+}
+
+#endif // __PartyManager_H__

Modified: rl/trunk/engine/rules/include/RulesMessages.h
===================================================================
--- rl/trunk/engine/rules/include/RulesMessages.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/RulesMessages.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,75 +1,101 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Rl_RulesMessages_H__
-#define __Rl_RulesMessages_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;MessageType.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;CoreMessages.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-	class Combatant;
-	class GameObject;
-
-	/// 0x03xxxxxx as mask for rules messages
-    enum RulesMessageTypeIds
-    {
-        // Game event log //
-        // Mask
-        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
-        // Events
-        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
-
-		// Combat
-		// Mask
-		RLMSG_COMBAT_EVENTS = 0x03000200,
-		// Events
-		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
-		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
-		RLMSG_COMBAT_ENDED = 0x03000210,
-
-		// Game object related events
-        // Mask
-        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
-        // Events
-        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301
-    };
-
-    /// Message sent right after a new game log event has been added.
-	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
-		MessageType_GameEventLog_EventAdded;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
-		MessageType_CombatOpponentEntered;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
-		MessageType_CombatOpponentLeft;
-
-    typedef MessageType&lt;RLMSG_COMBAT_ENDED, bool&gt;
-		MessageType_CombatEnded;
-
-    typedef MessageType&lt;RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState&gt;
-		MessageType_GameObjectLifeStateChanged;
-    
-    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_RulesMessages_H__
+#define __Rl_RulesMessages_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;MessageType.h&quot;
+#include &quot;RulesConstants.h&quot;
+#include &quot;CoreMessages.h&quot;
+#include &quot;Effect.h&quot;
+
+namespace rl
+{
+	class Combatant;
+    class Creature;
+	class GameObject;
+
+	/// 0x03xxxxxx as mask for rules messages
+    enum RulesMessageTypeIds
+    {
+        // Game event log //
+        // Mask
+        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
+        // Events
+        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
+
+		// Combat
+		// Mask
+		RLMSG_COMBAT_EVENTS = 0x03000200,
+		// Events
+		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
+		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
+		RLMSG_COMBAT_ENDED = 0x03000210,
+
+		// Game object related events
+        // Mask
+        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
+        // Events
+        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301,
+        
+        // Player character related events
+        // Mask
+        RLMSG_PLAYERCHAR_EVENTS = 0x03000400,
+        // Events
+        RLMSG_PLAYERCHAR_DIED = 0x03000401,
+        RLMSG_PLAYERCHAR_ALL_DIED = 0x03000402,
+        RLMSG_PLAYERCHAR_ADDED = 0x03000403,
+        RLMSG_PLAYERCHAR_REMOVED = 0x03000404,
+        RLMSG_PLAYERCHAR_ACTIVE_CHANGED = 0x03000405        
+    };
+
+    /// Message sent right after a new game log event has been added.
+	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
+		MessageType_GameEventLog_EventAdded;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
+		MessageType_CombatOpponentEntered;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
+		MessageType_CombatOpponentLeft;
+
+    typedef MessageType&lt;RLMSG_COMBAT_ENDED, bool&gt;
+		MessageType_CombatEnded;
+
+    typedef MessageType&lt;RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState&gt;
+		MessageType_GameObjectLifeStateChanged;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
+    
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_DIED, Creature*&gt;
+        MessageType_PlayerCharDied;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ADDED, Creature*&gt;
+        MessageType_PlayerCharAdded;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_REMOVED, Creature*&gt;
+        MessageType_PlayerCharRemoved;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ACTIVE_CHANGED, Creature*, Creature*&gt;
+        MessageType_ActivePlayerCharChanged;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ALL_DIED&gt;
+        MessageType_AllPlayerCharsDied;
+
+}
+#endif

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -31,6 +31,7 @@
 	class GameEventLog;
     class GlobalProperties;
 	class QuestBook;
+    class PartyManager;
     class XdimlLoader;
 
 	class _RlRulesExport RulesSubsystem : public Ogre::Singleton&lt;RulesSubsystem&gt;
@@ -52,6 +53,7 @@
         XdimlLoader* mXdimlLoader;
         GlobalProperties* mGlobalProperties;
         EffectManagementTask* mEffectManagementTask;
+        PartyManager* mPartyManager;
     };
 }
 

Added: rl/trunk/engine/rules/src/PartyManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -0,0 +1,140 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;PartyManager.h&quot;
+
+#include &lt;boost/bind.hpp&gt;
+
+#include &quot;Creature.h&quot;
+#include &quot;RulesMessages.h&quot;
+
+template &lt;&gt;
+rl::PartyManager* Ogre::Singleton&lt;rl::PartyManager&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    
+    PartyManager::PartyManager()
+    {
+        ///@todo watch characters for death, trigger game over if no-one is left
+        mLifeStateChangeConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectLifeStateChanged&gt;(
+                boost::bind(&amp;PartyManager::onGameObjectLifeStateChanged, this, _1, _2, _3));
+    }
+    
+    void PartyManager::addCharacter(Creature* character)
+    {
+        mParty.push_back(character);
+        ///@todo send message
+        
+        if (mActiveCharacter == NULL)
+        {
+            setActiveCharacter(character);
+        }
+    }
+    
+    void PartyManager::removeCharacter(Creature* character)
+    {
+        for (std::vector&lt;Creature*&gt;::iterator it = mParty.begin();
+             it != mParty.end(); ++it)
+        {
+            if (*it == character)
+            {
+                ///@todo send message
+                mParty.erase(it);
+                break;
+            }
+        }
+        checkParty();
+    }
+    
+    void PartyManager::setActiveCharacter(Creature* character)
+    {
+        if (!isInParty(character))
+        {
+            addCharacter(character);
+        }
+        if (mActiveCharacter != character)
+        {
+            Creature* oldActiveChar = mActiveCharacter;
+            mActiveCharacter = character;
+            MessagePump::getSingleton().sendMessage&lt;MessageType_ActivePlayerCharChanged&gt;(
+                oldActiveChar, mActiveCharacter);
+        }        
+    }
+    
+    Creature* PartyManager::getActiveCharacter() const
+    {
+        return mActiveCharacter;
+    }
+    
+    std::vector&lt;Creature*&gt; PartyManager::getCharacters() const
+    {
+        return mParty;
+    }
+    
+    bool PartyManager::isInParty(Creature* creature) const
+    {
+        for (int i = 0; i &lt; mParty.size(); ++i)
+        {
+            if (mParty[i] == creature)
+            {
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    bool PartyManager::onGameObjectLifeStateChanged(GameObject* gameobject, 
+        Effect::LifeState oldstate, Effect::LifeState newstate)
+    {
+        LOG_DEBUG(&quot;PartyManager&quot;, &quot;Someone changed state.&quot;);
+        if (0 != (newstate &amp; Effect::LS_DEAD|Effect::LS_UNCONSCIOUS|Effect::LS_INCAPACITATED))
+        {
+            LOG_DEBUG(&quot;PartyManager&quot;, &quot;Someone died or was rendered unconscious.&quot;);
+            Creature* crea = dynamic_cast&lt;Creature*&gt;(gameobject);
+            if (crea &amp;&amp; isInParty(crea))
+            {
+                checkParty();
+            }
+        }
+        
+        return false;
+    }
+    
+    void PartyManager::checkParty()
+    {   
+        int alive = 0;
+        for (std::vector&lt;Creature*&gt;::iterator it = mParty.begin();
+             it != mParty.end(); ++it)
+        {
+            Creature* cur = *it;
+            if (!(cur-&gt;getLifeState() &amp; Effect::LS_DEAD|Effect::LS_UNCONSCIOUS|Effect::LS_INCAPACITATED))
+            {
+                alive++;
+            }
+        }
+        
+        if (alive == 0)
+        {
+            MessagePump::getSingleton().sendMessage&lt;MessageType_AllPlayerCharsDied&gt;();
+        }
+    }
+    
+    
+}

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,116 +1,125 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;CombatManager.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;DsaDataLoader.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;EffectManagementTask.h&quot;
-#include &quot;GameEventLog.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;GameTimeSource.h&quot;
-#include &quot;GlobalProperties.h&quot;
-#include &lt;ConfigurationManager.h&gt;
-
-template &lt;&gt;
-rl::RulesSubsystem* Singleton&lt;rl::RulesSubsystem&gt;::ms_Singleton = 0;
-namespace rl
-{
-    RulesSubsystem::RulesSubsystem()
-		: mQuestBook(NULL),
-        mActionManager(NULL),
-        mCombatManager(NULL),
-        mDsaManager(NULL),
-		mGameEventLog(NULL),
-        mMovingCreatureManager(NULL),
-        mXdimlLoader(NULL),
-        mGlobalProperties(NULL),
-        mEffectManagementTask(NULL)
-    {
-		LOG_MESSAGE(Logger::RULES, &quot;Start&quot;);
-        //Zufallsgenerator initialisieren
-        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
-
-        TimeSourceManager::getSingleton().registerTimeSource(
-            new GameTimeSource());
-
-        //Singletons erzeugen
-        mActionManager = new ActionManager();
-		LOG_MESSAGE(Logger::RULES, &quot;ActionManager erzeugt&quot;);
-        mCombatManager = new CombatManager();
-		LOG_MESSAGE(Logger::RULES, &quot;CombatManager erzeugt&quot;);
-        mDsaManager = new DsaManager();
-		LOG_MESSAGE(Logger::RULES, &quot;DsaManager erzeugt&quot;);
-        mGameEventLog = new GameEventLog();
-		LOG_MESSAGE(Logger::RULES, &quot;GameEventLog erzeugt&quot;);
-        mMovingCreatureManager = new CreatureControllerManager();
-		LOG_MESSAGE(Logger::RULES, &quot;CreatureControllerManager erzeugt&quot;);
-		resetQuestBook();
-		LOG_MESSAGE(Logger::RULES, &quot;Questverwaltung erzeugt&quot;);
-        mGlobalProperties = new GlobalProperties();
-
-        mEffectManagementTask = new EffectManagementTask();
-        GameLoop::getSingleton().addTask(
-            mEffectManagementTask, GameLoop::TG_LOGIC);
-
-		//Daten laden
-		mXdimlLoader = new XdimlLoader();
-		LOG_MESSAGE(Logger::RULES, &quot;Basisdaten geladen&quot;);
-
-        new EffectFactoryManager();
-        new GameObjectManager();
-		LOG_MESSAGE(Logger::RULES, &quot;Erzeugen abgeschlossen&quot;);
-    }
-
-	RulesSubsystem::~RulesSubsystem()
-    {
-        GameLoop::getSingleton().removeTask(mEffectManagementTask);
-        delete mEffectManagementTask;
-        delete mGlobalProperties;
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-        delete mQuestBook;
-		delete mGameEventLog;
-        delete mDsaManager;
-        delete mCombatManager;
-        delete mActionManager;
-        delete mXdimlLoader;
-        delete GameObjectManager::getSingletonPtr();
-        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
-        delete EffectFactoryManager::getSingletonPtr();
-    }
-
-	QuestBook* RulesSubsystem::getQuestBook()
-	{
-		return mQuestBook;
-	}
-
-	void RulesSubsystem::resetQuestBook()
-	{
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-		delete mQuestBook;
-		mQuestBook = new QuestBook();
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;RulesSubsystem.h&quot;
+
+#include &quot;ActionManager.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;DsaDataLoader.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;EffectManagementTask.h&quot;
+#include &quot;GameEventLog.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;GameTimeSource.h&quot;
+#include &quot;GlobalProperties.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;QuestBook.h&quot;
+
+template &lt;&gt;
+rl::RulesSubsystem* Singleton&lt;rl::RulesSubsystem&gt;::ms_Singleton = 0;
+namespace rl
+{
+    RulesSubsystem::RulesSubsystem()
+		: mQuestBook(NULL),
+        mActionManager(NULL),
+        mCombatManager(NULL),
+        mDsaManager(NULL),
+		mGameEventLog(NULL),
+        mMovingCreatureManager(NULL),
+        mXdimlLoader(NULL),
+        mGlobalProperties(NULL),
+        mEffectManagementTask(NULL)
+    {
+		LOG_MESSAGE(Logger::RULES, &quot;Start&quot;);
+        //Zufallsgenerator initialisieren
+        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
+
+        TimeSourceManager::getSingleton().registerTimeSource(
+            new GameTimeSource());
+
+        //Singletons erzeugen
+        mActionManager = new ActionManager();
+		LOG_MESSAGE(Logger::RULES, &quot;ActionManager erzeugt&quot;);
+        mCombatManager = new CombatManager();
+		LOG_MESSAGE(Logger::RULES, &quot;CombatManager erzeugt&quot;);
+        mDsaManager = new DsaManager();
+		LOG_MESSAGE(Logger::RULES, &quot;DsaManager erzeugt&quot;);
+        mGameEventLog = new GameEventLog();
+		LOG_MESSAGE(Logger::RULES, &quot;GameEventLog erzeugt&quot;);
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, &quot;CreatureControllerManager erzeugt&quot;);
+		resetQuestBook();
+		LOG_MESSAGE(Logger::RULES, &quot;Questverwaltung erzeugt&quot;);
+        mGlobalProperties = new GlobalProperties();
+
+        mEffectManagementTask = new EffectManagementTask();
+        GameLoop::getSingleton().addTask(
+            mEffectManagementTask, GameLoop::TG_LOGIC);
+
+		//Daten laden
+		mXdimlLoader = new XdimlLoader();
+		LOG_MESSAGE(Logger::RULES, &quot;Basisdaten geladen&quot;);
+
+        new EffectFactoryManager();
+        new GameObjectManager();
+        
+        mPartyManager = new PartyManager();
+		LOG_MESSAGE(Logger::RULES, &quot;Erzeugen abgeschlossen&quot;);
+    }
+
+	RulesSubsystem::~RulesSubsystem()
+    {
+        delete mPartyManager;
+        GameLoop::getSingleton().removeTask(mEffectManagementTask);
+        delete mEffectManagementTask;
+        delete mGlobalProperties;
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+        delete mQuestBook;
+		delete mGameEventLog;
+        delete mDsaManager;
+        delete mCombatManager;
+        delete mActionManager;
+        delete mXdimlLoader;
+        delete GameObjectManager::getSingletonPtr();
+        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
+        delete EffectFactoryManager::getSingletonPtr();
+    }
+
+	QuestBook* RulesSubsystem::getQuestBook()
+	{
+		return mQuestBook;
+	}
+
+	void RulesSubsystem::resetQuestBook()
+	{
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+		delete mQuestBook;
+		mQuestBook = new QuestBook();
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
+	}
+}

Modified: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,124 +1,124 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;SceneManager.h&quot;
-
-#include &quot;Creature.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;Scene.h&quot;
-#include &quot;SceneLoader.h&quot;
-#include &quot;UiSubsystem.h&quot;
-
-template&lt;&gt; rl::SceneManager* Ogre::Singleton&lt;rl::SceneManager&gt;::ms_Singleton = NULL;
-
-namespace rl 
-{
-
-    SceneManager::SceneManager()
-        : Ogre::Singleton&lt;SceneManager&gt;(),
-          Ogre::ScriptLoader(),
-          mCurrentScene(NULL)
-    {
-        mScriptPatterns.push_back(&quot;*.rlscene&quot;);
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-    }
-
-    SceneManager::~SceneManager()
-    {
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-        for (std::map&lt;CeGuiString, Scene*&gt;::iterator it = mScenes.begin();
-            it != mScenes.end(); ++it)
-        {
-            delete it-&gt;second;
-        }
-    }
-
-    void SceneManager::addScene(Scene* scene) 
-    {
-        mScenes[scene-&gt;getName()] = scene;
-    }
-
-    void SceneManager::loadScene(const CeGuiString&amp; sceneName, bool saveCurrent)
-    {
-        if (mCurrentScene &amp;&amp; sceneName == mCurrentScene-&gt;getName())
-        {
-            return;
-        }
-
-        Creature* activeChar = UiSubsystem::getSingleton().getActiveCharacter();
-
-        if (activeChar) {
-            CreatureControllerManager::getSingleton().detachController(
-                activeChar);
-            activeChar-&gt;setState(GOS_LOADED);
-        }
-
-        if (saveCurrent) 
-        {
-            mSceneStates[mCurrentScene] = mCurrentScene-&gt;getAllProperties();
-        }
-
-        std::map&lt;CeGuiString, Scene*&gt;::iterator itScene = mScenes.find(sceneName);
-        if (itScene != mScenes.end())
-        {            
-            std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState =
-                mSceneStates.end();
-            if (saveCurrent) 
-            {
-                std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState 
-                    = mSceneStates.find(mCurrentScene);
-            }
-
-            itScene-&gt;second-&gt;load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
-            mCurrentScene = itScene-&gt;second;
-            
-            if (itState != mSceneStates.end())
-            {
-                mCurrentScene-&gt;setProperties(itState-&gt;second);
-            }
-        }
-        else
-        {
-            LOG_ERROR(&quot;SceneManager&quot;, 
-                &quot;Scene '&quot; + sceneName + &quot;' not found. Have you forgotten to define it in a .rlscene file?&quot;);
-        }
-
-        if (activeChar) 
-        {
-            UiSubsystem::getSingleton().setActiveCharacter(activeChar);
-        }
-    }
-
-    const Ogre::StringVector&amp; SceneManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SceneManager::parseScript(Ogre::DataStreamPtr&amp; data, const Ogre::String&amp; resourceGroup)
-    {
-        SceneLoader* loader = new SceneLoader();
-        addScene(loader-&gt;loadScene(data));
-        delete loader;
-    }
-
-    Ogre::Real SceneManager::getLoadingOrder() const
-    {
-        return 1000;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;SceneManager.h&quot;
+
+#include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;Scene.h&quot;
+#include &quot;SceneLoader.h&quot;
+
+template&lt;&gt; rl::SceneManager* Ogre::Singleton&lt;rl::SceneManager&gt;::ms_Singleton = NULL;
+
+namespace rl 
+{
+
+    SceneManager::SceneManager()
+        : Ogre::Singleton&lt;SceneManager&gt;(),
+          Ogre::ScriptLoader(),
+          mCurrentScene(NULL)
+    {
+        mScriptPatterns.push_back(&quot;*.rlscene&quot;);
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+    }
+
+    SceneManager::~SceneManager()
+    {
+        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
+        for (std::map&lt;CeGuiString, Scene*&gt;::iterator it = mScenes.begin();
+            it != mScenes.end(); ++it)
+        {
+            delete it-&gt;second;
+        }
+    }
+
+    void SceneManager::addScene(Scene* scene) 
+    {
+        mScenes[scene-&gt;getName()] = scene;
+    }
+
+    void SceneManager::loadScene(const CeGuiString&amp; sceneName, bool saveCurrent)
+    {
+        if (mCurrentScene &amp;&amp; sceneName == mCurrentScene-&gt;getName())
+        {
+            return;
+        }
+
+        Creature* activeChar = PartyManager::getSingleton().getActiveCharacter();
+
+        if (activeChar) {
+            CreatureControllerManager::getSingleton().detachController(
+                activeChar);
+            activeChar-&gt;setState(GOS_LOADED);
+        }
+
+        if (saveCurrent) 
+        {
+            mSceneStates[mCurrentScene] = mCurrentScene-&gt;getAllProperties();
+        }
+
+        std::map&lt;CeGuiString, Scene*&gt;::iterator itScene = mScenes.find(sceneName);
+        if (itScene != mScenes.end())
+        {            
+            std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState =
+                mSceneStates.end();
+            if (saveCurrent) 
+            {
+                std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState 
+                    = mSceneStates.find(mCurrentScene);
+            }
+
+            itScene-&gt;second-&gt;load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene-&gt;second;
+            
+            if (itState != mSceneStates.end())
+            {
+                mCurrentScene-&gt;setProperties(itState-&gt;second);
+            }
+        }
+        else
+        {
+            LOG_ERROR(&quot;SceneManager&quot;, 
+                &quot;Scene '&quot; + sceneName + &quot;' not found. Have you forgotten to define it in a .rlscene file?&quot;);
+        }
+
+        if (activeChar) 
+        {
+            PartyManager::getSingleton().setActiveCharacter(activeChar);
+        }
+    }
+
+    const Ogre::StringVector&amp; SceneManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    void SceneManager::parseScript(Ogre::DataStreamPtr&amp; data, const Ogre::String&amp; resourceGroup)
+    {
+        SceneLoader* loader = new SceneLoader();
+        addScene(loader-&gt;loadScene(data));
+        delete loader;
+    }
+
+    Ogre::Real SceneManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+}

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -41,6 +41,7 @@
 #include &quot;ObjectStateChangeEventSource.h&quot;
 #include &quot;ObjectStateChangeEvent.h&quot;
 #include &quot;ObjectStateChangeListener.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;Quest.h&quot;
 #include &quot;QuestBook.h&quot;
 #include &quot;QuestEvent.h&quot;

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,952 +1,962 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-//%template(GameObjectVector) std::vector&lt; rl::GameObject* &gt;;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template&lt;typename T&gt;
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
-      Tripel(const Tripel&amp; rhs);
-
-      //Tripel&amp; operator=(const Tripel&amp; rhs);
-      bool operator==(const Tripel&amp; rhs);
-      bool operator&lt;(const Tripel&amp; rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date&amp; rhs);
-      
-        bool operator==(const Date&amp; rhs);
-        bool operator&lt;(const Date&amp; rhs);
-        bool operator&lt;=(const Date&amp; rhs);
-        bool operator&gt;=(const Date&amp; rhs);
-        bool operator&gt;(const Date&amp; rhs);
-
-        Date operator+(const RL_LONGLONG&amp; rhs);
-        Date operator-(const RL_LONGLONG&amp; rhs);
-        Date operator*(const Ogre::Real&amp; rhs);
-        Date operator/(const Ogre::Real&amp; rhs);
-        RL_LONGLONG operator-(const Date&amp; rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
-    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem&amp; getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date&amp; date);
-        
-        int rollD20();
-        Tripel&lt;int&gt; roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager&amp; getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature(&quot;director&quot;) GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager&amp; getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog&amp; getSingleton();
-		void logEvent(const Ogre::String&amp; eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String&amp; key) const;
-        
-        static rl::GlobalProperties&amp; getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature(&quot;director&quot;) QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map&lt;const rl::CeGuiString,int&gt; AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &amp;ausweichTalente);
-
-        bool operator==(const Talent&amp; rhs) const;
-        bool operator&lt;(const Talent&amp; rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature(&quot;director&quot;) Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1&lt;&lt;0;
-        static const int ACT_INVIS_DESC = 1&lt;&lt;1;
-        static const int ACT_DISABLED = 1&lt;&lt;2;
-        static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature(&quot;director&quot;) ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature(&quot;director&quot;) GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3&amp; position);
-        void setOrientation(const Ogre::Quaternion&amp; orientation);
-        const Ogre::Quaternion&amp; getOrientation() const;
-        const Ogre::Vector3&amp; getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date&amp; dsatime);
-        WaitJob(const Ogre::Real&amp; realtime);
-    };
-    
-    class GoToJob : public rl::Job
-    {
-    public:
-
-		GoToJob(rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		// Unclear what version is called from ruby, so uncomment second ctor.
-		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-    };
-    
-    %feature(&quot;director&quot;) Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
-            ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
-            ITEMTYPE_RING       = 1 &lt;&lt; 2,
-            ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
-            ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
-            ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
-            ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
-            ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
-            ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
-            ITEMTYPE_BELT       = 1 &lt;&lt; 9,
-            ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
-            ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
-            ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
-            ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
-            ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
-            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
-            ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel&lt;int&gt;&amp; getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair&lt;int, int&gt;&amp; getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair&lt;int, int&gt;&amp; newWm);
-        const std::pair&lt;int,int&gt;&amp; getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = &quot;g_be&quot;;
-        static const CeGuiString Armor::PROPERTY_G_RS = &quot;g_rs&quot;;
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature(&quot;director&quot;) Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1&lt;&lt;0;
-        static const LifeState LS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
-        static const LifeState LS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
-        static const LifeState LS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
-        static const ModType MODTYPE_SUM      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 &lt;&lt; 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const Ogre::String getName() const;
-        void setName(Ogre::String name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String&amp; name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager&amp; getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString&amp; slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void ready(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void dropItem(const rl::CeGuiString&amp; slotName);
-    };
-
-    %feature(&quot;director&quot;) Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///&lt; Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///&lt; Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///&lt; Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-        static const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
-        static const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
-        static const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
-        static const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
-        static const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
-        static const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
-        static const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
-        static const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
-        static const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature(&quot;director&quot;) ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager&amp; getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            MT_ZIELSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN,
-            MT_STUFENERKENNUNG,
-            MT_FALLEN,
-            MT_LIEGEN
-        } MovementType;
-        
-        Creature *getCreature();
-        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &amp;name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &amp;collisionName = &quot;&quot;);
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager&amp; getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3&amp; pos);
-        void setOrientation(const Ogre::Quaternion&amp; ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast&lt;rl::Selector*&gt;(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast&lt;rl::HalfSphereSelector*&gt;(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast&lt;rl::RaySelector*&gt;(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast&lt;rl::GameObject*&gt;(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+//%template(GameObjectVector) std::vector&lt; rl::GameObject* &gt;;
+
+namespace rl {
+
+    // Before first use of GameObject or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+
+                    
+   template&lt;typename T&gt;
+   class Tripel {
+   public:
+      T first;
+      T second;
+      T third;
+
+      Tripel();      
+      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
+      Tripel(const Tripel&amp; rhs);
+
+      //Tripel&amp; operator=(const Tripel&amp; rhs);
+      bool operator==(const Tripel&amp; rhs);
+      bool operator&lt;(const Tripel&amp; rhs);     
+   };
+    
+    class Date {
+    public:
+        static const RL_LONGLONG ONE_SECOND = 1000ULL;
+        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
+        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
+        static const RL_LONGLONG ONE_DAY = 86400000ULL;
+        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
+        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
+        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
+        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
+        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
+
+        Date();
+        Date(RL_LONGLONG timestamp);
+        Date(const Date&amp; rhs);
+      
+        bool operator==(const Date&amp; rhs);
+        bool operator&lt;(const Date&amp; rhs);
+        bool operator&lt;=(const Date&amp; rhs);
+        bool operator&gt;=(const Date&amp; rhs);
+        bool operator&gt;(const Date&amp; rhs);
+
+        Date operator+(const RL_LONGLONG&amp; rhs);
+        Date operator-(const RL_LONGLONG&amp; rhs);
+        Date operator*(const Ogre::Real&amp; rhs);
+        Date operator/(const Ogre::Real&amp; rhs);
+        RL_LONGLONG operator-(const Date&amp; rhs);
+      
+        RL_LONGLONG getTimestamp();
+
+        int getTimeFraction();
+        int getYear();
+        int getMonth();
+        rl::CeGuiString getMonthName();
+        int getDayOfYear();
+        int getDayOfMonth();
+        int getDayOfWeek();
+        rl::CeGuiString getDayOfWeekName();
+        int getHour();
+        int getMinute();
+        int getSecond();
+        int getMilliSecond();
+      
+        rl::CeGuiString toString();
+    };
+   
+    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
+    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
+
+    class RulesSubsystem 
+    {
+        public:
+             static rl::RulesSubsystem&amp; getSingleton();
+             rl::QuestBook* getQuestBook();
+             void resetQuestBook();
+    };
+  
+    class DsaManager {
+    public:
+        RL_LONGLONG getTimestamp();
+        Date getCurrentDate();
+        void setCurrentDate(const Date&amp; date);
+        
+        int rollD20();
+        Tripel&lt;int&gt; roll3D20();
+        int rollD6();
+        int roll(int d6, int d20);
+      
+        static DsaManager&amp; getSingleton();
+        rl::Talent* getTalent(const rl::CeGuiString name) const;
+        rl::Creature* getCreature(const int id) const;
+    };
+    
+    %feature(&quot;director&quot;) GameObjectFactory; 
+    class GameObjectFactory
+    {
+    public:
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
+        GameObjectFactory();
+        virtual ~GameObjectFactory();
+    };
+
+    class GameObjectManager
+    {
+    public:
+        static rl::GameObjectManager&amp; getSingleton();
+        rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
+        rl::GameObject* getGameObject(unsigned int id) const;
+        void setGameObjectFactory(rl::GameObjectFactory* gof);
+
+    private:
+        GameObjectManager();
+    };
+
+	enum GameEventType
+	{
+		GET_DEFAULT,
+		GET_COMBAT,
+		GET_DIALOG,
+		GET_QUEST
+	};
+	
+    class GameEventLog
+    {
+    public:
+        static rl::GameEventLog&amp; getSingleton();
+		void logEvent(const Ogre::String&amp; eventString, GameEventType type);
+
+    private:
+        GameEventLog();
+    };
+    
+    class GlobalProperties 
+    {
+    public:
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        bool hasProperty(const Ogre::String&amp; key) const;
+        
+        static rl::GlobalProperties&amp; getSingleton();
+    private:
+        GlobalProperties();
+    };
+
+    %feature(&quot;director&quot;) QuestListener; 
+    class QuestListener
+    {
+    public:
+        virtual ~QuestListener();
+        
+        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
+        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
+        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
+    };
+
+    class JournalEntry
+    {
+    public:
+        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        virtual ~JournalEntry();
+
+        rl::CeGuiString getCaption() const;
+
+        rl::CeGuiString getText() const;
+    };
+    
+    class Quest
+    {
+    public:
+        enum State
+        {
+            OPEN = 0,
+            ASSIGNED,
+            FAILED,
+            SUCCEEDED,
+            COMPLETED
+        };
+
+        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Quest();
+
+        const rl::CeGuiString getId();
+        const rl::CeGuiString getName();
+        const rl::CeGuiString getDescription();
+        int getPartsToDo();
+        void setPartsToDo(int partsToDo);
+        int getPartsDone();
+        void setPartsDone(int partsDone);
+        void increasePartsDone(int parts = 1);
+        void decreasePartsDone(int parts = 1);
+
+        rl::Quest::State getState();
+        void setState(rl::Quest::State state);
+        bool isKnown();
+        void setKnown(bool known);
+
+        // QuestVector getSubquests();
+        void addSubquest(rl::Quest* quest); 
+    };   
+    
+    class QuestEvent
+    {
+    public:
+        rl::Quest* getQuest();
+    private:
+        QuestEvent( rl::QuestBook* src, int reason );
+    };
+    
+    class QuestBook
+    {
+    public:
+        rl::Quest* getQuest(const rl::CeGuiString id);
+        void addQuest(rl::Quest* quest);
+        
+        void addJournalEntry(rl::JournalEntry* entry);
+        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
+        
+        void addQuestListener(rl::QuestListener* listener);
+        void removeQuestListener(rl::QuestListener* listener);
+    };
+    
+    class Talent
+    {
+    public:
+        typedef std::map&lt;const rl::CeGuiString,int&gt; AusweichTalente;
+        Talent(const rl::CeGuiString name,
+               const rl::CeGuiString description,
+               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
+               int ebe,
+               int gruppe,
+               const rl::CeGuiString art,
+               const AusweichTalente &amp;ausweichTalente);
+
+        bool operator==(const Talent&amp; rhs) const;
+        bool operator&lt;(const Talent&amp; rhs) const;
+        rl::CeGuiString getName() const;
+        rl::CeGuiString getDescription() const;
+        int getEbe() const;
+
+        /// Berechnet effektive Behinderung bei gegebener Behinderung;
+        int calculateEbe(int be) const;
+        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
+    };
+
+    class ActionGroup
+    {
+    public:
+        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
+        ~ActionGroup();
+    
+        const rl::CeGuiString getName() const;
+    };
+    
+    %feature(&quot;director&quot;) Action;   
+    class Action
+    {
+    public:
+        static const int ACT_NORMAL = 1&lt;&lt;0;
+        static const int ACT_INVIS_DESC = 1&lt;&lt;1;
+        static const int ACT_DISABLED = 1&lt;&lt;2;
+        static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
+
+        static const int TC_NO_TARGET = 0;
+        static const int TC_GAMEOBJECT = 1;
+        static const int TC_CREATURE = 2;
+        static const int TC_ITEM = 3;
+        static const int TC_POINT = 4;
+        static const int TC_RADIUS = 5;
+        static const int TC_POINT_AND_RADIUS = 6;
+    
+        Action(const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Action();
+
+        virtual const rl::CeGuiString getName() const;
+        //virtual const rl::CeGuiString getClassName() const;
+        virtual const rl::CeGuiString getDescription() const;
+        virtual int getTargetClass() const;
+        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
+            rl::GameObject *target);
+        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
+            
+        void setGroup(rl::ActionGroup* group);
+        rl::ActionGroup* getGroup() const;
+    };
+    
+    %feature(&quot;director&quot;) ObjectStateChangeListener;      
+    class ObjectStateChangeListener      
+    {      
+    public:      
+        virtual ~ObjectStateChangeListener();      
+               
+        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
+    };
+              
+               
+    class ObjectStateChangeEventSource      
+    {      
+    public:      
+        ObjectStateChangeEventSource( );      
+               
+        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
+        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
+        bool hasListeners( ) const;      
+        rl::GameObject* getObject() const;
+        void fireObjectStateChangeEvent();      
+    };      
+               
+    class ObjectStateChangeEvent      
+    {      
+    public:      
+        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
+        rl::GameObject* getProvokingObject() const;      
+        rl::ObjectStateChangeEventSource* getSource() const;      
+    };
+            
+    enum GameObjectState
+    {
+        GOS_UNDEFINED = 0,
+        GOS_UNLOADED,
+        GOS_LOADED,
+        GOS_IN_POSSESSION,
+        GOS_IN_SCENE,
+        GOS_HELD,
+        GOS_READY
+    };
+    
+    class PropertyRecord
+    {
+    public:
+        PropertyRecord();
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+    
+    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
+    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
+    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
+    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
+    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
+    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
+    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
+    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
+    
+    %feature(&quot;director&quot;) GameObject;
+    class GameObject: public ObjectStateChangeEventSource
+    {
+    public:
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        virtual unsigned int getId();
+
+        virtual const rl::CeGuiString getName() const;
+        virtual void setName(rl::CeGuiString name);
+
+        const rl::CeGuiString getDescription() const;
+        virtual void setDescription(rl::CeGuiString description);   
+        
+        void setActor(rl::Actor* actor);
+        rl::Actor* getActor();
+
+        void addAction(rl::Action *action, int option = ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
+        void removeAction(rl::Action *action);
+
+        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
+        void setPosition(const Ogre::Vector3&amp; position);
+        void setOrientation(const Ogre::Quaternion&amp; orientation);
+        const Ogre::Quaternion&amp; getOrientation() const;
+        const Ogre::Vector3&amp; getPosition() const;
+        
+        void setMeshfile(rl::CeGuiString meshfile);
+        
+        virtual Action* getDefaultAction(rl::Creature* actor) const;
+        
+        void doAction(
+            const rl::CeGuiString actionName, 
+            rl::Creature* actor,
+            rl::GameObject* target);
+        void doAction(
+            const rl::CeGuiString actionName);
+        void doAction(rl::Action* action, rl::Creature* actor,
+            rl::GameObject* target);
+            
+        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
+            
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+        
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+        
+        void addEffect(rl::Effect* effect);
+        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
+        void removeEffect(rl::Effect* effect);
+        
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void placeIntoScene();
+        void removeFromScene();
+        
+        rl::GameObjectState getState() const;
+        void setState(rl::GameObjectState state);
+        
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    class WaitJob : public rl::Job
+    {
+    public:
+        WaitJob(const rl::Date&amp; dsatime);
+        WaitJob(const Ogre::Real&amp; realtime);
+    };
+    
+    class GoToJob : public rl::Job
+    {
+    public:
+
+		GoToJob(rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		// Unclear what version is called from ruby, so uncomment second ctor.
+		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+    };
+    
+    %feature(&quot;director&quot;) Item;
+    class Item : public rl::GameObject {
+    public:
+        enum ItemType{
+            ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
+            ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
+            ITEMTYPE_RING       = 1 &lt;&lt; 2,
+            ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
+            ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
+            ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
+            ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
+            ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
+            ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
+            ITEMTYPE_BELT       = 1 &lt;&lt; 9,
+            ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
+            ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
+            ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
+            ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
+            ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
+            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
+            ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+        };
+    
+        Item(unsigned int id);
+        virtual ~Item();
+        
+        virtual void placeIntoScene();
+        
+        void setItemType(rl::Item::ItemType itemType);
+        rl::Item::ItemType getItemType() const;
+        virtual void setState(rl::GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(rl::Slot* slot);
+        rl::Slot* getParentSlot() const;
+
+        void setParentContainer(rl::Container* cont);
+        rl::Container* getParentContainer() const;
+
+        void setOwner(rl::GameObject* go);
+        rl::GameObject* getOwner() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        virtual bool isContainer();
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Weapon;
+    class Weapon : public rl::Item 
+    {
+    public:
+        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
+
+        Weapon(unsigned int id);
+        virtual ~Weapon();
+                
+        void setTp(int d6, int d20, int mod);
+        const Tripel&lt;int&gt;&amp; getTp() const;
+        void setTpKk(int base, int step);
+        const std::pair&lt;int, int&gt;&amp; getTpKk() const;
+        void setBf(int newBf);
+        int getBf();
+        void setIni(int newIni);
+        int getIni();
+        void setWm(std::pair&lt;int, int&gt;&amp; newWm);
+        const std::pair&lt;int,int&gt;&amp; getWm() const;
+        void setDk(Weapon::Distanzklasse newDk);
+        Weapon::Distanzklasse getDk();
+        void setKampftechnik(const rl::CeGuiString newKampftechnik);
+        const rl::CeGuiString getKampftechnik() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Armor;
+    class Armor : public Item
+    {
+    public:
+    
+        static const CeGuiString Armor::PROPERTY_G_BE = &quot;g_be&quot;;
+        static const CeGuiString Armor::PROPERTY_G_RS = &quot;g_rs&quot;;
+        
+        Armor(unsigned int id);
+        virtual ~Armor();
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Container;
+    class Container : public Item
+    {
+    public:
+        Container(unsigned int id);
+        virtual ~Container();
+
+        Ogre::Real getCapacity() const;
+        void setCapacity(Ogre::Real capacity);
+        void setVolume(unsigned int x, unsigned int y);
+        Ogre::Real getContentWeight() const;
+        void addItem(rl::Item* item);
+        void removeItem(rl::Item* item);
+        rl::ItemSet getItems() const;
+        int getItemCount() const;
+        rl::Item* getItemAt(unsigned int x, unsigned int y);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+
+    %feature(&quot;director&quot;) Effect;
+    class Effect
+    {
+    public:    
+        typedef unsigned long LifeState;
+        static const LifeState LS_NONE           = 1&lt;&lt;0;
+        static const LifeState LS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
+        static const LifeState LS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
+        static const LifeState LS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
+        static const LifeState LS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
+        static const LifeState LS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
+        static const LifeState LS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
+        static const LifeState LS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
+        static const LifeState LS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
+        static const LifeState LS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
+        static const LifeState LS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
+        static const LifeState LS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
+
+        // Meta stati
+        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
+        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
+
+        typedef int ModType;
+        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
+        static const ModType MODTYPE_SUM      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
+        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
+        static const ModType MODTYPE_MULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
+        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
+
+        typedef unsigned long ModTag;
+        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
+        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
+        static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
+        static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
+        static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
+        static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
+        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 &lt;&lt; 6;
+    
+        enum Quantifier
+        {
+            QUANTIFIER_MULTIPLE,
+            QUANTIFIER_UNIQUE,
+            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
+            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
+        };
+        
+      // other constants
+        static const int REMOVE = -1;
+        static const int PERMANENT = 0;
+
+
+        Effect(int stufe = 1);
+        virtual ~Effect();
+
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
+        const rl::CeGuiString getDescription() const;
+        void setDescription(rl::CeGuiString description);
+        Quantifier getQuantifier();
+        void setQuantifier(Quantifier quantifier);
+        virtual const int getStufe();
+        virtual void increaseStufe();
+        virtual void decreaseStufe();
+        virtual void enable();
+        virtual void disable();
+        virtual RL_LONGLONG timeCheck() = 0;
+
+        virtual LifeState getLifeState() const;
+        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+
+    class EffectFactory
+    {
+    public:
+        virtual rl::Effect* createEffect(const Ogre::String&amp; name, int stufe) = 0;
+    };
+
+    class EffectFactoryManager
+    {
+    public:
+        void setEffectFactory(rl::EffectFactory* factory);
+        static rl::EffectFactoryManager&amp; getSingleton();
+    };
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+
+    class Inventory 
+    {
+    private:
+        Inventory(rl::Creature* owner);
+    public:
+        void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
+        rl::Item* getItem(const rl::CeGuiString&amp; slotName) const;
+        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
+        void ready(rl::Item* item, const rl::CeGuiString&amp; slot);
+        void dropItem(const rl::CeGuiString&amp; slotName);
+    };
+
+    %feature(&quot;director&quot;) Creature;
+    class Creature : public GameObject {
+    public:
+    
+    typedef Ogre::String Wert;
+        enum Alignment
+        {
+            ALIGNMENT_ALLY,    ///&lt; Creature fights with the player.
+            ALIGNMENT_NEUTRAL, ///&lt; Creature doesn't fight for either side.
+            ALIGNMENT_ENEMY    ///&lt; Creature fights against the player.
+        };
+
+        enum SfStatus
+        {
+            SFSTATUS_IN_TRAINING = 1,
+            SFSTATUS_OK,
+            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
+        };
+
+        // some targets
+        static const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+        static const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
+        static const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
+        static const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
+        static const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
+        static const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
+        static const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
+        static const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
+        static const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
+        static const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
+        static const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
+        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
+        static const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
+        
+        
+        Creature(unsigned int id);
+        virtual ~Creature();
+
+        virtual int getLe();
+        virtual void modifyLe(int mod, bool ignoreMax = false);
+        virtual void modifyAe(int mod);
+        virtual void modifyAu(int mod);
+        void setWert(Wert wertId, int value);
+        virtual int getWert(Wert wertId, bool getUnmodified = false);
+        
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
+        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
+        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
+
+        
+        void addTalent(const rl::CeGuiString talentName, int value=0);
+        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
+        virtual int getTalent(const rl::CeGuiString talentName);
+        virtual void setTalent(const rl::CeGuiString talentName, int value);
+        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
+        virtual void addSe(const rl::CeGuiString talentName);
+        
+        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
+        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
+        
+        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
+        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+        
+        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
+        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
+        
+        rl::Inventory* getInventory();
+        
+        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        static const int LEDAMAGE_NORMAL = 0;
+        static const int LEDAMAGE_FIRE = 1;
+        static const int LEDAMAGE_WATER = 2;
+        static const int LEDAMAGE_DEMONIC = 4;
+        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        static const int AUDAMAGE_NORMAL = 0;
+        static const int AUDAMAGE_HEAT = 1;
+        static const int AUDAMAGE_COLD = 2;
+        static const int AUDAMAGE_CHOKE = 4;
+        static const int AUDAMAGE_DROWN = 8;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+
+        void setAlignment(Alignment);
+        Alignment getAlignment() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+   };
+   
+    %feature(&quot;director&quot;) ActionManager;
+    class ActionManager
+    {
+    public:
+        void registerAction(rl::Action* action);
+        void unregisterAction(const rl::CeGuiString actionName);
+        rl::Action* getAction(const rl::CeGuiString actionName) const;
+
+        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
+    
+        static rl::ActionManager&amp; getSingleton();
+    };
+    
+    class CreatureController
+    {
+    public:
+        
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
+        } MovementType;
+        
+        Creature *getCreature();
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const;
+        Ogre::Vector3 getRotation() const;
+        Ogre::Vector3 getVelocity() const;
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &amp;name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &amp;collisionName = &quot;&quot;);
+    protected:
+        CreatureController(Creature *character);
+        ~CreatureController();
+    };
+    
+    class CreatureControllerManager
+    {
+    public:
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        rl::CreatureController* getCreatureController(rl::Creature* creature);
+
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(rl::Creature* creature);
+
+        static rl::CreatureControllerManager&amp; getSingleton();
+    };
+
+	// Before first use of Selector or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
+
+	class Selector
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        GameObject* getFirstSelectedObject() const;
+		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+		virtual void updatePrimitive() = 0;
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
+		virtual void updatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3&amp; pos);
+        void setOrientation(const Ogre::Quaternion&amp; ori);
+		virtual void updatePrimitive();
+	};
+    
+    class PartyManager
+    {
+    public:
+        void setActiveCharacter(Creature* character);
+        Creature* getActiveCharacter() const;
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        static PartyManager&amp; getSingleton();
+    };
+
+} // Namespace
+
+%{
+static swig_type_info *Selector_dynamic_cast(void **ptr)
+{
+	rl::Selector *pSelector = static_cast&lt;rl::Selector*&gt;(*ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast&lt;rl::HalfSphereSelector*&gt;(pSelector);
+	if (pHalfSphereSel)
+	{
+		*ptr = pHalfSphereSel;
+		return SWIGTYPE_p_rl__HalfSphereSelector;
+	}
+	rl::RaySelector *pRaySel = dynamic_cast&lt;rl::RaySelector*&gt;(pSelector);
+	if (pRaySel)
+	{
+		*ptr = pRaySel;
+		return SWIGTYPE_p_rl__RaySelector;
+	}
+}
+	
+static swig_type_info *GameObject_dynamic_cast(void **ptr)
+{
+    rl::GameObject *pGameObject = static_cast&lt;rl::GameObject*&gt;(*ptr);
+
+    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(pGameObject);
+    if (pCreature) {
+        *ptr=pCreature;
+        return SWIGTYPE_p_rl__Creature;
+    }
+    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(pGameObject);
+    if (pWeapon) {
+        *ptr=pWeapon;
+        return SWIGTYPE_p_rl__Weapon;
+    }
+    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(pGameObject);
+    if (pArmor) {
+        *ptr=pArmor;
+        return SWIGTYPE_p_rl__Armor;
+    }
+    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(pGameObject);
+    if (pContainer) {
+        *ptr=pContainer;
+        return SWIGTYPE_p_rl__Container;
+    }
+    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(pGameObject);
+    if (pItem) {
+        *ptr=pItem;
+        return SWIGTYPE_p_rl__Item;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
+

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlUi.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,162 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-
-%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
-
-%feature(&quot;director&quot;) ControlState;
-class ControlState
-{
-private:
-    ControlState(rl::Actor* camera, rl::Actor* character);
-public:
-};
-
-class CutsceneControlState : public ControlState
-{
-private:
-       CutsceneControlState(rl::Actor* camera);
-
-public:
-    virtual ~CutsceneControlState();
-
-    void setCameraPosition(const Ogre::Vector3&amp; pos);
-    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
-    void lookAt(const Ogre::Vector3&amp; point);
-};
-
-class UiSubsystem
-{
-public:
-    static UiSubsystem&amp; getSingleton(void);
-    void initializeSubsystem();
-
-    rl::Creature* getActiveCharacter();
-    void setActiveCharacter(rl::Creature* chara);
-};
-
-enum ControlStateType 
-{
-    CST_NONE = 1,
-    CST_FREEFLIGHT,
-    CST_MOVEMENT,
-    CST_DIALOG,
-    CST_CUTSCENE,
-    CST_COMBAT,
-};
-
-class InputManager
-{
-public:
-    static InputManager&amp; getSingleton(void);
-
-    void pushControlState(rl::ControlStateType);
-    void popControlState();
-
-    void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
-private:
-    InputManager();
-};
-
-class WindowFactory
-{
-public:
-    enum PopupType
-    {
-        ICON_ERROR = 1,
-        ICON_QUEST
-    };
-
-    static rl::WindowFactory&amp; getSingleton();
-
-    void update();
-
-    void showAboutWindow();
-    void showActionChoice(rl::GameObject* obj);
-    void showCharacterActionChoice();
-    void showCharacterSheet();
-    void showCharacterSheet(rl::Creature* chara);
-    void showContainerContent(rl::Container* container);
-    void showDescriptionWindow(rl::GameObject* obj);
-    void showPropertiesWindow(rl::GameObject* obj);
-    void showGameSaveLoadWindow();
-    void showExitConfirmation();
-    void showJournalWindow();
-    void showLogfiles();
-    void showMainMenu();
-    void showMessageWindow(const rl::CeGuiString&amp; message);
-    void showPlaylist();
-    void showPopupMessage(int popupTypes);
-    void showGameSettings();
-
-    void toggleConsole();
-    void toggleDebugWindow();
-    void toggleGameLogWindow();
-    void toggleCharacterStateWindow();
-    void toggleInGameGlobalMenu();
-    void toggleInventoryWindow();
-
-    void checkForErrors();
-    rl::GameLoggerWindow* getGameLogger();
-
-    void showNextDebugWindowPage();
-};
-
-class WindowManager
-{
-public:
-    static rl::WindowManager&amp; getSingleton();
-    void closeTopWindow();
-};
-
-%feature(&quot;director&quot;) MessageWindow; 
-class MessageWindow
-{
-public:
-    enum Buttons 
-    {
-        OK,
-        YES_NO
-    };
-
-    MessageWindow::MessageWindow(
-        const rl::CeGuiString&amp; title, 
-        const rl::CeGuiString&amp; text, 
-        const Buttons buttons);
-    virtual ~MessageWindow();
-    virtual bool onButtonClicked(int button, const rl::CeGuiString&amp; text);
-    void setVisible(bool visible);
-};
-
-} //namespace rl
-
-%{
-static swig_type_info *ControlState_dynamic_cast(void **ptr)
-{
-    rl::ControlState *pControlState =
-        static_cast&lt;rl::ControlState*&gt;(*ptr);
-
-    rl::CutsceneControlState *pCutSceneCS =
-        dynamic_cast&lt;rl::CutsceneControlState*&gt;(pControlState);
-    if (pCutSceneCS != NULL) {
-        *ptr=pCutSceneCS;
-        return SWIGTYPE_p_rl__CutsceneControlState;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+
+%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
+
+%feature(&quot;director&quot;) ControlState;
+class ControlState
+{
+private:
+    ControlState(rl::Actor* camera, rl::Actor* character);
+public:
+};
+
+class CutsceneControlState : public ControlState
+{
+private:
+       CutsceneControlState(rl::Actor* camera);
+
+public:
+    virtual ~CutsceneControlState();
+
+    void setCameraPosition(const Ogre::Vector3&amp; pos);
+    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
+    void lookAt(const Ogre::Vector3&amp; point);
+};
+
+class UiSubsystem
+{
+public:
+    static UiSubsystem&amp; getSingleton(void);
+    void initializeSubsystem();
+};
+
+enum ControlStateType 
+{
+    CST_NONE = 1,
+    CST_FREEFLIGHT,
+    CST_MOVEMENT,
+    CST_DIALOG,
+    CST_CUTSCENE,
+    CST_COMBAT,
+};
+
+class InputManager
+{
+public:
+    static InputManager&amp; getSingleton(void);
+
+    void pushControlState(rl::ControlStateType);
+    void popControlState();
+
+    void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
+private:
+    InputManager();
+};
+
+class WindowFactory
+{
+public:
+    enum PopupType
+    {
+        ICON_ERROR = 1,
+        ICON_QUEST
+    };
+
+    static rl::WindowFactory&amp; getSingleton();
+
+    void update();
+
+    void showAboutWindow();
+    void showActionChoice(rl::GameObject* obj);
+    void showCharacterActionChoice();
+    void showCharacterSheet();
+    void showCharacterSheet(rl::Creature* chara);
+    void showContainerContent(rl::Container* container);
+    void showDescriptionWindow(rl::GameObject* obj);
+    void showPropertiesWindow(rl::GameObject* obj);
+    void showGameSaveLoadWindow();
+    void showExitConfirmation();
+    void showJournalWindow();
+    void showLogfiles();
+    void showMainMenu();
+    void showMessageWindow(const rl::CeGuiString&amp; message);
+    void showPlaylist();
+    void showPopupMessage(int popupTypes);
+    void showGameSettings();
+
+    void toggleConsole();
+    void toggleDebugWindow();
+    void toggleGameLogWindow();
+    void toggleCharacterStateWindow();
+    void toggleInGameGlobalMenu();
+    void toggleInventoryWindow();
+
+    void checkForErrors();
+    rl::GameLoggerWindow* getGameLogger();
+
+    void showNextDebugWindowPage();
+};
+
+class WindowManager
+{
+public:
+    static rl::WindowManager&amp; getSingleton();
+    void closeTopWindow();
+};
+
+%feature(&quot;director&quot;) MessageWindow; 
+class MessageWindow
+{
+public:
+    enum Buttons 
+    {
+        OK,
+        YES_NO
+    };
+
+    MessageWindow::MessageWindow(
+        const rl::CeGuiString&amp; title, 
+        const rl::CeGuiString&amp; text, 
+        const Buttons buttons);
+    virtual ~MessageWindow();
+    virtual bool onButtonClicked(int button, const rl::CeGuiString&amp; text);
+    void setVisible(bool visible);
+};
+
+} //namespace rl
+
+%{
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
+{
+    rl::ControlState *pControlState =
+        static_cast&lt;rl::ControlState*&gt;(*ptr);
+
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast&lt;rl::CutsceneControlState*&gt;(pControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/trunk/engine/ui/include/UiMessages.h
===================================================================
--- rl/trunk/engine/ui/include/UiMessages.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/UiMessages.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -37,10 +37,7 @@
 
         RLMSG_COMBAT_IO_ATTACK_OPPONENT = 0x04000103,
         RLMSG_COMBAT_IO_PARRY_OPPONENT = 0x04000104,
-        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105,
-
-        // Character change
-        RLMSG_ACTIVE_CHARACTER_CHANGED = 0x04000201
+        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105
     };
 
     /// Message sent after enemy action button has been pressed.
@@ -53,7 +50,5 @@
     typedef MessageType&lt;RLMSG_COMBAT_IO_ATTACK_OPPONENT, Combatant*&gt; MessageType_CombatIoAttackOpponent;
     typedef MessageType&lt;RLMSG_COMBAT_IO_PARRY_OPPONENT, Combatant*&gt; MessageType_CombatIoParryOpponent;
     typedef MessageType&lt;RLMSG_COMBAT_IO_END_TURN_REQUESTED&gt; MessageType_CombatIoEndTurnRequested;
-
-    typedef MessageType&lt;RLMSG_ACTIVE_CHARACTER_CHANGED, Creature*&gt; MessageType_ActiveCharacterChanged;
 }
 #endif

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,84 +1,89 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __UiSubsystem_H__
-#define __UiSubsystem_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;World.h&quot;
-
-
-#include &quot;ControlState.h&quot;
-#include &quot;MessagePump.h&quot;
-
-// Gar nicht sch&#246;n, aber ansonsten gibt es unn&#246;tige Abh&#228;ngigkeiten,
-// wenn man die Header hier inkludiert.
-namespace CEGUI {
-    class OgreCEGUIRenderer;
-    class OgreCEGUIResourceProvider;
-    class System;
-}
-
-namespace rl {
-
-    class Creature;
-    class GameActor;
-    class GameObject;
-    class InputManager;
-    class WindowFactory;
-    class WindowManager;
-
-    class _RlUiExport UiSubsystem : public Ogre::Singleton&lt;UiSubsystem&gt;
-    {
-    public:
-        static const char* CEGUI_ROOT;
-
-        /** Default Constructor */
-        UiSubsystem();
-        /** Default Deconstructor */
-        virtual ~UiSubsystem();
-
-        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
-        Creature* getActiveCharacter() const;
-        ///@todo function feels misplaced here,
-        void setActiveCharacter(Creature* person);
-
-        virtual bool onBeforeClearScene();
-        virtual bool onBeforeGameObjectsLoaded();
-        virtual bool onGameObjectsLoaded();
-
-        void initializeSubsystem();
-
-    private:
-        Creature* mCharacter;
-        int mCharacterId;
-
-	    MessagePump::ScopedConnection mSceneClearingConnection;
-        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
-        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
-
-        // Singletons
-        InputManager* mInputManager;
-        WindowFactory* mWindowFactory;
-        WindowManager* mWindowManager;
-
-        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
-        CEGUI::ResourceProvider* mGuiResourceProvider;
-        CEGUI::System* mGuiSystem;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __UiSubsystem_H__
+#define __UiSubsystem_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;World.h&quot;
+
+
+#include &quot;ControlState.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;Effect.h&quot;
+
+// Gar nicht sch&#203;&#134;n, aber ansonsten gibt es unn&#203;&#134;tige Abh&#226;&#128;&#176;ngigkeiten,
+// wenn man die Header hier inkludiert.
+namespace CEGUI {
+    class OgreCEGUIRenderer;
+    class OgreCEGUIResourceProvider;
+    class System;
+}
+
+namespace rl {
+
+    class Creature;
+    class GameActor;
+    class GameObject;
+    class InputManager;
+    class WindowFactory;
+    class WindowManager;
+
+    class _RlUiExport UiSubsystem : public Ogre::Singleton&lt;UiSubsystem&gt;
+    {
+    public:
+        static const char* CEGUI_ROOT;
+
+        /** Default Constructor */
+        UiSubsystem();
+        /** Default Deconstructor */
+        virtual ~UiSubsystem();
+
+        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
+
+        void initializeSubsystem();
+
+    private:
+        Creature* mCharacter;
+        int mCharacterId;
+
+	    MessagePump::ScopedConnection mSceneClearingConnection;
+        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
+        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
+        MessagePump::ScopedConnection mActiveCharacterChangedConnection;
+        MessagePump::ScopedConnection mAllPlayerCharactersDiedConnection;
+
+        bool onBeforeClearScene();
+        bool onBeforeGameObjectsLoaded();
+        bool onGameObjectsLoaded();
+        ///@todo function feels misplaced here,
+        bool onActiveCharacterChanged(Creature* oldActive, Creature* newActive);
+        bool onAllPlayerCharactersDied();
+        
+
+        // Singletons
+        InputManager* mInputManager;
+        WindowFactory* mWindowFactory;
+        WindowManager* mWindowManager;
+
+        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
+        CEGUI::ResourceProvider* mGuiResourceProvider;
+        CEGUI::System* mGuiSystem;
+        
+    };
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -86,6 +86,7 @@
         void showMainMenuLoadWindow(MainMenuWindow* win);
 		void hideMainMenuLoadWindow();
         void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
         /**
          * Creates a GameSettings object and displays its layout file on screen
          */

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,235 +1,236 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;UiPrerequisites.h&quot;
-
-#include &quot;UiSubsystem.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;GameLoop.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;MeshObject.h&quot;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-template&lt;&gt; rl::DebugWindow* Ogre::Singleton&lt;rl::DebugWindow&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    DebugWindow::DebugWindow() : AbstractWindow(&quot;debugwindow.xml&quot;, WIT_NONE),
-          mMessageText(),
-          mPageCaption(),
-          mPageText(),
-          mPageTexts(),
-          mCurrentPage(StringUtil::BLANK),
-          mDebugPageName(&quot;General Informations&quot;)
-    {
-        mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
-        mPageCaption-&gt;moveToFront();
-
-        mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
-
-        mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
-        mMessageText-&gt;moveToFront();
-
-        bindDestroyWindowToXButton();
-        registerPage(&quot;General Informations&quot;);
-    }
-
-    DebugWindow::~DebugWindow()
-    {
-        unregisterPage(&quot;General Informations&quot;);
-    }
-
-    void DebugWindow::registerPage(const Ogre::String&amp; page)
-    {
-        if (mPageTexts.find(page) != mPageTexts.end())
-        {
-            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; already registered as a page.&quot;);
-        }
-        else
-        {
-            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
-        }
-
-        // If this is the first page, activate it
-        if (mCurrentPage == StringUtil::BLANK)
-        {
-            mCurrentPage = page;
-        }
-    }
-
-    void DebugWindow::unregisterPage(const Ogre::String&amp; page)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it != mPageTexts.end())
-        {
-            mPageTexts.erase(it);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, page + &quot; is not registered as a page.&quot;);
-        }
-
-        // If this is the current page, switch over to the next
-        // or clear text, if no other page is left.
-        if (mCurrentPage == page &amp;&amp; !mPageTexts.empty())
-        {
-            mCurrentPage = page;
-        }
-        else if (mCurrentPage == page)
-        {
-            mCurrentPage = StringUtil::BLANK;
-        }
-        updatePageText();
-    }
-
-    void DebugWindow::setPageText(const Ogre::String&amp; page, const Ogre::String&amp; text)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it == mPageTexts.end())
-        {
-            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; is not registered as a page.&quot;);
-        }
-        else
-        {
-            it-&gt;second = text;
-        }
-
-        if (mCurrentPage == page)
-        {
-            updatePageText();
-        }
-    }
-
-    void DebugWindow::setMessageText(const Ogre::String&amp; text)
-    {
-        CeGuiString o(text.c_str());
-        mMessageText-&gt;setText(o);
-    }
-
-    void DebugWindow::showNextPage()
-    {
-        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
-        if (it != mPageTexts.end())
-        {
-            ++it;
-            if (it == mPageTexts.end())
-            {
-                it = mPageTexts.begin();
-            }
-            mCurrentPage = it-&gt;first;
-            updatePageText();
-        }
-        else
-        {
-            RlAssert1(mPageTexts.empty());
-        }
-    }
-
-    void DebugWindow::run(Ogre::Real elapsedTime)
-    {
-        updateFps();
-    }
-
-    void DebugWindow::updatePageText()
-    {
-        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
-            StringUtil::BLANK : mPageTexts[mCurrentPage];
-        mPageCaption-&gt;setText(mCurrentPage);
-        mPageText-&gt;setText(text);
-    }
-
-    void DebugWindow::updateFps()
-    {
-        const RenderTarget::FrameStats&amp; stats = CoreSubsystem::getSingleton().getRenderWindow()-&gt;getStatistics();
-
-        Ogre::String textSt = &quot;Current FPS: &quot; +
-            StringConverter::toString(stats.lastFPS)+
-            &quot;\nBest/worst/avg FPS: &quot; +
-            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.worstFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.avgFPS)+
-            &quot;\nBest/worst Frame times: &quot; +
-            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.worstFPS)+
-            &quot;\nTriangle Count: &quot; +
-            StringConverter::toString(stats.triangleCount);
-
-        if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &amp;&amp;
-            UiSubsystem::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
-        {
-            ActorControlledObject* charObj = UiSubsystem::getSingletonPtr()-&gt;
-                getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
-
-            if( charObj != NULL )
-            {
-                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
-                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
-
-                textSt += &quot;\nPlayer Position [ &quot;
-                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-
-                textSt += &quot;\nPlayer Orientation [ &quot;
-                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-            }
-        }
-
-        Actor* camActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-        if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
-        {
-            Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
-            Ogre::Vector3 pos = cam-&gt;getDerivedPosition();
-
-            textSt += &quot;\nCamera Position [ &quot;
-                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-        }
-
-        setPageText(mDebugPageName, textSt);
-    }
-
-    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
-    {
-        AbstractWindow::setVisible(visible, destroyAfterHide);
-        if (visible)
-            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-        else
-            GameLoop::getSingleton().removeTask(this);
-    }
-
-    const Ogre::String&amp; DebugWindow::getName() const
-    {
-        static Ogre::String NAME = &quot;DebugWindow&quot;;
-
-        return NAME;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;UiPrerequisites.h&quot;
+
+#include &quot;UiSubsystem.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;GameLoop.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;PartyManager.h&quot;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+template&lt;&gt; rl::DebugWindow* Ogre::Singleton&lt;rl::DebugWindow&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    DebugWindow::DebugWindow() : AbstractWindow(&quot;debugwindow.xml&quot;, WIT_NONE),
+          mMessageText(),
+          mPageCaption(),
+          mPageText(),
+          mPageTexts(),
+          mCurrentPage(StringUtil::BLANK),
+          mDebugPageName(&quot;General Informations&quot;)
+    {
+        mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
+        mPageCaption-&gt;moveToFront();
+
+        mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
+
+        mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
+        mMessageText-&gt;moveToFront();
+
+        bindDestroyWindowToXButton();
+        registerPage(&quot;General Informations&quot;);
+    }
+
+    DebugWindow::~DebugWindow()
+    {
+        unregisterPage(&quot;General Informations&quot;);
+    }
+
+    void DebugWindow::registerPage(const Ogre::String&amp; page)
+    {
+        if (mPageTexts.find(page) != mPageTexts.end())
+        {
+            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; already registered as a page.&quot;);
+        }
+        else
+        {
+            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
+        }
+
+        // If this is the first page, activate it
+        if (mCurrentPage == StringUtil::BLANK)
+        {
+            mCurrentPage = page;
+        }
+    }
+
+    void DebugWindow::unregisterPage(const Ogre::String&amp; page)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it != mPageTexts.end())
+        {
+            mPageTexts.erase(it);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, page + &quot; is not registered as a page.&quot;);
+        }
+
+        // If this is the current page, switch over to the next
+        // or clear text, if no other page is left.
+        if (mCurrentPage == page &amp;&amp; !mPageTexts.empty())
+        {
+            mCurrentPage = page;
+        }
+        else if (mCurrentPage == page)
+        {
+            mCurrentPage = StringUtil::BLANK;
+        }
+        updatePageText();
+    }
+
+    void DebugWindow::setPageText(const Ogre::String&amp; page, const Ogre::String&amp; text)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it == mPageTexts.end())
+        {
+            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; is not registered as a page.&quot;);
+        }
+        else
+        {
+            it-&gt;second = text;
+        }
+
+        if (mCurrentPage == page)
+        {
+            updatePageText();
+        }
+    }
+
+    void DebugWindow::setMessageText(const Ogre::String&amp; text)
+    {
+        CeGuiString o(text.c_str());
+        mMessageText-&gt;setText(o);
+    }
+
+    void DebugWindow::showNextPage()
+    {
+        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
+        if (it != mPageTexts.end())
+        {
+            ++it;
+            if (it == mPageTexts.end())
+            {
+                it = mPageTexts.begin();
+            }
+            mCurrentPage = it-&gt;first;
+            updatePageText();
+        }
+        else
+        {
+            RlAssert1(mPageTexts.empty());
+        }
+    }
+
+    void DebugWindow::run(Ogre::Real elapsedTime)
+    {
+        updateFps();
+    }
+
+    void DebugWindow::updatePageText()
+    {
+        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
+            StringUtil::BLANK : mPageTexts[mCurrentPage];
+        mPageCaption-&gt;setText(mCurrentPage);
+        mPageText-&gt;setText(text);
+    }
+
+    void DebugWindow::updateFps()
+    {
+        const RenderTarget::FrameStats&amp; stats = CoreSubsystem::getSingleton().getRenderWindow()-&gt;getStatistics();
+
+        Ogre::String textSt = &quot;Current FPS: &quot; +
+            StringConverter::toString(stats.lastFPS)+
+            &quot;\nBest/worst/avg FPS: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.avgFPS)+
+            &quot;\nBest/worst Frame times: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS)+
+            &quot;\nTriangle Count: &quot; +
+            StringConverter::toString(stats.triangleCount);
+
+        if (PartyManager::getSingleton().getActiveCharacter() != NULL &amp;&amp;
+            PartyManager::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
+        {
+            ActorControlledObject* charObj = PartyManager::getSingletonPtr()-&gt;
+                getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
+
+            if( charObj != NULL )
+            {
+                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
+                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
+
+                textSt += &quot;\nPlayer Position [ &quot;
+                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+
+                textSt += &quot;\nPlayer Orientation [ &quot;
+                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+            }
+        }
+
+        Actor* camActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
+        if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
+        {
+            Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
+            Ogre::Vector3 pos = cam-&gt;getDerivedPosition();
+
+            textSt += &quot;\nCamera Position [ &quot;
+                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+        }
+
+        setPageText(mDebugPageName, textSt);
+    }
+
+    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+        if (visible)
+            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
+        else
+            GameLoop::getSingleton().removeTask(this);
+    }
+
+    const Ogre::String&amp; DebugWindow::getName() const
+    {
+        static Ogre::String NAME = &quot;DebugWindow&quot;;
+
+        return NAME;
+    }
+
+}

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -51,6 +51,7 @@
 #include &quot;Job.h&quot;
 #include &quot;JobScheduler.h&quot;
 #include &quot;MovementControlState.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;RubyInterpreter.h&quot;
 #include &quot;UiSubsystem.h&quot;
 #include &quot;WindowFactory.h&quot;
@@ -394,7 +395,7 @@
     void InputManager::pushControlState(ControlStateType controlStateType)
     {
         Actor* camera = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-        Creature* character = UiSubsystem::getSingleton().getActiveCharacter();
+        Creature* character = PartyManager::getSingleton().getActiveCharacter();
 
         ControlState* controller = NULL;
         switch (controlStateType)

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -40,6 +40,7 @@
 #include &quot;GameObjectManager.h&quot;
 #include &quot;InputManager.h&quot;
 #include &quot;Logger.h&quot;
+#include &quot;RulesMessages.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 #include &quot;SoundManager.h&quot;
 #include &quot;UiMessages.h&quot;
@@ -70,6 +71,9 @@
         mBeforeLoadingGameObjectsConnection = 
             MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; &gt;(
                 boost::bind(&amp;UiSubsystem::onBeforeGameObjectsLoaded, this));
+        mActiveCharacterChangedConnection = 
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_ActivePlayerCharChanged&gt;(
+                boost::bind(&amp;UiSubsystem::onActiveCharacterChanged, this, _1, _2));
         mWindowFactory = new WindowFactory();
     }
 
@@ -149,58 +153,47 @@
         return mGuiRenderer;
     }
 
-    Creature* UiSubsystem::getActiveCharacter() const
+    bool UiSubsystem::onActiveCharacterChanged(Creature* oldActive, Creature* newActive)
     {
-        return mCharacter;
-    }
-
-    void UiSubsystem::setActiveCharacter(Creature* creature)
-    {
         // Ensure we have a sound listener
         if (SoundManager::getSingleton().getListenerActor() == NULL)
         {
             SoundManager::getSingleton().createListenerActor();
         }
 
-        if (creature != mCharacter )
+        if (oldActive)
         {
-            if (mCharacter)
+            ScriptWrapper::getSingleton().disowned( oldActive );
+            if (oldActive-&gt;getActor())
             {
-                ScriptWrapper::getSingleton().disowned( mCharacter );
-                if (mCharacter-&gt;getActor())
-                {
-                    mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
-                }
-                mCharacter-&gt;setQueryFlags(mCharacter-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
+                oldActive-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
             }
-
-            if (!creature)
-            {
-                mCharacter = NULL;
-                mInputManager-&gt;clearControlStates();
-            }
-            else
-            {
-                ScriptWrapper::getSingleton().owned(creature);
-                mCharacter = creature;
-                mCharacter-&gt;addQueryFlag(QUERYFLAG_PLAYER);
-
-                mWindowFactory-&gt;setActiveCharacter(creature);
-
-                mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
-                LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
-
-                // Reset control stack for the new Character and set to movement.
-                mInputManager-&gt;setControlState(CST_MOVEMENT);
-            }
-
-            MessagePump::getSingleton().sendMessage&lt;MessageType_ActiveCharacterChanged&gt;(creature);
+            oldActive-&gt;setQueryFlags(oldActive-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
         }
+        
+        if (!newActive)
+        {
+            mInputManager-&gt;clearControlStates();
+        }
+        else
+        {
+            ScriptWrapper::getSingleton().owned(newActive);
+            newActive-&gt;addQueryFlag(QUERYFLAG_PLAYER);
+            
+            mWindowFactory-&gt;setActiveCharacter(newActive);
+            
+            newActive-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
+            LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
+            
+            // Reset control stack for the new Character and set to movement.
+            mInputManager-&gt;setControlState(CST_MOVEMENT);
+        }
+        
+        return true;
     }
 
     bool UiSubsystem::onBeforeClearScene()
     {
-        setActiveCharacter(NULL);
         // Remove control states here too, in case that there has not yet been a
         // person set active.
         mInputManager-&gt;clearControlStates();
@@ -241,9 +234,18 @@
             mCharacterId = mCharacter-&gt;getId();
         }
         else
+        {
             mCharacterId = -1;
-
+        }
+        
         //mInputManager-&gt;clearControlStates();
         return false;
     }
+    
+    bool UiSubsystem::onAllPlayerCharactersDied()
+    {
+        LOG_MESSAGE(Logger::UI, &quot;All player chars are dead, show game over&quot;);
+        WindowFactory::getSingleton().showGameOverWindow();
+        return true;
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,455 +1,462 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;WindowFactory.h&quot;
-
-#include &quot;AboutWindow.h&quot;
-#include &quot;ActionChoiceWindow.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CharacterSheetWindow.h&quot;
-#include &quot;CharacterStateWindow.h&quot;
-#include &quot;CloseConfirmationWindow.h&quot;
-#include &quot;CombatWindow.h&quot;
-#include &quot;Console.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;DialogControlState.h&quot;
-#include &quot;DialogWindow.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameLoggerWindow.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;GameObjectInfoWindow.h&quot;
-#include &quot;PropertiesWindow.h&quot;
-#include &quot;GameSaveLoadWindow.h&quot;
-#include &quot;MainMenuLoadWindow.h&quot;
-#include &quot;GameSettings.h&quot;
-#include &quot;InfoPopup.h&quot;
-#include &quot;InGameMenuWindow.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;InventoryWindow.h&quot;
-#include &quot;JournalWindow.h&quot;
-#include &quot;LogWindow.h&quot;
-#include &quot;MessageWindow.h&quot;
-#include &quot;MainMenuWindow.h&quot;
-#include &quot;MainMenuEngineWindow.h&quot;
-#include &quot;MovableText.h&quot;
-#include &quot;ObjectDescriptionWindow.h&quot;
-#include &quot;PlaylistWindow.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;SubtitleWindow.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowManager.h&quot;
-
-#undef max
-
-template&lt;&gt; rl::WindowFactory* Ogre::Singleton&lt;rl::WindowFactory&gt;::ms_Singleton = 0;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl {
-
-    WindowFactory::WindowFactory()
-        : mGameLogger(NULL),
-        mCharacterStateWindow(NULL),
-        mInGameMenuWindow(NULL),
-        mCharacterSheet(NULL),
-        mJournalWindow(NULL),
-        mInventoryWindow(NULL),
-        mLogWindow(NULL),
-        mDebugWindow(NULL),
-        mConsole(NULL),
-        mInfoPopup(NULL),
-        mObjectNameText(NULL),
-        mShownObject(NULL),
-        mObjectDescriptionWindow(NULL),
-        mMainMenuWindow(NULL),
-		mMainMenuLoadWindow(NULL),
-        mGameSettings(NULL),
-        mCombatWindow(NULL)
-    {
-    }
-
-    void WindowFactory::initialize()
-    {
-        mConsole = new Console();
-        mDebugWindow = new DebugWindow();
-        CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;
-            setOutputFunction(
-                (VALUE(*)(...))&amp;WindowFactory::consoleWrite );
-
-        mLogWindow = new LogWindow();
-
-        mGameLogger = new GameLoggerWindow();
-        mCharacterStateWindow = new CharacterStateWindow();
-        mInGameMenuWindow = new InGameMenuWindow();
-        mCharacterSheet = new CharacterSheetWindow();
-        mJournalWindow = new JournalWindow();
-        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
-        mObjectDescriptionWindow = new ObjectDescriptionWindow();
-        mGameSettings = new GameSettings();
-
-        RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mJournalWindow);
-        //RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mInfoPopup);
-        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
-
-        logAllWindows();
-    }
-
-    WindowFactory::~WindowFactory()
-    {
-        delete mLogWindow;
-        delete mObjectDescriptionWindow;
-        delete mJournalWindow;
-        delete mGameLogger;
-        delete mCharacterSheet;
-        delete mInGameMenuWindow;
-        delete mInventoryWindow;
-        delete mCharacterStateWindow;
-        //delete mInfoPopup;
-        delete mDebugWindow;
-        delete mConsole;
-        delete mMainMenuWindow;
-        delete mGameSettings;
-        delete mCombatWindow;
-    }
-
-    void WindowFactory::showCharacterActionChoice()
-    {
-        showActionChoice(UiSubsystem::getSingleton().getActiveCharacter());
-    }
-
-    void WindowFactory::showContainerContent(Container* container)
-    {
-        if( !mInventoryWindow )
-            toggleInventoryWindow();
-
-        mInventoryWindow-&gt;showContainerContent(container);
-    }
-
-    void WindowFactory::showMessageWindow(const CeGuiString&amp; message)
-    {
-        MessageWindow* w = new MessageWindow(&quot;&quot;, message, MessageWindow::OK);
-        w-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showMainMenu()
-    {
-        mMainMenuWindow-&gt;setVisible(true);
-    }
-
-    void WindowFactory::toggleConsole()
-    {
-        mConsole-&gt;setVisible(!mConsole-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleDebugWindow()
-    {
-        mDebugWindow-&gt;setVisible(!mDebugWindow-&gt;isVisible());
-    }
-
-    void WindowFactory::showPropertiesWindow(GameObject* obj)
-    {
-        PropertiesWindow* wnd = new PropertiesWindow(obj);
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showGameSaveLoadWindow()
-    {
-        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
-        wnd-&gt;initialize();
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
-    {
-		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
-        mMainMenuLoadWindow-&gt;initialize();
-        mMainMenuLoadWindow-&gt;setVisible(true);
-    }
-
-	void WindowFactory::hideMainMenuLoadWindow()
-    {
-		if(mMainMenuLoadWindow != NULL &amp;&amp; mMainMenuLoadWindow-&gt;isVisible())
-		{
-			mMainMenuLoadWindow-&gt;setVisible(false,true);
-			mMainMenuWindow = NULL;
-		}
-    }
-
-    void WindowFactory::toggleGameLogWindow()
-    {
-        mGameLogger-&gt;setVisible(!mGameLogger-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleInventoryWindow()
-    {
-        if (mInventoryWindow != NULL &amp;&amp; mInventoryWindow-&gt;isVisible())
-        {
-            mInventoryWindow-&gt;setVisible(false, true);
-            mInventoryWindow = NULL;
-        }
-        else
-        {
-            if (mInventoryWindow != NULL)
-            {
-                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
-                mInventoryWindow = NULL;
-            }
-
-            if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
-            {
-                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
-
-                Ogre::String inventoryWindowType = creat-&gt;getInventoryWindowType();
-                if (inventoryWindowType == &quot;&quot;)
-                {
-                    inventoryWindowType = &quot;inventory_default.xml&quot;; ///@TODO: Extract
-                }
-                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat-&gt;getInventory());
-                mInventoryWindow-&gt;setVisible(true);
-            }
-        }
-    }
-
-    void WindowFactory::notifyInventoryWindowDestroyed()
-    {
-        mInventoryWindow = NULL;
-    }
-
-	bool WindowFactory::isInventoryWindowDestroyed()
-	{
-		return mInventoryWindow == NULL;
-	}
-
-
-    void WindowFactory::showCharacterSheet()
-    {
-        if (mCharacterSheet-&gt;isVisible())
-        {
-            mCharacterSheet-&gt;setCharacter(NULL);
-            mCharacterSheet-&gt;setVisible(false);
-        }
-        else
-        {
-            mCharacterSheet-&gt;setCharacter(UiSubsystem::getSingleton().getActiveCharacter());
-            mCharacterSheet-&gt;setVisible(true);
-        }
-    }
-
-    void WindowFactory::showJournalWindow()
-    {
-        if (mJournalWindow-&gt;isVisible())
-        {
-            mJournalWindow-&gt;setVisible(false);
-        }
-        else
-        {
-            mJournalWindow-&gt;setVisible(true);
-        }
-    }
-
-    void WindowFactory::showAboutWindow()
-    {
-        (new AboutWindow())-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showCharacterSheet(Creature* chara)
-    {
-        if (!mCharacterSheet) 
-        {
-            mCharacterSheet = new CharacterSheetWindow();
-        }
-        mCharacterSheet-&gt;setCharacter(chara);
-        mCharacterSheet-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showDescriptionWindow(GameObject* obj)
-    {
-        (new GameObjectInfoWindow(obj, UiSubsystem::getSingleton().getActiveCharacter()))-&gt;setVisible(true);
-    }
-
-    void WindowFactory::toggleCharacterStateWindow()
-    {
-        mCharacterStateWindow-&gt;setVisible(!mCharacterStateWindow-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleInGameGlobalMenu()
-    {
-        mInGameMenuWindow-&gt;setVisible(!mInGameMenuWindow-&gt;isVisible());
-    }
-
-    GameLoggerWindow* WindowFactory::getGameLogger()
-    {
-        return mGameLogger;
-    }
-
-    void WindowFactory::showPlaylist()
-    {
-        PlaylistWindow* wnd = new PlaylistWindow();
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::checkForErrors()
-    {
-        if (Logger::getSingleton().isErrorPresent())
-        {
-            mLogWindow-&gt;setVisible(true);
-            Logger::getSingleton().resetErrorState();
-        }
-    }
-
-    void WindowFactory::update()
-    {
-        mInGameMenuWindow-&gt;update();
-    }
-
-    void WindowFactory::showExitConfirmation()
-    {
-        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
-        LOG_MESSAGE2(Logger::UI, &quot;Start&quot;, &quot;UiSubsystem::requestExit&quot;);
-        closeConfirmationWindow-&gt;setVisible(true);
-    }
-
-    void WindowFactory::writeToConsole(Ogre::String text)
-    {
-        if (mConsole != NULL)
-        {
-            mConsole-&gt;write(text);
-        }
-        else
-        {
-            LOG_MESSAGE(&quot;Console&quot;, text);
-        }
-    }
-
-    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
-    {
-        CeGuiString text = RubyInterpreter::val2ceguistr(str);
-
-        if (WindowFactory::getSingletonPtr() != NULL )
-        {
-            if (WindowFactory::getSingleton().mConsole != NULL)
-            {
-                WindowFactory::getSingleton().mConsole-&gt;
-                    write(text + &quot; \n&quot;);
-                return Qnil;
-            }
-        }
-        
-        LOG_MESSAGE(&quot;Console&quot;, text);
-        return Qnil;
-    }
-
-    void WindowFactory::setActiveCharacter(Creature* character)
-    {
-        mCharacterStateWindow-&gt;setCharacter(character);
-        if (mCharacterSheet) 
-        {
-            mCharacterSheet-&gt;setCharacter(character);
-        }
-
-        if (mInventoryWindow &amp;&amp; mInventoryWindow-&gt;isVisible())
-        {
-            toggleInventoryWindow();
-        }
-
-        LOG_MESSAGE(Logger::UI, &quot;CharacterStateWindow updated&quot;);
-    }
-
-    void WindowFactory::showActionChoice(GameObject* obj)
-    {
-        ActionChoiceWindow* w = new ActionChoiceWindow(UiSubsystem::getSingleton().getActiveCharacter());
-        int numActions = w-&gt;showActionsOfObject(obj);
-        if (numActions &gt; 0)
-        {
-            w-&gt;setVisible(true);
-        }
-        else
-        {
-            WindowManager::getSingleton().destroyWindow(w);
-        }
-    }
-
-    void WindowFactory::showLogfiles()
-    {
-        (new LogWindow())-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showPopupMessage(int popupTypes)
-    {
-        if (popupTypes &amp; WindowFactory::ICON_ERROR)
-        {
-            //mInfoPopup-&gt;showError();
-        }
-
-        if (popupTypes &amp; WindowFactory::ICON_QUEST)
-        {
-            //mInfoPopup-&gt;showQuestBookChange();
-        }
-    }
-
-    void WindowFactory::showObjectDescription(GameObject* object)
-    {
-        mObjectDescriptionWindow-&gt;show(object);
-    }
-
-    void WindowFactory::showNextDebugWindowPage()
-    {
-        mDebugWindow-&gt;showNextPage();
-    }
-
-    void WindowFactory::showGameSettings()
-    {
-        // Create the game settings window and show it
-        mGameSettings-&gt;setVisible(true);
-    }
-
-    void WindowFactory::logAllWindows()
-    {
-        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
-        CEGUI::uint count = rootWnd-&gt;getChildCount();
-        for (CEGUI::uint chIdx =  0; chIdx &lt; count; ++chIdx)
-        {
-            CEGUI::Window* wnd = rootWnd-&gt;getChildAtIdx(chIdx);
-            LOG_MESSAGE(
-                Logger::UI,
-                wnd-&gt;getName()
-                + (wnd-&gt;isVisible() ? &quot; vis&quot; : &quot; nvis&quot;)
-                + &quot; @&quot;
-                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_x)
-                + &quot;, &quot;
-                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_y)
-                + &quot; &quot;
-                + StringConverter::toString(wnd-&gt;getPixelSize().d_width)
-                + &quot;, &quot;
-                + StringConverter::toString(wnd-&gt;getPixelSize().d_height));
-        }
-    }
-
-    CombatWindow* WindowFactory::getCombatWindow()
-    {
-        if (mCombatWindow == NULL)
-        {
-            mCombatWindow = new CombatWindow();
-        }
-        return mCombatWindow;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;WindowFactory.h&quot;
+
+#include &quot;AboutWindow.h&quot;
+#include &quot;ActionChoiceWindow.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CharacterSheetWindow.h&quot;
+#include &quot;CharacterStateWindow.h&quot;
+#include &quot;CloseConfirmationWindow.h&quot;
+#include &quot;CombatWindow.h&quot;
+#include &quot;Console.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;DialogControlState.h&quot;
+#include &quot;DialogWindow.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameLoggerWindow.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;GameObjectInfoWindow.h&quot;
+#include &quot;GameOverWindow.h&quot;
+#include &quot;GameSaveLoadWindow.h&quot;
+#include &quot;GameSettings.h&quot;
+#include &quot;InfoPopup.h&quot;
+#include &quot;InGameMenuWindow.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;InventoryWindow.h&quot;
+#include &quot;JournalWindow.h&quot;
+#include &quot;LogWindow.h&quot;
+#include &quot;MessageWindow.h&quot;
+#include &quot;MainMenuLoadWindow.h&quot;
+#include &quot;MainMenuWindow.h&quot;
+#include &quot;MainMenuEngineWindow.h&quot;
+#include &quot;MovableText.h&quot;
+#include &quot;ObjectDescriptionWindow.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;PlaylistWindow.h&quot;
+#include &quot;PropertiesWindow.h&quot;
+#include &quot;QuestBook.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+#include &quot;SubtitleWindow.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowManager.h&quot;
+
+#undef max
+
+template&lt;&gt; rl::WindowFactory* Ogre::Singleton&lt;rl::WindowFactory&gt;::ms_Singleton = 0;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl {
+
+    WindowFactory::WindowFactory()
+        : mGameLogger(NULL),
+        mCharacterStateWindow(NULL),
+        mInGameMenuWindow(NULL),
+        mCharacterSheet(NULL),
+        mJournalWindow(NULL),
+        mInventoryWindow(NULL),
+        mLogWindow(NULL),
+        mDebugWindow(NULL),
+        mConsole(NULL),
+        mInfoPopup(NULL),
+        mObjectNameText(NULL),
+        mShownObject(NULL),
+        mObjectDescriptionWindow(NULL),
+        mMainMenuWindow(NULL),
+		mMainMenuLoadWindow(NULL),
+        mGameSettings(NULL),
+        mCombatWindow(NULL)
+    {
+    }
+
+    void WindowFactory::initialize()
+    {
+        mConsole = new Console();
+        mDebugWindow = new DebugWindow();
+        CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;
+            setOutputFunction(
+                (VALUE(*)(...))&amp;WindowFactory::consoleWrite );
+
+        mLogWindow = new LogWindow();
+
+        mGameLogger = new GameLoggerWindow();
+        mCharacterStateWindow = new CharacterStateWindow();
+        mInGameMenuWindow = new InGameMenuWindow();
+        mCharacterSheet = new CharacterSheetWindow();
+        mJournalWindow = new JournalWindow();
+        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
+        mObjectDescriptionWindow = new ObjectDescriptionWindow();
+        mGameSettings = new GameSettings();
+
+        RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mJournalWindow);
+        //RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mInfoPopup);
+        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+
+        logAllWindows();
+    }
+
+    WindowFactory::~WindowFactory()
+    {
+        delete mLogWindow;
+        delete mObjectDescriptionWindow;
+        delete mJournalWindow;
+        delete mGameLogger;
+        delete mCharacterSheet;
+        delete mInGameMenuWindow;
+        delete mInventoryWindow;
+        delete mCharacterStateWindow;
+        //delete mInfoPopup;
+        delete mDebugWindow;
+        delete mConsole;
+        delete mMainMenuWindow;
+        delete mGameSettings;
+        delete mCombatWindow;
+    }
+
+    void WindowFactory::showCharacterActionChoice()
+    {
+        showActionChoice(PartyManager::getSingleton().getActiveCharacter());
+    }
+
+    void WindowFactory::showContainerContent(Container* container)
+    {
+        if( !mInventoryWindow )
+            toggleInventoryWindow();
+
+        mInventoryWindow-&gt;showContainerContent(container);
+    }
+
+    void WindowFactory::showMessageWindow(const CeGuiString&amp; message)
+    {
+        MessageWindow* w = new MessageWindow(&quot;&quot;, message, MessageWindow::OK);
+        w-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showMainMenu()
+    {
+        mMainMenuWindow-&gt;setVisible(true);
+    }
+
+    void WindowFactory::toggleConsole()
+    {
+        mConsole-&gt;setVisible(!mConsole-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleDebugWindow()
+    {
+        mDebugWindow-&gt;setVisible(!mDebugWindow-&gt;isVisible());
+    }
+
+    void WindowFactory::showPropertiesWindow(GameObject* obj)
+    {
+        PropertiesWindow* wnd = new PropertiesWindow(obj);
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showGameSaveLoadWindow()
+    {
+        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
+        wnd-&gt;initialize();
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
+    {
+		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
+        mMainMenuLoadWindow-&gt;initialize();
+        mMainMenuLoadWindow-&gt;setVisible(true);
+    }
+
+	void WindowFactory::hideMainMenuLoadWindow()
+    {
+		if(mMainMenuLoadWindow != NULL &amp;&amp; mMainMenuLoadWindow-&gt;isVisible())
+		{
+			mMainMenuLoadWindow-&gt;setVisible(false,true);
+			mMainMenuWindow = NULL;
+		}
+    }
+
+    void WindowFactory::toggleGameLogWindow()
+    {
+        mGameLogger-&gt;setVisible(!mGameLogger-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleInventoryWindow()
+    {
+        if (mInventoryWindow != NULL &amp;&amp; mInventoryWindow-&gt;isVisible())
+        {
+            mInventoryWindow-&gt;setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
+
+            if (PartyManager::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = PartyManager::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat-&gt;getInventoryWindowType();
+                if (inventoryWindowType == &quot;&quot;)
+                {
+                    inventoryWindowType = &quot;inventory_default.xml&quot;; ///@TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat-&gt;getInventory());
+                mInventoryWindow-&gt;setVisible(true);
+            }
+        }
+    }
+
+    void WindowFactory::notifyInventoryWindowDestroyed()
+    {
+        mInventoryWindow = NULL;
+    }
+
+	bool WindowFactory::isInventoryWindowDestroyed()
+	{
+		return mInventoryWindow == NULL;
+	}
+
+
+    void WindowFactory::showCharacterSheet()
+    {
+        if (mCharacterSheet-&gt;isVisible())
+        {
+            mCharacterSheet-&gt;setCharacter(NULL);
+            mCharacterSheet-&gt;setVisible(false);
+        }
+        else
+        {
+            mCharacterSheet-&gt;setCharacter(PartyManager::getSingleton().getActiveCharacter());
+            mCharacterSheet-&gt;setVisible(true);
+        }
+    }
+
+    void WindowFactory::showJournalWindow()
+    {
+        if (mJournalWindow-&gt;isVisible())
+        {
+            mJournalWindow-&gt;setVisible(false);
+        }
+        else
+        {
+            mJournalWindow-&gt;setVisible(true);
+        }
+    }
+
+    void WindowFactory::showAboutWindow()
+    {
+        (new AboutWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showCharacterSheet(Creature* chara)
+    {
+        if (!mCharacterSheet) 
+        {
+            mCharacterSheet = new CharacterSheetWindow();
+        }
+        mCharacterSheet-&gt;setCharacter(chara);
+        mCharacterSheet-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showDescriptionWindow(GameObject* obj)
+    {
+        (new GameObjectInfoWindow(obj, PartyManager::getSingleton().getActiveCharacter()))-&gt;setVisible(true);
+    }
+
+    void WindowFactory::toggleCharacterStateWindow()
+    {
+        mCharacterStateWindow-&gt;setVisible(!mCharacterStateWindow-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleInGameGlobalMenu()
+    {
+        mInGameMenuWindow-&gt;setVisible(!mInGameMenuWindow-&gt;isVisible());
+    }
+
+    GameLoggerWindow* WindowFactory::getGameLogger()
+    {
+        return mGameLogger;
+    }
+
+    void WindowFactory::showPlaylist()
+    {
+        PlaylistWindow* wnd = new PlaylistWindow();
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::checkForErrors()
+    {
+        if (Logger::getSingleton().isErrorPresent())
+        {
+            mLogWindow-&gt;setVisible(true);
+            Logger::getSingleton().resetErrorState();
+        }
+    }
+
+    void WindowFactory::update()
+    {
+        mInGameMenuWindow-&gt;update();
+    }
+
+    void WindowFactory::showExitConfirmation()
+    {
+        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
+        LOG_MESSAGE2(Logger::UI, &quot;Start&quot;, &quot;UiSubsystem::requestExit&quot;);
+        closeConfirmationWindow-&gt;setVisible(true);
+    }
+
+    void WindowFactory::writeToConsole(Ogre::String text)
+    {
+        if (mConsole != NULL)
+        {
+            mConsole-&gt;write(text);
+        }
+        else
+        {
+            LOG_MESSAGE(&quot;Console&quot;, text);
+        }
+    }
+
+    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
+    {
+        CeGuiString text = RubyInterpreter::val2ceguistr(str);
+
+        if (WindowFactory::getSingletonPtr() != NULL )
+        {
+            if (WindowFactory::getSingleton().mConsole != NULL)
+            {
+                WindowFactory::getSingleton().mConsole-&gt;
+                    write(text + &quot; \n&quot;);
+                return Qnil;
+            }
+        }
+        
+        LOG_MESSAGE(&quot;Console&quot;, text);
+        return Qnil;
+    }
+
+    void WindowFactory::setActiveCharacter(Creature* character)
+    {
+        mCharacterStateWindow-&gt;setCharacter(character);
+        if (mCharacterSheet) 
+        {
+            mCharacterSheet-&gt;setCharacter(character);
+        }
+
+        if (mInventoryWindow &amp;&amp; mInventoryWindow-&gt;isVisible())
+        {
+            toggleInventoryWindow();
+        }
+
+        LOG_MESSAGE(Logger::UI, &quot;CharacterStateWindow updated&quot;);
+    }
+
+    void WindowFactory::showActionChoice(GameObject* obj)
+    {
+        ActionChoiceWindow* w = new ActionChoiceWindow(PartyManager::getSingleton().getActiveCharacter());
+        int numActions = w-&gt;showActionsOfObject(obj);
+        if (numActions &gt; 0)
+        {
+            w-&gt;setVisible(true);
+        }
+        else
+        {
+            WindowManager::getSingleton().destroyWindow(w);
+        }
+    }
+
+    void WindowFactory::showLogfiles()
+    {
+        (new LogWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showPopupMessage(int popupTypes)
+    {
+        if (popupTypes &amp; WindowFactory::ICON_ERROR)
+        {
+            //mInfoPopup-&gt;showError();
+        }
+
+        if (popupTypes &amp; WindowFactory::ICON_QUEST)
+        {
+            //mInfoPopup-&gt;showQuestBookChange();
+        }
+    }
+
+    void WindowFactory::showObjectDescription(GameObject* object)
+    {
+        mObjectDescriptionWindow-&gt;show(object);
+    }
+
+    void WindowFactory::showNextDebugWindowPage()
+    {
+        mDebugWindow-&gt;showNextPage();
+    }
+
+    void WindowFactory::showGameSettings()
+    {
+        // Create the game settings window and show it
+        mGameSettings-&gt;setVisible(true);
+    }
+    
+    void WindowFactory::showGameOverWindow()
+    {
+        (new GameOverWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::logAllWindows()
+    {
+        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
+        CEGUI::uint count = rootWnd-&gt;getChildCount();
+        for (CEGUI::uint chIdx =  0; chIdx &lt; count; ++chIdx)
+        {
+            CEGUI::Window* wnd = rootWnd-&gt;getChildAtIdx(chIdx);
+            LOG_MESSAGE(
+                Logger::UI,
+                wnd-&gt;getName()
+                + (wnd-&gt;isVisible() ? &quot; vis&quot; : &quot; nvis&quot;)
+                + &quot; @&quot;
+                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_x)
+                + &quot;, &quot;
+                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_y)
+                + &quot; &quot;
+                + StringConverter::toString(wnd-&gt;getPixelSize().d_width)
+                + &quot;, &quot;
+                + StringConverter::toString(wnd-&gt;getPixelSize().d_height));
+        }
+    }
+
+    CombatWindow* WindowFactory::getCombatWindow()
+    {
+        if (mCombatWindow == NULL)
+        {
+            mCombatWindow = new CombatWindow();
+        }
+        return mCombatWindow;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001567.html">[Dsa-hl-svn] r4510 - rl/trunk/engine/script/src
</A></li>
	<LI>Next message: <A HREF="001569.html">[Dsa-hl-svn] r4512 - in modules: aitest/scripts/maps	combattest/scripts combattest/scripts/maps common/scripts	kanalisation/scripts kanalisation/scripts/maps	persistenztest/scripts persistenztest/scripts/maps	regressiontest/scripts regressiontest/scripts/maps	ruchin/scripts ruchin/scripts/maps techdemo/scripts/maps	techdemo2/scripts techdemo2/scripts/maps teichtest/scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1568">[ date ]</a>
              <a href="thread.html#1568">[ thread ]</a>
              <a href="subject.html#1568">[ subject ]</a>
              <a href="author.html#1568">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
