<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4519 - in rl/branches/newton20: Mac	Mac/Rastullah.xcodeproj engine/common/include	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4519%20-%20in%20rl/branches/newton20%3A%20Mac%0A%09Mac/Rastullah.xcodeproj%20engine/common/include%0A%09engine/core/include%20engine/core/src%20engine/rules%0A%09engine/rules/include%20engine/rules/src%20engine/script/src%0A%09engine/script/swig%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200809190822.m8J8MoYH030513%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001575.html">
   <LINK REL="Next"  HREF="001577.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4519 - in rl/branches/newton20: Mac	Mac/Rastullah.xcodeproj engine/common/include	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui engine/ui/include engine/ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4519%20-%20in%20rl/branches/newton20%3A%20Mac%0A%09Mac/Rastullah.xcodeproj%20engine/common/include%0A%09engine/core/include%20engine/core/src%20engine/rules%0A%09engine/rules/include%20engine/rules/src%20engine/script/src%0A%09engine/script/swig%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200809190822.m8J8MoYH030513%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4519 - in rl/branches/newton20: Mac	Mac/Rastullah.xcodeproj engine/common/include	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui engine/ui/include engine/ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Fri Sep 19 10:22:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001575.html">[Dsa-hl-svn] r4518 - rl/trunk/engine/rules/src
</A></li>
        <LI>Next message: <A HREF="001577.html">[Dsa-hl-svn] r4520 - in rl/trunk/editors/Lockenwickler: . src	src/media src/media/icons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1576">[ date ]</a>
              <a href="thread.html#1576">[ thread ]</a>
              <a href="subject.html#1576">[ subject ]</a>
              <a href="author.html#1576">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2008-09-19 10:22:31 +0200 (Fri, 19 Sep 2008)
New Revision: 4519

Added:
   rl/branches/newton20/engine/rules/include/PartyManager.h
   rl/branches/newton20/engine/rules/src/PartyManager.cpp
   rl/branches/newton20/engine/ui/include/GameOverWindow.h
   rl/branches/newton20/engine/ui/src/GameOverWindow.cpp
Modified:
   rl/branches/newton20/Mac/Info.plist
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/engine/common/include/Property.h
   rl/branches/newton20/engine/core/include/SaveAble.h
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/SaveAble.cpp
   rl/branches/newton20/engine/rules/RlRules2005.vcproj
   rl/branches/newton20/engine/rules/include/Effect.h
   rl/branches/newton20/engine/rules/include/EffectManager.h
   rl/branches/newton20/engine/rules/include/GameObjectManager.h
   rl/branches/newton20/engine/rules/include/Makefile.am
   rl/branches/newton20/engine/rules/include/RulesMessages.h
   rl/branches/newton20/engine/rules/include/RulesSubsystem.h
   rl/branches/newton20/engine/rules/src/Creature.cpp
   rl/branches/newton20/engine/rules/src/Effect.cpp
   rl/branches/newton20/engine/rules/src/EffectManager.cpp
   rl/branches/newton20/engine/rules/src/GameObjectManager.cpp
   rl/branches/newton20/engine/rules/src/Makefile.am
   rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp
   rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp
   rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/newton20/engine/script/src/SceneManager.cpp
   rl/branches/newton20/engine/script/src/ZoneProcessor.cpp
   rl/branches/newton20/engine/script/swig/RlRules.head.swig
   rl/branches/newton20/engine/script/swig/RlRules.swig
   rl/branches/newton20/engine/script/swig/RlUi.swig
   rl/branches/newton20/engine/ui/RlUI2005.vcproj
   rl/branches/newton20/engine/ui/include/Makefile.am
   rl/branches/newton20/engine/ui/include/UiMessages.h
   rl/branches/newton20/engine/ui/include/UiSubsystem.h
   rl/branches/newton20/engine/ui/include/WindowFactory.h
   rl/branches/newton20/engine/ui/src/DebugWindow.cpp
   rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp
   rl/branches/newton20/engine/ui/src/InputManager.cpp
   rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp
   rl/branches/newton20/engine/ui/src/Makefile.am
   rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
   rl/branches/newton20/engine/ui/src/WindowFactory.cpp
Log:
merged changes from trunk


Modified: rl/branches/newton20/Mac/Info.plist
===================================================================
--- rl/branches/newton20/Mac/Info.plist	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/Mac/Info.plist	2008-09-19 08:22:31 UTC (rev 4519)
@@ -19,7 +19,7 @@
 	&lt;key&gt;CFBundleSignature&lt;/key&gt;
 	&lt;string&gt;????&lt;/string&gt;
 	&lt;key&gt;CFBundleVersion&lt;/key&gt;
-	&lt;string&gt;1.0&lt;/string&gt;
+	&lt;string&gt;0.3&lt;/string&gt;
 	&lt;key&gt;CSResourcesFileMapped&lt;/key&gt;
 	&lt;true/&gt;
 &lt;/dict&gt;

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -613,8 +613,13 @@
 		485B895A0E15796500D5B19C /* Scene.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89570E15796500D5B19C /* Scene.cpp */; };
 		485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89580E15796500D5B19C /* SceneLoader.cpp */; };
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
+		487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029C60E80DCEA00B66388 /* GameOverWindow.h */; };
+		487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029C80E80DCF900B66388 /* GameOverWindow.cpp */; };
+		487029E80E80E12200B66388 /* PartyManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029E70E80E12200B66388 /* PartyManager.h */; };
+		487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029E90E80E13300B66388 /* PartyManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -664,7 +669,6 @@
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
 		48B0B0490E65BBB30023B198 /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
 		48B0B04A0E65BBC10023B198 /* libfmodex.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
-		48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8D0C4E960486CD37000505A6 /* Info.plist */; };
 		48B772DD0D58350B000A3B97 /* XmlProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DA0D58350B000A3B97 /* XmlProcessor.h */; };
 		48B772DE0D58350B000A3B97 /* XmlPropertyReader.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DB0D58350B000A3B97 /* XmlPropertyReader.h */; };
 		48B772DF0D58350B000A3B97 /* XmlPropertyWriter.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DC0D58350B000A3B97 /* XmlPropertyWriter.h */; };
@@ -853,6 +857,7 @@
 			dstPath = &quot;&quot;;
 			dstSubfolderSpec = 10;
 			files = (
+				487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */,
 				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
@@ -884,7 +889,7 @@
 		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
 		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
 		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
-		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = &quot;RlScript-Info.plist&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };
+		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = &quot;RlScript-Info.plist&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
 		444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractMapNodeProcessor.cpp; path = ../engine/script/src/AbstractMapNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
@@ -1442,9 +1447,14 @@
 		485B89570E15796500D5B19C /* Scene.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Scene.cpp; path = ../engine/script/src/Scene.cpp; sourceTree = SOURCE_ROOT; };
 		485B89580E15796500D5B19C /* SceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneLoader.cpp; path = ../engine/script/src/SceneLoader.cpp; sourceTree = SOURCE_ROOT; };
 		485B89590E15796500D5B19C /* SceneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneManager.cpp; path = ../engine/script/src/SceneManager.cpp; sourceTree = SOURCE_ROOT; };
+		487029C60E80DCEA00B66388 /* GameOverWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameOverWindow.h; path = ../engine/ui/include/GameOverWindow.h; sourceTree = SOURCE_ROOT; };
+		487029C80E80DCF900B66388 /* GameOverWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameOverWindow.cpp; path = ../engine/ui/src/GameOverWindow.cpp; sourceTree = SOURCE_ROOT; };
+		487029E70E80E12200B66388 /* PartyManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PartyManager.h; path = ../engine/rules/include/PartyManager.h; sourceTree = SOURCE_ROOT; };
+		487029E90E80E13300B66388 /* PartyManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PartyManager.cpp; path = ../engine/rules/src/PartyManager.cpp; sourceTree = SOURCE_ROOT; };
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
@@ -1687,9 +1697,8 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
-				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
+				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
 				195DF8CFFE9D517E11CA2CBB /* Products */,
@@ -1701,10 +1710,10 @@
 			isa = PBXGroup;
 			children = (
 				48CFBFD60E2E87A800CD0C51 /* Scripts */,
-				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC220BD0E3E000C6D4A0 /* RlAi */,
 				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
 				444EAB200BD0E27400C6D4A0 /* RlCore */,
+				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC590BD0E50600C6D4A0 /* RlRules */,
 				444EAE600BD0E66500C6D4A0 /* RlScript */,
 				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
@@ -1716,7 +1725,6 @@
 		20286C2CFDCF999611CA2CEA /* Resources */ = {
 			isa = PBXGroup;
 			children = (
-				48D401810D9E483200AE5340 /* modules */,
 				440786120C09D602006E496D /* RlScript-Info.plist */,
 				8D0C4E960486CD37000505A6 /* Info.plist */,
 				0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */,
@@ -1728,6 +1736,9 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				487750AF0E7E3C9C0018216B /* Cg.framework */,
+				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
+				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
 				484FE6B90E17BC8800FA880F /* Carbon.framework */,
 				48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */,
@@ -2055,6 +2066,8 @@
 		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
 			isa = PBXGroup;
 			children = (
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
 				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
 				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
@@ -2167,9 +2180,12 @@
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				487029E90E80E13300B66388 /* PartyManager.cpp */,
+				487029E70E80E12200B66388 /* PartyManager.h */,
 				4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */,
 				4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */,
 				4890C0CB0E18062B00BE5850 /* JogMovement.cpp */,
+				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */,
 				4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */,
 				4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */,
@@ -2226,7 +2242,6 @@
 				483D311B0D85B215003477A0 /* Kampfaktion.h */,
 				483D311C0D85B215003477A0 /* RulesConstants.h */,
 				483D31160D85B215003477A0 /* EffectManagementTask.h */,
-				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				44D8145B0BF7B52600534175 /* Selector.h */,
 				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
 				444826040BF7B37D00C5A94F /* Selector.cpp */,
@@ -2708,6 +2723,7 @@
 				4890C0C60E18061300BE5850 /* StrafeMovement.h in Headers */,
 				4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */,
 				4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */,
+				487029E80E80E12200B66388 /* PartyManager.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2769,6 +2785,7 @@
 				48389B9B0D86743900AFAB66 /* GameSaveLoadWindow.h in Headers */,
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
+				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3046,7 +3063,6 @@
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
-				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
 				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -3305,6 +3321,7 @@
 				4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */,
 				4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */,
 				4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */,
+				487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3363,6 +3380,7 @@
 				48389B930D86741F00AFAB66 /* GameSaveLoadWindow.cpp in Sources */,
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
+				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/engine/common/include/Property.h
===================================================================
--- rl/branches/newton20/engine/common/include/Property.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/common/include/Property.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -87,6 +87,7 @@
         PropertyMethod(Bool, const bool&amp;);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&amp;);
+        PropertyMethod(Long, const RL_LONGLONG&amp;);
         PropertyMethod(Real, const Ogre::Real&amp;);
         PropertyMethod(Vector3, const Ogre::Vector3&amp;);
         PropertyMethod(Quaternion, const Ogre::Quaternion&amp;);

Modified: rl/branches/newton20/engine/core/include/SaveAble.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -12,4 +12,30 @@
  *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
\ No newline at end of file
+ */
+
+
+/// Basis jedes Objektes im Spiel, welches ver&#228;nderlich ist und einen abspeicherbaren Status haben soll
+
+#ifndef __SaveAble_H__
+#define __SaveAble_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;Properties.h&quot;
+
+namespace rl
+{
+
+	class SaveAble : public PropertyHolder
+	{
+	public:
+		void setSaveAble(bool enable);
+		bool isSaveAble();
+	protected:
+		bool mIsSaveAble;
+	};
+
+}
+
+
+#endif
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -124,8 +124,6 @@
         addSetting(&quot;MovementController keys&quot;, &quot;reset_camera&quot;, &quot;0 (Nummernblock)&quot;);
 
         addSetting(&quot;Localization&quot;, &quot;language&quot;, &quot;de&quot;);
-
-        setRastullahCfgPath();
     }
 
     ConfigurationManager::~ConfigurationManager()
@@ -187,6 +185,7 @@
 
     void ConfigurationManager::loadConfig()
     {
+        setRastullahCfgPath();
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
         fs::path rastullahCfgDirectory(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
@@ -265,6 +264,8 @@
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
             mModulesRootDirectory = RL_MODULEDIR;
+#           elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+            mModulesRootDirectory = mExecutablePath + &quot;/../Resources/modules&quot;;
 #           else
             mModulesRootDirectory = &quot;./modules&quot;;
 #           endif
@@ -388,8 +389,8 @@
 	void ConfigurationManager::setExecutable(const Ogre::String&amp; path)
 	{
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		
 		mExecutablePath = exeAbsolute.remove_leaf().string();
+        std::cout &lt;&lt; &quot;ConfigurationManager&quot; &lt;&lt; &quot;Executable is &quot; &lt;&lt; path &lt;&lt; &quot; &quot; &lt;&lt; mExecutablePath;
 	}
 
 	const Ogre::String&amp; ConfigurationManager::getExecutablePath() const
@@ -436,20 +437,23 @@
 
     bool ConfigurationManager::checkForFile(const Ogre::String&amp; filename)
     {
-        try {
+        try 
+        {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename);
+			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename) &lt;&lt; std::endl;
             if (fs::exists(filename))
 #           else
 			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; 
-				fs::complete(fs::path(filename, fs::portable_posix_name)).string();
+				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
+                 &lt;&lt; std::endl;
 			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
 #           endif
             {
                 return true;
             }
         }
-        catch (fs::filesystem_error&amp;) {
+        catch (fs::filesystem_error&amp;) 
+        {
             return false;
         }
 

Modified: rl/branches/newton20/engine/core/src/SaveAble.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -21,11 +21,15 @@
 #include &quot;Property.h&quot;
 #include &quot;Properties.h&quot;
 
-class SaveAble
+namespace rl
 {
-public:
-    void setSaveAble(bool enable);
-    bool isSaveAble();
-protected:
-    bool mIsSaveAble;
-};
\ No newline at end of file
+	void SaveAble::setSaveAble(bool enable)
+	{
+		mIsSaveAble = true;
+	}
+
+	bool SaveAble::isSaveAble()
+	{
+		return mIsSaveAble;
+	}
+}
\ No newline at end of file

Modified: rl/branches/newton20/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/newton20/engine/rules/RlRules2005.vcproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/RlRules2005.vcproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -407,6 +407,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\PartyManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\Quest.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -709,6 +713,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\PartyManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\Quest.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/branches/newton20/engine/rules/include/Effect.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Effect.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/Effect.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -80,13 +80,17 @@
             QUANTIFIER_UNIQUE_BUT_CUMULATIVE
         };
 
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_STUFE;
+        static const Ogre::String PROPERTY_ENABLED;
 
+
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);
         virtual ~Effect() {}
 
-        const CeGuiString getName() const;
-        void setName(CeGuiString name);
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
         const CeGuiString getDescription() const;
         void setDescription(CeGuiString description);
         /// @see Quantifier
@@ -131,7 +135,7 @@
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
         virtual PropertyKeys getAllPropertyKeys() const;
 	protected:
-		CeGuiString mName;
+		Ogre::String mName;
 		CeGuiString mDescription;
 		/// Dauer desEffekts in Aktionen.
 		int mStufe;

Modified: rl/branches/newton20/engine/rules/include/EffectManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/EffectManager.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/EffectManager.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,121 +1,130 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __EFFECTMANAGER_H__
-#define __EFFECTMANAGER_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;set&gt;
-
-#include &quot;Date.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-    class GameObject;
-
-    /**
-     * @brief Manages the effects affecting a game object
-     * 
-     * This class manages all effects applied to a game object.
-     * Each game object has a seperate EffectManager. The method checkEffects()
-     * should be called every Aktion (the dark eye time unit)
-     **/
-
-	class _RlRulesExport EffectManager
-	{
-	public:
-		EffectManager(GameObject* gameobject);
-		~EffectManager();
-
-        /**
-         *  Checks effects for changes.
-         **/
-		void checkEffects();
-        /** 
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  in welcher Zeit er wieder ueberprueft werden muss.
-         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException time parameter is &lt;= 0
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheckDate Date
-         **/
-        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
-        /**
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
-         *  @param date Das Datum der naechsten Ueberpruefung.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException date lies in the past
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheck, Date
-         **/
-        void addDateCheck(RL_LONGLONG date, Effect* effect);
-        /**
-         * Fuegt einen neuen Effekt in die Liste ein.
-         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
-         **/
-		void addEffect(Effect* effect);
-        
-        /// Removes effects by pointer.
-        void removeEffect(Effect* effect);
-
-        /// Removes effects by name.
-        void removeEffect(CeGuiString name);
-        
-        /**
-         * Checks the effects for the given status.
-         **/
-        Effect::LifeState getLifeState();
-        
-        /**
-         * Returns the specified modificator.
-         * @param target specifies what modificator you want to get (e.g. &quot;Athletik&quot;)
-         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
-         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
-         **/
-        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-        /**
-         * Returns a printable list of all effects
-         **/
-        CeGuiString getEffects();
-
-        void checkStateChange(Effect::LifeState oldState);
-
-	private:
-
-        GameObject* mGameObject;
-
-        // only used in checkEffects!
-        bool mCheckEffectsRunning;
-
-        /// Eine einfache Menge von Effekten
-		typedef std::set&lt;Effect*&gt; Effects;
-		Effects mEffects;
-        /**
-         * Eine Liste die wiedergibt, wann welcher Effekt
-         * ueberprueft werden muss.
-         **/
-        typedef std::map&lt;RL_LONGLONG, Effects&gt; Checklist;
-        Checklist mChecklist;
-	};
-}
-
-#endif //__EFFECTMANAGER_H__
-		
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __EFFECTMANAGER_H__
+#define __EFFECTMANAGER_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &lt;set&gt;
+
+#include &quot;Date.h&quot;
+#include &quot;Effect.h&quot;
+
+namespace rl
+{
+    class GameObject;
+
+    /**
+     * @brief Manages the effects affecting a game object
+     * 
+     * This class manages all effects applied to a game object.
+     * Each game object has a seperate EffectManager. The method checkEffects()
+     * should be called every Aktion (the dark eye time unit)
+     **/
+
+    class _RlRulesExport EffectManager : public PropertyHolder
+	{
+	public:
+    
+        static const Ogre::String PROPERTY_TIMECHECK;
+        static const Ogre::String PROPERTY_TIME;
+        static const Ogre::String PROPERTY_EFFECT;
+        
+		EffectManager(GameObject* gameobject);
+		~EffectManager();
+
+        /**
+         *  Checks effects for changes.
+         **/
+		void checkEffects();
+        /** 
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  in welcher Zeit er wieder ueberprueft werden muss.
+         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException time parameter is &lt;= 0
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheckDate Date
+         **/
+        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
+        /**
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
+         *  @param date Das Datum der naechsten Ueberpruefung.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException date lies in the past
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheck, Date
+         **/
+        void addDateCheck(RL_LONGLONG date, Effect* effect);
+        /**
+         * Fuegt einen neuen Effekt in die Liste ein.
+         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
+         **/
+		void addEffect(Effect* effect);
+        
+        /// Removes effects by pointer.
+        void removeEffect(Effect* effect);
+
+        /// Removes effects by name.
+        void removeEffect(CeGuiString name);
+        
+        /**
+         * Checks the effects for the given status.
+         **/
+        Effect::LifeState getLifeState();
+        
+        /**
+         * Returns the specified modificator.
+         * @param target specifies what modificator you want to get (e.g. &quot;Athletik&quot;)
+         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
+         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
+         **/
+        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+        /**
+         * Returns a printable list of all effects
+         **/
+        CeGuiString getEffects();
+
+        void checkStateChange(Effect::LifeState oldState);
+
+        virtual const Property getProperty(const CeGuiString&amp; key) const;
+        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+	private:
+
+        GameObject* mGameObject;
+
+        // only used in checkEffects!
+        bool mCheckEffectsRunning;
+
+        /// Eine einfache Menge von Effekten
+		typedef std::vector&lt;Effect*&gt; Effects;
+		Effects mEffects;
+        /**
+         * Eine Liste die wiedergibt, wann welcher Effekt
+         * ueberprueft werden muss.
+         **/
+        typedef std::map&lt;RL_LONGLONG, Effects&gt; Checklist;
+        Checklist mChecklist;
+	};
+}
+
+#endif //__EFFECTMANAGER_H__
+		

Modified: rl/branches/newton20/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/GameObjectManager.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/GameObjectManager.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -42,8 +42,7 @@
     class _RlRulesExport GameObjectManager : 
         public Ogre::Singleton&lt;GameObjectManager&gt;,
         public GameObjectStateListener,
-        public Ogre::ScriptLoader,
-        public SaveGameData
+        public Ogre::ScriptLoader
     {
     public:
         GameObjectManager();
@@ -74,14 +73,6 @@
         void registerGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterAllGameObjectStateListener();
-
-        /// Override from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;
     private:
         typedef std::map&lt;const CeGuiString, PropertyRecordPtr&gt; ClassPropertyMap;
         typedef std::set&lt;GameObjectStateListener*&gt; GameObjectStateListenerSet;

Modified: rl/branches/newton20/engine/rules/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/rules/include/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -31,6 +31,7 @@
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
 	ObjectStateChangeListener.h \
+	PartyManager.h \
 	Quest.h \
 	QuestBook.h \
 	QuestEvent.h \

Copied: rl/branches/newton20/engine/rules/include/PartyManager.h (from rev 4518, rl/trunk/engine/rules/include/PartyManager.h)

Modified: rl/branches/newton20/engine/rules/include/RulesMessages.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesMessages.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/RulesMessages.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,75 +1,101 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Rl_RulesMessages_H__
-#define __Rl_RulesMessages_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;MessageType.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;CoreMessages.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-	class Combatant;
-	class GameObject;
-
-	/// 0x03xxxxxx as mask for rules messages
-    enum RulesMessageTypeIds
-    {
-        // Game event log //
-        // Mask
-        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
-        // Events
-        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
-
-		// Combat
-		// Mask
-		RLMSG_COMBAT_EVENTS = 0x03000200,
-		// Events
-		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
-		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
-		RLMSG_COMBAT_ENDED = 0x03000210,
-
-		// Game object related events
-        // Mask
-        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
-        // Events
-        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301
-    };
-
-    /// Message sent right after a new game log event has been added.
-	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
-		MessageType_GameEventLog_EventAdded;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
-		MessageType_CombatOpponentEntered;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
-		MessageType_CombatOpponentLeft;
-
-    typedef MessageType&lt;RLMSG_COMBAT_ENDED, bool&gt;
-		MessageType_CombatEnded;
-
-    typedef MessageType&lt;RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState&gt;
-		MessageType_GameObjectLifeStateChanged;
-    
-    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_RulesMessages_H__
+#define __Rl_RulesMessages_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;MessageType.h&quot;
+#include &quot;RulesConstants.h&quot;
+#include &quot;CoreMessages.h&quot;
+#include &quot;Effect.h&quot;
+
+namespace rl
+{
+	class Combatant;
+    class Creature;
+	class GameObject;
+
+	/// 0x03xxxxxx as mask for rules messages
+    enum RulesMessageTypeIds
+    {
+        // Game event log //
+        // Mask
+        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
+        // Events
+        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
+
+		// Combat
+		// Mask
+		RLMSG_COMBAT_EVENTS = 0x03000200,
+		// Events
+		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
+		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
+		RLMSG_COMBAT_ENDED = 0x03000210,
+
+		// Game object related events
+        // Mask
+        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
+        // Events
+        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301,
+        
+        // Player character related events
+        // Mask
+        RLMSG_PLAYERCHAR_EVENTS = 0x03000400,
+        // Events
+        RLMSG_PLAYERCHAR_DIED = 0x03000401,
+        RLMSG_PLAYERCHAR_ALL_DIED = 0x03000402,
+        RLMSG_PLAYERCHAR_ADDED = 0x03000403,
+        RLMSG_PLAYERCHAR_REMOVED = 0x03000404,
+        RLMSG_PLAYERCHAR_ACTIVE_CHANGED = 0x03000405        
+    };
+
+    /// Message sent right after a new game log event has been added.
+	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
+		MessageType_GameEventLog_EventAdded;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
+		MessageType_CombatOpponentEntered;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
+		MessageType_CombatOpponentLeft;
+
+    typedef MessageType&lt;RLMSG_COMBAT_ENDED, bool&gt;
+		MessageType_CombatEnded;
+
+    typedef MessageType&lt;RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState&gt;
+		MessageType_GameObjectLifeStateChanged;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
+    
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_DIED, Creature*&gt;
+        MessageType_PlayerCharDied;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ADDED, Creature*&gt;
+        MessageType_PlayerCharAdded;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_REMOVED, Creature*&gt;
+        MessageType_PlayerCharRemoved;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ACTIVE_CHANGED, Creature*, Creature*&gt;
+        MessageType_ActivePlayerCharChanged;
+
+    typedef MessageType&lt;RLMSG_PLAYERCHAR_ALL_DIED&gt;
+        MessageType_AllPlayerCharsDied;
+
+}
+#endif

Modified: rl/branches/newton20/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesSubsystem.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/RulesSubsystem.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -31,6 +31,7 @@
 	class GameEventLog;
     class GlobalProperties;
 	class QuestBook;
+    class PartyManager;
     class XdimlLoader;
 
 	class _RlRulesExport RulesSubsystem : public Ogre::Singleton&lt;RulesSubsystem&gt;
@@ -52,6 +53,7 @@
         XdimlLoader* mXdimlLoader;
         GlobalProperties* mGlobalProperties;
         EffectManagementTask* mEffectManagementTask;
+        PartyManager* mPartyManager;
     };
 }
 

Modified: rl/branches/newton20/engine/rules/src/Creature.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Creature.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Creature.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1066,10 +1066,10 @@
         {
             mErschoepfung = value.toInt();
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager-&gt;setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             mEigenschaften.clear();
@@ -1161,10 +1161,10 @@
         {
             return Property(mErschoepfung);
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    return Property(mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS));
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager-&gt;getProperty(Creature::PROPERTY_EFFECTS);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
@@ -1237,7 +1237,7 @@
         keys.insert(Creature::PROPERTY_CURRENT_AE);
         keys.insert(Creature::PROPERTY_CURRENT_AU);
         keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        //keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EFFECTS);
         keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
         keys.insert(Creature::PROPERTY_TALENTE);
         keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);

Modified: rl/branches/newton20/engine/rules/src/Effect.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Effect.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Effect.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,132 +1,172 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Effect.h&quot;
-#include &quot;DsaManager.h&quot;
-
-namespace rl
-{
-
-	Effect::Effect(int stufe)
-	{
-		mStufe = stufe;
-		mQuantifier = QUANTIFIER_MULTIPLE;
-	}
-
-	const CeGuiString Effect::getName() const
-	{
-		return mName;
-	}
-
-	void Effect::setName(CeGuiString name)
-	{
-		mName = name;
-	}
-
-	const CeGuiString Effect::getDescription() const
-	{
-		return mDescription;
-	}
-
-	void Effect::setDescription(CeGuiString description)
-	{
-		mDescription = description;
-	}
-
-    Effect::Quantifier Effect::getQuantifier()
-	{
-		return mQuantifier;
-	}
-
-	void Effect::setQuantifier(Quantifier quantifier)
-	{
-		mQuantifier = quantifier;
-	}
-
-
-	const int Effect::getStufe()
-	{
-		return mStufe;
-	}
-
-	void Effect::increaseStufe()
-	{
-	}
-
-	void Effect::decreaseStufe()
-	{
-	}
-
-	void Effect::enable()
-	{
-		if (!mEnabled)
-		{
-			mEnabled = true;
-		}
-	}
-
-	void Effect::disable()
-	{
-		if (mEnabled)
-		{
-			mEnabled = false;
-		}
-	}
-
-    RL_LONGLONG Effect::timeCheck()
-    {
-      return PERMANENT;
-    }
-
-	Effect::LifeState Effect::getLifeState() const
-    {
-      // should be overlaoaded in the specific derivated effects.
-      return LS_NONE;
-    }
-
-    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
-    {
-        return 0;
-    }
-
-    const Property Effect::getProperty(const CeGuiString&amp; key) const
-    {
-        //else
-        //{
-            Throw(
-                IllegalArgumentException, 
-                key + &quot; is not a property of this effect (&quot; + mName + &quot;)&quot;);
-        //}
-    }
-
-    void Effect::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        // else
-        //{
-            LOG_WARNING(
-                Logger::RULES,
-                key + &quot; is not a property of this Effect (&quot;+mName+&quot;)&quot;);
-        //}
-    }
-
-    PropertyKeys Effect::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Effect.h&quot;
+#include &quot;DsaManager.h&quot;
+
+namespace rl
+{
+    const Ogre::String Effect::PROPERTY_NAME = &quot;name&quot;;
+    const Ogre::String Effect::PROPERTY_STUFE = &quot;stufe&quot;;
+    const Ogre::String Effect::PROPERTY_ENABLED = &quot;enabled&quot;;    
+
+	Effect::Effect(int stufe)
+	{
+		mStufe = stufe;
+		mQuantifier = QUANTIFIER_MULTIPLE;
+	}
+
+	const Ogre::String Effect::getName() const
+	{
+		return mName;
+	}
+
+	void Effect::setName(Ogre::String name)
+	{
+		mName = name;
+	}
+
+	const CeGuiString Effect::getDescription() const
+	{
+		return mDescription;
+	}
+
+	void Effect::setDescription(CeGuiString description)
+	{
+		mDescription = description;
+	}
+
+    Effect::Quantifier Effect::getQuantifier()
+	{
+		return mQuantifier;
+	}
+
+	void Effect::setQuantifier(Quantifier quantifier)
+	{
+		mQuantifier = quantifier;
+	}
+
+
+	const int Effect::getStufe()
+	{
+		return mStufe;
+	}
+
+	void Effect::increaseStufe()
+	{
+	}
+
+	void Effect::decreaseStufe()
+	{
+	}
+
+	void Effect::enable()
+	{
+		if (!mEnabled)
+		{
+			mEnabled = true;
+		}
+	}
+
+	void Effect::disable()
+	{
+		if (mEnabled)
+		{
+			mEnabled = false;
+		}
+	}
+
+    RL_LONGLONG Effect::timeCheck()
+    {
+        return PERMANENT;
+    }
+
+	Effect::LifeState Effect::getLifeState() const
+    {
+        // should be overlaoaded in the specific derivated effects.
+        return LS_NONE;
+    }
+
+    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
+    {
+        return 0;
+    }
+
+    const Property Effect::getProperty(const CeGuiString&amp; key) const
+    {
+        Property prop;
+        if (key == Effect::PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == Effect::PROPERTY_STUFE)
+        {
+            prop.setValue(mStufe);
+        }
+        else if (key == Effect::PROPERTY_ENABLED)
+        {
+            prop.setValue(mEnabled);
+        }
+        else
+        {
+            Throw(
+                IllegalArgumentException, 
+                key + &quot; is not a property of this effect (&quot; + mName + &quot;)&quot;);
+        }
+        return prop;
+    }
+
+    void Effect::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        try
+        {
+            if (key == Effect::PROPERTY_NAME)
+            {
+                mName = value.toString().c_str();
+            }
+            else if (key == Effect::PROPERTY_STUFE)
+            {
+                mStufe = value.toInt();
+            }
+            else if (key == Effect::PROPERTY_ENABLED)
+            {
+                mEnabled = value.toBool();
+            }
+            else
+            {
+                LOG_WARNING(
+                    Logger::RULES,
+                    key + &quot; is not a property of this Effect (&quot; + mName + &quot;)&quot;);
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;property &quot; + key + &quot; has the wrong format: &quot; + ex.getMessage());
+        }
+    }
+
+    PropertyKeys Effect::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Effect::PROPERTY_NAME);
+        keys.insert(Effect::PROPERTY_STUFE);
+        return keys;
+    }
+
+}

Modified: rl/branches/newton20/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/EffectManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/EffectManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,210 +1,328 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;EffectManager.h&quot;
-
-#include &lt;sstream&gt;
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-
-namespace rl
-{
-	EffectManager::EffectManager(GameObject* gameobject)
-        : mGameObject(gameobject),
-        mCheckEffectsRunning(false)
-	{
-	}
-
-	EffectManager::~EffectManager()
-	{
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			//delete (*it);
-            ScriptWrapper::getSingleton().disowned(*it);
-		}
-	}
-
-	void EffectManager::checkEffects()
-	{
-            if( mCheckEffectsRunning )
-                return;
-            mCheckEffectsRunning = true;
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        Checklist::iterator checkIt = mChecklist.begin();
-        if (checkIt == mChecklist.end()) return;
-        while ( checkIt != mChecklist.end() &amp;&amp; checkIt-&gt;first &lt;= now )
-        {
-				std::stringstream debugInfo;
-				debugInfo &lt;&lt; &quot;Effect check: &quot; &lt;&lt; checkIt-&gt;first &lt;&lt; &quot; now: &quot; &lt;&lt; now &lt;&lt; std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-            for (Effects::iterator effIt = checkIt-&gt;second.begin(); effIt != checkIt-&gt;second.end(); effIt++)
-            {
-                int nextCheck;
-                nextCheck = (*effIt)-&gt;timeCheck();
-                switch (nextCheck)
-                {
-                  case Effect::REMOVE:
-                    removeEffect(*effIt);
-                    break;
-                  case Effect::PERMANENT:
-                    break;
-                  default:
-                    addTimeCheck(nextCheck, *effIt);
-                }
-            }
-            mChecklist.erase(checkIt++);
-        }
-
-        mCheckEffectsRunning = false;
-	}
-
-    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
-    {
-        // Preconditions: time &gt; 0, effect != NULL
-        if (time &lt;= 0) Throw(IllegalArgumentException, &quot;time parameter is &lt;= 0!&quot;);
-        if (effect == NULL) Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
-        // Get current ingame time and add timeUntilCheck
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        RL_LONGLONG timeForCheck = now + timeUntilCheck;
-				std::stringstream debugInfo;
-				debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; timeForCheck &lt;&lt; std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-        // Insert Sum and effect into the checklist
-        mChecklist[timeForCheck].insert(effect);
-    }
-
-    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
-    {
-        // Preconditions: date &gt; now, effect != NULL
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        if (date &lt;= now) Throw(IllegalArgumentException, &quot;date lies in the past!&quot;);
-        if (effect == NULL) Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
-        // Insert date and effect into the checklist
-				std::stringstream debugInfo;
-				debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; date &lt;&lt; std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-        mChecklist[date].insert(effect);
-    }
-
-
-	void EffectManager::addEffect(Effect* effect)
-	{
-        Effect::LifeState oldState = getLifeState();
-
-        LOG_DEBUG(Logger::RULES, &quot;Adding effect &quot; + effect-&gt;getName());
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			if ((*it)-&gt;getName() == effect-&gt;getName())
-			{
-				if ((*it)-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE) return;
-				if ((*it)-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
-				{
-					//TODO
-					//Vielleicht alten durch neuen ersetzen?
-					//oder (*it)-&gt;setDuration(effect-&gt;getDuration())
-				}
-				if ((*it)-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
-				{
-					for (int i = 0; i &lt; effect-&gt;getStufe(); i++)
-						(*it)-&gt;increaseStufe();
-				}
-			}
-		}
-        ScriptWrapper::getSingleton().owned(effect);
-		mEffects.insert(effect);
-		effect-&gt;enable();
-
-        checkStateChange(oldState);
-	}
-
-    void EffectManager::removeEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-    
-        effect-&gt;disable();
-        mEffects.erase(effect);
-        ScriptWrapper::getSingleton().disowned(effect);
-        ///@todo also remove from the check lists?
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(CeGuiString name)
-    {
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-            if ((*it)-&gt;getName() == name)
-            {
-                removeEffect(*it);
-                return;
-            }
-        }
-    }
-
-    Effect::LifeState EffectManager::getLifeState()
-    {
-        checkEffects();
-        Effect::LifeState status = 0;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            status = status | ((*it)-&gt;getLifeState());
-        }
-        return status;
-    }
-
-    void EffectManager::checkStateChange(Effect::LifeState oldState)
-    {
-        Effect::LifeState currentState = getLifeState();
-        if (currentState != oldState)
-        {
-			MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectLifeStateChanged&gt;(mGameObject,
-				oldState, currentState);
-        }
-    }
-
-    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
-    {
-      checkEffects();
-      int mod = 0;
-	  if (type == Effect::MODTYPE_MULT) mod = 1;
-      for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-      {
-        mod += (*it)-&gt;getMod(target, type, tag);
-      }
-      return mod;
-    }
-
-    CeGuiString EffectManager::getEffects()
-    {
-        CeGuiString retVal = &quot;&quot;;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            retVal += (*it)-&gt;getName() + &quot;\n&quot;;
-            retVal += (*it)-&gt;getDescription() + &quot;\n&quot;;
-        }
-        return retVal;
-    }
-}
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;EffectManager.h&quot;
+
+#include &lt;sstream&gt;
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+
+namespace rl
+{
+    const Ogre::String EffectManager::PROPERTY_TIMECHECK = &quot;timechecks&quot;;
+    const Ogre::String EffectManager::PROPERTY_TIME = &quot;time&quot;;
+    const Ogre::String EffectManager::PROPERTY_EFFECT = &quot;effect&quot;;
+
+    EffectManager::EffectManager(GameObject* gameobject)
+        : mGameObject(gameobject),
+        mCheckEffectsRunning(false)
+    {
+    }
+
+    EffectManager::~EffectManager()
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            //delete (*it);
+            ScriptWrapper::getSingleton().disowned(*it);
+        }
+    }
+
+    void EffectManager::checkEffects()
+    {
+        if( mCheckEffectsRunning ) {
+                return;
+        }
+        mCheckEffectsRunning = true;
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        Checklist::iterator checkIt = mChecklist.begin();
+        if (checkIt == mChecklist.end()) return;
+        while ( checkIt != mChecklist.end() &amp;&amp; checkIt-&gt;first &lt;= now )
+        {
+                std::stringstream debugInfo;
+                debugInfo &lt;&lt; &quot;Effect check: &quot; &lt;&lt; checkIt-&gt;first &lt;&lt; &quot; now: &quot; &lt;&lt; now &lt;&lt; std::endl;
+                LOG_DEBUG(Logger::RULES,
+                    debugInfo.str());
+            for (Effects::iterator effIt = checkIt-&gt;second.begin(); effIt != checkIt-&gt;second.end(); effIt++)
+            {
+                int nextCheck;
+                nextCheck = (*effIt)-&gt;timeCheck();
+                switch (nextCheck)
+                {
+                  case Effect::REMOVE:
+                    removeEffect(*effIt);
+                    break;
+                  case Effect::PERMANENT:
+                    break;
+                  default:
+                    addTimeCheck(nextCheck, *effIt);
+                }
+            }
+            mChecklist.erase(checkIt++);
+        }
+
+        mCheckEffectsRunning = false;
+    }
+
+    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
+    {
+        // Preconditions: time &gt; 0, effect != NULL
+        if (time &lt;= 0) Throw(IllegalArgumentException, &quot;time parameter is &lt;= 0!&quot;);
+        if (effect == NULL) Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
+        // Get current ingame time and add timeUntilCheck
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        RL_LONGLONG timeForCheck = now + timeUntilCheck;
+        std::stringstream debugInfo;
+        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; timeForCheck &lt;&lt; std::endl;
+        LOG_DEBUG(Logger::RULES,
+            debugInfo.str());
+        // Insert Sum and effect into the checklist
+        mChecklist[timeForCheck].push_back(effect);
+    }
+
+    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
+    {
+        // Preconditions: date &gt; now, effect != NULL
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        if (date &lt;= now) 
+        {
+            Throw(IllegalArgumentException, &quot;date lies in the past!&quot;);
+        }
+        if (effect == NULL) 
+        {
+            Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
+        }
+        // Insert date and effect into the checklist
+        std::stringstream debugInfo;
+        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; date &lt;&lt; std::endl;
+        LOG_DEBUG(Logger::RULES, debugInfo.str());
+        mChecklist[date].push_back(effect);
+    }
+
+
+    void EffectManager::addEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+
+        LOG_DEBUG(Logger::RULES, &quot;Adding effect &quot; + effect-&gt;getName());
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            Effect* cur = *it;
+            if (cur-&gt;getName() == effect-&gt;getName())
+            {
+                if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
+                {
+                    return;
+                }
+                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
+                {
+                    //TODO
+                    //Vielleicht alten durch neuen ersetzen?
+                    //oder (*it)-&gt;setDuration(effect-&gt;getDuration())
+                }
+                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
+                {
+                    for (int i = 0; i &lt; effect-&gt;getStufe(); i++)
+                    {
+                        cur-&gt;increaseStufe();
+                    }
+                }
+            }
+        }
+        ScriptWrapper::getSingleton().owned(effect);
+        mEffects.push_back(effect);
+        effect-&gt;enable();
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+    
+        effect-&gt;disable();
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); ++it)
+        {
+            if (*it == effect)
+            {
+                mEffects.erase(it);
+                break;
+            }
+        }
+        ScriptWrapper::getSingleton().disowned(effect);
+        ///@todo also remove from the check lists?
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(CeGuiString name)
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            if ((*it)-&gt;getName() == name)
+            {
+                removeEffect(*it);
+                return;
+            }
+        }
+    }
+
+    Effect::LifeState EffectManager::getLifeState()
+    {
+        checkEffects();
+        Effect::LifeState status = 0;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            status = status | ((*it)-&gt;getLifeState());
+        }
+        return status;
+    }
+
+    void EffectManager::checkStateChange(Effect::LifeState oldState)
+    {
+        Effect::LifeState currentState = getLifeState();
+        if (currentState != oldState)
+        {
+            MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectLifeStateChanged&gt;(mGameObject,
+                oldState, currentState);
+        }
+    }
+
+    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
+    {
+        checkEffects();
+        int mod = 0;
+        if (type == Effect::MODTYPE_MULT) mod = 1;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            mod += (*it)-&gt;getMod(target, type, tag);
+        }
+        return mod;
+    }
+
+    CeGuiString EffectManager::getEffects()
+    {
+        CeGuiString retVal = &quot;&quot;;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            retVal += (*it)-&gt;getName() + &quot;\n&quot;;
+            retVal += (*it)-&gt;getDescription() + &quot;\n&quot;;
+        }
+        return retVal;
+    }
+
+    const Property EffectManager::getProperty(const CeGuiString&amp; key) const
+    {
+        Property rval;
+        if (key == Creature::PROPERTY_EFFECTS)
+        {
+            PropertyMap map;
+            
+            std::map&lt;Effect*, int&gt; effectIds;
+            PropertyArray effectProps;
+            for (int i = 0, size = mEffects.size(); i &lt; size; ++i)
+            {
+                Effect* cur = mEffects[i];
+                effectProps.push_back(cur-&gt;getAllProperties()-&gt;toPropertyMap());
+                effectIds[cur] = i;
+            }
+            
+            PropertyArray timeCheck;
+            for (std::map&lt;RL_LONGLONG, Effects&gt;::const_iterator itTc = mChecklist.begin(); 
+                itTc != mChecklist.end(); ++itTc)
+            {
+                for (Effects::const_iterator itEff = itTc-&gt;second.begin(); 
+                    itEff != itTc-&gt;second.end(); ++itEff)
+                {
+                    PropertyMap tcElem;
+                    tcElem[EffectManager::PROPERTY_EFFECT] = effectIds[*itEff];
+                    tcElem[EffectManager::PROPERTY_TIME] = itTc-&gt;first;
+                    timeCheck.push_back(tcElem);
+                }
+            }
+            
+            map[Creature::PROPERTY_EFFECTS] = effectProps;
+            map[EffectManager::PROPERTY_TIMECHECK] = timeCheck;
+            rval.setValue(map);
+        }
+        else 
+        {
+            Throw(IllegalArgumentException, key + &quot; is not a property of EffectManager.&quot;);
+        }
+        return rval;
+    }
+    
+    void EffectManager::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        try
+        {
+            if (key == Creature::PROPERTY_EFFECTS)
+            {
+                PropertyMap map = value.toMap();
+                
+                std::vector&lt;Effect*&gt; effectIds;
+                
+                PropertyArray arr = map[Creature::PROPERTY_EFFECTS].toArray();
+                for (int i = 0, size = arr.size(); i &lt; size; ++i)
+                {
+                    PropertyMap cur = arr[i].toMap();
+                    Ogre::String name = cur[Effect::PROPERTY_NAME].toString().c_str();
+                    int stufe = cur[Effect::PROPERTY_STUFE];
+                    Effect* eff = EffectFactoryManager::getSingleton().createEffect(name, stufe);
+                    eff-&gt;setProperties(cur);
+                    mEffects.push_back(eff);
+                    ///@TODO: activate effects?
+                }
+                
+                PropertyArray timeCheckProp = map[EffectManager::PROPERTY_TIMECHECK].toArray();
+                for (int i = 0, size = timeCheckProp.size(); i &lt; size; ++i)
+                {
+                    PropertyMap cur = timeCheckProp[i].toMap();
+                    RL_LONGLONG time = cur[EffectManager::PROPERTY_TIME].toLong();
+                    Effect* eff = mEffects[cur[EffectManager::PROPERTY_EFFECT].toInt()];
+                    mChecklist[time].push_back(eff);
+                }
+            }
+            else
+            {
+                LOG_WARNING(Logger::RULES, 
+                    key + &quot; is not a property of EffectManager&quot;);
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(Logger::RULES, 
+                &quot;property &quot; + key + &quot; has the wrong format&quot;);
+        }
+    }
+
+    PropertyKeys EffectManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        return keys;
+    }
+
+}
+

Modified: rl/branches/newton20/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GameObjectManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/GameObjectManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -47,12 +47,10 @@
 
         mScriptPatterns.push_back(&quot;*.gof&quot;);
         Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-        SaveGameManager::getSingleton().registerSaveGameData(this);
     }
 
     GameObjectManager::~GameObjectManager()
     {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
         unregisterAllGameObjectStateListener();
         deleteAllGameObjects();
     }
@@ -293,90 +291,6 @@
         return createRubyGameObject(classname, id);
     }
 
-    CeGuiString GameObjectManager::getXmlNodeIdentifier() const
-    {
-        return &quot;gameobjects&quot;;
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-    
-    void GameObjectManager::writeData(SaveGameFileWriter *writer)
-    {
-        LOG_MESSAGE(Logger::RULES, &quot;Saving Game Objects&quot;);
-        DOMElement* gameobjects = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        std::list&lt;GameObject*&gt; gos = getAllGameObjects();
-
-		for(std::list&lt;GameObject*&gt;::const_iterator it_gameobjects = gos.begin(); it_gameobjects != gos.end(); it_gameobjects++)
-        {
-            DOMElement* gameobject = writer-&gt;appendChildElement(writer-&gt;getDocument(), gameobjects, &quot;gameobject&quot;);
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;ID&quot;, (*it_gameobjects)-&gt;getId());
-            writer-&gt;setAttributeValueAsString(gameobject, &quot;ClassID&quot;, (*it_gameobjects)-&gt;getClassId());
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;State&quot;, (int)(*it_gameobjects)-&gt;getState());
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;QueryFlags&quot;, (int)(*it_gameobjects)-&gt;getQueryFlags());
-
-            PropertyMap actualMap = (*it_gameobjects)-&gt;getAllProperties()-&gt;toPropertyMap();
-
-            writer-&gt;writeEachPropertyToElem(gameobject, (*it_gameobjects)-&gt;getAllProperties()-&gt;getDifference(getClassProperties((*it_gameobjects)-&gt;getClassId()))-&gt;toPropertyMap());
-            //writer-&gt;writeEachPropertyToElem(gameobject, getPropertyMapDifference(actualMap, getClassProperties((*it_gameobjects)-&gt;getClassId())-&gt;toPropertyMap()));
-        } 
-    }
-
-    void GameObjectManager::readData(SaveGameFileReader *reader)
-    {
-        deleteAllGameObjects();
-
-        reader-&gt;initializeXml();
-
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList-&gt;getLength())
-        {
-            DOMNodeList* xmlGameObjects = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;gameobject&quot;).data()); //there should be only one &quot;gameobjects&quot; node
-            if(xmlGameObjects-&gt;getLength())
-            {
-                for(XMLSize_t childIdx = 0; childIdx &lt; xmlGameObjects-&gt;getLength(); childIdx++)
-                {
-                    DOMNode* xmlGameObject = xmlGameObjects-&gt;item(childIdx);
-                    if(xmlGameObject-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        int ID = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ID&quot;);
-                        Ogre::String classID = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ClassID&quot;);
-                        GameObjectState state = (GameObjectState)reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;State&quot;);
-                        int flags = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;QueryFlags&quot;);
-                        PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlGameObject));
-
-                        GameObject* object = NULL;
-                        if(getGameObject(ID) == NULL)
-                            object = createGameObject(classID, ID);
-                        else
-                            object = getGameObject(ID);
-                        
-                        applyProperties(object, properties);
-                        // Placing the actor a a little bit higher in the scene. The actor will fall onto ground.
-                        // Avoiding problems with the physics, because the character the creature is transfixed to ground
-                        if(state == GOS_IN_SCENE)
-                        {
-                            object-&gt;setProperty(GameObject::PROPERTY_POSITION, 
-	                            Property(object-&gt;getProperty(GameObject::PROPERTY_POSITION).toVector3() + Ogre::Vector3(0.0f,0.01f,0.0f)));
-                        }
-                        object-&gt;setState(state);
-                        object-&gt;setQueryFlags(flags);
-                    }
-                }
-            }
-        } 
-
-        MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectsLoaded&gt;();
-
-        reader-&gt;shutdownXml();
-    }
-
-    int GameObjectManager::getPriority() const
-    {
-        return 100;
-    }
-
     PropertyMap GameObjectManager::getPropertyMapDifference(PropertyMap map1, PropertyMap map2)
     {
         PropertyRecord pr;

Modified: rl/branches/newton20/engine/rules/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/rules/src/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -37,6 +37,7 @@
 	ObjectStateChangeEvent.cpp \
 	ObjectStateChangeEventSource.cpp \
 	ObjectStateChangeListener.cpp \
+	PartyManager.cpp \
 	Quest.cpp \
 	QuestBook.cpp \
 	QuestEvent.cpp \

Copied: rl/branches/newton20/engine/rules/src/PartyManager.cpp (from rev 4518, rl/trunk/engine/rules/src/PartyManager.cpp)

Modified: rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,116 +1,125 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;CombatManager.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;DsaDataLoader.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;EffectManagementTask.h&quot;
-#include &quot;GameEventLog.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;GameTimeSource.h&quot;
-#include &quot;GlobalProperties.h&quot;
-#include &lt;ConfigurationManager.h&gt;
-
-template &lt;&gt;
-rl::RulesSubsystem* Singleton&lt;rl::RulesSubsystem&gt;::ms_Singleton = 0;
-namespace rl
-{
-    RulesSubsystem::RulesSubsystem()
-		: mQuestBook(NULL),
-        mActionManager(NULL),
-        mCombatManager(NULL),
-        mDsaManager(NULL),
-		mGameEventLog(NULL),
-        mMovingCreatureManager(NULL),
-        mXdimlLoader(NULL),
-        mGlobalProperties(NULL),
-        mEffectManagementTask(NULL)
-    {
-		LOG_MESSAGE(Logger::RULES, &quot;Start&quot;);
-        //Zufallsgenerator initialisieren
-        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
-
-        TimeSourceManager::getSingleton().registerTimeSource(
-            new GameTimeSource());
-
-        //Singletons erzeugen
-        mActionManager = new ActionManager();
-		LOG_MESSAGE(Logger::RULES, &quot;ActionManager erzeugt&quot;);
-        mCombatManager = new CombatManager();
-		LOG_MESSAGE(Logger::RULES, &quot;CombatManager erzeugt&quot;);
-        mDsaManager = new DsaManager();
-		LOG_MESSAGE(Logger::RULES, &quot;DsaManager erzeugt&quot;);
-        mGameEventLog = new GameEventLog();
-		LOG_MESSAGE(Logger::RULES, &quot;GameEventLog erzeugt&quot;);
-        mMovingCreatureManager = new CreatureControllerManager();
-		LOG_MESSAGE(Logger::RULES, &quot;CreatureControllerManager erzeugt&quot;);
-		resetQuestBook();
-		LOG_MESSAGE(Logger::RULES, &quot;Questverwaltung erzeugt&quot;);
-        mGlobalProperties = new GlobalProperties();
-
-        mEffectManagementTask = new EffectManagementTask();
-        GameLoop::getSingleton().addTask(
-            mEffectManagementTask, GameLoop::TG_LOGIC);
-
-		//Daten laden
-		mXdimlLoader = new XdimlLoader();
-		LOG_MESSAGE(Logger::RULES, &quot;Basisdaten geladen&quot;);
-
-        new EffectFactoryManager();
-        new GameObjectManager();
-		LOG_MESSAGE(Logger::RULES, &quot;Erzeugen abgeschlossen&quot;);
-    }
-
-	RulesSubsystem::~RulesSubsystem()
-    {
-        GameLoop::getSingleton().removeTask(mEffectManagementTask);
-        delete mEffectManagementTask;
-        delete mGlobalProperties;
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-        delete mQuestBook;
-		delete mGameEventLog;
-        delete mDsaManager;
-        delete mCombatManager;
-        delete mActionManager;
-        delete mXdimlLoader;
-        delete GameObjectManager::getSingletonPtr();
-        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
-        delete EffectFactoryManager::getSingletonPtr();
-    }
-
-	QuestBook* RulesSubsystem::getQuestBook()
-	{
-		return mQuestBook;
-	}
-
-	void RulesSubsystem::resetQuestBook()
-	{
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-		delete mQuestBook;
-		mQuestBook = new QuestBook();
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;RulesSubsystem.h&quot;
+
+#include &quot;ActionManager.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;DsaDataLoader.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;EffectManagementTask.h&quot;
+#include &quot;GameEventLog.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;GameTimeSource.h&quot;
+#include &quot;GlobalProperties.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;QuestBook.h&quot;
+
+template &lt;&gt;
+rl::RulesSubsystem* Singleton&lt;rl::RulesSubsystem&gt;::ms_Singleton = 0;
+namespace rl
+{
+    RulesSubsystem::RulesSubsystem()
+		: mQuestBook(NULL),
+        mActionManager(NULL),
+        mCombatManager(NULL),
+        mDsaManager(NULL),
+		mGameEventLog(NULL),
+        mMovingCreatureManager(NULL),
+        mXdimlLoader(NULL),
+        mGlobalProperties(NULL),
+        mEffectManagementTask(NULL)
+    {
+		LOG_MESSAGE(Logger::RULES, &quot;Start&quot;);
+        //Zufallsgenerator initialisieren
+        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
+
+        TimeSourceManager::getSingleton().registerTimeSource(
+            new GameTimeSource());
+
+        //Singletons erzeugen
+        mActionManager = new ActionManager();
+		LOG_MESSAGE(Logger::RULES, &quot;ActionManager erzeugt&quot;);
+        mCombatManager = new CombatManager();
+		LOG_MESSAGE(Logger::RULES, &quot;CombatManager erzeugt&quot;);
+        mDsaManager = new DsaManager();
+		LOG_MESSAGE(Logger::RULES, &quot;DsaManager erzeugt&quot;);
+        mGameEventLog = new GameEventLog();
+		LOG_MESSAGE(Logger::RULES, &quot;GameEventLog erzeugt&quot;);
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, &quot;CreatureControllerManager erzeugt&quot;);
+		resetQuestBook();
+		LOG_MESSAGE(Logger::RULES, &quot;Questverwaltung erzeugt&quot;);
+        mGlobalProperties = new GlobalProperties();
+
+        mEffectManagementTask = new EffectManagementTask();
+        GameLoop::getSingleton().addTask(
+            mEffectManagementTask, GameLoop::TG_LOGIC);
+
+		//Daten laden
+		mXdimlLoader = new XdimlLoader();
+		LOG_MESSAGE(Logger::RULES, &quot;Basisdaten geladen&quot;);
+
+        new EffectFactoryManager();
+        new GameObjectManager();
+        
+        mPartyManager = new PartyManager();
+		LOG_MESSAGE(Logger::RULES, &quot;Erzeugen abgeschlossen&quot;);
+    }
+
+	RulesSubsystem::~RulesSubsystem()
+    {
+        delete mPartyManager;
+        GameLoop::getSingleton().removeTask(mEffectManagementTask);
+        delete mEffectManagementTask;
+        delete mGlobalProperties;
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+        delete mQuestBook;
+		delete mGameEventLog;
+        delete mDsaManager;
+        delete mCombatManager;
+        delete mActionManager;
+        delete mXdimlLoader;
+        delete GameObjectManager::getSingletonPtr();
+        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
+        delete EffectFactoryManager::getSingletonPtr();
+    }
+
+	QuestBook* RulesSubsystem::getQuestBook()
+	{
+		return mQuestBook;
+	}
+
+	void RulesSubsystem::resetQuestBook()
+	{
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+		delete mQuestBook;
+		mQuestBook = new QuestBook();
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
+	}
+}

Modified: rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -102,7 +102,7 @@
 	{
         if (fogElem)
         {
-		    if (!hasAttribute(fogElem, &quot;material&quot;))
+		    if (!hasAttribute(fogElem, &quot;type&quot;))
 		    {
 			    LOG_ERROR(
 				    Logger::RULES,

Modified: rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -172,9 +172,9 @@
 		Camera* cam = CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()-&gt;createCamera(&quot;Cam&quot; + entity-&gt;getName());
 		cam-&gt;setNearClipDistance(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getNearClipDistance());
         cam-&gt;setFarClipDistance(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getFarClipDistance());
-		cam-&gt;setAutoAspectRatio(true);
+		//cam-&gt;setFarClipDistance(1000000);
+		cam-&gt;setAspectRatio(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getAspectRatio());
 		cam-&gt;setFOVy(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getFOVy());
-		cam-&gt;enableCustomNearClipPlane((MovablePlane*)plane);
 
 		AliasTextureNamePairList aliases;
 
@@ -190,6 +190,8 @@
 			rttTex-&gt;addListener(new PlaneReflectionTextureListener(entity, cam, plane));
 			
 			aliases[&quot;reflection&quot;] = &quot;Reflection&quot; + entity-&gt;getName();
+
+			cam-&gt;enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(getAttributeValueAsBool(rttElem, &quot;refraction&quot;))
 		{
@@ -203,6 +205,9 @@
 			rttTex-&gt;addListener(new PlaneRefractionTextureListener(entity, cam));
 
 			aliases[&quot;refraction&quot;] = &quot;Refraction&quot; + entity-&gt;getName();
+
+			plane-&gt;normal = Vector3::NEGATIVE_UNIT_Y;
+			cam-&gt;enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(!material-&gt;applyTextureAliases(aliases))
 			LOG_ERROR(&quot;PLANE&quot;, &quot;Texture Aliase konnten nicht angewandt werden&quot;);
@@ -220,7 +225,7 @@
 		mCamera-&gt;setPosition(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldPosition());
 		mCamera-&gt;setOrientation(CoreSubsystem::getSingleton().getWorld()-&gt;getActiveCamera()-&gt;getWorldOrientation());
 		mEntity-&gt;setVisible(false);
-		mCamera-&gt;enableReflection(*mPlane);
+		mCamera-&gt;enableReflection((MovablePlane*)mPlane);
 	}
 
 	void PlaneReflectionTextureListener::postRenderTargetUpdate(const Ogre::RenderTargetEvent&amp; evt)

Modified: rl/branches/newton20/engine/script/src/SceneManager.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,124 +1,124 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;SceneManager.h&quot;
-
-#include &quot;Creature.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;Scene.h&quot;
-#include &quot;SceneLoader.h&quot;
-#include &quot;UiSubsystem.h&quot;
-
-template&lt;&gt; rl::SceneManager* Ogre::Singleton&lt;rl::SceneManager&gt;::ms_Singleton = NULL;
-
-namespace rl 
-{
-
-    SceneManager::SceneManager()
-        : Ogre::Singleton&lt;SceneManager&gt;(),
-          Ogre::ScriptLoader(),
-          mCurrentScene(NULL)
-    {
-        mScriptPatterns.push_back(&quot;*.rlscene&quot;);
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-    }
-
-    SceneManager::~SceneManager()
-    {
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-        for (std::map&lt;CeGuiString, Scene*&gt;::iterator it = mScenes.begin();
-            it != mScenes.end(); ++it)
-        {
-            delete it-&gt;second;
-        }
-    }
-
-    void SceneManager::addScene(Scene* scene) 
-    {
-        mScenes[scene-&gt;getName()] = scene;
-    }
-
-    void SceneManager::loadScene(const CeGuiString&amp; sceneName, bool saveCurrent)
-    {
-        if (mCurrentScene &amp;&amp; sceneName == mCurrentScene-&gt;getName())
-        {
-            return;
-        }
-
-        Creature* activeChar = UiSubsystem::getSingleton().getActiveCharacter();
-
-        if (activeChar) {
-            CreatureControllerManager::getSingleton().detachController(
-                activeChar);
-            activeChar-&gt;setState(GOS_LOADED);
-        }
-
-        if (saveCurrent) 
-        {
-            mSceneStates[mCurrentScene] = mCurrentScene-&gt;getAllProperties();
-        }
-
-        std::map&lt;CeGuiString, Scene*&gt;::iterator itScene = mScenes.find(sceneName);
-        if (itScene != mScenes.end())
-        {            
-            std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState =
-                mSceneStates.end();
-            if (saveCurrent) 
-            {
-                std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState 
-                    = mSceneStates.find(mCurrentScene);
-            }
-
-            itScene-&gt;second-&gt;load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
-            mCurrentScene = itScene-&gt;second;
-            
-            if (itState != mSceneStates.end())
-            {
-                mCurrentScene-&gt;setProperties(itState-&gt;second);
-            }
-        }
-        else
-        {
-            LOG_ERROR(&quot;SceneManager&quot;, 
-                &quot;Scene '&quot; + sceneName + &quot;' not found. Have you forgotten to define it in a .rlscene file?&quot;);
-        }
-
-        if (activeChar) 
-        {
-            UiSubsystem::getSingleton().setActiveCharacter(activeChar);
-        }
-    }
-
-    const Ogre::StringVector&amp; SceneManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SceneManager::parseScript(Ogre::DataStreamPtr&amp; data, const Ogre::String&amp; resourceGroup)
-    {
-        SceneLoader* loader = new SceneLoader();
-        addScene(loader-&gt;loadScene(data));
-        delete loader;
-    }
-
-    Ogre::Real SceneManager::getLoadingOrder() const
-    {
-        return 1000;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;SceneManager.h&quot;
+
+#include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;Scene.h&quot;
+#include &quot;SceneLoader.h&quot;
+
+template&lt;&gt; rl::SceneManager* Ogre::Singleton&lt;rl::SceneManager&gt;::ms_Singleton = NULL;
+
+namespace rl 
+{
+
+    SceneManager::SceneManager()
+        : Ogre::Singleton&lt;SceneManager&gt;(),
+          Ogre::ScriptLoader(),
+          mCurrentScene(NULL)
+    {
+        mScriptPatterns.push_back(&quot;*.rlscene&quot;);
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+    }
+
+    SceneManager::~SceneManager()
+    {
+        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
+        for (std::map&lt;CeGuiString, Scene*&gt;::iterator it = mScenes.begin();
+            it != mScenes.end(); ++it)
+        {
+            delete it-&gt;second;
+        }
+    }
+
+    void SceneManager::addScene(Scene* scene) 
+    {
+        mScenes[scene-&gt;getName()] = scene;
+    }
+
+    void SceneManager::loadScene(const CeGuiString&amp; sceneName, bool saveCurrent)
+    {
+        if (mCurrentScene &amp;&amp; sceneName == mCurrentScene-&gt;getName())
+        {
+            return;
+        }
+
+        Creature* activeChar = PartyManager::getSingleton().getActiveCharacter();
+
+        if (activeChar) {
+            CreatureControllerManager::getSingleton().detachController(
+                activeChar);
+            activeChar-&gt;setState(GOS_LOADED);
+        }
+
+        if (saveCurrent) 
+        {
+            mSceneStates[mCurrentScene] = mCurrentScene-&gt;getAllProperties();
+        }
+
+        std::map&lt;CeGuiString, Scene*&gt;::iterator itScene = mScenes.find(sceneName);
+        if (itScene != mScenes.end())
+        {            
+            std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState =
+                mSceneStates.end();
+            if (saveCurrent) 
+            {
+                std::map&lt;Scene*, PropertyRecordPtr&gt;::iterator itState 
+                    = mSceneStates.find(mCurrentScene);
+            }
+
+            itScene-&gt;second-&gt;load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene-&gt;second;
+            
+            if (itState != mSceneStates.end())
+            {
+                mCurrentScene-&gt;setProperties(itState-&gt;second);
+            }
+        }
+        else
+        {
+            LOG_ERROR(&quot;SceneManager&quot;, 
+                &quot;Scene '&quot; + sceneName + &quot;' not found. Have you forgotten to define it in a .rlscene file?&quot;);
+        }
+
+        if (activeChar) 
+        {
+            PartyManager::getSingleton().setActiveCharacter(activeChar);
+        }
+    }
+
+    const Ogre::StringVector&amp; SceneManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    void SceneManager::parseScript(Ogre::DataStreamPtr&amp; data, const Ogre::String&amp; resourceGroup)
+    {
+        SceneLoader* loader = new SceneLoader();
+        addScene(loader-&gt;loadScene(data));
+        delete loader;
+    }
+
+    Ogre::Real SceneManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+}

Modified: rl/branches/newton20/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/ZoneProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/ZoneProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,230 +1,267 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;ZoneProcessor.h&quot;
-
-#include &quot;ActorManager.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;ScriptSubsystem.h&quot;
-#include &quot;Trigger.h&quot;
-#include &quot;TriggerFactory.h&quot;
-#include &quot;Zone.h&quot;
-#include &quot;ZoneManager.h&quot;
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl
-{
-
-	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
-	{
-		if (zonesElem == NULL)
-		{
-			return false; // no zones
-		}
-
-        for (DOMNode* cur = zonesElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE
-				&amp;&amp; hasNodeName(cur, &quot;zone&quot;))
-            {
-				DOMElement* curZoneElem = static_cast&lt;DOMElement*&gt;(cur);
-				if (hasAttribute(curZoneElem, &quot;name&quot;))
-				{
-					Ogre::String name = getAttributeValueAsStdString(curZoneElem, &quot;name&quot;);
-                    Zone* zone = NULL;
-                    if( name == &quot;default&quot; )
-                        zone = ZoneManager::getSingleton().getDefaultZone();
-                    else
-                    {
-                        // get the zone with that name or create one
-                        zone = ZoneManager::getSingleton().getZone(name);
-                        if( !zone )
-                            zone = ZoneManager::getSingleton().createZone(name, false);
-
-                        // multiple areas
-                        for(DOMNode* curArea = cur-&gt;getFirstChild(); curArea != NULL; curArea = curArea-&gt;getNextSibling())
-                        {
-                            if( curArea-&gt;getNodeType() == DOMNode::ELEMENT_NODE
-                                &amp;&amp; hasNodeName(curArea, &quot;area&quot;) )
-                            {
-                                DOMElement *curAreaElem = static_cast&lt;DOMElement*&gt;(curArea);
-                                if( hasAttribute(curAreaElem, &quot;type&quot;) )
-                                {
-                                    // type
-                                    Ogre::String type;
-                                    type = getAttributeValueAsStdString(curAreaElem, &quot;type&quot;);
-
-                                    // add or subtract?
-                                    bool subtract = false;
-                                    if( hasAttribute(curAreaElem, &quot;subtract&quot;) )
-                                        subtract = getAttributeValueAsBool(curAreaElem, &quot;subtract&quot;);
-
-                                    // position
-                                    Vector3 position = Vector3::ZERO;
-                                    DOMElement* positionElem = getChildNamed(curAreaElem, &quot;position&quot;);
-                                    if( positionElem != NULL )
-                                        position = getValueAsVector3(positionElem);
-
-                                    //scale, rotation, offset
-                                    Vector3 scale = Vector3::UNIT_SCALE;
-                                    DOMElement* scaleElem = getChildNamed(curAreaElem, &quot;scale&quot;);
-                                    if( scaleElem != NULL )
-                                        scale = getValueAsVector3(scaleElem);
-
-                                    Vector3 offset = Vector3::ZERO;
-                                    DOMElement* offsetElem = getChildNamed(curAreaElem, &quot;offset&quot;);
-                                    if( offsetElem != NULL )
-                                        offset = getValueAsVector3(offsetElem);
-
-                                    Quaternion rotation = Quaternion::IDENTITY;
-                                    DOMElement* rotationElem = getChildNamed(curAreaElem, &quot;rotation&quot;);
-                                    if( rotationElem != NULL )
-                                        rotation = getValueAsQuaternion(rotationElem);
-
-                                    //transition distance
-                                    Real transitionDistance = 0;
-                                    DOMElement* transitionElem = getChildNamed(curAreaElem, &quot;transition_distance&quot;);
-                                    if( transitionElem != NULL )
-                                        transitionDistance = getValueAsReal(transitionElem);
-
-					            
-                                    if (type == &quot;mesh&quot;)
-    					            {
-                                        Ogre::String meshName;
-                                        if( hasAttribute(curAreaElem, &quot;meshfile&quot;) )
-                                        {
-                                            meshName = getAttributeValueAsStdString(curAreaElem, &quot;meshfile&quot;);
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                        else
-                                            LOG_ERROR(Logger::SCRIPT, &quot;an &lt;area&gt; element with type=\&quot;mesh\&quot; must have attribute 'meshfile'&quot;);
-                                    }
-    					            else
-                                    {
-                                        GeometryType geom = GT_NONE;
-                                        if (type == &quot;sphere&quot; )
-                                            geom = GT_SPHERE;
-                                        else if (type == &quot;box&quot; )
-                                            geom = GT_BOX;
-                                        else if (type == &quot;ellipsoid&quot; )
-                                            geom = GT_ELLIPSOID;
-                                        else if (type == &quot;pyramid&quot; )
-                                            geom = GT_PYRAMID;
-                                        else if (type == &quot;capsule&quot; )
-                                            geom = GT_CAPSULE;
-                                        else
-                                        {
-                                            LOG_ERROR(Logger::SCRIPT, &quot;Unknown area type '&quot; + type + &quot;' !&quot;);
-                                        }
-                                        if ( geom != GT_NONE )
-                                        {
-                                            Ogre::AxisAlignedBox aabb;
-                                            aabb.setMinimum( - scale / 2.0f);
-                                            aabb.setMaximum( + scale / 2.0f);
-
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addAreaToZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                    }
-                                }
-                                else
-                                {
-                                    LOG_ERROR(Logger::SCRIPT, &quot;&lt;area&gt; elemt must have attribute 'type'&quot;);
-                                }
-                            }
-                        }
-                    }
-
-					if (zone != NULL)
-					{
-						for (DOMNode* cur = curZoneElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-						{
-							if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-							{
-								DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-								if (hasNodeName(curElem, &quot;light&quot;))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
-									zone-&gt;addLight(ActorManager::getSingleton().getActor(name));
-								}
-								else if (hasNodeName(curElem, &quot;sound&quot;))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
-									zone-&gt;addSound(name);
-								}
-								else if (hasNodeName(curElem, &quot;trigger&quot;))
-								{
-									Ogre::String classname =
-										getAttributeValueAsStdString(curElem, &quot;classname&quot;);
-
-									Ogre::String name =
-										getAttributeValueAsStdString(curElem, &quot;name&quot;);
-
-									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
-										-&gt;createTrigger(classname, name);
-
-                                    // add trigger properties
-                                    for( DOMNode* curProperty = cur-&gt;getFirstChild(); curProperty != NULL; curProperty = curProperty-&gt;getNextSibling() )
-                                    {
-                                        if( hasNodeName(curProperty, &quot;property&quot;) )
-                                        {
-                                            PropertyEntry propEntry = processProperty(static_cast&lt;DOMElement*&gt;(curProperty));
-                                            if (propEntry.first != &quot;&quot;)
-                                            {
-                                                trigger-&gt;setProperty(propEntry.first, propEntry.second);
-                                            }
-                                        }
-                                    }
-
-                                    zone-&gt;addTrigger(trigger);
-								}
-                                else if (hasNodeName(curElem, &quot;eaxpreset&quot;))
-                                {
-									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
-                                    zone-&gt;setEaxPreset(name);
-                                }
-							}
-						}
-					}
-					else
-					{
-						LOG_ERROR(Logger::SCRIPT, &quot;Zone named '&quot;+name+&quot;' could not be processes.&quot;);
-					}
-				}
-				else
-				{
-					LOG_ERROR(Logger::SCRIPT, &quot;&lt;zone&gt; element must have attribute 'name'.&quot;);
-				}
-			}
-		}
-
-        ZoneManager::getSingleton().update();
-		return true;
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;ZoneProcessor.h&quot;
+
+#include &quot;ActorManager.h&quot;
+#include &quot;RulesConstants.h&quot;
+#include &quot;ScriptSubsystem.h&quot;
+#include &quot;Trigger.h&quot;
+#include &quot;TriggerFactory.h&quot;
+#include &quot;Zone.h&quot;
+#include &quot;ZoneManager.h&quot;
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl
+{
+
+	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	{
+		if (zonesElem == NULL)
+		{
+			return false; // no zones
+		}
+
+        for (DOMNode* cur = zonesElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+				&amp;&amp; hasNodeName(cur, &quot;zone&quot;))
+            {
+				DOMElement* curZoneElem = static_cast&lt;DOMElement*&gt;(cur);
+				if (hasAttribute(curZoneElem, &quot;name&quot;))
+				{
+					Ogre::String name = getAttributeValueAsStdString(curZoneElem, &quot;name&quot;);
+                    Zone* zone = NULL;
+                    if (name == &quot;default&quot;)
+                    {
+                        zone = ZoneManager::getSingleton().getDefaultZone();
+                    }
+                    else
+                    {
+                        // get the zone with that name or create one
+                        zone = ZoneManager::getSingleton().getZone(name);
+                        if (!zone)
+                        {
+                            zone = ZoneManager::getSingleton().createZone(name, false);
+                        }
+
+                        // multiple areas
+                        for(DOMNode* curArea = cur-&gt;getFirstChild(); curArea != NULL; curArea = curArea-&gt;getNextSibling())
+                        {
+                            if (curArea-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+                                &amp;&amp; hasNodeName(curArea, &quot;area&quot;))
+                            {
+                                DOMElement *curAreaElem = static_cast&lt;DOMElement*&gt;(curArea);
+                                if (hasAttribute(curAreaElem, &quot;type&quot;))
+                                {
+                                    // type
+                                    Ogre::String type;
+                                    type = getAttributeValueAsStdString(curAreaElem, &quot;type&quot;);
+
+                                    // add or subtract?
+                                    bool subtract = false;
+                                    if (hasAttribute(curAreaElem, &quot;subtract&quot;))
+                                    {
+                                        subtract = getAttributeValueAsBool(curAreaElem, &quot;subtract&quot;);
+                                    }
+
+                                    // position
+                                    Vector3 position = Vector3::ZERO;
+                                    DOMElement* positionElem = getChildNamed(curAreaElem, &quot;position&quot;);
+                                    if (positionElem)
+                                    {
+                                        position = getValueAsVector3(positionElem);
+                                    }
+
+                                    //scale, rotation, offset
+                                    Vector3 scale = Vector3::UNIT_SCALE;
+                                    DOMElement* scaleElem = getChildNamed(curAreaElem, &quot;scale&quot;);
+                                    if (!scaleElem)
+                                    {
+                                        scaleElem = getChildNamed(curAreaElem, &quot;size&quot;);
+                                    }
+                                    
+                                    if (scaleElem)
+                                    {
+                                        scale = getValueAsVector3(scaleElem);
+                                    }
+
+                                    Vector3 offset = Vector3::ZERO;
+                                    DOMElement* offsetElem = getChildNamed(curAreaElem, &quot;offset&quot;);
+                                    if (offsetElem)
+                                    {
+                                        offset = getValueAsVector3(offsetElem);
+                                    }
+
+                                    Quaternion rotation = Quaternion::IDENTITY;
+                                    DOMElement* rotationElem = getChildNamed(curAreaElem, &quot;rotation&quot;);
+                                    if (rotationElem)
+                                    {
+                                        rotation = getValueAsQuaternion(rotationElem);
+                                    }
+
+                                    //transition distance
+                                    Real transitionDistance = 0;
+                                    DOMElement* transitionElem = getChildNamed(curAreaElem, &quot;transition_distance&quot;);
+                                    if (transitionElem)
+                                    {
+                                        transitionDistance = getValueAsReal(transitionElem);
+                                    }
+					            
+                                    if (type == &quot;mesh&quot;)
+    					            {
+                                        Ogre::String meshName;
+                                        if (hasAttribute(curAreaElem, &quot;meshfile&quot;))
+                                        {
+                                            meshName = getAttributeValueAsStdString(curAreaElem, &quot;meshfile&quot;);
+                                            if (subtract)
+                                            {
+                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                            else
+                                            {
+                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, &quot;an &lt;area&gt; element with type=\&quot;mesh\&quot; must have attribute 'meshfile'&quot;);
+                                        }
+                                    }
+    					            else
+                                    {
+                                        GeometryType geom = GT_NONE;
+                                        if (type == &quot;sphere&quot;)
+                                        {
+                                            geom = GT_SPHERE;
+                                        }
+                                        else if (type == &quot;box&quot;)
+                                        {
+                                            geom = GT_BOX;
+                                        }
+                                        else if (type == &quot;ellipsoid&quot;)
+                                        {
+                                            geom = GT_ELLIPSOID;
+                                        }
+                                        else if (type == &quot;pyramid&quot;)
+                                        {
+                                            geom = GT_PYRAMID;
+                                        }
+                                        else if (type == &quot;capsule&quot;)
+                                        {
+                                            geom = GT_CAPSULE;
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, &quot;Unknown area type '&quot; + type + &quot;' !&quot;);
+                                        }
+                                        
+                                        if ( geom != GT_NONE)
+                                        {
+                                            Ogre::AxisAlignedBox aabb;
+                                            aabb.setMinimum( - scale / 2.0f);
+                                            aabb.setMaximum( + scale / 2.0f);
+
+                                            if (subtract)
+                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            else
+                                                ZoneManager::getSingleton().addAreaToZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    LOG_ERROR(Logger::SCRIPT, &quot;&lt;area&gt; elemt must have attribute 'type'&quot;);
+                                }
+                            }
+                        }
+                    }
+
+					if (zone)
+					{
+						for (DOMNode* cur = curZoneElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+						{
+							if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+							{
+								DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+								if (hasNodeName(curElem, &quot;light&quot;))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
+									zone-&gt;addLight(ActorManager::getSingleton().getActor(name));
+								}
+								else if (hasNodeName(curElem, &quot;sound&quot;))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
+									zone-&gt;addSound(name);
+								}
+								else if (hasNodeName(curElem, &quot;trigger&quot;))
+								{
+									Ogre::String classname =
+										getAttributeValueAsStdString(curElem, &quot;classname&quot;);
+
+									Ogre::String name =
+										getAttributeValueAsStdString(curElem, &quot;name&quot;);
+
+									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
+										-&gt;createTrigger(classname, name);
+
+                                    // add trigger properties
+                                    for( DOMNode* curProperty = cur-&gt;getFirstChild(); curProperty != NULL; curProperty = curProperty-&gt;getNextSibling())
+                                    {
+                                        if (hasNodeName(curProperty, &quot;property&quot;))
+                                        {
+                                            PropertyEntry propEntry = processProperty(static_cast&lt;DOMElement*&gt;(curProperty));
+                                            if (propEntry.first != &quot;&quot;)
+                                            {
+                                                trigger-&gt;setProperty(propEntry.first, propEntry.second);
+                                            }
+                                        }
+                                    }
+
+                                    zone-&gt;addTrigger(trigger);
+								}
+                                else if (hasNodeName(curElem, &quot;eaxpreset&quot;))
+                                {
+									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
+                                    zone-&gt;setEaxPreset(name);
+                                }
+							}
+						}
+					}
+					else
+					{
+						LOG_ERROR(Logger::SCRIPT, &quot;Zone named '&quot;+name+&quot;' could not be processes.&quot;);
+					}
+				}
+				else
+				{
+					LOG_ERROR(Logger::SCRIPT, &quot;&lt;zone&gt; element must have attribute 'name'.&quot;);
+				}
+			}
+		}
+
+        ZoneManager::getSingleton().update();
+		return true;
+	}
+
+}

Modified: rl/branches/newton20/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlRules.head.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlRules.head.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -41,6 +41,7 @@
 #include &quot;ObjectStateChangeEventSource.h&quot;
 #include &quot;ObjectStateChangeEvent.h&quot;
 #include &quot;ObjectStateChangeListener.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;Quest.h&quot;
 #include &quot;QuestBook.h&quot;
 #include &quot;QuestEvent.h&quot;

Modified: rl/branches/newton20/engine/script/swig/RlRules.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlRules.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlRules.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,952 +1,962 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-//%template(GameObjectVector) std::vector&lt; rl::GameObject* &gt;;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template&lt;typename T&gt;
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
-      Tripel(const Tripel&amp; rhs);
-
-      //Tripel&amp; operator=(const Tripel&amp; rhs);
-      bool operator==(const Tripel&amp; rhs);
-      bool operator&lt;(const Tripel&amp; rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date&amp; rhs);
-      
-        bool operator==(const Date&amp; rhs);
-        bool operator&lt;(const Date&amp; rhs);
-        bool operator&lt;=(const Date&amp; rhs);
-        bool operator&gt;=(const Date&amp; rhs);
-        bool operator&gt;(const Date&amp; rhs);
-
-        Date operator+(const RL_LONGLONG&amp; rhs);
-        Date operator-(const RL_LONGLONG&amp; rhs);
-        Date operator*(const Ogre::Real&amp; rhs);
-        Date operator/(const Ogre::Real&amp; rhs);
-        RL_LONGLONG operator-(const Date&amp; rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
-    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem&amp; getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date&amp; date);
-        
-        int rollD20();
-        Tripel&lt;int&gt; roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager&amp; getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature(&quot;director&quot;) GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager&amp; getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog&amp; getSingleton();
-		void logEvent(const Ogre::String&amp; eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String&amp; key) const;
-        
-        static rl::GlobalProperties&amp; getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature(&quot;director&quot;) QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map&lt;const rl::CeGuiString,int&gt; AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &amp;ausweichTalente);
-
-        bool operator==(const Talent&amp; rhs) const;
-        bool operator&lt;(const Talent&amp; rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature(&quot;director&quot;) Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1&lt;&lt;0;
-        static const int ACT_INVIS_DESC = 1&lt;&lt;1;
-        static const int ACT_DISABLED = 1&lt;&lt;2;
-        static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature(&quot;director&quot;) ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature(&quot;director&quot;) GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3&amp; position);
-        void setOrientation(const Ogre::Quaternion&amp; orientation);
-        const Ogre::Quaternion&amp; getOrientation() const;
-        const Ogre::Vector3&amp; getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date&amp; dsatime);
-        WaitJob(const Ogre::Real&amp; realtime);
-    };
-    
-    class GoToJob : public rl::Job
-    {
-    public:
-
-		GoToJob(rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		// Unclear what version is called from ruby, so uncomment second ctor.
-		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-    };
-    
-    %feature(&quot;director&quot;) Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
-            ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
-            ITEMTYPE_RING       = 1 &lt;&lt; 2,
-            ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
-            ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
-            ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
-            ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
-            ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
-            ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
-            ITEMTYPE_BELT       = 1 &lt;&lt; 9,
-            ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
-            ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
-            ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
-            ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
-            ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
-            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
-            ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel&lt;int&gt;&amp; getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair&lt;int, int&gt;&amp; getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair&lt;int, int&gt;&amp; newWm);
-        const std::pair&lt;int,int&gt;&amp; getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = &quot;g_be&quot;;
-        static const CeGuiString Armor::PROPERTY_G_RS = &quot;g_rs&quot;;
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature(&quot;director&quot;) Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1&lt;&lt;0;
-        static const LifeState LS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
-        static const LifeState LS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
-        static const LifeState LS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
-        static const ModType MODTYPE_SUM      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 &lt;&lt; 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String&amp; name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager&amp; getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString&amp; slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void ready(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void dropItem(const rl::CeGuiString&amp; slotName);
-    };
-
-    %feature(&quot;director&quot;) Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///&lt; Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///&lt; Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///&lt; Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-        static const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
-        static const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
-        static const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
-        static const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
-        static const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
-        static const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
-        static const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
-        static const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
-        static const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature(&quot;director&quot;) ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager&amp; getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            MT_ZIELSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN,
-            MT_STUFENERKENNUNG,
-            MT_FALLEN,
-            MT_LIEGEN
-        } MovementType;
-        
-        Creature *getCreature();
-        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &amp;name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &amp;collisionName = &quot;&quot;);
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager&amp; getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3&amp; pos);
-        void setOrientation(const Ogre::Quaternion&amp; ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast&lt;rl::Selector*&gt;(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast&lt;rl::HalfSphereSelector*&gt;(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast&lt;rl::RaySelector*&gt;(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast&lt;rl::GameObject*&gt;(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+//%template(GameObjectVector) std::vector&lt; rl::GameObject* &gt;;
+
+namespace rl {
+
+    // Before first use of GameObject or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+
+                    
+   template&lt;typename T&gt;
+   class Tripel {
+   public:
+      T first;
+      T second;
+      T third;
+
+      Tripel();      
+      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
+      Tripel(const Tripel&amp; rhs);
+
+      //Tripel&amp; operator=(const Tripel&amp; rhs);
+      bool operator==(const Tripel&amp; rhs);
+      bool operator&lt;(const Tripel&amp; rhs);     
+   };
+    
+    class Date {
+    public:
+        static const RL_LONGLONG ONE_SECOND = 1000ULL;
+        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
+        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
+        static const RL_LONGLONG ONE_DAY = 86400000ULL;
+        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
+        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
+        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
+        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
+        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
+
+        Date();
+        Date(RL_LONGLONG timestamp);
+        Date(const Date&amp; rhs);
+      
+        bool operator==(const Date&amp; rhs);
+        bool operator&lt;(const Date&amp; rhs);
+        bool operator&lt;=(const Date&amp; rhs);
+        bool operator&gt;=(const Date&amp; rhs);
+        bool operator&gt;(const Date&amp; rhs);
+
+        Date operator+(const RL_LONGLONG&amp; rhs);
+        Date operator-(const RL_LONGLONG&amp; rhs);
+        Date operator*(const Ogre::Real&amp; rhs);
+        Date operator/(const Ogre::Real&amp; rhs);
+        RL_LONGLONG operator-(const Date&amp; rhs);
+      
+        RL_LONGLONG getTimestamp();
+
+        int getTimeFraction();
+        int getYear();
+        int getMonth();
+        rl::CeGuiString getMonthName();
+        int getDayOfYear();
+        int getDayOfMonth();
+        int getDayOfWeek();
+        rl::CeGuiString getDayOfWeekName();
+        int getHour();
+        int getMinute();
+        int getSecond();
+        int getMilliSecond();
+      
+        rl::CeGuiString toString();
+    };
+   
+    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
+    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
+
+    class RulesSubsystem 
+    {
+        public:
+             static rl::RulesSubsystem&amp; getSingleton();
+             rl::QuestBook* getQuestBook();
+             void resetQuestBook();
+    };
+  
+    class DsaManager {
+    public:
+        RL_LONGLONG getTimestamp();
+        Date getCurrentDate();
+        void setCurrentDate(const Date&amp; date);
+        
+        int rollD20();
+        Tripel&lt;int&gt; roll3D20();
+        int rollD6();
+        int roll(int d6, int d20);
+      
+        static DsaManager&amp; getSingleton();
+        rl::Talent* getTalent(const rl::CeGuiString name) const;
+        rl::Creature* getCreature(const int id) const;
+    };
+    
+    %feature(&quot;director&quot;) GameObjectFactory; 
+    class GameObjectFactory
+    {
+    public:
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
+        GameObjectFactory();
+        virtual ~GameObjectFactory();
+    };
+
+    class GameObjectManager
+    {
+    public:
+        static rl::GameObjectManager&amp; getSingleton();
+        rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
+        rl::GameObject* getGameObject(unsigned int id) const;
+        void setGameObjectFactory(rl::GameObjectFactory* gof);
+
+    private:
+        GameObjectManager();
+    };
+
+	enum GameEventType
+	{
+		GET_DEFAULT,
+		GET_COMBAT,
+		GET_DIALOG,
+		GET_QUEST
+	};
+	
+    class GameEventLog
+    {
+    public:
+        static rl::GameEventLog&amp; getSingleton();
+		void logEvent(const Ogre::String&amp; eventString, GameEventType type);
+
+    private:
+        GameEventLog();
+    };
+    
+    class GlobalProperties 
+    {
+    public:
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        bool hasProperty(const Ogre::String&amp; key) const;
+        
+        static rl::GlobalProperties&amp; getSingleton();
+    private:
+        GlobalProperties();
+    };
+
+    %feature(&quot;director&quot;) QuestListener; 
+    class QuestListener
+    {
+    public:
+        virtual ~QuestListener();
+        
+        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
+        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
+        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
+    };
+
+    class JournalEntry
+    {
+    public:
+        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        virtual ~JournalEntry();
+
+        rl::CeGuiString getCaption() const;
+
+        rl::CeGuiString getText() const;
+    };
+    
+    class Quest
+    {
+    public:
+        enum State
+        {
+            OPEN = 0,
+            ASSIGNED,
+            FAILED,
+            SUCCEEDED,
+            COMPLETED
+        };
+
+        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Quest();
+
+        const rl::CeGuiString getId();
+        const rl::CeGuiString getName();
+        const rl::CeGuiString getDescription();
+        int getPartsToDo();
+        void setPartsToDo(int partsToDo);
+        int getPartsDone();
+        void setPartsDone(int partsDone);
+        void increasePartsDone(int parts = 1);
+        void decreasePartsDone(int parts = 1);
+
+        rl::Quest::State getState();
+        void setState(rl::Quest::State state);
+        bool isKnown();
+        void setKnown(bool known);
+
+        // QuestVector getSubquests();
+        void addSubquest(rl::Quest* quest); 
+    };   
+    
+    class QuestEvent
+    {
+    public:
+        rl::Quest* getQuest();
+    private:
+        QuestEvent( rl::QuestBook* src, int reason );
+    };
+    
+    class QuestBook
+    {
+    public:
+        rl::Quest* getQuest(const rl::CeGuiString id);
+        void addQuest(rl::Quest* quest);
+        
+        void addJournalEntry(rl::JournalEntry* entry);
+        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
+        
+        void addQuestListener(rl::QuestListener* listener);
+        void removeQuestListener(rl::QuestListener* listener);
+    };
+    
+    class Talent
+    {
+    public:
+        typedef std::map&lt;const rl::CeGuiString,int&gt; AusweichTalente;
+        Talent(const rl::CeGuiString name,
+               const rl::CeGuiString description,
+               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
+               int ebe,
+               int gruppe,
+               const rl::CeGuiString art,
+               const AusweichTalente &amp;ausweichTalente);
+
+        bool operator==(const Talent&amp; rhs) const;
+        bool operator&lt;(const Talent&amp; rhs) const;
+        rl::CeGuiString getName() const;
+        rl::CeGuiString getDescription() const;
+        int getEbe() const;
+
+        /// Berechnet effektive Behinderung bei gegebener Behinderung;
+        int calculateEbe(int be) const;
+        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
+    };
+
+    class ActionGroup
+    {
+    public:
+        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
+        ~ActionGroup();
+    
+        const rl::CeGuiString getName() const;
+    };
+    
+    %feature(&quot;director&quot;) Action;   
+    class Action
+    {
+    public:
+        static const int ACT_NORMAL = 1&lt;&lt;0;
+        static const int ACT_INVIS_DESC = 1&lt;&lt;1;
+        static const int ACT_DISABLED = 1&lt;&lt;2;
+        static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
+
+        static const int TC_NO_TARGET = 0;
+        static const int TC_GAMEOBJECT = 1;
+        static const int TC_CREATURE = 2;
+        static const int TC_ITEM = 3;
+        static const int TC_POINT = 4;
+        static const int TC_RADIUS = 5;
+        static const int TC_POINT_AND_RADIUS = 6;
+    
+        Action(const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Action();
+
+        virtual const rl::CeGuiString getName() const;
+        //virtual const rl::CeGuiString getClassName() const;
+        virtual const rl::CeGuiString getDescription() const;
+        virtual int getTargetClass() const;
+        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
+            rl::GameObject *target);
+        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
+            
+        void setGroup(rl::ActionGroup* group);
+        rl::ActionGroup* getGroup() const;
+    };
+    
+    %feature(&quot;director&quot;) ObjectStateChangeListener;      
+    class ObjectStateChangeListener      
+    {      
+    public:      
+        virtual ~ObjectStateChangeListener();      
+               
+        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
+    };
+              
+               
+    class ObjectStateChangeEventSource      
+    {      
+    public:      
+        ObjectStateChangeEventSource( );      
+               
+        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
+        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
+        bool hasListeners( ) const;      
+        rl::GameObject* getObject() const;
+        void fireObjectStateChangeEvent();      
+    };      
+               
+    class ObjectStateChangeEvent      
+    {      
+    public:      
+        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
+        rl::GameObject* getProvokingObject() const;      
+        rl::ObjectStateChangeEventSource* getSource() const;      
+    };
+            
+    enum GameObjectState
+    {
+        GOS_UNDEFINED = 0,
+        GOS_UNLOADED,
+        GOS_LOADED,
+        GOS_IN_POSSESSION,
+        GOS_IN_SCENE,
+        GOS_HELD,
+        GOS_READY
+    };
+    
+    class PropertyRecord
+    {
+    public:
+        PropertyRecord();
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+    
+    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
+    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
+    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
+    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
+    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
+    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
+    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
+    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
+    
+    %feature(&quot;director&quot;) GameObject;
+    class GameObject: public ObjectStateChangeEventSource
+    {
+    public:
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        virtual unsigned int getId();
+
+        virtual const rl::CeGuiString getName() const;
+        virtual void setName(rl::CeGuiString name);
+
+        const rl::CeGuiString getDescription() const;
+        virtual void setDescription(rl::CeGuiString description);   
+        
+        void setActor(rl::Actor* actor);
+        rl::Actor* getActor();
+
+        void addAction(rl::Action *action, int option = ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
+        void removeAction(rl::Action *action);
+
+        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
+        void setPosition(const Ogre::Vector3&amp; position);
+        void setOrientation(const Ogre::Quaternion&amp; orientation);
+        const Ogre::Quaternion&amp; getOrientation() const;
+        const Ogre::Vector3&amp; getPosition() const;
+        
+        void setMeshfile(rl::CeGuiString meshfile);
+        
+        virtual Action* getDefaultAction(rl::Creature* actor) const;
+        
+        void doAction(
+            const rl::CeGuiString actionName, 
+            rl::Creature* actor,
+            rl::GameObject* target);
+        void doAction(
+            const rl::CeGuiString actionName);
+        void doAction(rl::Action* action, rl::Creature* actor,
+            rl::GameObject* target);
+            
+        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
+            
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+        
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+        
+        void addEffect(rl::Effect* effect);
+        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
+        void removeEffect(rl::Effect* effect);
+        
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void placeIntoScene();
+        void removeFromScene();
+        
+        rl::GameObjectState getState() const;
+        void setState(rl::GameObjectState state);
+        
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    class WaitJob : public rl::Job
+    {
+    public:
+        WaitJob(const rl::Date&amp; dsatime);
+        WaitJob(const Ogre::Real&amp; realtime);
+    };
+    
+    class GoToJob : public rl::Job
+    {
+    public:
+
+		GoToJob(rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		// Unclear what version is called from ruby, so uncomment second ctor.
+		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+    };
+    
+    %feature(&quot;director&quot;) Item;
+    class Item : public rl::GameObject {
+    public:
+        enum ItemType{
+            ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
+            ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
+            ITEMTYPE_RING       = 1 &lt;&lt; 2,
+            ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
+            ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
+            ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
+            ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
+            ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
+            ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
+            ITEMTYPE_BELT       = 1 &lt;&lt; 9,
+            ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
+            ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
+            ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
+            ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
+            ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
+            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
+            ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+        };
+    
+        Item(unsigned int id);
+        virtual ~Item();
+        
+        virtual void placeIntoScene();
+        
+        void setItemType(rl::Item::ItemType itemType);
+        rl::Item::ItemType getItemType() const;
+        virtual void setState(rl::GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(rl::Slot* slot);
+        rl::Slot* getParentSlot() const;
+
+        void setParentContainer(rl::Container* cont);
+        rl::Container* getParentContainer() const;
+
+        void setOwner(rl::GameObject* go);
+        rl::GameObject* getOwner() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        virtual bool isContainer();
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Weapon;
+    class Weapon : public rl::Item 
+    {
+    public:
+        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
+
+        Weapon(unsigned int id);
+        virtual ~Weapon();
+                
+        void setTp(int d6, int d20, int mod);
+        const Tripel&lt;int&gt;&amp; getTp() const;
+        void setTpKk(int base, int step);
+        const std::pair&lt;int, int&gt;&amp; getTpKk() const;
+        void setBf(int newBf);
+        int getBf();
+        void setIni(int newIni);
+        int getIni();
+        void setWm(std::pair&lt;int, int&gt;&amp; newWm);
+        const std::pair&lt;int,int&gt;&amp; getWm() const;
+        void setDk(Weapon::Distanzklasse newDk);
+        Weapon::Distanzklasse getDk();
+        void setKampftechnik(const rl::CeGuiString newKampftechnik);
+        const rl::CeGuiString getKampftechnik() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Armor;
+    class Armor : public Item
+    {
+    public:
+    
+        static const CeGuiString Armor::PROPERTY_G_BE = &quot;g_be&quot;;
+        static const CeGuiString Armor::PROPERTY_G_RS = &quot;g_rs&quot;;
+        
+        Armor(unsigned int id);
+        virtual ~Armor();
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature(&quot;director&quot;) Container;
+    class Container : public Item
+    {
+    public:
+        Container(unsigned int id);
+        virtual ~Container();
+
+        Ogre::Real getCapacity() const;
+        void setCapacity(Ogre::Real capacity);
+        void setVolume(unsigned int x, unsigned int y);
+        Ogre::Real getContentWeight() const;
+        void addItem(rl::Item* item);
+        void removeItem(rl::Item* item);
+        rl::ItemSet getItems() const;
+        int getItemCount() const;
+        rl::Item* getItemAt(unsigned int x, unsigned int y);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+
+    %feature(&quot;director&quot;) Effect;
+    class Effect
+    {
+    public:    
+        typedef unsigned long LifeState;
+        static const LifeState LS_NONE           = 1&lt;&lt;0;
+        static const LifeState LS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
+        static const LifeState LS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
+        static const LifeState LS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
+        static const LifeState LS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
+        static const LifeState LS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
+        static const LifeState LS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
+        static const LifeState LS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
+        static const LifeState LS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
+        static const LifeState LS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
+        static const LifeState LS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
+        static const LifeState LS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
+
+        // Meta stati
+        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
+        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
+
+        typedef int ModType;
+        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
+        static const ModType MODTYPE_SUM      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
+        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
+        static const ModType MODTYPE_MULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
+        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
+
+        typedef unsigned long ModTag;
+        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
+        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
+        static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
+        static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
+        static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
+        static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
+        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 &lt;&lt; 6;
+    
+        enum Quantifier
+        {
+            QUANTIFIER_MULTIPLE,
+            QUANTIFIER_UNIQUE,
+            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
+            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
+        };
+        
+      // other constants
+        static const int REMOVE = -1;
+        static const int PERMANENT = 0;
+
+
+        Effect(int stufe = 1);
+        virtual ~Effect();
+
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
+        const rl::CeGuiString getDescription() const;
+        void setDescription(rl::CeGuiString description);
+        Quantifier getQuantifier();
+        void setQuantifier(Quantifier quantifier);
+        virtual const int getStufe();
+        virtual void increaseStufe();
+        virtual void decreaseStufe();
+        virtual void enable();
+        virtual void disable();
+        virtual RL_LONGLONG timeCheck() = 0;
+
+        virtual LifeState getLifeState() const;
+        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+
+    class EffectFactory
+    {
+    public:
+        virtual rl::Effect* createEffect(const Ogre::String&amp; name, int stufe) = 0;
+    };
+
+    class EffectFactoryManager
+    {
+    public:
+        void setEffectFactory(rl::EffectFactory* factory);
+        static rl::EffectFactoryManager&amp; getSingleton();
+    };
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+
+    class Inventory 
+    {
+    private:
+        Inventory(rl::Creature* owner);
+    public:
+        void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
+        rl::Item* getItem(const rl::CeGuiString&amp; slotName) const;
+        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
+        void ready(rl::Item* item, const rl::CeGuiString&amp; slot);
+        void dropItem(const rl::CeGuiString&amp; slotName);
+    };
+
+    %feature(&quot;director&quot;) Creature;
+    class Creature : public GameObject {
+    public:
+    
+    typedef Ogre::String Wert;
+        enum Alignment
+        {
+            ALIGNMENT_ALLY,    ///&lt; Creature fights with the player.
+            ALIGNMENT_NEUTRAL, ///&lt; Creature doesn't fight for either side.
+            ALIGNMENT_ENEMY    ///&lt; Creature fights against the player.
+        };
+
+        enum SfStatus
+        {
+            SFSTATUS_IN_TRAINING = 1,
+            SFSTATUS_OK,
+            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
+        };
+
+        // some targets
+        static const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
+        static const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
+        static const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
+        static const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
+        static const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
+        static const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
+        static const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
+        static const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
+        static const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
+        static const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
+        static const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
+        static const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
+        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
+        static const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
+        
+        
+        Creature(unsigned int id);
+        virtual ~Creature();
+
+        virtual int getLe();
+        virtual void modifyLe(int mod, bool ignoreMax = false);
+        virtual void modifyAe(int mod);
+        virtual void modifyAu(int mod);
+        void setWert(Wert wertId, int value);
+        virtual int getWert(Wert wertId, bool getUnmodified = false);
+        
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
+        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
+        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
+
+        
+        void addTalent(const rl::CeGuiString talentName, int value=0);
+        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
+        virtual int getTalent(const rl::CeGuiString talentName);
+        virtual void setTalent(const rl::CeGuiString talentName, int value);
+        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
+        virtual void addSe(const rl::CeGuiString talentName);
+        
+        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
+        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
+        
+        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
+        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+        
+        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
+        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
+        
+        rl::Inventory* getInventory();
+        
+        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        static const int LEDAMAGE_NORMAL = 0;
+        static const int LEDAMAGE_FIRE = 1;
+        static const int LEDAMAGE_WATER = 2;
+        static const int LEDAMAGE_DEMONIC = 4;
+        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        static const int AUDAMAGE_NORMAL = 0;
+        static const int AUDAMAGE_HEAT = 1;
+        static const int AUDAMAGE_COLD = 2;
+        static const int AUDAMAGE_CHOKE = 4;
+        static const int AUDAMAGE_DROWN = 8;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+
+        void setAlignment(Alignment);
+        Alignment getAlignment() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+   };
+   
+    %feature(&quot;director&quot;) ActionManager;
+    class ActionManager
+    {
+    public:
+        void registerAction(rl::Action* action);
+        void unregisterAction(const rl::CeGuiString actionName);
+        rl::Action* getAction(const rl::CeGuiString actionName) const;
+
+        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
+    
+        static rl::ActionManager&amp; getSingleton();
+    };
+    
+    class CreatureController
+    {
+    public:
+        
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
+        } MovementType;
+        
+        Creature *getCreature();
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const;
+        Ogre::Vector3 getRotation() const;
+        Ogre::Vector3 getVelocity() const;
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &amp;name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &amp;collisionName = &quot;&quot;);
+    protected:
+        CreatureController(Creature *character);
+        ~CreatureController();
+    };
+    
+    class CreatureControllerManager
+    {
+    public:
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        rl::CreatureController* getCreatureController(rl::Creature* creature);
+
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(rl::Creature* creature);
+
+        static rl::CreatureControllerManager&amp; getSingleton();
+    };
+
+	// Before first use of Selector or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
+
+	class Selector
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        GameObject* getFirstSelectedObject() const;
+		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+		virtual void updatePrimitive() = 0;
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
+		virtual void updatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3&amp; pos);
+        void setOrientation(const Ogre::Quaternion&amp; ori);
+		virtual void updatePrimitive();
+	};
+    
+    class PartyManager
+    {
+    public:
+        void setActiveCharacter(Creature* character);
+        Creature* getActiveCharacter() const;
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        static PartyManager&amp; getSingleton();
+    };
+
+} // Namespace
+
+%{
+static swig_type_info *Selector_dynamic_cast(void **ptr)
+{
+	rl::Selector *pSelector = static_cast&lt;rl::Selector*&gt;(*ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast&lt;rl::HalfSphereSelector*&gt;(pSelector);
+	if (pHalfSphereSel)
+	{
+		*ptr = pHalfSphereSel;
+		return SWIGTYPE_p_rl__HalfSphereSelector;
+	}
+	rl::RaySelector *pRaySel = dynamic_cast&lt;rl::RaySelector*&gt;(pSelector);
+	if (pRaySel)
+	{
+		*ptr = pRaySel;
+		return SWIGTYPE_p_rl__RaySelector;
+	}
+}
+	
+static swig_type_info *GameObject_dynamic_cast(void **ptr)
+{
+    rl::GameObject *pGameObject = static_cast&lt;rl::GameObject*&gt;(*ptr);
+
+    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(pGameObject);
+    if (pCreature) {
+        *ptr=pCreature;
+        return SWIGTYPE_p_rl__Creature;
+    }
+    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(pGameObject);
+    if (pWeapon) {
+        *ptr=pWeapon;
+        return SWIGTYPE_p_rl__Weapon;
+    }
+    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(pGameObject);
+    if (pArmor) {
+        *ptr=pArmor;
+        return SWIGTYPE_p_rl__Armor;
+    }
+    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(pGameObject);
+    if (pContainer) {
+        *ptr=pContainer;
+        return SWIGTYPE_p_rl__Container;
+    }
+    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(pGameObject);
+    if (pItem) {
+        *ptr=pItem;
+        return SWIGTYPE_p_rl__Item;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
+

Modified: rl/branches/newton20/engine/script/swig/RlUi.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlUi.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlUi.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,162 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-
-%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
-
-%feature(&quot;director&quot;) ControlState;
-class ControlState
-{
-private:
-    ControlState(rl::Actor* camera, rl::Actor* character);
-public:
-};
-
-class CutsceneControlState : public ControlState
-{
-private:
-       CutsceneControlState(rl::Actor* camera);
-
-public:
-    virtual ~CutsceneControlState();
-
-    void setCameraPosition(const Ogre::Vector3&amp; pos);
-    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
-    void lookAt(const Ogre::Vector3&amp; point);
-};
-
-class UiSubsystem
-{
-public:
-    static UiSubsystem&amp; getSingleton(void);
-    void initializeSubsystem();
-
-    rl::Creature* getActiveCharacter();
-    void setActiveCharacter(rl::Creature* chara);
-};
-
-enum ControlStateType 
-{
-    CST_NONE = 1,
-    CST_FREEFLIGHT,
-    CST_MOVEMENT,
-    CST_DIALOG,
-    CST_CUTSCENE,
-    CST_COMBAT,
-};
-
-class InputManager
-{
-public:
-    static InputManager&amp; getSingleton(void);
-
-    void pushControlState(rl::ControlStateType);
-    void popControlState();
-
-    void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
-private:
-    InputManager();
-};
-
-class WindowFactory
-{
-public:
-    enum PopupType
-    {
-        ICON_ERROR = 1,
-        ICON_QUEST
-    };
-
-    static rl::WindowFactory&amp; getSingleton();
-
-    void update();
-
-    void showAboutWindow();
-    void showActionChoice(rl::GameObject* obj);
-    void showCharacterActionChoice();
-    void showCharacterSheet();
-    void showCharacterSheet(rl::Creature* chara);
-    void showContainerContent(rl::Container* container);
-    void showDescriptionWindow(rl::GameObject* obj);
-    void showPropertiesWindow(rl::GameObject* obj);
-    void showGameSaveLoadWindow();
-    void showExitConfirmation();
-    void showJournalWindow();
-    void showLogfiles();
-    void showMainMenu();
-    void showMessageWindow(const rl::CeGuiString&amp; message);
-    void showPlaylist();
-    void showPopupMessage(int popupTypes);
-    void showGameSettings();
-
-    void toggleConsole();
-    void toggleDebugWindow();
-    void toggleGameLogWindow();
-    void toggleCharacterStateWindow();
-    void toggleInGameGlobalMenu();
-    void toggleInventoryWindow();
-
-    void checkForErrors();
-    rl::GameLoggerWindow* getGameLogger();
-
-    void showNextDebugWindowPage();
-};
-
-class WindowManager
-{
-public:
-    static rl::WindowManager&amp; getSingleton();
-    void closeTopWindow();
-};
-
-%feature(&quot;director&quot;) MessageWindow; 
-class MessageWindow
-{
-public:
-    enum Buttons 
-    {
-        OK,
-        YES_NO
-    };
-
-    MessageWindow::MessageWindow(
-        const rl::CeGuiString&amp; title, 
-        const rl::CeGuiString&amp; text, 
-        const Buttons buttons);
-    virtual ~MessageWindow();
-    virtual bool onButtonClicked(int button, const rl::CeGuiString&amp; text);
-    void setVisible(bool visible);
-};
-
-} //namespace rl
-
-%{
-static swig_type_info *ControlState_dynamic_cast(void **ptr)
-{
-    rl::ControlState *pControlState =
-        static_cast&lt;rl::ControlState*&gt;(*ptr);
-
-    rl::CutsceneControlState *pCutSceneCS =
-        dynamic_cast&lt;rl::CutsceneControlState*&gt;(pControlState);
-    if (pCutSceneCS != NULL) {
-        *ptr=pCutSceneCS;
-        return SWIGTYPE_p_rl__CutsceneControlState;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+
+%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
+
+%feature(&quot;director&quot;) ControlState;
+class ControlState
+{
+private:
+    ControlState(rl::Actor* camera, rl::Actor* character);
+public:
+};
+
+class CutsceneControlState : public ControlState
+{
+private:
+       CutsceneControlState(rl::Actor* camera);
+
+public:
+    virtual ~CutsceneControlState();
+
+    void setCameraPosition(const Ogre::Vector3&amp; pos);
+    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
+    void lookAt(const Ogre::Vector3&amp; point);
+};
+
+class UiSubsystem
+{
+public:
+    static UiSubsystem&amp; getSingleton(void);
+    void initializeSubsystem();
+};
+
+enum ControlStateType 
+{
+    CST_NONE = 1,
+    CST_FREEFLIGHT,
+    CST_MOVEMENT,
+    CST_DIALOG,
+    CST_CUTSCENE,
+    CST_COMBAT,
+};
+
+class InputManager
+{
+public:
+    static InputManager&amp; getSingleton(void);
+
+    void pushControlState(rl::ControlStateType);
+    void popControlState();
+
+    void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
+private:
+    InputManager();
+};
+
+class WindowFactory
+{
+public:
+    enum PopupType
+    {
+        ICON_ERROR = 1,
+        ICON_QUEST
+    };
+
+    static rl::WindowFactory&amp; getSingleton();
+
+    void update();
+
+    void showAboutWindow();
+    void showActionChoice(rl::GameObject* obj);
+    void showCharacterActionChoice();
+    void showCharacterSheet();
+    void showCharacterSheet(rl::Creature* chara);
+    void showContainerContent(rl::Container* container);
+    void showDescriptionWindow(rl::GameObject* obj);
+    void showPropertiesWindow(rl::GameObject* obj);
+    void showGameSaveLoadWindow();
+    void showExitConfirmation();
+    void showJournalWindow();
+    void showLogfiles();
+    void showMainMenu();
+    void showMessageWindow(const rl::CeGuiString&amp; message);
+    void showPlaylist();
+    void showPopupMessage(int popupTypes);
+    void showGameSettings();
+
+    void toggleConsole();
+    void toggleDebugWindow();
+    void toggleGameLogWindow();
+    void toggleCharacterStateWindow();
+    void toggleInGameGlobalMenu();
+    void toggleInventoryWindow();
+
+    void checkForErrors();
+    rl::GameLoggerWindow* getGameLogger();
+
+    void showNextDebugWindowPage();
+};
+
+class WindowManager
+{
+public:
+    static rl::WindowManager&amp; getSingleton();
+    void closeTopWindow();
+};
+
+%feature(&quot;director&quot;) MessageWindow; 
+class MessageWindow
+{
+public:
+    enum Buttons 
+    {
+        OK,
+        YES_NO
+    };
+
+    MessageWindow::MessageWindow(
+        const rl::CeGuiString&amp; title, 
+        const rl::CeGuiString&amp; text, 
+        const Buttons buttons);
+    virtual ~MessageWindow();
+    virtual bool onButtonClicked(int button, const rl::CeGuiString&amp; text);
+    void setVisible(bool visible);
+};
+
+} //namespace rl
+
+%{
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
+{
+    rl::ControlState *pControlState =
+        static_cast&lt;rl::ControlState*&gt;(*ptr);
+
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast&lt;rl::CutsceneControlState*&gt;(pControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/branches/newton20/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -377,6 +377,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\GameOverWindow.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\InputManager.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -598,6 +602,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\GameOverWindow.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\InputManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Copied: rl/branches/newton20/engine/ui/include/GameOverWindow.h (from rev 4518, rl/trunk/engine/ui/include/GameOverWindow.h)

Modified: rl/branches/newton20/engine/ui/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/include/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -21,6 +21,7 @@
     FreeflightControlState.h \
     GameLoggerWindow.h \
     GameObjectInfoWindow.h \
+	GameOverWindow.h \
 	GameSaveLoadWindow.h \
     GameSettings.h \
     InfoPopup.h \

Modified: rl/branches/newton20/engine/ui/include/UiMessages.h
===================================================================
--- rl/branches/newton20/engine/ui/include/UiMessages.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/UiMessages.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -37,10 +37,7 @@
 
         RLMSG_COMBAT_IO_ATTACK_OPPONENT = 0x04000103,
         RLMSG_COMBAT_IO_PARRY_OPPONENT = 0x04000104,
-        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105,
-
-        // Character change
-        RLMSG_ACTIVE_CHARACTER_CHANGED = 0x04000201
+        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105
     };
 
     /// Message sent after enemy action button has been pressed.
@@ -53,7 +50,5 @@
     typedef MessageType&lt;RLMSG_COMBAT_IO_ATTACK_OPPONENT, Combatant*&gt; MessageType_CombatIoAttackOpponent;
     typedef MessageType&lt;RLMSG_COMBAT_IO_PARRY_OPPONENT, Combatant*&gt; MessageType_CombatIoParryOpponent;
     typedef MessageType&lt;RLMSG_COMBAT_IO_END_TURN_REQUESTED&gt; MessageType_CombatIoEndTurnRequested;
-
-    typedef MessageType&lt;RLMSG_ACTIVE_CHARACTER_CHANGED, Creature*&gt; MessageType_ActiveCharacterChanged;
 }
 #endif

Modified: rl/branches/newton20/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/branches/newton20/engine/ui/include/UiSubsystem.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/UiSubsystem.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,84 +1,89 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __UiSubsystem_H__
-#define __UiSubsystem_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;World.h&quot;
-
-
-#include &quot;ControlState.h&quot;
-#include &quot;MessagePump.h&quot;
-
-// Gar nicht sch&#246;n, aber ansonsten gibt es unn&#246;tige Abh&#228;ngigkeiten,
-// wenn man die Header hier inkludiert.
-namespace CEGUI {
-    class OgreCEGUIRenderer;
-    class OgreCEGUIResourceProvider;
-    class System;
-}
-
-namespace rl {
-
-    class Creature;
-    class GameActor;
-    class GameObject;
-    class InputManager;
-    class WindowFactory;
-    class WindowManager;
-
-    class _RlUiExport UiSubsystem : public Ogre::Singleton&lt;UiSubsystem&gt;
-    {
-    public:
-        static const char* CEGUI_ROOT;
-
-        /** Default Constructor */
-        UiSubsystem();
-        /** Default Deconstructor */
-        virtual ~UiSubsystem();
-
-        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
-        Creature* getActiveCharacter() const;
-        ///@todo function feels misplaced here,
-        void setActiveCharacter(Creature* person);
-
-        virtual bool onBeforeClearScene();
-        virtual bool onBeforeGameObjectsLoaded();
-        virtual bool onGameObjectsLoaded();
-
-        void initializeSubsystem();
-
-    private:
-        Creature* mCharacter;
-        int mCharacterId;
-
-	    MessagePump::ScopedConnection mSceneClearingConnection;
-        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
-        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
-
-        // Singletons
-        InputManager* mInputManager;
-        WindowFactory* mWindowFactory;
-        WindowManager* mWindowManager;
-
-        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
-        CEGUI::ResourceProvider* mGuiResourceProvider;
-        CEGUI::System* mGuiSystem;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __UiSubsystem_H__
+#define __UiSubsystem_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;World.h&quot;
+
+
+#include &quot;ControlState.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;Effect.h&quot;
+
+// Gar nicht sch&#203;&#134;n, aber ansonsten gibt es unn&#203;&#134;tige Abh&#226;&#128;&#176;ngigkeiten,
+// wenn man die Header hier inkludiert.
+namespace CEGUI {
+    class OgreCEGUIRenderer;
+    class OgreCEGUIResourceProvider;
+    class System;
+}
+
+namespace rl {
+
+    class Creature;
+    class GameActor;
+    class GameObject;
+    class InputManager;
+    class WindowFactory;
+    class WindowManager;
+
+    class _RlUiExport UiSubsystem : public Ogre::Singleton&lt;UiSubsystem&gt;
+    {
+    public:
+        static const char* CEGUI_ROOT;
+
+        /** Default Constructor */
+        UiSubsystem();
+        /** Default Deconstructor */
+        virtual ~UiSubsystem();
+
+        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
+
+        void initializeSubsystem();
+
+    private:
+        Creature* mCharacter;
+        int mCharacterId;
+
+	    MessagePump::ScopedConnection mSceneClearingConnection;
+        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
+        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
+        MessagePump::ScopedConnection mActiveCharacterChangedConnection;
+        MessagePump::ScopedConnection mAllPlayerCharactersDiedConnection;
+
+        bool onBeforeClearScene();
+        bool onBeforeGameObjectsLoaded();
+        bool onGameObjectsLoaded();
+        ///@todo function feels misplaced here,
+        bool onActiveCharacterChanged(Creature* oldActive, Creature* newActive);
+        bool onAllPlayerCharactersDied();
+        
+
+        // Singletons
+        InputManager* mInputManager;
+        WindowFactory* mWindowFactory;
+        WindowManager* mWindowManager;
+
+        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
+        CEGUI::ResourceProvider* mGuiResourceProvider;
+        CEGUI::System* mGuiSystem;
+        
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/ui/include/WindowFactory.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -86,6 +86,7 @@
         void showMainMenuLoadWindow(MainMenuWindow* win);
 		void hideMainMenuLoadWindow();
         void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
         /**
          * Creates a GameSettings object and displays its layout file on screen
          */

Modified: rl/branches/newton20/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,235 +1,236 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;UiPrerequisites.h&quot;
-
-#include &quot;UiSubsystem.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;GameLoop.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;MeshObject.h&quot;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-template&lt;&gt; rl::DebugWindow* Ogre::Singleton&lt;rl::DebugWindow&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    DebugWindow::DebugWindow() : AbstractWindow(&quot;debugwindow.xml&quot;, WIT_NONE),
-          mMessageText(),
-          mPageCaption(),
-          mPageText(),
-          mPageTexts(),
-          mCurrentPage(StringUtil::BLANK),
-          mDebugPageName(&quot;General Informations&quot;)
-    {
-        mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
-        mPageCaption-&gt;moveToFront();
-
-        mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
-
-        mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
-        mMessageText-&gt;moveToFront();
-
-        bindDestroyWindowToXButton();
-        registerPage(&quot;General Informations&quot;);
-    }
-
-    DebugWindow::~DebugWindow()
-    {
-        unregisterPage(&quot;General Informations&quot;);
-    }
-
-    void DebugWindow::registerPage(const Ogre::String&amp; page)
-    {
-        if (mPageTexts.find(page) != mPageTexts.end())
-        {
-            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; already registered as a page.&quot;);
-        }
-        else
-        {
-            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
-        }
-
-        // If this is the first page, activate it
-        if (mCurrentPage == StringUtil::BLANK)
-        {
-            mCurrentPage = page;
-        }
-    }
-
-    void DebugWindow::unregisterPage(const Ogre::String&amp; page)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it != mPageTexts.end())
-        {
-            mPageTexts.erase(it);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, page + &quot; is not registered as a page.&quot;);
-        }
-
-        // If this is the current page, switch over to the next
-        // or clear text, if no other page is left.
-        if (mCurrentPage == page &amp;&amp; !mPageTexts.empty())
-        {
-            mCurrentPage = page;
-        }
-        else if (mCurrentPage == page)
-        {
-            mCurrentPage = StringUtil::BLANK;
-        }
-        updatePageText();
-    }
-
-    void DebugWindow::setPageText(const Ogre::String&amp; page, const Ogre::String&amp; text)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it == mPageTexts.end())
-        {
-            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; is not registered as a page.&quot;);
-        }
-        else
-        {
-            it-&gt;second = text;
-        }
-
-        if (mCurrentPage == page)
-        {
-            updatePageText();
-        }
-    }
-
-    void DebugWindow::setMessageText(const Ogre::String&amp; text)
-    {
-        CeGuiString o(text.c_str());
-        mMessageText-&gt;setText(o);
-    }
-
-    void DebugWindow::showNextPage()
-    {
-        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
-        if (it != mPageTexts.end())
-        {
-            ++it;
-            if (it == mPageTexts.end())
-            {
-                it = mPageTexts.begin();
-            }
-            mCurrentPage = it-&gt;first;
-            updatePageText();
-        }
-        else
-        {
-            RlAssert1(mPageTexts.empty());
-        }
-    }
-
-    void DebugWindow::run(Ogre::Real elapsedTime)
-    {
-        updateFps();
-    }
-
-    void DebugWindow::updatePageText()
-    {
-        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
-            StringUtil::BLANK : mPageTexts[mCurrentPage];
-        mPageCaption-&gt;setText(mCurrentPage);
-        mPageText-&gt;setText(text);
-    }
-
-    void DebugWindow::updateFps()
-    {
-        const RenderTarget::FrameStats&amp; stats = CoreSubsystem::getSingleton().getRenderWindow()-&gt;getStatistics();
-
-        Ogre::String textSt = &quot;Current FPS: &quot; +
-            StringConverter::toString(stats.lastFPS)+
-            &quot;\nBest/worst/avg FPS: &quot; +
-            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.worstFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.avgFPS)+
-            &quot;\nBest/worst Frame times: &quot; +
-            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
-            StringConverter::toString(stats.worstFPS)+
-            &quot;\nTriangle Count: &quot; +
-            StringConverter::toString(stats.triangleCount);
-
-        if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &amp;&amp;
-            UiSubsystem::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
-        {
-            ActorControlledObject* charObj = UiSubsystem::getSingletonPtr()-&gt;
-                getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
-
-            if( charObj != NULL )
-            {
-                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
-                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
-
-                textSt += &quot;\nPlayer Position [ &quot;
-                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-
-                textSt += &quot;\nPlayer Orientation [ &quot;
-                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-            }
-        }
-
-        Actor* camActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-        if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
-        {
-            Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
-            Ogre::Vector3 pos = cam-&gt;getDerivedPosition();
-
-            textSt += &quot;\nCamera Position [ &quot;
-                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-        }
-
-        setPageText(mDebugPageName, textSt);
-    }
-
-    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
-    {
-        AbstractWindow::setVisible(visible, destroyAfterHide);
-        if (visible)
-            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-        else
-            GameLoop::getSingleton().removeTask(this);
-    }
-
-    const Ogre::String&amp; DebugWindow::getName() const
-    {
-        static Ogre::String NAME = &quot;DebugWindow&quot;;
-
-        return NAME;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;UiPrerequisites.h&quot;
+
+#include &quot;UiSubsystem.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;GameLoop.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;PartyManager.h&quot;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+template&lt;&gt; rl::DebugWindow* Ogre::Singleton&lt;rl::DebugWindow&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    DebugWindow::DebugWindow() : AbstractWindow(&quot;debugwindow.xml&quot;, WIT_NONE),
+          mMessageText(),
+          mPageCaption(),
+          mPageText(),
+          mPageTexts(),
+          mCurrentPage(StringUtil::BLANK),
+          mDebugPageName(&quot;General Informations&quot;)
+    {
+        mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
+        mPageCaption-&gt;moveToFront();
+
+        mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
+
+        mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
+        mMessageText-&gt;moveToFront();
+
+        bindDestroyWindowToXButton();
+        registerPage(&quot;General Informations&quot;);
+    }
+
+    DebugWindow::~DebugWindow()
+    {
+        unregisterPage(&quot;General Informations&quot;);
+    }
+
+    void DebugWindow::registerPage(const Ogre::String&amp; page)
+    {
+        if (mPageTexts.find(page) != mPageTexts.end())
+        {
+            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; already registered as a page.&quot;);
+        }
+        else
+        {
+            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
+        }
+
+        // If this is the first page, activate it
+        if (mCurrentPage == StringUtil::BLANK)
+        {
+            mCurrentPage = page;
+        }
+    }
+
+    void DebugWindow::unregisterPage(const Ogre::String&amp; page)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it != mPageTexts.end())
+        {
+            mPageTexts.erase(it);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, page + &quot; is not registered as a page.&quot;);
+        }
+
+        // If this is the current page, switch over to the next
+        // or clear text, if no other page is left.
+        if (mCurrentPage == page &amp;&amp; !mPageTexts.empty())
+        {
+            mCurrentPage = page;
+        }
+        else if (mCurrentPage == page)
+        {
+            mCurrentPage = StringUtil::BLANK;
+        }
+        updatePageText();
+    }
+
+    void DebugWindow::setPageText(const Ogre::String&amp; page, const Ogre::String&amp; text)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it == mPageTexts.end())
+        {
+            LOG_ERROR(&quot;DebugWindow&quot;, page + &quot; is not registered as a page.&quot;);
+        }
+        else
+        {
+            it-&gt;second = text;
+        }
+
+        if (mCurrentPage == page)
+        {
+            updatePageText();
+        }
+    }
+
+    void DebugWindow::setMessageText(const Ogre::String&amp; text)
+    {
+        CeGuiString o(text.c_str());
+        mMessageText-&gt;setText(o);
+    }
+
+    void DebugWindow::showNextPage()
+    {
+        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
+        if (it != mPageTexts.end())
+        {
+            ++it;
+            if (it == mPageTexts.end())
+            {
+                it = mPageTexts.begin();
+            }
+            mCurrentPage = it-&gt;first;
+            updatePageText();
+        }
+        else
+        {
+            RlAssert1(mPageTexts.empty());
+        }
+    }
+
+    void DebugWindow::run(Ogre::Real elapsedTime)
+    {
+        updateFps();
+    }
+
+    void DebugWindow::updatePageText()
+    {
+        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
+            StringUtil::BLANK : mPageTexts[mCurrentPage];
+        mPageCaption-&gt;setText(mCurrentPage);
+        mPageText-&gt;setText(text);
+    }
+
+    void DebugWindow::updateFps()
+    {
+        const RenderTarget::FrameStats&amp; stats = CoreSubsystem::getSingleton().getRenderWindow()-&gt;getStatistics();
+
+        Ogre::String textSt = &quot;Current FPS: &quot; +
+            StringConverter::toString(stats.lastFPS)+
+            &quot;\nBest/worst/avg FPS: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.avgFPS)+
+            &quot;\nBest/worst Frame times: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS)+
+            &quot;\nTriangle Count: &quot; +
+            StringConverter::toString(stats.triangleCount);
+
+        if (PartyManager::getSingleton().getActiveCharacter() != NULL &amp;&amp;
+            PartyManager::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
+        {
+            ActorControlledObject* charObj = PartyManager::getSingletonPtr()-&gt;
+                getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
+
+            if( charObj != NULL )
+            {
+                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
+                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
+
+                textSt += &quot;\nPlayer Position [ &quot;
+                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+
+                textSt += &quot;\nPlayer Orientation [ &quot;
+                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+            }
+        }
+
+        Actor* camActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
+        if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
+        {
+            Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
+            Ogre::Vector3 pos = cam-&gt;getDerivedPosition();
+
+            textSt += &quot;\nCamera Position [ &quot;
+                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+        }
+
+        setPageText(mDebugPageName, textSt);
+    }
+
+    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+        if (visible)
+            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
+        else
+            GameLoop::getSingleton().removeTask(this);
+    }
+
+    const Ogre::String&amp; DebugWindow::getName() const
+    {
+        static Ogre::String NAME = &quot;DebugWindow&quot;;
+
+        return NAME;
+    }
+
+}

Copied: rl/branches/newton20/engine/ui/src/GameOverWindow.cpp (from rev 4518, rl/trunk/engine/ui/src/GameOverWindow.cpp)

Modified: rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -106,7 +106,6 @@
     {
         //mSaveGameTable-&gt;autoSizeColumnHeader(0);
         //mSaveGameTable-&gt;autoSizeColumnHeader(1);
-        listSaveGames();
     }
 
     //------------------------------------------------------- LoadEvent
@@ -123,13 +122,6 @@
         if(filename != &quot;&quot;)
         {
 
-            if(SaveGameManager::getSingleton().SaveGameFileExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()))
-                SaveGameManager::getSingleton().loadSaveGameFile(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
-            else
-            {
-                LOG_ERROR(Logger::UI, &quot;Save Game &quot; + filename + &quot; doesn't exist!&quot;);
-                WindowFactory::getSingleton().showMessageWindow(&quot;Der Spielstand existiert nicht&quot;);
-            }
         }*/
 
         return true;
@@ -145,18 +137,13 @@
 
         if(filename != &quot;&quot;)
         {
-            LOG_MESSAGE(Logger::UI, &quot;Create a SaveGameFile&quot;);
 
-            SaveGameManager::getSingleton().saveSaveGameFile(filename);
-
-            LOG_MESSAGE(Logger::UI, &quot;Created save game&quot;);
         }
         else
         {
             WindowFactory::getSingleton().showMessageWindow(&quot;Bitte einen Namen f&#252;r den Spielstand eingeben&quot;);
         }
 
-        listSaveGames();
 
         return true;
     }
@@ -166,35 +153,12 @@
     bool GameSaveLoadWindow::handleDeleteEvent()
     {
         LOG_MESSAGE(Logger::UI, &quot;Delete Button pressed&quot;);
-        if(SaveGameManager::getSingleton().SaveGameFileExists(mFilename-&gt;getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId()))
-        {
-            SaveGameManager::getSingleton().deleteSaveGameFile(mFilename-&gt;getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
-            listSaveGames();
-        }
+
         return true;
     }
 
     void GameSaveLoadWindow::listSaveGames()
     {
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId());
-    
-        while(mSaveGameTable-&gt;getRowCount() &gt; saveGames.size())
-		    mSaveGameTable-&gt;removeRow(mSaveGameTable-&gt;getRowCount()-1);
-        while(mSaveGameTable-&gt;getRowCount() &lt; saveGames.size())
-		    mSaveGameTable-&gt;addRow();
-        
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            ListboxTextItem* item = new CEGUI::ListboxTextItem(it-&gt;second-&gt;getName());
-            item-&gt;setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable-&gt;setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_TIME));
-            item-&gt;setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable-&gt;setItem(item, 1, saveGameNum);
-            saveGameNum++;
-        }
         //mSaveGameTable-&gt;autoSizeColumnHeader(0);
         //mSaveGameTable-&gt;autoSizeColumnHeader(1);
     }

Modified: rl/branches/newton20/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -51,6 +51,7 @@
 #include &quot;Job.h&quot;
 #include &quot;JobScheduler.h&quot;
 #include &quot;MovementControlState.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;RubyInterpreter.h&quot;
 #include &quot;UiSubsystem.h&quot;
 #include &quot;WindowFactory.h&quot;
@@ -394,7 +395,7 @@
     void InputManager::pushControlState(ControlStateType controlStateType)
     {
         Actor* camera = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-        Creature* character = UiSubsystem::getSingleton().getActiveCharacter();
+        Creature* character = PartyManager::getSingleton().getActiveCharacter();
 
         ControlState* controller = NULL;
         switch (controlStateType)

Modified: rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -114,7 +114,6 @@
 		//	module = CoreSubsystem::getSingleton().getModule(moduleId.c_str());
 		//	assert(module != NULL /*MainMenuLoadWindow::handleLoadEvent()*/);
 		//	CoreSubsystem::getSingleton().startAdventureModule(module);
-		//	SaveGameManager::getSingleton().loadSaveGameFile(((SaveGameFile*)mSaveGameTable-&gt;getFirstSelectedItem()-&gt;getUserData())-&gt;getId());
 		//}
 
         return true;
@@ -129,9 +128,6 @@
         if(mSaveGameTable-&gt;getFirstSelectedItem())
 		{
             mSaveGameTable-&gt;getRowWithID(mSaveGameTable-&gt;getFirstSelectedItem()-&gt;getID());
-            
-            SaveGameManager::getSingleton().deleteSaveGameFile(
-                ((SaveGameFile*)mSaveGameTable-&gt;getFirstSelectedItem()-&gt;getUserData())-&gt;getId());
         }
 
         return true;
@@ -140,31 +136,6 @@
     void MainMenuLoadWindow::listSaveGames()
     {
         mSaveGameTable-&gt;clearAllSelections();
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames();
-
-        while(mSaveGameTable-&gt;getRowCount() &gt; saveGames.size())
-		    mSaveGameTable-&gt;removeRow(mSaveGameTable-&gt;getRowCount()-1);
-        while(mSaveGameTable-&gt;getRowCount() &lt; saveGames.size())
-		    mSaveGameTable-&gt;addRow();
-
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            CEGUI::ListboxTextItem* item = new CEGUI::ListboxTextItem(it-&gt;second-&gt;getName());
-            item-&gt;setUserData(it-&gt;second);
-            item-&gt;setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable-&gt;setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_MODULENAME).toString());
-            item-&gt;setUserData(it-&gt;second);
-            item-&gt;setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable-&gt;setItem(item, 1, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it-&gt;second-&gt;getProperty(SaveGameFile::PROPERTY_TIME).toString());
-            item-&gt;setUserData(it-&gt;second);
-            item-&gt;setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable-&gt;setItem(item, 2, saveGameNum);
-            saveGameNum++;
-        }
         /*mSaveGameTable-&gt;autoSizeColumnHeader(0);
         mSaveGameTable-&gt;autoSizeColumnHeader(1);
         mSaveGameTable-&gt;autoSizeColumnHeader(2);*/

Modified: rl/branches/newton20/engine/ui/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/src/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -29,6 +29,7 @@
     FreeflightControlState.cpp \
     GameLoggerWindow.cpp \
     GameObjectInfoWindow.cpp \
+	GameOverWindow.cpp \
 	GameSaveLoadWindow.cpp \
     GameSettings.cpp \
     InfoPopup.cpp \

Modified: rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -40,6 +40,7 @@
 #include &quot;ItemDescriptionDragContainer.h&quot;
 #include &quot;ItemIconDragContainer.h&quot;
 #include &quot;Logger.h&quot;
+#include &quot;RulesMessages.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 #include &quot;SoundManager.h&quot;
 #include &quot;UiMessages.h&quot;
@@ -82,6 +83,9 @@
         mBeforeLoadingGameObjectsConnection = 
             MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; &gt;(
                 boost::bind(&amp;UiSubsystem::onBeforeGameObjectsLoaded, this));
+        mActiveCharacterChangedConnection = 
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_ActivePlayerCharChanged&gt;(
+                boost::bind(&amp;UiSubsystem::onActiveCharacterChanged, this, _1, _2));
         mWindowFactory = new WindowFactory();
     }
 
@@ -166,58 +170,47 @@
         return mGuiRenderer;
     }
 
-    Creature* UiSubsystem::getActiveCharacter() const
+    bool UiSubsystem::onActiveCharacterChanged(Creature* oldActive, Creature* newActive)
     {
-        return mCharacter;
-    }
-
-    void UiSubsystem::setActiveCharacter(Creature* creature)
-    {
         // Ensure we have a sound listener
         if (SoundManager::getSingleton().getListenerActor() == NULL)
         {
             SoundManager::getSingleton().createListenerActor();
         }
 
-        if (creature != mCharacter )
+        if (oldActive)
         {
-            if (mCharacter)
+            ScriptWrapper::getSingleton().disowned( oldActive );
+            if (oldActive-&gt;getActor())
             {
-                ScriptWrapper::getSingleton().disowned( mCharacter );
-                if (mCharacter-&gt;getActor())
-                {
-                    mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
-                }
-                mCharacter-&gt;setQueryFlags(mCharacter-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
+                oldActive-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
             }
-
-            if (!creature)
-            {
-                mCharacter = NULL;
-                mInputManager-&gt;clearControlStates();
-            }
-            else
-            {
-                ScriptWrapper::getSingleton().owned(creature);
-                mCharacter = creature;
-                mCharacter-&gt;addQueryFlag(QUERYFLAG_PLAYER);
-
-                mWindowFactory-&gt;setActiveCharacter(creature);
-
-                mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
-                LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
-
-                // Reset control stack for the new Character and set to movement.
-                mInputManager-&gt;setControlState(CST_MOVEMENT);
-            }
-
-            MessagePump::getSingleton().sendMessage&lt;MessageType_ActiveCharacterChanged&gt;(creature);
+            oldActive-&gt;setQueryFlags(oldActive-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
         }
+        
+        if (!newActive)
+        {
+            mInputManager-&gt;clearControlStates();
+        }
+        else
+        {
+            ScriptWrapper::getSingleton().owned(newActive);
+            newActive-&gt;addQueryFlag(QUERYFLAG_PLAYER);
+            
+            mWindowFactory-&gt;setActiveCharacter(newActive);
+            
+            newActive-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
+            LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
+            
+            // Reset control stack for the new Character and set to movement.
+            mInputManager-&gt;setControlState(CST_MOVEMENT);
+        }
+        
+        return true;
     }
 
     bool UiSubsystem::onBeforeClearScene()
     {
-        setActiveCharacter(NULL);
         // Remove control states here too, in case that there has not yet been a
         // person set active.
         mInputManager-&gt;clearControlStates();
@@ -258,9 +251,18 @@
             mCharacterId = mCharacter-&gt;getId();
         }
         else
+        {
             mCharacterId = -1;
-
+        }
+        
         //mInputManager-&gt;clearControlStates();
         return false;
     }
+    
+    bool UiSubsystem::onAllPlayerCharactersDied()
+    {
+        LOG_MESSAGE(Logger::UI, &quot;All player chars are dead, show game over&quot;);
+        WindowFactory::getSingleton().showGameOverWindow();
+        return true;
+    }
 }

Modified: rl/branches/newton20/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,455 +1,462 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;WindowFactory.h&quot;
-
-#include &quot;AboutWindow.h&quot;
-#include &quot;ActionChoiceWindow.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CharacterSheetWindow.h&quot;
-#include &quot;CharacterStateWindow.h&quot;
-#include &quot;CloseConfirmationWindow.h&quot;
-#include &quot;CombatWindow.h&quot;
-#include &quot;Console.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;DialogControlState.h&quot;
-#include &quot;DialogWindow.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameLoggerWindow.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;GameObjectInfoWindow.h&quot;
-#include &quot;PropertiesWindow.h&quot;
-#include &quot;GameSaveLoadWindow.h&quot;
-#include &quot;MainMenuLoadWindow.h&quot;
-#include &quot;GameSettings.h&quot;
-#include &quot;InfoPopup.h&quot;
-#include &quot;InGameMenuWindow.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;InventoryWindow.h&quot;
-#include &quot;JournalWindow.h&quot;
-#include &quot;LogWindow.h&quot;
-#include &quot;MessageWindow.h&quot;
-#include &quot;MainMenuWindow.h&quot;
-#include &quot;MainMenuEngineWindow.h&quot;
-#include &quot;MovableText.h&quot;
-#include &quot;ObjectDescriptionWindow.h&quot;
-#include &quot;PlaylistWindow.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;SubtitleWindow.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowManager.h&quot;
-
-#undef max
-
-template&lt;&gt; rl::WindowFactory* Ogre::Singleton&lt;rl::WindowFactory&gt;::ms_Singleton = 0;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl {
-
-    WindowFactory::WindowFactory()
-        : mGameLogger(NULL),
-        mCharacterStateWindow(NULL),
-        mInGameMenuWindow(NULL),
-        mCharacterSheet(NULL),
-        mJournalWindow(NULL),
-        mInventoryWindow(NULL),
-        mLogWindow(NULL),
-        mDebugWindow(NULL),
-        mConsole(NULL),
-        mInfoPopup(NULL),
-        mObjectNameText(NULL),
-        mShownObject(NULL),
-        mObjectDescriptionWindow(NULL),
-        mMainMenuWindow(NULL),
-		mMainMenuLoadWindow(NULL),
-        mGameSettings(NULL),
-        mCombatWindow(NULL)
-    {
-    }
-
-    void WindowFactory::initialize()
-    {
-        mConsole = new Console();
-        mDebugWindow = new DebugWindow();
-        CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;
-            setOutputFunction(
-                (VALUE(*)(...))&amp;WindowFactory::consoleWrite );
-
-        mLogWindow = new LogWindow();
-
-        mGameLogger = new GameLoggerWindow();
-        mCharacterStateWindow = new CharacterStateWindow();
-        mInGameMenuWindow = new InGameMenuWindow();
-        mCharacterSheet = new CharacterSheetWindow();
-        mJournalWindow = new JournalWindow();
-        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
-        mObjectDescriptionWindow = new ObjectDescriptionWindow();
-        mGameSettings = new GameSettings();
-
-        RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mJournalWindow);
-        //RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mInfoPopup);
-        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
-
-        logAllWindows();
-    }
-
-    WindowFactory::~WindowFactory()
-    {
-        delete mLogWindow;
-        delete mObjectDescriptionWindow;
-        delete mJournalWindow;
-        delete mGameLogger;
-        delete mCharacterSheet;
-        delete mInGameMenuWindow;
-        delete mInventoryWindow;
-        delete mCharacterStateWindow;
-        //delete mInfoPopup;
-        delete mDebugWindow;
-        delete mConsole;
-        delete mMainMenuWindow;
-        delete mGameSettings;
-        delete mCombatWindow;
-    }
-
-    void WindowFactory::showCharacterActionChoice()
-    {
-        showActionChoice(UiSubsystem::getSingleton().getActiveCharacter());
-    }
-
-    void WindowFactory::showContainerContent(Container* container)
-    {
-        if( !mInventoryWindow )
-            toggleInventoryWindow();
-
-        mInventoryWindow-&gt;showContainerContent(container);
-    }
-
-    void WindowFactory::showMessageWindow(const CeGuiString&amp; message)
-    {
-        MessageWindow* w = new MessageWindow(&quot;&quot;, message, MessageWindow::OK);
-        w-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showMainMenu()
-    {
-        mMainMenuWindow-&gt;setVisible(true);
-    }
-
-    void WindowFactory::toggleConsole()
-    {
-        mConsole-&gt;setVisible(!mConsole-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleDebugWindow()
-    {
-        mDebugWindow-&gt;setVisible(!mDebugWindow-&gt;isVisible());
-    }
-
-    void WindowFactory::showPropertiesWindow(GameObject* obj)
-    {
-        PropertiesWindow* wnd = new PropertiesWindow(obj);
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showGameSaveLoadWindow()
-    {
-        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
-        wnd-&gt;initialize();
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
-    {
-		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
-        mMainMenuLoadWindow-&gt;initialize();
-        mMainMenuLoadWindow-&gt;setVisible(true);
-    }
-
-	void WindowFactory::hideMainMenuLoadWindow()
-    {
-		if(mMainMenuLoadWindow != NULL &amp;&amp; mMainMenuLoadWindow-&gt;isVisible())
-		{
-			mMainMenuLoadWindow-&gt;setVisible(false,true);
-			mMainMenuWindow = NULL;
-		}
-    }
-
-    void WindowFactory::toggleGameLogWindow()
-    {
-        mGameLogger-&gt;setVisible(!mGameLogger-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleInventoryWindow()
-    {
-        if (mInventoryWindow != NULL &amp;&amp; mInventoryWindow-&gt;isVisible())
-        {
-            mInventoryWindow-&gt;setVisible(false, true);
-            mInventoryWindow = NULL;
-        }
-        else
-        {
-            if (mInventoryWindow != NULL)
-            {
-                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
-                mInventoryWindow = NULL;
-            }
-
-            if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
-            {
-                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
-
-                Ogre::String inventoryWindowType = creat-&gt;getInventoryWindowType();
-                if (inventoryWindowType == &quot;&quot;)
-                {
-                    inventoryWindowType = &quot;inventory_default.xml&quot;; ///@TODO: Extract
-                }
-                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat-&gt;getInventory());
-                mInventoryWindow-&gt;setVisible(true);
-            }
-        }
-    }
-
-    void WindowFactory::notifyInventoryWindowDestroyed()
-    {
-        mInventoryWindow = NULL;
-    }
-
-	bool WindowFactory::isInventoryWindowDestroyed()
-	{
-		return mInventoryWindow == NULL;
-	}
-
-
-    void WindowFactory::showCharacterSheet()
-    {
-        if (mCharacterSheet-&gt;isVisible())
-        {
-            mCharacterSheet-&gt;setCharacter(NULL);
-            mCharacterSheet-&gt;setVisible(false);
-        }
-        else
-        {
-            mCharacterSheet-&gt;setCharacter(UiSubsystem::getSingleton().getActiveCharacter());
-            mCharacterSheet-&gt;setVisible(true);
-        }
-    }
-
-    void WindowFactory::showJournalWindow()
-    {
-        if (mJournalWindow-&gt;isVisible())
-        {
-            mJournalWindow-&gt;setVisible(false);
-        }
-        else
-        {
-            mJournalWindow-&gt;setVisible(true);
-        }
-    }
-
-    void WindowFactory::showAboutWindow()
-    {
-        (new AboutWindow())-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showCharacterSheet(Creature* chara)
-    {
-        if (!mCharacterSheet) 
-        {
-            mCharacterSheet = new CharacterSheetWindow();
-        }
-        mCharacterSheet-&gt;setCharacter(chara);
-        mCharacterSheet-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showDescriptionWindow(GameObject* obj)
-    {
-        (new GameObjectInfoWindow(obj, UiSubsystem::getSingleton().getActiveCharacter()))-&gt;setVisible(true);
-    }
-
-    void WindowFactory::toggleCharacterStateWindow()
-    {
-        mCharacterStateWindow-&gt;setVisible(!mCharacterStateWindow-&gt;isVisible());
-    }
-
-    void WindowFactory::toggleInGameGlobalMenu()
-    {
-        mInGameMenuWindow-&gt;setVisible(!mInGameMenuWindow-&gt;isVisible());
-    }
-
-    GameLoggerWindow* WindowFactory::getGameLogger()
-    {
-        return mGameLogger;
-    }
-
-    void WindowFactory::showPlaylist()
-    {
-        PlaylistWindow* wnd = new PlaylistWindow();
-        wnd-&gt;setVisible(true);
-    }
-
-    void WindowFactory::checkForErrors()
-    {
-        if (Logger::getSingleton().isErrorPresent())
-        {
-            mLogWindow-&gt;setVisible(true);
-            Logger::getSingleton().resetErrorState();
-        }
-    }
-
-    void WindowFactory::update()
-    {
-        mInGameMenuWindow-&gt;update();
-    }
-
-    void WindowFactory::showExitConfirmation()
-    {
-        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
-        LOG_MESSAGE2(Logger::UI, &quot;Start&quot;, &quot;UiSubsystem::requestExit&quot;);
-        closeConfirmationWindow-&gt;setVisible(true);
-    }
-
-    void WindowFactory::writeToConsole(Ogre::String text)
-    {
-        if (mConsole != NULL)
-        {
-            mConsole-&gt;write(text);
-        }
-        else
-        {
-            LOG_MESSAGE(&quot;Console&quot;, text);
-        }
-    }
-
-    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
-    {
-        CeGuiString text = RubyInterpreter::val2ceguistr(str);
-
-        if (WindowFactory::getSingletonPtr() != NULL )
-        {
-            if (WindowFactory::getSingleton().mConsole != NULL)
-            {
-                WindowFactory::getSingleton().mConsole-&gt;
-                    write(text + &quot; \n&quot;);
-                return Qnil;
-            }
-        }
-        
-        LOG_MESSAGE(&quot;Console&quot;, text);
-        return Qnil;
-    }
-
-    void WindowFactory::setActiveCharacter(Creature* character)
-    {
-        mCharacterStateWindow-&gt;setCharacter(character);
-        if (mCharacterSheet) 
-        {
-            mCharacterSheet-&gt;setCharacter(character);
-        }
-
-        if (mInventoryWindow &amp;&amp; mInventoryWindow-&gt;isVisible())
-        {
-            toggleInventoryWindow();
-        }
-
-        LOG_MESSAGE(Logger::UI, &quot;CharacterStateWindow updated&quot;);
-    }
-
-    void WindowFactory::showActionChoice(GameObject* obj)
-    {
-        ActionChoiceWindow* w = new ActionChoiceWindow(UiSubsystem::getSingleton().getActiveCharacter());
-        int numActions = w-&gt;showActionsOfObject(obj);
-        if (numActions &gt; 0)
-        {
-            w-&gt;setVisible(true);
-        }
-        else
-        {
-            WindowManager::getSingleton().destroyWindow(w);
-        }
-    }
-
-    void WindowFactory::showLogfiles()
-    {
-        (new LogWindow())-&gt;setVisible(true);
-    }
-
-    void WindowFactory::showPopupMessage(int popupTypes)
-    {
-        if (popupTypes &amp; WindowFactory::ICON_ERROR)
-        {
-            //mInfoPopup-&gt;showError();
-        }
-
-        if (popupTypes &amp; WindowFactory::ICON_QUEST)
-        {
-            //mInfoPopup-&gt;showQuestBookChange();
-        }
-    }
-
-    void WindowFactory::showObjectDescription(GameObject* object)
-    {
-        mObjectDescriptionWindow-&gt;show(object);
-    }
-
-    void WindowFactory::showNextDebugWindowPage()
-    {
-        mDebugWindow-&gt;showNextPage();
-    }
-
-    void WindowFactory::showGameSettings()
-    {
-        // Create the game settings window and show it
-        mGameSettings-&gt;setVisible(true);
-    }
-
-    void WindowFactory::logAllWindows()
-    {
-        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
-        CEGUI::uint count = rootWnd-&gt;getChildCount();
-        for (CEGUI::uint chIdx =  0; chIdx &lt; count; ++chIdx)
-        {
-            CEGUI::Window* wnd = rootWnd-&gt;getChildAtIdx(chIdx);
-            LOG_MESSAGE(
-                Logger::UI,
-                wnd-&gt;getName()
-                + (wnd-&gt;isVisible() ? &quot; vis&quot; : &quot; nvis&quot;)
-                + &quot; @&quot;
-                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_x)
-                + &quot;, &quot;
-                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_y)
-                + &quot; &quot;
-                + StringConverter::toString(wnd-&gt;getPixelSize().d_width)
-                + &quot;, &quot;
-                + StringConverter::toString(wnd-&gt;getPixelSize().d_height));
-        }
-    }
-
-    CombatWindow* WindowFactory::getCombatWindow()
-    {
-        if (mCombatWindow == NULL)
-        {
-            mCombatWindow = new CombatWindow();
-        }
-        return mCombatWindow;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;WindowFactory.h&quot;
+
+#include &quot;AboutWindow.h&quot;
+#include &quot;ActionChoiceWindow.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CharacterSheetWindow.h&quot;
+#include &quot;CharacterStateWindow.h&quot;
+#include &quot;CloseConfirmationWindow.h&quot;
+#include &quot;CombatWindow.h&quot;
+#include &quot;Console.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;DialogControlState.h&quot;
+#include &quot;DialogWindow.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameLoggerWindow.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;GameObjectInfoWindow.h&quot;
+#include &quot;GameOverWindow.h&quot;
+#include &quot;GameSaveLoadWindow.h&quot;
+#include &quot;GameSettings.h&quot;
+#include &quot;InfoPopup.h&quot;
+#include &quot;InGameMenuWindow.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;InventoryWindow.h&quot;
+#include &quot;JournalWindow.h&quot;
+#include &quot;LogWindow.h&quot;
+#include &quot;MessageWindow.h&quot;
+#include &quot;MainMenuLoadWindow.h&quot;
+#include &quot;MainMenuWindow.h&quot;
+#include &quot;MainMenuEngineWindow.h&quot;
+#include &quot;MovableText.h&quot;
+#include &quot;ObjectDescriptionWindow.h&quot;
+#include &quot;PartyManager.h&quot;
+#include &quot;PlaylistWindow.h&quot;
+#include &quot;PropertiesWindow.h&quot;
+#include &quot;QuestBook.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+#include &quot;SubtitleWindow.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowManager.h&quot;
+
+#undef max
+
+template&lt;&gt; rl::WindowFactory* Ogre::Singleton&lt;rl::WindowFactory&gt;::ms_Singleton = 0;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl {
+
+    WindowFactory::WindowFactory()
+        : mGameLogger(NULL),
+        mCharacterStateWindow(NULL),
+        mInGameMenuWindow(NULL),
+        mCharacterSheet(NULL),
+        mJournalWindow(NULL),
+        mInventoryWindow(NULL),
+        mLogWindow(NULL),
+        mDebugWindow(NULL),
+        mConsole(NULL),
+        mInfoPopup(NULL),
+        mObjectNameText(NULL),
+        mShownObject(NULL),
+        mObjectDescriptionWindow(NULL),
+        mMainMenuWindow(NULL),
+		mMainMenuLoadWindow(NULL),
+        mGameSettings(NULL),
+        mCombatWindow(NULL)
+    {
+    }
+
+    void WindowFactory::initialize()
+    {
+        mConsole = new Console();
+        mDebugWindow = new DebugWindow();
+        CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;
+            setOutputFunction(
+                (VALUE(*)(...))&amp;WindowFactory::consoleWrite );
+
+        mLogWindow = new LogWindow();
+
+        mGameLogger = new GameLoggerWindow();
+        mCharacterStateWindow = new CharacterStateWindow();
+        mInGameMenuWindow = new InGameMenuWindow();
+        mCharacterSheet = new CharacterSheetWindow();
+        mJournalWindow = new JournalWindow();
+        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
+        mObjectDescriptionWindow = new ObjectDescriptionWindow();
+        mGameSettings = new GameSettings();
+
+        RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mJournalWindow);
+        //RulesSubsystem::getSingleton().getQuestBook()-&gt;addQuestListener(mInfoPopup);
+        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+
+        logAllWindows();
+    }
+
+    WindowFactory::~WindowFactory()
+    {
+        delete mLogWindow;
+        delete mObjectDescriptionWindow;
+        delete mJournalWindow;
+        delete mGameLogger;
+        delete mCharacterSheet;
+        delete mInGameMenuWindow;
+        delete mInventoryWindow;
+        delete mCharacterStateWindow;
+        //delete mInfoPopup;
+        delete mDebugWindow;
+        delete mConsole;
+        delete mMainMenuWindow;
+        delete mGameSettings;
+        delete mCombatWindow;
+    }
+
+    void WindowFactory::showCharacterActionChoice()
+    {
+        showActionChoice(PartyManager::getSingleton().getActiveCharacter());
+    }
+
+    void WindowFactory::showContainerContent(Container* container)
+    {
+        if( !mInventoryWindow )
+            toggleInventoryWindow();
+
+        mInventoryWindow-&gt;showContainerContent(container);
+    }
+
+    void WindowFactory::showMessageWindow(const CeGuiString&amp; message)
+    {
+        MessageWindow* w = new MessageWindow(&quot;&quot;, message, MessageWindow::OK);
+        w-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showMainMenu()
+    {
+        mMainMenuWindow-&gt;setVisible(true);
+    }
+
+    void WindowFactory::toggleConsole()
+    {
+        mConsole-&gt;setVisible(!mConsole-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleDebugWindow()
+    {
+        mDebugWindow-&gt;setVisible(!mDebugWindow-&gt;isVisible());
+    }
+
+    void WindowFactory::showPropertiesWindow(GameObject* obj)
+    {
+        PropertiesWindow* wnd = new PropertiesWindow(obj);
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showGameSaveLoadWindow()
+    {
+        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
+        wnd-&gt;initialize();
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
+    {
+		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
+        mMainMenuLoadWindow-&gt;initialize();
+        mMainMenuLoadWindow-&gt;setVisible(true);
+    }
+
+	void WindowFactory::hideMainMenuLoadWindow()
+    {
+		if(mMainMenuLoadWindow != NULL &amp;&amp; mMainMenuLoadWindow-&gt;isVisible())
+		{
+			mMainMenuLoadWindow-&gt;setVisible(false,true);
+			mMainMenuWindow = NULL;
+		}
+    }
+
+    void WindowFactory::toggleGameLogWindow()
+    {
+        mGameLogger-&gt;setVisible(!mGameLogger-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleInventoryWindow()
+    {
+        if (mInventoryWindow != NULL &amp;&amp; mInventoryWindow-&gt;isVisible())
+        {
+            mInventoryWindow-&gt;setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
+
+            if (PartyManager::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = PartyManager::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat-&gt;getInventoryWindowType();
+                if (inventoryWindowType == &quot;&quot;)
+                {
+                    inventoryWindowType = &quot;inventory_default.xml&quot;; ///@TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat-&gt;getInventory());
+                mInventoryWindow-&gt;setVisible(true);
+            }
+        }
+    }
+
+    void WindowFactory::notifyInventoryWindowDestroyed()
+    {
+        mInventoryWindow = NULL;
+    }
+
+	bool WindowFactory::isInventoryWindowDestroyed()
+	{
+		return mInventoryWindow == NULL;
+	}
+
+
+    void WindowFactory::showCharacterSheet()
+    {
+        if (mCharacterSheet-&gt;isVisible())
+        {
+            mCharacterSheet-&gt;setCharacter(NULL);
+            mCharacterSheet-&gt;setVisible(false);
+        }
+        else
+        {
+            mCharacterSheet-&gt;setCharacter(PartyManager::getSingleton().getActiveCharacter());
+            mCharacterSheet-&gt;setVisible(true);
+        }
+    }
+
+    void WindowFactory::showJournalWindow()
+    {
+        if (mJournalWindow-&gt;isVisible())
+        {
+            mJournalWindow-&gt;setVisible(false);
+        }
+        else
+        {
+            mJournalWindow-&gt;setVisible(true);
+        }
+    }
+
+    void WindowFactory::showAboutWindow()
+    {
+        (new AboutWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showCharacterSheet(Creature* chara)
+    {
+        if (!mCharacterSheet) 
+        {
+            mCharacterSheet = new CharacterSheetWindow();
+        }
+        mCharacterSheet-&gt;setCharacter(chara);
+        mCharacterSheet-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showDescriptionWindow(GameObject* obj)
+    {
+        (new GameObjectInfoWindow(obj, PartyManager::getSingleton().getActiveCharacter()))-&gt;setVisible(true);
+    }
+
+    void WindowFactory::toggleCharacterStateWindow()
+    {
+        mCharacterStateWindow-&gt;setVisible(!mCharacterStateWindow-&gt;isVisible());
+    }
+
+    void WindowFactory::toggleInGameGlobalMenu()
+    {
+        mInGameMenuWindow-&gt;setVisible(!mInGameMenuWindow-&gt;isVisible());
+    }
+
+    GameLoggerWindow* WindowFactory::getGameLogger()
+    {
+        return mGameLogger;
+    }
+
+    void WindowFactory::showPlaylist()
+    {
+        PlaylistWindow* wnd = new PlaylistWindow();
+        wnd-&gt;setVisible(true);
+    }
+
+    void WindowFactory::checkForErrors()
+    {
+        if (Logger::getSingleton().isErrorPresent())
+        {
+            mLogWindow-&gt;setVisible(true);
+            Logger::getSingleton().resetErrorState();
+        }
+    }
+
+    void WindowFactory::update()
+    {
+        mInGameMenuWindow-&gt;update();
+    }
+
+    void WindowFactory::showExitConfirmation()
+    {
+        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
+        LOG_MESSAGE2(Logger::UI, &quot;Start&quot;, &quot;UiSubsystem::requestExit&quot;);
+        closeConfirmationWindow-&gt;setVisible(true);
+    }
+
+    void WindowFactory::writeToConsole(Ogre::String text)
+    {
+        if (mConsole != NULL)
+        {
+            mConsole-&gt;write(text);
+        }
+        else
+        {
+            LOG_MESSAGE(&quot;Console&quot;, text);
+        }
+    }
+
+    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
+    {
+        CeGuiString text = RubyInterpreter::val2ceguistr(str);
+
+        if (WindowFactory::getSingletonPtr() != NULL )
+        {
+            if (WindowFactory::getSingleton().mConsole != NULL)
+            {
+                WindowFactory::getSingleton().mConsole-&gt;
+                    write(text + &quot; \n&quot;);
+                return Qnil;
+            }
+        }
+        
+        LOG_MESSAGE(&quot;Console&quot;, text);
+        return Qnil;
+    }
+
+    void WindowFactory::setActiveCharacter(Creature* character)
+    {
+        mCharacterStateWindow-&gt;setCharacter(character);
+        if (mCharacterSheet) 
+        {
+            mCharacterSheet-&gt;setCharacter(character);
+        }
+
+        if (mInventoryWindow &amp;&amp; mInventoryWindow-&gt;isVisible())
+        {
+            toggleInventoryWindow();
+        }
+
+        LOG_MESSAGE(Logger::UI, &quot;CharacterStateWindow updated&quot;);
+    }
+
+    void WindowFactory::showActionChoice(GameObject* obj)
+    {
+        ActionChoiceWindow* w = new ActionChoiceWindow(PartyManager::getSingleton().getActiveCharacter());
+        int numActions = w-&gt;showActionsOfObject(obj);
+        if (numActions &gt; 0)
+        {
+            w-&gt;setVisible(true);
+        }
+        else
+        {
+            WindowManager::getSingleton().destroyWindow(w);
+        }
+    }
+
+    void WindowFactory::showLogfiles()
+    {
+        (new LogWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::showPopupMessage(int popupTypes)
+    {
+        if (popupTypes &amp; WindowFactory::ICON_ERROR)
+        {
+            //mInfoPopup-&gt;showError();
+        }
+
+        if (popupTypes &amp; WindowFactory::ICON_QUEST)
+        {
+            //mInfoPopup-&gt;showQuestBookChange();
+        }
+    }
+
+    void WindowFactory::showObjectDescription(GameObject* object)
+    {
+        mObjectDescriptionWindow-&gt;show(object);
+    }
+
+    void WindowFactory::showNextDebugWindowPage()
+    {
+        mDebugWindow-&gt;showNextPage();
+    }
+
+    void WindowFactory::showGameSettings()
+    {
+        // Create the game settings window and show it
+        mGameSettings-&gt;setVisible(true);
+    }
+    
+    void WindowFactory::showGameOverWindow()
+    {
+        (new GameOverWindow())-&gt;setVisible(true);
+    }
+
+    void WindowFactory::logAllWindows()
+    {
+        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
+        CEGUI::uint count = rootWnd-&gt;getChildCount();
+        for (CEGUI::uint chIdx =  0; chIdx &lt; count; ++chIdx)
+        {
+            CEGUI::Window* wnd = rootWnd-&gt;getChildAtIdx(chIdx);
+            LOG_MESSAGE(
+                Logger::UI,
+                wnd-&gt;getName()
+                + (wnd-&gt;isVisible() ? &quot; vis&quot; : &quot; nvis&quot;)
+                + &quot; @&quot;
+                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_x)
+                + &quot;, &quot;
+                + StringConverter::toString(wnd-&gt;getPixelRect().getPosition().d_y)
+                + &quot; &quot;
+                + StringConverter::toString(wnd-&gt;getPixelSize().d_width)
+                + &quot;, &quot;
+                + StringConverter::toString(wnd-&gt;getPixelSize().d_height));
+        }
+    }
+
+    CombatWindow* WindowFactory::getCombatWindow()
+    {
+        if (mCombatWindow == NULL)
+        {
+            mCombatWindow = new CombatWindow();
+        }
+        return mCombatWindow;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001575.html">[Dsa-hl-svn] r4518 - rl/trunk/engine/rules/src
</A></li>
	<LI>Next message: <A HREF="001577.html">[Dsa-hl-svn] r4520 - in rl/trunk/editors/Lockenwickler: . src	src/media src/media/icons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1576">[ date ]</a>
              <a href="thread.html#1576">[ thread ]</a>
              <a href="subject.html#1576">[ subject ]</a>
              <a href="author.html#1576">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
