<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4508 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/common/include engine/core/src engine/rules/include	engine/rules/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4508%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/common/include%20engine/core/src%20engine/rules/include%0A%09engine/rules/src&In-Reply-To=%3C200809151930.m8FJU3Zc022409%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001564.html">
   <LINK REL="Next"  HREF="001566.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4508 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/common/include engine/core/src engine/rules/include	engine/rules/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4508%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/common/include%20engine/core/src%20engine/rules/include%0A%09engine/rules/src&In-Reply-To=%3C200809151930.m8FJU3Zc022409%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4508 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/common/include engine/core/src engine/rules/include	engine/rules/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 21:30:03 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001564.html">[Dsa-hl-svn] r4507 - in rl/trunk/engine: rules/include rules/src	script/swig
</A></li>
        <LI>Next message: <A HREF="001566.html">[Dsa-hl-svn] r4509 - rl/trunk/Mac
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1565">[ date ]</a>
              <a href="thread.html#1565">[ thread ]</a>
              <a href="subject.html#1565">[ subject ]</a>
              <a href="author.html#1565">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-09-15 21:29:55 +0200 (Mon, 15 Sep 2008)
New Revision: 4508

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
Log:
Save effects to properties

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-15 19:29:55 UTC (rev 4508)
@@ -615,6 +615,7 @@
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -664,7 +665,6 @@
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
 		48B0B0490E65BBB30023B198 /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
 		48B0B04A0E65BBC10023B198 /* libfmodex.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
-		48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8D0C4E960486CD37000505A6 /* Info.plist */; };
 		48B772DD0D58350B000A3B97 /* XmlProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DA0D58350B000A3B97 /* XmlProcessor.h */; };
 		48B772DE0D58350B000A3B97 /* XmlPropertyReader.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DB0D58350B000A3B97 /* XmlPropertyReader.h */; };
 		48B772DF0D58350B000A3B97 /* XmlPropertyWriter.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DC0D58350B000A3B97 /* XmlPropertyWriter.h */; };
@@ -853,6 +853,7 @@
 			dstPath = &quot;&quot;;
 			dstSubfolderSpec = 10;
 			files = (
+				487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */,
 				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
@@ -1445,6 +1446,7 @@
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
@@ -1688,6 +1690,7 @@
 			isa = PBXGroup;
 			children = (
 				20286C2AFDCF999611CA2CEA /* Sources */,
+				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
 				195DF8CFFE9D517E11CA2CBB /* Products */,
@@ -1714,7 +1717,6 @@
 		20286C2CFDCF999611CA2CEA /* Resources */ = {
 			isa = PBXGroup;
 			children = (
-				48D401810D9E483200AE5340 /* modules */,
 				440786120C09D602006E496D /* RlScript-Info.plist */,
 				8D0C4E960486CD37000505A6 /* Info.plist */,
 				0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */,
@@ -1726,6 +1728,7 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				487750AF0E7E3C9C0018216B /* Cg.framework */,
 				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
 				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
@@ -3046,7 +3049,6 @@
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
-				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
 				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/common/include/Property.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -87,6 +87,7 @@
         PropertyMethod(Bool, const bool&amp;);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&amp;);
+        PropertyMethod(Long, const RL_LONGLONG&amp;);
         PropertyMethod(Real, const Ogre::Real&amp;);
         PropertyMethod(Vector3, const Ogre::Vector3&amp;);
         PropertyMethod(Quaternion, const Ogre::Quaternion&amp;);

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -124,8 +124,6 @@
         addSetting(&quot;MovementController keys&quot;, &quot;reset_camera&quot;, &quot;0 (Nummernblock)&quot;);
 
         addSetting(&quot;Localization&quot;, &quot;language&quot;, &quot;de&quot;);
-
-        setRastullahCfgPath();
     }
 
     ConfigurationManager::~ConfigurationManager()
@@ -187,6 +185,7 @@
 
     void ConfigurationManager::loadConfig()
     {
+        setRastullahCfgPath();
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
         fs::path rastullahCfgDirectory(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
@@ -265,7 +264,7 @@
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
             mModulesRootDirectory = RL_MODULEDIR;
-#           elsif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#           elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
             mModulesRootDirectory = mExecutablePath + &quot;/../Resources/modules&quot;;
 #           else
             mModulesRootDirectory = &quot;./modules&quot;;
@@ -390,8 +389,8 @@
 	void ConfigurationManager::setExecutable(const Ogre::String&amp; path)
 	{
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		
 		mExecutablePath = exeAbsolute.remove_leaf().string();
+        std::cout &lt;&lt; &quot;ConfigurationManager&quot; &lt;&lt; &quot;Executable is &quot; &lt;&lt; path &lt;&lt; &quot; &quot; &lt;&lt; mExecutablePath;
 	}
 
 	const Ogre::String&amp; ConfigurationManager::getExecutablePath() const
@@ -441,11 +440,12 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename);
+			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; fs::complete(filename) &lt;&lt; std::endl;
             if (fs::exists(filename))
 #           else
 			std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; 
-				fs::complete(fs::path(filename, fs::portable_posix_name)).string();
+				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
+                 &lt;&lt; std::endl;
 			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
 #           endif
             {

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/include/Effect.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -82,6 +82,7 @@
 
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_STUFE;
+        static const Ogre::String PROPERTY_ENABLED;
 
 
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/include/EffectManager.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,125 +1,130 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __EFFECTMANAGER_H__
-#define __EFFECTMANAGER_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;set&gt;
-
-#include &quot;Date.h&quot;
-#include &quot;Effect.h&quot;
-
-namespace rl
-{
-    class GameObject;
-
-    /**
-     * @brief Manages the effects affecting a game object
-     * 
-     * This class manages all effects applied to a game object.
-     * Each game object has a seperate EffectManager. The method checkEffects()
-     * should be called every Aktion (the dark eye time unit)
-     **/
-
-    class _RlRulesExport EffectManager : public PropertyHolder
-	{
-	public:
-		EffectManager(GameObject* gameobject);
-		~EffectManager();
-
-        /**
-         *  Checks effects for changes.
-         **/
-		void checkEffects();
-        /** 
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  in welcher Zeit er wieder ueberprueft werden muss.
-         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException time parameter is &lt;= 0
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheckDate Date
-         **/
-        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
-        /**
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
-         *  @param date Das Datum der naechsten Ueberpruefung.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException date lies in the past
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheck, Date
-         **/
-        void addDateCheck(RL_LONGLONG date, Effect* effect);
-        /**
-         * Fuegt einen neuen Effekt in die Liste ein.
-         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
-         **/
-		void addEffect(Effect* effect);
-        
-        /// Removes effects by pointer.
-        void removeEffect(Effect* effect);
-
-        /// Removes effects by name.
-        void removeEffect(CeGuiString name);
-        
-        /**
-         * Checks the effects for the given status.
-         **/
-        Effect::LifeState getLifeState();
-        
-        /**
-         * Returns the specified modificator.
-         * @param target specifies what modificator you want to get (e.g. &quot;Athletik&quot;)
-         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
-         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
-         **/
-        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-        /**
-         * Returns a printable list of all effects
-         **/
-        CeGuiString getEffects();
-
-        void checkStateChange(Effect::LifeState oldState);
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __EFFECTMANAGER_H__
+#define __EFFECTMANAGER_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &lt;set&gt;
+
+#include &quot;Date.h&quot;
+#include &quot;Effect.h&quot;
+
+namespace rl
+{
+    class GameObject;
+
+    /**
+     * @brief Manages the effects affecting a game object
+     * 
+     * This class manages all effects applied to a game object.
+     * Each game object has a seperate EffectManager. The method checkEffects()
+     * should be called every Aktion (the dark eye time unit)
+     **/
+
+    class _RlRulesExport EffectManager : public PropertyHolder
+	{
+	public:
+    
+        static const Ogre::String PROPERTY_TIMECHECK;
+        static const Ogre::String PROPERTY_TIME;
+        static const Ogre::String PROPERTY_EFFECT;
+        
+		EffectManager(GameObject* gameobject);
+		~EffectManager();
+
+        /**
+         *  Checks effects for changes.
+         **/
+		void checkEffects();
+        /** 
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  in welcher Zeit er wieder ueberprueft werden muss.
+         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException time parameter is &lt;= 0
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheckDate Date
+         **/
+        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
+        /**
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
+         *  @param date Das Datum der naechsten Ueberpruefung.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException date lies in the past
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheck, Date
+         **/
+        void addDateCheck(RL_LONGLONG date, Effect* effect);
+        /**
+         * Fuegt einen neuen Effekt in die Liste ein.
+         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
+         **/
+		void addEffect(Effect* effect);
+        
+        /// Removes effects by pointer.
+        void removeEffect(Effect* effect);
+
+        /// Removes effects by name.
+        void removeEffect(CeGuiString name);
+        
+        /**
+         * Checks the effects for the given status.
+         **/
+        Effect::LifeState getLifeState();
+        
+        /**
+         * Returns the specified modificator.
+         * @param target specifies what modificator you want to get (e.g. &quot;Athletik&quot;)
+         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
+         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
+         **/
+        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+        /**
+         * Returns a printable list of all effects
+         **/
+        CeGuiString getEffects();
+
+        void checkStateChange(Effect::LifeState oldState);
+
         virtual const Property getProperty(const CeGuiString&amp; key) const;
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-	private:
-
-        GameObject* mGameObject;
-
-        // only used in checkEffects!
-        bool mCheckEffectsRunning;
-
-        /// Eine einfache Menge von Effekten
-		typedef std::set&lt;Effect*&gt; Effects;
-		Effects mEffects;
-        /**
-         * Eine Liste die wiedergibt, wann welcher Effekt
-         * ueberprueft werden muss.
-         **/
-        typedef std::map&lt;RL_LONGLONG, Effects&gt; Checklist;
-        Checklist mChecklist;
-	};
-}
-
-#endif //__EFFECTMANAGER_H__
-		
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+	private:
+
+        GameObject* mGameObject;
+
+        // only used in checkEffects!
+        bool mCheckEffectsRunning;
+
+        /// Eine einfache Menge von Effekten
+		typedef std::vector&lt;Effect*&gt; Effects;
+		Effects mEffects;
+        /**
+         * Eine Liste die wiedergibt, wann welcher Effekt
+         * ueberprueft werden muss.
+         **/
+        typedef std::map&lt;RL_LONGLONG, Effects&gt; Checklist;
+        Checklist mChecklist;
+	};
+}
+
+#endif //__EFFECTMANAGER_H__
+		

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/src/Effect.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,163 +1,172 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Effect.h&quot;
-#include &quot;DsaManager.h&quot;
-
-namespace rl
-{
-    const Ogre::String Effect::PROPERTY_NAME = &quot;name&quot;;
-    const Ogre::String Effect::PROPERTY_STUFE = &quot;stufe&quot;;
-
-	Effect::Effect(int stufe)
-	{
-		mStufe = stufe;
-		mQuantifier = QUANTIFIER_MULTIPLE;
-	}
-
-	const Ogre::String Effect::getName() const
-	{
-		return mName;
-	}
-
-	void Effect::setName(Ogre::String name)
-	{
-		mName = name;
-	}
-
-	const CeGuiString Effect::getDescription() const
-	{
-		return mDescription;
-	}
-
-	void Effect::setDescription(CeGuiString description)
-	{
-		mDescription = description;
-	}
-
-    Effect::Quantifier Effect::getQuantifier()
-	{
-		return mQuantifier;
-	}
-
-	void Effect::setQuantifier(Quantifier quantifier)
-	{
-		mQuantifier = quantifier;
-	}
-
-
-	const int Effect::getStufe()
-	{
-		return mStufe;
-	}
-
-	void Effect::increaseStufe()
-	{
-	}
-
-	void Effect::decreaseStufe()
-	{
-	}
-
-	void Effect::enable()
-	{
-		if (!mEnabled)
-		{
-			mEnabled = true;
-		}
-	}
-
-	void Effect::disable()
-	{
-		if (mEnabled)
-		{
-			mEnabled = false;
-		}
-	}
-
-    RL_LONGLONG Effect::timeCheck()
-    {
-        return PERMANENT;
-    }
-
-	Effect::LifeState Effect::getLifeState() const
-    {
-        // should be overlaoaded in the specific derivated effects.
-        return LS_NONE;
-    }
-
-    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
-    {
-        return 0;
-    }
-
-    const Property Effect::getProperty(const CeGuiString&amp; key) const
-    {
-        Property prop;
-        if (key == Effect::PROPERTY_NAME)
-        {
-            prop.setValue(mName);
-        }
-        else if (key == Effect::PROPERTY_STUFE)
-        {
-            prop.setValue(mStufe);
-        }
-        else
-        {
-            Throw(
-                IllegalArgumentException, 
-                key + &quot; is not a property of this effect (&quot; + mName + &quot;)&quot;);
-        }
-        return prop;
-    }
-
-    void Effect::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        try
-        {
-            if (key == Effect::PROPERTY_NAME)
-            {
-                mName = value.toString().c_str();
-            }
-            else if (key == Effect::PROPERTY_STUFE)
-            {
-                mStufe = value.toInt();
-            }
-            else
-            {
-                LOG_WARNING(
-                    Logger::RULES,
-                    key + &quot; is not a property of this Effect (&quot; + mName + &quot;)&quot;);
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                &quot;property &quot; + key + &quot; has the wrong format&quot;);
-        }
-    }
-
-    PropertyKeys Effect::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(Effect::PROPERTY_NAME);
-        keys.insert(Effect::PROPERTY_STUFE);
-        return keys;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Effect.h&quot;
+#include &quot;DsaManager.h&quot;
+
+namespace rl
+{
+    const Ogre::String Effect::PROPERTY_NAME = &quot;name&quot;;
+    const Ogre::String Effect::PROPERTY_STUFE = &quot;stufe&quot;;
+    const Ogre::String Effect::PROPERTY_ENABLED = &quot;enabled&quot;;    
+
+	Effect::Effect(int stufe)
+	{
+		mStufe = stufe;
+		mQuantifier = QUANTIFIER_MULTIPLE;
+	}
+
+	const Ogre::String Effect::getName() const
+	{
+		return mName;
+	}
+
+	void Effect::setName(Ogre::String name)
+	{
+		mName = name;
+	}
+
+	const CeGuiString Effect::getDescription() const
+	{
+		return mDescription;
+	}
+
+	void Effect::setDescription(CeGuiString description)
+	{
+		mDescription = description;
+	}
+
+    Effect::Quantifier Effect::getQuantifier()
+	{
+		return mQuantifier;
+	}
+
+	void Effect::setQuantifier(Quantifier quantifier)
+	{
+		mQuantifier = quantifier;
+	}
+
+
+	const int Effect::getStufe()
+	{
+		return mStufe;
+	}
+
+	void Effect::increaseStufe()
+	{
+	}
+
+	void Effect::decreaseStufe()
+	{
+	}
+
+	void Effect::enable()
+	{
+		if (!mEnabled)
+		{
+			mEnabled = true;
+		}
+	}
+
+	void Effect::disable()
+	{
+		if (mEnabled)
+		{
+			mEnabled = false;
+		}
+	}
+
+    RL_LONGLONG Effect::timeCheck()
+    {
+        return PERMANENT;
+    }
+
+	Effect::LifeState Effect::getLifeState() const
+    {
+        // should be overlaoaded in the specific derivated effects.
+        return LS_NONE;
+    }
+
+    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
+    {
+        return 0;
+    }
+
+    const Property Effect::getProperty(const CeGuiString&amp; key) const
+    {
+        Property prop;
+        if (key == Effect::PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == Effect::PROPERTY_STUFE)
+        {
+            prop.setValue(mStufe);
+        }
+        else if (key == Effect::PROPERTY_ENABLED)
+        {
+            prop.setValue(mEnabled);
+        }
+        else
+        {
+            Throw(
+                IllegalArgumentException, 
+                key + &quot; is not a property of this effect (&quot; + mName + &quot;)&quot;);
+        }
+        return prop;
+    }
+
+    void Effect::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        try
+        {
+            if (key == Effect::PROPERTY_NAME)
+            {
+                mName = value.toString().c_str();
+            }
+            else if (key == Effect::PROPERTY_STUFE)
+            {
+                mStufe = value.toInt();
+            }
+            else if (key == Effect::PROPERTY_ENABLED)
+            {
+                mEnabled = value.toBool();
+            }
+            else
+            {
+                LOG_WARNING(
+                    Logger::RULES,
+                    key + &quot; is not a property of this Effect (&quot; + mName + &quot;)&quot;);
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                &quot;property &quot; + key + &quot; has the wrong format: &quot; + ex.getMessage());
+        }
+    }
+
+    PropertyKeys Effect::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Effect::PROPERTY_NAME);
+        keys.insert(Effect::PROPERTY_STUFE);
+        return keys;
+    }
+
+}

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,237 +1,270 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;EffectManager.h&quot;
-
-#include &lt;sstream&gt;
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-
-namespace rl
-{
-    EffectManager::EffectManager(GameObject* gameobject)
-        : mGameObject(gameobject),
-        mCheckEffectsRunning(false)
-    {
-    }
-
-    EffectManager::~EffectManager()
-    {
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            //delete (*it);
-            ScriptWrapper::getSingleton().disowned(*it);
-        }
-    }
-
-    void EffectManager::checkEffects()
-    {
-        if( mCheckEffectsRunning ) {
-                return;
-        }
-        mCheckEffectsRunning = true;
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        Checklist::iterator checkIt = mChecklist.begin();
-        if (checkIt == mChecklist.end()) return;
-        while ( checkIt != mChecklist.end() &amp;&amp; checkIt-&gt;first &lt;= now )
-        {
-                std::stringstream debugInfo;
-                debugInfo &lt;&lt; &quot;Effect check: &quot; &lt;&lt; checkIt-&gt;first &lt;&lt; &quot; now: &quot; &lt;&lt; now &lt;&lt; std::endl;
-                LOG_DEBUG(Logger::RULES,
-                    debugInfo.str());
-            for (Effects::iterator effIt = checkIt-&gt;second.begin(); effIt != checkIt-&gt;second.end(); effIt++)
-            {
-                int nextCheck;
-                nextCheck = (*effIt)-&gt;timeCheck();
-                switch (nextCheck)
-                {
-                  case Effect::REMOVE:
-                    removeEffect(*effIt);
-                    break;
-                  case Effect::PERMANENT:
-                    break;
-                  default:
-                    addTimeCheck(nextCheck, *effIt);
-                }
-            }
-            mChecklist.erase(checkIt++);
-        }
-
-        mCheckEffectsRunning = false;
-    }
-
-    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
-    {
-        // Preconditions: time &gt; 0, effect != NULL
-        if (time &lt;= 0) Throw(IllegalArgumentException, &quot;time parameter is &lt;= 0!&quot;);
-        if (effect == NULL) Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
-        // Get current ingame time and add timeUntilCheck
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        RL_LONGLONG timeForCheck = now + timeUntilCheck;
-        std::stringstream debugInfo;
-        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; timeForCheck &lt;&lt; std::endl;
-        LOG_DEBUG(Logger::RULES,
-            debugInfo.str());
-        // Insert Sum and effect into the checklist
-        mChecklist[timeForCheck].insert(effect);
-    }
-
-    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
-    {
-        // Preconditions: date &gt; now, effect != NULL
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        if (date &lt;= now) 
-        {
-            Throw(IllegalArgumentException, &quot;date lies in the past!&quot;);
-        }
-        if (effect == NULL) 
-        {
-            Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
-        }
-        // Insert date and effect into the checklist
-        std::stringstream debugInfo;
-        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; date &lt;&lt; std::endl;
-        LOG_DEBUG(Logger::RULES, debugInfo.str());
-        mChecklist[date].insert(effect);
-    }
-
-
-    void EffectManager::addEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-
-        LOG_DEBUG(Logger::RULES, &quot;Adding effect &quot; + effect-&gt;getName());
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            Effect* cur = *it;
-            if (cur-&gt;getName() == effect-&gt;getName())
-            {
-                if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
-                {
-                    return;
-                }
-                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
-                {
-                    //TODO
-                    //Vielleicht alten durch neuen ersetzen?
-                    //oder (*it)-&gt;setDuration(effect-&gt;getDuration())
-                }
-                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
-                {
-                    for (int i = 0; i &lt; effect-&gt;getStufe(); i++)
-                    {
-                        cur-&gt;increaseStufe();
-                    }
-                }
-            }
-        }
-        ScriptWrapper::getSingleton().owned(effect);
-        mEffects.insert(effect);
-        effect-&gt;enable();
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-    
-        effect-&gt;disable();
-        mEffects.erase(effect);
-        ScriptWrapper::getSingleton().disowned(effect);
-        ///@todo also remove from the check lists?
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(CeGuiString name)
-    {
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            if ((*it)-&gt;getName() == name)
-            {
-                removeEffect(*it);
-                return;
-            }
-        }
-    }
-
-    Effect::LifeState EffectManager::getLifeState()
-    {
-        checkEffects();
-        Effect::LifeState status = 0;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            status = status | ((*it)-&gt;getLifeState());
-        }
-        return status;
-    }
-
-    void EffectManager::checkStateChange(Effect::LifeState oldState)
-    {
-        Effect::LifeState currentState = getLifeState();
-        if (currentState != oldState)
-        {
-            MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectLifeStateChanged&gt;(mGameObject,
-                oldState, currentState);
-        }
-    }
-
-    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
-    {
-        checkEffects();
-        int mod = 0;
-        if (type == Effect::MODTYPE_MULT) mod = 1;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            mod += (*it)-&gt;getMod(target, type, tag);
-        }
-        return mod;
-    }
-
-    CeGuiString EffectManager::getEffects()
-    {
-        CeGuiString retVal = &quot;&quot;;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            retVal += (*it)-&gt;getName() + &quot;\n&quot;;
-            retVal += (*it)-&gt;getDescription() + &quot;\n&quot;;
-        }
-        return retVal;
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;EffectManager.h&quot;
+
+#include &lt;sstream&gt;
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;EffectFactory.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+
+namespace rl
+{
+    const Ogre::String EffectManager::PROPERTY_TIMECHECK = &quot;timechecks&quot;;
+    const Ogre::String EffectManager::PROPERTY_TIME = &quot;time&quot;;
+    const Ogre::String EffectManager::PROPERTY_EFFECT = &quot;effect&quot;;
+
+    EffectManager::EffectManager(GameObject* gameobject)
+        : mGameObject(gameobject),
+        mCheckEffectsRunning(false)
+    {
+    }
+
+    EffectManager::~EffectManager()
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            //delete (*it);
+            ScriptWrapper::getSingleton().disowned(*it);
+        }
+    }
+
+    void EffectManager::checkEffects()
+    {
+        if( mCheckEffectsRunning ) {
+                return;
+        }
+        mCheckEffectsRunning = true;
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        Checklist::iterator checkIt = mChecklist.begin();
+        if (checkIt == mChecklist.end()) return;
+        while ( checkIt != mChecklist.end() &amp;&amp; checkIt-&gt;first &lt;= now )
+        {
+                std::stringstream debugInfo;
+                debugInfo &lt;&lt; &quot;Effect check: &quot; &lt;&lt; checkIt-&gt;first &lt;&lt; &quot; now: &quot; &lt;&lt; now &lt;&lt; std::endl;
+                LOG_DEBUG(Logger::RULES,
+                    debugInfo.str());
+            for (Effects::iterator effIt = checkIt-&gt;second.begin(); effIt != checkIt-&gt;second.end(); effIt++)
+            {
+                int nextCheck;
+                nextCheck = (*effIt)-&gt;timeCheck();
+                switch (nextCheck)
+                {
+                  case Effect::REMOVE:
+                    removeEffect(*effIt);
+                    break;
+                  case Effect::PERMANENT:
+                    break;
+                  default:
+                    addTimeCheck(nextCheck, *effIt);
+                }
+            }
+            mChecklist.erase(checkIt++);
+        }
+
+        mCheckEffectsRunning = false;
+    }
+
+    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
+    {
+        // Preconditions: time &gt; 0, effect != NULL
+        if (time &lt;= 0) Throw(IllegalArgumentException, &quot;time parameter is &lt;= 0!&quot;);
+        if (effect == NULL) Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
+        // Get current ingame time and add timeUntilCheck
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        RL_LONGLONG timeForCheck = now + timeUntilCheck;
+        std::stringstream debugInfo;
+        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; timeForCheck &lt;&lt; std::endl;
+        LOG_DEBUG(Logger::RULES,
+            debugInfo.str());
+        // Insert Sum and effect into the checklist
+        mChecklist[timeForCheck].push_back(effect);
+    }
+
+    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
+    {
+        // Preconditions: date &gt; now, effect != NULL
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        if (date &lt;= now) 
+        {
+            Throw(IllegalArgumentException, &quot;date lies in the past!&quot;);
+        }
+        if (effect == NULL) 
+        {
+            Throw(IllegalArgumentException, &quot;effect pointer is NULL!&quot;);
+        }
+        // Insert date and effect into the checklist
+        std::stringstream debugInfo;
+        debugInfo &lt;&lt; &quot;Adding check! now:&quot; &lt;&lt; now &lt;&lt; &quot; check: &quot; &lt;&lt; date &lt;&lt; std::endl;
+        LOG_DEBUG(Logger::RULES, debugInfo.str());
+        mChecklist[date].push_back(effect);
+    }
+
+
+    void EffectManager::addEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+
+        LOG_DEBUG(Logger::RULES, &quot;Adding effect &quot; + effect-&gt;getName());
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            Effect* cur = *it;
+            if (cur-&gt;getName() == effect-&gt;getName())
+            {
+                if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
+                {
+                    return;
+                }
+                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
+                {
+                    //TODO
+                    //Vielleicht alten durch neuen ersetzen?
+                    //oder (*it)-&gt;setDuration(effect-&gt;getDuration())
+                }
+                else if (cur-&gt;getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
+                {
+                    for (int i = 0; i &lt; effect-&gt;getStufe(); i++)
+                    {
+                        cur-&gt;increaseStufe();
+                    }
+                }
+            }
+        }
+        ScriptWrapper::getSingleton().owned(effect);
+        mEffects.push_back(effect);
+        effect-&gt;enable();
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+    
+        effect-&gt;disable();
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); ++it)
+        {
+            if (*it == effect)
+            {
+                mEffects.erase(it);
+                break;
+            }
+        }
+        ScriptWrapper::getSingleton().disowned(effect);
+        ///@todo also remove from the check lists?
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(CeGuiString name)
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            if ((*it)-&gt;getName() == name)
+            {
+                removeEffect(*it);
+                return;
+            }
+        }
+    }
+
+    Effect::LifeState EffectManager::getLifeState()
+    {
+        checkEffects();
+        Effect::LifeState status = 0;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            status = status | ((*it)-&gt;getLifeState());
+        }
+        return status;
+    }
+
+    void EffectManager::checkStateChange(Effect::LifeState oldState)
+    {
+        Effect::LifeState currentState = getLifeState();
+        if (currentState != oldState)
+        {
+            MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectLifeStateChanged&gt;(mGameObject,
+                oldState, currentState);
+        }
+    }
+
+    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
+    {
+        checkEffects();
+        int mod = 0;
+        if (type == Effect::MODTYPE_MULT) mod = 1;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            mod += (*it)-&gt;getMod(target, type, tag);
+        }
+        return mod;
+    }
+
+    CeGuiString EffectManager::getEffects()
+    {
+        CeGuiString retVal = &quot;&quot;;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            retVal += (*it)-&gt;getName() + &quot;\n&quot;;
+            retVal += (*it)-&gt;getDescription() + &quot;\n&quot;;
+        }
+        return retVal;
+    }
+
     const Property EffectManager::getProperty(const CeGuiString&amp; key) const
     {
         Property rval;
         if (key == Creature::PROPERTY_EFFECTS)
         {
-            PropertyArray arr;
-            for (Effects::const_iterator it = mEffects.begin(); it != mEffects.end(); it++)
+            PropertyMap map;
+            
+            std::map&lt;Effect*, int&gt; effectIds;
+            PropertyArray effectProps;
+            for (int i = 0, size = mEffects.size(); i &lt; size; ++i)
             {
-                arr.push_back((*it)-&gt;getAllProperties()-&gt;toPropertyMap());
+                Effect* cur = mEffects[i];
+                effectProps.push_back(cur-&gt;getAllProperties()-&gt;toPropertyMap());
+                effectIds[cur] = i;
             }
-            rval = Property(arr);
+            
+            PropertyArray timeCheck;
+            for (std::map&lt;RL_LONGLONG, Effects&gt;::const_iterator itTc = mChecklist.begin(); 
+                itTc != mChecklist.end(); ++itTc)
+            {
+                for (Effects::const_iterator itEff = itTc-&gt;second.begin(); 
+                    itEff != itTc-&gt;second.end(); ++itEff)
+                {
+                    PropertyMap tcElem;
+                    tcElem[EffectManager::PROPERTY_EFFECT] = effectIds[*itEff];
+                    tcElem[EffectManager::PROPERTY_TIME] = itTc-&gt;first;
+                    timeCheck.push_back(tcElem);
+                }
+            }
+            
+            map[Creature::PROPERTY_EFFECTS] = effectProps;
+            map[EffectManager::PROPERTY_TIMECHECK] = timeCheck;
+            rval.setValue(map);
         }
         else 
         {
@@ -246,36 +279,50 @@
         {
             if (key == Creature::PROPERTY_EFFECTS)
             {
-                PropertyArray arr = value.toArray();
-                for (PropertyArray::iterator it = arr.begin(); it != arr.end(); it++)
+                PropertyMap map = value.toMap();
+                
+                std::vector&lt;Effect*&gt; effectIds;
+                
+                PropertyArray arr = map[Creature::PROPERTY_EFFECTS].toArray();
+                for (int i = 0, size = arr.size(); i &lt; size; ++i)
                 {
-                    PropertyMap cur = it-&gt;toMap();
+                    PropertyMap cur = arr[i].toMap();
                     Ogre::String name = cur[Effect::PROPERTY_NAME].toString().c_str();
                     int stufe = cur[Effect::PROPERTY_STUFE];
                     Effect* eff = EffectFactoryManager::getSingleton().createEffect(name, stufe);
-                    mEffects.insert(eff);
-                    ///@TODO: activate effects
-                }                
+                    eff-&gt;setProperties(cur);
+                    mEffects.push_back(eff);
+                    ///@TODO: activate effects?
+                }
+                
+                PropertyArray timeCheckProp = map[EffectManager::PROPERTY_TIMECHECK].toArray();
+                for (int i = 0, size = timeCheckProp.size(); i &lt; size; ++i)
+                {
+                    PropertyMap cur = timeCheckProp[i].toMap();
+                    RL_LONGLONG time = cur[EffectManager::PROPERTY_TIME].toLong();
+                    Effect* eff = mEffects[cur[EffectManager::PROPERTY_EFFECT].toInt()];
+                    mChecklist[time].push_back(eff);
+                }
             }
-            else
-            {
-                LOG_WARNING(Logger::RULES, 
-                    key + &quot; is not a property of EffectManager&quot;);
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(Logger::RULES, 
-                &quot;property &quot; + key + &quot; has the wrong format&quot;);
+            else
+            {
+                LOG_WARNING(Logger::RULES, 
+                    key + &quot; is not a property of EffectManager&quot;);
+            }
         }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(Logger::RULES, 
+                &quot;property &quot; + key + &quot; has the wrong format&quot;);
+        }
     }
 
-    PropertyKeys EffectManager::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        return keys;
-    }
-
-}
-
+    PropertyKeys EffectManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        return keys;
+    }
+
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001564.html">[Dsa-hl-svn] r4507 - in rl/trunk/engine: rules/include rules/src	script/swig
</A></li>
	<LI>Next message: <A HREF="001566.html">[Dsa-hl-svn] r4509 - rl/trunk/Mac
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1565">[ date ]</a>
              <a href="thread.html#1565">[ thread ]</a>
              <a href="subject.html#1565">[ subject ]</a>
              <a href="author.html#1565">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
