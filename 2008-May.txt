From chrber at mail.berlios.de  Fri May  2 13:42:17 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Fri, 2 May 2008 13:42:17 +0200
Subject: [Dsa-hl-svn] r4371 - in dependencies/opensteer: include/OpenSteer
	macosx/OpenSteer.xcodeproj
Message-ID: <200805021142.m42BgH6f015769@sheep.berlios.de>

Author: chrber
Date: 2008-05-02 13:41:56 +0200 (Fri, 02 May 2008)
New Revision: 4371

Modified:
   dependencies/opensteer/include/OpenSteer/Vec3.h
   dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
Log:
Carbon.h is now needed for Ogre on Mac OS X


Modified: dependencies/opensteer/include/OpenSteer/Vec3.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3.h	2008-04-30 15:59:51 UTC (rev 4370)
+++ dependencies/opensteer/include/OpenSteer/Vec3.h	2008-05-02 11:41:56 UTC (rev 4371)
@@ -53,6 +53,7 @@
 
 #include "OpenSteer/Utilities.h"  // for interpolate, etc.
 #ifdef __APPLE__
+	#include <Carbon/Carbon.h>
     #include <Ogre/Ogre.h>
 #else
     #include <Ogre.h>

Modified: dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
===================================================================



From chrber at mail.berlios.de  Fri May  2 13:43:56 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Fri, 2 May 2008 13:43:56 +0200
Subject: [Dsa-hl-svn] r4372 - in dependencies/OgreNewt:
	Mac/OgreNewt.xcodeproj include/OgreNewt
Message-ID: <200805021143.m42Bhu6X015873@sheep.berlios.de>

Author: chrber
Date: 2008-05-02 13:43:53 +0200 (Fri, 02 May 2008)
New Revision: 4372

Modified:
   dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h
Log:
Carbon.h is now needed for Ogre on Mac OS X


Modified: dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj
===================================================================
--- dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj	2008-05-02 11:41:56 UTC (rev 4371)
+++ dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj	2008-05-02 11:43:53 UTC (rev 4372)
@@ -320,8 +320,13 @@
 				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = "";
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/Ogre.framework/Headers,
+					/usr/local/include,
+				);
 				INFOPLIST_FILE = Info.plist;
 				INSTALL_PATH = "$(HOME)/Library/Frameworks";
+				LIBRARY_SEARCH_PATHS = /usr/local/lib;
 				LIBRARY_STYLE = DYNAMIC;
 				MACH_O_TYPE = mh_dylib;
 				PRODUCT_NAME = OgreNewt;

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h	2008-05-02 11:41:56 UTC (rev 4371)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h	2008-05-02 11:43:53 UTC (rev 4372)
@@ -14,6 +14,7 @@
 #define __INCLUDE_OGRENEWT_PREREQ__
 
 #ifdef __APPLE__
+#   include <Carbon/Carbon.h>
 #   include <Ogre/Ogre.h>
 #else
 #   include <Ogre.h>



From alassion at mail.berlios.de  Sun May  4 14:52:24 2008
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sun, 4 May 2008 14:52:24 +0200
Subject: [Dsa-hl-svn] r4373 - content/textures
Message-ID: <200805041252.m44CqOce002419@sheep.berlios.de>

Author: alassion
Date: 2008-05-04 14:50:26 +0200 (Sun, 04 May 2008)
New Revision: 4373

Modified:
   content/textures/baumstamm_kana_normal.png
   content/textures/boden_kana.png
   content/textures/boden_kana_normal.png
   content/textures/felsen2_kana_normal.png
   content/textures/pflaster_kana_normal.png
   content/textures/pilz.png
   content/textures/saeule_kana.png
   content/textures/saeule_kana_normal.png
   content/textures/schild_kana_normal.png
   content/textures/wand_kana.png
   content/textures/wand_kana_normal.png
Log:
- changed and added a few textures

Modified: content/textures/baumstamm_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/boden_kana.png
===================================================================
(Binary files differ)

Modified: content/textures/boden_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/felsen2_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/pflaster_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/pilz.png
===================================================================
(Binary files differ)

Modified: content/textures/saeule_kana.png
===================================================================
(Binary files differ)

Modified: content/textures/saeule_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/schild_kana_normal.png
===================================================================
(Binary files differ)

Modified: content/textures/wand_kana.png
===================================================================
(Binary files differ)

Modified: content/textures/wand_kana_normal.png
===================================================================
(Binary files differ)



From melven at mail.berlios.de  Tue May  6 20:51:10 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 6 May 2008 20:51:10 +0200
Subject: [Dsa-hl-svn] r4374 - rl/trunk/engine/rules/src
Message-ID: <200805061851.m46IpATQ018929@sheep.berlios.de>

Author: melven
Date: 2008-05-06 20:51:09 +0200 (Tue, 06 May 2008)
New Revision: 4374

Modified:
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
play animation "sterben" only once!


Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-04 12:50:26 UTC (rev 4373)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-06 18:51:09 UTC (rev 4374)
@@ -74,9 +74,9 @@
 	{
             // todo: wieder aufstehen
             if( mMovingCreature->getCreature()->getLifeState() & (Effect::LS_DEAD | Effect::LS_UNCONSCIOUS) )
-                mMovingCreature->setAnimation(mAnim1.first, mAnim1.second, 0);
+                mMovingCreature->setAnimation(mAnim1.first, mAnim1.second, 1);
             else
-                mMovingCreature->setAnimation(mAnim.first, mAnim.second, 0);
+                mMovingCreature->setAnimation(mAnim.first, mAnim.second, 1);
 	    return true;
 	}
         virtual void applyAuChanges(Ogre::Real elapsedTime)



From melven at mail.berlios.de  Tue May  6 21:47:24 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 6 May 2008 21:47:24 +0200
Subject: [Dsa-hl-svn] r4375 - in rl/trunk/engine/rules: include src
Message-ID: <200805061947.m46JlO6g022790@sheep.berlios.de>

Author: melven
Date: 2008-05-06 21:47:22 +0200 (Tue, 06 May 2008)
New Revision: 4375

Modified:
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/EffectManager.cpp
Log:
removed bug 57: game frozen, when paralue-effect is used


Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2008-05-06 18:51:09 UTC (rev 4374)
+++ rl/trunk/engine/rules/include/EffectManager.h	2008-05-06 19:47:22 UTC (rev 4375)
@@ -102,6 +102,9 @@
 
         GameObject* mGameObject;
 
+        // only used in checkEffects!
+        bool mCheckEffectsRunning;
+
         /// Eine einfache Menge von Effekten
 		typedef std::set<Effect*> Effects;
 		Effects mEffects;

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2008-05-06 18:51:09 UTC (rev 4374)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
@@ -29,7 +29,8 @@
 namespace rl
 {
 	EffectManager::EffectManager(GameObject* gameobject)
-        : mGameObject(gameobject)
+        : mGameObject(gameobject),
+        mCheckEffectsRunning(false)
 	{
 	}
 
@@ -44,6 +45,9 @@
 
 	void EffectManager::checkEffects()
 	{
+            if( mCheckEffectsRunning )
+                return;
+            mCheckEffectsRunning = true;
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
         Checklist::iterator checkIt = mChecklist.begin();
         if (checkIt == mChecklist.end()) return;
@@ -70,6 +74,8 @@
             }
             mChecklist.erase(checkIt++);
         }
+
+        mCheckEffectsRunning = false;
 	}
 
     void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)



From blakharaz at mail.berlios.de  Tue May 20 23:21:44 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 20 May 2008 23:21:44 +0200
Subject: [Dsa-hl-svn] r4376 - in rl/trunk/engine/rules: include src
Message-ID: <200805202121.m4KLLiQ4019336@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-20 23:21:27 +0200 (Tue, 20 May 2008)
New Revision: 4376

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
Log:
Use CEGUI::String as game object classId


Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/trunk/engine/rules/include/GameObject.h	2008-05-20 21:21:27 UTC (rev 4376)
@@ -72,8 +72,8 @@
 
         int getId() const;
 
-        const Ogre::String getClassId() const;
-        void setClassId(Ogre::String classId);
+        const CeGuiString& getClassId() const;
+        void setClassId(const CeGuiString& classId);
         
         const CeGuiString& getName() const;
         void setName(const CeGuiString& name);
@@ -196,7 +196,7 @@
         CeGuiString mMeshfile;
 		MeshPartMap mMeshParts;
         CeGuiString mSubmeshPreName;
-        Ogre::String mClassId;
+        CeGuiString mClassId;
         
         Actor* mActor;
         

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2008-05-20 21:21:27 UTC (rev 4376)
@@ -50,7 +50,7 @@
         ~GameObjectManager();
 
         GameObject* getGameObject(unsigned int id) const;
-        GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
+        GameObject* createGameObject(const CeGuiString& classId, unsigned int id = 0);
 		
         void deleteGameObject(unsigned int id);
         void deleteGameObject(GameObject* obj);
@@ -83,7 +83,7 @@
         virtual void readData(SaveGameFileReader* reader);
         virtual int getPriority() const;
     private:
-        typedef std::map<const Ogre::String, PropertyRecordPtr> ClassPropertyMap;
+        typedef std::map<const CeGuiString, PropertyRecordPtr> ClassPropertyMap;
         typedef std::set<GameObjectStateListener*> GameObjectStateListenerSet;
 
         Ogre::StringVector mScriptPatterns;
@@ -95,7 +95,7 @@
         GameObjectStateListenerSet mGameObjectStateListeners;
 
         unsigned int generateId();
-        const PropertyRecordPtr getClassProperties(const Ogre::String& classId) const;
+        const PropertyRecordPtr getClassProperties(const CeGuiString& classId) const;
         void applyProperties(GameObject* go, PropertyRecordPtr ps) const;
 
         PropertyMap getPropertyMapDifference(PropertyMap map1, PropertyMap map2);

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2008-05-20 21:21:27 UTC (rev 4376)
@@ -108,12 +108,12 @@
         return mId;
     }
 
-    const Ogre::String GameObject::getClassId() const
+    const CeGuiString& GameObject::getClassId() const
     {
         return mClassId;
     }
 
-    void GameObject::setClassId(Ogre::String classId)
+    void GameObject::setClassId(const CeGuiString& classId)
     {
         mClassId = classId;
     }

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-05-20 21:21:27 UTC (rev 4376)
@@ -117,7 +117,7 @@
     }
 
     GameObject* GameObjectManager::createGameObject(
-        const Ogre::String& classId, unsigned int id)
+        const CeGuiString& classId, unsigned int id)
     {
 		LOG_MESSAGE("GameObjectManager", "Create/Get GameObject of type " + classId
 			+ " #" + Ogre::StringConverter::toString((int)id));
@@ -142,7 +142,7 @@
         }
 
         PropertyRecordPtr ps = getClassProperties(classId);
-        Ogre::String classname =  ps->getProperty(GameObject::PROPERTY_BASE_CLASS).toString().c_str();
+        Ogre::String classname = ps->getProperty(GameObject::PROPERTY_BASE_CLASS).toString().c_str();
 
         GameObject* go = mGameObjectFactory
             ->createGameObject(
@@ -214,7 +214,7 @@
 		return Property(go->getClassId() + "|" + CEGUI::PropertyHelper::uintToString(go->getId()));
 	}
 
-    const PropertyRecordPtr GameObjectManager::getClassProperties(const Ogre::String& classId) const
+    const PropertyRecordPtr GameObjectManager::getClassProperties(const CeGuiString& classId) const
     {
         ClassPropertyMap::const_iterator it = mClassProperties.find(classId);
         if (it == mClassProperties.end())



From pnyx at mail.berlios.de  Thu May 22 11:40:24 2008
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 22 May 2008 11:40:24 +0200
Subject: [Dsa-hl-svn] r4377 - rl/trunk/engine/rules/src
Message-ID: <200805220940.m4M9eOZQ000655@sheep.berlios.de>

Author: pnyx
Date: 2008-05-22 11:40:23 +0200 (Thu, 22 May 2008)
New Revision: 4377

Modified:
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
methodes needed to return a value

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-20 21:21:27 UTC (rev 4376)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-22 09:40:23 UTC (rev 4377)
@@ -85,10 +85,12 @@
         virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
 	{
 	    direction = Vector3::ZERO;
+		return false;
 	}
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
 	{
 	    rotation = Vector3::ZERO;
+		return false;
 	}
     protected:
         Creature::AnimationSpeedPair mAnim;



From tanis at mail.berlios.de  Thu May 22 17:20:58 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 17:20:58 +0200
Subject: [Dsa-hl-svn] r4378 - rl/trunk/engine/script/swig
Message-ID: <200805221520.m4MFKwTh030753@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 17:20:56 +0200 (Thu, 22 May 2008)
New Revision: 4378

Modified:
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
export GoToJob to ruby scripting interface.

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-22 09:40:23 UTC (rev 4377)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-22 15:20:56 UTC (rev 4378)
@@ -35,6 +35,7 @@
 #include "GameObject.h"
 #include "GameObjectManager.h"
 #include "GlobalProperties.h"
+#include "GoToJob.h"
 #include "Inventory.h"
 #include "Item.h"
 #include "ObjectStateChangeEventSource.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-05-22 09:40:23 UTC (rev 4377)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-05-22 15:20:56 UTC (rev 4378)
@@ -445,6 +445,16 @@
         WaitJob(const Ogre::Real& realtime);
     };
     
+    class GoToJob : public rl::Job
+    {
+    public:
+
+		GoToJob(rl::Creature* actor, const Ogre::Vector3& targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		// Unclear what version is called from ruby, so uncomment second ctor.
+		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+    };
+    
     %feature("director") Item;
     class Item : public rl::GameObject {
     public:



From tanis at mail.berlios.de  Thu May 22 17:28:14 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 17:28:14 +0200
Subject: [Dsa-hl-svn] r4379 - modules/common/scripts/jobs
Message-ID: <200805221528.m4MFSE2j031313@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 17:28:13 +0200 (Thu, 22 May 2008)
New Revision: 4379

Added:
   modules/common/scripts/jobs/gotojobs.rb
Log:
First basic GoTo-Job-Functions exposed in ruby.

Added: modules/common/scripts/jobs/gotojobs.rb
===================================================================
--- modules/common/scripts/jobs/gotojobs.rb	2008-05-22 15:20:56 UTC (rev 4378)
+++ modules/common/scripts/jobs/gotojobs.rb	2008-05-22 15:28:13 UTC (rev 4379)
@@ -0,0 +1,10 @@
+require 'globals.rb'
+
+def GoTo(acting_creature, targetpos)
+    job = GoToJob.new(acting_creature, targetpos, 1000000, 1000000)
+    $JS.addJob(job)
+end
+
+def _GoTo(acting_creature, targetpos)
+    GoToJob.new(acting_creature, targetpos, 1000000, 1000000)
+end



From tanis at mail.berlios.de  Thu May 22 18:54:04 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 18:54:04 +0200
Subject: [Dsa-hl-svn] r4380 - rl/trunk/tools
Message-ID: <200805221654.m4MGs4rj002906@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 18:54:01 +0200 (Thu, 22 May 2008)
New Revision: 4380

Added:
   rl/trunk/tools/material_updater.rb
Log:
Material update script for transition from Ogre 1.4 to Ogre 1.6
N O C H   N I C H T  B E N U T Z E N !!!

Added: rl/trunk/tools/material_updater.rb
===================================================================
--- rl/trunk/tools/material_updater.rb	2008-05-22 15:28:13 UTC (rev 4379)
+++ rl/trunk/tools/material_updater.rb	2008-05-22 16:54:01 UTC (rev 4380)
@@ -0,0 +1,108 @@
+=begin
+Copyright (c) 2008 Daniel Wickert
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.  
+
+ This script adds necessary import statements for switch Ogre 1.4 -> Ogre 1.6
+ Only run it once on any given set of materials.
+ If a base material's source file can't be determined,
+ it is imported from __unkown_material_file__,
+ so it is easy to spot missing files.
+
+ This script expects a single base directory as argument,
+ if none given process current directory
+ call:
+ > ruby material_upgrader.rb [base_directory]
+
+=end
+
+require 'find'
+
+base = ARGV.empty? ? '.' : ARGV[0]
+
+# key: derived material name, value: base material name.
+derived_materials = Hash.new
+# key: file name, value: Array of material names.
+materials_per_file = Hash.new
+# key: material name, value: file base name.
+file_per_material = Hash.new("__unkown_material_file__")
+
+# Find all materials, their base materials and store which material is defined where.
+Find.find(base) do |path|
+  if test(?d, path) :
+    # Do not enter hidden directories like .svn
+    if File.basename(path)[0] == ?. :
+      Find.prune
+    end
+    puts "Entering " + path + "..."
+  else
+    # Actual file. Is it a material or program?
+    if path =~ /\.(material|program)$/ :
+      puts "   Parsing #{File.basename(path)}..."
+      materials = Array.new
+      File.open(path, "r+").each do |line|
+        # For each material in the file store it in an array.
+        if line =~ /^\s*material\s+([^:\s]*)/ :
+          puts "      found material #$1."
+          materials << $1
+          file_per_material[$1] = File.basename(path)
+        end
+        # For each dervied material store material and its base material in a hash.
+        if line =~ /^\s*material\s+([^:\s]*)?\s*:\s*([^:\s]*)?\s+$/ :
+          puts "         it is derived from #$2."
+          derived_materials[$1] = $2
+        end
+      end
+      materials_per_file[path] = materials
+    end
+  end
+end
+
+materials_per_file.each do |file, materials|
+  # does the file contain derived materials?
+  imports = Array.new
+  materials.each do |mat|
+    if derived_materials.has_key? mat :
+      # Prepare an import statement.
+      basemat = derived_materials[mat]
+      importfile = file_per_material[basemat]
+      if importfile != File.basename(file) :
+        imports << "import #{basemat} from #{importfile}\n"        
+      end
+    end
+  end
+  if not imports.empty? :
+    imports.sort!
+    imports.uniq!
+    # Open file and add imports at the beginning.
+    puts "in file #{file}:"
+    imports.each {|line| puts "   #{line}"}
+    File.open(file, File::RDWR) do |f|
+      content = f.readlines
+      f.pos = 0
+      f.print imports
+      f.print "\n"
+      f.print content
+      f.truncate f.pos
+    end
+  end
+end
+
+
+



From tanis at mail.berlios.de  Thu May 22 20:21:26 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 20:21:26 +0200
Subject: [Dsa-hl-svn] r4381 - in rl/branches: .
	ogre16/rl/trunk/engine/core/include ogre16/rl/trunk/engine/core/src
	ogre16/rl/trunk/engine/rules/src ogre16/rl/trunk/engine/script/swig
	ogre16/rl/trunk/engine/ui/src ogre16/rl/trunk/tools
Message-ID: <200805221821.m4MILQ4A004025@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 20:21:17 +0200 (Thu, 22 May 2008)
New Revision: 4381

Added:
   rl/branches/ogre16/
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
   rl/branches/ogre16/rl/trunk/tools/material_updater.rb
Removed:
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
Modified:
   rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h
   rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h
   rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h
   rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h
   rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h
   rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp
   rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Branch for new ogre version 1.6

Copied: rl/branches/ogre16 (from rev 4375, )

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h
===================================================================
--- rl/trunk/engine/core/include/ListenerMovable.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -48,6 +48,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
     
         /// Gibt die Hauptlautstaerke zurueck
         virtual const int getGain() const;

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h
===================================================================
--- rl/trunk/engine/core/include/MovableText.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -58,6 +58,7 @@
         const Ogre::Vector3& getWorldPosition(void) const;
         void _notifyCurrentCamera(Ogre::Camera *cam);
         void _updateRenderQueue(Ogre::RenderQueue* queue);
+		void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
         const Ogre::AxisAlignedBox &getBoundingBox(void) const { return mAABB; }
         const Ogre::String& getMovableType(void) const { return msType; }

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -81,6 +81,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
 
         /// Gibt die eingestellte Position der Soundquelle zurueck

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h
===================================================================
--- rl/trunk/engine/core/include/SoundResource.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -47,7 +47,7 @@
         /// Den Datenstrom zur???ckgeben
         const Ogre::DataStreamPtr &getDataStream() const;
         /// Groesse zurueckgeben.
-        int getSize() const;
+        virtual size_t getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h
===================================================================
--- rl/trunk/engine/core/include/SoundStitching.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -83,6 +83,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
         /// Count of configured slots.
         unsigned int getNumSlots();

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -432,19 +432,6 @@
         {
             Vector3 vec = Vector3(sx,sy,sz);
             node->setScale( vec );
-
-            // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()->isMeshObject() )
-            {
-                MeshObject* meshObj = dynamic_cast<MeshObject*>( getControlledObject() );
-
-                // ... und gr??er/kleiner als normal skaliert wird ...
-                if( vec != Vector3(1,1,1) )
-                    // ... m?ssen die Normalen neu berechnet werden.
-                    meshObj->getEntity()->setNormaliseNormals( true );
-                else
-                    meshObj->getEntity()->setNormaliseNormals( false );
-            }
         }
     }
 

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -81,6 +81,7 @@
         addSetting("Video", "Max Anisotropy", "1");
 		addSetting("Video", "Cast Shadows", "yes");
 		addSetting("Video", "Shadow Texture Size", "512");
+		addSetting("Video", "useNVPerfHUD", "true");
 
         // Setup input default values
         addSetting("Input", "Mouse Sensitivity", "4");

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,581 +1,582 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "XmlResourceManager.h"
-
-#include "CoreSubsystem.h"
-
-#include <OgreEnvironment.h>
-
-#include "ActorManager.h"
-#include "AnimationManager.h"
-#include "ContentModule.h"
-#include "ConfigurationManager.h"
-#include "DebugVisualsManager.h"
-#include "DotSceneOctreeWorld.h"
-#include "Exception.h"
-#include "GameEventManager.h"
-#include "GameLoop.h"
-#include "JobScheduler.h"
-#include "Logger.h"
-#include "MessagePump.h"
-#include "PhysicsManager.h"
-#include "RubyInterpreter.h"
-#include "SaveGameManager.h"
-#include "ScriptWrapper.h"
-#include "SoundManager.h"
-#include "TimeSource.h"
-#include "ZoneManager.h"
-
-#include <ctime>
-
-using namespace Ogre;
-
-template<> rl::CoreSubsystem* Singleton<rl::CoreSubsystem>::ms_Singleton = 0;
-
-namespace rl
-{
-    CoreSubsystem::CoreSubsystem()
-        : Singleton<CoreSubsystem>(),
-        mWorld(NULL),
-        mRubyInterpreter(NULL),
-        mModules(),
-        mActiveAdventureModule(NULL),
-        mDefaultActiveModule(""),
-        mClockStartTime(),
-        mDeveloperMode(false),
-        mInitialized(false),
-        mDefaultTechniques(),
-        mOgreRoot(NULL),
-        mScriptWrapper(NULL),
-        mXmlResourceManager(NULL),
-        mPhysicsManager(NULL),
-        mMessagePump(NULL),
-        mGameLoop(NULL),
-        mAnimationManager(NULL),
-        mActorManager(NULL),
-        mGameEventManager(NULL),
-        mSoundManager(NULL),
-        mDebugVisualsManager(NULL),
-        mJobScheduler(NULL),
-        mRenderWindow(NULL),
-        mZoneManager(NULL)
-    {
-        initializeCoreSubsystem();
-    }
-
-    CoreSubsystem::~CoreSubsystem()
-    {
-        delete meshmagick::OgreEnvironment::getSingletonPtr();
-        delete mWorld;
-        delete mZoneManager;
-        delete mGameEventManager;
-        delete mMessagePump;
-        delete mJobScheduler;
-        delete mAnimationManager;
-        delete mActorManager;
-        delete mPhysicsManager;
-        delete mScriptWrapper;
-        delete mDebugVisualsManager;
-        delete ConfigurationManager::getSingletonPtr();
-        delete mSoundManager;
-        mRenderWindow->destroy();
-        delete mOgreRoot;
-        delete mRubyInterpreter;
-        delete mTimeSourceManager;
-        delete mSaveGameManager;
-        delete mGameLoop;
-        //mXmlResourceManager->unloadAll();
-        //delete mXmlResourceManager;
-    }
-
-    void CoreSubsystem::startCore()
-    {
-        loadPlugins();
-
-        mInitialized = true;
-
-        if (mDefaultActiveModule == "")
-        {
-            mDefaultActiveModule = "intro"; ///@fixme replace by last active
-        }
-
-
-        ContentModule* mod = getModule(mDefaultActiveModule);
-        if (mod == NULL)
-        {
-            Throw(rl::RuntimeException, "Module "+mDefaultActiveModule+" not found");
-        }
-        else
-        {
-            startAdventureModule(mod);
-        }
-
-        mGameLoop->loop();
-
-        mWorld->clearScene();
-        unloadPlugins();
-
-        //mRubyInterpreter->finalizeInterpreter();
-    }
-
-    void CoreSubsystem::renderOneFrame()
-    {
-        mGameLoop->_executeOneRenderLoop();
-    }
-
-    void CoreSubsystem::setDeveloperMode(bool developerMode)
-    {
-        mDeveloperMode = developerMode;
-    }
-
-    bool CoreSubsystem::getDeveloperMode() const
-    {
-        return mDeveloperMode;
-    }
-
-    bool CoreSubsystem::isInitialized() const
-    {
-        return mInitialized;
-    }
-
-    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
-    {
-        return mRenderWindow;
-    }
-
-	void CoreSubsystem::setPaused(bool paused)
-	{
-       // mAnimationManager->setPaused(paused);
-       // mPhysicsManager->setPaused(paused);
-        mTimeSourceManager->setPaused(paused);
-        mGameLoop->setPaused(paused);
-	}
-
-    void CoreSubsystem::setTimeFactor(const Ogre::Real &factor)
-    {
-        mTimeSourceManager->setTimeFactor(factor);
-        mPhysicsManager->setTimeFactor(factor);
-        mGameLoop->setTimeFactor(factor);
-    }
-
-    bool CoreSubsystem::initializeCoreSubsystem()
-    {
-        // set default queryflags to zero
-        Ogre::MovableObject::setDefaultQueryFlags(0);
-        // By not specifying the first two parameters, OGRE will not try
-        // to load plugins.cfg and ogre.cfg
-        mOgreRoot = new Root("", "", ConfigurationManager::getSingleton().getOgreLogFile());
-
-        // Load Ogre plugins
-        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
-        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it < pluginList.end(); it++)
-        {
-            mOgreRoot->loadPlugin(*it);
-        }
-
-        // Find out, what Renderer plugins are available
-        RenderSystemList* rsl = mOgreRoot->getAvailableRenderers();
-        RenderSystemList::iterator it;
-
-        for (it = rsl->begin(); it < rsl->end(); it++)
-        {
-            if ((*it)->getName() == ConfigurationManager::getSingleton().getStringSetting(
-                "Video", "Render System"))
-            {
-                // Select and initialise the render system
-                mOgreRoot->setRenderSystem(*it);
-                mOgreRoot->initialise(false, "");
-            }
-        }
-
-        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
-
-        // Muss vor dem Laden der Ressourcen geschehen,
-        // weil es sonst sofort angewandt wird.
-        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
-
-        // EDIT:
-        LOG_MESSAGE(Logger::CORE,"init");
-
-        std::stringstream name;
-        name << "Rastullahs Lockenpracht - ";
-        name << getEngineVersionString() << " ";
-        name << getEngineVersionName() << " [";
-        name << getEngineBuildNumber() << "]";
-
-        // Get width and height of the RenderWindow from the "Video Mode" setting
-        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
-            "Video", "Video Mode");
-        int temp = VideoMode.find("x");
-        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
-        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
-
-        mRenderWindow = mOgreRoot->createRenderWindow(
-            name.str(), width, height,
-            ConfigurationManager::getSingleton().getBoolSetting(
-                "Video", "Fullscreen"),
-            ConfigurationManager::getSingleton().getVideoSettings());
-
-        if (!mRenderWindow)
-            return false;
-
-        mGameLoop = new GameLoop();
-        LOG_MESSAGE(Logger::CORE,"GameLoopmanager erzeugt");
-
-        mSaveGameManager = new SaveGameManager();
-        LOG_MESSAGE(Logger::RULES, "SaveGameManager erzeugt");
-		
-		mTimeSourceManager = new TimeSourceManager();
-        mTimeSourceManager->registerTimeSource(new RealTimeContinuous());
-        mTimeSourceManager->registerTimeSource(new RealTimeInterruptable());
-        LOG_MESSAGE(Logger::CORE,"Time sources (realtime) created");
-
-        mScriptWrapper = new ScriptWrapper();
-        LOG_MESSAGE(Logger::CORE,"Skriptwrapper erzeugt");
-        ///@todo: muss loeschbar werden.
-        mRubyInterpreter = new RubyInterpreter();
-        LOG_MESSAGE(Logger::CORE,"RubyInterpreter erzeugt");
-        mRubyInterpreter->initializeInterpreter();
-        LOG_MESSAGE(Logger::CORE,"RubyInterpreter initialisiert");
-
-        mMessagePump = new MessagePump();
-        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,"MessagePump erzeugt");
-
-        mActorManager = new ActorManager();
-        LOG_MESSAGE(Logger::CORE,"Aktormanager erzeugt");
-
-        mSoundManager = new SoundManager();
-        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
-        LOG_MESSAGE(Logger::CORE,"SoundManager erzeugt");
-
-        initializeResources();
-
-        // Set default mipmap level (NB some APIs ignore this)
-        ///@todo: In Config-Datei verlagern
-        TextureManager::getSingleton().setDefaultNumMipmaps(5);
-        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
-        MaterialManager::getSingleton().setDefaultAnisotropy(
-            ConfigurationManager::getSingleton().getIntSetting(
-                "Video", "Max Anisotropy"));
-
-
-        mWorld = new DotSceneOctreeWorld();
-        mActorManager->setWorld(mWorld);
-
-        mPhysicsManager = new PhysicsManager();
-        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
-        LOG_MESSAGE(Logger::CORE,"PhysicsManager erzeugt");
-
-        mAnimationManager = new AnimationManager();
-        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,"AnimationManager erzeugt");
-
-        mGameEventManager = new GameEventManager();
-        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,"GameEventManager erzeugt");
-
-        mDebugVisualsManager = new DebugVisualsManager();
-        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,"DebugVisualsManager erzeugt");
-
-        mJobScheduler = new JobScheduler();
-        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,"JobScheduler erzeugt");
-
-		mZoneManager = new ZoneManager();
-        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,"ZoneManager erzeugt");
-
-		new meshmagick::OgreEnvironment();
-		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
-
-        return true;
-    }
-
-    void CoreSubsystem::initializeResources()
-    {
-        mXmlResourceManager = new XmlResourceManager();
-
-        // Fuer Configs die keinem Typ zugeordnet sind,
-        // und die per kompletten Verezeichnis erfragt werden
-        ResourceGroupManager::getSingleton().addResourceLocation(
-            ConfigurationManager::getSingleton().
-                getModulesRootDirectory(),
-            "FileSystem",
-            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-
-        // Initialise the modules
-        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
-
-        for (size_t i = 0; i < modulesList.size(); i++)
-        {
-            mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
-
-            ContentModule* module = getModule(modulesList[i]);
-
-            if (module == NULL)
-            {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "'");
-            }
-            //else
-            //{
-            //    if (module->isCommon())
-            //    {
-            //        module->initializeTextures();
-            //        module->initialize();
-            //    }
-            //}
-        }
-    }
-
-    ContentModule* CoreSubsystem::getModule(const Ogre::String& moduleId) const
-    {
-        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
-
-        if (moduleIt != mModules.end())
-        {
-            return (*moduleIt).second;
-        }
-        else
-        {
-            return NULL;
-        }
-    }
-
-    void CoreSubsystem::registerModule(ContentModule* module)
-    {
-        mModules[module->getId()] = module;
-    }
-
-    void CoreSubsystem::updateDefaultScheme()
-    {
-        int numTu = mOgreRoot->getRenderSystem()->getCapabilities()->getNumTextureUnits();
-
-        Ogre::String tuScheme;
-
-        if (numTu >= 6)
-            tuScheme = "tu6";
-        else if (numTu >= 2)
-            tuScheme = "tu2";
-        else
-            tuScheme = "tu1";
-
-        LOG_MESSAGE(Logger::CORE,
-            "Found " + Ogre::StringConverter::toString(numTu) + " Texture Units, using "+
-            "alphablending scheme " + tuScheme);
-
-        for (ResourceManager::ResourceMapIterator itMat =
-            MaterialManager::getSingleton().getResourceIterator();
-            itMat.hasMoreElements();)
-        {
-            MaterialPtr mat = itMat.getNext();
-            for (Material::TechniqueIterator itTech =
-                mat->getTechniqueIterator();
-                itTech.hasMoreElements();)
-            {
-                Technique* tech = itTech.getNext();
-                if (tech->getSchemeName() == tuScheme)
-                {
-                    tech->setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
-                    mDefaultTechniques.push_back(tech);
-                }
-                else if (tech->getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
-                {
-                    mDefaultTechniques.push_back(tech);
-                }
-            }
-        }
-    }
-
-    void CoreSubsystem::setScheme(const Ogre::String& schemeName)
-    {
-        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
-        {
-            /*for (std::vector<Technique*>::iterator iter = mDefaultTechniques.begin();
-                iter != mDefaultTechniques.end(); ++iter)
-            {
-                Technique* cur = *iter;
-                cur->setSchemeName(schemeName);
-            }*/
-
-            MaterialManager::getSingleton().setActiveScheme(schemeName);
-        }
-    }
-
-    void CoreSubsystem::startAdventureModule(ContentModule* module)
-    {
-        if (mActiveAdventureModule != NULL)
-        {
-            mActiveAdventureModule->unload();
-        }
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
-
-        updateDefaultScheme();
-        loadModule(module);
-        mActiveAdventureModule = module;
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
-        
-        module->start();
-    }
-
-    void CoreSubsystem::loadModule(ContentModule* module)
-    {
-        if (module->getMinimumEngineVersion() > getEngineBuildNumber())
-        {
-            Throw(
-                rl::RuntimeException,
-                "Module "
-                + Ogre::String(module->getName().c_str())
-                + " needs engine >="
-                + StringConverter::toString(module->getMinimumEngineVersion())
-                + " but engine is "
-                + StringConverter::toString(getEngineBuildNumber()));
-        }
-
-        StringVector deps = module->getDependencies();
-        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
-        {
-            Ogre::String depName = *depsIt;
-            ModuleMap::iterator modIt = mModules.find(depName);
-            if (modIt == mModules.end())
-            {
-                Throw(
-                    rl::RuntimeException,
-                    "Depedency Module " + depName
-                    + " needed by " + Ogre::String(module->getName().c_str())
-                    + " not found.");
-            }
-
-            ContentModule* depMod = (*modIt).second;
-
-            if (!depMod->isLoaded())
-            {
-                loadModule(depMod);
-            }
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            "Start initializing module " + module->getName());
-        module->initializeTextures();
-        module->initialize();
-
-        ResourceGroupManager::getSingleton().initialiseResourceGroup(module->getId());
-        module->precreateMeshes();
-
-        if (module->isCommon())
-        {
-            module->start();
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            "Module " + module->getName() + " initialized.");
-    }
-
-    void CoreSubsystem::setDefaultActiveModule(const Ogre::String& module)
-    {
-        mDefaultActiveModule = module;
-    }
-
-    const Ogre::String& CoreSubsystem::getDefaultActiveModule() const
-    {
-        return mDefaultActiveModule;
-    }
-
-    World* CoreSubsystem::getWorld()
-    {
-        return mWorld;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionString() const
-    {
-        static Ogre::String version = "0.3.0";
-        return version;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionName() const
-    {
-        static Ogre::String version = "Internal Build";
-        return version;
-    }
-
-    long CoreSubsystem::getEngineBuildNumber() const
-    {
-        static const Ogre::String sMonths[] =
-        {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
-         "Sep", "Oct", "Nov", "Dec"};
-
-        Ogre::String dateStr = Ogre::String(__DATE__);
-        Ogre::String monthStr = dateStr.substr(0,3);
-        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
-        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
-        int month = 0;
-
-        while( month < 12 && monthStr.compare(sMonths[month]) != 0 )
-            month++;
-
-        return /* Jahr */          year * 100000 +
-               /* Monat */         (month+1) * 1000 +
-               /* Tag */           day * 10 +
-               /* Sub-Version */   0;
-    }
-
-    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
-    {
-        return mRubyInterpreter;
-    }
-
-    void CoreSubsystem::makeScreenshot( const Ogre::String& sName )
-    {
-        mRenderWindow->writeContentsToTimestampedFile(sName, ".png");
-    }
-
-    ContentModule* CoreSubsystem::getActiveAdventureModule() const
-    {
-        return mActiveAdventureModule;
-    }
-
-    const ModuleMap& CoreSubsystem::getAllModules() const
-    {
-        return mModules;
-    }
-
-    void CoreSubsystem::loadMap(const Ogre::String type, const Ogre::String filename,
-        const Ogre::String module)
-    {
-        mWorld->loadScene(filename, module);
-    }
-
-    void CoreSubsystem::loadPlugins()
-    {
-        mSoundManager->applySettings(rl::ConfigurationManager::getSingleton().getSettings("Sound"));
-        LOG_MESSAGE(Logger::CORE, "Soundeinstellungen geladen");
-    }
-
-    void CoreSubsystem::unloadPlugins()
-    {
-        mSoundManager->unloadAllDrivers();
-        LOG_MESSAGE(Logger::CORE, "Soundtreiber entladen");
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "XmlResourceManager.h"
+
+#include "CoreSubsystem.h"
+
+#include <OgreEnvironment.h>
+
+#include "ActorManager.h"
+#include "AnimationManager.h"
+#include "ContentModule.h"
+#include "ConfigurationManager.h"
+#include "DebugVisualsManager.h"
+#include "DotSceneOctreeWorld.h"
+#include "Exception.h"
+#include "GameEventManager.h"
+#include "GameLoop.h"
+#include "JobScheduler.h"
+#include "Logger.h"
+#include "MessagePump.h"
+#include "PhysicsManager.h"
+#include "RubyInterpreter.h"
+#include "SaveGameManager.h"
+#include "ScriptWrapper.h"
+#include "SoundManager.h"
+#include "TimeSource.h"
+#include "ZoneManager.h"
+
+#include <ctime>
+
+using namespace Ogre;
+
+template<> rl::CoreSubsystem* Singleton<rl::CoreSubsystem>::ms_Singleton = 0;
+
+namespace rl
+{
+    CoreSubsystem::CoreSubsystem()
+        : Singleton<CoreSubsystem>(),
+        mWorld(NULL),
+        mRubyInterpreter(NULL),
+        mModules(),
+        mActiveAdventureModule(NULL),
+        mDefaultActiveModule(""),
+        mClockStartTime(),
+        mDeveloperMode(false),
+        mInitialized(false),
+        mDefaultTechniques(),
+        mOgreRoot(NULL),
+        mScriptWrapper(NULL),
+        mXmlResourceManager(NULL),
+        mPhysicsManager(NULL),
+        mMessagePump(NULL),
+        mGameLoop(NULL),
+        mAnimationManager(NULL),
+        mActorManager(NULL),
+        mGameEventManager(NULL),
+        mSoundManager(NULL),
+        mDebugVisualsManager(NULL),
+        mJobScheduler(NULL),
+        mRenderWindow(NULL),
+        mZoneManager(NULL)
+    {
+        initializeCoreSubsystem();
+    }
+
+    CoreSubsystem::~CoreSubsystem()
+    {
+        delete meshmagick::OgreEnvironment::getSingletonPtr();
+        delete mWorld;
+        delete mZoneManager;
+        delete mGameEventManager;
+        delete mMessagePump;
+        delete mJobScheduler;
+        delete mAnimationManager;
+        delete mActorManager;
+        delete mPhysicsManager;
+        delete mScriptWrapper;
+        delete mDebugVisualsManager;
+        delete ConfigurationManager::getSingletonPtr();
+        delete mSoundManager;
+        mRenderWindow->destroy();
+        delete mOgreRoot;
+        delete mRubyInterpreter;
+        delete mTimeSourceManager;
+        delete mSaveGameManager;
+        delete mGameLoop;
+        //mXmlResourceManager->unloadAll();
+        //delete mXmlResourceManager;
+    }
+
+    void CoreSubsystem::startCore()
+    {
+        loadPlugins();
+
+        mInitialized = true;
+
+        if (mDefaultActiveModule == "")
+        {
+            mDefaultActiveModule = "intro"; ///@fixme replace by last active
+        }
+
+
+        ContentModule* mod = getModule(mDefaultActiveModule);
+        if (mod == NULL)
+        {
+            Throw(rl::RuntimeException, "Module "+mDefaultActiveModule+" not found");
+        }
+        else
+        {
+            startAdventureModule(mod);
+        }
+
+        mGameLoop->loop();
+
+        mWorld->clearScene();
+        unloadPlugins();
+
+        //mRubyInterpreter->finalizeInterpreter();
+    }
+
+    void CoreSubsystem::renderOneFrame()
+    {
+        mGameLoop->_executeOneRenderLoop();
+    }
+
+    void CoreSubsystem::setDeveloperMode(bool developerMode)
+    {
+        mDeveloperMode = developerMode;
+    }
+
+    bool CoreSubsystem::getDeveloperMode() const
+    {
+        return mDeveloperMode;
+    }
+
+    bool CoreSubsystem::isInitialized() const
+    {
+        return mInitialized;
+    }
+
+    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
+    {
+        return mRenderWindow;
+    }
+
+	void CoreSubsystem::setPaused(bool paused)
+	{
+       // mAnimationManager->setPaused(paused);
+       // mPhysicsManager->setPaused(paused);
+        mTimeSourceManager->setPaused(paused);
+        mGameLoop->setPaused(paused);
+	}
+
+    void CoreSubsystem::setTimeFactor(const Ogre::Real &factor)
+    {
+        mTimeSourceManager->setTimeFactor(factor);
+        mPhysicsManager->setTimeFactor(factor);
+        mGameLoop->setTimeFactor(factor);
+    }
+
+    bool CoreSubsystem::initializeCoreSubsystem()
+    {
+        // set default queryflags to zero
+        Ogre::MovableObject::setDefaultQueryFlags(0);
+        // By not specifying the first two parameters, OGRE will not try
+        // to load plugins.cfg and ogre.cfg
+        mOgreRoot = new Root("", "", ConfigurationManager::getSingleton().getOgreLogFile());
+		LogManager::getSingleton().getDefaultLog()->setLogDetail(LL_BOREME);
+
+        // Load Ogre plugins
+        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
+        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it < pluginList.end(); it++)
+        {
+            mOgreRoot->loadPlugin(*it);
+        }
+
+        // Find out, what Renderer plugins are available
+        RenderSystemList* rsl = mOgreRoot->getAvailableRenderers();
+        RenderSystemList::iterator it;
+
+        for (it = rsl->begin(); it < rsl->end(); it++)
+        {
+            if ((*it)->getName() == ConfigurationManager::getSingleton().getStringSetting(
+                "Video", "Render System"))
+            {
+                // Select and initialise the render system
+                mOgreRoot->setRenderSystem(*it);
+                mOgreRoot->initialise(false, "");
+            }
+        }
+
+        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
+
+        // Muss vor dem Laden der Ressourcen geschehen,
+        // weil es sonst sofort angewandt wird.
+        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
+
+        // EDIT:
+        LOG_MESSAGE(Logger::CORE,"init");
+
+        std::stringstream name;
+        name << "Rastullahs Lockenpracht - ";
+        name << getEngineVersionString() << " ";
+        name << getEngineVersionName() << " [";
+        name << getEngineBuildNumber() << "]";
+
+        // Get width and height of the RenderWindow from the "Video Mode" setting
+        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
+            "Video", "Video Mode");
+        int temp = VideoMode.find("x");
+        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
+        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
+
+        mRenderWindow = mOgreRoot->createRenderWindow(
+            name.str(), width, height,
+            ConfigurationManager::getSingleton().getBoolSetting(
+                "Video", "Fullscreen"),
+            ConfigurationManager::getSingleton().getVideoSettings());
+
+        if (!mRenderWindow)
+            return false;
+
+        mGameLoop = new GameLoop();
+        LOG_MESSAGE(Logger::CORE,"GameLoopmanager erzeugt");
+
+        mSaveGameManager = new SaveGameManager();
+        LOG_MESSAGE(Logger::RULES, "SaveGameManager erzeugt");
+		
+		mTimeSourceManager = new TimeSourceManager();
+        mTimeSourceManager->registerTimeSource(new RealTimeContinuous());
+        mTimeSourceManager->registerTimeSource(new RealTimeInterruptable());
+        LOG_MESSAGE(Logger::CORE,"Time sources (realtime) created");
+
+        mScriptWrapper = new ScriptWrapper();
+        LOG_MESSAGE(Logger::CORE,"Skriptwrapper erzeugt");
+        ///@todo: muss loeschbar werden.
+        mRubyInterpreter = new RubyInterpreter();
+        LOG_MESSAGE(Logger::CORE,"RubyInterpreter erzeugt");
+        mRubyInterpreter->initializeInterpreter();
+        LOG_MESSAGE(Logger::CORE,"RubyInterpreter initialisiert");
+
+        mMessagePump = new MessagePump();
+        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,"MessagePump erzeugt");
+
+        mActorManager = new ActorManager();
+        LOG_MESSAGE(Logger::CORE,"Aktormanager erzeugt");
+
+        mSoundManager = new SoundManager();
+        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
+        LOG_MESSAGE(Logger::CORE,"SoundManager erzeugt");
+
+        initializeResources();
+
+        // Set default mipmap level (NB some APIs ignore this)
+        ///@todo: In Config-Datei verlagern
+        TextureManager::getSingleton().setDefaultNumMipmaps(5);
+        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
+        MaterialManager::getSingleton().setDefaultAnisotropy(
+            ConfigurationManager::getSingleton().getIntSetting(
+                "Video", "Max Anisotropy"));
+
+
+        mWorld = new DotSceneOctreeWorld();
+        mActorManager->setWorld(mWorld);
+
+        mPhysicsManager = new PhysicsManager();
+        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
+        LOG_MESSAGE(Logger::CORE,"PhysicsManager erzeugt");
+
+        mAnimationManager = new AnimationManager();
+        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,"AnimationManager erzeugt");
+
+        mGameEventManager = new GameEventManager();
+        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,"GameEventManager erzeugt");
+
+        mDebugVisualsManager = new DebugVisualsManager();
+        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,"DebugVisualsManager erzeugt");
+
+        mJobScheduler = new JobScheduler();
+        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,"JobScheduler erzeugt");
+
+		mZoneManager = new ZoneManager();
+        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,"ZoneManager erzeugt");
+
+		new meshmagick::OgreEnvironment();
+		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
+
+        return true;
+    }
+
+    void CoreSubsystem::initializeResources()
+    {
+        mXmlResourceManager = new XmlResourceManager();
+
+        // Fuer Configs die keinem Typ zugeordnet sind,
+        // und die per kompletten Verezeichnis erfragt werden
+        ResourceGroupManager::getSingleton().addResourceLocation(
+            ConfigurationManager::getSingleton().
+                getModulesRootDirectory(),
+            "FileSystem",
+            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+
+        // Initialise the modules
+        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
+
+        for (size_t i = 0; i < modulesList.size(); i++)
+        {
+            mRubyInterpreter->executeFile(ContentModule::getInitFile(modulesList[i]));
+
+            ContentModule* module = getModule(modulesList[i]);
+
+            if (module == NULL)
+            {
+                Throw(rl::RuntimeException,
+                      ContentModule::getInitFile(modulesList[i]) + " did not register module '" + modulesList[i] + "'");
+            }
+            //else
+            //{
+            //    if (module->isCommon())
+            //    {
+            //        module->initializeTextures();
+            //        module->initialize();
+            //    }
+            //}
+        }
+    }
+
+    ContentModule* CoreSubsystem::getModule(const Ogre::String& moduleId) const
+    {
+        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
+
+        if (moduleIt != mModules.end())
+        {
+            return (*moduleIt).second;
+        }
+        else
+        {
+            return NULL;
+        }
+    }
+
+    void CoreSubsystem::registerModule(ContentModule* module)
+    {
+        mModules[module->getId()] = module;
+    }
+
+    void CoreSubsystem::updateDefaultScheme()
+    {
+        int numTu = mOgreRoot->getRenderSystem()->getCapabilities()->getNumTextureUnits();
+
+        Ogre::String tuScheme;
+
+        if (numTu >= 6)
+            tuScheme = "tu6";
+        else if (numTu >= 2)
+            tuScheme = "tu2";
+        else
+            tuScheme = "tu1";
+
+        LOG_MESSAGE(Logger::CORE,
+            "Found " + Ogre::StringConverter::toString(numTu) + " Texture Units, using "+
+            "alphablending scheme " + tuScheme);
+
+        for (ResourceManager::ResourceMapIterator itMat =
+            MaterialManager::getSingleton().getResourceIterator();
+            itMat.hasMoreElements();)
+        {
+            MaterialPtr mat = itMat.getNext();
+            for (Material::TechniqueIterator itTech =
+                mat->getTechniqueIterator();
+                itTech.hasMoreElements();)
+            {
+                Technique* tech = itTech.getNext();
+                if (tech->getSchemeName() == tuScheme)
+                {
+                    tech->setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
+                    mDefaultTechniques.push_back(tech);
+                }
+                else if (tech->getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
+                {
+                    mDefaultTechniques.push_back(tech);
+                }
+            }
+        }
+    }
+
+    void CoreSubsystem::setScheme(const Ogre::String& schemeName)
+    {
+        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
+        {
+            /*for (std::vector<Technique*>::iterator iter = mDefaultTechniques.begin();
+                iter != mDefaultTechniques.end(); ++iter)
+            {
+                Technique* cur = *iter;
+                cur->setSchemeName(schemeName);
+            }*/
+
+            MaterialManager::getSingleton().setActiveScheme(schemeName);
+        }
+    }
+
+    void CoreSubsystem::startAdventureModule(ContentModule* module)
+    {
+        if (mActiveAdventureModule != NULL)
+        {
+            mActiveAdventureModule->unload();
+        }
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
+
+        updateDefaultScheme();
+        loadModule(module);
+        mActiveAdventureModule = module;
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
+        
+        module->start();
+    }
+
+    void CoreSubsystem::loadModule(ContentModule* module)
+    {
+        if (module->getMinimumEngineVersion() > getEngineBuildNumber())
+        {
+            Throw(
+                rl::RuntimeException,
+                "Module "
+                + Ogre::String(module->getName().c_str())
+                + " needs engine >="
+                + StringConverter::toString(module->getMinimumEngineVersion())
+                + " but engine is "
+                + StringConverter::toString(getEngineBuildNumber()));
+        }
+
+        StringVector deps = module->getDependencies();
+        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
+        {
+            Ogre::String depName = *depsIt;
+            ModuleMap::iterator modIt = mModules.find(depName);
+            if (modIt == mModules.end())
+            {
+                Throw(
+                    rl::RuntimeException,
+                    "Depedency Module " + depName
+                    + " needed by " + Ogre::String(module->getName().c_str())
+                    + " not found.");
+            }
+
+            ContentModule* depMod = (*modIt).second;
+
+            if (!depMod->isLoaded())
+            {
+                loadModule(depMod);
+            }
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            "Start initializing module " + module->getName());
+        module->initializeTextures();
+        module->initialize();
+
+        ResourceGroupManager::getSingleton().initialiseResourceGroup(module->getId());
+        module->precreateMeshes();
+
+        if (module->isCommon())
+        {
+            module->start();
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            "Module " + module->getName() + " initialized.");
+    }
+
+    void CoreSubsystem::setDefaultActiveModule(const Ogre::String& module)
+    {
+        mDefaultActiveModule = module;
+    }
+
+    const Ogre::String& CoreSubsystem::getDefaultActiveModule() const
+    {
+        return mDefaultActiveModule;
+    }
+
+    World* CoreSubsystem::getWorld()
+    {
+        return mWorld;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionString() const
+    {
+        static Ogre::String version = "0.3.0";
+        return version;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionName() const
+    {
+        static Ogre::String version = "Internal Build";
+        return version;
+    }
+
+    long CoreSubsystem::getEngineBuildNumber() const
+    {
+        static const Ogre::String sMonths[] =
+        {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
+         "Sep", "Oct", "Nov", "Dec"};
+
+        Ogre::String dateStr = Ogre::String(__DATE__);
+        Ogre::String monthStr = dateStr.substr(0,3);
+        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
+        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
+        int month = 0;
+
+        while( month < 12 && monthStr.compare(sMonths[month]) != 0 )
+            month++;
+
+        return /* Jahr */          year * 100000 +
+               /* Monat */         (month+1) * 1000 +
+               /* Tag */           day * 10 +
+               /* Sub-Version */   0;
+    }
+
+    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
+    {
+        return mRubyInterpreter;
+    }
+
+    void CoreSubsystem::makeScreenshot( const Ogre::String& sName )
+    {
+        mRenderWindow->writeContentsToTimestampedFile(sName, ".png");
+    }
+
+    ContentModule* CoreSubsystem::getActiveAdventureModule() const
+    {
+        return mActiveAdventureModule;
+    }
+
+    const ModuleMap& CoreSubsystem::getAllModules() const
+    {
+        return mModules;
+    }
+
+    void CoreSubsystem::loadMap(const Ogre::String type, const Ogre::String filename,
+        const Ogre::String module)
+    {
+        mWorld->loadScene(filename, module);
+    }
+
+    void CoreSubsystem::loadPlugins()
+    {
+        mSoundManager->applySettings(rl::ConfigurationManager::getSingleton().getSettings("Sound"));
+        LOG_MESSAGE(Logger::CORE, "Soundeinstellungen geladen");
+    }
+
+    void CoreSubsystem::unloadPlugins()
+    {
+        mSoundManager->unloadAllDrivers();
+        LOG_MESSAGE(Logger::CORE, "Soundtreiber entladen");
+    }
+}

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -772,9 +772,6 @@
               return;
         }
 
-        if (parentNode->getScale() != Vector3::UNIT_SCALE)
-            newEnt->setNormaliseNormals(true);
-
         parentNode->attachObject(newEnt);
 
         LOG_DEBUG(Logger::CORE, " Entity '"+meshName+"' mit dem Namen '"+entName+"' in den Knoten '"+parentNode->getName()+"' eingef?gt.");

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerMovable.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -103,9 +103,15 @@
  */
 void ListenerMovable::_updateRenderQueue(RenderQueue *queue)
 {
-    // BListenerrauchen wir nicht
+    // Brauchen wir nicht
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 /**
  * @return Die aktuelle Richtung der Soundquelle (at-Vektor)
  * @author JoSch

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -554,4 +554,10 @@
     {
         return mAlignment;
     }
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+		bool debugRenderables)
+	{
+		visitor->visit(this, 0, false);
+	}
 }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -130,8 +130,8 @@
 		if (mBody && mActor)
 		{
 			mBody->setPositionOrientation(
-				mActor->_getSceneNode()->getWorldPosition(),
-				mActor->_getSceneNode()->getWorldOrientation());
+				mActor->_getSceneNode()->_getDerivedPosition(),
+				mActor->_getSceneNode()->_getDerivedOrientation());
 			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -315,8 +315,8 @@
 
 
             body->attachToNode(node);
-            body->setPositionOrientation(node->getWorldPosition(),
-                node->getWorldOrientation());
+            body->setPositionOrientation(node->_getDerivedPosition(),
+                node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
 			mLevelBodiesQuadTree.add(body);

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp
===================================================================
--- rl/trunk/engine/core/src/Sound.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -125,6 +125,12 @@
     // Brauchen wir nicht
 }
 
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 void Sound::setRolloffStartDistance(const Ogre::Real& distance)
 {
 	mRolloffStartDistance = distance;

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundResource.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -88,7 +88,7 @@
  * @author JoSch
  * @date 03-14-2005
  */
-int SoundResource::getSize() const
+size_t SoundResource::getSize() const
 {
     return calculateSize();
 }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundStitching.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -126,6 +126,12 @@
     // Brauchen wir nicht
 }
 
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
 {
 	mRolloffStartDistance = distance;

Modified: rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -85,10 +85,12 @@
         virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
 	{
 	    direction = Vector3::ZERO;
+        return false;
 	}
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
 	{
 	    rotation = Vector3::ZERO;
+        return false;
 	}
     protected:
         Creature::AnimationSpeedPair mAnim;

Deleted: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,57 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-%{
-//----------- Includes - Rules -----------
-#include "FixRubyHeaders.h"
-#include "RulesPrerequisites.h"
-
-#include "Action.h"
-#include "ActionManager.h"
-#include "Armor.h"
-#include "Container.h"
-#include "Creature.h"
-#include "CreatureController.h"
-#include "CreatureControllerManager.h"
-#include "Date.h"
-#include "DsaManager.h"
-#include "Effect.h"
-#include "EffectFactory.h"
-#include "EigenschaftenStateSet.h"
-#include "GameEventLog.h"
-#include "GameObject.h"
-#include "GameObjectManager.h"
-#include "GlobalProperties.h"
-#include "Inventory.h"
-#include "Item.h"
-#include "ObjectStateChangeEventSource.h"
-#include "ObjectStateChangeEvent.h"
-#include "ObjectStateChangeListener.h"
-#include "Quest.h"
-#include "QuestBook.h"
-#include "QuestEvent.h"
-#include "QuestListener.h"
-#include "RulesConstants.h"
-#include "RulesSubsystem.h"
-#include "Selector.h"
-#include "SonderfertigkeitenStateSet.h"
-#include "StateSet.h"
-#include "Talent.h"
-#include "TalentStateSet.h"
-#include "Tripel.h"
-#include "WaitJob.h"
-#include "Weapon.h"
-%}

Copied: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig (from rev 4378, rl/trunk/engine/script/swig/RlRules.head.swig)

Deleted: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,938 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-//%template(GameObjectVector) std::vector< rl::GameObject* >;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template<typename T>
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T& t1, const T& t2, const T& t3);
-      Tripel(const Tripel& rhs);
-
-      //Tripel& operator=(const Tripel& rhs);
-      bool operator==(const Tripel& rhs);
-      bool operator<(const Tripel& rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date& rhs);
-      
-        bool operator==(const Date& rhs);
-        bool operator<(const Date& rhs);
-        bool operator<=(const Date& rhs);
-        bool operator>=(const Date& rhs);
-        bool operator>(const Date& rhs);
-
-        Date operator+(const RL_LONGLONG& rhs);
-        Date operator-(const RL_LONGLONG& rhs);
-        Date operator*(const Ogre::Real& rhs);
-        Date operator/(const Ogre::Real& rhs);
-        RL_LONGLONG operator-(const Date& rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&, const Date&);
-    Date operator-(const RL_LONGLONG&, const Date&);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem& getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date& date);
-        
-        int rollD20();
-        Tripel<int> roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager& getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature("director") GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager& getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog& getSingleton();
-		void logEvent(const Ogre::String& eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String& key) const;
-        
-        static rl::GlobalProperties& getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature("director") QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map<const rl::CeGuiString,int> AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel<rl::CeGuiString>& eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &ausweichTalente);
-
-        bool operator==(const Talent& rhs) const;
-        bool operator<(const Talent& rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel<rl::CeGuiString> getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature("director") Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1<<0;
-        static const int ACT_INVIS_DESC = 1<<1;
-        static const int ACT_DISABLED = 1<<2;
-        static const int ACT_NEEDS_TALENT = 1<<8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature("director") ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature("director") GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector<Action*> getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3& position);
-        void setOrientation(const Ogre::Quaternion& orientation);
-        const Ogre::Quaternion& getOrientation() const;
-        const Ogre::Vector3& getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date& dsatime);
-        WaitJob(const Ogre::Real& realtime);
-    };
-    
-    %feature("director") Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 << 0,
-            ITEMTYPE_SHIELD     = 1 << 1,
-            ITEMTYPE_RING       = 1 << 2,
-            ITEMTYPE_GLOVES     = 1 << 3,
-            ITEMTYPE_BRACELET   = 1 << 4,
-            ITEMTYPE_ARMOR      = 1 << 5,
-            ITEMTYPE_CAPE       = 1 << 6,
-            ITEMTYPE_BRACERS    = 1 << 7,
-            ITEMTYPE_BACKPACK   = 1 << 8,
-            ITEMTYPE_BELT       = 1 << 9,
-            ITEMTYPE_NECKLACE   = 1 << 10,
-            ITEMTYPE_HELMET     = 1 << 11,
-            ITEMTYPE_TROUSERS   = 1 << 12,
-            ITEMTYPE_SHINBONE   = 1 << 13,
-            ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_CLOTHES    = 1 << 15,
-            ITEMTYPE_OTHER      = 1 << 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel<int>& getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair<int, int>& getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair<int, int>& newWm);
-        const std::pair<int,int>& getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
-        static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature("director") Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1<<0;
-        static const LifeState LS_BLIND          = 1<<1;   ///< The creature can't see anything.
-        static const LifeState LS_DEAD           = 1<<2;   ///< The creature is dead.
-        static const LifeState LS_DEAF           = 1<<3;   ///< The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1<<10;  ///< The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 << 0;
-        static const ModType MODTYPE_SUM      = 1 << 1;   ///< Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 << 3;   ///< Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 << 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 << 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 << 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 << 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 << 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 << 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager& getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString& slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString& slot);
-        void ready(rl::Item* item, const rl::CeGuiString& slot);
-        void dropItem(const rl::CeGuiString& slotName);
-    };
-
-    %feature("director") Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///< Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///< Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///< Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
-        static const std::string Creature::ALL_TALENTE = "alle Talente";
-        static const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
-        static const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
-        static const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
-        static const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
-        static const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
-        static const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
-        static const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
-        static const Creature::Wert Creature::WERT_GS = "GS";
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
-        static const Creature::Wert Creature::WERT_BE = "BE";
-        static const Creature::Wert Creature::WERT_RS = "RS";
-        static const Creature::Wert Creature::WERT_INI = "INI";
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
-        static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair<int,int> value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature("director") ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager& getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN
-        } MovementType;
-        
-        Creature *getCreature();
-        //bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = "");
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager& getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector<GameObject*>& getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3& pos);
-        void setOrientation(const Ogre::Quaternion& ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-

Copied: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig (from rev 4378, rl/trunk/engine/script/swig/RlRules.swig)

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -185,8 +185,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->_getDerivedPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->_getDerivedOrientation();
 
                 textSt += "\nPlayer Position [ "
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -118,7 +118,7 @@
         win->getCustomAttribute("WINDOW", &windowHnd);
 
         #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-            pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_EXCLUSIVE")));
+            pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_NONEXCLUSIVE")));
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
         #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX & defined DEBUG
 //            pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
@@ -591,6 +591,7 @@
 
     bool InputManager::keyPressed(const OIS::KeyEvent& evt)
     {
+		//return false;
         bool retval = false;
         if( WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_KEYBOARD_INPUT )
         {
@@ -628,12 +629,13 @@
                 
         }
 
-        return true;
-        //return retval;
+        //return true;
+        return retval;
     }
 
     bool InputManager::keyReleased(const OIS::KeyEvent& evt)
     {
+		//return false;
         bool retval = false;
         if( WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_KEYBOARD_INPUT )
         {
@@ -644,8 +646,8 @@
         if( !mControlStates.empty() )
             if( mControlStates.top()->keyReleased(evt, retval) )
                 retval = true;
-        return true;
-        //return false;
+        //return true;
+        return false;
     }
 
 }

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -448,7 +448,7 @@
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
+		Ogre::Vector3 rayStart = cameraActor->getWorldPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 

Copied: rl/branches/ogre16/rl/trunk/tools/material_updater.rb (from rev 4380, rl/trunk/tools/material_updater.rb)



From tanis at mail.berlios.de  Thu May 22 20:54:52 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 20:54:52 +0200
Subject: [Dsa-hl-svn] r4382 - in rl/branches/ogre16: . rl
Message-ID: <200805221854.m4MIsqjp006602@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 20:54:51 +0200 (Thu, 22 May 2008)
New Revision: 4382

Added:
   rl/branches/ogre16/trunk/
Removed:
   rl/branches/ogre16/rl/trunk/
Log:
Moved remotely

Copied: rl/branches/ogre16/trunk (from rev 4381, rl/branches/ogre16/rl/trunk)



From tanis at mail.berlios.de  Thu May 22 20:55:47 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 20:55:47 +0200
Subject: [Dsa-hl-svn] r4383 - rl/branches/ogre16
Message-ID: <200805221855.m4MItl6s006709@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 20:55:44 +0200 (Thu, 22 May 2008)
New Revision: 4383

Removed:
   rl/branches/ogre16/content/
   rl/branches/ogre16/dependencies/
   rl/branches/ogre16/experiments/
   rl/branches/ogre16/presentation/
   rl/branches/ogre16/rl/
   rl/branches/ogre16/tools/
Log:
Removed file/folder



From tanis at mail.berlios.de  Thu May 22 20:56:46 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 22 May 2008 20:56:46 +0200
Subject: [Dsa-hl-svn] r4384 - rl/branches/ogre16
Message-ID: <200805221856.m4MIukOb006797@sheep.berlios.de>

Author: tanis
Date: 2008-05-22 20:56:44 +0200 (Thu, 22 May 2008)
New Revision: 4384

Added:
   rl/branches/ogre16/rl/
Removed:
   rl/branches/ogre16/trunk/
Log:
Renamed remotely

Copied: rl/branches/ogre16/rl (from rev 4383, rl/branches/ogre16/trunk)



From blakharaz at mail.berlios.de  Sat May 31 11:10:03 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:10:03 +0200
Subject: [Dsa-hl-svn] r4385 - rl/trunk/engine/ui/src
Message-ID: <200805310910.m4V9A3pb004866@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:10:01 +0200 (Sat, 31 May 2008)
New Revision: 4385

Modified:
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
Log:
Remove listener on destruction


Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2008-05-22 18:56:44 UTC (rev 4384)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2008-05-31 09:10:01 UTC (rev 4385)
@@ -72,6 +72,7 @@
 
 CharacterSheetWindow::~CharacterSheetWindow()
 {
+    setCharacter(NULL);
 }
 
 void CharacterSheetWindow::setCharacter(Creature* creature)



From blakharaz at mail.berlios.de  Sat May 31 11:10:30 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:10:30 +0200
Subject: [Dsa-hl-svn] r4386 - rl/trunk/engine/ui/src
Message-ID: <200805310910.m4V9AUAe004888@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:10:29 +0200 (Sat, 31 May 2008)
New Revision: 4386

Modified:
   rl/trunk/engine/ui/src/UiSubsystem.cpp
Log:
Avoid null pointer


Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-05-31 09:10:01 UTC (rev 4385)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-05-31 09:10:29 UTC (rev 4386)
@@ -166,7 +166,10 @@
             if (mCharacter)
             {
                 ScriptWrapper::getSingleton().disowned( mCharacter );
-                mCharacter->getActor()->detach(SoundManager::getSingleton().getListenerActor());
+                if (mCharacter->getActor())
+                {
+                    mCharacter->getActor()->detach(SoundManager::getSingleton().getListenerActor());
+                }
                 mCharacter->setQueryFlags(mCharacter->getQueryFlags() & (~QUERYFLAG_PLAYER));
             }
 



From blakharaz at mail.berlios.de  Sat May 31 11:12:22 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:12:22 +0200
Subject: [Dsa-hl-svn] r4387 - in rl/trunk/engine: core/include core/src
	rules/include rules/src
Message-ID: <200805310912.m4V9CM34005081@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:12:17 +0200 (Sat, 31 May 2008)
New Revision: 4387

Modified:
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/Slot.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/Slot.cpp
Log:
Save current scene in gameobjects when they are in the scene or attached to gameobjects in the scene


Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2008-05-31 09:12:17 UTC (rev 4387)
@@ -111,6 +111,9 @@
 
     void setTimeFactor(const Ogre::Real& factor = 1.0F);
 
+    void _setCurrentScene(const CeGuiString& scene);
+    const CeGuiString& getCurrentScene() const;
+
 private:
     World* mWorld;
     RubyInterpreter* mRubyInterpreter;
@@ -118,6 +121,7 @@
     ContentModule* mActiveAdventureModule;
     Ogre::String mDefaultActiveModule;
     Ogre::RenderWindow* mRenderWindow;            //!< Render window for OGRE
+    CeGuiString mCurrentScene;
 
     RL_LONGLONG mClockStartTime;
 

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-31 09:12:17 UTC (rev 4387)
@@ -73,7 +73,8 @@
         mDebugVisualsManager(NULL),
         mJobScheduler(NULL),
         mRenderWindow(NULL),
-        mZoneManager(NULL)
+        mZoneManager(NULL),
+        mCurrentScene("")
     {
         initializeCoreSubsystem();
     }
@@ -578,4 +579,14 @@
         mSoundManager->unloadAllDrivers();
         LOG_MESSAGE(Logger::CORE, "Soundtreiber entladen");
     }
+
+    void CoreSubsystem::_setCurrentScene(const CeGuiString& scene)
+    {
+        mCurrentScene = scene;
+    }
+
+    const CeGuiString& CoreSubsystem::getCurrentScene() const
+    {
+        return mCurrentScene;
+    }
 }

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2008-05-31 09:12:17 UTC (rev 4387)
@@ -29,6 +29,7 @@
 
 namespace rl
 {
+    class Creature;
     class CreatureController;
 
     /// This class manages CreatureControllers, which provide an API for moving the creature

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/include/GameObject.h	2008-05-31 09:12:17 UTC (rev 4387)
@@ -52,6 +52,7 @@
         static const Ogre::String PROPERTY_OBJECT_ID;
         static const Ogre::String PROPERTY_INHERITS;
         static const Ogre::String PROPERTY_BASE_CLASS;
+        static const Ogre::String PROPERTY_SCENE; 
         static const Ogre::String PROPERTY_POSITION; 
         static const Ogre::String PROPERTY_ORIENTATION; 
         static const Ogre::String PROPERTY_NAME;
@@ -98,6 +99,9 @@
         void addAction(Action* action, int option = Action::ACT_NORMAL);
         void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
         void removeAction(Action* action);
+
+        void setScene(const CeGuiString& scene);
+        const CeGuiString& getScene() const;
     
         /*
          * sets the actor of this gameobject
@@ -214,8 +218,8 @@
 
         virtual void doPlaceIntoScene();
         virtual void doRemoveFromScene();
+        CeGuiString mScene;
 
-
     private:
         static int sNextGameObjectId;    
 

Modified: rl/trunk/engine/rules/include/Slot.h
===================================================================
--- rl/trunk/engine/rules/include/Slot.h	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/include/Slot.h	2008-05-31 09:12:17 UTC (rev 4387)
@@ -33,7 +33,7 @@
     // item-state etc, returns true, if succeeded to set item, false indicates to to nothing
     // subclasses MUST call this method when overriding
     virtual bool setItem(Item* item);
-    virtual void update() {} // this must only be called from creature::doPlaceIntoScene
+    virtual void update(); // this must only be called from creature::doPlaceIntoScene
     Item* getItem() const;
     bool isAllowed(const Item* item) const;
     bool isEmpty() const {return mItem == NULL;}

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/src/Container.cpp	2008-05-31 09:12:17 UTC (rev 4387)
@@ -158,6 +158,7 @@
             else
                 item->setOwner(this);
 			item->setState(GOS_IN_POSSESSION);
+            item->setScene(mScene);
 
 			return true;
 		}
@@ -178,6 +179,7 @@
             // this is the case, if the item is removed automatically
             // don't change this without looking at Item::setState
             item->removeOldState();
+            item->setScene("");
         }
         else
         {

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/src/Creature.cpp	2008-05-31 09:12:17 UTC (rev 4387)
@@ -1292,5 +1292,13 @@
     void Creature::doRemoveFromScene()
     {
         GameObject::doRemoveFromScene();
+
+        // check items in inventory
+        Inventory::SlotMap slots = mInventory->getAllSlots();
+        Inventory::SlotMap::iterator it = slots.begin();
+        for( ; it != slots.end(); it++ )
+        {
+            it->second->update();
+        }
     }
 }

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2008-05-31 09:12:17 UTC (rev 4387)
@@ -44,6 +44,7 @@
     const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid";
     const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass";
     const Ogre::String GameObject::PROPERTY_POSITION = "position";
+    const Ogre::String GameObject::PROPERTY_SCENE = "scene";
     const Ogre::String GameObject::PROPERTY_INHERITS = "inherits";
     const Ogre::String GameObject::PROPERTY_ORIENTATION = "orientation";
     const Ogre::String GameObject::PROPERTY_NAME = "name";
@@ -71,7 +72,8 @@
             mMass(0),
             mGeometryType(GT_NONE),
             mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
-            mState(GOS_LOADED)
+            mState(GOS_LOADED),
+            mScene("")
     {
         mEffectManager = new EffectManager(this);
 
@@ -163,6 +165,16 @@
         mSubmeshPreName = name;
     }
 
+    const CeGuiString& GameObject::getScene() const
+    {
+        return mScene;
+    }
+
+    void GameObject::setScene(const CeGuiString& scene)
+    {
+        mScene = scene;
+    }
+
     void GameObject::addAction(Action* action, int option)
     {
         if (action == NULL)
@@ -703,6 +715,7 @@
             {
                 actor->placeIntoScene(mPosition, mOrientation);
                 setActor(actor);
+                mScene = CoreSubsystem::getSingleton().getCurrentScene();
 
                 // this is done in setstate now
                 //GameObjectState tmpState = mState;
@@ -736,6 +749,7 @@
 
                 setActor(NULL);
                 actor->removeFromScene();
+                mScene = "";
             }
 
             // give the setstate function the possibility to reuse the actor

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2008-05-31 09:10:29 UTC (rev 4386)
+++ rl/trunk/engine/rules/src/Slot.cpp	2008-05-31 09:12:17 UTC (rev 4387)
@@ -96,7 +96,26 @@
         return true;
     }
 
+    void Slot::update()
+    {
+        if (isEmpty()) 
+        {
+            return;
+        }
 
+        if (mOwner->getState() == GOS_IN_SCENE
+            || mOwner->getState() == GOS_HELD
+            || mOwner->getState() == GOS_READY)
+        {
+            mItem->setScene(mOwner->getScene());
+        }
+        else 
+        {
+            mItem->setScene("");
+        }
+    }
+
+
     BoneSlot::BoneSlot(Creature* owner, const CeGuiString& name, int itemReadyMask, int itemHeldMask, const Ogre::String& bone)
         : Slot(owner, name, itemReadyMask, itemHeldMask), mBone(bone)
     {
@@ -128,6 +147,7 @@
 
     void BoneSlot::update()
     {
+        Slot::update();
         if( mItem && (mOwner->getState() == GOS_IN_SCENE
                 || mOwner->getState() == GOS_HELD
                 || mOwner->getState() == GOS_READY) )
@@ -208,6 +228,7 @@
 
     void SubmeshSlot::update()
     {
+        Slot::update();
 	    if (mOwner->getActor())
 	    {
 		    MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
@@ -309,6 +330,7 @@
 
     void MaterialSlot::update()
     {
+        Slot::update();
         if (mItem)
         {
             try



From blakharaz at mail.berlios.de  Sat May 31 11:13:33 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:13:33 +0200
Subject: [Dsa-hl-svn] r4388 - rl/trunk/engine/common/include
Message-ID: <200805310913.m4V9DXh3005330@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:13:32 +0200 (Sat, 31 May 2008)
New Revision: 4388

Modified:
   rl/trunk/engine/common/include/FixRubyHeaders.h
Log:
Remove warnings about Ruby's socket constants

Modified: rl/trunk/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/trunk/engine/common/include/FixRubyHeaders.h	2008-05-31 09:12:17 UTC (rev 4387)
+++ rl/trunk/engine/common/include/FixRubyHeaders.h	2008-05-31 09:13:32 UTC (rev 4388)
@@ -41,3 +41,41 @@
 #undef max
 #undef min
 
+#undef EWOULDBLOCK	
+#undef EINPROGRESS	
+#undef EALREADY	
+#undef ENOTSOCK	
+#undef EDESTADDRREQ	
+#undef EMSGSIZE	
+#undef EPROTOTYPE	
+#undef ENOPROTOOPT	
+#undef EPROTONOSUPPORT	
+#undef ESOCKTNOSUPPORT	
+#undef EOPNOTSUPP	
+#undef EPFNOSUPPORT	
+#undef EAFNOSUPPORT	
+#undef EADDRINUSE	
+#undef EADDRNOTAVAIL	
+#undef ENETDOWN	
+#undef ENETUNREACH	
+#undef ENETRESET	
+#undef ECONNABORTED	
+#undef ECONNRESET	
+#undef ENOBUFS		
+#undef EISCONN		
+#undef ENOTCONN	
+#undef ESHUTDOWN	
+#undef ETOOMANYREFS	
+#undef ETIMEDOUT	
+#undef ECONNREFUSED	
+#undef ELOOP		
+/*#undef ENAMETOOLONG	*/
+#undef EHOSTDOWN	
+#undef EHOSTUNREACH	
+/*#undef ENOTEMPTY	*/
+#undef EPROCLIM	
+#undef EUSERS		
+#undef EDQUOT		
+#undef ESTALE		
+#undef EREMOTE		
+



From blakharaz at mail.berlios.de  Sat May 31 11:17:50 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:17:50 +0200
Subject: [Dsa-hl-svn] r4389 - in modules: combattest/dsa common/dsa
Message-ID: <200805310917.m4V9HoVO005522@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:17:47 +0200 (Sat, 31 May 2008)
New Revision: 4389

Added:
   modules/common/dsa/animals.gof
   modules/common/dsa/weapons.gof
Removed:
   modules/combattest/dsa/gameobjectdefinitions.gof
Log:
Move wolf and short sword to common module

Deleted: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2008-05-31 09:13:32 UTC (rev 4388)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2008-05-31 09:17:47 UTC (rev 4389)
@@ -1,122 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
-<GameObjectDefinitions>
-  <gameobjectclass classid="Wolf" baseclass="Creature">
-    <property name="classid" type="STRING" data="Wolf"/>
-    <property name="baseclass" type="STRING" data="Creature"/>
-    <property name="name" type="STRING" data="Wolf"/>
-    <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
-    <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
-    <property name="mass" type="REAL" data="30"/>
-    <property name="geometrytype" type="STRING" data="sphere"/>
-	<property name="eigenschaften" type="MAP">
-		<property name="MU" type="INT" data="12"/>
-		<property name="KL" type="INT" data="8"/>
-		<property name="IN" type="INT" data="9"/>
-		<property name="CH" type="INT" data="10"/>
-		<property name="FF" type="INT" data="11"/>
-		<property name="GE" type="INT" data="12"/>
-		<property name="KO" type="INT" data="13"/>
-		<property name="KK" type="INT" data="14"/>
-	</property>
-	<property name="kampftechniken" type="MAP">
-		<property name="Raufen" type="INTPAIR" data="9,2"/>
-	</property>
-	<property name="talente" type="MAP">
-		<property name="Athletik" type="INT" data="3"/>
-	</property>
-	<property name="inventory" type="MAP">
-		<property name="slots" type="ARRAY">
-			<property type="MAP"> 
-				<property name="name" type="STRING" data="Snout"/>
-				<property name="type" type="STRING" data="default"/>
-				<property name="readies" type="INT" data="1"/> 
-			</property>
-		</property>
-	</property>
-	<property name="ai" type="MAP">
-		<property name="behaviours" type="ARRAY">
-			<property type="STRING" data="DefaultWanderBehaviour"/>
-			<property type="STRING" data="AvoidObstaclesBehaviour"/>
-		</property>
-	</property>
-	<property name="animations" type="MAP">
-		<property name="stehen" type="STRING" data="idle"/>
-		<property name="stehen_rechts" type="STRING" data="gehen"/>
-		<property name="stehen_links" type="STRING" data="gehen"/>
-		<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
-		<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
-		<property name="gehen" type="STRING" data="gehen"/>
-		<property name="gehen_rueckwaerts" type="STRING" data="gehen"/>
-		<property name="joggen_rueckwaerts" type="STRING" data="gehen"/>
-		<property name="joggen" type="STRING" data="rennen"/>
-		<property name="laufen" type="STRING" data="rennen"/>
-		<property name="rennen" type="STRING" data="rennen"/>
-		<property name="stehen_zu_schleichen" type="STRING" data="idle"/>
-		<property name="schleichen_zu_stehen" type="STRING" data="idle"/>
-		<property name="schleichen" type="STRING" data="idle"/>
-		<property name="schleichen_vorwaerts" type="STRING" data="gehen"/>
-		<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
-		<property name="hochsprung" type="STRING" data="idle_sprung"/>
-		<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
-		<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
-		<property name="weitsprung" type="STRING" data="rennen_sprung"/>
-		<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
-		<property name="fallen" type="STRING" data="idle"/>
-		<!-- Kampf -->
-		<property name="kampf_attacke_pariert" type="STRING" data="attacke"/>
-		<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="attacke"/>
-		<property name="kampf_attacke_treffer" type="STRING" data="attacke"/>
-		<property name="kampf_attacke_misserfolg" type="STRING" data="attacke"/>
-		<property name="kampf_parade_erfolg" type="STRING" data="ausweichen"/>
-		<property name="kampf_parade_misserfolg" type="STRING" data="ausweichen"/>
-		<property name="kampf_getroffen" type="STRING" data="getroffen"/>
-	</property>
-	<property name="animationspeeds" type="MAP">
-		<property name="gehen" type="REAL" data="0.2"/>
-		<property name="joggen" type="REAL" data="0.2"/>
-		<property name="laufen" type="REAL" data="0.2"/>
-		<property name="rennen" type="REAL" data="0.2"/>
-	</property>
-	<property name="kampfaktionen" type="ARRAY">
-		<property type="STRING" data="Attacke"/>
-		<property type="STRING" data="Ausweichen"/>
-		<property type="STRING" data="Bewegen"/>
-		<property type="STRING" data="Folgen"/>
-	</property>
-  </gameobjectclass>
-  
-	<gameobjectclass classid="Kurzschwert" baseclass="Weapon">
-		<property name="name" type="STRING" data="Kurzschwert"/>
-		<property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
-		<property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
-		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
-		<property name="mass" type="REAL" data="1.0"/>
-		<property name="size" type="INTPAIR" data="2,4"/>
-		<property name="geometrytype" type="STRING" data="box"/>
-		<property name="kampftechnik" type="STRING" data="Schwerter"/>
-		<!-- INTTRIPLE xyz for TP: x*d6 + y*d20 + z -->
-		<property name="TP" type="INTTRIPLE" data="1,0,2"/>
-		<property name="TPKK" type="INTPAIR" data="11,5"/>
-		<property name="BF" type="INT" data="1"/>
-		<property name="INI" type="INT" data="0"/>
-		<property name="WM" type="INTPAIR" data="0,-1"/>
-		<property name="DK" type="STRING" data="HN"/>
-	</gameobjectclass>
-	
-	<gameobjectclass classid="Wolfsschnauze" baseclass="Weapon">
-		<property name="name" type="STRING" data="Wolfsschnauze"/>
-		<property name="description" type="STRING" data="Die Z?hne eines Wolfes - scharf und dreckig"/>
-		<property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
-		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
-		<property name="mass" type="REAL" data="1.0"/>
-		<property name="size" type="INTPAIR" data="2,4"/>
-		<property name="kampftechnik" type="STRING" data="Raufen"/>
-		<!-- INTTRIPLE xyz for TP: x*d6 + y*d20 + z -->
-		<property name="TP" type="INTTRIPLE" data="1,0,0"/>
-		<property name="TPKK" type="INTPAIR" data="11,5"/>
-		<property name="BF" type="INT" data="0"/>
-		<property name="INI" type="INT" data="2"/>
-		<property name="WM" type="INTPAIR" data="0,-5"/>
-		<property name="DK" type="STRING" data="HN"/>
-	</gameobjectclass>
-</GameObjectDefinitions>

Added: modules/common/dsa/animals.gof
===================================================================
--- modules/common/dsa/animals.gof	2008-05-31 09:13:32 UTC (rev 4388)
+++ modules/common/dsa/animals.gof	2008-05-31 09:17:47 UTC (rev 4389)
@@ -0,0 +1,104 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+  <gameobjectclass classid="Wolf" baseclass="Creature">
+    <property name="classid" type="STRING" data="Wolf"/>
+    <property name="baseclass" type="STRING" data="Creature"/>
+    <property name="name" type="STRING" data="Wolf"/>
+    <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
+    <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
+    <property name="mass" type="REAL" data="30"/>
+    <property name="geometrytype" type="STRING" data="sphere"/>
+	<property name="eigenschaften" type="MAP">
+		<property name="MU" type="INT" data="12"/>
+		<property name="KL" type="INT" data="8"/>
+		<property name="IN" type="INT" data="9"/>
+		<property name="CH" type="INT" data="10"/>
+		<property name="FF" type="INT" data="11"/>
+		<property name="GE" type="INT" data="12"/>
+		<property name="KO" type="INT" data="13"/>
+		<property name="KK" type="INT" data="14"/>
+	</property>
+	<property name="kampftechniken" type="MAP">
+		<property name="Raufen" type="INTPAIR" data="9,2"/>
+	</property>
+	<property name="talente" type="MAP">
+		<property name="Athletik" type="INT" data="3"/>
+	</property>
+	<property name="inventory" type="MAP">
+		<property name="slots" type="ARRAY">
+			<property type="MAP"> 
+				<property name="name" type="STRING" data="Snout"/>
+				<property name="type" type="STRING" data="default"/>
+				<property name="readies" type="INT" data="1"/> 
+			</property>
+		</property>
+	</property>
+	<property name="ai" type="MAP">
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultWanderBehaviour"/>
+			<property type="STRING" data="AvoidObstaclesBehaviour"/>
+		</property>
+	</property>
+	<property name="animations" type="MAP">
+		<property name="stehen" type="STRING" data="idle"/>
+		<property name="stehen_rechts" type="STRING" data="gehen"/>
+		<property name="stehen_links" type="STRING" data="gehen"/>
+		<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
+		<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
+		<property name="gehen" type="STRING" data="gehen"/>
+		<property name="gehen_rueckwaerts" type="STRING" data="gehen"/>
+		<property name="joggen_rueckwaerts" type="STRING" data="gehen"/>
+		<property name="joggen" type="STRING" data="rennen"/>
+		<property name="laufen" type="STRING" data="rennen"/>
+		<property name="rennen" type="STRING" data="rennen"/>
+		<property name="stehen_zu_schleichen" type="STRING" data="idle"/>
+		<property name="schleichen_zu_stehen" type="STRING" data="idle"/>
+		<property name="schleichen" type="STRING" data="idle"/>
+		<property name="schleichen_vorwaerts" type="STRING" data="gehen"/>
+		<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
+		<property name="hochsprung" type="STRING" data="idle_sprung"/>
+		<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
+		<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
+		<property name="weitsprung" type="STRING" data="rennen_sprung"/>
+		<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
+		<property name="fallen" type="STRING" data="idle"/>
+		<!-- Kampf -->
+		<property name="kampf_attacke_pariert" type="STRING" data="attacke"/>
+		<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="attacke"/>
+		<property name="kampf_attacke_treffer" type="STRING" data="attacke"/>
+		<property name="kampf_attacke_misserfolg" type="STRING" data="attacke"/>
+		<property name="kampf_parade_erfolg" type="STRING" data="ausweichen"/>
+		<property name="kampf_parade_misserfolg" type="STRING" data="ausweichen"/>
+		<property name="kampf_getroffen" type="STRING" data="getroffen"/>
+	</property>
+	<property name="animationspeeds" type="MAP">
+		<property name="gehen" type="REAL" data="0.2"/>
+		<property name="joggen" type="REAL" data="0.2"/>
+		<property name="laufen" type="REAL" data="0.2"/>
+		<property name="rennen" type="REAL" data="0.2"/>
+	</property>
+	<property name="kampfaktionen" type="ARRAY">
+		<property type="STRING" data="Attacke"/>
+		<property type="STRING" data="Ausweichen"/>
+		<property type="STRING" data="Bewegen"/>
+		<property type="STRING" data="Folgen"/>
+	</property>
+  </gameobjectclass>
+
+  <gameobjectclass classid="Wolfsschnauze" baseclass="Weapon">
+		<property name="name" type="STRING" data="Wolfsschnauze"/>
+		<property name="description" type="STRING" data="Die Z?hne eines Wolfes - scharf und dreckig"/>
+		<property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
+		<property name="mass" type="REAL" data="1.0"/>
+		<property name="size" type="INTPAIR" data="2,4"/>
+		<property name="kampftechnik" type="STRING" data="Raufen"/>
+		<!-- INTTRIPLE xyz for TP: x*d6 + y*d20 + z -->
+		<property name="TP" type="INTTRIPLE" data="1,0,0"/>
+		<property name="TPKK" type="INTPAIR" data="11,5"/>
+		<property name="BF" type="INT" data="0"/>
+		<property name="INI" type="INT" data="2"/>
+		<property name="WM" type="INTPAIR" data="0,-5"/>
+		<property name="DK" type="STRING" data="HN"/>
+	</gameobjectclass>
+</GameObjectDefinitions>

Added: modules/common/dsa/weapons.gof
===================================================================
--- modules/common/dsa/weapons.gof	2008-05-31 09:13:32 UTC (rev 4388)
+++ modules/common/dsa/weapons.gof	2008-05-31 09:17:47 UTC (rev 4389)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+	<gameobjectclass classid="Kurzschwert" baseclass="Weapon">
+		<property name="name" type="STRING" data="Kurzschwert"/>
+		<property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
+		<property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+		<property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
+		<property name="mass" type="REAL" data="1.0"/>
+		<property name="size" type="INTPAIR" data="2,4"/>
+		<property name="geometrytype" type="STRING" data="box"/>
+		<property name="kampftechnik" type="STRING" data="Schwerter"/>
+		<!-- INTTRIPLE xyz for TP: x*d6 + y*d20 + z -->
+		<property name="TP" type="INTTRIPLE" data="1,0,2"/>
+		<property name="TPKK" type="INTPAIR" data="11,5"/>
+		<property name="BF" type="INT" data="1"/>
+		<property name="INI" type="INT" data="0"/>
+		<property name="WM" type="INTPAIR" data="0,-1"/>
+		<property name="DK" type="STRING" data="HN"/>
+	</gameobjectclass>
+</GameObjectDefinitions>



From blakharaz at mail.berlios.de  Sat May 31 11:21:43 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:21:43 +0200
Subject: [Dsa-hl-svn] r4390 - modules/persistenztest/maps
	modules/persistenztest/scripts
	modules/persistenztest/scripts/maps rl/trunk/engine/script
	rl/trunk/engine/script/include rl/trunk/engine/script/src
	rl/trunk/engine/script/swig
Message-ID: <200805310921.m4V9Lh4p005702@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:21:36 +0200 (Sat, 31 May 2008)
New Revision: 4390

Added:
   modules/persistenztest/maps/map01.rlscene
   modules/persistenztest/maps/map02.rlscene
   rl/trunk/engine/script/include/Scene.h
   rl/trunk/engine/script/include/SceneLoader.h
   rl/trunk/engine/script/include/SceneManager.h
   rl/trunk/engine/script/src/Scene.cpp
   rl/trunk/engine/script/src/SceneLoader.cpp
   rl/trunk/engine/script/src/SceneManager.cpp
Modified:
   modules/persistenztest/scripts/MapChange.rb
   modules/persistenztest/scripts/maps/map01.rb
   modules/persistenztest/scripts/maps/map02.rb
   modules/persistenztest/scripts/maps/setchar.rb
   modules/persistenztest/scripts/moduleconfig.rb
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/include/Makefile.am
   rl/trunk/engine/script/include/MapLoader.h
   rl/trunk/engine/script/include/ScriptSubsystem.h
   rl/trunk/engine/script/include/stdinc.h
   rl/trunk/engine/script/src/Makefile.am
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ScriptSubsystem.cpp
   rl/trunk/engine/script/swig/RlScript.head.swig
   rl/trunk/engine/script/swig/RlScript.swig
Log:
Added Scene and SceneManager and tests for scene loading and change in module persistenztest

Added: modules/persistenztest/maps/map01.rlscene
===================================================================
--- modules/persistenztest/maps/map01.rlscene	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/maps/map01.rlscene	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,4 @@
+<scene name="scene01">
+	<map file="persistenztest01.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Added: modules/persistenztest/maps/map02.rlscene
===================================================================
--- modules/persistenztest/maps/map02.rlscene	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/maps/map02.rlscene	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,4 @@
+<scene name="scene02">
+	<map file="persistenztest02.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Modified: modules/persistenztest/scripts/MapChange.rb
===================================================================
--- modules/persistenztest/scripts/MapChange.rb	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/scripts/MapChange.rb	2008-05-31 09:21:36 UTC (rev 4390)
@@ -1,21 +1,22 @@
 require "embed.rb"
 require "areahelper.rb"
 
-def changeMap(mapLoader, mapNames)
-	characterId = $UI.getActiveCharacter().getId()
-	CreatureControllerManager.getSingleton().detachController($UI.getActiveCharacter())
-	$UI.setActiveCharacter(nil)
+def changeScene(scene)
+#	characterId = $UI.getActiveCharacter().getId()
+#	CreatureControllerManager.getSingleton().detachController($UI.getActiveCharacter())
+#	$UI.setActiveCharacter(nil)
 	#$SCRIPT.logError(mapNames.type().to_s)
-	mapLoader.requestSceneChange(mapNames)
+#	mapLoader.requestSceneChange(mapNames)
+	SceneManager::getSingleton().loadScene(scene, true);
 end
 
-class MapChangeTrigger < Trigger
+class SceneChangeTrigger < Trigger
   def initialize(classname, name)
     super(classname, name, false);
   end
 
   def activate()
-	changeMap($MAPLOADER, @maps)
+	changeScene(@scene)
     return false
   end
   def deactivate()
@@ -27,8 +28,8 @@
   def getProperty(name)
 	super(name)
   end
-  def setMaps(maps)
-	@maps = maps
+  def setScene(scene)
+	@scene = scene
   end
   def getAllProperties()
     ps = super();
@@ -36,17 +37,16 @@
   end
 end
 
-def CreateMapChangeTrigger(name, pos, orientation, size, maps)
-	unless ( ZoneManager.getSingleton().getZone("MapChangeZone_" + name) == nil )
-		raise ArgumentError, "A MapChangeTrigger with name " + name + " already exists!", caller
+def CreateSceneChangeTrigger(name, pos, orientation, size, scene)
+	unless ( ZoneManager.getSingleton().getZone("SceneChangeZone_" + name) == nil )
+		raise ArgumentError, "A SceneChangeTrigger with name " + name + " already exists!", caller
 	end
-	trigger = $SCRIPT.getTriggerFactory().createTrigger("MapChangeTrigger", "MapChangeTrigger" + name)
-	trigger.setMaps(maps)
-	zone = ZoneManager.getSingleton().createZone("MapChangeZone_" + name, true)
+	trigger = $SCRIPT.getTriggerFactory().createTrigger("SceneChangeTrigger", "SceneChangeTrigger" + name)
+	trigger.setScene(scene)
+	zone = ZoneManager.getSingleton().createZone("SceneChangeZone_" + name, true)
 	ZoneManager.getSingleton().addAreaToZone(
-    "MapChangeZone_" + name, 
-    size, PhysicsManager::GT_BOX, pos, [0,0,0], orientation, 0.2, RlScript::QUERYFLAG_PLAYER);
-	trigger.setProperty("zone","MapChangeZone_" + name)
+	    "SceneChangeZone_" + name, 
+	    size, PhysicsManager::GT_BOX, pos, [0,0,0], orientation, 0.2, RlScript::QUERYFLAG_PLAYER);
+	trigger.setProperty("zone","SceneChangeZone_" + name)
 	zone.addTrigger(trigger)
-	zone.getTriggers().methods()
 end
\ No newline at end of file

Modified: modules/persistenztest/scripts/maps/map01.rb
===================================================================
--- modules/persistenztest/scripts/maps/map01.rb	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/scripts/maps/map01.rb	2008-05-31 09:21:36 UTC (rev 4390)
@@ -5,6 +5,6 @@
 
 base.placeIntoScene([8,0,8])
 
-puts CreateMapChangeTrigger("map1", [8,0,8], [0,0,0,1], [2, 2, 2], ["persistenztest02.rlmap.xml","hero.rlmap.xml"])
+CreateSceneChangeTrigger("map1", [8,0,8], [0,0,0,1], [2, 2, 2], "scene02")
 
 #puts 'Map 1 init script wurde ausgef?hrt!'

Modified: modules/persistenztest/scripts/maps/map02.rb
===================================================================
--- modules/persistenztest/scripts/maps/map02.rb	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/scripts/maps/map02.rb	2008-05-31 09:21:36 UTC (rev 4390)
@@ -4,6 +4,6 @@
 
 base.placeIntoScene([8,0,8])
 
-puts CreateMapChangeTrigger("map2", [8,0,-8], [0,0,0,1], [2, 2, 2], ["persistenztest01.rlmap.xml","hero.rlmap.xml"])
+CreateSceneChangeTrigger("map2", [8,0,-8], [0,0,0,1], [2, 2, 2], "scene01")
 
 puts 'Map 2 ausgef?hrt'
\ No newline at end of file

Modified: modules/persistenztest/scripts/maps/setchar.rb
===================================================================
--- modules/persistenztest/scripts/maps/setchar.rb	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/scripts/maps/setchar.rb	2008-05-31 09:21:36 UTC (rev 4390)
@@ -5,10 +5,16 @@
 require 'MapChange.rb'
 
 $SCRIPT.log("Prepare hero for being the active character")
-$hero = $GOM.getGameObject(10);
-PlayerSettings.preparePlayer($hero)
+hero = $GOM.getGameObject(10);
+PlayerSettings.preparePlayer(hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+$UI.setActiveCharacter(hero)
 
-$SCRIPT.log("Hero ready")
\ No newline at end of file
+$SCRIPT.log("Hero ready")
+itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
+hero.getInventory().hold(itemToAdd, "Trousers");
+itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
+hero.getInventory().hold(itemToAdd, "Clothes");
+itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
+hero.getInventory().hold(itemToAdd, "Boots");

Modified: modules/persistenztest/scripts/moduleconfig.rb
===================================================================
--- modules/persistenztest/scripts/moduleconfig.rb	2008-05-31 09:17:47 UTC (rev 4389)
+++ modules/persistenztest/scripts/moduleconfig.rb	2008-05-31 09:21:36 UTC (rev 4390)
@@ -24,11 +24,9 @@
     def start()
         require "mckhero.rb"
         require "hero.rb"
-		$MAPLOADER = MapLoader.new("persistenztest")
-		$MAPLOADER.setDefaultMaps(["persistenztest01.rlmap.xml","hero.rlmap.xml"])
-		registerContentLoader($MAPLOADER)
-		loadContent();
-		load "persistenztest.rb"
+		require "MapChange.rb"
+		require "Clothing.rb"
+		SceneManager::getSingleton().loadScene("scene01", false);
     end
 end
 

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2008-05-31 09:21:36 UTC (rev 4390)
@@ -355,6 +355,18 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\Scene.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SceneLoader.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SceneManager.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\SoundNodeProcessor.cpp"
 					>
 				</File>
@@ -450,6 +462,18 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\Scene.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SceneLoader.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SceneManager.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\SoundNodeProcessor.h"
 					>
 				</File>

Modified: rl/trunk/engine/script/include/Makefile.am
===================================================================
--- rl/trunk/engine/script/include/Makefile.am	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/Makefile.am	2008-05-31 09:21:36 UTC (rev 4390)
@@ -7,10 +7,13 @@
 	MapLoader.h \
 	ParticleSystemNodeProcessor.h \
 	TriggerFactory.h \
-	SoundNodeProcessor.h \
+	Scene.h \
+	SceneLoader.h \
+	SceneManager.h \
 	ScriptObjectMarker.h \
 	ScriptPrerequisites.h \
 	ScriptSubsystem.h \
+	SoundNodeProcessor.h \
 	WaypointProcessor.h \
 	UnifiedFactory.h \
 	ZoneProcessor.h

Modified: rl/trunk/engine/script/include/MapLoader.h
===================================================================
--- rl/trunk/engine/script/include/MapLoader.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/MapLoader.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -38,6 +38,7 @@
     public:
         static const CeGuiString PROPERTY_ACTIVEMAPS;
 
+        MapLoader();
         MapLoader(const Ogre::String& resourceGroup);
         ~MapLoader();
 
@@ -56,9 +57,9 @@
 
         const CeGuiString getClassName() const;
 
-        const Property getProperty(const CeGuiString& key) const;
-        void setProperty(const CeGuiString& key, const Property& value);
-
+        const Property getProperty(const CeGuiString& key) const;
+        void setProperty(const CeGuiString& key, const Property& value);
+
         PropertyKeys getAllPropertyKeys() const;
     private:
         std::list<AbstractMapNodeProcessor*> mNodeProcessors;
@@ -76,7 +77,8 @@
         void processSceneNodes(XERCES_CPP_NAMESPACE::DOMElement* nodesElem, bool loadGameObjects);
         void setLoadingPercentage(Ogre::Real percentage, const Ogre::String& text = "");
         bool changeScene(Ogre::StringVector mapsresources);
-
+        void initialize(const Ogre::String& resourceGroup);
+    
         MessagePump::ScopedConnection RequestedSceneChangeConnection;
     };
 

Added: rl/trunk/engine/script/include/Scene.h
===================================================================
--- rl/trunk/engine/script/include/Scene.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/Scene.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RlScene_H__
+#define __RlScene_H__
+
+#include "ScriptPrerequisites.h"
+
+#include <vector>
+
+#include "Properties.h"
+
+namespace rl {
+
+    class Scene : public PropertyHolder
+    {
+    public:
+        static const Ogre::String PROPERTY_GAMEOBJECTS;
+
+        Scene(const CeGuiString& name);
+        ~Scene();
+
+        void addMap(const Ogre::String& mapfile);
+        void load(bool loadGameObjects);
+        const CeGuiString& getName() const;
+
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+    private:
+        CeGuiString mName;
+        std::vector<Ogre::String> mMaps;
+    };
+
+}
+
+#endif // __RlScene_H__

Added: rl/trunk/engine/script/include/SceneLoader.h
===================================================================
--- rl/trunk/engine/script/include/SceneLoader.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/SceneLoader.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __SceneLoader_H__
+#define __SceneLoader_H__
+
+#include "ScriptPrerequisites.h"
+
+#include "XmlProcessor.h"
+
+namespace rl
+{
+    class Scene;
+
+    class SceneLoader : protected XmlProcessor
+    {
+    public:
+        Scene* loadScene(Ogre::DataStreamPtr& data);
+    };
+}
+
+#endif // __SceneLoader_H__
\ No newline at end of file

Added: rl/trunk/engine/script/include/SceneManager.h
===================================================================
--- rl/trunk/engine/script/include/SceneManager.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/SceneManager.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RlSceneManager_H__
+#define __RlSceneManager_H__
+
+#include "ScriptPrerequisites.h"
+
+#include "Properties.h"
+
+namespace rl 
+{
+
+    class Scene;
+
+    class _RlScriptExport SceneManager 
+        : public Ogre::Singleton<SceneManager>, public Ogre::ScriptLoader//, public PropertyHolder
+    {
+    public:
+        SceneManager();
+        ~SceneManager();
+
+        void addScene(Scene* scene);
+        void loadScene(const CeGuiString& name, bool saveCurrent = true);
+
+        const Ogre::StringVector& getScriptPatterns() const;
+        void parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup);
+        Ogre::Real getLoadingOrder() const;
+
+        /*virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;*/
+
+    private:
+        std::map<CeGuiString, Scene*> mScenes;
+        Ogre::StringVector mScriptPatterns;
+        Scene* mCurrentScene;
+        std::map<Scene*, PropertyRecordPtr> mSceneStates;
+    };
+
+}
+
+#endif // __RlSceneManager_H__

Modified: rl/trunk/engine/script/include/ScriptSubsystem.h
===================================================================
--- rl/trunk/engine/script/include/ScriptSubsystem.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/ScriptSubsystem.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -21,8 +21,8 @@
 
 namespace rl 
 {
+    class ScriptObjectMarker;
 	class TriggerFactory;
-    class ScriptObjectMarker;
 
     class _RlScriptExport ScriptSubsystem : public Ogre::Singleton<ScriptSubsystem>
     {

Modified: rl/trunk/engine/script/include/stdinc.h
===================================================================
--- rl/trunk/engine/script/include/stdinc.h	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/include/stdinc.h	2008-05-31 09:21:36 UTC (rev 4390)
@@ -52,7 +52,7 @@
 
 #include <OgreNewt.h>
 
-#include <CeGuiString.h>
+#include <CEGUIString.h>
 #include <CEGUILogger.h>
 
 #include <boost/filesystem/operations.hpp>

Modified: rl/trunk/engine/script/src/Makefile.am
===================================================================
--- rl/trunk/engine/script/src/Makefile.am	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/Makefile.am	2008-05-31 09:21:36 UTC (rev 4390)
@@ -20,6 +20,9 @@
 	LightNodeProcessor.cpp \
 	MapLoader.cpp \
 	ParticleSystemNodeProcessor.cpp \
+	Scene.cpp \
+	SceneLoader.cpp \
+	SceneManager.cpp \
 	ScriptSubsystem.cpp \
 	ScriptObjectMarker.cpp \
 	SoundNodeProcessor.cpp \

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2008-05-31 09:21:36 UTC (rev 4390)
@@ -48,20 +48,22 @@
 
     const CeGuiString MapLoader::PROPERTY_ACTIVEMAPS = "activemaps";
 
+    MapLoader::MapLoader()
+        : mRootSceneNode(NULL),
+          mResourceGroup(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()),
+          mPercentageWindow(NULL),
+          ContentLoader(mResourceGroup)
+    {
+        initialize(mResourceGroup);
+    }
+
     MapLoader::MapLoader(const Ogre::String& resourceGroup)
         : mRootSceneNode(NULL),
           mResourceGroup(resourceGroup),
           mPercentageWindow(NULL),
           ContentLoader(resourceGroup)
     {
-        mNodeProcessors.push_back(new EntityNodeProcessor(resourceGroup));
-        mNodeProcessors.push_back(new GameObjectNodeProcessor());
-        mNodeProcessors.push_back(new SoundNodeProcessor());
-        mNodeProcessors.push_back(new LightNodeProcessor());
-		mNodeProcessors.push_back(new ParticleSystemNodeProcessor());
-
-        RequestedSceneChangeConnection = MessagePump::getSingleton().addMessageHandler<MessageType_SceneChangeRequested>(
-            boost::bind(&MapLoader::changeScene, this, _1));
+        initialize(resourceGroup);
     }
 
     MapLoader::~MapLoader()
@@ -74,6 +76,18 @@
         delete mPercentageWindow;
     }
 
+    void MapLoader::initialize(const Ogre::String& resourceGroup)
+    {
+        mNodeProcessors.push_back(new EntityNodeProcessor(resourceGroup));
+        mNodeProcessors.push_back(new GameObjectNodeProcessor());
+        mNodeProcessors.push_back(new SoundNodeProcessor());
+        mNodeProcessors.push_back(new LightNodeProcessor());
+		mNodeProcessors.push_back(new ParticleSystemNodeProcessor());
+
+        RequestedSceneChangeConnection = MessagePump::getSingleton().addMessageHandler<MessageType_SceneChangeRequested>(
+            boost::bind(&MapLoader::changeScene, this, _1));
+    }
+
     void MapLoader::loadContent()
     {
         if(mLoadedMaps.empty()) // No maps defined to load -> no savegame
@@ -204,35 +218,35 @@
         return "MapLoader";
     }
 
-    const Property MapLoader::getProperty(const CeGuiString& key) const
-    {
-        if(PROPERTY_ACTIVEMAPS == key)
-        {
-            PropertyArray vec;
-            for(Ogre::StringVector::const_iterator it = mLoadedMaps.begin(); it != mLoadedMaps.end(); ++it)
-            {
-                vec.push_back(Property(*it));
-            }
-            return Property(vec);
-        }
-        return ContentLoader::getProperty(key);
-    }
-    
-    void MapLoader::setProperty(const CeGuiString& key, const Property& value)
-    {
-        if(PROPERTY_ACTIVEMAPS == key)
-        {
-            mLoadedMaps.clear();
-            PropertyArray vec(value.toArray());
-            for(PropertyArray::const_iterator it = vec.begin(); it != vec.end(); ++it)
-            {
-                mLoadedMaps.push_back(it->toString().c_str());
-            }
-        }
-        else
-            ContentLoader::setProperty(key,value);
-    }
-
+    const Property MapLoader::getProperty(const CeGuiString& key) const
+    {
+        if(PROPERTY_ACTIVEMAPS == key)
+        {
+            PropertyArray vec;
+            for(Ogre::StringVector::const_iterator it = mLoadedMaps.begin(); it != mLoadedMaps.end(); ++it)
+            {
+                vec.push_back(Property(*it));
+            }
+            return Property(vec);
+        }
+        return ContentLoader::getProperty(key);
+    }
+    
+    void MapLoader::setProperty(const CeGuiString& key, const Property& value)
+    {
+        if(PROPERTY_ACTIVEMAPS == key)
+        {
+            mLoadedMaps.clear();
+            PropertyArray vec(value.toArray());
+            for(PropertyArray::const_iterator it = vec.begin(); it != vec.end(); ++it)
+            {
+                mLoadedMaps.push_back(it->toString().c_str());
+            }
+        }
+        else
+            ContentLoader::setProperty(key,value);
+    }
+
     PropertyKeys MapLoader::getAllPropertyKeys() const
     {
         PropertyKeys keys = ContentLoader::getAllPropertyKeys();

Added: rl/trunk/engine/script/src/Scene.cpp
===================================================================
--- rl/trunk/engine/script/src/Scene.cpp	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/Scene.cpp	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,123 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h" //precompiled header
+
+#include "Scene.h"
+
+#include "CoreSubsystem.h"
+#include "GameObject.h"
+#include "GameObjectManager.h"
+#include "MapLoader.h"
+#include "World.h"
+
+namespace rl 
+{
+
+const Ogre::String Scene::PROPERTY_GAMEOBJECTS = "gameobjects";
+
+Scene::Scene(const CeGuiString& name)
+: mName(name)
+{
+}
+
+Scene::~Scene() 
+{
+}
+
+void Scene::addMap(const Ogre::String &mapfile)
+{
+    mMaps.push_back(mapfile);
+}
+
+void Scene::load(bool loadGameObjects)
+{
+    CoreSubsystem::getSingleton().getWorld()->clearScene();
+    MapLoader* loader = new MapLoader();
+    loader->loadScene(mMaps, loadGameObjects);
+}
+
+const CeGuiString& Scene::getName() const
+{
+    return mName;
+}
+
+const Property Scene::getProperty(const CeGuiString& key) const
+{
+    Property prop;
+
+    if (key == PROPERTY_GAMEOBJECTS)
+    {
+        PropertyArray goProps;
+
+        std::list<GameObject*> golist = GameObjectManager::getSingleton().getAllGameObjects();
+        std::list<GameObject*>::iterator end = golist.end();
+        for (std::list<GameObject*>::iterator it = golist.begin(); it != end; ++it)
+        {
+            GameObject* cur = *it;
+            if (cur->getState() == GOS_LOADED || cur->getState() == GOS_IN_SCENE)
+            {
+                goProps.push_back(cur->getAllProperties()->toPropertyMap());
+            }
+        }
+
+        prop = goProps;
+    }
+    else
+    {
+        Throw(IllegalArgumentException, "Property '" + key + "' is no property of a scene.");
+    }
+
+    return prop;
+}
+
+void Scene::setProperty(const CeGuiString& key, const Property& value)
+{
+    try 
+    {
+        if (key == PROPERTY_GAMEOBJECTS)
+        {
+            PropertyArray goProps = value.toArray();
+
+            for (PropertyArray::iterator it = goProps.begin(); it != goProps.end(); ++it)
+            {
+                PropertyRecord cur(it->toMap());
+                GameObject* go = GameObjectManager::getSingleton().createGameObject(
+                    cur.getProperty(GameObject::PROPERTY_BASE_CLASS).toString(),
+                    cur.getProperty(GameObject::PROPERTY_CLASS_ID).toInt());
+            }
+        }
+        else
+        {
+            LOG_WARNING("Scene", "Property '" + key + "' is no property of a scene.");
+        }
+    }
+    catch (WrongFormatException ex)
+    {
+        LOG_ERROR(
+            "Scene",
+            "property " + key + " has the wrong format");
+    }
+}
+
+PropertyKeys Scene::getAllPropertyKeys() const
+{
+    PropertyKeys keys;
+    keys.insert(Scene::PROPERTY_GAMEOBJECTS);
+    return keys;
+}
+
+}
\ No newline at end of file

Added: rl/trunk/engine/script/src/SceneLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneLoader.cpp	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/SceneLoader.cpp	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SceneLoader.h"
+
+#include <xercesc/dom/DOM.hpp>
+
+#include "Scene.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+
+Scene* SceneLoader::loadScene(Ogre::DataStreamPtr &data)
+{
+    initializeXml();
+
+    DOMDocument* doc = loadDocument(data);
+    DOMElement* root = doc->getDocumentElement();
+    Scene* scene = new Scene(getAttributeValueAsString(root, "name"));
+    
+    DOMNodeList* children = root->getChildNodes();
+    for (XMLSize_t i = 0; i < children->getLength(); ++i)
+    {
+        DOMNode* cur = children->item(i);
+        if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+        {
+            DOMElement* elem = static_cast<DOMElement*>(cur);
+            if (hasNodeName(elem, "map"))
+            {
+                scene->addMap(getAttributeValueAsStdString(elem, "file"));
+            }
+        }
+    }
+
+    shutdownXml();
+
+    return scene;
+}
+
+}

Added: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2008-05-31 09:21:36 UTC (rev 4390)
@@ -0,0 +1,125 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h" //precompiled header
+
+#include "SceneManager.h"
+
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "Scene.h"
+#include "SceneLoader.h"
+#include "UiSubsystem.h"
+
+rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
+
+namespace rl 
+{
+
+    SceneManager::SceneManager()
+        : Ogre::Singleton<SceneManager>(),
+          Ogre::ScriptLoader(),
+          mCurrentScene(NULL)
+    {
+        mScriptPatterns.push_back("*.rlscene");
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+    }
+
+    SceneManager::~SceneManager()
+    {
+        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
+        for (std::map<CeGuiString, Scene*>::iterator it = mScenes.begin();
+            it != mScenes.end(); ++it)
+        {
+            delete it->second;
+        }
+    }
+
+    void SceneManager::addScene(Scene* scene) 
+    {
+        mScenes[scene->getName()] = scene;
+    }
+
+    void SceneManager::loadScene(const CeGuiString& sceneName, bool saveCurrent)
+    {
+        if (mCurrentScene && sceneName == mCurrentScene->getName())
+        {
+            return;
+        }
+
+        Creature* activeChar = UiSubsystem::getSingleton().getActiveCharacter();
+
+        if (activeChar) {
+            CreatureControllerManager::getSingleton().detachController(
+                activeChar);
+            activeChar->setState(GOS_LOADED);
+        }
+
+        if (saveCurrent) 
+        {
+            mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
+        }
+
+        std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
+        if (itScene != mScenes.end())
+        {            
+            if (saveCurrent) 
+            {
+                itScene->second->load(false);
+                mCurrentScene = itScene->second;
+                std::map<Scene*, PropertyRecordPtr>::iterator itState 
+                    = mSceneStates.find(mCurrentScene);
+                if (itState != mSceneStates.end())
+                {
+                    mCurrentScene->setProperties(itState->second);
+                }
+            }
+            else 
+            {
+                itScene->second->load(true);
+                mCurrentScene = itScene->second;
+            }
+        }
+        else
+        {
+            LOG_ERROR("SceneManager", 
+                "Scene '" + sceneName + "' not found. Have you forgotten to define it in a .rlscene file?");
+        }
+
+        if (activeChar) 
+        {
+            UiSubsystem::getSingleton().setActiveCharacter(activeChar);
+        }
+    }
+
+    const Ogre::StringVector& SceneManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    void SceneManager::parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup)
+    {
+        SceneLoader* loader = new SceneLoader();
+        addScene(loader->loadScene(data));
+        delete loader;
+    }
+
+    Ogre::Real SceneManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+}

Modified: rl/trunk/engine/script/src/ScriptSubsystem.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptSubsystem.cpp	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/src/ScriptSubsystem.cpp	2008-05-31 09:21:36 UTC (rev 4390)
@@ -16,9 +16,13 @@
 #include "stdinc.h" //precompiled header
 
 #include "ScriptSubsystem.h"
+
+#include "SceneManager.h"
 #include "ScriptObjectMarker.h"
 #include "Logger.h"
 
+#include "SceneManager.h"
+
 using Ogre::Singleton;
 
 template<> rl::ScriptSubsystem* Singleton<rl::ScriptSubsystem>::ms_Singleton = NULL;
@@ -29,10 +33,12 @@
 		: mScriptObjectMarker(NULL), mTriggerFactory(NULL)
     {
         mScriptObjectMarker = new ScriptObjectMarker();
+        new SceneManager();
     }
 
     ScriptSubsystem::~ScriptSubsystem()
     {
+        delete SceneManager::getSingletonPtr();
         delete mScriptObjectMarker;
     }
 

Modified: rl/trunk/engine/script/swig/RlScript.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.swig	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/swig/RlScript.head.swig	2008-05-31 09:21:36 UTC (rev 4390)
@@ -16,9 +16,10 @@
 
 %{
 //----------- Includes - Script -----------
+#include "ContentLoader.h"
 #include "MapLoader.h"
+#include "SceneManager.h"
 #include "ScriptSubsystem.h"
 #include "TriggerFactory.h"
 #include "UnifiedFactory.h"
-#include "ContentLoader.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2008-05-31 09:17:47 UTC (rev 4389)
+++ rl/trunk/engine/script/swig/RlScript.swig	2008-05-31 09:21:36 UTC (rev 4390)
@@ -30,8 +30,10 @@
     class MapLoader : public rl::ContentLoader
     {
     public:
+        MapLoader();
+        MapLoader(const Ogre::String& resourceGroup);
         virtual ~MapLoader();
-        MapLoader(const Ogre::String& resourceGroup);
+
         void loadMap(const Ogre::String& mapresource, bool loadGameObjects = true);
         void loadContent();
         void unloadContent();
@@ -66,4 +68,13 @@
         virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
     };
 
-}
\ No newline at end of file
+    class SceneManager 
+    {
+    public:
+        static rl::SceneManager& getSingleton();
+        void loadScene(const rl::CeGuiString& name, bool saveCurrent = true);
+
+    private:
+        SceneManager();
+    };
+}



From blakharaz at mail.berlios.de  Sat May 31 11:22:15 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 31 May 2008 11:22:15 +0200
Subject: [Dsa-hl-svn] r4391 - rl/trunk/engine/common
Message-ID: <200805310922.m4V9MFWu005722@sheep.berlios.de>

Author: blakharaz
Date: 2008-05-31 11:22:14 +0200 (Sat, 31 May 2008)
New Revision: 4391

Modified:
   rl/trunk/engine/common/RlCommon2005.vcproj
Log:
Removed boost_thread.lib

Modified: rl/trunk/engine/common/RlCommon2005.vcproj
===================================================================
--- rl/trunk/engine/common/RlCommon2005.vcproj	2008-05-31 09:21:36 UTC (rev 4390)
+++ rl/trunk/engine/common/RlCommon2005.vcproj	2008-05-31 09:22:14 UTC (rev 4391)
@@ -69,7 +69,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib boost_thread-vc80-mt-gd-1_33_1.lib"
+				AdditionalDependencies="OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="2"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"
@@ -157,7 +157,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib boost_thread-vc80-mt-1_33_1.lib"
+				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="1"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"
@@ -243,7 +243,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib boost_thread-vc80-mt-1_33_1.lib"
+				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="1"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\Release&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"



